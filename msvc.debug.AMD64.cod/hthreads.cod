; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	hthreads_internal_init
PUBLIC	locks_cmd
PUBLIC	threads_cmd
PUBLIC	hthread_initialize_lock
PUBLIC	hthread_obtain_lock
PUBLIC	hthread_try_obtain_lock
PUBLIC	hthread_test_lock
PUBLIC	hthread_have_lock
PUBLIC	hthread_release_lock
PUBLIC	hthread_destroy_lock
PUBLIC	hthread_initialize_rwlock
PUBLIC	hthread_destroy_rwlock
PUBLIC	hthread_obtain_rdlock
PUBLIC	hthread_obtain_wrlock
PUBLIC	hthread_release_rwlock
PUBLIC	hthread_try_obtain_rdlock
PUBLIC	hthread_try_obtain_wrlock
PUBLIC	hthread_test_rdlock
PUBLIC	hthread_test_wrlock
PUBLIC	hthread_initialize_condition
PUBLIC	hthread_destroy_condition
PUBLIC	hthread_signal_condition
PUBLIC	hthread_broadcast_condition
PUBLIC	hthread_wait_condition
PUBLIC	hthread_timed_wait_condition
PUBLIC	hthread_initialize_join_attr
PUBLIC	hthread_initialize_detach_attr
PUBLIC	hthread_create_thread
PUBLIC	hthread_join_thread
PUBLIC	hthread_detach_thread
PUBLIC	hthread_exit_thread
PUBLIC	hthread_equal_threads
PUBLIC	hthread_set_thread_prio
PUBLIC	hthread_get_thread_prio
PUBLIC	hthread_report_deadlocks
PUBLIC	hthread_set_lock_name
PUBLIC	hthread_get_lock_name
PUBLIC	hthread_set_thread_name
PUBLIC	hthread_get_thread_name
EXTRN	__imp__stricmp:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp__aligned_free:PROC
EXTRN	__imp__aligned_malloc:PROC
EXTRN	__imp_qsort:PROC
EXTRN	__imp_exit:PROC
EXTRN	__imp_perror:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	fthreads_internal_init:PROC
EXTRN	fthread_getschedparam:PROC
EXTRN	fthread_setschedparam:PROC
EXTRN	fthread_get_priority_min:PROC
EXTRN	fthread_get_priority_max:PROC
EXTRN	fthread_attr_init:PROC
EXTRN	fthread_attr_setdetachstate:PROC
EXTRN	fthread_attr_setstacksize:PROC
EXTRN	fthread_join:PROC
EXTRN	fthread_detach:PROC
EXTRN	fthread_create:PROC
EXTRN	fthread_exit:PROC
EXTRN	fthread_self:PROC
EXTRN	fthread_equal:PROC
EXTRN	fthread_mutex_init:PROC
EXTRN	fthread_mutex_destroy:PROC
EXTRN	fthread_mutex_lock:PROC
EXTRN	fthread_mutex_trylock:PROC
EXTRN	fthread_mutex_unlock:PROC
EXTRN	fthread_cond_init:PROC
EXTRN	fthread_cond_destroy:PROC
EXTRN	fthread_cond_signal:PROC
EXTRN	fthread_cond_broadcast:PROC
EXTRN	fthread_cond_wait:PROC
EXTRN	fthread_cond_timedwait:PROC
EXTRN	fthread_mutexattr_init:PROC
EXTRN	fthread_mutexattr_destroy:PROC
EXTRN	fthread_mutexattr_settype:PROC
EXTRN	ptt_pthread_trace:PROC
EXTRN	strlcpy:PROC
EXTRN	timeval_subtract:PROC
EXTRN	trimloc:PROC
EXTRN	FormatTIMEVAL:PROC
EXTRN	w32_strerror:PROC
EXTRN	clock_gettime:PROC
EXTRN	gettimeofday:PROC
EXTRN	w32_set_thread_name:PROC
EXTRN	fwritemsg:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	pttclass:QWORD
EXTRN	__imp_sysblk:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
locklist DB	010H DUP (?)
listlock DQ	01H DUP (?)
lockcount DD	01H DUP (?)
threadlist DB	010H DUP (?)
	ALIGN	8

threadlock DQ	01H DUP (?)
threadcount DD	01H DUP (?)
inited	DB	01H DUP (?)
	ALIGN	4

$SG160090 DB	01H DUP (?)
	ALIGN	4

$SG160098 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$hthreads_internal_init DD imagerel $LN11
	DD	imagerel $LN11+637
	DD	imagerel $unwind$hthreads_internal_init
$pdata$locks_cmd DD imagerel $LN52
	DD	imagerel $LN52+2334
	DD	imagerel $unwind$locks_cmd
$pdata$threads_cmd DD imagerel $LN51
	DD	imagerel $LN51+2176
	DD	imagerel $unwind$threads_cmd
$pdata$hthread_initialize_lock DD imagerel $LN14
	DD	imagerel $LN14+664
	DD	imagerel $unwind$hthread_initialize_lock
$pdata$hthread_obtain_lock DD imagerel $LN16
	DD	imagerel $LN16+444
	DD	imagerel $unwind$hthread_obtain_lock
$pdata$hthread_try_obtain_lock DD imagerel $LN14
	DD	imagerel $LN14+353
	DD	imagerel $unwind$hthread_try_obtain_lock
$pdata$hthread_test_lock DD imagerel $LN4
	DD	imagerel $LN4+80
	DD	imagerel $unwind$hthread_test_lock
$pdata$hthread_have_lock DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$hthread_have_lock
$pdata$hthread_release_lock DD imagerel $LN8
	DD	imagerel $LN8+228
	DD	imagerel $unwind$hthread_release_lock
$pdata$hthread_destroy_lock DD imagerel $LN12
	DD	imagerel $LN12+374
	DD	imagerel $unwind$hthread_destroy_lock
$pdata$hthread_initialize_rwlock DD imagerel $LN17
	DD	imagerel $LN17+764
	DD	imagerel $unwind$hthread_initialize_rwlock
$pdata$hthread_destroy_rwlock DD imagerel $LN12
	DD	imagerel $LN12+374
	DD	imagerel $unwind$hthread_destroy_rwlock
$pdata$hthread_obtain_rdlock DD imagerel $LN14
	DD	imagerel $LN14+327
	DD	imagerel $unwind$hthread_obtain_rdlock
$pdata$hthread_obtain_wrlock DD imagerel $LN16
	DD	imagerel $LN16+444
	DD	imagerel $unwind$hthread_obtain_wrlock
$pdata$hthread_release_rwlock DD imagerel $LN8
	DD	imagerel $LN8+228
	DD	imagerel $unwind$hthread_release_rwlock
$pdata$hthread_try_obtain_rdlock DD imagerel $LN12
	DD	imagerel $LN12+248
	DD	imagerel $unwind$hthread_try_obtain_rdlock
$pdata$hthread_try_obtain_wrlock DD imagerel $LN13
	DD	imagerel $LN13+343
	DD	imagerel $unwind$hthread_try_obtain_wrlock
$pdata$hthread_test_rdlock DD imagerel $LN4
	DD	imagerel $LN4+80
	DD	imagerel $unwind$hthread_test_rdlock
$pdata$hthread_test_wrlock DD imagerel $LN4
	DD	imagerel $LN4+80
	DD	imagerel $unwind$hthread_test_wrlock
$pdata$hthread_initialize_condition DD imagerel $LN7
	DD	imagerel $LN7+112
	DD	imagerel $unwind$hthread_initialize_condition
$pdata$hthread_destroy_condition DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$hthread_destroy_condition
$pdata$hthread_signal_condition DD imagerel $LN7
	DD	imagerel $LN7+113
	DD	imagerel $unwind$hthread_signal_condition
$pdata$hthread_broadcast_condition DD imagerel $LN7
	DD	imagerel $LN7+113
	DD	imagerel $unwind$hthread_broadcast_condition
$pdata$hthread_wait_condition DD imagerel $LN12
	DD	imagerel $LN12+268
	DD	imagerel $unwind$hthread_wait_condition
$pdata$hthread_timed_wait_condition DD imagerel $LN12
	DD	imagerel $LN12+288
	DD	imagerel $unwind$hthread_timed_wait_condition
$pdata$hthread_initialize_join_attr DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$hthread_initialize_join_attr
$pdata$hthread_initialize_detach_attr DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$hthread_initialize_detach_attr
$pdata$hthread_create_thread DD imagerel $LN8
	DD	imagerel $LN8+492
	DD	imagerel $unwind$hthread_create_thread
$pdata$hthread_join_thread DD imagerel $LN15
	DD	imagerel $LN15+274
	DD	imagerel $unwind$hthread_join_thread
$pdata$hthread_detach_thread DD imagerel $LN11
	DD	imagerel $LN11+190
	DD	imagerel $unwind$hthread_detach_thread
$pdata$hthread_exit_thread DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$hthread_exit_thread
$pdata$hthread_equal_threads DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$hthread_equal_threads
$pdata$hthread_set_thread_prio DD imagerel $LN6
	DD	imagerel $LN6+295
	DD	imagerel $unwind$hthread_set_thread_prio
$pdata$hthread_get_thread_prio DD imagerel $LN6
	DD	imagerel $LN6+300
	DD	imagerel $unwind$hthread_get_thread_prio
$pdata$hthread_report_deadlocks DD imagerel $LN13
	DD	imagerel $LN13+287
	DD	imagerel $unwind$hthread_report_deadlocks
$pdata$hthread_set_lock_name DD imagerel $LN4
	DD	imagerel $LN4+103
	DD	imagerel $unwind$hthread_set_lock_name
$pdata$hthread_get_lock_name DD imagerel $LN5
	DD	imagerel $LN5+106
	DD	imagerel $unwind$hthread_get_lock_name
$pdata$hthread_set_thread_name DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$hthread_set_thread_name
$pdata$hthread_get_thread_name DD imagerel $LN5
	DD	imagerel $LN5+120
	DD	imagerel $unwind$hthread_get_thread_name
$pdata$calloc_aligned DD imagerel calloc_aligned
	DD	imagerel calloc_aligned+81
	DD	imagerel $unwind$calloc_aligned
$pdata$strcaseabbrev DD imagerel strcaseabbrev
	DD	imagerel strcaseabbrev+320
	DD	imagerel $unwind$strcaseabbrev
$pdata$host_tod DD imagerel host_tod
	DD	imagerel host_tod+168
	DD	imagerel $unwind$host_tod
$pdata$loglock DD imagerel loglock
	DD	imagerel loglock+938
	DD	imagerel $unwind$loglock
$pdata$hthreads_find_ILOCK_locked DD imagerel hthreads_find_ILOCK_locked
	DD	imagerel hthreads_find_ILOCK_locked+249
	DD	imagerel $unwind$hthreads_find_ILOCK_locked
$pdata$hthread_find_HTHREAD_locked DD imagerel hthread_find_HTHREAD_locked
	DD	imagerel hthread_find_HTHREAD_locked+262
	DD	imagerel $unwind$hthread_find_HTHREAD_locked
$pdata$hthread_find_HTHREAD DD imagerel hthread_find_HTHREAD
	DD	imagerel hthread_find_HTHREAD+58
	DD	imagerel $unwind$hthread_find_HTHREAD
$pdata$hthread_obtaining_lock DD imagerel hthread_obtaining_lock
	DD	imagerel hthread_obtaining_lock+114
	DD	imagerel $unwind$hthread_obtaining_lock
$pdata$hthread_lock_obtained DD imagerel hthread_lock_obtained
	DD	imagerel hthread_lock_obtained+49
	DD	imagerel $unwind$hthread_lock_obtained
$pdata$hthread_init_thread_attr DD imagerel hthread_init_thread_attr
	DD	imagerel hthread_init_thread_attr+87
	DD	imagerel $unwind$hthread_init_thread_attr
$pdata$hthread_list_abandoned_locks DD imagerel hthread_list_abandoned_locks
	DD	imagerel hthread_list_abandoned_locks+665
	DD	imagerel $unwind$hthread_list_abandoned_locks
$pdata$hthread_has_exited DD imagerel hthread_has_exited
	DD	imagerel hthread_has_exited+189
	DD	imagerel $unwind$hthread_has_exited
$pdata$hthread_func DD imagerel hthread_func
	DD	imagerel hthread_func+158
	DD	imagerel $unwind$hthread_func
$pdata$hthreads_copy_locks_list DD imagerel hthreads_copy_locks_list
	DD	imagerel hthreads_copy_locks_list+455
	DD	imagerel $unwind$hthreads_copy_locks_list
$pdata$lsortby_nam DD imagerel lsortby_nam
	DD	imagerel lsortby_nam+93
	DD	imagerel $unwind$lsortby_nam
$pdata$lsortby_ob_tim DD imagerel lsortby_ob_tim
	DD	imagerel lsortby_ob_tim+131
	DD	imagerel $unwind$lsortby_ob_tim
$pdata$lsortby_ob_tid DD imagerel lsortby_ob_tid
	DD	imagerel lsortby_ob_tid+127
	DD	imagerel $unwind$lsortby_ob_tid
$pdata$lsortby_ob_loc DD imagerel lsortby_ob_loc
	DD	imagerel lsortby_ob_loc+87
	DD	imagerel $unwind$lsortby_ob_loc
$pdata$hthreads_copy_threads_list DD imagerel hthreads_copy_threads_list
	DD	imagerel hthreads_copy_threads_list+477
	DD	imagerel $unwind$hthreads_copy_threads_list
$pdata$tsortby_nam DD imagerel tsortby_nam
	DD	imagerel tsortby_nam+43
	DD	imagerel $unwind$tsortby_nam
$pdata$tsortby_tim DD imagerel tsortby_tim
	DD	imagerel tsortby_tim+84
	DD	imagerel $unwind$tsortby_tim
$pdata$tsortby_tid DD imagerel tsortby_tid
	DD	imagerel tsortby_tid+83
	DD	imagerel $unwind$tsortby_tid
$pdata$tsortby_loc DD imagerel tsortby_loc
	DD	imagerel tsortby_loc+43
	DD	imagerel $unwind$tsortby_loc
$pdata$hthread_is_deadlocked_locked DD imagerel hthread_is_deadlocked_locked
	DD	imagerel hthread_is_deadlocked_locked+562
	DD	imagerel $unwind$hthread_is_deadlocked_locked
pdata	ENDS
_DATA	SEGMENT
$SG159093 DB	'already init''ed', 00H
$SG159095 DB	'max recursion', 00H
	ORG $+2
$SG159097 DB	'not owned', 00H
	ORG $+2
$SG159112 DB	'E', 00H
	ORG $+2
$SG159099 DB	'invalid argument', 00H
	ORG $+3
$SG159117 DB	'I', 00H
	ORG $+2
$SG159101 DB	'deadlock', 00H
	ORG $+3
$SG159124 DB	'I', 00H
	ORG $+2
$SG159103 DB	'not recoverable', 00H
$SG159105 DB	'owner dead', 00H
	ORG $+1
$SG159107 DB	'busy', 00H
	ORG $+3
$SG159205 DB	'null:0', 00H
	ORG $+1
$SG159705 DB	'E', 00H
	ORG $+2
$SG159109 DB	'timeout', 00H
$SG159111 DB	'(unknown)', 00H
	ORG $+2
$SG159239 DB	'null:0', 00H
	ORG $+1
$SG159709 DB	'E', 00H
	ORG $+2
$SG159113 DB	'HHC90013%s ''%s(%s)'' failed: rc=%d: %s; tid=%8.8x, loc='
	DB	'%s', 0aH, 00H
	ORG $+2
$SG159340 DB	'unlock', 00H
	ORG $+1
$SG159860 DB	'W', 00H
	ORG $+2
$SG159114 DB	'loglock', 00H
$SG159115 DB	'hthreads.c', 00H
	ORG $+1
$SG159878 DB	'W', 00H
	ORG $+2
$SG159118 DB	'HHC90028%s lock %s was already initialized at %s', 0aH, 00H
	ORG $+2
$SG159343 DB	'null:0', 00H
	ORG $+1
$SG159997 DB	'ALL', 00H
$SG159119 DB	'loglock', 00H
$SG159120 DB	'hthreads.c', 00H
	ORG $+1
$SG160014 DB	'TID', 00H
$SG159122 DB	'still held', 00H
	ORG $+1
$SG160026 DB	'TOD', 00H
$SG159123 DB	'obtained', 00H
	ORG $+3
$SG159361 DB	'null:0', 00H
	ORG $+1
$SG160032 DB	'LOC', 00H
$SG159125 DB	'HHC90014%s lock %s was %s by thread %8.8x at %s', 0aH, 00H
	ORG $+3
$SG159598 DB	'signal', 00H
	ORG $+1
$SG160040 DB	'I', 00H
	ORG $+2
$SG159126 DB	'loglock', 00H
$SG159127 DB	'hthreads.c', 00H
	ORG $+1
$SG160045 DB	'I', 00H
	ORG $+2
$SG159157 DB	'hthreads.c:206', 00H
	ORG $+1
$SG159158 DB	'main', 00H
	ORG $+3
$SG159159 DB	'Fatal error in hthreads_internal_init function', 00H
	ORG $+1
$SG159203 DB	'initialize lock', 00H
$SG159212 DB	'lock init', 00H
	ORG $+2
$SG159783 DB	'create', 00H
	ORG $+1
$SG160051 DB	'W', 00H
	ORG $+2
$SG159213 DB	'Fatal error in hthread_initialize_lock function', 00H
$SG159237 DB	'initialize rwlock', 00H
	ORG $+2
$SG160056 DB	'I', 00H
	ORG $+2
$SG159249 DB	'rwlock init', 00H
$SG160061 DB	'E', 00H
	ORG $+2
$SG159250 DB	'Fatal error in hthread_initialize_rwlock function', 00H
	ORG $+2
$SG160206 DB	'ALL', 00H
$SG159317 DB	'lock before', 00H
$SG160223 DB	'TID', 00H
$SG159321 DB	'lock after', 00H
	ORG $+1
$SG160232 DB	'TOD', 00H
$SG159323 DB	'obtain_lock', 00H
$SG160238 DB	'LOC', 00H
$SG159342 DB	'release_lock', 00H
	ORG $+3
$SG159358 DB	'rwunlock', 00H
	ORG $+3
$SG160017 DB	'OWNER', 00H
	ORG $+2
$SG160248 DB	'W', 00H
	ORG $+2
$SG159360 DB	'release_rwlock', 00H
	ORG $+1
$SG159379 DB	'destroy_lock', 00H
	ORG $+3
$SG159380 DB	'destroy_lock', 00H
	ORG $+3
$SG159399 DB	'destroy_rwlock', 00H
	ORG $+1
$SG159400 DB	'destroy_rwlock', 00H
	ORG $+1
$SG159423 DB	'try before', 00H
	ORG $+1
$SG160252 DB	'I', 00H
	ORG $+2
$SG159425 DB	'try after', 00H
	ORG $+2
$SG160258 DB	'W', 00H
	ORG $+2
$SG159427 DB	'try_obtain_lock', 00H
$SG159464 DB	'rdlock before', 00H
	ORG $+2
$SG159468 DB	'rdlock after', 00H
	ORG $+3
$SG159470 DB	'obtain_rdloc', 00H
	ORG $+3
$SG159495 DB	'wrlock before', 00H
	ORG $+2
$SG159499 DB	'wrlock after', 00H
	ORG $+3
$SG159501 DB	'obtain_wrlock', 00H
	ORG $+2
$SG159523 DB	'tryrd before', 00H
	ORG $+3
$SG159525 DB	'tryrd after', 00H
$SG160263 DB	'I', 00H
	ORG $+2
$SG159527 DB	'try_obtain_rdlock', 00H
	ORG $+2
$SG160268 DB	'E', 00H
	ORG $+2
$SG159549 DB	'trywr before', 00H
	ORG $+3
$SG159551 DB	'trywr after', 00H
	ORG $+4
$SG159553 DB	'try_obtain_wrlock', 00H
	ORG $+6
$SG159581 DB	'cond init', 00H
	ORG $+6
$SG159611 DB	'broadcast', 00H
	ORG $+6
$SG159631 DB	'wait before', 00H
	ORG $+4
$SG159633 DB	'wait after', 00H
	ORG $+5
$SG159635 DB	'wait_condition', 00H
	ORG $+1
$SG159657 DB	'tw before', 00H
	ORG $+6
$SG159659 DB	'tw after', 00H
	ORG $+7
$SG159661 DB	'timed_wait_condition', 00H
	ORG $+3
$SG159706 DB	'HHC90016%s Thread %8.8x (%s) abandoned at %s lock %s obt'
	DB	'ained on %s at %s', 0aH, 00H
	ORG $+5
$SG159707 DB	'hthread_list_abandoned_locks', 00H
	ORG $+3
$SG159708 DB	'hthreads.c', 00H
	ORG $+5
$SG159710 DB	'HHC90015%s Thread %8.8x (%s) abandoned lock %s obtained '
	DB	'on %s at %s', 0aH, 00H
	ORG $+3
$SG159711 DB	'hthread_list_abandoned_locks', 00H
	ORG $+3
$SG159712 DB	'hthreads.c', 00H
	ORG $+5
$SG159806 DB	'join before', 00H
	ORG $+4
$SG159808 DB	'join after', 00H
	ORG $+5
$SG159829 DB	'dtch before', 00H
	ORG $+4
$SG159831 DB	'dtch after', 00H
	ORG $+5
$SG159859 DB	'hthread_setschedparam()', 00H
$SG159861 DB	'HHC90020%s ''%s'' failed at loc=%s: rc=%d: %s', 0aH, 00H
	ORG $+3
$SG159862 DB	'hthread_set_thread_prio', 00H
$SG159863 DB	'hthreads.c', 00H
	ORG $+5
$SG159877 DB	'hthread_getschedparam()', 00H
$SG159879 DB	'HHC90020%s ''%s'' failed at loc=%s: rc=%d: %s', 0aH, 00H
	ORG $+3
$SG159880 DB	'hthread_get_thread_prio', 00H
$SG159881 DB	'hthreads.c', 00H
	ORG $+1
$SG160000 DB	'HELD', 00H
	ORG $+3
$SG160002 DB	'%x%c', 00H
	ORG $+3
$SG160008 DB	'SORT', 00H
	ORG $+3
$SG160011 DB	'NAME', 00H
	ORG $+3
$SG160020 DB	'WHEN', 00H
	ORG $+3
$SG160023 DB	'TIME', 00H
	ORG $+3
$SG160029 DB	'WHERE', 00H
	ORG $+6
$SG160041 DB	'HHC90017%s Lock %16.16llx (%s) created by %8.8x (%s) on '
	DB	'%s at %s', 0aH, 00H
	ORG $+6
$SG160042 DB	'locks_cmd', 00H
	ORG $+6
$SG160043 DB	'hthreads.c', 00H
	ORG $+5
$SG160052 DB	'HHC90019%s No locks found for thread %8.8x.', 0aH, 00H
	ORG $+3
$SG160057 DB	'HHC90018%s Total locks defined: %d', 0aH, 00H
	ORG $+4
$SG160046 DB	'HHC90029%s Lock %16.16llx (%s) obtained by %8.8x (%s) on'
	DB	' %s at %s', 0aH, 00H
	ORG $+5
$SG160047 DB	'locks_cmd', 00H
	ORG $+6
$SG160048 DB	'hthreads.c', 00H
	ORG $+5
$SG160053 DB	'locks_cmd', 00H
	ORG $+6
$SG160054 DB	'hthreads.c', 00H
	ORG $+5
$SG160058 DB	'locks_cmd', 00H
	ORG $+6
$SG160059 DB	'hthreads.c', 00H
	ORG $+5
$SG160209 DB	'WAITING', 00H
$SG160062 DB	'HHC02211%s Invalid argument(s). Type ''help %s'' for ass'
	DB	'istance.', 0aH, 00H
$SG160063 DB	'locks_cmd', 00H
	ORG $+6
$SG160064 DB	'hthreads.c', 00H
	ORG $+1
$SG160211 DB	'%x%c', 00H
	ORG $+3
$SG160217 DB	'SORT', 00H
	ORG $+3
$SG160220 DB	'NAME', 00H
	ORG $+3
$SG160226 DB	'WHEN', 00H
	ORG $+3
$SG160229 DB	'TIME', 00H
	ORG $+3
$SG160235 DB	'WHERE', 00H
	ORG $+6
$SG160249 DB	'HHC90023%s Thread %-15.15s tid=%8.8x waiting since %s at'
	DB	' %s for lock %s = %16.16llx', 0aH, 00H
	ORG $+3
$SG160250 DB	'threads_cmd', 00H
	ORG $+4
$SG160251 DB	'hthreads.c', 00H
	ORG $+5
$SG160254 DB	'threads_cmd', 00H
	ORG $+12
$SG160253 DB	'HHC90022%s Thread %-15.15s tid=%8.8x created on %s at %-'
	DB	'18.18s', 0aH, 00H
$SG160255 DB	'hthreads.c', 00H
	ORG $+5
$SG160259 DB	'HHC90026%s No threads found with tid %8.8x.', 0aH, 00H
	ORG $+3
$SG160260 DB	'threads_cmd', 00H
	ORG $+4
$SG160261 DB	'hthreads.c', 00H
	ORG $+5
$SG160264 DB	'HHC90027%s Total threads running: %d', 0aH, 00H
	ORG $+2
$SG160265 DB	'threads_cmd', 00H
	ORG $+4
$SG160266 DB	'hthreads.c', 00H
	ORG $+13
$SG160269 DB	'HHC02211%s Invalid argument(s). Type ''help %s'' for ass'
	DB	'istance.', 0aH, 00H
$SG160270 DB	'threads_cmd', 00H
	ORG $+4
$SG160271 DB	'hthreads.c', 00H
	ORG $+5
$SG160304 DB	'HHC90025%s Thread %s is stuck waiting for lock %s held b'
	DB	'y thread %s', 0aH, 00H
	ORG $+3
$SG160305 DB	'hthread_is_deadlocked_locked', 00H
	ORG $+3
$SG160306 DB	'hthreads.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:hthread_list_abandoned_locks
	DD	01aH
	DD	0281H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:host_tod
	DD	0eH
	DD	096H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:threads_cmd
	DD	01fH
	DD	0868H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:locks_cmd
	DD	01fH
	DD	0906H
voltbl	ENDS
xdata	SEGMENT
$unwind$hthreads_internal_init DD 010401H
	DD	0a204H
$unwind$locks_cmd DD 022719H
	DD	0290115H
	DD	imagerel __GSHandlerCheck
	DD	0130H
$unwind$threads_cmd DD 022719H
	DD	02b0115H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$hthread_initialize_lock DD 011301H
	DD	0c213H
$unwind$hthread_obtain_lock DD 010e01H
	DD	0c20eH
$unwind$hthread_try_obtain_lock DD 010e01H
	DD	0c20eH
$unwind$hthread_test_lock DD 010901H
	DD	06209H
$unwind$hthread_have_lock DD 010901H
	DD	06209H
$unwind$hthread_release_lock DD 010e01H
	DD	0a20eH
$unwind$hthread_destroy_lock DD 010e01H
	DD	0a20eH
$unwind$hthread_initialize_rwlock DD 011301H
	DD	0e213H
$unwind$hthread_destroy_rwlock DD 010e01H
	DD	0a20eH
$unwind$hthread_obtain_rdlock DD 010e01H
	DD	0c20eH
$unwind$hthread_obtain_wrlock DD 010e01H
	DD	0c20eH
$unwind$hthread_release_rwlock DD 010e01H
	DD	0a20eH
$unwind$hthread_try_obtain_rdlock DD 010e01H
	DD	0a20eH
$unwind$hthread_try_obtain_wrlock DD 010e01H
	DD	0c20eH
$unwind$hthread_test_rdlock DD 010901H
	DD	06209H
$unwind$hthread_test_wrlock DD 010901H
	DD	06209H
$unwind$hthread_initialize_condition DD 010e01H
	DD	0a20eH
$unwind$hthread_destroy_condition DD 010901H
	DD	06209H
$unwind$hthread_signal_condition DD 010e01H
	DD	0a20eH
$unwind$hthread_broadcast_condition DD 010e01H
	DD	0a20eH
$unwind$hthread_wait_condition DD 011301H
	DD	0a213H
$unwind$hthread_timed_wait_condition DD 011801H
	DD	0a218H
$unwind$hthread_initialize_join_attr DD 010901H
	DD	06209H
$unwind$hthread_initialize_detach_attr DD 010901H
	DD	06209H
$unwind$hthread_create_thread DD 011801H
	DD	0e218H
$unwind$hthread_join_thread DD 011201H
	DD	0c212H
$unwind$hthread_detach_thread DD 010d01H
	DD	0a20dH
$unwind$hthread_exit_thread DD 010e01H
	DD	0620eH
$unwind$hthread_equal_threads DD 010c01H
	DD	0620cH
$unwind$hthread_set_thread_prio DD 021501H
	DD	0700ef215H
$unwind$hthread_get_thread_prio DD 021101H
	DD	0700af211H
$unwind$hthread_report_deadlocks DD 010901H
	DD	0c209H
$unwind$hthread_set_lock_name DD 010e01H
	DD	0620eH
$unwind$hthread_get_lock_name DD 010901H
	DD	08209H
$unwind$hthread_set_thread_name DD 010d01H
	DD	0620dH
$unwind$hthread_get_thread_name DD 010d01H
	DD	0620dH
$unwind$calloc_aligned DD 020f01H
	DD	0700b520fH
$unwind$strcaseabbrev DD 011301H
	DD	08213H
$unwind$host_tod DD 011319H
	DD	0a204H
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$loglock DD 021a01H
	DD	015011aH
$unwind$hthreads_find_ILOCK_locked DD 010e01H
	DD	0620eH
$unwind$hthread_find_HTHREAD_locked DD 010d01H
	DD	0a20dH
$unwind$hthread_find_HTHREAD DD 010801H
	DD	06208H
$unwind$hthread_obtaining_lock DD 010e01H
	DD	0620eH
$unwind$hthread_lock_obtained DD 010401H
	DD	06204H
$unwind$hthread_init_thread_attr DD 010d01H
	DD	0620dH
$unwind$hthread_list_abandoned_locks DD 022219H
	DD	01d0110H
	DD	imagerel __GSHandlerCheck
	DD	0d8H
$unwind$hthread_has_exited DD 010d01H
	DD	0820dH
$unwind$hthread_func DD 010901H
	DD	0a209H
$unwind$hthreads_copy_locks_list DD 031001H
	DD	0700ca210H
	DD	0600bH
$unwind$lsortby_nam DD 010e01H
	DD	0620eH
$unwind$lsortby_ob_tim DD 010e01H
	DD	0620eH
$unwind$lsortby_ob_tid DD 010e01H
	DD	0620eH
$unwind$lsortby_ob_loc DD 010e01H
	DD	0620eH
$unwind$hthreads_copy_threads_list DD 031001H
	DD	0700ca210H
	DD	0600bH
$unwind$tsortby_nam DD 010e01H
	DD	0420eH
$unwind$tsortby_tim DD 010e01H
	DD	0220eH
$unwind$tsortby_tid DD 010e01H
	DD	0620eH
$unwind$tsortby_loc DD 010e01H
	DD	0420eH
$unwind$hthread_is_deadlocked_locked DD 021a01H
	DD	011011aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
ht$ = 80
ilk$ = 88
le$1 = 96
ht2$ = 104
now$ = 112
dur$ = 120
sev$ = 144
tid$ = 152
ht_anchor$ = 160
ilk_anchor$ = 168
hthread_is_deadlocked_locked PROC

; 1673 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1674 :     HTHREAD*  ht;
; 1675 :     HTHREAD*  ht2;
; 1676 :     ILOCK*    ilk;
; 1677 :     struct timeval  now;    // Current time of day.
; 1678 :     struct timeval  dur;    // How long we've been waiting for lock.
; 1679 : 
; 1680 :     // TECHNIQUE: starting with the requested thread, chase the lock
; 1681 :     // owner chain until we eventually reach a thread we have already
; 1682 :     // seen, at which point a deadlock has been detected.
; 1683 :     //
; 1684 :     // As each thread is chased, we set a footprint in order to know
; 1685 :     // whether or not we have seen this thread before.
; 1686 :     //
; 1687 :     // We stop our chase and immediately return false (no deadlock)
; 1688 :     // as soon as we reach a thread that is either not waiting for
; 1689 :     // any lock or is not waiting long enough for a lock.
; 1690 : 
; 1691 :     /* Start clean: remove all previous footprints */
; 1692 :     gettimeofday( &now, NULL );

  0001a	33 d2		 xor	 edx, edx
  0001c	48 8d 4c 24 70	 lea	 rcx, QWORD PTR now$[rsp]
  00021	e8 00 00 00 00	 call	 gettimeofday

; 1693 :     {
; 1694 :         LIST_ENTRY* le = ht_anchor->Flink;

  00026	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR ht_anchor$[rsp]
  0002e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00031	48 89 44 24 60	 mov	 QWORD PTR le$1[rsp], rax
$LN2@hthread_is:

; 1695 :         while (le != ht_anchor)

  00036	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR ht_anchor$[rsp]
  0003e	48 39 44 24 60	 cmp	 QWORD PTR le$1[rsp], rax
  00043	74 22		 je	 SHORT $LN3@hthread_is

; 1696 :         {
; 1697 :             ht = CONTAINING_RECORD( le, HTHREAD, ht_link );

  00045	48 8b 44 24 60	 mov	 rax, QWORD PTR le$1[rsp]
  0004a	48 89 44 24 50	 mov	 QWORD PTR ht$[rsp], rax

; 1698 :             ht->ht_footprint = false;

  0004f	48 8b 44 24 50	 mov	 rax, QWORD PTR ht$[rsp]
  00054	c6 40 48 00	 mov	 BYTE PTR [rax+72], 0

; 1699 :             le = le->Flink;

  00058	48 8b 44 24 60	 mov	 rax, QWORD PTR le$1[rsp]
  0005d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00060	48 89 44 24 60	 mov	 QWORD PTR le$1[rsp], rax

; 1700 :         }

  00065	eb cf		 jmp	 SHORT $LN2@hthread_is
$LN3@hthread_is:

; 1701 :     }
; 1702 : 
; 1703 :     /* Locate the thread entry for the thread we're interested in */
; 1704 :     if (!(ht = hthread_find_HTHREAD_locked( tid, ht_anchor )))

  00067	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR ht_anchor$[rsp]
  0006f	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tid$[rsp]
  00076	e8 00 00 00 00	 call	 hthread_find_HTHREAD_locked
  0007b	48 89 44 24 50	 mov	 QWORD PTR ht$[rsp], rax
  00080	48 83 7c 24 50
	00		 cmp	 QWORD PTR ht$[rsp], 0
  00086	75 07		 jne	 SHORT $LN6@hthread_is

; 1705 :         return false;

  00088	32 c0		 xor	 al, al
  0008a	e9 9b 01 00 00	 jmp	 $LN1@hthread_is
$LN6@hthread_is:
$LN4@hthread_is:

; 1706 : 
; 1707 :     /* Chase thread's lock chain until deadlock detected */
; 1708 :     while (!ht->ht_footprint)

  0008f	48 8b 44 24 50	 mov	 rax, QWORD PTR ht$[rsp]
  00094	0f b6 40 48	 movzx	 eax, BYTE PTR [rax+72]
  00098	85 c0		 test	 eax, eax
  0009a	0f 85 ba 00 00
	00		 jne	 $LN5@hthread_is

; 1709 :     {
; 1710 :         /* Remember that we've been here before */
; 1711 :         ht->ht_footprint = true;

  000a0	48 8b 44 24 50	 mov	 rax, QWORD PTR ht$[rsp]
  000a5	c6 40 48 01	 mov	 BYTE PTR [rax+72], 1

; 1712 : 
; 1713 :         /* Is this thread waiting for a lock? */
; 1714 :         if (!ht->ht_ob_lock)

  000a9	48 8b 44 24 50	 mov	 rax, QWORD PTR ht$[rsp]
  000ae	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  000b3	75 07		 jne	 SHORT $LN7@hthread_is

; 1715 :             return false;

  000b5	32 c0		 xor	 al, al
  000b7	e9 6e 01 00 00	 jmp	 $LN1@hthread_is
$LN7@hthread_is:

; 1716 : 
; 1717 :         /* Has thread been waiting for this lock for a long time? */
; 1718 :         timeval_subtract( &ht->ht_ob_time, &now, &dur );

  000bc	48 8b 44 24 50	 mov	 rax, QWORD PTR ht$[rsp]
  000c1	48 83 c0 30	 add	 rax, 48			; 00000030H
  000c5	4c 8d 44 24 78	 lea	 r8, QWORD PTR dur$[rsp]
  000ca	48 8d 54 24 70	 lea	 rdx, QWORD PTR now$[rsp]
  000cf	48 8b c8	 mov	 rcx, rax
  000d2	e8 00 00 00 00	 call	 timeval_subtract

; 1719 :         if (dur.tv_sec < DEADLOCK_SECONDS)

  000d7	83 7c 24 78 02	 cmp	 DWORD PTR dur$[rsp], 2
  000dc	7d 07		 jge	 SHORT $LN8@hthread_is

; 1720 :             return false;

  000de	32 c0		 xor	 al, al
  000e0	e9 45 01 00 00	 jmp	 $LN1@hthread_is
$LN8@hthread_is:

; 1721 : 
; 1722 :         /* Remember which thread is waiting to obtain a lock */
; 1723 :         ht2 = ht;

  000e5	48 8b 44 24 50	 mov	 rax, QWORD PTR ht$[rsp]
  000ea	48 89 44 24 68	 mov	 QWORD PTR ht2$[rsp], rax

; 1724 : 
; 1725 :         /* Locate the lock entry that this thread is waiting for */
; 1726 :         if (!(ilk = hthreads_find_ILOCK_locked( ht->ht_ob_lock, ilk_anchor )))

  000ef	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR ilk_anchor$[rsp]
  000f7	48 8b 44 24 50	 mov	 rax, QWORD PTR ht$[rsp]
  000fc	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00100	e8 00 00 00 00	 call	 hthreads_find_ILOCK_locked
  00105	48 89 44 24 58	 mov	 QWORD PTR ilk$[rsp], rax
  0010a	48 83 7c 24 58
	00		 cmp	 QWORD PTR ilk$[rsp], 0
  00110	75 07		 jne	 SHORT $LN9@hthread_is

; 1727 :             return false;

  00112	32 c0		 xor	 al, al
  00114	e9 11 01 00 00	 jmp	 $LN1@hthread_is
$LN9@hthread_is:

; 1728 : 
; 1729 :         /* Now switch over to chasing the lock chain for the thread
; 1730 :            currently owning the lock our thread is waiting to obtain.
; 1731 :         */
; 1732 :         if (!(ht = hthread_find_HTHREAD_locked( ilk->il_ob_tid, ht_anchor )))

  00119	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR ht_anchor$[rsp]
  00121	48 8b 44 24 58	 mov	 rax, QWORD PTR ilk$[rsp]
  00126	8b 48 30	 mov	 ecx, DWORD PTR [rax+48]
  00129	e8 00 00 00 00	 call	 hthread_find_HTHREAD_locked
  0012e	48 89 44 24 50	 mov	 QWORD PTR ht$[rsp], rax
  00133	48 83 7c 24 50
	00		 cmp	 QWORD PTR ht$[rsp], 0
  00139	75 07		 jne	 SHORT $LN10@hthread_is

; 1733 :             return false;

  0013b	32 c0		 xor	 al, al
  0013d	e9 e8 00 00 00	 jmp	 $LN1@hthread_is
$LN10@hthread_is:

; 1734 : 
; 1735 :         // PROGRAMMING NOTE: due to the way hthreads tracks lock
; 1736 :         // attempts and lock acquisition (wherein it first marks
; 1737 :         // that a lock is ATTEMPTING to be obtained (by setting
; 1738 :         // ht_ob_lock), then AFTERWARDS marking that it has now
; 1739 :         // been successfully obtained (by CLEARING ht_ob_lock),
; 1740 :         // (which are two separate function calls), it becomes
; 1741 :         // possible for our COPIED locks list to indicate that
; 1742 :         // our thread is still waiting for a lock (as indicated
; 1743 :         // by "ht_ob_lock" being non-NULL in our COPIED threads
; 1744 :         // list) that in fact (in actuality) has already been
; 1745 :         // successfully obtained! (as inciated by our COPIED
; 1746 :         // locks list entry indicating that it is in fact OUR
; 1747 :         // thread that currently owns the lock in question!)
; 1748 :         //
; 1749 :         // That is to say, our working COPIES of the live locks
; 1750 :         // and threads lists, by coincidence, was made AFTER
; 1751 :         // the lock's "il_ob_tid" field was set to our thread's
; 1752 :         // id (indicating our thread successfully obtained the
; 1753 :         // lock) but BEFORE the thread entry's "ht_ob_lock" field
; 1754 :         // could be cleared to indicate the thread was no longer
; 1755 :         // waiting for the lock.
; 1756 :         //
; 1757 :         // Therefore we must always check whether the thread that
; 1758 :         // currently owns the lock that we are supposedly waiting
; 1759 :         // to obtain happens to be OURSELVES or not! If the thread
; 1760 :         // that currently owns the lock is not ourselves, then fine,
; 1761 :         // we continue chasing our lock chain for this new thread.
; 1762 :         // But if the lock owner is in fact OURSELVES, there is
; 1763 :         // obviously is no deadlock so we immediately return false.
; 1764 : 
; 1765 :         if (ht == ht2)          // (lock owned by OURSELVES?!)

  00142	48 8b 44 24 68	 mov	 rax, QWORD PTR ht2$[rsp]
  00147	48 39 44 24 50	 cmp	 QWORD PTR ht$[rsp], rax
  0014c	75 07		 jne	 SHORT $LN11@hthread_is

; 1766 :             return false;       // (then obviously no deadlock!)

  0014e	32 c0		 xor	 al, al
  00150	e9 d5 00 00 00	 jmp	 $LN1@hthread_is
$LN11@hthread_is:

; 1767 :     }

  00155	e9 35 ff ff ff	 jmp	 $LN4@hthread_is
$LN5@hthread_is:

; 1768 : 
; 1769 :     /* Report the deadlock if asked to do so */
; 1770 :     if (sev)

  0015a	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR sev$[rsp], 0
  00163	0f 84 bf 00 00
	00		 je	 $LN12@hthread_is

; 1771 :     {
; 1772 :         ht  = hthread_find_HTHREAD_locked( tid, ht_anchor );

  00169	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR ht_anchor$[rsp]
  00171	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tid$[rsp]
  00178	e8 00 00 00 00	 call	 hthread_find_HTHREAD_locked
  0017d	48 89 44 24 50	 mov	 QWORD PTR ht$[rsp], rax

; 1773 :         ilk = hthreads_find_ILOCK_locked( ht->ht_ob_lock, ilk_anchor );

  00182	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR ilk_anchor$[rsp]
  0018a	48 8b 44 24 50	 mov	 rax, QWORD PTR ht$[rsp]
  0018f	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00193	e8 00 00 00 00	 call	 hthreads_find_ILOCK_locked
  00198	48 89 44 24 58	 mov	 QWORD PTR ilk$[rsp], rax

; 1774 :         ht2 = hthread_find_HTHREAD_locked( ilk->il_ob_tid, ht_anchor );

  0019d	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR ht_anchor$[rsp]
  001a5	48 8b 44 24 58	 mov	 rax, QWORD PTR ilk$[rsp]
  001aa	8b 48 30	 mov	 ecx, DWORD PTR [rax+48]
  001ad	e8 00 00 00 00	 call	 hthread_find_HTHREAD_locked
  001b2	48 89 44 24 68	 mov	 QWORD PTR ht2$[rsp], rax

; 1775 : 
; 1776 :         // "Thread %s is stuck waiting for lock %s held by thread %s"
; 1777 :         WRMSG( HHC90025, sev, ht->ht_name, ilk->il_name, ht2->ht_name );

  001b7	b9 01 00 00 00	 mov	 ecx, 1
  001bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001c2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ht2$[rsp]
  001c7	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  001cb	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001d0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ilk$[rsp]
  001d5	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  001d9	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001de	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ht$[rsp]
  001e3	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  001e7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001ec	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sev$[rsp]
  001f4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160304
  00200	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00205	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0020a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00210	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160305
  00217	ba f1 06 00 00	 mov	 edx, 1777		; 000006f1H
  0021c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160306
  00223	e8 00 00 00 00	 call	 fwritemsg
$LN12@hthread_is:

; 1778 :     }
; 1779 : 
; 1780 :     return true;

  00228	b0 01		 mov	 al, 1
$LN1@hthread_is:

; 1781 : }

  0022a	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00231	c3		 ret	 0
hthread_is_deadlocked_locked ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
p1$ = 48
p2$ = 56
tsortby_loc PROC

; 1539 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1540 :     return strcasecmp( p1->ht_cr_locat, p2->ht_cr_locat );

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR p2$[rsp]
  00013	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00017	48 8b 44 24 30	 mov	 rax, QWORD PTR p1$[rsp]
  0001c	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp

; 1541 : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
tsortby_loc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
tv75 = 32
p1$ = 64
p2$ = 72
tsortby_tid PROC

; 1534 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1535 :     return equal_threads( p1->ht_tid,             p2->ht_tid ) ? 0 :

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR p2$[rsp]
  00013	8b 50 20	 mov	 edx, DWORD PTR [rax+32]
  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR p1$[rsp]
  0001b	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  0001e	e8 00 00 00 00	 call	 hthread_equal_threads
  00023	85 c0		 test	 eax, eax
  00025	74 0b		 je	 SHORT $LN3@tsortby_ti
  00027	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR tv75[rsp], 0
  00030	eb 18		 jmp	 SHORT $LN4@tsortby_ti
$LN3@tsortby_ti:
  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR p1$[rsp]
  00037	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  0003a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR p2$[rsp]
  0003f	8b 49 20	 mov	 ecx, DWORD PTR [rcx+32]
  00042	48 2b c1	 sub	 rax, rcx
  00045	48 89 44 24 20	 mov	 QWORD PTR tv75[rsp], rax
$LN4@tsortby_ti:
  0004a	8b 44 24 20	 mov	 eax, DWORD PTR tv75[rsp]

; 1536 :               ((intptr_t) p1->ht_tid - (intptr_t) p2->ht_tid);
; 1537 : }

  0004e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00052	c3		 ret	 0
tsortby_tid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
tv73 = 0
p1$ = 32
p2$ = 40
tsortby_tim PROC

; 1528 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 1529 :     return     (p1->ht_cr_time.tv_sec    !=     p2->ht_cr_time.tv_sec)  ?

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR p1$[rsp]
  00013	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p2$[rsp]
  00018	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  0001b	39 48 18	 cmp	 DWORD PTR [rax+24], ecx
  0001e	74 17		 je	 SHORT $LN3@tsortby_ti
  00020	48 8b 44 24 20	 mov	 rax, QWORD PTR p1$[rsp]
  00025	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p2$[rsp]
  0002a	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  0002d	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00030	2b c1		 sub	 eax, ecx
  00032	89 04 24	 mov	 DWORD PTR tv73[rsp], eax
  00035	eb 15		 jmp	 SHORT $LN4@tsortby_ti
$LN3@tsortby_ti:
  00037	48 8b 44 24 20	 mov	 rax, QWORD PTR p1$[rsp]
  0003c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p2$[rsp]
  00041	8b 49 1c	 mov	 ecx, DWORD PTR [rcx+28]
  00044	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00047	2b c1		 sub	 eax, ecx
  00049	89 04 24	 mov	 DWORD PTR tv73[rsp], eax
$LN4@tsortby_ti:
  0004c	8b 04 24	 mov	 eax, DWORD PTR tv73[rsp]

; 1530 :         ((long) p1->ht_cr_time.tv_sec  - (long) p2->ht_cr_time.tv_sec)  :
; 1531 :         ((long) p1->ht_cr_time.tv_usec - (long) p2->ht_cr_time.tv_usec) ;
; 1532 : }

  0004f	48 83 c4 18	 add	 rsp, 24
  00053	c3		 ret	 0
tsortby_tim ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
p1$ = 48
p2$ = 56
tsortby_nam PROC

; 1524 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1525 :     return strcasecmp( p1->ht_name, p2->ht_name );

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR p2$[rsp]
  00013	48 8b 50 40	 mov	 rdx, QWORD PTR [rax+64]
  00017	48 8b 44 24 30	 mov	 rax, QWORD PTR p1$[rsp]
  0001c	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp

; 1526 : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
tsortby_nam ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
i$ = 32
k$ = 36
hta$ = 40
ple$ = 48
_EX_Head$1 = 56
ht$ = 64
_EX_Tail$2 = 72
ppHTHREAD$ = 112
anchor$ = 120
hthreads_copy_threads_list PROC

; 1485 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1486 :     HTHREAD*     ht;                /* Pointer to HTHREAD structure  */
; 1487 :     HTHREAD*     hta;               /* Pointer to HTHREAD array      */
; 1488 :     LIST_ENTRY*  ple;               /* Ptr to LIST_ENTRY structure   */
; 1489 :     int i, k;
; 1490 : 
; 1491 :     LockThreadsList();

  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:threadlock
  00017	e8 00 00 00 00	 call	 fthread_mutex_lock

; 1492 :     {
; 1493 :         /* Allocate private list array */
; 1494 :         if (!(*ppHTHREAD = hta = (HTHREAD*) malloc( threadcount * sizeof( HTHREAD ))))

  0001c	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR threadcount
  00023	48 6b c0 50	 imul	 rax, rax, 80		; 00000050H
  00027	48 8b c8	 mov	 rcx, rax
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00030	48 89 44 24 28	 mov	 QWORD PTR hta$[rsp], rax
  00035	48 8b 44 24 70	 mov	 rax, QWORD PTR ppHTHREAD$[rsp]
  0003a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR hta$[rsp]
  0003f	48 89 08	 mov	 QWORD PTR [rax], rcx
  00042	48 83 7c 24 28
	00		 cmp	 QWORD PTR hta$[rsp], 0
  00048	75 13		 jne	 SHORT $LN8@hthreads_c

; 1495 :         {
; 1496 :             UnlockThreadsList();

  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:threadlock
  00051	e8 00 00 00 00	 call	 fthread_mutex_unlock

; 1497 :             return 0;

  00056	33 c0		 xor	 eax, eax
  00058	e9 79 01 00 00	 jmp	 $LN1@hthreads_c
$LN8@hthreads_c:

; 1498 :         }
; 1499 : 
; 1500 :         /* Copy each live entry to the private array entry */
; 1501 :         for (i=0, ple = threadlist.Flink; ple != &threadlist; ple = ple->Flink, i++)

  0005d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR threadlist
  0006c	48 89 44 24 30	 mov	 QWORD PTR ple$[rsp], rax
  00071	eb 17		 jmp	 SHORT $LN4@hthreads_c
$LN2@hthreads_c:
  00073	48 8b 44 24 30	 mov	 rax, QWORD PTR ple$[rsp]
  00078	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007b	48 89 44 24 30	 mov	 QWORD PTR ple$[rsp], rax
  00080	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00084	ff c0		 inc	 eax
  00086	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@hthreads_c:
  0008a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:threadlist
  00091	48 39 44 24 30	 cmp	 QWORD PTR ple$[rsp], rax
  00096	74 62		 je	 SHORT $LN3@hthreads_c

; 1502 :         {
; 1503 :             ht = CONTAINING_RECORD( ple, HTHREAD, ht_link );

  00098	48 8b 44 24 30	 mov	 rax, QWORD PTR ple$[rsp]
  0009d	48 89 44 24 40	 mov	 QWORD PTR ht$[rsp], rax

; 1504 :             memcpy( &hta[i], ht, sizeof( HTHREAD ));

  000a2	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000a7	48 6b c0 50	 imul	 rax, rax, 80		; 00000050H
  000ab	48 8b 4c 24 28	 mov	 rcx, QWORD PTR hta$[rsp]
  000b0	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  000b4	48 8b 74 24 40	 mov	 rsi, QWORD PTR ht$[rsp]
  000b9	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  000be	f3 a4		 rep movsb

; 1505 :             hta[i].ht_name = strdup( ht->ht_name );

  000c0	48 8b 44 24 40	 mov	 rax, QWORD PTR ht$[rsp]
  000c5	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  000cf	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000d4	48 6b c9 50	 imul	 rcx, rcx, 80		; 00000050H
  000d8	48 8b 54 24 28	 mov	 rdx, QWORD PTR hta$[rsp]
  000dd	48 89 44 0a 40	 mov	 QWORD PTR [rdx+rcx+64], rax

; 1506 :             hta[i].ht_footprint = false;

  000e2	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000e7	48 6b c0 50	 imul	 rax, rax, 80		; 00000050H
  000eb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR hta$[rsp]
  000f0	c6 44 01 48 00	 mov	 BYTE PTR [rcx+rax+72], 0

; 1507 :         }

  000f5	e9 79 ff ff ff	 jmp	 $LN2@hthreads_c
$LN3@hthreads_c:

; 1508 : 
; 1509 :         k = threadcount;  /* Save how entries there are */

  000fa	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR threadcount
  00100	89 44 24 24	 mov	 DWORD PTR k$[rsp], eax

; 1510 :     }
; 1511 :     UnlockThreadsList();

  00104	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:threadlock
  0010b	e8 00 00 00 00	 call	 fthread_mutex_unlock

; 1512 : 
; 1513 :     /* Chain their private array copy */
; 1514 :     InitializeListHead( anchor );

  00110	48 8b 44 24 78	 mov	 rax, QWORD PTR anchor$[rsp]
  00115	48 8b 4c 24 78	 mov	 rcx, QWORD PTR anchor$[rsp]
  0011a	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  0011e	48 8b 44 24 78	 mov	 rax, QWORD PTR anchor$[rsp]
  00123	48 8b 4c 24 78	 mov	 rcx, QWORD PTR anchor$[rsp]
  00128	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1515 :     for (i=0; i < k; i++)

  0012b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00133	eb 0a		 jmp	 SHORT $LN7@hthreads_c
$LN5@hthreads_c:
  00135	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00139	ff c0		 inc	 eax
  0013b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@hthreads_c:
  0013f	8b 44 24 24	 mov	 eax, DWORD PTR k$[rsp]
  00143	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00147	0f 8d 85 00 00
	00		 jge	 $LN6@hthreads_c

; 1516 :         InsertListTail( anchor, &hta[i].ht_link );

  0014d	48 8b 44 24 78	 mov	 rax, QWORD PTR anchor$[rsp]
  00152	48 89 44 24 38	 mov	 QWORD PTR _EX_Head$1[rsp], rax
  00157	48 8b 44 24 38	 mov	 rax, QWORD PTR _EX_Head$1[rsp]
  0015c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00160	48 89 44 24 48	 mov	 QWORD PTR _EX_Tail$2[rsp], rax
  00165	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0016a	48 6b c0 50	 imul	 rax, rax, 80		; 00000050H
  0016e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR hta$[rsp]
  00173	48 8b 54 24 38	 mov	 rdx, QWORD PTR _EX_Head$1[rsp]
  00178	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  0017c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00181	48 6b c0 50	 imul	 rax, rax, 80		; 00000050H
  00185	48 8b 4c 24 28	 mov	 rcx, QWORD PTR hta$[rsp]
  0018a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _EX_Tail$2[rsp]
  0018f	48 89 54 01 08	 mov	 QWORD PTR [rcx+rax+8], rdx
  00194	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00199	48 6b c0 50	 imul	 rax, rax, 80		; 00000050H
  0019d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR hta$[rsp]
  001a2	48 03 c8	 add	 rcx, rax
  001a5	48 8b c1	 mov	 rax, rcx
  001a8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _EX_Tail$2[rsp]
  001ad	48 89 01	 mov	 QWORD PTR [rcx], rax
  001b0	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  001b5	48 6b c0 50	 imul	 rax, rax, 80		; 00000050H
  001b9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR hta$[rsp]
  001be	48 03 c8	 add	 rcx, rax
  001c1	48 8b c1	 mov	 rax, rcx
  001c4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _EX_Head$1[rsp]
  001c9	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  001cd	e9 63 ff ff ff	 jmp	 $LN5@hthreads_c
$LN6@hthreads_c:

; 1517 :     return k;

  001d2	8b 44 24 24	 mov	 eax, DWORD PTR k$[rsp]
$LN1@hthreads_c:

; 1518 : }

  001d6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001da	5f		 pop	 rdi
  001db	5e		 pop	 rsi
  001dc	c3		 ret	 0
hthreads_copy_threads_list ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 32
tv73 = 36
p1$ = 64
p2$ = 72
lsortby_ob_loc PROC

; 1272 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1273 :     int rc = strcasecmp( p1->il_ob_locat, p2->il_ob_locat );

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR p2$[rsp]
  00013	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  00017	48 8b 44 24 40	 mov	 rax, QWORD PTR p1$[rsp]
  0001c	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00026	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1274 :     return rc == 0 ? lsortby_nam( p1, p2 ) : rc;

  0002a	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  0002f	75 15		 jne	 SHORT $LN3@lsortby_ob
  00031	48 8b 54 24 48	 mov	 rdx, QWORD PTR p2$[rsp]
  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR p1$[rsp]
  0003b	e8 00 00 00 00	 call	 lsortby_nam
  00040	89 44 24 24	 mov	 DWORD PTR tv73[rsp], eax
  00044	eb 08		 jmp	 SHORT $LN4@lsortby_ob
$LN3@lsortby_ob:
  00046	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  0004a	89 44 24 24	 mov	 DWORD PTR tv73[rsp], eax
$LN4@lsortby_ob:
  0004e	8b 44 24 24	 mov	 eax, DWORD PTR tv73[rsp]

; 1275 : }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	c3		 ret	 0
lsortby_ob_loc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 32
tv81 = 36
tv75 = 40
p1$ = 64
p2$ = 72
lsortby_ob_tid PROC

; 1266 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1267 :     int rc = equal_threads( p1->il_ob_tid,             p2->il_ob_tid ) ? 0 :

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR p2$[rsp]
  00013	8b 50 30	 mov	 edx, DWORD PTR [rax+48]
  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR p1$[rsp]
  0001b	8b 48 30	 mov	 ecx, DWORD PTR [rax+48]
  0001e	e8 00 00 00 00	 call	 hthread_equal_threads
  00023	85 c0		 test	 eax, eax
  00025	74 0b		 je	 SHORT $LN3@lsortby_ob
  00027	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tv75[rsp], 0
  00030	eb 18		 jmp	 SHORT $LN4@lsortby_ob
$LN3@lsortby_ob:
  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR p1$[rsp]
  00037	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0003a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR p2$[rsp]
  0003f	8b 49 30	 mov	 ecx, DWORD PTR [rcx+48]
  00042	48 2b c1	 sub	 rax, rcx
  00045	48 89 44 24 28	 mov	 QWORD PTR tv75[rsp], rax
$LN4@lsortby_ob:
  0004a	8b 44 24 28	 mov	 eax, DWORD PTR tv75[rsp]
  0004e	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1268 :                 ((intptr_t) p1->il_ob_tid - (intptr_t) p2->il_ob_tid);
; 1269 :     return rc == 0 ? lsortby_nam( p1, p2 ) : rc;

  00052	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00057	75 15		 jne	 SHORT $LN5@lsortby_ob
  00059	48 8b 54 24 48	 mov	 rdx, QWORD PTR p2$[rsp]
  0005e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR p1$[rsp]
  00063	e8 00 00 00 00	 call	 lsortby_nam
  00068	89 44 24 24	 mov	 DWORD PTR tv81[rsp], eax
  0006c	eb 08		 jmp	 SHORT $LN6@lsortby_ob
$LN5@lsortby_ob:
  0006e	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  00072	89 44 24 24	 mov	 DWORD PTR tv81[rsp], eax
$LN6@lsortby_ob:
  00076	8b 44 24 24	 mov	 eax, DWORD PTR tv81[rsp]

; 1270 : }

  0007a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007e	c3		 ret	 0
lsortby_ob_tid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
tv73 = 32
rc$ = 36
tv78 = 40
p1$ = 64
p2$ = 72
lsortby_ob_tim PROC

; 1259 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1260 :     int rc  =  (p1->il_ob_time.tv_sec    !=     p2->il_ob_time.tv_sec)  ?

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR p1$[rsp]
  00013	48 8b 4c 24 48	 mov	 rcx, QWORD PTR p2$[rsp]
  00018	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0001b	39 48 28	 cmp	 DWORD PTR [rax+40], ecx
  0001e	74 18		 je	 SHORT $LN3@lsortby_ob
  00020	48 8b 44 24 40	 mov	 rax, QWORD PTR p1$[rsp]
  00025	48 8b 4c 24 48	 mov	 rcx, QWORD PTR p2$[rsp]
  0002a	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0002d	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00030	2b c1		 sub	 eax, ecx
  00032	89 44 24 20	 mov	 DWORD PTR tv73[rsp], eax
  00036	eb 16		 jmp	 SHORT $LN4@lsortby_ob
$LN3@lsortby_ob:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR p1$[rsp]
  0003d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR p2$[rsp]
  00042	8b 49 2c	 mov	 ecx, DWORD PTR [rcx+44]
  00045	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  00048	2b c1		 sub	 eax, ecx
  0004a	89 44 24 20	 mov	 DWORD PTR tv73[rsp], eax
$LN4@lsortby_ob:
  0004e	8b 44 24 20	 mov	 eax, DWORD PTR tv73[rsp]
  00052	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 1261 :         ((long) p1->il_ob_time.tv_sec  - (long) p2->il_ob_time.tv_sec)  :
; 1262 :         ((long) p1->il_ob_time.tv_usec - (long) p2->il_ob_time.tv_usec) ;
; 1263 :     return rc == 0 ? lsortby_nam( p1, p2 ) : rc;

  00056	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  0005b	75 15		 jne	 SHORT $LN5@lsortby_ob
  0005d	48 8b 54 24 48	 mov	 rdx, QWORD PTR p2$[rsp]
  00062	48 8b 4c 24 40	 mov	 rcx, QWORD PTR p1$[rsp]
  00067	e8 00 00 00 00	 call	 lsortby_nam
  0006c	89 44 24 28	 mov	 DWORD PTR tv78[rsp], eax
  00070	eb 08		 jmp	 SHORT $LN6@lsortby_ob
$LN5@lsortby_ob:
  00072	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
  00076	89 44 24 28	 mov	 DWORD PTR tv78[rsp], eax
$LN6@lsortby_ob:
  0007a	8b 44 24 28	 mov	 eax, DWORD PTR tv78[rsp]

; 1264 : }

  0007e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00082	c3		 ret	 0
lsortby_ob_tim ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 32
tv74 = 36
p1$ = 64
p2$ = 72
lsortby_nam PROC

; 1254 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1255 :     int rc = strcasecmp( p1->il_name, p2->il_name );

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR p2$[rsp]
  00013	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  00017	48 8b 44 24 40	 mov	 rax, QWORD PTR p1$[rsp]
  0001c	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00026	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1256 :     return rc == 0 ? ((int)((S64)p1->il_addr - (S64)p2->il_addr)) : rc;

  0002a	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  0002f	75 1b		 jne	 SHORT $LN3@lsortby_na
  00031	48 8b 44 24 40	 mov	 rax, QWORD PTR p1$[rsp]
  00036	48 8b 4c 24 48	 mov	 rcx, QWORD PTR p2$[rsp]
  0003b	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0003f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00043	48 2b c1	 sub	 rax, rcx
  00046	89 44 24 24	 mov	 DWORD PTR tv74[rsp], eax
  0004a	eb 08		 jmp	 SHORT $LN4@lsortby_na
$LN3@lsortby_na:
  0004c	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  00050	89 44 24 24	 mov	 DWORD PTR tv74[rsp], eax
$LN4@lsortby_na:
  00054	8b 44 24 24	 mov	 eax, DWORD PTR tv74[rsp]

; 1257 : }

  00058	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005c	c3		 ret	 0
lsortby_nam ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
i$ = 32
k$ = 36
ilka$ = 40
ple$ = 48
_EX_Head$1 = 56
ilk$ = 64
_EX_Tail$2 = 72
ppILOCK$ = 112
anchor$ = 120
hthreads_copy_locks_list PROC

; 1216 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1217 :     ILOCK*       ilk;               /* Pointer to ILOCK structure    */
; 1218 :     ILOCK*       ilka;              /* Pointer to ILOCK array        */
; 1219 :     LIST_ENTRY*  ple;               /* Ptr to LIST_ENTRY structure   */
; 1220 :     int i, k;
; 1221 : 
; 1222 :     LockLocksList();

  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:listlock
  00017	e8 00 00 00 00	 call	 fthread_mutex_lock

; 1223 :     {
; 1224 :         /* Allocate private list array */
; 1225 :         if (!(*ppILOCK = ilka = (ILOCK*) malloc( lockcount * sizeof( ILOCK ))))

  0001c	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR lockcount
  00023	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00027	48 8b c8	 mov	 rcx, rax
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00030	48 89 44 24 28	 mov	 QWORD PTR ilka$[rsp], rax
  00035	48 8b 44 24 70	 mov	 rax, QWORD PTR ppILOCK$[rsp]
  0003a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ilka$[rsp]
  0003f	48 89 08	 mov	 QWORD PTR [rax], rcx
  00042	48 83 7c 24 28
	00		 cmp	 QWORD PTR ilka$[rsp], 0
  00048	75 13		 jne	 SHORT $LN8@hthreads_c

; 1226 :         {
; 1227 :             UnlockLocksList();

  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:listlock
  00051	e8 00 00 00 00	 call	 fthread_mutex_unlock

; 1228 :             return 0;

  00056	33 c0		 xor	 eax, eax
  00058	e9 63 01 00 00	 jmp	 $LN1@hthreads_c
$LN8@hthreads_c:

; 1229 :         }
; 1230 : 
; 1231 :         /* Copy each live entry to the private array entry */
; 1232 :         for (i=0, ple = locklist.Flink; ple != &locklist; ple = ple->Flink, i++)

  0005d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR locklist
  0006c	48 89 44 24 30	 mov	 QWORD PTR ple$[rsp], rax
  00071	eb 17		 jmp	 SHORT $LN4@hthreads_c
$LN2@hthreads_c:
  00073	48 8b 44 24 30	 mov	 rax, QWORD PTR ple$[rsp]
  00078	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007b	48 89 44 24 30	 mov	 QWORD PTR ple$[rsp], rax
  00080	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00084	ff c0		 inc	 eax
  00086	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@hthreads_c:
  0008a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:locklist
  00091	48 39 44 24 30	 cmp	 QWORD PTR ple$[rsp], rax
  00096	74 4c		 je	 SHORT $LN3@hthreads_c

; 1233 :         {
; 1234 :             ilk = CONTAINING_RECORD( ple, ILOCK, il_link );

  00098	48 8b 44 24 30	 mov	 rax, QWORD PTR ple$[rsp]
  0009d	48 89 44 24 40	 mov	 QWORD PTR ilk$[rsp], rax

; 1235 :             memcpy( &ilka[i], ilk, sizeof( ILOCK ));

  000a2	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000a7	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000ab	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ilka$[rsp]
  000b0	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  000b4	48 8b 74 24 40	 mov	 rsi, QWORD PTR ilk$[rsp]
  000b9	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  000be	f3 a4		 rep movsb

; 1236 :             ilka[i].il_name = strdup( ilk->il_name );

  000c0	48 8b 44 24 40	 mov	 rax, QWORD PTR ilk$[rsp]
  000c5	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  000cf	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000d4	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  000d8	48 8b 54 24 28	 mov	 rdx, QWORD PTR ilka$[rsp]
  000dd	48 89 44 0a 18	 mov	 QWORD PTR [rdx+rcx+24], rax

; 1237 :         }

  000e2	eb 8f		 jmp	 SHORT $LN2@hthreads_c
$LN3@hthreads_c:

; 1238 : 
; 1239 :         k = lockcount;  /* Save how entries there are */

  000e4	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR lockcount
  000ea	89 44 24 24	 mov	 DWORD PTR k$[rsp], eax

; 1240 :     }
; 1241 :     UnlockLocksList();

  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:listlock
  000f5	e8 00 00 00 00	 call	 fthread_mutex_unlock

; 1242 : 
; 1243 :     /* Chain their private array copy */
; 1244 :     InitializeListHead( anchor );

  000fa	48 8b 44 24 78	 mov	 rax, QWORD PTR anchor$[rsp]
  000ff	48 8b 4c 24 78	 mov	 rcx, QWORD PTR anchor$[rsp]
  00104	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00108	48 8b 44 24 78	 mov	 rax, QWORD PTR anchor$[rsp]
  0010d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR anchor$[rsp]
  00112	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1245 :     for (i=0; i < k; i++)

  00115	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0011d	eb 0a		 jmp	 SHORT $LN7@hthreads_c
$LN5@hthreads_c:
  0011f	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00123	ff c0		 inc	 eax
  00125	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@hthreads_c:
  00129	8b 44 24 24	 mov	 eax, DWORD PTR k$[rsp]
  0012d	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00131	0f 8d 85 00 00
	00		 jge	 $LN6@hthreads_c

; 1246 :         InsertListTail( anchor, &ilka[i].il_link );

  00137	48 8b 44 24 78	 mov	 rax, QWORD PTR anchor$[rsp]
  0013c	48 89 44 24 38	 mov	 QWORD PTR _EX_Head$1[rsp], rax
  00141	48 8b 44 24 38	 mov	 rax, QWORD PTR _EX_Head$1[rsp]
  00146	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0014a	48 89 44 24 48	 mov	 QWORD PTR _EX_Tail$2[rsp], rax
  0014f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00154	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00158	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ilka$[rsp]
  0015d	48 8b 54 24 38	 mov	 rdx, QWORD PTR _EX_Head$1[rsp]
  00162	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  00166	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0016b	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0016f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ilka$[rsp]
  00174	48 8b 54 24 48	 mov	 rdx, QWORD PTR _EX_Tail$2[rsp]
  00179	48 89 54 01 08	 mov	 QWORD PTR [rcx+rax+8], rdx
  0017e	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00183	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00187	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ilka$[rsp]
  0018c	48 03 c8	 add	 rcx, rax
  0018f	48 8b c1	 mov	 rax, rcx
  00192	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _EX_Tail$2[rsp]
  00197	48 89 01	 mov	 QWORD PTR [rcx], rax
  0019a	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0019f	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  001a3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ilka$[rsp]
  001a8	48 03 c8	 add	 rcx, rax
  001ab	48 8b c1	 mov	 rax, rcx
  001ae	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _EX_Head$1[rsp]
  001b3	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  001b7	e9 63 ff ff ff	 jmp	 $LN5@hthreads_c
$LN6@hthreads_c:

; 1247 :     return k;

  001bc	8b 44 24 24	 mov	 eax, DWORD PTR k$[rsp]
$LN1@hthreads_c:

; 1248 : }

  001c0	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001c4	5f		 pop	 rdi
  001c5	5e		 pop	 rsi
  001c6	c3		 ret	 0
hthreads_copy_locks_list ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
tid$ = 32
name$ = 40
arg$ = 48
pfn$ = 56
rc$ = 64
arg2$ = 96
hthread_func PROC

; 1047 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1048 :     THREAD_FUNC*  pfn  = (THREAD_FUNC*) *((void**)arg2+0);

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR arg2$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 44 24 38	 mov	 QWORD PTR pfn$[rsp], rax

; 1049 :     void*         arg  = (void*)        *((void**)arg2+1);

  00016	48 8b 44 24 60	 mov	 rax, QWORD PTR arg2$[rsp]
  0001b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001f	48 89 44 24 30	 mov	 QWORD PTR arg$[rsp], rax

; 1050 :     const char*   name = (const char*)  *((void**)arg2+2);

  00024	48 8b 44 24 60	 mov	 rax, QWORD PTR arg2$[rsp]
  00029	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002d	48 89 44 24 28	 mov	 QWORD PTR name$[rsp], rax

; 1051 :     TID           tid  = hthread_self();

  00032	e8 00 00 00 00	 call	 fthread_self
  00037	89 44 24 20	 mov	 DWORD PTR tid$[rsp], eax

; 1052 :     void*         rc;
; 1053 :     free( arg2 );

  0003b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR arg2$[rsp]
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1054 :     if (name)

  00046	48 83 7c 24 28
	00		 cmp	 QWORD PTR name$[rsp], 0
  0004c	74 2d		 je	 SHORT $LN5@hthread_fu
$LN4@hthread_fu:

; 1055 :     {
; 1056 :         SET_THREAD_NAME_ID( tid, name );

  0004e	48 8b 54 24 28	 mov	 rdx, QWORD PTR name$[rsp]
  00053	8b 4c 24 20	 mov	 ecx, DWORD PTR tid$[rsp]
  00057	e8 00 00 00 00	 call	 w32_set_thread_name
  0005c	48 8b 54 24 28	 mov	 rdx, QWORD PTR name$[rsp]
  00061	8b 4c 24 20	 mov	 ecx, DWORD PTR tid$[rsp]
  00065	e8 00 00 00 00	 call	 hthread_set_thread_name
  0006a	33 c0		 xor	 eax, eax
  0006c	85 c0		 test	 eax, eax
  0006e	75 de		 jne	 SHORT $LN4@hthread_fu

; 1057 :         free( name );

  00070	48 8b 4c 24 28	 mov	 rcx, QWORD PTR name$[rsp]
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@hthread_fu:

; 1058 :     }
; 1059 :     rc = pfn( arg );

  0007b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR arg$[rsp]
  00080	ff 54 24 38	 call	 QWORD PTR pfn$[rsp]
  00084	48 89 44 24 40	 mov	 QWORD PTR rc$[rsp], rax

; 1060 :     hthread_has_exited( tid, NULL );

  00089	33 d2		 xor	 edx, edx
  0008b	8b 4c 24 20	 mov	 ecx, DWORD PTR tid$[rsp]
  0008f	e8 00 00 00 00	 call	 hthread_has_exited

; 1061 :     return rc;

  00094	48 8b 44 24 40	 mov	 rax, QWORD PTR rc$[rsp]

; 1062 : }

  00099	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0009d	c3		 ret	 0
hthread_func ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
ht$1 = 32
_EX_Flink$2 = 40
_EX_Blink$3 = 48
tid$ = 80
exit_loc$ = 88
hthread_has_exited PROC

; 1025 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1026 :     hthread_list_abandoned_locks( tid, exit_loc );

  0000d	48 8b 54 24 58	 mov	 rdx, QWORD PTR exit_loc$[rsp]
  00012	8b 4c 24 50	 mov	 ecx, DWORD PTR tid$[rsp]
  00016	e8 00 00 00 00	 call	 hthread_list_abandoned_locks

; 1027 : 
; 1028 :     LockThreadsList();

  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:threadlock
  00022	e8 00 00 00 00	 call	 fthread_mutex_lock

; 1029 :     {
; 1030 :         HTHREAD* ht = hthread_find_HTHREAD_locked( tid, NULL );

  00027	33 d2		 xor	 edx, edx
  00029	8b 4c 24 50	 mov	 ecx, DWORD PTR tid$[rsp]
  0002d	e8 00 00 00 00	 call	 hthread_find_HTHREAD_locked
  00032	48 89 44 24 20	 mov	 QWORD PTR ht$1[rsp], rax

; 1031 :         if (ht)

  00037	48 83 7c 24 20
	00		 cmp	 QWORD PTR ht$1[rsp], 0
  0003d	74 6d		 je	 SHORT $LN2@hthread_ha

; 1032 :         {
; 1033 :             RemoveListEntry( &ht->ht_link );

  0003f	48 8b 44 24 20	 mov	 rax, QWORD PTR ht$1[rsp]
  00044	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00047	48 89 44 24 28	 mov	 QWORD PTR _EX_Flink$2[rsp], rax
  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR ht$1[rsp]
  00051	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00055	48 89 44 24 30	 mov	 QWORD PTR _EX_Blink$3[rsp], rax
  0005a	48 8b 44 24 30	 mov	 rax, QWORD PTR _EX_Blink$3[rsp]
  0005f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _EX_Flink$2[rsp]
  00064	48 89 08	 mov	 QWORD PTR [rax], rcx
  00067	48 8b 44 24 28	 mov	 rax, QWORD PTR _EX_Flink$2[rsp]
  0006c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _EX_Blink$3[rsp]
  00071	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1034 :             threadcount--;

  00075	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR threadcount
  0007b	ff c8		 dec	 eax
  0007d	89 05 00 00 00
	00		 mov	 DWORD PTR threadcount, eax

; 1035 :             free( ht->ht_name );

  00083	48 8b 44 24 20	 mov	 rax, QWORD PTR ht$1[rsp]
  00088	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1036 :             free( ht->ht_ob_where );

  00092	48 8b 44 24 20	 mov	 rax, QWORD PTR ht$1[rsp]
  00097	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1037 :             free_aligned( ht );

  000a1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ht$1[rsp]
  000a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free
$LN2@hthread_ha:

; 1038 :         }
; 1039 :     }
; 1040 :     UnlockThreadsList();

  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:threadlock
  000b3	e8 00 00 00 00	 call	 fthread_mutex_unlock

; 1041 : }

  000b8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000bc	c3		 ret	 0
hthread_has_exited ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
ilk$ = 112
ple$ = 120
tv83 = 128
tv88 = 136
tv92 = 144
tv138 = 152
tv143 = 160
threadname$ = 168
tod$1 = 184
__$ArrayPad$ = 216
tid$ = 240
exit_loc$ = 248
hthread_list_abandoned_locks PROC

; 982  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 983  :     ILOCK*       ilk;
; 984  :     LIST_ENTRY*  ple;
; 985  :     char         threadname[16];
; 986  : 
; 987  :     if (sysblk.shutdown)

  00022	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00029	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0002f	c1 e8 0b	 shr	 eax, 11
  00032	83 e0 01	 and	 eax, 1
  00035	85 c0		 test	 eax, eax
  00037	74 05		 je	 SHORT $LN5@hthread_li

; 988  :         return;

  00039	e9 43 02 00 00	 jmp	 $LN1@hthread_li
$LN5@hthread_li:

; 989  : 
; 990  :     get_thread_name( tid, threadname );

  0003e	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR threadname$[rsp]
  00046	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tid$[rsp]
  0004d	e8 00 00 00 00	 call	 hthread_get_thread_name

; 991  : 
; 992  :     LockLocksList();

  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:listlock
  00059	e8 00 00 00 00	 call	 fthread_mutex_lock

; 993  :     {
; 994  :         for (ple = locklist.Flink; ple != &locklist; ple = ple->Flink)

  0005e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR locklist
  00065	48 89 44 24 78	 mov	 QWORD PTR ple$[rsp], rax
  0006a	eb 0d		 jmp	 SHORT $LN4@hthread_li
$LN2@hthread_li:
  0006c	48 8b 44 24 78	 mov	 rax, QWORD PTR ple$[rsp]
  00071	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00074	48 89 44 24 78	 mov	 QWORD PTR ple$[rsp], rax
$LN4@hthread_li:
  00079	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:locklist
  00080	48 39 44 24 78	 cmp	 QWORD PTR ple$[rsp], rax
  00085	0f 84 ea 01 00
	00		 je	 $LN3@hthread_li

; 995  :         {
; 996  :             ilk = CONTAINING_RECORD( ple, ILOCK, il_link );

  0008b	48 8b 44 24 78	 mov	 rax, QWORD PTR ple$[rsp]
  00090	48 89 44 24 70	 mov	 QWORD PTR ilk$[rsp], rax

; 997  :             if (hthread_equal( ilk->il_ob_tid, tid ))

  00095	8b 94 24 f0 00
	00 00		 mov	 edx, DWORD PTR tid$[rsp]
  0009c	48 8b 44 24 70	 mov	 rax, QWORD PTR ilk$[rsp]
  000a1	8b 48 30	 mov	 ecx, DWORD PTR [rax+48]
  000a4	e8 00 00 00 00	 call	 fthread_equal
  000a9	85 c0		 test	 eax, eax
  000ab	0f 84 bf 01 00
	00		 je	 $LN6@hthread_li

; 998  :             {
; 999  :                 char tod[27];           /* "YYYY-MM-DD HH:MM:SS.uuuuuu"  */
; 1000 : 
; 1001 :                 FormatTIMEVAL( &ilk->il_ob_time, tod, sizeof( tod ));

  000b1	48 8b 44 24 70	 mov	 rax, QWORD PTR ilk$[rsp]
  000b6	48 83 c0 28	 add	 rax, 40			; 00000028H
  000ba	41 b8 1b 00 00
	00		 mov	 r8d, 27
  000c0	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR tod$1[rsp]
  000c8	48 8b c8	 mov	 rcx, rax
  000cb	e8 00 00 00 00	 call	 FormatTIMEVAL

; 1002 : 
; 1003 :                 if (exit_loc)

  000d0	48 83 bc 24 f8
	00 00 00 00	 cmp	 QWORD PTR exit_loc$[rsp], 0
  000d9	0f 84 dc 00 00
	00		 je	 $LN7@hthread_li

; 1004 :                 {
; 1005 :                     // "Thread "TIDPAT" (%s) has abandoned at %s lock %s obtained on %s at %s"
; 1006 :                     WRMSG( HHC90016, "E", TID_CAST( tid ), threadname, TRIMLOC( exit_loc ),

  000df	48 8b 44 24 70	 mov	 rax, QWORD PTR ilk$[rsp]
  000e4	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  000e8	e8 00 00 00 00	 call	 trimloc
  000ed	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv83[rsp], rax
  000f5	b9 01 00 00 00	 mov	 ecx, 1
  000fa	48 6b c9 0b	 imul	 rcx, rcx, 11
  000fe	48 8d 8c 0c b8
	00 00 00	 lea	 rcx, QWORD PTR tod$1[rsp+rcx]
  00106	48 89 8c 24 88
	00 00 00	 mov	 QWORD PTR tv88[rsp], rcx
  0010e	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR exit_loc$[rsp]
  00116	e8 00 00 00 00	 call	 trimloc
  0011b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv92[rsp], rax
  00123	b9 01 00 00 00	 mov	 ecx, 1
  00128	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0012e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv83[rsp]
  00136	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  0013b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv88[rsp]
  00143	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00148	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ilk$[rsp]
  0014d	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00151	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00156	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv92[rsp]
  0015e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00163	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR threadname$[rsp]
  0016b	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00170	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tid$[rsp]
  00177	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0017b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159705
  00182	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00187	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159706
  0018e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00193	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00198	41 b9 03 00 00
	00		 mov	 r9d, 3
  0019e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159707
  001a5	ba ef 03 00 00	 mov	 edx, 1007		; 000003efH
  001aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159708
  001b1	e8 00 00 00 00	 call	 fwritemsg

; 1007 :                         ilk->il_name, &tod[11], TRIMLOC( ilk->il_ob_locat ));
; 1008 :                 }

  001b6	e9 b5 00 00 00	 jmp	 $LN8@hthread_li
$LN7@hthread_li:

; 1009 :                 else
; 1010 :                 {
; 1011 :                     // "Thread "TIDPAT" (%s) has abandoned lock %s obtained on %s at %s"
; 1012 :                     WRMSG( HHC90015, "E", TID_CAST( tid ), threadname,

  001bb	48 8b 44 24 70	 mov	 rax, QWORD PTR ilk$[rsp]
  001c0	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  001c4	e8 00 00 00 00	 call	 trimloc
  001c9	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv138[rsp], rax
  001d1	b9 01 00 00 00	 mov	 ecx, 1
  001d6	48 6b c9 0b	 imul	 rcx, rcx, 11
  001da	48 8d 8c 0c b8
	00 00 00	 lea	 rcx, QWORD PTR tod$1[rsp+rcx]
  001e2	48 89 8c 24 a0
	00 00 00	 mov	 QWORD PTR tv143[rsp], rcx
  001ea	b9 01 00 00 00	 mov	 ecx, 1
  001ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001f5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv138[rsp]
  001fd	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00202	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv143[rsp]
  0020a	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0020f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ilk$[rsp]
  00214	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00218	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0021d	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR threadname$[rsp]
  00225	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0022a	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tid$[rsp]
  00231	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00235	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159709
  0023c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00241	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159710
  00248	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0024d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00252	41 b9 03 00 00
	00		 mov	 r9d, 3
  00258	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159711
  0025f	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00264	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159712
  0026b	e8 00 00 00 00	 call	 fwritemsg
$LN8@hthread_li:
$LN6@hthread_li:

; 1013 :                         ilk->il_name, &tod[11], TRIMLOC( ilk->il_ob_locat ));
; 1014 :                 }
; 1015 :             }
; 1016 :         }

  00270	e9 f7 fd ff ff	 jmp	 $LN2@hthread_li
$LN3@hthread_li:

; 1017 :     }
; 1018 :     UnlockLocksList();

  00275	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:listlock
  0027c	e8 00 00 00 00	 call	 fthread_mutex_unlock
$LN1@hthread_li:

; 1019 : }

  00281	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00289	48 33 cc	 xor	 rcx, rsp
  0028c	e8 00 00 00 00	 call	 __security_check_cookie
  00291	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  00298	c3		 ret	 0
hthread_list_abandoned_locks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 32
pat$ = 64
state$ = 72
hthread_init_thread_attr PROC

; 948  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 949  :     int rc;
; 950  :     rc = hthread_attr_init( pat );

  0000d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pat$[rsp]
  00012	e8 00 00 00 00	 call	 fthread_attr_init
  00017	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 951  :     if (!rc)

  0001b	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00020	75 13		 jne	 SHORT $LN2@hthread_in

; 952  :         rc = hthread_attr_setstacksize( pat, HTHREAD_STACK_SIZE );

  00022	ba 00 00 10 00	 mov	 edx, 1048576		; 00100000H
  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pat$[rsp]
  0002c	e8 00 00 00 00	 call	 fthread_attr_setstacksize
  00031	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
$LN2@hthread_in:

; 953  :     if (!rc)

  00035	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  0003a	75 12		 jne	 SHORT $LN3@hthread_in

; 954  :         rc = hthread_attr_setdetachstate( pat, state );

  0003c	8b 54 24 48	 mov	 edx, DWORD PTR state$[rsp]
  00040	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pat$[rsp]
  00045	e8 00 00 00 00	 call	 fthread_attr_setdetachstate
  0004a	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
$LN3@hthread_in:

; 955  :     return rc;

  0004e	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 956  : }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	c3		 ret	 0
hthread_init_thread_attr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
ht$ = 32
hthread_lock_obtained PROC

; 491  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 492  :     HTHREAD* ht;
; 493  :     if (!(ht = hthread_find_HTHREAD( hthread_self() )))

  00004	e8 00 00 00 00	 call	 fthread_self
  00009	8b c8		 mov	 ecx, eax
  0000b	e8 00 00 00 00	 call	 hthread_find_HTHREAD
  00010	48 89 44 24 20	 mov	 QWORD PTR ht$[rsp], rax
  00015	48 83 7c 24 20
	00		 cmp	 QWORD PTR ht$[rsp], 0
  0001b	75 02		 jne	 SHORT $LN2@hthread_lo

; 494  :         return;

  0001d	eb 0d		 jmp	 SHORT $LN1@hthread_lo
$LN2@hthread_lo:

; 495  :     ht->ht_ob_lock = NULL;

  0001f	48 8b 44 24 20	 mov	 rax, QWORD PTR ht$[rsp]
  00024	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0
$LN1@hthread_lo:

; 496  : }

  0002c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00030	c3		 ret	 0
hthread_lock_obtained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
ht$ = 32
plk$ = 64
loc$ = 72
hthread_obtaining_lock PROC

; 477  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 478  :     HTHREAD* ht;
; 479  :     if (!(ht = hthread_find_HTHREAD( hthread_self() )))

  0000e	e8 00 00 00 00	 call	 fthread_self
  00013	8b c8		 mov	 ecx, eax
  00015	e8 00 00 00 00	 call	 hthread_find_HTHREAD
  0001a	48 89 44 24 20	 mov	 QWORD PTR ht$[rsp], rax
  0001f	48 83 7c 24 20
	00		 cmp	 QWORD PTR ht$[rsp], 0
  00025	75 02		 jne	 SHORT $LN2@hthread_ob

; 480  :         return;

  00027	eb 44		 jmp	 SHORT $LN1@hthread_ob
$LN2@hthread_ob:

; 481  :     ht->ht_ob_lock = plk;

  00029	48 8b 44 24 20	 mov	 rax, QWORD PTR ht$[rsp]
  0002e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR plk$[rsp]
  00033	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 482  :     free( ht->ht_ob_where );

  00037	48 8b 44 24 20	 mov	 rax, QWORD PTR ht$[rsp]
  0003c	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 483  :     ht->ht_ob_where = strdup( loc );

  00046	48 8b 4c 24 48	 mov	 rcx, QWORD PTR loc$[rsp]
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00051	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ht$[rsp]
  00056	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 484  :     gettimeofday( &ht->ht_ob_time, NULL );

  0005a	48 8b 44 24 20	 mov	 rax, QWORD PTR ht$[rsp]
  0005f	48 83 c0 30	 add	 rax, 48			; 00000030H
  00063	33 d2		 xor	 edx, edx
  00065	48 8b c8	 mov	 rcx, rax
  00068	e8 00 00 00 00	 call	 gettimeofday
$LN1@hthread_ob:

; 485  : }

  0006d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00071	c3		 ret	 0
hthread_obtaining_lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
ht$ = 32
tid$ = 64
hthread_find_HTHREAD PROC

; 463  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 464  :     HTHREAD* ht;
; 465  :     LockThreadsList();

  00008	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:threadlock
  0000f	e8 00 00 00 00	 call	 fthread_mutex_lock

; 466  :     {
; 467  :         ht = hthread_find_HTHREAD_locked( tid, NULL );

  00014	33 d2		 xor	 edx, edx
  00016	8b 4c 24 40	 mov	 ecx, DWORD PTR tid$[rsp]
  0001a	e8 00 00 00 00	 call	 hthread_find_HTHREAD_locked
  0001f	48 89 44 24 20	 mov	 QWORD PTR ht$[rsp], rax

; 468  :     }
; 469  :     UnlockThreadsList();

  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:threadlock
  0002b	e8 00 00 00 00	 call	 fthread_mutex_unlock

; 470  :     return ht;

  00030	48 8b 44 24 20	 mov	 rax, QWORD PTR ht$[rsp]

; 471  : }

  00035	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00039	c3		 ret	 0
hthread_find_HTHREAD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
ht$ = 32
ple$ = 40
_EX_Head$1 = 48
_EX_Flink$2 = 56
_EX_Blink$3 = 64
_EX_Next$4 = 72
tid$ = 96
anchor$ = 104
hthread_find_HTHREAD_locked PROC

; 439  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 440  :     HTHREAD*     ht;
; 441  :     LIST_ENTRY*  ple;
; 442  : 
; 443  :     if (!anchor) anchor = &threadlist;

  0000d	48 83 7c 24 68
	00		 cmp	 QWORD PTR anchor$[rsp], 0
  00013	75 0c		 jne	 SHORT $LN5@hthread_fi
  00015	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:threadlist
  0001c	48 89 44 24 68	 mov	 QWORD PTR anchor$[rsp], rax
$LN5@hthread_fi:

; 444  : 
; 445  :     for (ple = anchor->Flink; ple != anchor; ple = ple->Flink)

  00021	48 8b 44 24 68	 mov	 rax, QWORD PTR anchor$[rsp]
  00026	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00029	48 89 44 24 28	 mov	 QWORD PTR ple$[rsp], rax
  0002e	eb 0d		 jmp	 SHORT $LN4@hthread_fi
$LN2@hthread_fi:
  00030	48 8b 44 24 28	 mov	 rax, QWORD PTR ple$[rsp]
  00035	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00038	48 89 44 24 28	 mov	 QWORD PTR ple$[rsp], rax
$LN4@hthread_fi:
  0003d	48 8b 44 24 68	 mov	 rax, QWORD PTR anchor$[rsp]
  00042	48 39 44 24 28	 cmp	 QWORD PTR ple$[rsp], rax
  00047	0f 84 b2 00 00
	00		 je	 $LN3@hthread_fi

; 446  :     {
; 447  :         ht = CONTAINING_RECORD( ple, HTHREAD, ht_link );

  0004d	48 8b 44 24 28	 mov	 rax, QWORD PTR ple$[rsp]
  00052	48 89 44 24 20	 mov	 QWORD PTR ht$[rsp], rax

; 448  : 
; 449  :         if (equal_threads( ht->ht_tid, tid ))

  00057	8b 54 24 60	 mov	 edx, DWORD PTR tid$[rsp]
  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR ht$[rsp]
  00060	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  00063	e8 00 00 00 00	 call	 hthread_equal_threads
  00068	85 c0		 test	 eax, eax
  0006a	0f 84 8a 00 00
	00		 je	 $LN6@hthread_fi

; 450  :         {
; 451  :             RemoveListEntry( &ht->ht_link );

  00070	48 8b 44 24 20	 mov	 rax, QWORD PTR ht$[rsp]
  00075	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00078	48 89 44 24 38	 mov	 QWORD PTR _EX_Flink$2[rsp], rax
  0007d	48 8b 44 24 20	 mov	 rax, QWORD PTR ht$[rsp]
  00082	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00086	48 89 44 24 40	 mov	 QWORD PTR _EX_Blink$3[rsp], rax
  0008b	48 8b 44 24 40	 mov	 rax, QWORD PTR _EX_Blink$3[rsp]
  00090	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _EX_Flink$2[rsp]
  00095	48 89 08	 mov	 QWORD PTR [rax], rcx
  00098	48 8b 44 24 38	 mov	 rax, QWORD PTR _EX_Flink$2[rsp]
  0009d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _EX_Blink$3[rsp]
  000a2	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 452  :             InsertListHead( anchor, &ht->ht_link );

  000a6	48 8b 44 24 68	 mov	 rax, QWORD PTR anchor$[rsp]
  000ab	48 89 44 24 30	 mov	 QWORD PTR _EX_Head$1[rsp], rax
  000b0	48 8b 44 24 30	 mov	 rax, QWORD PTR _EX_Head$1[rsp]
  000b5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b8	48 89 44 24 48	 mov	 QWORD PTR _EX_Next$4[rsp], rax
  000bd	48 8b 44 24 20	 mov	 rax, QWORD PTR ht$[rsp]
  000c2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _EX_Next$4[rsp]
  000c7	48 89 08	 mov	 QWORD PTR [rax], rcx
  000ca	48 8b 44 24 20	 mov	 rax, QWORD PTR ht$[rsp]
  000cf	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _EX_Head$1[rsp]
  000d4	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  000d8	48 8b 44 24 20	 mov	 rax, QWORD PTR ht$[rsp]
  000dd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _EX_Head$1[rsp]
  000e2	48 89 01	 mov	 QWORD PTR [rcx], rax
  000e5	48 8b 44 24 20	 mov	 rax, QWORD PTR ht$[rsp]
  000ea	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _EX_Next$4[rsp]
  000ef	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 453  :             return ht;

  000f3	48 8b 44 24 20	 mov	 rax, QWORD PTR ht$[rsp]
  000f8	eb 07		 jmp	 SHORT $LN1@hthread_fi
$LN6@hthread_fi:

; 454  :         }
; 455  :     }

  000fa	e9 31 ff ff ff	 jmp	 $LN2@hthread_fi
$LN3@hthread_fi:

; 456  :     return NULL;

  000ff	33 c0		 xor	 eax, eax
$LN1@hthread_fi:

; 457  : }

  00101	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00105	c3		 ret	 0
hthread_find_HTHREAD_locked ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
ilk$ = 0
ple$ = 8
_EX_Head$1 = 16
_EX_Flink$2 = 24
_EX_Blink$3 = 32
_EX_Next$4 = 40
plk$ = 64
anchor$ = 72
hthreads_find_ILOCK_locked PROC

; 238  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 239  :     ILOCK*       ilk;               /* Pointer to ILOCK structure    */
; 240  :     LIST_ENTRY*  ple;               /* Ptr to LIST_ENTRY structure   */
; 241  : 
; 242  :     if (!anchor) anchor = &locklist;

  0000e	48 83 7c 24 48
	00		 cmp	 QWORD PTR anchor$[rsp], 0
  00014	75 0c		 jne	 SHORT $LN5@hthreads_f
  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:locklist
  0001d	48 89 44 24 48	 mov	 QWORD PTR anchor$[rsp], rax
$LN5@hthreads_f:

; 243  : 
; 244  :     for (ple = anchor->Flink; ple != anchor; ple = ple->Flink)

  00022	48 8b 44 24 48	 mov	 rax, QWORD PTR anchor$[rsp]
  00027	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002a	48 89 44 24 08	 mov	 QWORD PTR ple$[rsp], rax
  0002f	eb 0d		 jmp	 SHORT $LN4@hthreads_f
$LN2@hthreads_f:
  00031	48 8b 44 24 08	 mov	 rax, QWORD PTR ple$[rsp]
  00036	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00039	48 89 44 24 08	 mov	 QWORD PTR ple$[rsp], rax
$LN4@hthreads_f:
  0003e	48 8b 44 24 48	 mov	 rax, QWORD PTR anchor$[rsp]
  00043	48 39 44 24 08	 cmp	 QWORD PTR ple$[rsp], rax
  00048	0f 84 a4 00 00
	00		 je	 $LN3@hthreads_f

; 245  :     {
; 246  :         ilk = CONTAINING_RECORD( ple, ILOCK, il_link );

  0004e	48 8b 44 24 08	 mov	 rax, QWORD PTR ple$[rsp]
  00053	48 89 04 24	 mov	 QWORD PTR ilk$[rsp], rax

; 247  :         if (ilk->il_addr == plk)

  00057	48 8b 04 24	 mov	 rax, QWORD PTR ilk$[rsp]
  0005b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR plk$[rsp]
  00060	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  00064	0f 85 83 00 00
	00		 jne	 $LN6@hthreads_f

; 248  :         {
; 249  :             RemoveListEntry( &ilk->il_link );

  0006a	48 8b 04 24	 mov	 rax, QWORD PTR ilk$[rsp]
  0006e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00071	48 89 44 24 18	 mov	 QWORD PTR _EX_Flink$2[rsp], rax
  00076	48 8b 04 24	 mov	 rax, QWORD PTR ilk$[rsp]
  0007a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0007e	48 89 44 24 20	 mov	 QWORD PTR _EX_Blink$3[rsp], rax
  00083	48 8b 44 24 20	 mov	 rax, QWORD PTR _EX_Blink$3[rsp]
  00088	48 8b 4c 24 18	 mov	 rcx, QWORD PTR _EX_Flink$2[rsp]
  0008d	48 89 08	 mov	 QWORD PTR [rax], rcx
  00090	48 8b 44 24 18	 mov	 rax, QWORD PTR _EX_Flink$2[rsp]
  00095	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _EX_Blink$3[rsp]
  0009a	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 250  :             InsertListHead( anchor, &ilk->il_link );

  0009e	48 8b 44 24 48	 mov	 rax, QWORD PTR anchor$[rsp]
  000a3	48 89 44 24 10	 mov	 QWORD PTR _EX_Head$1[rsp], rax
  000a8	48 8b 44 24 10	 mov	 rax, QWORD PTR _EX_Head$1[rsp]
  000ad	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b0	48 89 44 24 28	 mov	 QWORD PTR _EX_Next$4[rsp], rax
  000b5	48 8b 04 24	 mov	 rax, QWORD PTR ilk$[rsp]
  000b9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _EX_Next$4[rsp]
  000be	48 89 08	 mov	 QWORD PTR [rax], rcx
  000c1	48 8b 04 24	 mov	 rax, QWORD PTR ilk$[rsp]
  000c5	48 8b 4c 24 10	 mov	 rcx, QWORD PTR _EX_Head$1[rsp]
  000ca	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  000ce	48 8b 04 24	 mov	 rax, QWORD PTR ilk$[rsp]
  000d2	48 8b 4c 24 10	 mov	 rcx, QWORD PTR _EX_Head$1[rsp]
  000d7	48 89 01	 mov	 QWORD PTR [rcx], rax
  000da	48 8b 04 24	 mov	 rax, QWORD PTR ilk$[rsp]
  000de	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _EX_Next$4[rsp]
  000e3	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 251  :             return ilk;

  000e7	48 8b 04 24	 mov	 rax, QWORD PTR ilk$[rsp]
  000eb	eb 07		 jmp	 SHORT $LN1@hthreads_f
$LN6@hthreads_f:

; 252  :         }
; 253  :     }

  000ed	e9 3f ff ff ff	 jmp	 $LN2@hthreads_f
$LN3@hthreads_f:

; 254  :     return NULL;

  000f2	33 c0		 xor	 eax, eax
$LN1@hthreads_f:

; 255  : }

  000f4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f8	c3		 ret	 0
hthreads_find_ILOCK_locked ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
tv64 = 112
tv70 = 116
err_desc$ = 120
tv143 = 128
tv67 = 136
tv87 = 144
tv136 = 152
ilk$ = 176
rc$ = 184
calltype$ = 192
err_loc$ = 200
loglock	PROC

; 86   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 87   :     const char* err_desc;
; 88   : 
; 89   :     switch (rc)

  0001a	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR rc$[rsp]
  00021	89 44 24 70	 mov	 DWORD PTR tv64[rsp], eax
  00025	8b 44 24 70	 mov	 eax, DWORD PTR tv64[rsp]
  00029	ff c8		 dec	 eax
  0002b	89 44 24 70	 mov	 DWORD PTR tv64[rsp], eax
  0002f	81 7c 24 70 89
	00 00 00	 cmp	 DWORD PTR tv64[rsp], 137 ; 00000089H
  00037	0f 87 9e 00 00
	00		 ja	 $LN13@loglock
  0003d	48 63 44 24 70	 movsxd	 rax, DWORD PTR tv64[rsp]
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00049	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN19@loglock[rcx+rax]
  00051	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN20@loglock[rcx+rax*4]
  00058	48 03 c1	 add	 rax, rcx
  0005b	ff e0		 jmp	 rax
$LN4@loglock:

; 90   :     {
; 91   :         case EEXIST:          err_desc = "already init'ed";  break;

  0005d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159093
  00064	48 89 44 24 78	 mov	 QWORD PTR err_desc$[rsp], rax
  00069	eb 7c		 jmp	 SHORT $LN2@loglock
$LN5@loglock:

; 92   :         case EAGAIN:          err_desc = "max recursion";    break;

  0006b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159095
  00072	48 89 44 24 78	 mov	 QWORD PTR err_desc$[rsp], rax
  00077	eb 6e		 jmp	 SHORT $LN2@loglock
$LN6@loglock:

; 93   :         case EPERM:           err_desc = "not owned";        break;

  00079	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159097
  00080	48 89 44 24 78	 mov	 QWORD PTR err_desc$[rsp], rax
  00085	eb 60		 jmp	 SHORT $LN2@loglock
$LN7@loglock:

; 94   :         case EINVAL:          err_desc = "invalid argument"; break;

  00087	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159099
  0008e	48 89 44 24 78	 mov	 QWORD PTR err_desc$[rsp], rax
  00093	eb 52		 jmp	 SHORT $LN2@loglock
$LN8@loglock:

; 95   :         case EDEADLK:         err_desc = "deadlock";         break;

  00095	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159101
  0009c	48 89 44 24 78	 mov	 QWORD PTR err_desc$[rsp], rax
  000a1	eb 44		 jmp	 SHORT $LN2@loglock
$LN9@loglock:

; 96   :         case ENOTRECOVERABLE: err_desc = "not recoverable";  break;

  000a3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159103
  000aa	48 89 44 24 78	 mov	 QWORD PTR err_desc$[rsp], rax
  000af	eb 36		 jmp	 SHORT $LN2@loglock
$LN10@loglock:

; 97   :         case EOWNERDEAD:      err_desc = "owner dead";       break;

  000b1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159105
  000b8	48 89 44 24 78	 mov	 QWORD PTR err_desc$[rsp], rax
  000bd	eb 28		 jmp	 SHORT $LN2@loglock
$LN11@loglock:

; 98   :         case EBUSY:           err_desc = "busy";             break;

  000bf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159107
  000c6	48 89 44 24 78	 mov	 QWORD PTR err_desc$[rsp], rax
  000cb	eb 1a		 jmp	 SHORT $LN2@loglock
$LN12@loglock:

; 99   :         case ETIMEDOUT:       err_desc = "timeout";          break;

  000cd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159109
  000d4	48 89 44 24 78	 mov	 QWORD PTR err_desc$[rsp], rax
  000d9	eb 0c		 jmp	 SHORT $LN2@loglock
$LN13@loglock:

; 100  :         default:              err_desc = "(unknown)";        break;

  000db	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159111
  000e2	48 89 44 24 78	 mov	 QWORD PTR err_desc$[rsp], rax
$LN2@loglock:

; 101  :     }
; 102  : 
; 103  :     // "'%s(%s)' failed: rc=%d: %s; tid="TIDPAT", loc=%s"
; 104  :     WRMSG( HHC90013, "E", calltype, ilk->il_name, rc, err_desc,

  000e7	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR err_loc$[rsp]
  000ef	e8 00 00 00 00	 call	 trimloc
  000f4	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv67[rsp], rax
  000fc	e8 00 00 00 00	 call	 fthread_self
  00101	89 44 24 74	 mov	 DWORD PTR tv70[rsp], eax
  00105	b9 01 00 00 00	 mov	 ecx, 1
  0010a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00110	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv67[rsp]
  00118	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  0011d	8b 4c 24 74	 mov	 ecx, DWORD PTR tv70[rsp]
  00121	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00125	48 8b 4c 24 78	 mov	 rcx, QWORD PTR err_desc$[rsp]
  0012a	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0012f	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR rc$[rsp]
  00136	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0013a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR ilk$[rsp]
  00142	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00146	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0014b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR calltype$[rsp]
  00153	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00158	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159112
  0015f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00164	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159113
  0016b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00170	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00175	41 b9 03 00 00
	00		 mov	 r9d, 3
  0017b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159114
  00182	ba 69 00 00 00	 mov	 edx, 105		; 00000069H
  00187	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159115
  0018e	e8 00 00 00 00	 call	 fwritemsg

; 105  :         TID_CAST( hthread_self() ), TRIMLOC( err_loc ));
; 106  : 
; 107  :     if (EEXIST == rc)

  00193	83 bc 24 b8 00
	00 00 11	 cmp	 DWORD PTR rc$[rsp], 17
  0019b	75 7d		 jne	 SHORT $LN14@loglock

; 108  :     {
; 109  :         // "lock %s was already initialized at %s"
; 110  :         WRMSG( HHC90028, "I", ilk->il_name, TRIMLOC( ilk->il_cr_locat ));

  0019d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ilk$[rsp]
  001a5	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  001a9	e8 00 00 00 00	 call	 trimloc
  001ae	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv87[rsp], rax
  001b6	b9 01 00 00 00	 mov	 ecx, 1
  001bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001c1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv87[rsp]
  001c9	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001ce	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR ilk$[rsp]
  001d6	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  001da	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159117
  001e6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159118
  001f2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001f7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001fc	41 b9 03 00 00
	00		 mov	 r9d, 3
  00202	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159119
  00209	ba 6e 00 00 00	 mov	 edx, 110		; 0000006eH
  0020e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159120
  00215	e8 00 00 00 00	 call	 fwritemsg
$LN14@loglock:

; 111  :     }
; 112  :     if (ilk->il_ob_tid)

  0021a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ilk$[rsp]
  00222	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00226	0f 84 c3 00 00
	00		 je	 $LN15@loglock

; 113  :     {
; 114  :         // "lock %s was %s by thread "TIDPAT" at %s"
; 115  :         WRMSG( HHC90014, "I", ilk->il_name,

  0022c	83 bc 24 b8 00
	00 00 11	 cmp	 DWORD PTR rc$[rsp], 17
  00234	75 11		 jne	 SHORT $LN17@loglock
  00236	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159122
  0023d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv143[rsp], rax
  00245	eb 0f		 jmp	 SHORT $LN18@loglock
$LN17@loglock:
  00247	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159123
  0024e	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv143[rsp], rax
$LN18@loglock:
  00256	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ilk$[rsp]
  0025e	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  00262	e8 00 00 00 00	 call	 trimloc
  00267	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv136[rsp], rax
  0026f	b9 01 00 00 00	 mov	 ecx, 1
  00274	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0027a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv136[rsp]
  00282	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00287	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR ilk$[rsp]
  0028f	8b 49 30	 mov	 ecx, DWORD PTR [rcx+48]
  00292	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00296	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv143[rsp]
  0029e	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002a3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR ilk$[rsp]
  002ab	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  002af	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159124
  002bb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159125
  002c7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002cc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002d1	41 b9 03 00 00
	00		 mov	 r9d, 3
  002d7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159126
  002de	ba 76 00 00 00	 mov	 edx, 118		; 00000076H
  002e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159127
  002ea	e8 00 00 00 00	 call	 fwritemsg
$LN15@loglock:

; 116  :             EEXIST == rc ? "still held" : "obtained",
; 117  :             TID_CAST( ilk->il_ob_tid ),
; 118  :             TRIMLOC( ilk->il_ob_locat ));
; 119  :     }
; 120  : }

  002ef	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  002f6	c3		 ret	 0
  002f7	90		 npad	 1
$LN20@loglock:
  002f8	00 00 00 00	 DD	 $LN6@loglock
  002fc	00 00 00 00	 DD	 $LN5@loglock
  00300	00 00 00 00	 DD	 $LN11@loglock
  00304	00 00 00 00	 DD	 $LN4@loglock
  00308	00 00 00 00	 DD	 $LN7@loglock
  0030c	00 00 00 00	 DD	 $LN8@loglock
  00310	00 00 00 00	 DD	 $LN9@loglock
  00314	00 00 00 00	 DD	 $LN10@loglock
  00318	00 00 00 00	 DD	 $LN12@loglock
  0031c	00 00 00 00	 DD	 $LN13@loglock
$LN19@loglock:
  00320	00		 DB	 0
  00321	09		 DB	 9
  00322	09		 DB	 9
  00323	09		 DB	 9
  00324	09		 DB	 9
  00325	09		 DB	 9
  00326	09		 DB	 9
  00327	09		 DB	 9
  00328	09		 DB	 9
  00329	09		 DB	 9
  0032a	01		 DB	 1
  0032b	09		 DB	 9
  0032c	09		 DB	 9
  0032d	09		 DB	 9
  0032e	09		 DB	 9
  0032f	02		 DB	 2
  00330	03		 DB	 3
  00331	09		 DB	 9
  00332	09		 DB	 9
  00333	09		 DB	 9
  00334	09		 DB	 9
  00335	04		 DB	 4
  00336	09		 DB	 9
  00337	09		 DB	 9
  00338	09		 DB	 9
  00339	09		 DB	 9
  0033a	09		 DB	 9
  0033b	09		 DB	 9
  0033c	09		 DB	 9
  0033d	09		 DB	 9
  0033e	09		 DB	 9
  0033f	09		 DB	 9
  00340	09		 DB	 9
  00341	09		 DB	 9
  00342	09		 DB	 9
  00343	05		 DB	 5
  00344	09		 DB	 9
  00345	09		 DB	 9
  00346	09		 DB	 9
  00347	09		 DB	 9
  00348	09		 DB	 9
  00349	09		 DB	 9
  0034a	09		 DB	 9
  0034b	09		 DB	 9
  0034c	09		 DB	 9
  0034d	09		 DB	 9
  0034e	09		 DB	 9
  0034f	09		 DB	 9
  00350	09		 DB	 9
  00351	09		 DB	 9
  00352	09		 DB	 9
  00353	09		 DB	 9
  00354	09		 DB	 9
  00355	09		 DB	 9
  00356	09		 DB	 9
  00357	09		 DB	 9
  00358	09		 DB	 9
  00359	09		 DB	 9
  0035a	09		 DB	 9
  0035b	09		 DB	 9
  0035c	09		 DB	 9
  0035d	09		 DB	 9
  0035e	09		 DB	 9
  0035f	09		 DB	 9
  00360	09		 DB	 9
  00361	09		 DB	 9
  00362	09		 DB	 9
  00363	09		 DB	 9
  00364	09		 DB	 9
  00365	09		 DB	 9
  00366	09		 DB	 9
  00367	09		 DB	 9
  00368	09		 DB	 9
  00369	09		 DB	 9
  0036a	09		 DB	 9
  0036b	09		 DB	 9
  0036c	09		 DB	 9
  0036d	09		 DB	 9
  0036e	09		 DB	 9
  0036f	09		 DB	 9
  00370	09		 DB	 9
  00371	09		 DB	 9
  00372	09		 DB	 9
  00373	09		 DB	 9
  00374	09		 DB	 9
  00375	09		 DB	 9
  00376	09		 DB	 9
  00377	09		 DB	 9
  00378	09		 DB	 9
  00379	09		 DB	 9
  0037a	09		 DB	 9
  0037b	09		 DB	 9
  0037c	09		 DB	 9
  0037d	09		 DB	 9
  0037e	09		 DB	 9
  0037f	09		 DB	 9
  00380	09		 DB	 9
  00381	09		 DB	 9
  00382	09		 DB	 9
  00383	09		 DB	 9
  00384	09		 DB	 9
  00385	09		 DB	 9
  00386	09		 DB	 9
  00387	09		 DB	 9
  00388	09		 DB	 9
  00389	09		 DB	 9
  0038a	09		 DB	 9
  0038b	09		 DB	 9
  0038c	09		 DB	 9
  0038d	09		 DB	 9
  0038e	09		 DB	 9
  0038f	09		 DB	 9
  00390	09		 DB	 9
  00391	09		 DB	 9
  00392	09		 DB	 9
  00393	09		 DB	 9
  00394	09		 DB	 9
  00395	09		 DB	 9
  00396	09		 DB	 9
  00397	09		 DB	 9
  00398	09		 DB	 9
  00399	09		 DB	 9
  0039a	09		 DB	 9
  0039b	09		 DB	 9
  0039c	09		 DB	 9
  0039d	09		 DB	 9
  0039e	06		 DB	 6
  0039f	09		 DB	 9
  003a0	09		 DB	 9
  003a1	09		 DB	 9
  003a2	09		 DB	 9
  003a3	09		 DB	 9
  003a4	07		 DB	 7
  003a5	09		 DB	 9
  003a6	09		 DB	 9
  003a7	09		 DB	 9
  003a8	09		 DB	 9
  003a9	08		 DB	 8
loglock	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.h
_TEXT	SEGMENT
result$ = 32
temp$ = 40
time$1 = 48
__$ArrayPad$ = 64
host_tod PROC

; 565  : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000b	48 33 c4	 xor	 rax, rsp
  0000e	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 566  :   register TOD  result;
; 567  :   register U64  temp;
; 568  : 
; 569  :   /* Use the same clock source as host_ETOD().
; 570  :      Refer to host_ETOD() in clock.c for additional comments.
; 571  :    */
; 572  : 
; 573  : #if !defined( _MSVC_ ) && !defined( CLOCK_REALTIME )
; 574  :   {
; 575  :     struct timeval time;
; 576  :     gettimeofday( &time, NULL );    /* Get current host time         */
; 577  :     result = time.tv_usec << 4;     /* Adjust microseconds to bit-59 */
; 578  :     temp   = time.tv_sec;           /* Load seconds                  */
; 579  :   }
; 580  : #else
; 581  :   {
; 582  :     struct timespec time;
; 583  :     clock_gettime( CLOCK_REALTIME, &time );

  00013	48 8d 54 24 30	 lea	 rdx, QWORD PTR time$1[rsp]
  00018	33 c9		 xor	 ecx, ecx
  0001a	e8 00 00 00 00	 call	 clock_gettime

; 584  :     result  = time.tv_nsec;         /* Adjust nanoseconds to bit-59  */

  0001f	48 63 44 24 38	 movsxd	 rax, DWORD PTR time$1[rsp+8]
  00024	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 585  :     result <<= 1;                   /* and divide by 1000

  00029	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  0002e	48 d1 e0	 shl	 rax, 1
  00031	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 586  :                                        (bit-shift compressed)        */
; 587  :     result  /= 125;                 /* ...                           */

  00036	33 d2		 xor	 edx, edx
  00038	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  0003d	b9 7d 00 00 00	 mov	 ecx, 125		; 0000007dH
  00042	48 f7 f1	 div	 rcx
  00045	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 588  :     temp     = time.tv_sec;         /* Load seconds                  */

  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR time$1[rsp]
  0004f	48 89 44 24 28	 mov	 QWORD PTR temp$[rsp], rax

; 589  :    }
; 590  : #endif /* !defined( _MSVC_ ) && !defined( CLOCK_REALTIME ) */
; 591  : 
; 592  :   temp   *= ETOD_SEC;               /* Convert seconds to ETOD fmt   */

  00054	48 69 44 24 28
	00 24 f4 00	 imul	 rax, QWORD PTR temp$[rsp], 16000000 ; 00f42400H
  0005d	48 89 44 24 28	 mov	 QWORD PTR temp$[rsp], rax

; 593  :   result += temp;                   /* Add seconds                   */

  00062	48 8b 44 24 28	 mov	 rax, QWORD PTR temp$[rsp]
  00067	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  0006c	48 03 c8	 add	 rcx, rax
  0006f	48 8b c1	 mov	 rax, rcx
  00072	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 594  :   result += ETOD_1970;              /* Adjust to epoch 1970          */

  00077	48 b8 00 00 ca
	8b 04 91 7d 00	 mov	 rax, 35343820800000000	; 007d91048bca0000H
  00081	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00086	48 03 c8	 add	 rcx, rax
  00089	48 8b c1	 mov	 rax, rcx
  0008c	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 595  :   return ( result );

  00091	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]

; 596  : }

  00096	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0009b	48 33 cc	 xor	 rcx, rsp
  0009e	e8 00 00 00 00	 call	 __security_check_cookie
  000a3	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000a7	c3		 ret	 0
host_tod ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\extstring.h
_TEXT	SEGMENT
tv84 = 32
tv73 = 36
tv93 = 40
a$ = 48
s$ = 56
string$ = 80
abbrev$ = 88
n$ = 96
strcaseabbrev PROC

; 91   : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 92   :     register const char *s = string;

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00018	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax

; 93   :     register const char *a = abbrev;

  0001d	48 8b 44 24 58	 mov	 rax, QWORD PTR abbrev$[rsp]
  00022	48 89 44 24 30	 mov	 QWORD PTR a$[rsp], rax

; 94   :     if (*a &&
; 95   :         *s &&

  00027	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0002c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0002f	85 c0		 test	 eax, eax
  00031	0f 84 02 01 00
	00		 je	 $LN5@strcaseabb
  00037	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  0003c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0003f	85 c0		 test	 eax, eax
  00041	0f 84 f2 00 00
	00		 je	 $LN5@strcaseabb
  00047	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0004c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0004f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00054	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  00057	3b c1		 cmp	 eax, ecx
  00059	74 30		 je	 SHORT $LN6@strcaseabb
  0005b	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00060	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00063	e8 00 00 00 00	 call	 asciitoupper
  00068	0f be c0	 movsx	 eax, al
  0006b	89 44 24 24	 mov	 DWORD PTR tv73[rsp], eax
  0006f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00074	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00077	e8 00 00 00 00	 call	 asciitoupper
  0007c	0f be c0	 movsx	 eax, al
  0007f	8b 4c 24 24	 mov	 ecx, DWORD PTR tv73[rsp]
  00083	3b c8		 cmp	 ecx, eax
  00085	0f 85 ae 00 00
	00		 jne	 $LN5@strcaseabb
$LN6@strcaseabb:
$LN2@strcaseabb:

; 96   :         (*a == *s ||
; 97   :         asciitoupper(*a) == asciitoupper(*s)))
; 98   :     {
; 99   :         for (;;)
; 100  :         {
; 101  :             a++;

  0008b	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00090	48 ff c0	 inc	 rax
  00093	48 89 44 24 30	 mov	 QWORD PTR a$[rsp], rax

; 102  :             if (!*a)

  00098	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0009d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000a0	85 c0		 test	 eax, eax
  000a2	75 31		 jne	 SHORT $LN7@strcaseabb

; 103  :                 return (((uintptr_t)a - (uintptr_t)abbrev) >= n);

  000a4	48 8b 44 24 58	 mov	 rax, QWORD PTR abbrev$[rsp]
  000a9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  000ae	48 2b c8	 sub	 rcx, rax
  000b1	48 8b c1	 mov	 rax, rcx
  000b4	8b 4c 24 60	 mov	 ecx, DWORD PTR n$[rsp]
  000b8	48 3b c1	 cmp	 rax, rcx
  000bb	72 0a		 jb	 SHORT $LN12@strcaseabb
  000bd	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv84[rsp], 1
  000c5	eb 08		 jmp	 SHORT $LN13@strcaseabb
$LN12@strcaseabb:
  000c7	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
$LN13@strcaseabb:
  000cf	8b 44 24 20	 mov	 eax, DWORD PTR tv84[rsp]
  000d3	eb 66		 jmp	 SHORT $LN1@strcaseabb
$LN7@strcaseabb:

; 104  :             s++;

  000d5	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  000da	48 ff c0	 inc	 rax
  000dd	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax

; 105  :             if (!*s)

  000e2	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  000e7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ea	85 c0		 test	 eax, eax
  000ec	75 02		 jne	 SHORT $LN8@strcaseabb

; 106  :                 break;

  000ee	eb 49		 jmp	 SHORT $LN3@strcaseabb
$LN8@strcaseabb:

; 107  :             if (*a == *s)

  000f0	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  000f5	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000f8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  000fd	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  00100	3b c1		 cmp	 eax, ecx
  00102	75 02		 jne	 SHORT $LN9@strcaseabb

; 108  :                 continue;

  00104	eb 85		 jmp	 SHORT $LN2@strcaseabb
$LN9@strcaseabb:

; 109  :             if (asciitoupper(*a) != asciitoupper(*s))

  00106	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0010b	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0010e	e8 00 00 00 00	 call	 asciitoupper
  00113	0f be c0	 movsx	 eax, al
  00116	89 44 24 28	 mov	 DWORD PTR tv93[rsp], eax
  0011a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  0011f	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00122	e8 00 00 00 00	 call	 asciitoupper
  00127	0f be c0	 movsx	 eax, al
  0012a	8b 4c 24 28	 mov	 ecx, DWORD PTR tv93[rsp]
  0012e	3b c8		 cmp	 ecx, eax
  00130	74 02		 je	 SHORT $LN10@strcaseabb

; 110  :                 break;

  00132	eb 05		 jmp	 SHORT $LN3@strcaseabb
$LN10@strcaseabb:

; 111  :         }

  00134	e9 52 ff ff ff	 jmp	 $LN2@strcaseabb
$LN3@strcaseabb:
$LN5@strcaseabb:

; 112  :     }
; 113  :     return 0;

  00139	33 c0		 xor	 eax, eax
$LN1@strcaseabb:

; 114  : }

  0013b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0013f	c3		 ret	 0
strcaseabbrev ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\extstring.h
_TEXT	SEGMENT
c$ = 8
asciitoupper PROC

; 29   : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 30   :   if (c < 'a' || c > 'z')

  00004	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00009	83 f8 61	 cmp	 eax, 97			; 00000061H
  0000c	7c 0a		 jl	 SHORT $LN3@asciitoupp
  0000e	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00013	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  00016	7e 07		 jle	 SHORT $LN2@asciitoupp
$LN3@asciitoupp:

; 31   :       return c;

  00018	0f b6 44 24 08	 movzx	 eax, BYTE PTR c$[rsp]
  0001d	eb 08		 jmp	 SHORT $LN1@asciitoupp
$LN2@asciitoupp:

; 32   :   return (c - 32);

  0001f	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00024	83 e8 20	 sub	 eax, 32			; 00000020H
$LN1@asciitoupp:

; 33   : }

  00027	c3		 ret	 0
asciitoupper ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hmalloc.h
_TEXT	SEGMENT
result$ = 32
size$ = 64
alignment$ = 72
calloc_aligned PROC

; 151  :     {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 152  :         void* result;
; 153  : 
; 154  :         if (!size)

  0000f	48 83 7c 24 40
	00		 cmp	 QWORD PTR size$[rsp], 0
  00015	75 04		 jne	 SHORT $LN2@calloc_ali

; 155  :         {
; 156  :             return (NULL);

  00017	33 c0		 xor	 eax, eax
  00019	eb 30		 jmp	 SHORT $LN1@calloc_ali
$LN2@calloc_ali:

; 157  :         }
; 158  : 
; 159  :         result = _aligned_malloc(size, alignment);

  0001b	48 8b 54 24 48	 mov	 rdx, QWORD PTR alignment$[rsp]
  00020	48 8b 4c 24 40	 mov	 rcx, QWORD PTR size$[rsp]
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_malloc
  0002b	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 160  : 
; 161  :         if (result != NULL)

  00030	48 83 7c 24 20
	00		 cmp	 QWORD PTR result$[rsp], 0
  00036	74 0e		 je	 SHORT $LN3@calloc_ali

; 162  :         {
; 163  :             memset(result, 0, size);

  00038	48 8b 7c 24 20	 mov	 rdi, QWORD PTR result$[rsp]
  0003d	33 c0		 xor	 eax, eax
  0003f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR size$[rsp]
  00044	f3 aa		 rep stosb
$LN3@calloc_ali:

; 164  :         }
; 165  : 
; 166  :         return (result);

  00046	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
$LN1@calloc_ali:

; 167  :     }

  0004b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004f	5f		 pop	 rdi
  00050	c3		 ret	 0
calloc_aligned ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
ht$1 = 32
tv72 = 40
tid$ = 64
buffer16$ = 72
hthread_get_thread_name PROC

; 1471 : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1472 :     LockThreadsList();

  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:threadlock
  00014	e8 00 00 00 00	 call	 fthread_mutex_lock

; 1473 :     {
; 1474 :         HTHREAD* ht = hthread_find_HTHREAD_locked( tid, NULL );

  00019	33 d2		 xor	 edx, edx
  0001b	8b 4c 24 40	 mov	 ecx, DWORD PTR tid$[rsp]
  0001f	e8 00 00 00 00	 call	 hthread_find_HTHREAD_locked
  00024	48 89 44 24 20	 mov	 QWORD PTR ht$1[rsp], rax

; 1475 :         strlcpy( buffer16, ht ? ht->ht_name : "", 16 );

  00029	48 83 7c 24 20
	00		 cmp	 QWORD PTR ht$1[rsp], 0
  0002f	74 10		 je	 SHORT $LN3@hthread_ge
  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR ht$1[rsp]
  00036	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0003a	48 89 44 24 28	 mov	 QWORD PTR tv72[rsp], rax
  0003f	eb 0c		 jmp	 SHORT $LN4@hthread_ge
$LN3@hthread_ge:
  00041	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160098
  00048	48 89 44 24 28	 mov	 QWORD PTR tv72[rsp], rax
$LN4@hthread_ge:
  0004d	41 b8 10 00 00
	00		 mov	 r8d, 16
  00053	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv72[rsp]
  00058	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buffer16$[rsp]
  0005d	e8 00 00 00 00	 call	 strlcpy

; 1476 :     }
; 1477 :     UnlockThreadsList();

  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:threadlock
  00069	e8 00 00 00 00	 call	 fthread_mutex_unlock

; 1478 :     return buffer16;

  0006e	48 8b 44 24 48	 mov	 rax, QWORD PTR buffer16$[rsp]

; 1479 : }

  00073	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00077	c3		 ret	 0
hthread_get_thread_name ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
ht$1 = 32
tid$ = 64
name$ = 72
hthread_set_thread_name PROC

; 1436 : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1437 :     if (!inited)

  0000d	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR inited
  00014	85 c0		 test	 eax, eax
  00016	75 05		 jne	 SHORT $LN2@hthread_se

; 1438 :         hthreads_internal_init();

  00018	e8 00 00 00 00	 call	 hthreads_internal_init
$LN2@hthread_se:

; 1439 : 
; 1440 :     LockThreadsList();

  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:threadlock
  00024	e8 00 00 00 00	 call	 fthread_mutex_lock

; 1441 :     {
; 1442 :         HTHREAD* ht = hthread_find_HTHREAD_locked( tid, NULL );

  00029	33 d2		 xor	 edx, edx
  0002b	8b 4c 24 40	 mov	 ecx, DWORD PTR tid$[rsp]
  0002f	e8 00 00 00 00	 call	 hthread_find_HTHREAD_locked
  00034	48 89 44 24 20	 mov	 QWORD PTR ht$1[rsp], rax

; 1443 :         if (ht)

  00039	48 83 7c 24 20
	00		 cmp	 QWORD PTR ht$1[rsp], 0
  0003f	74 23		 je	 SHORT $LN3@hthread_se

; 1444 :         {
; 1445 :             free( ht->ht_name );

  00041	48 8b 44 24 20	 mov	 rax, QWORD PTR ht$1[rsp]
  00046	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1446 :             ht->ht_name = strdup( name );

  00050	48 8b 4c 24 48	 mov	 rcx, QWORD PTR name$[rsp]
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0005b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ht$1[rsp]
  00060	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax
$LN3@hthread_se:

; 1447 :         }
; 1448 :     }
; 1449 :     UnlockThreadsList();

  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:threadlock
  0006b	e8 00 00 00 00	 call	 fthread_mutex_unlock

; 1450 : }

  00070	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00074	c3		 ret	 0
hthread_set_thread_name ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
ilk$1 = 32
tv70 = 40
name$ = 48
plk$ = 80
hthread_get_lock_name PROC

; 1456 : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1457 :     const char* name;
; 1458 :     LockLocksList();

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:listlock
  00010	e8 00 00 00 00	 call	 fthread_mutex_lock

; 1459 :     {
; 1460 :         ILOCK* ilk = hthreads_find_ILOCK_locked( plk, NULL );

  00015	33 d2		 xor	 edx, edx
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR plk$[rsp]
  0001c	e8 00 00 00 00	 call	 hthreads_find_ILOCK_locked
  00021	48 89 44 24 20	 mov	 QWORD PTR ilk$1[rsp], rax

; 1461 :         name = ilk ? ilk->il_name : "";

  00026	48 83 7c 24 20
	00		 cmp	 QWORD PTR ilk$1[rsp], 0
  0002c	74 10		 je	 SHORT $LN3@hthread_ge
  0002e	48 8b 44 24 20	 mov	 rax, QWORD PTR ilk$1[rsp]
  00033	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00037	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
  0003c	eb 0c		 jmp	 SHORT $LN4@hthread_ge
$LN3@hthread_ge:
  0003e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160090
  00045	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
$LN4@hthread_ge:
  0004a	48 8b 44 24 28	 mov	 rax, QWORD PTR tv70[rsp]
  0004f	48 89 44 24 30	 mov	 QWORD PTR name$[rsp], rax

; 1462 :     }
; 1463 :     UnlockLocksList();

  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:listlock
  0005b	e8 00 00 00 00	 call	 fthread_mutex_unlock

; 1464 :     return name;

  00060	48 8b 44 24 30	 mov	 rax, QWORD PTR name$[rsp]

; 1465 : }

  00065	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00069	c3		 ret	 0
hthread_get_lock_name ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
ilk$1 = 32
plk$ = 64
name$ = 72
hthread_set_lock_name PROC

; 1419 : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1420 :     LockLocksList();

  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:listlock
  00015	e8 00 00 00 00	 call	 fthread_mutex_lock

; 1421 :     {
; 1422 :         ILOCK* ilk = hthreads_find_ILOCK_locked( plk, NULL );

  0001a	33 d2		 xor	 edx, edx
  0001c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR plk$[rsp]
  00021	e8 00 00 00 00	 call	 hthreads_find_ILOCK_locked
  00026	48 89 44 24 20	 mov	 QWORD PTR ilk$1[rsp], rax

; 1423 :         if (ilk)

  0002b	48 83 7c 24 20
	00		 cmp	 QWORD PTR ilk$1[rsp], 0
  00031	74 23		 je	 SHORT $LN2@hthread_se

; 1424 :         {
; 1425 :             free( ilk->il_name );

  00033	48 8b 44 24 20	 mov	 rax, QWORD PTR ilk$1[rsp]
  00038	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1426 :             ilk->il_name = strdup( name );

  00042	48 8b 4c 24 48	 mov	 rcx, QWORD PTR name$[rsp]
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ilk$1[rsp]
  00052	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
$LN2@hthread_se:

; 1427 :         }
; 1428 :     }
; 1429 :     UnlockLocksList();

  00056	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:listlock
  0005d	e8 00 00 00 00	 call	 fthread_mutex_unlock

; 1430 : }

  00062	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00066	c3		 ret	 0
hthread_set_lock_name ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
i$ = 32
deadlocked$ = 36
ht_count$ = 40
ilk_count$ = 44
ht$ = 48
ilk$ = 56
ilk_anchor$ = 64
ht_anchor$ = 80
sev$ = 112
hthread_report_deadlocks PROC

; 1787 : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1788 :     HTHREAD*    ht;                 /* Private threads array         */
; 1789 :     LIST_ENTRY  ht_anchor;          /* Private threads array anchor  */
; 1790 :     int         ht_count;           /* Number of entries in array    */
; 1791 :     ILOCK*      ilk;                /* Private locks array           */
; 1792 :     LIST_ENTRY  ilk_anchor;         /* Private locks array anchor    */
; 1793 :     int         ilk_count;          /* Number of entries in array    */
; 1794 :     int         i, deadlocked = 0;  /* Work variables                */

  00009	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR deadlocked$[rsp], 0

; 1795 : 
; 1796 :     /* Retrieve a private array copy of both lists */
; 1797 :     ht_count  = hthreads_copy_threads_list ( &ht,  &ht_anchor  );

  00011	48 8d 54 24 50	 lea	 rdx, QWORD PTR ht_anchor$[rsp]
  00016	48 8d 4c 24 30	 lea	 rcx, QWORD PTR ht$[rsp]
  0001b	e8 00 00 00 00	 call	 hthreads_copy_threads_list
  00020	89 44 24 28	 mov	 DWORD PTR ht_count$[rsp], eax

; 1798 :     ilk_count = hthreads_copy_locks_list   ( &ilk, &ilk_anchor );

  00024	48 8d 54 24 40	 lea	 rdx, QWORD PTR ilk_anchor$[rsp]
  00029	48 8d 4c 24 38	 lea	 rcx, QWORD PTR ilk$[rsp]
  0002e	e8 00 00 00 00	 call	 hthreads_copy_locks_list
  00033	89 44 24 2c	 mov	 DWORD PTR ilk_count$[rsp], eax

; 1799 : 
; 1800 :     /* Check each thread in our array */
; 1801 :     for (i=0; i < ht_count; i++)

  00037	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0003f	eb 0a		 jmp	 SHORT $LN4@hthread_re
$LN2@hthread_re:
  00041	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00045	ff c0		 inc	 eax
  00047	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@hthread_re:
  0004b	8b 44 24 28	 mov	 eax, DWORD PTR ht_count$[rsp]
  0004f	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00053	7d 39		 jge	 SHORT $LN3@hthread_re

; 1802 :         if (hthread_is_deadlocked_locked( sev, ht[i].ht_tid, &ht_anchor, &ilk_anchor ))

  00055	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0005a	48 6b c0 50	 imul	 rax, rax, 80		; 00000050H
  0005e	4c 8d 4c 24 40	 lea	 r9, QWORD PTR ilk_anchor$[rsp]
  00063	4c 8d 44 24 50	 lea	 r8, QWORD PTR ht_anchor$[rsp]
  00068	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ht$[rsp]
  0006d	8b 54 01 20	 mov	 edx, DWORD PTR [rcx+rax+32]
  00071	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sev$[rsp]
  00076	e8 00 00 00 00	 call	 hthread_is_deadlocked_locked
  0007b	0f b6 c0	 movzx	 eax, al
  0007e	85 c0		 test	 eax, eax
  00080	74 0a		 je	 SHORT $LN11@hthread_re

; 1803 :             deadlocked++; /* count deadlocked threads */

  00082	8b 44 24 24	 mov	 eax, DWORD PTR deadlocked$[rsp]
  00086	ff c0		 inc	 eax
  00088	89 44 24 24	 mov	 DWORD PTR deadlocked$[rsp], eax
$LN11@hthread_re:
  0008c	eb b3		 jmp	 SHORT $LN2@hthread_re
$LN3@hthread_re:

; 1804 : 
; 1805 :     /* Free our private array copies of both lists */
; 1806 :     for (i=0; i < ht_count; i++)

  0008e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00096	eb 0a		 jmp	 SHORT $LN7@hthread_re
$LN5@hthread_re:
  00098	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0009c	ff c0		 inc	 eax
  0009e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@hthread_re:
  000a2	8b 44 24 28	 mov	 eax, DWORD PTR ht_count$[rsp]
  000a6	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  000aa	7d 1b		 jge	 SHORT $LN6@hthread_re

; 1807 :         free( ht[i].ht_name );

  000ac	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000b1	48 6b c0 50	 imul	 rax, rax, 80		; 00000050H
  000b5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ht$[rsp]
  000ba	48 8b 4c 01 40	 mov	 rcx, QWORD PTR [rcx+rax+64]
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  000c5	eb d1		 jmp	 SHORT $LN5@hthread_re
$LN6@hthread_re:

; 1808 :     free( ht );

  000c7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ht$[rsp]
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1809 :     for (i=0; i < ilk_count; i++)

  000d2	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000da	eb 0a		 jmp	 SHORT $LN10@hthread_re
$LN8@hthread_re:
  000dc	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000e0	ff c0		 inc	 eax
  000e2	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN10@hthread_re:
  000e6	8b 44 24 2c	 mov	 eax, DWORD PTR ilk_count$[rsp]
  000ea	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  000ee	7d 1b		 jge	 SHORT $LN9@hthread_re

; 1810 :         free( ilk[i].il_name );

  000f0	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000f5	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000f9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ilk$[rsp]
  000fe	48 8b 4c 01 18	 mov	 rcx, QWORD PTR [rcx+rax+24]
  00103	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00109	eb d1		 jmp	 SHORT $LN8@hthread_re
$LN9@hthread_re:

; 1811 :     free( ilk );

  0010b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ilk$[rsp]
  00110	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1812 : 
; 1813 :     /* Return number of deadlocked threads detected */
; 1814 :     return deadlocked;

  00116	8b 44 24 24	 mov	 eax, DWORD PTR deadlocked$[rsp]

; 1815 : }

  0011a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0011e	c3		 ret	 0
hthread_report_deadlocks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 96
param$ = 100
prio$ = 104
policy$ = 108
tv81 = 112
tv85 = 120
tid$ = 144
prio_loc$ = 152
hthread_get_thread_prio PROC

; 1182 : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	57		 push	 rdi
  0000a	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 1183 :     int rc, policy, prio;
; 1184 :     struct sched_param  param = {0};

  00011	48 8d 44 24 64	 lea	 rax, QWORD PTR param$[rsp]
  00016	48 8b f8	 mov	 rdi, rax
  00019	33 c0		 xor	 eax, eax
  0001b	b9 04 00 00 00	 mov	 ecx, 4
  00020	f3 aa		 rep stosb

; 1185 : 
; 1186 :     if (equal_threads( tid, 0 ))

  00022	33 d2		 xor	 edx, edx
  00024	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tid$[rsp]
  0002b	e8 00 00 00 00	 call	 hthread_equal_threads
  00030	85 c0		 test	 eax, eax
  00032	74 0c		 je	 SHORT $LN2@hthread_ge

; 1187 :         tid = hthread_self();

  00034	e8 00 00 00 00	 call	 fthread_self
  00039	89 84 24 90 00
	00 00		 mov	 DWORD PTR tid$[rsp], eax
$LN2@hthread_ge:

; 1188 : 
; 1189 :     SETMODE( ROOT );
; 1190 :     {
; 1191 :         rc = hthread_getschedparam( tid, &policy, &param );

  00040	4c 8d 44 24 64	 lea	 r8, QWORD PTR param$[rsp]
  00045	48 8d 54 24 6c	 lea	 rdx, QWORD PTR policy$[rsp]
  0004a	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tid$[rsp]
  00051	e8 00 00 00 00	 call	 fthread_getschedparam
  00056	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 1192 :     }
; 1193 :     SETMODE( USER );
; 1194 : 
; 1195 :     /* Convert pthread priority to hthread priority relative to 0 */
; 1196 :     prio = param.sched_priority - sysblk.minprio;

  0005a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00061	8b 80 5c 13 00
	00		 mov	 eax, DWORD PTR [rax+4956]
  00067	8b 4c 24 64	 mov	 ecx, DWORD PTR param$[rsp]
  0006b	2b c8		 sub	 ecx, eax
  0006d	8b c1		 mov	 eax, ecx
  0006f	89 44 24 68	 mov	 DWORD PTR prio$[rsp], eax

; 1197 : 
; 1198 :     if (rc != 0)

  00073	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  00078	0f 84 a1 00 00
	00		 je	 $LN3@hthread_ge

; 1199 :     {
; 1200 :         prio = -1;  /* (return negative value to indicate error) */

  0007e	c7 44 24 68 ff
	ff ff ff	 mov	 DWORD PTR prio$[rsp], -1

; 1201 : 
; 1202 :         if (EPERM != rc)

  00086	83 7c 24 60 01	 cmp	 DWORD PTR rc$[rsp], 1
  0008b	0f 84 8e 00 00
	00		 je	 $LN4@hthread_ge

; 1203 :         {
; 1204 :             // "'%s' failed at loc=%s: rc=%d: %s"
; 1205 :             WRMSG( HHC90020, "W", "hthread_getschedparam()",

  00091	8b 4c 24 60	 mov	 ecx, DWORD PTR rc$[rsp]
  00095	e8 00 00 00 00	 call	 w32_strerror
  0009a	48 89 44 24 70	 mov	 QWORD PTR tv81[rsp], rax
  0009f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR prio_loc$[rsp]
  000a7	e8 00 00 00 00	 call	 trimloc
  000ac	48 89 44 24 78	 mov	 QWORD PTR tv85[rsp], rax
  000b1	b9 01 00 00 00	 mov	 ecx, 1
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000bc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv81[rsp]
  000c1	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000c6	8b 4c 24 60	 mov	 ecx, DWORD PTR rc$[rsp]
  000ca	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  000ce	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv85[rsp]
  000d3	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159877
  000df	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159878
  000eb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159879
  000f7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000fc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00101	41 b9 03 00 00
	00		 mov	 r9d, 3
  00107	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159880
  0010e	ba b6 04 00 00	 mov	 edx, 1206		; 000004b6H
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159881
  0011a	e8 00 00 00 00	 call	 fwritemsg
$LN4@hthread_ge:
$LN3@hthread_ge:

; 1206 :                 TRIMLOC( prio_loc ), rc, strerror( rc ));
; 1207 :         }
; 1208 :     }
; 1209 :     return prio;

  0011f	8b 44 24 68	 mov	 eax, DWORD PTR prio$[rsp]

; 1210 : }

  00123	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  0012a	5f		 pop	 rdi
  0012b	c3		 ret	 0
hthread_get_thread_prio ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 96
param$ = 100
tv81 = 104
tv85 = 112
tid$ = 144
prio$ = 152
prio_loc$ = 160
hthread_set_thread_prio PROC

; 1150 : {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	57		 push	 rdi
  0000e	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 1151 :     int rc;
; 1152 :     struct sched_param param = {0};

  00015	48 8d 44 24 64	 lea	 rax, QWORD PTR param$[rsp]
  0001a	48 8b f8	 mov	 rdi, rax
  0001d	33 c0		 xor	 eax, eax
  0001f	b9 04 00 00 00	 mov	 ecx, 4
  00024	f3 aa		 rep stosb

; 1153 : 
; 1154 :     /* Convert hthread priority relative to 0 to pthread priority */
; 1155 :     param.sched_priority = sysblk.minprio + prio;

  00026	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002d	8b 80 5c 13 00
	00		 mov	 eax, DWORD PTR [rax+4956]
  00033	03 84 24 98 00
	00 00		 add	 eax, DWORD PTR prio$[rsp]
  0003a	89 44 24 64	 mov	 DWORD PTR param$[rsp], eax

; 1156 : 
; 1157 :     if (equal_threads( tid, 0 ))

  0003e	33 d2		 xor	 edx, edx
  00040	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tid$[rsp]
  00047	e8 00 00 00 00	 call	 hthread_equal_threads
  0004c	85 c0		 test	 eax, eax
  0004e	74 0c		 je	 SHORT $LN2@hthread_se

; 1158 :         tid = hthread_self();

  00050	e8 00 00 00 00	 call	 fthread_self
  00055	89 84 24 90 00
	00 00		 mov	 DWORD PTR tid$[rsp], eax
$LN2@hthread_se:

; 1159 : 
; 1160 :     SETMODE( ROOT );
; 1161 :     {
; 1162 :         rc = hthread_setschedparam( tid, HTHREAD_POLICY, &param );

  0005c	4c 8d 44 24 64	 lea	 r8, QWORD PTR param$[rsp]
  00061	ba 01 00 00 00	 mov	 edx, 1
  00066	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tid$[rsp]
  0006d	e8 00 00 00 00	 call	 fthread_setschedparam
  00072	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 1163 :     }
; 1164 :     SETMODE( USER );
; 1165 : 
; 1166 :     if (rc != 0)

  00076	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  0007b	0f 84 99 00 00
	00		 je	 $LN3@hthread_se

; 1167 :     {
; 1168 :         if (EPERM != rc)

  00081	83 7c 24 60 01	 cmp	 DWORD PTR rc$[rsp], 1
  00086	0f 84 8e 00 00
	00		 je	 $LN4@hthread_se

; 1169 :         {
; 1170 :             // "'%s' failed at loc=%s: rc=%d: %s"
; 1171 :             WRMSG( HHC90020, "W", "hthread_setschedparam()",

  0008c	8b 4c 24 60	 mov	 ecx, DWORD PTR rc$[rsp]
  00090	e8 00 00 00 00	 call	 w32_strerror
  00095	48 89 44 24 68	 mov	 QWORD PTR tv81[rsp], rax
  0009a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR prio_loc$[rsp]
  000a2	e8 00 00 00 00	 call	 trimloc
  000a7	48 89 44 24 70	 mov	 QWORD PTR tv85[rsp], rax
  000ac	b9 01 00 00 00	 mov	 ecx, 1
  000b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv81[rsp]
  000bc	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000c1	8b 4c 24 60	 mov	 ecx, DWORD PTR rc$[rsp]
  000c5	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  000c9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv85[rsp]
  000ce	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159859
  000da	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159860
  000e6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159861
  000f2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000f7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000fc	41 b9 03 00 00
	00		 mov	 r9d, 3
  00102	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159862
  00109	ba 94 04 00 00	 mov	 edx, 1172		; 00000494H
  0010e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159863
  00115	e8 00 00 00 00	 call	 fwritemsg
$LN4@hthread_se:
$LN3@hthread_se:

; 1172 :                 TRIMLOC( prio_loc ), rc, strerror( rc ));
; 1173 :         }
; 1174 :     }
; 1175 :     return rc;

  0011a	8b 44 24 60	 mov	 eax, DWORD PTR rc$[rsp]

; 1176 : }

  0011e	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00125	5f		 pop	 rdi
  00126	c3		 ret	 0
hthread_set_thread_prio ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 32
tid1$ = 64
tid2$ = 72
hthread_equal_threads PROC

; 1140 : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1141 :     int rc;
; 1142 :     rc = hthread_equal( tid1, tid2 );

  0000c	8b 54 24 48	 mov	 edx, DWORD PTR tid2$[rsp]
  00010	8b 4c 24 40	 mov	 ecx, DWORD PTR tid1$[rsp]
  00014	e8 00 00 00 00	 call	 fthread_equal
  00019	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1143 :     return rc;

  0001d	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 1144 : }

  00021	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00025	c3		 ret	 0
hthread_equal_threads ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
tid$ = 32
rc$ = 64
exit_loc$ = 72
hthread_exit_thread PROC

; 1129 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1130 :     TID tid;
; 1131 :     tid = hthread_self();

  0000e	e8 00 00 00 00	 call	 fthread_self
  00013	89 44 24 20	 mov	 DWORD PTR tid$[rsp], eax

; 1132 :     hthread_has_exited( tid, exit_loc );

  00017	48 8b 54 24 48	 mov	 rdx, QWORD PTR exit_loc$[rsp]
  0001c	8b 4c 24 20	 mov	 ecx, DWORD PTR tid$[rsp]
  00020	e8 00 00 00 00	 call	 hthread_has_exited

; 1133 :     hthread_exit( rc );

  00025	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rc$[rsp]
  0002a	e8 00 00 00 00	 call	 fthread_exit

; 1134 : }

  0002f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00033	c3		 ret	 0
hthread_exit_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 64
tid$ = 96
det_loc$ = 104
hthread_detach_thread PROC

; 1117 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@hthread_de:

; 1118 :     int rc;
; 1119 :     PTTRACE( "dtch before", (void*) tid, NULL, det_loc, PTT_MAGIC );

  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  00014	48 83 e0 04	 and	 rax, 4
  00018	48 85 c0	 test	 rax, rax
  0001b	74 37		 je	 SHORT $LN8@hthread_de
  0001d	8b 44 24 60	 mov	 eax, DWORD PTR tid$[rsp]
  00021	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0002a	48 c7 44 24 28
	9d ff ff ff	 mov	 QWORD PTR [rsp+40], -99	; ffffffffffffff9dH
  00033	48 8b 4c 24 68	 mov	 rcx, QWORD PTR det_loc$[rsp]
  00038	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0003d	45 33 c9	 xor	 r9d, r9d
  00040	44 8b c0	 mov	 r8d, eax
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159829
  0004a	b9 04 00 00 00	 mov	 ecx, 4
  0004f	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN8@hthread_de:
  00054	33 c0		 xor	 eax, eax
  00056	85 c0		 test	 eax, eax
  00058	75 b3		 jne	 SHORT $LN4@hthread_de

; 1120 :     rc = hthread_detach( tid );

  0005a	8b 4c 24 60	 mov	 ecx, DWORD PTR tid$[rsp]
  0005e	e8 00 00 00 00	 call	 fthread_detach
  00063	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax
$LN7@hthread_de:

; 1121 :     PTTRACE( "dtch after", (void*) tid, NULL, det_loc, rc );

  00067	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  0006e	48 83 e0 04	 and	 rax, 4
  00072	48 85 c0	 test	 rax, rax
  00075	74 38		 je	 SHORT $LN9@hthread_de
  00077	48 63 44 24 40	 movsxd	 rax, DWORD PTR rc$[rsp]
  0007c	8b 4c 24 60	 mov	 ecx, DWORD PTR tid$[rsp]
  00080	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00089	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0008e	48 8b 44 24 68	 mov	 rax, QWORD PTR det_loc$[rsp]
  00093	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00098	45 33 c9	 xor	 r9d, r9d
  0009b	44 8b c1	 mov	 r8d, ecx
  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159831
  000a5	b9 04 00 00 00	 mov	 ecx, 4
  000aa	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN9@hthread_de:
  000af	33 c0		 xor	 eax, eax
  000b1	85 c0		 test	 eax, eax
  000b3	75 b2		 jne	 SHORT $LN7@hthread_de

; 1122 :     return rc;

  000b5	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]

; 1123 : }

  000b9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000bd	c3		 ret	 0
hthread_detach_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 64
tv70 = 72
tv87 = 80
tid$ = 112
prc$ = 120
join_loc$ = 128
hthread_join_thread PROC

; 1105 : {

$LN15:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 68	 sub	 rsp, 104		; 00000068H
$LN4@hthread_jo:

; 1106 :     int rc;
; 1107 :     PTTRACE( "join before", (void*) tid, prc ? *prc : NULL, join_loc, PTT_MAGIC );

  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  00019	48 83 e0 04	 and	 rax, 4
  0001d	48 85 c0	 test	 rax, rax
  00020	74 5c		 je	 SHORT $LN8@hthread_jo
  00022	48 83 7c 24 78
	00		 cmp	 QWORD PTR prc$[rsp], 0
  00028	74 0f		 je	 SHORT $LN11@hthread_jo
  0002a	48 8b 44 24 78	 mov	 rax, QWORD PTR prc$[rsp]
  0002f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00032	48 89 44 24 48	 mov	 QWORD PTR tv70[rsp], rax
  00037	eb 09		 jmp	 SHORT $LN12@hthread_jo
$LN11@hthread_jo:
  00039	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv70[rsp], 0
$LN12@hthread_jo:
  00042	8b 44 24 70	 mov	 eax, DWORD PTR tid$[rsp]
  00046	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0004f	48 c7 44 24 28
	9d ff ff ff	 mov	 QWORD PTR [rsp+40], -99	; ffffffffffffff9dH
  00058	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR join_loc$[rsp]
  00060	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00065	4c 8b 4c 24 48	 mov	 r9, QWORD PTR tv70[rsp]
  0006a	44 8b c0	 mov	 r8d, eax
  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159806
  00074	b9 04 00 00 00	 mov	 ecx, 4
  00079	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN8@hthread_jo:
  0007e	33 c0		 xor	 eax, eax
  00080	85 c0		 test	 eax, eax
  00082	75 8e		 jne	 SHORT $LN4@hthread_jo

; 1108 :     rc = hthread_join( tid, prc );

  00084	48 8b 54 24 78	 mov	 rdx, QWORD PTR prc$[rsp]
  00089	8b 4c 24 70	 mov	 ecx, DWORD PTR tid$[rsp]
  0008d	e8 00 00 00 00	 call	 fthread_join
  00092	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax
$LN7@hthread_jo:

; 1109 :     PTTRACE( "join after",  (void*) tid, prc ? *prc : NULL, join_loc, rc );

  00096	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  0009d	48 83 e0 04	 and	 rax, 4
  000a1	48 85 c0	 test	 rax, rax
  000a4	74 5d		 je	 SHORT $LN9@hthread_jo
  000a6	48 83 7c 24 78
	00		 cmp	 QWORD PTR prc$[rsp], 0
  000ac	74 0f		 je	 SHORT $LN13@hthread_jo
  000ae	48 8b 44 24 78	 mov	 rax, QWORD PTR prc$[rsp]
  000b3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b6	48 89 44 24 50	 mov	 QWORD PTR tv87[rsp], rax
  000bb	eb 09		 jmp	 SHORT $LN14@hthread_jo
$LN13@hthread_jo:
  000bd	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv87[rsp], 0
$LN14@hthread_jo:
  000c6	48 63 44 24 40	 movsxd	 rax, DWORD PTR rc$[rsp]
  000cb	8b 4c 24 70	 mov	 ecx, DWORD PTR tid$[rsp]
  000cf	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000d8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000dd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR join_loc$[rsp]
  000e5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ea	4c 8b 4c 24 50	 mov	 r9, QWORD PTR tv87[rsp]
  000ef	44 8b c1	 mov	 r8d, ecx
  000f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159808
  000f9	b9 04 00 00 00	 mov	 ecx, 4
  000fe	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN9@hthread_jo:
  00103	33 c0		 xor	 eax, eax
  00105	85 c0		 test	 eax, eax
  00107	75 8d		 jne	 SHORT $LN7@hthread_jo

; 1110 :     return rc;

  00109	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]

; 1111 : }

  0010d	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00111	c3		 ret	 0
hthread_join_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 64
ht$1 = 72
arg2$ = 80
_EX_Head$2 = 88
_EX_Next$3 = 96
ptid$ = 128
pat$ = 136
pfn$ = 144
arg$ = 152
name$ = 160
create_loc$ = 168
hthread_create_thread PROC

; 1071 : {

$LN8:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1072 :     int rc;
; 1073 :     void** arg2;
; 1074 :     arg2 = malloc( 3 * sizeof( void* ));

  00018	b9 18 00 00 00	 mov	 ecx, 24
  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00023	48 89 44 24 50	 mov	 QWORD PTR arg2$[rsp], rax

; 1075 :     *(arg2+0) = (void*) pfn;

  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR arg2$[rsp]
  0002d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pfn$[rsp]
  00035	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1076 :     *(arg2+1) = (void*) arg;

  00038	48 8b 44 24 50	 mov	 rax, QWORD PTR arg2$[rsp]
  0003d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  00045	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1077 :     *(arg2+2) = (void*) strdup( name );

  00049	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR name$[rsp]
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00057	48 8b 4c 24 50	 mov	 rcx, QWORD PTR arg2$[rsp]
  0005c	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1078 :     LockThreadsList();

  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:threadlock
  00067	e8 00 00 00 00	 call	 fthread_mutex_lock

; 1079 :     {
; 1080 :         if (0 == (rc = hthread_create( ptid, pat, hthread_func, arg2 )))

  0006c	4c 8b 4c 24 50	 mov	 r9, QWORD PTR arg2$[rsp]
  00071	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:hthread_func
  00078	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pat$[rsp]
  00080	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ptid$[rsp]
  00088	e8 00 00 00 00	 call	 fthread_create
  0008d	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax
  00091	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  00096	0f 85 e4 00 00
	00		 jne	 $LN5@hthread_cr

; 1081 :         {
; 1082 :             HTHREAD* ht = calloc_aligned( sizeof( HTHREAD ), 64 );

  0009c	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  000a1	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  000a6	e8 00 00 00 00	 call	 calloc_aligned
  000ab	48 89 44 24 48	 mov	 QWORD PTR ht$1[rsp], rax

; 1083 : 
; 1084 :             InitializeListLink( &ht->ht_link );

  000b0	48 8b 44 24 48	 mov	 rax, QWORD PTR ht$1[rsp]
  000b5	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  000bd	48 8b 44 24 48	 mov	 rax, QWORD PTR ht$1[rsp]
  000c2	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1085 :             gettimeofday( &ht->ht_cr_time, NULL );

  000c9	48 8b 44 24 48	 mov	 rax, QWORD PTR ht$1[rsp]
  000ce	48 83 c0 18	 add	 rax, 24
  000d2	33 d2		 xor	 edx, edx
  000d4	48 8b c8	 mov	 rcx, rax
  000d7	e8 00 00 00 00	 call	 gettimeofday

; 1086 : 
; 1087 :             ht->ht_cr_locat =  create_loc;

  000dc	48 8b 44 24 48	 mov	 rax, QWORD PTR ht$1[rsp]
  000e1	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR create_loc$[rsp]
  000e9	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1088 :             ht->ht_name     =  strdup( name );

  000ed	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR name$[rsp]
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  000fb	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ht$1[rsp]
  00100	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax

; 1089 :             ht->ht_tid      =  *ptid;

  00104	48 8b 44 24 48	 mov	 rax, QWORD PTR ht$1[rsp]
  00109	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ptid$[rsp]
  00111	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00113	89 48 20	 mov	 DWORD PTR [rax+32], ecx

; 1090 :             ht->ht_ob_lock  =  NULL;

  00116	48 8b 44 24 48	 mov	 rax, QWORD PTR ht$1[rsp]
  0011b	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 1091 : 
; 1092 :             InsertListHead( &threadlist, &ht->ht_link );

  00123	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:threadlist
  0012a	48 89 44 24 58	 mov	 QWORD PTR _EX_Head$2[rsp], rax
  0012f	48 8b 44 24 58	 mov	 rax, QWORD PTR _EX_Head$2[rsp]
  00134	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00137	48 89 44 24 60	 mov	 QWORD PTR _EX_Next$3[rsp], rax
  0013c	48 8b 44 24 48	 mov	 rax, QWORD PTR ht$1[rsp]
  00141	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _EX_Next$3[rsp]
  00146	48 89 08	 mov	 QWORD PTR [rax], rcx
  00149	48 8b 44 24 48	 mov	 rax, QWORD PTR ht$1[rsp]
  0014e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _EX_Head$2[rsp]
  00153	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00157	48 8b 44 24 48	 mov	 rax, QWORD PTR ht$1[rsp]
  0015c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _EX_Head$2[rsp]
  00161	48 89 01	 mov	 QWORD PTR [rcx], rax
  00164	48 8b 44 24 48	 mov	 rax, QWORD PTR ht$1[rsp]
  00169	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _EX_Next$3[rsp]
  0016e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1093 :             threadcount++;

  00172	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR threadcount
  00178	ff c0		 inc	 eax
  0017a	89 05 00 00 00
	00		 mov	 DWORD PTR threadcount, eax
$LN5@hthread_cr:

; 1094 :         }
; 1095 :     }
; 1096 :     UnlockThreadsList();

  00180	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:threadlock
  00187	e8 00 00 00 00	 call	 fthread_mutex_unlock
$LN4@hthread_cr:

; 1097 :     PTTRACE( "create", (void*)*ptid, NULL, create_loc, rc );

  0018c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  00193	48 83 e0 04	 and	 rax, 4
  00197	48 85 c0	 test	 rax, rax
  0019a	74 41		 je	 SHORT $LN6@hthread_cr
  0019c	48 63 44 24 40	 movsxd	 rax, DWORD PTR rc$[rsp]
  001a1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ptid$[rsp]
  001a9	8b 09		 mov	 ecx, DWORD PTR [rcx]
  001ab	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001b4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b9	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR create_loc$[rsp]
  001c1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c6	45 33 c9	 xor	 r9d, r9d
  001c9	44 8b c1	 mov	 r8d, ecx
  001cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159783
  001d3	b9 04 00 00 00	 mov	 ecx, 4
  001d8	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN6@hthread_cr:
  001dd	33 c0		 xor	 eax, eax
  001df	85 c0		 test	 eax, eax
  001e1	75 a9		 jne	 SHORT $LN4@hthread_cr

; 1098 :     return rc;

  001e3	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]

; 1099 : }

  001e7	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001eb	c3		 ret	 0
hthread_create_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 32
pat$ = 64
hthread_initialize_detach_attr PROC

; 972  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 973  :     int rc;
; 974  :     rc = hthread_init_thread_attr( pat, HTHREAD_CREATE_DETACHED );

  00009	ba 63 73 69 44	 mov	 edx, 1147761507		; 44697363H
  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pat$[rsp]
  00013	e8 00 00 00 00	 call	 hthread_init_thread_attr
  00018	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 975  :     return rc;

  0001c	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 976  : }

  00020	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00024	c3		 ret	 0
hthread_initialize_detach_attr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 32
pat$ = 64
hthread_initialize_join_attr PROC

; 962  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 963  :     int rc;
; 964  :     rc = hthread_init_thread_attr( pat, HTHREAD_CREATE_JOINABLE );

  00009	ba 6e 69 6f 4a	 mov	 edx, 1248815470		; 4a6f696eH
  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pat$[rsp]
  00013	e8 00 00 00 00	 call	 hthread_init_thread_attr
  00018	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 965  :     return rc;

  0001c	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 966  : }

  00020	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00024	c3		 ret	 0
hthread_initialize_join_attr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 64
ilk$ = 72
plc$ = 96
plk$ = 104
tm$ = 112
wait_loc$ = 120
hthread_timed_wait_condition PROC

; 931  : {

$LN12:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 932  :     int rc;
; 933  :     ILOCK* ilk;
; 934  :     ilk = (ILOCK*) plk->ilk;

  00018	48 8b 44 24 68	 mov	 rax, QWORD PTR plk$[rsp]
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 89 44 24 48	 mov	 QWORD PTR ilk$[rsp], rax
$LN4@hthread_ti:

; 935  :     PTTRACE( "tw before", plk, plc, wait_loc, PTT_MAGIC );

  00025	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  0002c	48 83 e0 04	 and	 rax, 4
  00030	48 85 c0	 test	 rax, rax
  00033	74 37		 je	 SHORT $LN8@hthread_ti
  00035	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0003e	48 c7 44 24 28
	9d ff ff ff	 mov	 QWORD PTR [rsp+40], -99	; ffffffffffffff9dH
  00047	48 8b 44 24 78	 mov	 rax, QWORD PTR wait_loc$[rsp]
  0004c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00051	4c 8b 4c 24 60	 mov	 r9, QWORD PTR plc$[rsp]
  00056	4c 8b 44 24 68	 mov	 r8, QWORD PTR plk$[rsp]
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159657
  00062	b9 04 00 00 00	 mov	 ecx, 4
  00067	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN8@hthread_ti:
  0006c	33 c0		 xor	 eax, eax
  0006e	85 c0		 test	 eax, eax
  00070	75 b3		 jne	 SHORT $LN4@hthread_ti

; 936  :     rc = hthread_cond_timedwait( plc, &ilk->il_lock, tm );

  00072	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  00077	48 83 c0 40	 add	 rax, 64			; 00000040H
  0007b	4c 8b 44 24 70	 mov	 r8, QWORD PTR tm$[rsp]
  00080	48 8b d0	 mov	 rdx, rax
  00083	48 8b 4c 24 60	 mov	 rcx, QWORD PTR plc$[rsp]
  00088	e8 00 00 00 00	 call	 fthread_cond_timedwait
  0008d	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax
$LN7@hthread_ti:

; 937  :     PTTRACE( "tw after", plk, plc, wait_loc, rc );

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  00098	48 83 e0 04	 and	 rax, 4
  0009c	48 85 c0	 test	 rax, rax
  0009f	74 38		 je	 SHORT $LN9@hthread_ti
  000a1	48 63 44 24 40	 movsxd	 rax, DWORD PTR rc$[rsp]
  000a6	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000af	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000b4	48 8b 44 24 78	 mov	 rax, QWORD PTR wait_loc$[rsp]
  000b9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000be	4c 8b 4c 24 60	 mov	 r9, QWORD PTR plc$[rsp]
  000c3	4c 8b 44 24 68	 mov	 r8, QWORD PTR plk$[rsp]
  000c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159659
  000cf	b9 04 00 00 00	 mov	 ecx, 4
  000d4	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN9@hthread_ti:
  000d9	33 c0		 xor	 eax, eax
  000db	85 c0		 test	 eax, eax
  000dd	75 b2		 jne	 SHORT $LN7@hthread_ti

; 938  :     ilk->il_ob_tid = hthread_self();

  000df	e8 00 00 00 00	 call	 fthread_self
  000e4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ilk$[rsp]
  000e9	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 939  :     if (rc && ETIMEDOUT != rc)

  000ec	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  000f1	74 24		 je	 SHORT $LN10@hthread_ti
  000f3	81 7c 24 40 8a
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 138	; 0000008aH
  000fb	74 1a		 je	 SHORT $LN10@hthread_ti

; 940  :         loglock( ilk, rc, "timed_wait_condition", wait_loc );

  000fd	4c 8b 4c 24 78	 mov	 r9, QWORD PTR wait_loc$[rsp]
  00102	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159661
  00109	8b 54 24 40	 mov	 edx, DWORD PTR rc$[rsp]
  0010d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ilk$[rsp]
  00112	e8 00 00 00 00	 call	 loglock
$LN10@hthread_ti:

; 941  :     return rc;

  00117	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]

; 942  : }

  0011b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0011f	c3		 ret	 0
hthread_timed_wait_condition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 64
ilk$ = 72
plc$ = 96
plk$ = 104
wait_loc$ = 112
hthread_wait_condition PROC

; 912  : {

$LN12:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 913  :     int rc;
; 914  :     ILOCK* ilk;
; 915  :     ilk = (ILOCK*) plk->ilk;

  00013	48 8b 44 24 68	 mov	 rax, QWORD PTR plk$[rsp]
  00018	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001b	48 89 44 24 48	 mov	 QWORD PTR ilk$[rsp], rax
$LN4@hthread_wa:

; 916  :     PTTRACE( "wait before", plk, plc, wait_loc, PTT_MAGIC );

  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  00027	48 83 e0 04	 and	 rax, 4
  0002b	48 85 c0	 test	 rax, rax
  0002e	74 37		 je	 SHORT $LN8@hthread_wa
  00030	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00039	48 c7 44 24 28
	9d ff ff ff	 mov	 QWORD PTR [rsp+40], -99	; ffffffffffffff9dH
  00042	48 8b 44 24 70	 mov	 rax, QWORD PTR wait_loc$[rsp]
  00047	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004c	4c 8b 4c 24 60	 mov	 r9, QWORD PTR plc$[rsp]
  00051	4c 8b 44 24 68	 mov	 r8, QWORD PTR plk$[rsp]
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159631
  0005d	b9 04 00 00 00	 mov	 ecx, 4
  00062	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN8@hthread_wa:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 b3		 jne	 SHORT $LN4@hthread_wa

; 917  :     rc = hthread_cond_wait( plc, &ilk->il_lock );

  0006d	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  00072	48 83 c0 40	 add	 rax, 64			; 00000040H
  00076	48 8b d0	 mov	 rdx, rax
  00079	48 8b 4c 24 60	 mov	 rcx, QWORD PTR plc$[rsp]
  0007e	e8 00 00 00 00	 call	 fthread_cond_wait
  00083	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax
$LN7@hthread_wa:

; 918  :     PTTRACE( "wait after", plk, plc, wait_loc, rc );

  00087	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  0008e	48 83 e0 04	 and	 rax, 4
  00092	48 85 c0	 test	 rax, rax
  00095	74 38		 je	 SHORT $LN9@hthread_wa
  00097	48 63 44 24 40	 movsxd	 rax, DWORD PTR rc$[rsp]
  0009c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000a5	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000aa	48 8b 44 24 70	 mov	 rax, QWORD PTR wait_loc$[rsp]
  000af	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b4	4c 8b 4c 24 60	 mov	 r9, QWORD PTR plc$[rsp]
  000b9	4c 8b 44 24 68	 mov	 r8, QWORD PTR plk$[rsp]
  000be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159633
  000c5	b9 04 00 00 00	 mov	 ecx, 4
  000ca	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN9@hthread_wa:
  000cf	33 c0		 xor	 eax, eax
  000d1	85 c0		 test	 eax, eax
  000d3	75 b2		 jne	 SHORT $LN7@hthread_wa

; 919  :     ilk->il_ob_tid = hthread_self();

  000d5	e8 00 00 00 00	 call	 fthread_self
  000da	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ilk$[rsp]
  000df	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 920  :     if (rc)

  000e2	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  000e7	74 1a		 je	 SHORT $LN10@hthread_wa

; 921  :         loglock( ilk, rc, "wait_condition", wait_loc );

  000e9	4c 8b 4c 24 70	 mov	 r9, QWORD PTR wait_loc$[rsp]
  000ee	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159635
  000f5	8b 54 24 40	 mov	 edx, DWORD PTR rc$[rsp]
  000f9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ilk$[rsp]
  000fe	e8 00 00 00 00	 call	 loglock
$LN10@hthread_wa:

; 922  :     return rc;

  00103	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]

; 923  : }

  00107	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0010b	c3		 ret	 0
hthread_wait_condition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 64
plc$ = 96
bcast_loc$ = 104
hthread_broadcast_condition PROC

; 901  : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 902  :     int rc;
; 903  :     rc = hthread_cond_broadcast( plc );

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR plc$[rsp]
  00013	e8 00 00 00 00	 call	 fthread_cond_broadcast
  00018	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax
$LN4@hthread_br:

; 904  :     PTTRACE( "broadcast", NULL, plc, bcast_loc, rc );

  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  00023	48 83 e0 04	 and	 rax, 4
  00027	48 85 c0	 test	 rax, rax
  0002a	74 36		 je	 SHORT $LN5@hthread_br
  0002c	48 63 44 24 40	 movsxd	 rax, DWORD PTR rc$[rsp]
  00031	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0003a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0003f	48 8b 44 24 68	 mov	 rax, QWORD PTR bcast_loc$[rsp]
  00044	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00049	4c 8b 4c 24 60	 mov	 r9, QWORD PTR plc$[rsp]
  0004e	45 33 c0	 xor	 r8d, r8d
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159611
  00058	b9 04 00 00 00	 mov	 ecx, 4
  0005d	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN5@hthread_br:
  00062	33 c0		 xor	 eax, eax
  00064	85 c0		 test	 eax, eax
  00066	75 b4		 jne	 SHORT $LN4@hthread_br

; 905  :     return rc;

  00068	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]

; 906  : }

  0006c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00070	c3		 ret	 0
hthread_broadcast_condition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 64
plc$ = 96
sig_loc$ = 104
hthread_signal_condition PROC

; 890  : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 891  :     int rc;
; 892  :     rc = hthread_cond_signal( plc );

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR plc$[rsp]
  00013	e8 00 00 00 00	 call	 fthread_cond_signal
  00018	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax
$LN4@hthread_si:

; 893  :     PTTRACE( "signal", NULL, plc, sig_loc, rc );

  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  00023	48 83 e0 04	 and	 rax, 4
  00027	48 85 c0	 test	 rax, rax
  0002a	74 36		 je	 SHORT $LN5@hthread_si
  0002c	48 63 44 24 40	 movsxd	 rax, DWORD PTR rc$[rsp]
  00031	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0003a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0003f	48 8b 44 24 68	 mov	 rax, QWORD PTR sig_loc$[rsp]
  00044	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00049	4c 8b 4c 24 60	 mov	 r9, QWORD PTR plc$[rsp]
  0004e	45 33 c0	 xor	 r8d, r8d
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159598
  00058	b9 04 00 00 00	 mov	 ecx, 4
  0005d	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN5@hthread_si:
  00062	33 c0		 xor	 eax, eax
  00064	85 c0		 test	 eax, eax
  00066	75 b4		 jne	 SHORT $LN4@hthread_si

; 894  :     return rc;

  00068	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]

; 895  : }

  0006c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00070	c3		 ret	 0
hthread_signal_condition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 32
plc$ = 64
hthread_destroy_condition PROC

; 880  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 881  :     int rc;
; 882  :     rc = hthread_cond_destroy( plc );

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR plc$[rsp]
  0000e	e8 00 00 00 00	 call	 fthread_cond_destroy
  00013	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 883  :     return rc;

  00017	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 884  : }

  0001b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001f	c3		 ret	 0
hthread_destroy_condition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 64
plc$ = 96
init_loc$ = 104
hthread_initialize_condition PROC

; 869  : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@hthread_in:

; 870  :     int rc;
; 871  :     PTTRACE( "cond init", NULL, plc, init_loc, PTT_MAGIC );

  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  00015	48 83 e0 04	 and	 rax, 4
  00019	48 85 c0	 test	 rax, rax
  0001c	74 35		 je	 SHORT $LN5@hthread_in
  0001e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00027	48 c7 44 24 28
	9d ff ff ff	 mov	 QWORD PTR [rsp+40], -99	; ffffffffffffff9dH
  00030	48 8b 44 24 68	 mov	 rax, QWORD PTR init_loc$[rsp]
  00035	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0003a	4c 8b 4c 24 60	 mov	 r9, QWORD PTR plc$[rsp]
  0003f	45 33 c0	 xor	 r8d, r8d
  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159581
  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN5@hthread_in:
  00053	33 c0		 xor	 eax, eax
  00055	85 c0		 test	 eax, eax
  00057	75 b5		 jne	 SHORT $LN4@hthread_in

; 872  :     rc = hthread_cond_init( plc );

  00059	48 8b 4c 24 60	 mov	 rcx, QWORD PTR plc$[rsp]
  0005e	e8 00 00 00 00	 call	 fthread_cond_init
  00063	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 873  :     return rc;

  00067	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]

; 874  : }

  0006b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0006f	c3		 ret	 0
hthread_initialize_condition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 32
ilk$ = 40
plk$ = 64
hthread_test_wrlock PROC

; 854  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 855  :     int rc;
; 856  :     ILOCK* ilk;
; 857  :     ilk = (ILOCK*) plk->ilk;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR plk$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 44 24 28	 mov	 QWORD PTR ilk$[rsp], rax

; 858  :     rc = hthread_rwlock_trywrlock( &ilk->il_rwlock );

  00016	48 8b 44 24 28	 mov	 rax, QWORD PTR ilk$[rsp]
  0001b	48 83 c0 40	 add	 rax, 64			; 00000040H
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 fthread_mutex_trylock
  00027	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 859  :     if (rc)

  0002b	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00030	74 06		 je	 SHORT $LN2@hthread_te

; 860  :         return rc;

  00032	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  00036	eb 13		 jmp	 SHORT $LN1@hthread_te
$LN2@hthread_te:

; 861  :     hthread_rwlock_unlock( &ilk->il_rwlock );

  00038	48 8b 44 24 28	 mov	 rax, QWORD PTR ilk$[rsp]
  0003d	48 83 c0 40	 add	 rax, 64			; 00000040H
  00041	48 8b c8	 mov	 rcx, rax
  00044	e8 00 00 00 00	 call	 fthread_mutex_unlock

; 862  :     return 0;

  00049	33 c0		 xor	 eax, eax
$LN1@hthread_te:

; 863  : }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
hthread_test_wrlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 32
ilk$ = 40
plk$ = 64
hthread_test_rdlock PROC

; 839  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 840  :     int rc;
; 841  :     ILOCK* ilk;
; 842  :     ilk = (ILOCK*) plk->ilk;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR plk$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 44 24 28	 mov	 QWORD PTR ilk$[rsp], rax

; 843  :     rc = hthread_rwlock_tryrdlock( &ilk->il_rwlock );

  00016	48 8b 44 24 28	 mov	 rax, QWORD PTR ilk$[rsp]
  0001b	48 83 c0 40	 add	 rax, 64			; 00000040H
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 fthread_mutex_trylock
  00027	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 844  :     if (rc)

  0002b	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00030	74 06		 je	 SHORT $LN2@hthread_te

; 845  :         return rc;

  00032	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  00036	eb 13		 jmp	 SHORT $LN1@hthread_te
$LN2@hthread_te:

; 846  :     hthread_rwlock_unlock( &ilk->il_rwlock );

  00038	48 8b 44 24 28	 mov	 rax, QWORD PTR ilk$[rsp]
  0003d	48 83 c0 40	 add	 rax, 64			; 00000040H
  00041	48 8b c8	 mov	 rcx, rax
  00044	e8 00 00 00 00	 call	 fthread_mutex_unlock

; 847  :     return 0;

  00049	33 c0		 xor	 eax, eax
$LN1@hthread_te:

; 848  : }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
hthread_test_rdlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 64
ilk$ = 72
tv$ = 80
plk$ = 112
obtain_loc$ = 120
hthread_try_obtain_wrlock PROC

; 811  : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 812  :     int rc;
; 813  :     ILOCK* ilk;
; 814  :     TIMEVAL tv;
; 815  :     ilk = (ILOCK*) plk->ilk;

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR plk$[rsp]
  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00016	48 89 44 24 48	 mov	 QWORD PTR ilk$[rsp], rax
$LN4@hthread_tr:

; 816  :     PTTRACE( "trywr before", plk, NULL, obtain_loc, PTT_MAGIC );

  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  00022	48 83 e0 04	 and	 rax, 4
  00026	48 85 c0	 test	 rax, rax
  00029	74 35		 je	 SHORT $LN8@hthread_tr
  0002b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00034	48 c7 44 24 28
	9d ff ff ff	 mov	 QWORD PTR [rsp+40], -99	; ffffffffffffff9dH
  0003d	48 8b 44 24 78	 mov	 rax, QWORD PTR obtain_loc$[rsp]
  00042	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00047	45 33 c9	 xor	 r9d, r9d
  0004a	4c 8b 44 24 70	 mov	 r8, QWORD PTR plk$[rsp]
  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159549
  00056	b9 04 00 00 00	 mov	 ecx, 4
  0005b	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN8@hthread_tr:
  00060	33 c0		 xor	 eax, eax
  00062	85 c0		 test	 eax, eax
  00064	75 b5		 jne	 SHORT $LN4@hthread_tr

; 817  :     rc = hthread_rwlock_trywrlock( &ilk->il_rwlock );

  00066	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  0006b	48 83 c0 40	 add	 rax, 64			; 00000040H
  0006f	48 8b c8	 mov	 rcx, rax
  00072	e8 00 00 00 00	 call	 fthread_mutex_trylock
  00077	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 818  :     gettimeofday( &tv, NULL );

  0007b	33 d2		 xor	 edx, edx
  0007d	48 8d 4c 24 50	 lea	 rcx, QWORD PTR tv$[rsp]
  00082	e8 00 00 00 00	 call	 gettimeofday
$LN7@hthread_tr:

; 819  :     PTTRACE2( "trywr after", plk, NULL, obtain_loc, rc, &tv );

  00087	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  0008e	48 83 e0 04	 and	 rax, 4
  00092	48 85 c0	 test	 rax, rax
  00095	74 37		 je	 SHORT $LN9@hthread_tr
  00097	48 63 44 24 40	 movsxd	 rax, DWORD PTR rc$[rsp]
  0009c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR tv$[rsp]
  000a1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000ab	48 8b 44 24 78	 mov	 rax, QWORD PTR obtain_loc$[rsp]
  000b0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b5	45 33 c9	 xor	 r9d, r9d
  000b8	4c 8b 44 24 70	 mov	 r8, QWORD PTR plk$[rsp]
  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159551
  000c4	b9 04 00 00 00	 mov	 ecx, 4
  000c9	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN9@hthread_tr:
  000ce	33 c0		 xor	 eax, eax
  000d0	85 c0		 test	 eax, eax
  000d2	75 b3		 jne	 SHORT $LN7@hthread_tr

; 820  :     if (rc && EBUSY != rc)

  000d4	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  000d9	74 21		 je	 SHORT $LN10@hthread_tr
  000db	83 7c 24 40 10	 cmp	 DWORD PTR rc$[rsp], 16
  000e0	74 1a		 je	 SHORT $LN10@hthread_tr

; 821  :         loglock( ilk, rc, "try_obtain_wrlock", obtain_loc );

  000e2	4c 8b 4c 24 78	 mov	 r9, QWORD PTR obtain_loc$[rsp]
  000e7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159553
  000ee	8b 54 24 40	 mov	 edx, DWORD PTR rc$[rsp]
  000f2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ilk$[rsp]
  000f7	e8 00 00 00 00	 call	 loglock
$LN10@hthread_tr:

; 822  :     if (!rc)

  000fc	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  00101	75 4b		 jne	 SHORT $LN11@hthread_tr

; 823  :     {
; 824  :         hthread_mutex_lock( &ilk->il_locklock );

  00103	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  00108	48 83 c0 38	 add	 rax, 56			; 00000038H
  0010c	48 8b c8	 mov	 rcx, rax
  0010f	e8 00 00 00 00	 call	 fthread_mutex_lock

; 825  :         {
; 826  :             ilk->il_ob_locat = obtain_loc;

  00114	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  00119	48 8b 4c 24 78	 mov	 rcx, QWORD PTR obtain_loc$[rsp]
  0011e	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 827  :             ilk->il_ob_tid = hthread_self();

  00122	e8 00 00 00 00	 call	 fthread_self
  00127	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ilk$[rsp]
  0012c	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 828  :             memcpy( &ilk->il_ob_time, &tv, sizeof( TIMEVAL ));

  0012f	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  00134	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv$[rsp]
  00139	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 829  :         }
; 830  :         hthread_mutex_unlock( &ilk->il_locklock );

  0013d	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  00142	48 83 c0 38	 add	 rax, 56			; 00000038H
  00146	48 8b c8	 mov	 rcx, rax
  00149	e8 00 00 00 00	 call	 fthread_mutex_unlock
$LN11@hthread_tr:

; 831  :     }
; 832  :     return rc;

  0014e	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]

; 833  : }

  00152	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00156	c3		 ret	 0
hthread_try_obtain_wrlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 64
ilk$ = 72
plk$ = 96
obtain_loc$ = 104
hthread_try_obtain_rdlock PROC

; 795  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 796  :     int rc;
; 797  :     ILOCK* ilk;
; 798  :     ilk = (ILOCK*) plk->ilk;

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR plk$[rsp]
  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00016	48 89 44 24 48	 mov	 QWORD PTR ilk$[rsp], rax
$LN4@hthread_tr:

; 799  :     PTTRACE( "tryrd before", plk, NULL, obtain_loc, PTT_MAGIC );

  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  00022	48 83 e0 04	 and	 rax, 4
  00026	48 85 c0	 test	 rax, rax
  00029	74 35		 je	 SHORT $LN8@hthread_tr
  0002b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00034	48 c7 44 24 28
	9d ff ff ff	 mov	 QWORD PTR [rsp+40], -99	; ffffffffffffff9dH
  0003d	48 8b 44 24 68	 mov	 rax, QWORD PTR obtain_loc$[rsp]
  00042	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00047	45 33 c9	 xor	 r9d, r9d
  0004a	4c 8b 44 24 60	 mov	 r8, QWORD PTR plk$[rsp]
  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159523
  00056	b9 04 00 00 00	 mov	 ecx, 4
  0005b	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN8@hthread_tr:
  00060	33 c0		 xor	 eax, eax
  00062	85 c0		 test	 eax, eax
  00064	75 b5		 jne	 SHORT $LN4@hthread_tr

; 800  :     rc = hthread_rwlock_tryrdlock( &ilk->il_rwlock );

  00066	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  0006b	48 83 c0 40	 add	 rax, 64			; 00000040H
  0006f	48 8b c8	 mov	 rcx, rax
  00072	e8 00 00 00 00	 call	 fthread_mutex_trylock
  00077	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax
$LN7@hthread_tr:

; 801  :     PTTRACE( "tryrd after", plk, NULL, obtain_loc, rc );

  0007b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  00082	48 83 e0 04	 and	 rax, 4
  00086	48 85 c0	 test	 rax, rax
  00089	74 36		 je	 SHORT $LN9@hthread_tr
  0008b	48 63 44 24 40	 movsxd	 rax, DWORD PTR rc$[rsp]
  00090	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00099	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0009e	48 8b 44 24 68	 mov	 rax, QWORD PTR obtain_loc$[rsp]
  000a3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a8	45 33 c9	 xor	 r9d, r9d
  000ab	4c 8b 44 24 60	 mov	 r8, QWORD PTR plk$[rsp]
  000b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159525
  000b7	b9 04 00 00 00	 mov	 ecx, 4
  000bc	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN9@hthread_tr:
  000c1	33 c0		 xor	 eax, eax
  000c3	85 c0		 test	 eax, eax
  000c5	75 b4		 jne	 SHORT $LN7@hthread_tr

; 802  :     if (rc && EBUSY != rc)

  000c7	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  000cc	74 21		 je	 SHORT $LN10@hthread_tr
  000ce	83 7c 24 40 10	 cmp	 DWORD PTR rc$[rsp], 16
  000d3	74 1a		 je	 SHORT $LN10@hthread_tr

; 803  :         loglock( ilk, rc, "try_obtain_rdlock", obtain_loc );

  000d5	4c 8b 4c 24 68	 mov	 r9, QWORD PTR obtain_loc$[rsp]
  000da	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159527
  000e1	8b 54 24 40	 mov	 edx, DWORD PTR rc$[rsp]
  000e5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ilk$[rsp]
  000ea	e8 00 00 00 00	 call	 loglock
$LN10@hthread_tr:

; 804  :     return rc;

  000ef	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]

; 805  : }

  000f3	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f7	c3		 ret	 0
hthread_try_obtain_rdlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 64
ilk$ = 72
plk$ = 96
release_loc$ = 104
hthread_release_rwlock PROC

; 565  : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 566  :     int rc;
; 567  :     ILOCK* ilk;
; 568  :     ilk = (ILOCK*) plk->ilk;

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR plk$[rsp]
  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00016	48 89 44 24 48	 mov	 QWORD PTR ilk$[rsp], rax

; 569  :     rc = hthread_rwlock_unlock( &ilk->il_rwlock );

  0001b	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  00020	48 83 c0 40	 add	 rax, 64			; 00000040H
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 fthread_mutex_unlock
  0002c	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax
$LN4@hthread_re:

; 570  :     PTTRACE( "rwunlock", plk, NULL, release_loc, rc );

  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  00037	48 83 e0 04	 and	 rax, 4
  0003b	48 85 c0	 test	 rax, rax
  0003e	74 36		 je	 SHORT $LN5@hthread_re
  00040	48 63 44 24 40	 movsxd	 rax, DWORD PTR rc$[rsp]
  00045	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0004e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00053	48 8b 44 24 68	 mov	 rax, QWORD PTR release_loc$[rsp]
  00058	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005d	45 33 c9	 xor	 r9d, r9d
  00060	4c 8b 44 24 60	 mov	 r8, QWORD PTR plk$[rsp]
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159358
  0006c	b9 04 00 00 00	 mov	 ecx, 4
  00071	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN5@hthread_re:
  00076	33 c0		 xor	 eax, eax
  00078	85 c0		 test	 eax, eax
  0007a	75 b4		 jne	 SHORT $LN4@hthread_re

; 571  :     if (rc)

  0007c	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  00081	74 1a		 je	 SHORT $LN6@hthread_re

; 572  :         loglock( ilk, rc, "release_rwlock", release_loc );

  00083	4c 8b 4c 24 68	 mov	 r9, QWORD PTR release_loc$[rsp]
  00088	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159360
  0008f	8b 54 24 40	 mov	 edx, DWORD PTR rc$[rsp]
  00093	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ilk$[rsp]
  00098	e8 00 00 00 00	 call	 loglock
$LN6@hthread_re:

; 573  :     hthread_mutex_lock( &ilk->il_locklock );

  0009d	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  000a2	48 83 c0 38	 add	 rax, 56			; 00000038H
  000a6	48 8b c8	 mov	 rcx, rax
  000a9	e8 00 00 00 00	 call	 fthread_mutex_lock

; 574  :     {
; 575  :         ilk->il_ob_locat = "null:0";

  000ae	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159361
  000ba	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 576  :         ilk->il_ob_tid = 0;

  000be	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  000c3	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 577  :     }
; 578  :     hthread_mutex_unlock( &ilk->il_locklock );

  000ca	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  000cf	48 83 c0 38	 add	 rax, 56			; 00000038H
  000d3	48 8b c8	 mov	 rcx, rax
  000d6	e8 00 00 00 00	 call	 fthread_mutex_unlock

; 579  :     return rc;

  000db	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]

; 580  : }

  000df	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000e3	c3		 ret	 0
hthread_release_rwlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 64
ilk$ = 72
waitdur$ = 80
tv$ = 88
plk$ = 112
obtain_loc$ = 120
hthread_obtain_wrlock PROC

; 753  : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 754  :     int rc;
; 755  :     U64 waitdur;
; 756  :     ILOCK* ilk;
; 757  :     TIMEVAL tv;
; 758  :     ilk = (ILOCK*) plk->ilk;

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR plk$[rsp]
  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00016	48 89 44 24 48	 mov	 QWORD PTR ilk$[rsp], rax

; 759  :     hthread_obtaining_lock( (LOCK*) plk, obtain_loc );

  0001b	48 8b 54 24 78	 mov	 rdx, QWORD PTR obtain_loc$[rsp]
  00020	48 8b 4c 24 70	 mov	 rcx, QWORD PTR plk$[rsp]
  00025	e8 00 00 00 00	 call	 hthread_obtaining_lock
$LN4@hthread_ob:

; 760  :     PTTRACE( "wrlock before", plk, NULL, obtain_loc, PTT_MAGIC );

  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  00031	48 83 e0 04	 and	 rax, 4
  00035	48 85 c0	 test	 rax, rax
  00038	74 35		 je	 SHORT $LN8@hthread_ob
  0003a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00043	48 c7 44 24 28
	9d ff ff ff	 mov	 QWORD PTR [rsp+40], -99	; ffffffffffffff9dH
  0004c	48 8b 44 24 78	 mov	 rax, QWORD PTR obtain_loc$[rsp]
  00051	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00056	45 33 c9	 xor	 r9d, r9d
  00059	4c 8b 44 24 70	 mov	 r8, QWORD PTR plk$[rsp]
  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159495
  00065	b9 04 00 00 00	 mov	 ecx, 4
  0006a	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN8@hthread_ob:
  0006f	33 c0		 xor	 eax, eax
  00071	85 c0		 test	 eax, eax
  00073	75 b5		 jne	 SHORT $LN4@hthread_ob

; 761  :     rc = hthread_rwlock_trywrlock( &ilk->il_rwlock );

  00075	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  0007a	48 83 c0 40	 add	 rax, 64			; 00000040H
  0007e	48 8b c8	 mov	 rcx, rax
  00081	e8 00 00 00 00	 call	 fthread_mutex_trylock
  00086	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 762  :     if (EBUSY == rc)

  0008a	83 7c 24 40 10	 cmp	 DWORD PTR rc$[rsp], 16
  0008f	75 3c		 jne	 SHORT $LN9@hthread_ob

; 763  :     {
; 764  :         waitdur = host_tod();

  00091	e8 00 00 00 00	 call	 host_tod
  00096	48 89 44 24 50	 mov	 QWORD PTR waitdur$[rsp], rax

; 765  :         rc = hthread_rwlock_wrlock( &ilk->il_rwlock );

  0009b	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  000a0	48 83 c0 40	 add	 rax, 64			; 00000040H
  000a4	48 8b c8	 mov	 rcx, rax
  000a7	e8 00 00 00 00	 call	 fthread_mutex_lock
  000ac	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 766  :         gettimeofday( &tv, NULL );

  000b0	33 d2		 xor	 edx, edx
  000b2	48 8d 4c 24 58	 lea	 rcx, QWORD PTR tv$[rsp]
  000b7	e8 00 00 00 00	 call	 gettimeofday

; 767  :         waitdur = host_tod() - waitdur;

  000bc	e8 00 00 00 00	 call	 host_tod
  000c1	48 2b 44 24 50	 sub	 rax, QWORD PTR waitdur$[rsp]
  000c6	48 89 44 24 50	 mov	 QWORD PTR waitdur$[rsp], rax

; 768  :     }

  000cb	eb 15		 jmp	 SHORT $LN10@hthread_ob
$LN9@hthread_ob:

; 769  :     else
; 770  :     {
; 771  :         gettimeofday( &tv, NULL );

  000cd	33 d2		 xor	 edx, edx
  000cf	48 8d 4c 24 58	 lea	 rcx, QWORD PTR tv$[rsp]
  000d4	e8 00 00 00 00	 call	 gettimeofday

; 772  :         waitdur = 0;

  000d9	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR waitdur$[rsp], 0
$LN10@hthread_ob:
$LN7@hthread_ob:

; 773  :     }
; 774  :     PTTRACE2( "wrlock after", plk, (void*) waitdur, obtain_loc, rc, &tv );

  000e2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  000e9	48 83 e0 04	 and	 rax, 4
  000ed	48 85 c0	 test	 rax, rax
  000f0	74 39		 je	 SHORT $LN11@hthread_ob
  000f2	48 63 44 24 40	 movsxd	 rax, DWORD PTR rc$[rsp]
  000f7	48 8d 4c 24 58	 lea	 rcx, QWORD PTR tv$[rsp]
  000fc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00101	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00106	48 8b 44 24 78	 mov	 rax, QWORD PTR obtain_loc$[rsp]
  0010b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00110	4c 8b 4c 24 50	 mov	 r9, QWORD PTR waitdur$[rsp]
  00115	4c 8b 44 24 70	 mov	 r8, QWORD PTR plk$[rsp]
  0011a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159499
  00121	b9 04 00 00 00	 mov	 ecx, 4
  00126	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN11@hthread_ob:
  0012b	33 c0		 xor	 eax, eax
  0012d	85 c0		 test	 eax, eax
  0012f	75 b1		 jne	 SHORT $LN7@hthread_ob

; 775  :     hthread_lock_obtained();

  00131	e8 00 00 00 00	 call	 hthread_lock_obtained

; 776  :     if (rc)

  00136	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  0013b	74 1a		 je	 SHORT $LN12@hthread_ob

; 777  :         loglock( ilk, rc, "obtain_wrlock", obtain_loc );

  0013d	4c 8b 4c 24 78	 mov	 r9, QWORD PTR obtain_loc$[rsp]
  00142	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159501
  00149	8b 54 24 40	 mov	 edx, DWORD PTR rc$[rsp]
  0014d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ilk$[rsp]
  00152	e8 00 00 00 00	 call	 loglock
$LN12@hthread_ob:

; 778  :     if (!rc || EOWNERDEAD == rc)

  00157	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  0015c	74 0a		 je	 SHORT $LN14@hthread_ob
  0015e	81 7c 24 40 85
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 133	; 00000085H
  00166	75 4b		 jne	 SHORT $LN13@hthread_ob
$LN14@hthread_ob:

; 779  :     {
; 780  :         hthread_mutex_lock( &ilk->il_locklock );

  00168	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  0016d	48 83 c0 38	 add	 rax, 56			; 00000038H
  00171	48 8b c8	 mov	 rcx, rax
  00174	e8 00 00 00 00	 call	 fthread_mutex_lock

; 781  :         {
; 782  :             ilk->il_ob_locat = obtain_loc;

  00179	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  0017e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR obtain_loc$[rsp]
  00183	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 783  :             ilk->il_ob_tid = hthread_self();

  00187	e8 00 00 00 00	 call	 fthread_self
  0018c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ilk$[rsp]
  00191	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 784  :             memcpy( &ilk->il_ob_time, &tv, sizeof( TIMEVAL ));

  00194	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  00199	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv$[rsp]
  0019e	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 785  :         }
; 786  :         hthread_mutex_unlock( &ilk->il_locklock );

  001a2	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  001a7	48 83 c0 38	 add	 rax, 56			; 00000038H
  001ab	48 8b c8	 mov	 rcx, rax
  001ae	e8 00 00 00 00	 call	 fthread_mutex_unlock
$LN13@hthread_ob:

; 787  :     }
; 788  :     return rc;

  001b3	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]

; 789  : }

  001b7	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001bb	c3		 ret	 0
hthread_obtain_wrlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 64
waitdur$ = 72
ilk$ = 80
plk$ = 112
obtain_loc$ = 120
hthread_obtain_rdlock PROC

; 726  : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 727  :     int rc;
; 728  :     U64 waitdur;
; 729  :     ILOCK* ilk;
; 730  :     ilk = (ILOCK*) plk->ilk;

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR plk$[rsp]
  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00016	48 89 44 24 50	 mov	 QWORD PTR ilk$[rsp], rax

; 731  :     hthread_obtaining_lock( (LOCK*) plk, obtain_loc );

  0001b	48 8b 54 24 78	 mov	 rdx, QWORD PTR obtain_loc$[rsp]
  00020	48 8b 4c 24 70	 mov	 rcx, QWORD PTR plk$[rsp]
  00025	e8 00 00 00 00	 call	 hthread_obtaining_lock
$LN4@hthread_ob:

; 732  :     PTTRACE( "rdlock before", plk, NULL, obtain_loc, PTT_MAGIC );

  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  00031	48 83 e0 04	 and	 rax, 4
  00035	48 85 c0	 test	 rax, rax
  00038	74 35		 je	 SHORT $LN8@hthread_ob
  0003a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00043	48 c7 44 24 28
	9d ff ff ff	 mov	 QWORD PTR [rsp+40], -99	; ffffffffffffff9dH
  0004c	48 8b 44 24 78	 mov	 rax, QWORD PTR obtain_loc$[rsp]
  00051	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00056	45 33 c9	 xor	 r9d, r9d
  00059	4c 8b 44 24 70	 mov	 r8, QWORD PTR plk$[rsp]
  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159464
  00065	b9 04 00 00 00	 mov	 ecx, 4
  0006a	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN8@hthread_ob:
  0006f	33 c0		 xor	 eax, eax
  00071	85 c0		 test	 eax, eax
  00073	75 b5		 jne	 SHORT $LN4@hthread_ob

; 733  :     rc = hthread_rwlock_tryrdlock( &ilk->il_rwlock );

  00075	48 8b 44 24 50	 mov	 rax, QWORD PTR ilk$[rsp]
  0007a	48 83 c0 40	 add	 rax, 64			; 00000040H
  0007e	48 8b c8	 mov	 rcx, rax
  00081	e8 00 00 00 00	 call	 fthread_mutex_trylock
  00086	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 734  :     if (EBUSY == rc)

  0008a	83 7c 24 40 10	 cmp	 DWORD PTR rc$[rsp], 16
  0008f	75 30		 jne	 SHORT $LN9@hthread_ob

; 735  :     {
; 736  :         waitdur = host_tod();

  00091	e8 00 00 00 00	 call	 host_tod
  00096	48 89 44 24 48	 mov	 QWORD PTR waitdur$[rsp], rax

; 737  :         rc = hthread_rwlock_rdlock( &ilk->il_rwlock );

  0009b	48 8b 44 24 50	 mov	 rax, QWORD PTR ilk$[rsp]
  000a0	48 83 c0 40	 add	 rax, 64			; 00000040H
  000a4	48 8b c8	 mov	 rcx, rax
  000a7	e8 00 00 00 00	 call	 fthread_mutex_lock
  000ac	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 738  :         waitdur = host_tod() - waitdur;

  000b0	e8 00 00 00 00	 call	 host_tod
  000b5	48 2b 44 24 48	 sub	 rax, QWORD PTR waitdur$[rsp]
  000ba	48 89 44 24 48	 mov	 QWORD PTR waitdur$[rsp], rax

; 739  :     }

  000bf	eb 09		 jmp	 SHORT $LN10@hthread_ob
$LN9@hthread_ob:

; 740  :     else
; 741  :         waitdur = 0;

  000c1	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR waitdur$[rsp], 0
$LN10@hthread_ob:
$LN7@hthread_ob:

; 742  :     PTTRACE( "rdlock after", plk, (void*) waitdur, obtain_loc, rc );

  000ca	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  000d1	48 83 e0 04	 and	 rax, 4
  000d5	48 85 c0	 test	 rax, rax
  000d8	74 38		 je	 SHORT $LN11@hthread_ob
  000da	48 63 44 24 40	 movsxd	 rax, DWORD PTR rc$[rsp]
  000df	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000e8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000ed	48 8b 44 24 78	 mov	 rax, QWORD PTR obtain_loc$[rsp]
  000f2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f7	4c 8b 4c 24 48	 mov	 r9, QWORD PTR waitdur$[rsp]
  000fc	4c 8b 44 24 70	 mov	 r8, QWORD PTR plk$[rsp]
  00101	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159468
  00108	b9 04 00 00 00	 mov	 ecx, 4
  0010d	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN11@hthread_ob:
  00112	33 c0		 xor	 eax, eax
  00114	85 c0		 test	 eax, eax
  00116	75 b2		 jne	 SHORT $LN7@hthread_ob

; 743  :     hthread_lock_obtained();

  00118	e8 00 00 00 00	 call	 hthread_lock_obtained

; 744  :     if (rc)

  0011d	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  00122	74 1a		 je	 SHORT $LN12@hthread_ob

; 745  :         loglock( ilk, rc, "obtain_rdloc", obtain_loc );

  00124	4c 8b 4c 24 78	 mov	 r9, QWORD PTR obtain_loc$[rsp]
  00129	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159470
  00130	8b 54 24 40	 mov	 edx, DWORD PTR rc$[rsp]
  00134	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ilk$[rsp]
  00139	e8 00 00 00 00	 call	 loglock
$LN12@hthread_ob:

; 746  :     return rc;

  0013e	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]

; 747  : }

  00142	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00146	c3		 ret	 0
hthread_obtain_rdlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc2$ = 32
rc1$ = 36
tv128 = 40
tv130 = 44
ilk$ = 48
_EX_Flink$1 = 56
_EX_Blink$2 = 64
plk$ = 96
destroy_loc$ = 104
hthread_destroy_rwlock PROC

; 624  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 625  :     int rc1, rc2 = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR rc2$[rsp], 0

; 626  :     ILOCK* ilk = (ILOCK*) plk->ilk;

  00016	48 8b 44 24 60	 mov	 rax, QWORD PTR plk$[rsp]
  0001b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001e	48 89 44 24 30	 mov	 QWORD PTR ilk$[rsp], rax

; 627  : 
; 628  :     if (!ilk)

  00023	48 83 7c 24 30
	00		 cmp	 QWORD PTR ilk$[rsp], 0
  00029	75 0a		 jne	 SHORT $LN2@hthread_de

; 629  :         return EINVAL;

  0002b	b8 16 00 00 00	 mov	 eax, 22
  00030	e9 3c 01 00 00	 jmp	 $LN1@hthread_de
$LN2@hthread_de:

; 630  : 
; 631  :     /* Destroy the Internal ILOCK structure HLOCK */
; 632  :     if ((rc1 = hthread_mutex_destroy( &ilk->il_locklock )) == 0)

  00035	48 8b 44 24 30	 mov	 rax, QWORD PTR ilk$[rsp]
  0003a	48 83 c0 38	 add	 rax, 56			; 00000038H
  0003e	48 8b c8	 mov	 rcx, rax
  00041	e8 00 00 00 00	 call	 fthread_mutex_destroy
  00046	89 44 24 24	 mov	 DWORD PTR rc1$[rsp], eax
  0004a	83 7c 24 24 00	 cmp	 DWORD PTR rc1$[rsp], 0
  0004f	75 38		 jne	 SHORT $LN3@hthread_de

; 633  :     {
; 634  :         /* Now destroy the actual locking model HRWLOCK rwlock */
; 635  :         if ((rc2 = hthread_rwlock_destroy( &ilk->il_rwlock )) != 0)

  00051	48 8b 44 24 30	 mov	 rax, QWORD PTR ilk$[rsp]
  00056	48 83 c0 40	 add	 rax, 64			; 00000040H
  0005a	48 8b c8	 mov	 rcx, rax
  0005d	e8 00 00 00 00	 call	 fthread_mutex_destroy
  00062	89 44 24 20	 mov	 DWORD PTR rc2$[rsp], eax
  00066	83 7c 24 20 00	 cmp	 DWORD PTR rc2$[rsp], 0
  0006b	74 1a		 je	 SHORT $LN5@hthread_de

; 636  :             loglock( ilk, rc2, "destroy_rwlock", destroy_loc );

  0006d	4c 8b 4c 24 68	 mov	 r9, QWORD PTR destroy_loc$[rsp]
  00072	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159399
  00079	8b 54 24 20	 mov	 edx, DWORD PTR rc2$[rsp]
  0007d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ilk$[rsp]
  00082	e8 00 00 00 00	 call	 loglock
$LN5@hthread_de:

; 637  :     }

  00087	eb 1a		 jmp	 SHORT $LN4@hthread_de
$LN3@hthread_de:

; 638  :     else
; 639  :         loglock( ilk, rc1, "destroy_rwlock", destroy_loc );

  00089	4c 8b 4c 24 68	 mov	 r9, QWORD PTR destroy_loc$[rsp]
  0008e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159400
  00095	8b 54 24 24	 mov	 edx, DWORD PTR rc1$[rsp]
  00099	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ilk$[rsp]
  0009e	e8 00 00 00 00	 call	 loglock
$LN4@hthread_de:

; 640  : 
; 641  :     if (rc1 == 0 && rc2 == 0)

  000a3	83 7c 24 24 00	 cmp	 DWORD PTR rc1$[rsp], 0
  000a8	0f 85 8d 00 00
	00		 jne	 $LN6@hthread_de
  000ae	83 7c 24 20 00	 cmp	 DWORD PTR rc2$[rsp], 0
  000b3	0f 85 82 00 00
	00		 jne	 $LN6@hthread_de

; 642  :     {
; 643  :         LockLocksList();

  000b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:listlock
  000c0	e8 00 00 00 00	 call	 fthread_mutex_lock

; 644  :         {
; 645  :             RemoveListEntry( &ilk->il_link );

  000c5	48 8b 44 24 30	 mov	 rax, QWORD PTR ilk$[rsp]
  000ca	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000cd	48 89 44 24 38	 mov	 QWORD PTR _EX_Flink$1[rsp], rax
  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR ilk$[rsp]
  000d7	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000db	48 89 44 24 40	 mov	 QWORD PTR _EX_Blink$2[rsp], rax
  000e0	48 8b 44 24 40	 mov	 rax, QWORD PTR _EX_Blink$2[rsp]
  000e5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _EX_Flink$1[rsp]
  000ea	48 89 08	 mov	 QWORD PTR [rax], rcx
  000ed	48 8b 44 24 38	 mov	 rax, QWORD PTR _EX_Flink$1[rsp]
  000f2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _EX_Blink$2[rsp]
  000f7	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 646  :             lockcount--;

  000fb	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR lockcount
  00101	ff c8		 dec	 eax
  00103	89 05 00 00 00
	00		 mov	 DWORD PTR lockcount, eax

; 647  :         }
; 648  :         UnlockLocksList();

  00109	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:listlock
  00110	e8 00 00 00 00	 call	 fthread_mutex_unlock

; 649  : 
; 650  :         free( ilk->il_name );

  00115	48 8b 44 24 30	 mov	 rax, QWORD PTR ilk$[rsp]
  0011a	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0011e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 651  :         free_aligned( ilk );

  00124	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ilk$[rsp]
  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free

; 652  :         plk->ilk = NULL;

  0012f	48 8b 44 24 60	 mov	 rax, QWORD PTR plk$[rsp]
  00134	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN6@hthread_de:

; 653  :     }
; 654  : 
; 655  :     return (rc1 ? rc1 : (rc2 ? rc2 : 0));

  0013b	83 7c 24 24 00	 cmp	 DWORD PTR rc1$[rsp], 0
  00140	74 0a		 je	 SHORT $LN10@hthread_de
  00142	8b 44 24 24	 mov	 eax, DWORD PTR rc1$[rsp]
  00146	89 44 24 2c	 mov	 DWORD PTR tv130[rsp], eax
  0014a	eb 21		 jmp	 SHORT $LN11@hthread_de
$LN10@hthread_de:
  0014c	83 7c 24 20 00	 cmp	 DWORD PTR rc2$[rsp], 0
  00151	74 0a		 je	 SHORT $LN8@hthread_de
  00153	8b 44 24 20	 mov	 eax, DWORD PTR rc2$[rsp]
  00157	89 44 24 28	 mov	 DWORD PTR tv128[rsp], eax
  0015b	eb 08		 jmp	 SHORT $LN9@hthread_de
$LN8@hthread_de:
  0015d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
$LN9@hthread_de:
  00165	8b 44 24 28	 mov	 eax, DWORD PTR tv128[rsp]
  00169	89 44 24 2c	 mov	 DWORD PTR tv130[rsp], eax
$LN11@hthread_de:
  0016d	8b 44 24 2c	 mov	 eax, DWORD PTR tv130[rsp]
$LN1@hthread_de:

; 656  : }

  00171	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00175	c3		 ret	 0
hthread_destroy_rwlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 64
attr2$ = 68
attr1$ = 72
ilk$ = 80
_EX_Head$1 = 88
_EX_Next$2 = 96
plk$ = 128
name$ = 136
create_loc$ = 144
hthread_initialize_rwlock PROC

; 352  : {

$LN17:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 353  :     int     rc;
; 354  :     MATTR   attr1;    /* for internal lock structure lock */
; 355  :     RWATTR  attr2;    /* for primary rwlock */
; 356  :     ILOCK*  ilk;
; 357  : 
; 358  :     LockLocksList();

  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:listlock
  0001a	e8 00 00 00 00	 call	 fthread_mutex_lock

; 359  :     {
; 360  :         ilk = hthreads_find_ILOCK_locked( (LOCK*) plk, NULL );

  0001f	33 d2		 xor	 edx, edx
  00021	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR plk$[rsp]
  00029	e8 00 00 00 00	 call	 hthreads_find_ILOCK_locked
  0002e	48 89 44 24 50	 mov	 QWORD PTR ilk$[rsp], rax

; 361  : 
; 362  :         if (ilk)

  00033	48 83 7c 24 50
	00		 cmp	 QWORD PTR ilk$[rsp], 0
  00039	74 34		 je	 SHORT $LN5@hthread_in

; 363  :         {
; 364  :             loglock( ilk, EEXIST, "initialize rwlock", create_loc );

  0003b	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR create_loc$[rsp]
  00043	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159237
  0004a	ba 11 00 00 00	 mov	 edx, 17
  0004f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ilk$[rsp]
  00054	e8 00 00 00 00	 call	 loglock

; 365  :             UnlockLocksList();

  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:listlock
  00060	e8 00 00 00 00	 call	 fthread_mutex_unlock

; 366  :             return EEXIST;

  00065	b8 11 00 00 00	 mov	 eax, 17
  0006a	e9 88 02 00 00	 jmp	 $LN1@hthread_in
$LN5@hthread_in:

; 367  :         }
; 368  : 
; 369  :         if (!(ilk = calloc_aligned( sizeof( ILOCK ), 64 )))

  0006f	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00074	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  00079	e8 00 00 00 00	 call	 calloc_aligned
  0007e	48 89 44 24 50	 mov	 QWORD PTR ilk$[rsp], rax
  00083	48 83 7c 24 50
	00		 cmp	 QWORD PTR ilk$[rsp], 0
  00089	75 05		 jne	 SHORT $LN6@hthread_in

; 370  :             goto fatal;

  0008b	e9 4f 02 00 00	 jmp	 $fatal$18
$LN6@hthread_in:

; 371  : 
; 372  :         gettimeofday( &ilk->il_cr_time, NULL );

  00090	48 8b 44 24 50	 mov	 rax, QWORD PTR ilk$[rsp]
  00095	48 83 c0 50	 add	 rax, 80			; 00000050H
  00099	33 d2		 xor	 edx, edx
  0009b	48 8b c8	 mov	 rcx, rax
  0009e	e8 00 00 00 00	 call	 gettimeofday

; 373  : 
; 374  :         ilk->il_addr             =  plk;

  000a3	48 8b 44 24 50	 mov	 rax, QWORD PTR ilk$[rsp]
  000a8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR plk$[rsp]
  000b0	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 375  :         ilk->il_name             =  strdup( name );

  000b4	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR name$[rsp]
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  000c2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ilk$[rsp]
  000c7	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 376  :         ilk->il_cr_locat         =  create_loc;

  000cb	48 8b 44 24 50	 mov	 rax, QWORD PTR ilk$[rsp]
  000d0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR create_loc$[rsp]
  000d8	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 377  :         ilk->il_cr_tid           =  hthread_self();

  000dc	e8 00 00 00 00	 call	 fthread_self
  000e1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ilk$[rsp]
  000e6	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 378  :         ilk->il_ob_locat         =  "null:0";

  000e9	48 8b 44 24 50	 mov	 rax, QWORD PTR ilk$[rsp]
  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159239
  000f5	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 379  :         ilk->il_ob_time.tv_sec   =  0;

  000f9	48 8b 44 24 50	 mov	 rax, QWORD PTR ilk$[rsp]
  000fe	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [rax+40], 0

; 380  :         ilk->il_ob_time.tv_usec  =  0;

  00105	48 8b 44 24 50	 mov	 rax, QWORD PTR ilk$[rsp]
  0010a	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [rax+44], 0

; 381  :         ilk->il_ob_tid           =  0;

  00111	48 8b 44 24 50	 mov	 rax, QWORD PTR ilk$[rsp]
  00116	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 382  : 
; 383  :         /* Initialize the requested lock */
; 384  : 
; 385  :         rc = hthread_mutexattr_init( &attr1 );

  0011d	48 8d 4c 24 48	 lea	 rcx, QWORD PTR attr1$[rsp]
  00122	e8 00 00 00 00	 call	 fthread_mutexattr_init
  00127	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 386  :         if (rc)

  0012b	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  00130	74 05		 je	 SHORT $LN7@hthread_in

; 387  :             goto fatal;

  00132	e9 a8 01 00 00	 jmp	 $fatal$18
$LN7@hthread_in:

; 388  : 
; 389  :         rc = hthread_rwlockattr_init( &attr2 );

  00137	48 8d 4c 24 44	 lea	 rcx, QWORD PTR attr2$[rsp]
  0013c	e8 00 00 00 00	 call	 fthread_mutexattr_init
  00141	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 390  :         if (rc)

  00145	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  0014a	74 05		 je	 SHORT $LN8@hthread_in

; 391  :             goto fatal;

  0014c	e9 8e 01 00 00	 jmp	 $fatal$18
$LN8@hthread_in:

; 392  : 
; 393  :         rc = hthread_mutexattr_settype( &attr1, HTHREAD_MUTEX_DEFAULT );

  00151	ba 65 63 6e 4f	 mov	 edx, 1332634469		; 4f6e6365H
  00156	48 8d 4c 24 48	 lea	 rcx, QWORD PTR attr1$[rsp]
  0015b	e8 00 00 00 00	 call	 fthread_mutexattr_settype
  00160	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 394  :         if (rc)

  00164	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  00169	74 05		 je	 SHORT $LN9@hthread_in

; 395  :             goto fatal;

  0016b	e9 6f 01 00 00	 jmp	 $fatal$18
$LN9@hthread_in:

; 396  : 
; 397  :         rc = hthread_rwlockattr_setpshared( &attr2, HTHREAD_RWLOCK_DEFAULT );

  00170	ba 65 63 6e 4f	 mov	 edx, 1332634469		; 4f6e6365H
  00175	48 8d 4c 24 44	 lea	 rcx, QWORD PTR attr2$[rsp]
  0017a	e8 00 00 00 00	 call	 fthread_mutexattr_settype
  0017f	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 398  :         if (rc)

  00183	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  00188	74 05		 je	 SHORT $LN10@hthread_in

; 399  :             goto fatal;

  0018a	e9 50 01 00 00	 jmp	 $fatal$18
$LN10@hthread_in:

; 400  : 
; 401  :         rc = hthread_mutex_init( &ilk->il_locklock, &attr1 );

  0018f	48 8b 44 24 50	 mov	 rax, QWORD PTR ilk$[rsp]
  00194	48 83 c0 38	 add	 rax, 56			; 00000038H
  00198	48 8d 54 24 48	 lea	 rdx, QWORD PTR attr1$[rsp]
  0019d	48 8b c8	 mov	 rcx, rax
  001a0	e8 00 00 00 00	 call	 fthread_mutex_init
  001a5	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 402  :         if (rc)

  001a9	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  001ae	74 05		 je	 SHORT $LN11@hthread_in

; 403  :             goto fatal;

  001b0	e9 2a 01 00 00	 jmp	 $fatal$18
$LN11@hthread_in:

; 404  : 
; 405  :         rc = hthread_rwlock_init( &ilk->il_rwlock, &attr2 );

  001b5	48 8b 44 24 50	 mov	 rax, QWORD PTR ilk$[rsp]
  001ba	48 83 c0 40	 add	 rax, 64			; 00000040H
  001be	48 8d 54 24 44	 lea	 rdx, QWORD PTR attr2$[rsp]
  001c3	48 8b c8	 mov	 rcx, rax
  001c6	e8 00 00 00 00	 call	 fthread_mutex_init
  001cb	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 406  :         if (rc)

  001cf	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  001d4	74 05		 je	 SHORT $LN12@hthread_in

; 407  :             goto fatal;

  001d6	e9 04 01 00 00	 jmp	 $fatal$18
$LN12@hthread_in:

; 408  : 
; 409  :         rc = hthread_mutexattr_destroy( &attr1 );

  001db	48 8d 4c 24 48	 lea	 rcx, QWORD PTR attr1$[rsp]
  001e0	e8 00 00 00 00	 call	 fthread_mutexattr_destroy
  001e5	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 410  :         if (rc)

  001e9	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  001ee	74 05		 je	 SHORT $LN13@hthread_in

; 411  :             goto fatal;

  001f0	e9 ea 00 00 00	 jmp	 $fatal$18
$LN13@hthread_in:

; 412  : 
; 413  :         rc = hthread_rwlockattr_destroy( &attr2 );

  001f5	48 8d 4c 24 44	 lea	 rcx, QWORD PTR attr2$[rsp]
  001fa	e8 00 00 00 00	 call	 fthread_mutexattr_destroy
  001ff	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 414  :         if (rc)

  00203	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  00208	74 05		 je	 SHORT $LN14@hthread_in

; 415  :             goto fatal;

  0020a	e9 d0 00 00 00	 jmp	 $fatal$18
$LN14@hthread_in:

; 416  : 
; 417  :         plk->ilk = ilk;     /* (RWLOCK is now initialized) */

  0020f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR plk$[rsp]
  00217	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ilk$[rsp]
  0021c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 418  : 
; 419  :         InsertListHead( &locklist, &ilk->il_link );

  0021f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:locklist
  00226	48 89 44 24 58	 mov	 QWORD PTR _EX_Head$1[rsp], rax
  0022b	48 8b 44 24 58	 mov	 rax, QWORD PTR _EX_Head$1[rsp]
  00230	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00233	48 89 44 24 60	 mov	 QWORD PTR _EX_Next$2[rsp], rax
  00238	48 8b 44 24 50	 mov	 rax, QWORD PTR ilk$[rsp]
  0023d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _EX_Next$2[rsp]
  00242	48 89 08	 mov	 QWORD PTR [rax], rcx
  00245	48 8b 44 24 50	 mov	 rax, QWORD PTR ilk$[rsp]
  0024a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _EX_Head$1[rsp]
  0024f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00253	48 8b 44 24 50	 mov	 rax, QWORD PTR ilk$[rsp]
  00258	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _EX_Head$1[rsp]
  0025d	48 89 01	 mov	 QWORD PTR [rcx], rax
  00260	48 8b 44 24 50	 mov	 rax, QWORD PTR ilk$[rsp]
  00265	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _EX_Next$2[rsp]
  0026a	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 420  :         lockcount++;

  0026e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR lockcount
  00274	ff c0		 inc	 eax
  00276	89 05 00 00 00
	00		 mov	 DWORD PTR lockcount, eax
$LN4@hthread_in:

; 421  : 
; 422  :         PTTRACE( "rwlock init", plk, &attr2, create_loc, PTT_MAGIC );

  0027c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  00283	48 83 e0 04	 and	 rax, 4
  00287	48 85 c0	 test	 rax, rax
  0028a	74 3d		 je	 SHORT $LN15@hthread_in
  0028c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00295	48 c7 44 24 28
	9d ff ff ff	 mov	 QWORD PTR [rsp+40], -99	; ffffffffffffff9dH
  0029e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR create_loc$[rsp]
  002a6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002ab	4c 8d 4c 24 44	 lea	 r9, QWORD PTR attr2$[rsp]
  002b0	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR plk$[rsp]
  002b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159249
  002bf	b9 04 00 00 00	 mov	 ecx, 4
  002c4	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN15@hthread_in:
  002c9	33 c0		 xor	 eax, eax
  002cb	85 c0		 test	 eax, eax
  002cd	75 ad		 jne	 SHORT $LN4@hthread_in

; 423  :     }
; 424  :     UnlockLocksList();

  002cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:listlock
  002d6	e8 00 00 00 00	 call	 fthread_mutex_unlock

; 425  : 
; 426  :     return 0;

  002db	33 c0		 xor	 eax, eax
  002dd	eb 18		 jmp	 SHORT $LN1@hthread_in
$fatal$18:

; 427  : 
; 428  : fatal:
; 429  : 
; 430  :     perror( "Fatal error in hthread_initialize_rwlock function" );

  002df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159250
  002e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_perror

; 431  :     exit(1);

  002ec	b9 01 00 00 00	 mov	 ecx, 1
  002f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN1@hthread_in:
$LN16@hthread_in:

; 432  : }

  002f7	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002fb	c3		 ret	 0
hthread_initialize_rwlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc2$ = 32
rc1$ = 36
tv128 = 40
tv130 = 44
ilk$ = 48
_EX_Flink$1 = 56
_EX_Blink$2 = 64
plk$ = 96
destroy_loc$ = 104
hthread_destroy_lock PROC

; 586  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 587  :     int rc1, rc2 = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR rc2$[rsp], 0

; 588  :     ILOCK* ilk = (ILOCK*) plk->ilk;

  00016	48 8b 44 24 60	 mov	 rax, QWORD PTR plk$[rsp]
  0001b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001e	48 89 44 24 30	 mov	 QWORD PTR ilk$[rsp], rax

; 589  : 
; 590  :     if (!ilk)

  00023	48 83 7c 24 30
	00		 cmp	 QWORD PTR ilk$[rsp], 0
  00029	75 0a		 jne	 SHORT $LN2@hthread_de

; 591  :         return EINVAL;

  0002b	b8 16 00 00 00	 mov	 eax, 22
  00030	e9 3c 01 00 00	 jmp	 $LN1@hthread_de
$LN2@hthread_de:

; 592  : 
; 593  :     /* Destroy the Internal ILOCK structure lock */
; 594  :     if ((rc1 = hthread_mutex_destroy( &ilk->il_locklock )) == 0)

  00035	48 8b 44 24 30	 mov	 rax, QWORD PTR ilk$[rsp]
  0003a	48 83 c0 38	 add	 rax, 56			; 00000038H
  0003e	48 8b c8	 mov	 rcx, rax
  00041	e8 00 00 00 00	 call	 fthread_mutex_destroy
  00046	89 44 24 24	 mov	 DWORD PTR rc1$[rsp], eax
  0004a	83 7c 24 24 00	 cmp	 DWORD PTR rc1$[rsp], 0
  0004f	75 38		 jne	 SHORT $LN3@hthread_de

; 595  :     {
; 596  :         /* Now destroy the actual locking model HLOCK lock */
; 597  :         if ((rc2 = hthread_mutex_destroy( &ilk->il_lock )) != 0)

  00051	48 8b 44 24 30	 mov	 rax, QWORD PTR ilk$[rsp]
  00056	48 83 c0 40	 add	 rax, 64			; 00000040H
  0005a	48 8b c8	 mov	 rcx, rax
  0005d	e8 00 00 00 00	 call	 fthread_mutex_destroy
  00062	89 44 24 20	 mov	 DWORD PTR rc2$[rsp], eax
  00066	83 7c 24 20 00	 cmp	 DWORD PTR rc2$[rsp], 0
  0006b	74 1a		 je	 SHORT $LN5@hthread_de

; 598  :             loglock( ilk, rc2, "destroy_lock", destroy_loc );

  0006d	4c 8b 4c 24 68	 mov	 r9, QWORD PTR destroy_loc$[rsp]
  00072	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159379
  00079	8b 54 24 20	 mov	 edx, DWORD PTR rc2$[rsp]
  0007d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ilk$[rsp]
  00082	e8 00 00 00 00	 call	 loglock
$LN5@hthread_de:

; 599  :     }

  00087	eb 1a		 jmp	 SHORT $LN4@hthread_de
$LN3@hthread_de:

; 600  :     else
; 601  :         loglock( ilk, rc1, "destroy_lock", destroy_loc );

  00089	4c 8b 4c 24 68	 mov	 r9, QWORD PTR destroy_loc$[rsp]
  0008e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159380
  00095	8b 54 24 24	 mov	 edx, DWORD PTR rc1$[rsp]
  00099	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ilk$[rsp]
  0009e	e8 00 00 00 00	 call	 loglock
$LN4@hthread_de:

; 602  : 
; 603  :     if (rc1 == 0 && rc2 == 0)

  000a3	83 7c 24 24 00	 cmp	 DWORD PTR rc1$[rsp], 0
  000a8	0f 85 8d 00 00
	00		 jne	 $LN6@hthread_de
  000ae	83 7c 24 20 00	 cmp	 DWORD PTR rc2$[rsp], 0
  000b3	0f 85 82 00 00
	00		 jne	 $LN6@hthread_de

; 604  :     {
; 605  :         LockLocksList();

  000b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:listlock
  000c0	e8 00 00 00 00	 call	 fthread_mutex_lock

; 606  :         {
; 607  :             RemoveListEntry( &ilk->il_link );

  000c5	48 8b 44 24 30	 mov	 rax, QWORD PTR ilk$[rsp]
  000ca	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000cd	48 89 44 24 38	 mov	 QWORD PTR _EX_Flink$1[rsp], rax
  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR ilk$[rsp]
  000d7	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000db	48 89 44 24 40	 mov	 QWORD PTR _EX_Blink$2[rsp], rax
  000e0	48 8b 44 24 40	 mov	 rax, QWORD PTR _EX_Blink$2[rsp]
  000e5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _EX_Flink$1[rsp]
  000ea	48 89 08	 mov	 QWORD PTR [rax], rcx
  000ed	48 8b 44 24 38	 mov	 rax, QWORD PTR _EX_Flink$1[rsp]
  000f2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _EX_Blink$2[rsp]
  000f7	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 608  :             lockcount--;

  000fb	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR lockcount
  00101	ff c8		 dec	 eax
  00103	89 05 00 00 00
	00		 mov	 DWORD PTR lockcount, eax

; 609  :         }
; 610  :         UnlockLocksList();

  00109	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:listlock
  00110	e8 00 00 00 00	 call	 fthread_mutex_unlock

; 611  : 
; 612  :         free( ilk->il_name );

  00115	48 8b 44 24 30	 mov	 rax, QWORD PTR ilk$[rsp]
  0011a	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0011e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 613  :         free_aligned( ilk );

  00124	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ilk$[rsp]
  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free

; 614  :         plk->ilk = NULL;

  0012f	48 8b 44 24 60	 mov	 rax, QWORD PTR plk$[rsp]
  00134	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN6@hthread_de:

; 615  :     }
; 616  : 
; 617  :     return (rc1 ? rc1 : (rc2 ? rc2 : 0));

  0013b	83 7c 24 24 00	 cmp	 DWORD PTR rc1$[rsp], 0
  00140	74 0a		 je	 SHORT $LN10@hthread_de
  00142	8b 44 24 24	 mov	 eax, DWORD PTR rc1$[rsp]
  00146	89 44 24 2c	 mov	 DWORD PTR tv130[rsp], eax
  0014a	eb 21		 jmp	 SHORT $LN11@hthread_de
$LN10@hthread_de:
  0014c	83 7c 24 20 00	 cmp	 DWORD PTR rc2$[rsp], 0
  00151	74 0a		 je	 SHORT $LN8@hthread_de
  00153	8b 44 24 20	 mov	 eax, DWORD PTR rc2$[rsp]
  00157	89 44 24 28	 mov	 DWORD PTR tv128[rsp], eax
  0015b	eb 08		 jmp	 SHORT $LN9@hthread_de
$LN8@hthread_de:
  0015d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
$LN9@hthread_de:
  00165	8b 44 24 28	 mov	 eax, DWORD PTR tv128[rsp]
  00169	89 44 24 2c	 mov	 DWORD PTR tv130[rsp], eax
$LN11@hthread_de:
  0016d	8b 44 24 2c	 mov	 eax, DWORD PTR tv130[rsp]
$LN1@hthread_de:

; 618  : }

  00171	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00175	c3		 ret	 0
hthread_destroy_lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 64
ilk$ = 72
plk$ = 96
release_loc$ = 104
hthread_release_lock PROC

; 544  : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 545  :     int rc;
; 546  :     ILOCK* ilk;
; 547  :     ilk = (ILOCK*) plk->ilk;

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR plk$[rsp]
  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00016	48 89 44 24 48	 mov	 QWORD PTR ilk$[rsp], rax

; 548  :     rc = hthread_mutex_unlock( &ilk->il_lock );

  0001b	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  00020	48 83 c0 40	 add	 rax, 64			; 00000040H
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 fthread_mutex_unlock
  0002c	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax
$LN4@hthread_re:

; 549  :     PTTRACE( "unlock", plk, NULL, release_loc, rc );

  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  00037	48 83 e0 04	 and	 rax, 4
  0003b	48 85 c0	 test	 rax, rax
  0003e	74 36		 je	 SHORT $LN5@hthread_re
  00040	48 63 44 24 40	 movsxd	 rax, DWORD PTR rc$[rsp]
  00045	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0004e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00053	48 8b 44 24 68	 mov	 rax, QWORD PTR release_loc$[rsp]
  00058	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005d	45 33 c9	 xor	 r9d, r9d
  00060	4c 8b 44 24 60	 mov	 r8, QWORD PTR plk$[rsp]
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159340
  0006c	b9 04 00 00 00	 mov	 ecx, 4
  00071	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN5@hthread_re:
  00076	33 c0		 xor	 eax, eax
  00078	85 c0		 test	 eax, eax
  0007a	75 b4		 jne	 SHORT $LN4@hthread_re

; 550  :     if (rc)

  0007c	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  00081	74 1a		 je	 SHORT $LN6@hthread_re

; 551  :         loglock( ilk, rc, "release_lock", release_loc );

  00083	4c 8b 4c 24 68	 mov	 r9, QWORD PTR release_loc$[rsp]
  00088	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159342
  0008f	8b 54 24 40	 mov	 edx, DWORD PTR rc$[rsp]
  00093	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ilk$[rsp]
  00098	e8 00 00 00 00	 call	 loglock
$LN6@hthread_re:

; 552  :     hthread_mutex_lock( &ilk->il_locklock );

  0009d	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  000a2	48 83 c0 38	 add	 rax, 56			; 00000038H
  000a6	48 8b c8	 mov	 rcx, rax
  000a9	e8 00 00 00 00	 call	 fthread_mutex_lock

; 553  :     {
; 554  :         ilk->il_ob_locat = "null:0";

  000ae	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159343
  000ba	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 555  :         ilk->il_ob_tid = 0;

  000be	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  000c3	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 556  :     }
; 557  :     hthread_mutex_unlock( &ilk->il_locklock );

  000ca	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  000cf	48 83 c0 38	 add	 rax, 56			; 00000038H
  000d3	48 8b c8	 mov	 rcx, rax
  000d6	e8 00 00 00 00	 call	 fthread_mutex_unlock

; 558  :     return rc;

  000db	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]

; 559  : }

  000df	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000e3	c3		 ret	 0
hthread_release_lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 32
ilk$ = 40
plk$ = 64
hthread_have_lock PROC

; 714  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 715  :     int rc;
; 716  :     ILOCK* ilk;
; 717  :     ilk = (ILOCK*) plk->ilk;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR plk$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 44 24 28	 mov	 QWORD PTR ilk$[rsp], rax

; 718  :     rc = hthread_equal_threads( hthread_self(), ilk->il_ob_tid );

  00016	e8 00 00 00 00	 call	 fthread_self
  0001b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ilk$[rsp]
  00020	8b 51 30	 mov	 edx, DWORD PTR [rcx+48]
  00023	8b c8		 mov	 ecx, eax
  00025	e8 00 00 00 00	 call	 hthread_equal_threads
  0002a	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 719  :     return rc;

  0002e	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 720  : }

  00032	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00036	c3		 ret	 0
hthread_have_lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 32
ilk$ = 40
plk$ = 64
hthread_test_lock PROC

; 699  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 700  :     int rc;
; 701  :     ILOCK* ilk;
; 702  :     ilk = (ILOCK*) plk->ilk;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR plk$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 44 24 28	 mov	 QWORD PTR ilk$[rsp], rax

; 703  :     rc = hthread_mutex_trylock( &ilk->il_lock );

  00016	48 8b 44 24 28	 mov	 rax, QWORD PTR ilk$[rsp]
  0001b	48 83 c0 40	 add	 rax, 64			; 00000040H
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 fthread_mutex_trylock
  00027	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 704  :     if (rc)

  0002b	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00030	74 06		 je	 SHORT $LN2@hthread_te

; 705  :         return rc;

  00032	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  00036	eb 13		 jmp	 SHORT $LN1@hthread_te
$LN2@hthread_te:

; 706  :     hthread_mutex_unlock( &ilk->il_lock );

  00038	48 8b 44 24 28	 mov	 rax, QWORD PTR ilk$[rsp]
  0003d	48 83 c0 40	 add	 rax, 64			; 00000040H
  00041	48 8b c8	 mov	 rcx, rax
  00044	e8 00 00 00 00	 call	 fthread_mutex_unlock

; 707  :     return 0;

  00049	33 c0		 xor	 eax, eax
$LN1@hthread_te:

; 708  : }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
hthread_test_lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 64
ilk$ = 72
tv$ = 80
plk$ = 112
obtain_loc$ = 120
hthread_try_obtain_lock PROC

; 662  : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 663  :     int rc;
; 664  :     ILOCK* ilk;
; 665  :     TIMEVAL tv;
; 666  :     ilk = (ILOCK*) plk->ilk;

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR plk$[rsp]
  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00016	48 89 44 24 48	 mov	 QWORD PTR ilk$[rsp], rax
$LN4@hthread_tr:

; 667  :     PTTRACE( "try before", plk, NULL, obtain_loc, PTT_MAGIC );

  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  00022	48 83 e0 04	 and	 rax, 4
  00026	48 85 c0	 test	 rax, rax
  00029	74 35		 je	 SHORT $LN8@hthread_tr
  0002b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00034	48 c7 44 24 28
	9d ff ff ff	 mov	 QWORD PTR [rsp+40], -99	; ffffffffffffff9dH
  0003d	48 8b 44 24 78	 mov	 rax, QWORD PTR obtain_loc$[rsp]
  00042	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00047	45 33 c9	 xor	 r9d, r9d
  0004a	4c 8b 44 24 70	 mov	 r8, QWORD PTR plk$[rsp]
  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159423
  00056	b9 04 00 00 00	 mov	 ecx, 4
  0005b	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN8@hthread_tr:
  00060	33 c0		 xor	 eax, eax
  00062	85 c0		 test	 eax, eax
  00064	75 b5		 jne	 SHORT $LN4@hthread_tr

; 668  :     rc = hthread_mutex_trylock( &ilk->il_lock );

  00066	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  0006b	48 83 c0 40	 add	 rax, 64			; 00000040H
  0006f	48 8b c8	 mov	 rcx, rax
  00072	e8 00 00 00 00	 call	 fthread_mutex_trylock
  00077	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 669  :     gettimeofday( &tv, NULL );

  0007b	33 d2		 xor	 edx, edx
  0007d	48 8d 4c 24 50	 lea	 rcx, QWORD PTR tv$[rsp]
  00082	e8 00 00 00 00	 call	 gettimeofday
$LN7@hthread_tr:

; 670  :     PTTRACE2( "try after", plk, NULL, obtain_loc, rc, &tv );

  00087	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  0008e	48 83 e0 04	 and	 rax, 4
  00092	48 85 c0	 test	 rax, rax
  00095	74 37		 je	 SHORT $LN9@hthread_tr
  00097	48 63 44 24 40	 movsxd	 rax, DWORD PTR rc$[rsp]
  0009c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR tv$[rsp]
  000a1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000ab	48 8b 44 24 78	 mov	 rax, QWORD PTR obtain_loc$[rsp]
  000b0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b5	45 33 c9	 xor	 r9d, r9d
  000b8	4c 8b 44 24 70	 mov	 r8, QWORD PTR plk$[rsp]
  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159425
  000c4	b9 04 00 00 00	 mov	 ecx, 4
  000c9	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN9@hthread_tr:
  000ce	33 c0		 xor	 eax, eax
  000d0	85 c0		 test	 eax, eax
  000d2	75 b3		 jne	 SHORT $LN7@hthread_tr

; 671  :     if (rc && EBUSY != rc)

  000d4	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  000d9	74 21		 je	 SHORT $LN10@hthread_tr
  000db	83 7c 24 40 10	 cmp	 DWORD PTR rc$[rsp], 16
  000e0	74 1a		 je	 SHORT $LN10@hthread_tr

; 672  :         loglock( ilk, rc, "try_obtain_lock", obtain_loc );

  000e2	4c 8b 4c 24 78	 mov	 r9, QWORD PTR obtain_loc$[rsp]
  000e7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159427
  000ee	8b 54 24 40	 mov	 edx, DWORD PTR rc$[rsp]
  000f2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ilk$[rsp]
  000f7	e8 00 00 00 00	 call	 loglock
$LN10@hthread_tr:

; 673  :     if (!rc || EOWNERDEAD == rc)

  000fc	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  00101	74 0a		 je	 SHORT $LN12@hthread_tr
  00103	81 7c 24 40 85
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 133	; 00000085H
  0010b	75 4b		 jne	 SHORT $LN11@hthread_tr
$LN12@hthread_tr:

; 674  :     {
; 675  :         hthread_mutex_lock( &ilk->il_locklock );

  0010d	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  00112	48 83 c0 38	 add	 rax, 56			; 00000038H
  00116	48 8b c8	 mov	 rcx, rax
  00119	e8 00 00 00 00	 call	 fthread_mutex_lock

; 676  :         {
; 677  :             ilk->il_ob_locat = obtain_loc;

  0011e	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  00123	48 8b 4c 24 78	 mov	 rcx, QWORD PTR obtain_loc$[rsp]
  00128	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 678  :             ilk->il_ob_tid = hthread_self();

  0012c	e8 00 00 00 00	 call	 fthread_self
  00131	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ilk$[rsp]
  00136	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 679  :             memcpy( &ilk->il_ob_time, &tv, sizeof( TIMEVAL ));

  00139	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  0013e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv$[rsp]
  00143	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 680  :         }
; 681  :         hthread_mutex_unlock( &ilk->il_locklock );

  00147	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  0014c	48 83 c0 38	 add	 rax, 56			; 00000038H
  00150	48 8b c8	 mov	 rcx, rax
  00153	e8 00 00 00 00	 call	 fthread_mutex_unlock
$LN11@hthread_tr:

; 682  :     }
; 683  :     return rc;

  00158	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]

; 684  : }

  0015c	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00160	c3		 ret	 0
hthread_try_obtain_lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 64
ilk$ = 72
waitdur$ = 80
tv$ = 88
plk$ = 112
obtain_loc$ = 120
hthread_obtain_lock PROC

; 502  : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 503  :     int rc;
; 504  :     U64 waitdur;
; 505  :     ILOCK* ilk;
; 506  :     TIMEVAL tv;
; 507  :     ilk = (ILOCK*) plk->ilk;

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR plk$[rsp]
  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00016	48 89 44 24 48	 mov	 QWORD PTR ilk$[rsp], rax

; 508  :     hthread_obtaining_lock( plk, obtain_loc );

  0001b	48 8b 54 24 78	 mov	 rdx, QWORD PTR obtain_loc$[rsp]
  00020	48 8b 4c 24 70	 mov	 rcx, QWORD PTR plk$[rsp]
  00025	e8 00 00 00 00	 call	 hthread_obtaining_lock
$LN4@hthread_ob:

; 509  :     PTTRACE( "lock before", plk, NULL, obtain_loc, PTT_MAGIC );

  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  00031	48 83 e0 04	 and	 rax, 4
  00035	48 85 c0	 test	 rax, rax
  00038	74 35		 je	 SHORT $LN8@hthread_ob
  0003a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00043	48 c7 44 24 28
	9d ff ff ff	 mov	 QWORD PTR [rsp+40], -99	; ffffffffffffff9dH
  0004c	48 8b 44 24 78	 mov	 rax, QWORD PTR obtain_loc$[rsp]
  00051	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00056	45 33 c9	 xor	 r9d, r9d
  00059	4c 8b 44 24 70	 mov	 r8, QWORD PTR plk$[rsp]
  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159317
  00065	b9 04 00 00 00	 mov	 ecx, 4
  0006a	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN8@hthread_ob:
  0006f	33 c0		 xor	 eax, eax
  00071	85 c0		 test	 eax, eax
  00073	75 b5		 jne	 SHORT $LN4@hthread_ob

; 510  :     rc = hthread_mutex_trylock( &ilk->il_lock );

  00075	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  0007a	48 83 c0 40	 add	 rax, 64			; 00000040H
  0007e	48 8b c8	 mov	 rcx, rax
  00081	e8 00 00 00 00	 call	 fthread_mutex_trylock
  00086	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 511  :     if (EBUSY == rc)

  0008a	83 7c 24 40 10	 cmp	 DWORD PTR rc$[rsp], 16
  0008f	75 3c		 jne	 SHORT $LN9@hthread_ob

; 512  :     {
; 513  :         waitdur = host_tod();

  00091	e8 00 00 00 00	 call	 host_tod
  00096	48 89 44 24 50	 mov	 QWORD PTR waitdur$[rsp], rax

; 514  :         rc = hthread_mutex_lock( &ilk->il_lock );

  0009b	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  000a0	48 83 c0 40	 add	 rax, 64			; 00000040H
  000a4	48 8b c8	 mov	 rcx, rax
  000a7	e8 00 00 00 00	 call	 fthread_mutex_lock
  000ac	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 515  :         gettimeofday( &tv, NULL );

  000b0	33 d2		 xor	 edx, edx
  000b2	48 8d 4c 24 58	 lea	 rcx, QWORD PTR tv$[rsp]
  000b7	e8 00 00 00 00	 call	 gettimeofday

; 516  :         waitdur = host_tod() - waitdur;

  000bc	e8 00 00 00 00	 call	 host_tod
  000c1	48 2b 44 24 50	 sub	 rax, QWORD PTR waitdur$[rsp]
  000c6	48 89 44 24 50	 mov	 QWORD PTR waitdur$[rsp], rax

; 517  :     }

  000cb	eb 15		 jmp	 SHORT $LN10@hthread_ob
$LN9@hthread_ob:

; 518  :     else
; 519  :     {
; 520  :         gettimeofday( &tv, NULL );

  000cd	33 d2		 xor	 edx, edx
  000cf	48 8d 4c 24 58	 lea	 rcx, QWORD PTR tv$[rsp]
  000d4	e8 00 00 00 00	 call	 gettimeofday

; 521  :         waitdur = 0;

  000d9	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR waitdur$[rsp], 0
$LN10@hthread_ob:
$LN7@hthread_ob:

; 522  :     }
; 523  :     PTTRACE2( "lock after", plk, (void*) waitdur, obtain_loc, rc, &tv );

  000e2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  000e9	48 83 e0 04	 and	 rax, 4
  000ed	48 85 c0	 test	 rax, rax
  000f0	74 39		 je	 SHORT $LN11@hthread_ob
  000f2	48 63 44 24 40	 movsxd	 rax, DWORD PTR rc$[rsp]
  000f7	48 8d 4c 24 58	 lea	 rcx, QWORD PTR tv$[rsp]
  000fc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00101	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00106	48 8b 44 24 78	 mov	 rax, QWORD PTR obtain_loc$[rsp]
  0010b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00110	4c 8b 4c 24 50	 mov	 r9, QWORD PTR waitdur$[rsp]
  00115	4c 8b 44 24 70	 mov	 r8, QWORD PTR plk$[rsp]
  0011a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159321
  00121	b9 04 00 00 00	 mov	 ecx, 4
  00126	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN11@hthread_ob:
  0012b	33 c0		 xor	 eax, eax
  0012d	85 c0		 test	 eax, eax
  0012f	75 b1		 jne	 SHORT $LN7@hthread_ob

; 524  :     hthread_lock_obtained();

  00131	e8 00 00 00 00	 call	 hthread_lock_obtained

; 525  :     if (rc)

  00136	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  0013b	74 1a		 je	 SHORT $LN12@hthread_ob

; 526  :         loglock( ilk, rc, "obtain_lock", obtain_loc );

  0013d	4c 8b 4c 24 78	 mov	 r9, QWORD PTR obtain_loc$[rsp]
  00142	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159323
  00149	8b 54 24 40	 mov	 edx, DWORD PTR rc$[rsp]
  0014d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ilk$[rsp]
  00152	e8 00 00 00 00	 call	 loglock
$LN12@hthread_ob:

; 527  :     if (!rc || EOWNERDEAD == rc)

  00157	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  0015c	74 0a		 je	 SHORT $LN14@hthread_ob
  0015e	81 7c 24 40 85
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 133	; 00000085H
  00166	75 4b		 jne	 SHORT $LN13@hthread_ob
$LN14@hthread_ob:

; 528  :     {
; 529  :         hthread_mutex_lock( &ilk->il_locklock );

  00168	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  0016d	48 83 c0 38	 add	 rax, 56			; 00000038H
  00171	48 8b c8	 mov	 rcx, rax
  00174	e8 00 00 00 00	 call	 fthread_mutex_lock

; 530  :         {
; 531  :             ilk->il_ob_locat = obtain_loc;

  00179	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  0017e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR obtain_loc$[rsp]
  00183	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 532  :             ilk->il_ob_tid = hthread_self();

  00187	e8 00 00 00 00	 call	 fthread_self
  0018c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ilk$[rsp]
  00191	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 533  :             memcpy( &ilk->il_ob_time, &tv, sizeof( TIMEVAL ));

  00194	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  00199	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv$[rsp]
  0019e	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 534  :         }
; 535  :         hthread_mutex_unlock( &ilk->il_locklock );

  001a2	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  001a7	48 83 c0 38	 add	 rax, 56			; 00000038H
  001ab	48 8b c8	 mov	 rcx, rax
  001ae	e8 00 00 00 00	 call	 fthread_mutex_unlock
$LN13@hthread_ob:

; 536  :     }
; 537  :     return rc;

  001b3	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]

; 538  : }

  001b7	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001bb	c3		 ret	 0
hthread_obtain_lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$ = 64
attr$ = 68
ilk$ = 72
_EX_Head$1 = 80
_EX_Next$2 = 88
plk$ = 112
name$ = 120
create_loc$ = 128
hthread_initialize_lock PROC

; 278  : {

$LN14:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 279  :     int     rc;
; 280  :     MATTR   attr;     /* for internal lock structure lock */
; 281  :     ILOCK*  ilk;
; 282  : 
; 283  :     LockLocksList();

  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:listlock
  0001a	e8 00 00 00 00	 call	 fthread_mutex_lock

; 284  :     {
; 285  :         ilk = hthreads_find_ILOCK_locked( plk, NULL );

  0001f	33 d2		 xor	 edx, edx
  00021	48 8b 4c 24 70	 mov	 rcx, QWORD PTR plk$[rsp]
  00026	e8 00 00 00 00	 call	 hthreads_find_ILOCK_locked
  0002b	48 89 44 24 48	 mov	 QWORD PTR ilk$[rsp], rax

; 286  : 
; 287  :         if (ilk)

  00030	48 83 7c 24 48
	00		 cmp	 QWORD PTR ilk$[rsp], 0
  00036	74 34		 je	 SHORT $LN5@hthread_in

; 288  :         {
; 289  :             loglock( ilk, EEXIST, "initialize lock", create_loc );

  00038	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR create_loc$[rsp]
  00040	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159203
  00047	ba 11 00 00 00	 mov	 edx, 17
  0004c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ilk$[rsp]
  00051	e8 00 00 00 00	 call	 loglock

; 290  :             UnlockLocksList();

  00056	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:listlock
  0005d	e8 00 00 00 00	 call	 fthread_mutex_unlock

; 291  :             return EEXIST;

  00062	b8 11 00 00 00	 mov	 eax, 17
  00067	e9 27 02 00 00	 jmp	 $LN1@hthread_in
$LN5@hthread_in:

; 292  :         }
; 293  : 
; 294  :         if (!(ilk = calloc_aligned( sizeof( ILOCK ), 64 )))

  0006c	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00071	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  00076	e8 00 00 00 00	 call	 calloc_aligned
  0007b	48 89 44 24 48	 mov	 QWORD PTR ilk$[rsp], rax
  00080	48 83 7c 24 48
	00		 cmp	 QWORD PTR ilk$[rsp], 0
  00086	75 05		 jne	 SHORT $LN6@hthread_in

; 295  :             goto fatal;

  00088	e9 ee 01 00 00	 jmp	 $fatal$15
$LN6@hthread_in:

; 296  : 
; 297  :         gettimeofday( &ilk->il_cr_time, NULL );

  0008d	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  00092	48 83 c0 50	 add	 rax, 80			; 00000050H
  00096	33 d2		 xor	 edx, edx
  00098	48 8b c8	 mov	 rcx, rax
  0009b	e8 00 00 00 00	 call	 gettimeofday

; 298  : 
; 299  :         ilk->il_addr             =  plk;

  000a0	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  000a5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR plk$[rsp]
  000aa	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 300  :         ilk->il_name             =  strdup( name );

  000ae	48 8b 4c 24 78	 mov	 rcx, QWORD PTR name$[rsp]
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  000b9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ilk$[rsp]
  000be	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 301  :         ilk->il_cr_locat         =  create_loc;

  000c2	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  000c7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR create_loc$[rsp]
  000cf	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 302  :         ilk->il_cr_tid           =  hthread_self();

  000d3	e8 00 00 00 00	 call	 fthread_self
  000d8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ilk$[rsp]
  000dd	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 303  :         ilk->il_ob_locat         =  "null:0";

  000e0	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  000e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159205
  000ec	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 304  :         ilk->il_ob_time.tv_sec   =  0;

  000f0	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  000f5	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [rax+40], 0

; 305  :         ilk->il_ob_time.tv_usec  =  0;

  000fc	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  00101	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [rax+44], 0

; 306  :         ilk->il_ob_tid           =  0;

  00108	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  0010d	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 307  : 
; 308  :         /* Initialize the requested lock */
; 309  : 
; 310  :         rc = hthread_mutexattr_init( &attr );

  00114	48 8d 4c 24 44	 lea	 rcx, QWORD PTR attr$[rsp]
  00119	e8 00 00 00 00	 call	 fthread_mutexattr_init
  0011e	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 311  :         if (rc)

  00122	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  00127	74 05		 je	 SHORT $LN7@hthread_in

; 312  :             goto fatal;

  00129	e9 4d 01 00 00	 jmp	 $fatal$15
$LN7@hthread_in:

; 313  : 
; 314  :         rc = hthread_mutexattr_settype( &attr, HTHREAD_MUTEX_DEFAULT );

  0012e	ba 65 63 6e 4f	 mov	 edx, 1332634469		; 4f6e6365H
  00133	48 8d 4c 24 44	 lea	 rcx, QWORD PTR attr$[rsp]
  00138	e8 00 00 00 00	 call	 fthread_mutexattr_settype
  0013d	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 315  :         if (rc)

  00141	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  00146	74 05		 je	 SHORT $LN8@hthread_in

; 316  :             goto fatal;

  00148	e9 2e 01 00 00	 jmp	 $fatal$15
$LN8@hthread_in:

; 317  : 
; 318  :         rc = hthread_mutex_init( &ilk->il_locklock, &attr );

  0014d	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  00152	48 83 c0 38	 add	 rax, 56			; 00000038H
  00156	48 8d 54 24 44	 lea	 rdx, QWORD PTR attr$[rsp]
  0015b	48 8b c8	 mov	 rcx, rax
  0015e	e8 00 00 00 00	 call	 fthread_mutex_init
  00163	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 319  :         if (rc)

  00167	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  0016c	74 05		 je	 SHORT $LN9@hthread_in

; 320  :             goto fatal;

  0016e	e9 08 01 00 00	 jmp	 $fatal$15
$LN9@hthread_in:

; 321  : 
; 322  :         rc = hthread_mutex_init( &ilk->il_lock, &attr );

  00173	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  00178	48 83 c0 40	 add	 rax, 64			; 00000040H
  0017c	48 8d 54 24 44	 lea	 rdx, QWORD PTR attr$[rsp]
  00181	48 8b c8	 mov	 rcx, rax
  00184	e8 00 00 00 00	 call	 fthread_mutex_init
  00189	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 323  :         if (rc)

  0018d	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  00192	74 05		 je	 SHORT $LN10@hthread_in

; 324  :             goto fatal;

  00194	e9 e2 00 00 00	 jmp	 $fatal$15
$LN10@hthread_in:

; 325  : 
; 326  :         rc = hthread_mutexattr_destroy( &attr );

  00199	48 8d 4c 24 44	 lea	 rcx, QWORD PTR attr$[rsp]
  0019e	e8 00 00 00 00	 call	 fthread_mutexattr_destroy
  001a3	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 327  :         if (rc)

  001a7	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  001ac	74 05		 je	 SHORT $LN11@hthread_in

; 328  :             goto fatal;

  001ae	e9 c8 00 00 00	 jmp	 $fatal$15
$LN11@hthread_in:

; 329  : 
; 330  :         plk->ilk = ilk; /* (LOCK is now initialized) */

  001b3	48 8b 44 24 70	 mov	 rax, QWORD PTR plk$[rsp]
  001b8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ilk$[rsp]
  001bd	48 89 08	 mov	 QWORD PTR [rax], rcx

; 331  : 
; 332  :         InsertListHead( &locklist, &ilk->il_link );

  001c0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:locklist
  001c7	48 89 44 24 50	 mov	 QWORD PTR _EX_Head$1[rsp], rax
  001cc	48 8b 44 24 50	 mov	 rax, QWORD PTR _EX_Head$1[rsp]
  001d1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001d4	48 89 44 24 58	 mov	 QWORD PTR _EX_Next$2[rsp], rax
  001d9	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  001de	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _EX_Next$2[rsp]
  001e3	48 89 08	 mov	 QWORD PTR [rax], rcx
  001e6	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  001eb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _EX_Head$1[rsp]
  001f0	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  001f4	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  001f9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _EX_Head$1[rsp]
  001fe	48 89 01	 mov	 QWORD PTR [rcx], rax
  00201	48 8b 44 24 48	 mov	 rax, QWORD PTR ilk$[rsp]
  00206	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _EX_Next$2[rsp]
  0020b	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 333  :         lockcount++;

  0020f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR lockcount
  00215	ff c0		 inc	 eax
  00217	89 05 00 00 00
	00		 mov	 DWORD PTR lockcount, eax
$LN4@hthread_in:

; 334  : 
; 335  :         PTTRACE( "lock init", plk, 0, create_loc, PTT_MAGIC );

  0021d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  00224	48 83 e0 04	 and	 rax, 4
  00228	48 85 c0	 test	 rax, rax
  0022b	74 38		 je	 SHORT $LN12@hthread_in
  0022d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00236	48 c7 44 24 28
	9d ff ff ff	 mov	 QWORD PTR [rsp+40], -99	; ffffffffffffff9dH
  0023f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR create_loc$[rsp]
  00247	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0024c	45 33 c9	 xor	 r9d, r9d
  0024f	4c 8b 44 24 70	 mov	 r8, QWORD PTR plk$[rsp]
  00254	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159212
  0025b	b9 04 00 00 00	 mov	 ecx, 4
  00260	e8 00 00 00 00	 call	 ptt_pthread_trace
$LN12@hthread_in:
  00265	33 c0		 xor	 eax, eax
  00267	85 c0		 test	 eax, eax
  00269	75 b2		 jne	 SHORT $LN4@hthread_in

; 336  :     }
; 337  :     UnlockLocksList();

  0026b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:listlock
  00272	e8 00 00 00 00	 call	 fthread_mutex_unlock

; 338  : 
; 339  :     return 0;

  00277	33 c0		 xor	 eax, eax
  00279	eb 18		 jmp	 SHORT $LN1@hthread_in
$fatal$15:

; 340  : 
; 341  : fatal:
; 342  : 
; 343  :     perror( "Fatal error in hthread_initialize_lock function" );

  0027b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159213
  00282	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_perror

; 344  :     exit(1);

  00288	b9 01 00 00 00	 mov	 ecx, 1
  0028d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN1@hthread_in:
$LN13@hthread_in:

; 345  : }

  00293	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00297	c3		 ret	 0
hthread_initialize_lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
i$ = 112
c$ = 116
tid$ = 120
rc$ = 124
ht$ = 128
k$ = 136
sortby$1 = 144
tv235 = 152
tv239 = 160
tv246 = 168
tv254 = 176
tv257 = 184
tv262 = 192
tv275 = 200
tv283 = 208
tv286 = 216
tv291 = 224
tv336 = 232
anchor$ = 240
ht_ob_time$ = 256
tod$ = 288
__$ArrayPad$ = 320
argc$ = 352
argv$ = 360
cmdline$ = 368
threads_cmd PROC

; 1547 : {

$LN51:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1548 :     LIST_ENTRY  anchor;             /* Private threads list anchor   */
; 1549 :     HTHREAD*     ht;                /* Pointer to HTHREAD array      */
; 1550 :     char         tod[27];           /* "YYYY-MM-DD HH:MM:SS.uuuuuu"  */
; 1551 :     char         ht_ob_time[27];    /* "YYYY-MM-DD HH:MM:SS.uuuuuu"  */
; 1552 :     TID          tid = 0;           /* Requested thread id           */

  00027	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tid$[rsp], 0

; 1553 :     int          i, k, rc = 0;      /* Work vars and return code     */

  0002f	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
$LN4@threads_cm:

; 1554 :     char         c;                 /* sscanf work; work flag        */
; 1555 : 
; 1556 :     UNREFERENCED( cmdline );

  00037	33 c0		 xor	 eax, eax
  00039	85 c0		 test	 eax, eax
  0003b	75 fa		 jne	 SHORT $LN4@threads_cm

; 1557 : 
; 1558 :     // Format:  threads [ALL|WAITING|tid] [SORT NAME|TID|{WHEN|TIME|TOD}|{WHERE|LOC}]
; 1559 : 
; 1560 :          if (argc <= 1)                  tid = (TID)  0;

  0003d	83 bc 24 60 01
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  00045	7f 0d		 jg	 SHORT $LN11@threads_cm
  00047	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tid$[rsp], 0
  0004f	e9 a2 00 00 00	 jmp	 $LN12@threads_cm
$LN11@threads_cm:

; 1561 :     else if (CMD( argv[1], ALL,     3 )) tid = (TID)  0;

  00054	b8 08 00 00 00	 mov	 eax, 8
  00059	48 6b c0 01	 imul	 rax, rax, 1
  0005d	41 b8 03 00 00
	00		 mov	 r8d, 3
  00063	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0006b	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160206
  00076	e8 00 00 00 00	 call	 strcaseabbrev
  0007b	85 c0		 test	 eax, eax
  0007d	74 0a		 je	 SHORT $LN13@threads_cm
  0007f	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tid$[rsp], 0
  00087	eb 6d		 jmp	 SHORT $LN14@threads_cm
$LN13@threads_cm:

; 1562 :     else if (CMD( argv[1], WAITING, 7 )) tid = (TID) -1;

  00089	b8 08 00 00 00	 mov	 eax, 8
  0008e	48 6b c0 01	 imul	 rax, rax, 1
  00092	41 b8 07 00 00
	00		 mov	 r8d, 7
  00098	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000a0	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  000a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160209
  000ab	e8 00 00 00 00	 call	 strcaseabbrev
  000b0	85 c0		 test	 eax, eax
  000b2	74 0a		 je	 SHORT $LN15@threads_cm
  000b4	c7 44 24 78 ff
	ff ff ff	 mov	 DWORD PTR tid$[rsp], -1	; ffffffffH
  000bc	eb 38		 jmp	 SHORT $LN16@threads_cm
$LN15@threads_cm:

; 1563 :     else if (sscanf( argv[1], SCN_TIDPAT "%c", &tid, &c ) != 1)

  000be	b8 08 00 00 00	 mov	 eax, 8
  000c3	48 6b c0 01	 imul	 rax, rax, 1
  000c7	4c 8d 4c 24 74	 lea	 r9, QWORD PTR c$[rsp]
  000cc	4c 8d 44 24 78	 lea	 r8, QWORD PTR tid$[rsp]
  000d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160211
  000d8	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000e0	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  000e4	e8 00 00 00 00	 call	 sscanf
  000e9	83 f8 01	 cmp	 eax, 1
  000ec	74 08		 je	 SHORT $LN17@threads_cm

; 1564 :         rc = -1;

  000ee	c7 44 24 7c ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN17@threads_cm:
$LN16@threads_cm:
$LN14@threads_cm:
$LN12@threads_cm:

; 1565 : 
; 1566 :     if (!rc)

  000f6	83 7c 24 7c 00	 cmp	 DWORD PTR rc$[rsp], 0
  000fb	0f 85 ec 06 00
	00		 jne	 $LN18@threads_cm

; 1567 :     {
; 1568 :         CMPFUNC* sortby = (CMPFUNC*) tsortby_tim;

  00101	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:tsortby_tim
  00108	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR sortby$1[rsp], rax

; 1569 : 
; 1570 :         if (argc == 4)

  00110	83 bc 24 60 01
	00 00 04	 cmp	 DWORD PTR argc$[rsp], 4
  00118	0f 85 f5 01 00
	00		 jne	 $LN19@threads_cm

; 1571 :         {
; 1572 :             if (!CMD( argv[2], SORT, 4 ))

  0011e	b8 08 00 00 00	 mov	 eax, 8
  00123	48 6b c0 02	 imul	 rax, rax, 2
  00127	41 b8 04 00 00
	00		 mov	 r8d, 4
  0012d	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00135	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  00139	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160217
  00140	e8 00 00 00 00	 call	 strcaseabbrev
  00145	85 c0		 test	 eax, eax
  00147	75 0d		 jne	 SHORT $LN21@threads_cm

; 1573 :                 rc = -1;

  00149	c7 44 24 7c ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
  00151	e9 bb 01 00 00	 jmp	 $LN22@threads_cm
$LN21@threads_cm:

; 1574 :             else
; 1575 :             {
; 1576 :                      if (CMD( argv[3], NAME,  4 )) sortby = (CMPFUNC*) tsortby_nam;

  00156	b8 08 00 00 00	 mov	 eax, 8
  0015b	48 6b c0 03	 imul	 rax, rax, 3
  0015f	41 b8 04 00 00
	00		 mov	 r8d, 4
  00165	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0016d	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  00171	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160220
  00178	e8 00 00 00 00	 call	 strcaseabbrev
  0017d	85 c0		 test	 eax, eax
  0017f	74 14		 je	 SHORT $LN23@threads_cm
  00181	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:tsortby_nam
  00188	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR sortby$1[rsp], rax
  00190	e9 7c 01 00 00	 jmp	 $LN24@threads_cm
$LN23@threads_cm:

; 1577 :                 else if (CMD( argv[3], TID,   3 )) sortby = (CMPFUNC*) tsortby_tid;

  00195	b8 08 00 00 00	 mov	 eax, 8
  0019a	48 6b c0 03	 imul	 rax, rax, 3
  0019e	41 b8 03 00 00
	00		 mov	 r8d, 3
  001a4	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001ac	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  001b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160223
  001b7	e8 00 00 00 00	 call	 strcaseabbrev
  001bc	85 c0		 test	 eax, eax
  001be	74 14		 je	 SHORT $LN25@threads_cm
  001c0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:tsortby_tid
  001c7	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR sortby$1[rsp], rax
  001cf	e9 3d 01 00 00	 jmp	 $LN26@threads_cm
$LN25@threads_cm:

; 1578 :                 else if (CMD( argv[3], WHEN,  4 )) sortby = (CMPFUNC*) tsortby_tim;

  001d4	b8 08 00 00 00	 mov	 eax, 8
  001d9	48 6b c0 03	 imul	 rax, rax, 3
  001dd	41 b8 04 00 00
	00		 mov	 r8d, 4
  001e3	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001eb	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  001ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160226
  001f6	e8 00 00 00 00	 call	 strcaseabbrev
  001fb	85 c0		 test	 eax, eax
  001fd	74 14		 je	 SHORT $LN27@threads_cm
  001ff	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:tsortby_tim
  00206	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR sortby$1[rsp], rax
  0020e	e9 fe 00 00 00	 jmp	 $LN28@threads_cm
$LN27@threads_cm:

; 1579 :                 else if (CMD( argv[3], TIME,  4 )) sortby = (CMPFUNC*) tsortby_tim;

  00213	b8 08 00 00 00	 mov	 eax, 8
  00218	48 6b c0 03	 imul	 rax, rax, 3
  0021c	41 b8 04 00 00
	00		 mov	 r8d, 4
  00222	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0022a	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  0022e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160229
  00235	e8 00 00 00 00	 call	 strcaseabbrev
  0023a	85 c0		 test	 eax, eax
  0023c	74 14		 je	 SHORT $LN29@threads_cm
  0023e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:tsortby_tim
  00245	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR sortby$1[rsp], rax
  0024d	e9 bf 00 00 00	 jmp	 $LN30@threads_cm
$LN29@threads_cm:

; 1580 :                 else if (CMD( argv[3], TOD,   3 )) sortby = (CMPFUNC*) tsortby_tim;

  00252	b8 08 00 00 00	 mov	 eax, 8
  00257	48 6b c0 03	 imul	 rax, rax, 3
  0025b	41 b8 03 00 00
	00		 mov	 r8d, 3
  00261	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00269	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  0026d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160232
  00274	e8 00 00 00 00	 call	 strcaseabbrev
  00279	85 c0		 test	 eax, eax
  0027b	74 14		 je	 SHORT $LN31@threads_cm
  0027d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:tsortby_tim
  00284	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR sortby$1[rsp], rax
  0028c	e9 80 00 00 00	 jmp	 $LN32@threads_cm
$LN31@threads_cm:

; 1581 :                 else if (CMD( argv[3], WHERE, 5 )) sortby = (CMPFUNC*) tsortby_loc;

  00291	b8 08 00 00 00	 mov	 eax, 8
  00296	48 6b c0 03	 imul	 rax, rax, 3
  0029a	41 b8 05 00 00
	00		 mov	 r8d, 5
  002a0	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002a8	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  002ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160235
  002b3	e8 00 00 00 00	 call	 strcaseabbrev
  002b8	85 c0		 test	 eax, eax
  002ba	74 11		 je	 SHORT $LN33@threads_cm
  002bc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:tsortby_loc
  002c3	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR sortby$1[rsp], rax
  002cb	eb 44		 jmp	 SHORT $LN34@threads_cm
$LN33@threads_cm:

; 1582 :                 else if (CMD( argv[3], LOC,   3 )) sortby = (CMPFUNC*) tsortby_loc;

  002cd	b8 08 00 00 00	 mov	 eax, 8
  002d2	48 6b c0 03	 imul	 rax, rax, 3
  002d6	41 b8 03 00 00
	00		 mov	 r8d, 3
  002dc	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002e4	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  002e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160238
  002ef	e8 00 00 00 00	 call	 strcaseabbrev
  002f4	85 c0		 test	 eax, eax
  002f6	74 11		 je	 SHORT $LN35@threads_cm
  002f8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:tsortby_loc
  002ff	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR sortby$1[rsp], rax
  00307	eb 08		 jmp	 SHORT $LN36@threads_cm
$LN35@threads_cm:

; 1583 :                 else
; 1584 :                     rc = -1;

  00309	c7 44 24 7c ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN36@threads_cm:
$LN34@threads_cm:
$LN32@threads_cm:
$LN30@threads_cm:
$LN28@threads_cm:
$LN26@threads_cm:
$LN24@threads_cm:
$LN22@threads_cm:

; 1585 :             }
; 1586 :         }

  00311	eb 1c		 jmp	 SHORT $LN20@threads_cm
$LN19@threads_cm:

; 1587 :         else if (argc != 1 && argc != 2)

  00313	83 bc 24 60 01
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  0031b	74 12		 je	 SHORT $LN37@threads_cm
  0031d	83 bc 24 60 01
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00325	74 08		 je	 SHORT $LN37@threads_cm

; 1588 :             rc = -1;

  00327	c7 44 24 7c ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN37@threads_cm:
$LN20@threads_cm:

; 1589 : 
; 1590 :         /* If no errors, perform the requested function */
; 1591 :         if (!rc)

  0032f	83 7c 24 7c 00	 cmp	 DWORD PTR rc$[rsp], 0
  00334	0f 85 b3 04 00
	00		 jne	 $LN38@threads_cm

; 1592 :         {
; 1593 :             /* Retrieve a copy of the threads list */
; 1594 :             k = hthreads_copy_threads_list( &ht, &anchor );

  0033a	48 8d 94 24 f0
	00 00 00	 lea	 rdx, QWORD PTR anchor$[rsp]
  00342	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR ht$[rsp]
  0034a	e8 00 00 00 00	 call	 hthreads_copy_threads_list
  0034f	89 84 24 88 00
	00 00		 mov	 DWORD PTR k$[rsp], eax

; 1595 : 
; 1596 :             /* Sort them into the requested sequence */
; 1597 :             if (k)

  00356	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR k$[rsp], 0
  0035e	0f 84 d3 03 00
	00		 je	 $LN39@threads_cm

; 1598 :             {
; 1599 :                 qsort( ht, k, sizeof( HTHREAD ), sortby );

  00364	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR k$[rsp]
  0036c	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR sortby$1[rsp]
  00374	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  0037a	48 8b d0	 mov	 rdx, rax
  0037d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ht$[rsp]
  00385	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_qsort

; 1600 : 
; 1601 :                 /* Display the requested threads */
; 1602 :                 for (c = 0 /* (zero locks found) */, i=0; i < k; i++)

  0038b	c6 44 24 74 00	 mov	 BYTE PTR c$[rsp], 0
  00390	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00398	eb 0a		 jmp	 SHORT $LN7@threads_cm
$LN5@threads_cm:
  0039a	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  0039e	ff c0		 inc	 eax
  003a0	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
$LN7@threads_cm:
  003a4	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  003ab	39 44 24 70	 cmp	 DWORD PTR i$[rsp], eax
  003af	0f 8d 33 03 00
	00		 jge	 $LN6@threads_cm

; 1603 :                 {
; 1604 :                     /* ALL, WAITING or specific TID? */
; 1605 :                     if (0
; 1606 :                         || !tid
; 1607 :                         || (equal_threads( tid, (TID) -1 ) && ht[i].ht_ob_lock)
; 1608 :                         || equal_threads( tid, ht[i].ht_tid )

  003b5	33 c0		 xor	 eax, eax
  003b7	85 c0		 test	 eax, eax
  003b9	75 58		 jne	 SHORT $LN42@threads_cm
  003bb	83 7c 24 78 00	 cmp	 DWORD PTR tid$[rsp], 0
  003c0	74 51		 je	 SHORT $LN42@threads_cm
  003c2	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  003c7	8b 4c 24 78	 mov	 ecx, DWORD PTR tid$[rsp]
  003cb	e8 00 00 00 00	 call	 hthread_equal_threads
  003d0	85 c0		 test	 eax, eax
  003d2	74 19		 je	 SHORT $LN43@threads_cm
  003d4	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  003d9	48 6b c0 50	 imul	 rax, rax, 80		; 00000050H
  003dd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ht$[rsp]
  003e5	48 83 7c 01 28
	00		 cmp	 QWORD PTR [rcx+rax+40], 0
  003eb	75 26		 jne	 SHORT $LN42@threads_cm
$LN43@threads_cm:
  003ed	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  003f2	48 6b c0 50	 imul	 rax, rax, 80		; 00000050H
  003f6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ht$[rsp]
  003fe	8b 54 01 20	 mov	 edx, DWORD PTR [rcx+rax+32]
  00402	8b 4c 24 78	 mov	 ecx, DWORD PTR tid$[rsp]
  00406	e8 00 00 00 00	 call	 hthread_equal_threads
  0040b	85 c0		 test	 eax, eax
  0040d	0f 84 d0 02 00
	00		 je	 $LN41@threads_cm
$LN42@threads_cm:

; 1609 :                     )
; 1610 :                     {
; 1611 :                         c = 1;  /* (at least one lock found) */

  00413	c6 44 24 74 01	 mov	 BYTE PTR c$[rsp], 1

; 1612 : 
; 1613 :                         FormatTIMEVAL( &ht[i].ht_cr_time, tod, sizeof( tod ));

  00418	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0041d	48 6b c0 50	 imul	 rax, rax, 80		; 00000050H
  00421	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ht$[rsp]
  00429	48 8d 44 01 18	 lea	 rax, QWORD PTR [rcx+rax+24]
  0042e	41 b8 1b 00 00
	00		 mov	 r8d, 27
  00434	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR tod$[rsp]
  0043c	48 8b c8	 mov	 rcx, rax
  0043f	e8 00 00 00 00	 call	 FormatTIMEVAL

; 1614 : 
; 1615 :                         if (equal_threads( tid, (TID) -1 ) && ht[i].ht_ob_lock)

  00444	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  00449	8b 4c 24 78	 mov	 ecx, DWORD PTR tid$[rsp]
  0044d	e8 00 00 00 00	 call	 hthread_equal_threads
  00452	85 c0		 test	 eax, eax
  00454	0f 84 99 01 00
	00		 je	 $LN44@threads_cm
  0045a	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0045f	48 6b c0 50	 imul	 rax, rax, 80		; 00000050H
  00463	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ht$[rsp]
  0046b	48 83 7c 01 28
	00		 cmp	 QWORD PTR [rcx+rax+40], 0
  00471	0f 84 7c 01 00
	00		 je	 $LN44@threads_cm

; 1616 :                         {
; 1617 :                             FormatTIMEVAL( &ht[i].ht_ob_time, ht_ob_time, sizeof( ht_ob_time ));

  00477	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0047c	48 6b c0 50	 imul	 rax, rax, 80		; 00000050H
  00480	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ht$[rsp]
  00488	48 8d 44 01 30	 lea	 rax, QWORD PTR [rcx+rax+48]
  0048d	41 b8 1b 00 00
	00		 mov	 r8d, 27
  00493	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR ht_ob_time$[rsp]
  0049b	48 8b c8	 mov	 rcx, rax
  0049e	e8 00 00 00 00	 call	 FormatTIMEVAL

; 1618 : 
; 1619 :                             // "Thread %-15.15s tid="TIDPAT" waiting since %s at %s for lock %s = "PTR_FMTx
; 1620 : 
; 1621 :                             WRMSG( HHC90023, "W", ht[i].ht_name, TID_CAST( ht[i].ht_tid ),

  004a3	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  004a8	48 6b c0 50	 imul	 rax, rax, 80		; 00000050H
  004ac	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv235[rsp], rax
  004b4	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$[rsp]
  004b9	48 6b c9 50	 imul	 rcx, rcx, 80		; 00000050H
  004bd	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR ht$[rsp]
  004c5	48 8b 4c 0a 28	 mov	 rcx, QWORD PTR [rdx+rcx+40]
  004ca	e8 00 00 00 00	 call	 hthread_get_lock_name
  004cf	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv239[rsp], rax
  004d7	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$[rsp]
  004dc	48 6b c9 50	 imul	 rcx, rcx, 80		; 00000050H
  004e0	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR ht$[rsp]
  004e8	48 8b 4c 0a 38	 mov	 rcx, QWORD PTR [rdx+rcx+56]
  004ed	e8 00 00 00 00	 call	 trimloc
  004f2	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv246[rsp], rax
  004fa	b9 01 00 00 00	 mov	 ecx, 1
  004ff	48 6b c9 0b	 imul	 rcx, rcx, 11
  00503	48 8d 8c 0c 00
	01 00 00	 lea	 rcx, QWORD PTR ht_ob_time$[rsp+rcx]
  0050b	48 89 8c 24 b0
	00 00 00	 mov	 QWORD PTR tv254[rsp], rcx
  00513	48 63 54 24 70	 movsxd	 rdx, DWORD PTR i$[rsp]
  00518	48 6b d2 50	 imul	 rdx, rdx, 80		; 00000050H
  0051c	48 89 94 24 b8
	00 00 00	 mov	 QWORD PTR tv257[rsp], rdx
  00524	4c 63 44 24 70	 movsxd	 r8, DWORD PTR i$[rsp]
  00529	4d 6b c0 50	 imul	 r8, r8, 80		; 00000050H
  0052d	4c 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv262[rsp], r8
  00535	b9 01 00 00 00	 mov	 ecx, 1
  0053a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00540	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ht$[rsp]
  00548	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR tv235[rsp]
  00550	48 8b 4c 11 28	 mov	 rcx, QWORD PTR [rcx+rdx+40]
  00555	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  0055a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv239[rsp]
  00562	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00567	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv246[rsp]
  0056f	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00574	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv254[rsp]
  0057c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00581	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ht$[rsp]
  00589	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR tv257[rsp]
  00591	8b 4c 11 20	 mov	 ecx, DWORD PTR [rcx+rdx+32]
  00595	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00599	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ht$[rsp]
  005a1	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR tv262[rsp]
  005a9	48 8b 4c 11 40	 mov	 rcx, QWORD PTR [rcx+rdx+64]
  005ae	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  005b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160248
  005ba	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160249
  005c6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005cb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005d0	41 b9 03 00 00
	00		 mov	 r9d, 3
  005d6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160250
  005dd	ba 57 06 00 00	 mov	 edx, 1623		; 00000657H
  005e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160251
  005e9	e8 00 00 00 00	 call	 fwritemsg

; 1622 :                                 &ht_ob_time[11], TRIMLOC( ht[i].ht_ob_where ),
; 1623 :                                 get_lock_name( ht[i].ht_ob_lock ), PTR_CAST( ht[i].ht_ob_lock ));
; 1624 :                         }

  005ee	e9 f0 00 00 00	 jmp	 $LN45@threads_cm
$LN44@threads_cm:

; 1625 :                         else
; 1626 :                         {
; 1627 :                             // "Thread %-15.15s tid="TIDPAT" created on %s at %-18.18s"
; 1628 : 
; 1629 :                             WRMSG( HHC90022, "I", ht[i].ht_name, TID_CAST( ht[i].ht_tid ),

  005f3	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  005f8	48 6b c0 50	 imul	 rax, rax, 80		; 00000050H
  005fc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ht$[rsp]
  00604	48 8b 4c 01 10	 mov	 rcx, QWORD PTR [rcx+rax+16]
  00609	e8 00 00 00 00	 call	 trimloc
  0060e	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv275[rsp], rax
  00616	b9 01 00 00 00	 mov	 ecx, 1
  0061b	48 6b c9 0b	 imul	 rcx, rcx, 11
  0061f	48 8d 8c 0c 20
	01 00 00	 lea	 rcx, QWORD PTR tod$[rsp+rcx]
  00627	48 89 8c 24 d0
	00 00 00	 mov	 QWORD PTR tv283[rsp], rcx
  0062f	48 63 54 24 70	 movsxd	 rdx, DWORD PTR i$[rsp]
  00634	48 6b d2 50	 imul	 rdx, rdx, 80		; 00000050H
  00638	48 89 94 24 d8
	00 00 00	 mov	 QWORD PTR tv286[rsp], rdx
  00640	4c 63 44 24 70	 movsxd	 r8, DWORD PTR i$[rsp]
  00645	4d 6b c0 50	 imul	 r8, r8, 80		; 00000050H
  00649	4c 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv291[rsp], r8
  00651	b9 01 00 00 00	 mov	 ecx, 1
  00656	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0065c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv275[rsp]
  00664	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00669	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv283[rsp]
  00671	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00676	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ht$[rsp]
  0067e	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR tv286[rsp]
  00686	8b 4c 11 20	 mov	 ecx, DWORD PTR [rcx+rdx+32]
  0068a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0068e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ht$[rsp]
  00696	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR tv291[rsp]
  0069e	48 8b 4c 11 40	 mov	 rcx, QWORD PTR [rcx+rdx+64]
  006a3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  006a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160252
  006af	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160253
  006bb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006c0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006c5	41 b9 03 00 00
	00		 mov	 r9d, 3
  006cb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160254
  006d2	ba 5e 06 00 00	 mov	 edx, 1630		; 0000065eH
  006d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160255
  006de	e8 00 00 00 00	 call	 fwritemsg
$LN45@threads_cm:
$LN41@threads_cm:

; 1630 :                                 &tod[11], TRIMLOC( ht[i].ht_cr_locat ));
; 1631 :                         }
; 1632 :                     }
; 1633 :                 }

  006e3	e9 b2 fc ff ff	 jmp	 $LN5@threads_cm
$LN6@threads_cm:

; 1634 : 
; 1635 :                 /* Free our copy of the threads list */
; 1636 :                 for (i=0; i < k; i++)

  006e8	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  006f0	eb 0a		 jmp	 SHORT $LN10@threads_cm
$LN8@threads_cm:
  006f2	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  006f6	ff c0		 inc	 eax
  006f8	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
$LN10@threads_cm:
  006fc	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  00703	39 44 24 70	 cmp	 DWORD PTR i$[rsp], eax
  00707	7d 1e		 jge	 SHORT $LN9@threads_cm

; 1637 :                     free( ht[i].ht_name );

  00709	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0070e	48 6b c0 50	 imul	 rax, rax, 80		; 00000050H
  00712	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ht$[rsp]
  0071a	48 8b 4c 01 40	 mov	 rcx, QWORD PTR [rcx+rax+64]
  0071f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00725	eb cb		 jmp	 SHORT $LN8@threads_cm
$LN9@threads_cm:

; 1638 :                 free( ht );

  00727	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ht$[rsp]
  0072f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1639 :             }

  00735	eb 05		 jmp	 SHORT $LN40@threads_cm
$LN39@threads_cm:

; 1640 :             else
; 1641 :                 c = 1;

  00737	c6 44 24 74 01	 mov	 BYTE PTR c$[rsp], 1
$LN40@threads_cm:

; 1642 : 
; 1643 :             /* Print results */
; 1644 :             if (!c)

  0073c	0f be 44 24 74	 movsx	 eax, BYTE PTR c$[rsp]
  00741	85 c0		 test	 eax, eax
  00743	75 50		 jne	 SHORT $LN46@threads_cm

; 1645 :             {
; 1646 :                 // "No threads found with tid "TIDPAT"."
; 1647 :                 WRMSG( HHC90026, "W", TID_CAST( tid ));

  00745	b9 01 00 00 00	 mov	 ecx, 1
  0074a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00750	8b 4c 24 78	 mov	 ecx, DWORD PTR tid$[rsp]
  00754	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00758	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160258
  0075f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00764	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160259
  0076b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00770	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00775	41 b9 03 00 00
	00		 mov	 r9d, 3
  0077b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160260
  00782	ba 6f 06 00 00	 mov	 edx, 1647		; 0000066fH
  00787	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160261
  0078e	e8 00 00 00 00	 call	 fwritemsg

; 1648 :             }

  00793	eb 58		 jmp	 SHORT $LN47@threads_cm
$LN46@threads_cm:

; 1649 :             else if (!tid)

  00795	83 7c 24 78 00	 cmp	 DWORD PTR tid$[rsp], 0
  0079a	75 51		 jne	 SHORT $LN48@threads_cm

; 1650 :             {
; 1651 :                 // "Total threads running: %d"
; 1652 :                 WRMSG( HHC90027, "I", k );

  0079c	b9 01 00 00 00	 mov	 ecx, 1
  007a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007a7	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR k$[rsp]
  007ae	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  007b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160263
  007b9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160264
  007c5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007ca	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007cf	41 b9 03 00 00
	00		 mov	 r9d, 3
  007d5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160265
  007dc	ba 74 06 00 00	 mov	 edx, 1652		; 00000674H
  007e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160266
  007e8	e8 00 00 00 00	 call	 fwritemsg
$LN48@threads_cm:
$LN47@threads_cm:
$LN38@threads_cm:
$LN18@threads_cm:

; 1653 :             }
; 1654 :         }
; 1655 :     }
; 1656 : 
; 1657 :     if (rc)

  007ed	83 7c 24 7c 00	 cmp	 DWORD PTR rc$[rsp], 0
  007f2	74 70		 je	 SHORT $LN49@threads_cm

; 1658 :     {
; 1659 :         // "Invalid argument(s). Type 'help %s' for assistance."
; 1660 :         WRMSG( HHC02211, "E", argv[0] );

  007f4	b8 08 00 00 00	 mov	 eax, 8
  007f9	48 6b c0 00	 imul	 rax, rax, 0
  007fd	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv336[rsp], rax
  00805	b9 01 00 00 00	 mov	 ecx, 1
  0080a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00810	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00818	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR tv336[rsp]
  00820	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00824	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00829	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160268
  00830	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00835	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160269
  0083c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00841	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00846	41 b9 03 00 00
	00		 mov	 r9d, 3
  0084c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160270
  00853	ba 7c 06 00 00	 mov	 edx, 1660		; 0000067cH
  00858	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160271
  0085f	e8 00 00 00 00	 call	 fwritemsg
$LN49@threads_cm:

; 1661 :     }
; 1662 : 
; 1663 :     return rc;

  00864	8b 44 24 7c	 mov	 eax, DWORD PTR rc$[rsp]

; 1664 : }

  00868	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00870	48 33 cc	 xor	 rcx, rsp
  00873	e8 00 00 00 00	 call	 __security_check_cookie
  00878	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  0087f	c3		 ret	 0
threads_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
i$ = 112
c$ = 116
tid$ = 120
ilk$ = 128
rc$ = 136
k$ = 140
sortby$1 = 144
tv221 = 152
tv242 = 160
tv246 = 168
tv251 = 176
tv256 = 184
tv274 = 192
tv295 = 200
tv299 = 208
tv304 = 216
tv309 = 224
tv354 = 232
anchor$ = 240
threadname$2 = 256
tod$3 = 272
__$ArrayPad$ = 304
argc$ = 336
argv$ = 344
cmdline$ = 352
locks_cmd PROC

; 1281 : {

$LN52:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1282 :     LIST_ENTRY  anchor;             /* Private locks list anchor     */
; 1283 :     ILOCK*      ilk;                /* Pointer to ILOCK array        */
; 1284 :     TID         tid = 0;            /* Requested thread id           */

  00027	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tid$[rsp], 0

; 1285 :     int         i, k, rc = 0;       /* Work vars and return code     */

  0002f	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR rc$[rsp], 0
$LN4@locks_cmd:

; 1286 :     char        c;                  /* sscanf work; work flag        */
; 1287 : 
; 1288 :     UNREFERENCED( cmdline );

  0003a	33 c0		 xor	 eax, eax
  0003c	85 c0		 test	 eax, eax
  0003e	75 fa		 jne	 SHORT $LN4@locks_cmd

; 1289 : 
; 1290 :     /*  Format: "locks [ALL|HELD|tid] [SORT NAME|{TID|OWNER}|{WHEN|TIME|TOD}|{WHERE|LOC}]"  */
; 1291 : 
; 1292 :          if (argc <= 1)               tid = (TID)  0;

  00040	83 bc 24 50 01
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  00048	7f 0d		 jg	 SHORT $LN11@locks_cmd
  0004a	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tid$[rsp], 0
  00052	e9 a5 00 00 00	 jmp	 $LN12@locks_cmd
$LN11@locks_cmd:

; 1293 :     else if (CMD( argv[1], ALL,  3 )) tid = (TID)  0;

  00057	b8 08 00 00 00	 mov	 eax, 8
  0005c	48 6b c0 01	 imul	 rax, rax, 1
  00060	41 b8 03 00 00
	00		 mov	 r8d, 3
  00066	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0006e	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159997
  00079	e8 00 00 00 00	 call	 strcaseabbrev
  0007e	85 c0		 test	 eax, eax
  00080	74 0a		 je	 SHORT $LN13@locks_cmd
  00082	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tid$[rsp], 0
  0008a	eb 70		 jmp	 SHORT $LN14@locks_cmd
$LN13@locks_cmd:

; 1294 :     else if (CMD( argv[1], HELD, 4 )) tid = (TID) -1;

  0008c	b8 08 00 00 00	 mov	 eax, 8
  00091	48 6b c0 01	 imul	 rax, rax, 1
  00095	41 b8 04 00 00
	00		 mov	 r8d, 4
  0009b	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000a3	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160000
  000ae	e8 00 00 00 00	 call	 strcaseabbrev
  000b3	85 c0		 test	 eax, eax
  000b5	74 0a		 je	 SHORT $LN15@locks_cmd
  000b7	c7 44 24 78 ff
	ff ff ff	 mov	 DWORD PTR tid$[rsp], -1	; ffffffffH
  000bf	eb 3b		 jmp	 SHORT $LN16@locks_cmd
$LN15@locks_cmd:

; 1295 :     else if (sscanf( argv[1], SCN_TIDPAT "%c", &tid, &c ) != 1)

  000c1	b8 08 00 00 00	 mov	 eax, 8
  000c6	48 6b c0 01	 imul	 rax, rax, 1
  000ca	4c 8d 4c 24 74	 lea	 r9, QWORD PTR c$[rsp]
  000cf	4c 8d 44 24 78	 lea	 r8, QWORD PTR tid$[rsp]
  000d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160002
  000db	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000e3	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  000e7	e8 00 00 00 00	 call	 sscanf
  000ec	83 f8 01	 cmp	 eax, 1
  000ef	74 0b		 je	 SHORT $LN17@locks_cmd

; 1296 :         rc = -1;

  000f1	c7 84 24 88 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR rc$[rsp], -1
$LN17@locks_cmd:
$LN16@locks_cmd:
$LN14@locks_cmd:
$LN12@locks_cmd:

; 1297 : 
; 1298 :     if (!rc)

  000fc	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00104	0f 85 7b 07 00
	00		 jne	 $LN18@locks_cmd

; 1299 :     {
; 1300 :         CMPFUNC* sortby = (CMPFUNC*) lsortby_nam;

  0010a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lsortby_nam
  00111	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR sortby$1[rsp], rax

; 1301 : 
; 1302 :         if (argc == 4)

  00119	83 bc 24 50 01
	00 00 04	 cmp	 DWORD PTR argc$[rsp], 4
  00121	0f 85 3a 02 00
	00		 jne	 $LN19@locks_cmd

; 1303 :         {
; 1304 :             if (!CMD( argv[2], SORT, 4 ))

  00127	b8 08 00 00 00	 mov	 eax, 8
  0012c	48 6b c0 02	 imul	 rax, rax, 2
  00130	41 b8 04 00 00
	00		 mov	 r8d, 4
  00136	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0013e	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  00142	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160008
  00149	e8 00 00 00 00	 call	 strcaseabbrev
  0014e	85 c0		 test	 eax, eax
  00150	75 10		 jne	 SHORT $LN21@locks_cmd

; 1305 :                 rc = -1;

  00152	c7 84 24 88 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR rc$[rsp], -1
  0015d	e9 fd 01 00 00	 jmp	 $LN22@locks_cmd
$LN21@locks_cmd:

; 1306 :             else
; 1307 :             {
; 1308 :                      if (CMD( argv[3], NAME,  4 )) sortby = (CMPFUNC*) lsortby_nam;

  00162	b8 08 00 00 00	 mov	 eax, 8
  00167	48 6b c0 03	 imul	 rax, rax, 3
  0016b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00171	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00179	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  0017d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160011
  00184	e8 00 00 00 00	 call	 strcaseabbrev
  00189	85 c0		 test	 eax, eax
  0018b	74 14		 je	 SHORT $LN23@locks_cmd
  0018d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lsortby_nam
  00194	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR sortby$1[rsp], rax
  0019c	e9 be 01 00 00	 jmp	 $LN24@locks_cmd
$LN23@locks_cmd:

; 1309 :                 else if (CMD( argv[3], TID,   3 )) sortby = (CMPFUNC*) lsortby_ob_tid;

  001a1	b8 08 00 00 00	 mov	 eax, 8
  001a6	48 6b c0 03	 imul	 rax, rax, 3
  001aa	41 b8 03 00 00
	00		 mov	 r8d, 3
  001b0	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001b8	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  001bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160014
  001c3	e8 00 00 00 00	 call	 strcaseabbrev
  001c8	85 c0		 test	 eax, eax
  001ca	74 14		 je	 SHORT $LN25@locks_cmd
  001cc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lsortby_ob_tid
  001d3	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR sortby$1[rsp], rax
  001db	e9 7f 01 00 00	 jmp	 $LN26@locks_cmd
$LN25@locks_cmd:

; 1310 :                 else if (CMD( argv[3], OWNER, 5 )) sortby = (CMPFUNC*) lsortby_ob_tid;

  001e0	b8 08 00 00 00	 mov	 eax, 8
  001e5	48 6b c0 03	 imul	 rax, rax, 3
  001e9	41 b8 05 00 00
	00		 mov	 r8d, 5
  001ef	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001f7	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  001fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160017
  00202	e8 00 00 00 00	 call	 strcaseabbrev
  00207	85 c0		 test	 eax, eax
  00209	74 14		 je	 SHORT $LN27@locks_cmd
  0020b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lsortby_ob_tid
  00212	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR sortby$1[rsp], rax
  0021a	e9 40 01 00 00	 jmp	 $LN28@locks_cmd
$LN27@locks_cmd:

; 1311 :                 else if (CMD( argv[3], WHEN,  4 )) sortby = (CMPFUNC*) lsortby_ob_tim;

  0021f	b8 08 00 00 00	 mov	 eax, 8
  00224	48 6b c0 03	 imul	 rax, rax, 3
  00228	41 b8 04 00 00
	00		 mov	 r8d, 4
  0022e	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00236	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  0023a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160020
  00241	e8 00 00 00 00	 call	 strcaseabbrev
  00246	85 c0		 test	 eax, eax
  00248	74 14		 je	 SHORT $LN29@locks_cmd
  0024a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lsortby_ob_tim
  00251	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR sortby$1[rsp], rax
  00259	e9 01 01 00 00	 jmp	 $LN30@locks_cmd
$LN29@locks_cmd:

; 1312 :                 else if (CMD( argv[3], TIME,  4 )) sortby = (CMPFUNC*) lsortby_ob_tim;

  0025e	b8 08 00 00 00	 mov	 eax, 8
  00263	48 6b c0 03	 imul	 rax, rax, 3
  00267	41 b8 04 00 00
	00		 mov	 r8d, 4
  0026d	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00275	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  00279	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160023
  00280	e8 00 00 00 00	 call	 strcaseabbrev
  00285	85 c0		 test	 eax, eax
  00287	74 14		 je	 SHORT $LN31@locks_cmd
  00289	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lsortby_ob_tim
  00290	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR sortby$1[rsp], rax
  00298	e9 c2 00 00 00	 jmp	 $LN32@locks_cmd
$LN31@locks_cmd:

; 1313 :                 else if (CMD( argv[3], TOD,   3 )) sortby = (CMPFUNC*) lsortby_ob_tim;

  0029d	b8 08 00 00 00	 mov	 eax, 8
  002a2	48 6b c0 03	 imul	 rax, rax, 3
  002a6	41 b8 03 00 00
	00		 mov	 r8d, 3
  002ac	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002b4	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  002b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160026
  002bf	e8 00 00 00 00	 call	 strcaseabbrev
  002c4	85 c0		 test	 eax, eax
  002c6	74 14		 je	 SHORT $LN33@locks_cmd
  002c8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lsortby_ob_tim
  002cf	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR sortby$1[rsp], rax
  002d7	e9 83 00 00 00	 jmp	 $LN34@locks_cmd
$LN33@locks_cmd:

; 1314 :                 else if (CMD( argv[3], WHERE, 5 )) sortby = (CMPFUNC*) lsortby_ob_loc;

  002dc	b8 08 00 00 00	 mov	 eax, 8
  002e1	48 6b c0 03	 imul	 rax, rax, 3
  002e5	41 b8 05 00 00
	00		 mov	 r8d, 5
  002eb	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002f3	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  002f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160029
  002fe	e8 00 00 00 00	 call	 strcaseabbrev
  00303	85 c0		 test	 eax, eax
  00305	74 11		 je	 SHORT $LN35@locks_cmd
  00307	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lsortby_ob_loc
  0030e	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR sortby$1[rsp], rax
  00316	eb 47		 jmp	 SHORT $LN36@locks_cmd
$LN35@locks_cmd:

; 1315 :                 else if (CMD( argv[3], LOC,   3 )) sortby = (CMPFUNC*) lsortby_ob_loc;

  00318	b8 08 00 00 00	 mov	 eax, 8
  0031d	48 6b c0 03	 imul	 rax, rax, 3
  00321	41 b8 03 00 00
	00		 mov	 r8d, 3
  00327	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0032f	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  00333	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160032
  0033a	e8 00 00 00 00	 call	 strcaseabbrev
  0033f	85 c0		 test	 eax, eax
  00341	74 11		 je	 SHORT $LN37@locks_cmd
  00343	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lsortby_ob_loc
  0034a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR sortby$1[rsp], rax
  00352	eb 0b		 jmp	 SHORT $LN38@locks_cmd
$LN37@locks_cmd:

; 1316 :                 else
; 1317 :                     rc = -1;

  00354	c7 84 24 88 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR rc$[rsp], -1
$LN38@locks_cmd:
$LN36@locks_cmd:
$LN34@locks_cmd:
$LN32@locks_cmd:
$LN30@locks_cmd:
$LN28@locks_cmd:
$LN26@locks_cmd:
$LN24@locks_cmd:
$LN22@locks_cmd:

; 1318 :             }
; 1319 :         }

  0035f	eb 1f		 jmp	 SHORT $LN20@locks_cmd
$LN19@locks_cmd:

; 1320 :         else if (argc != 1 && argc != 2)

  00361	83 bc 24 50 01
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  00369	74 15		 je	 SHORT $LN39@locks_cmd
  0036b	83 bc 24 50 01
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00373	74 0b		 je	 SHORT $LN39@locks_cmd

; 1321 :             rc = -1;

  00375	c7 84 24 88 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR rc$[rsp], -1
$LN39@locks_cmd:
$LN20@locks_cmd:

; 1322 : 
; 1323 :         /* If no errors, perform the requested function */
; 1324 :         if (!rc)

  00380	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00388	0f 85 f7 04 00
	00		 jne	 $LN40@locks_cmd

; 1325 :         {
; 1326 :             /* Retrieve a copy of the locks list */
; 1327 :             k = hthreads_copy_locks_list( &ilk, &anchor );

  0038e	48 8d 94 24 f0
	00 00 00	 lea	 rdx, QWORD PTR anchor$[rsp]
  00396	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR ilk$[rsp]
  0039e	e8 00 00 00 00	 call	 hthreads_copy_locks_list
  003a3	89 84 24 8c 00
	00 00		 mov	 DWORD PTR k$[rsp], eax

; 1328 : 
; 1329 :             /* Sort them into the requested sequence */
; 1330 :             if (k)

  003aa	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR k$[rsp], 0
  003b2	0f 84 17 04 00
	00		 je	 $LN41@locks_cmd

; 1331 :             {
; 1332 :                 char tod[32];           // "YYYY-MM-DD HH:MM:SS.uuuuuu"
; 1333 :                 char threadname[16];
; 1334 : 
; 1335 :                 qsort( ilk, k, sizeof( ILOCK ), sortby );

  003b8	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR k$[rsp]
  003c0	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR sortby$1[rsp]
  003c8	41 b8 60 00 00
	00		 mov	 r8d, 96			; 00000060H
  003ce	48 8b d0	 mov	 rdx, rax
  003d1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ilk$[rsp]
  003d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_qsort

; 1336 : 
; 1337 :                 /* Display the requested locks */
; 1338 :                 for (c = 0 /* (zero locks found) */, i=0; i < k; i++ )

  003df	c6 44 24 74 00	 mov	 BYTE PTR c$[rsp], 0
  003e4	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  003ec	eb 0a		 jmp	 SHORT $LN7@locks_cmd
$LN5@locks_cmd:
  003ee	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  003f2	ff c0		 inc	 eax
  003f4	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
$LN7@locks_cmd:
  003f8	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  003ff	39 44 24 70	 cmp	 DWORD PTR i$[rsp], eax
  00403	0f 8d 77 03 00
	00		 jge	 $LN6@locks_cmd

; 1339 :                 {
; 1340 :                     /* ALL, HELD or specific TID? */
; 1341 :                     if (0
; 1342 :                         || !tid
; 1343 :                         || (equal_threads( tid, (TID) -1 ) && !equal_threads( ilk[i].il_ob_tid, 0 ))
; 1344 :                         || equal_threads( tid, ilk[i].il_ob_tid )

  00409	33 c0		 xor	 eax, eax
  0040b	85 c0		 test	 eax, eax
  0040d	75 5f		 jne	 SHORT $LN44@locks_cmd
  0040f	83 7c 24 78 00	 cmp	 DWORD PTR tid$[rsp], 0
  00414	74 58		 je	 SHORT $LN44@locks_cmd
  00416	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  0041b	8b 4c 24 78	 mov	 ecx, DWORD PTR tid$[rsp]
  0041f	e8 00 00 00 00	 call	 hthread_equal_threads
  00424	85 c0		 test	 eax, eax
  00426	74 20		 je	 SHORT $LN45@locks_cmd
  00428	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0042d	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00431	33 d2		 xor	 edx, edx
  00433	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ilk$[rsp]
  0043b	8b 4c 01 30	 mov	 ecx, DWORD PTR [rcx+rax+48]
  0043f	e8 00 00 00 00	 call	 hthread_equal_threads
  00444	85 c0		 test	 eax, eax
  00446	74 26		 je	 SHORT $LN44@locks_cmd
$LN45@locks_cmd:
  00448	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0044d	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00451	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ilk$[rsp]
  00459	8b 54 01 30	 mov	 edx, DWORD PTR [rcx+rax+48]
  0045d	8b 4c 24 78	 mov	 ecx, DWORD PTR tid$[rsp]
  00461	e8 00 00 00 00	 call	 hthread_equal_threads
  00466	85 c0		 test	 eax, eax
  00468	0f 84 0d 03 00
	00		 je	 $LN43@locks_cmd
$LN44@locks_cmd:

; 1345 :                     )
; 1346 :                     {
; 1347 :                         c = 1;  /* (at least one lock found) */

  0046e	c6 44 24 74 01	 mov	 BYTE PTR c$[rsp], 1

; 1348 : 
; 1349 :                         get_thread_name( ilk[i].il_cr_tid, threadname );

  00473	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00478	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0047c	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR threadname$2[rsp]
  00484	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ilk$[rsp]
  0048c	8b 4c 01 58	 mov	 ecx, DWORD PTR [rcx+rax+88]
  00490	e8 00 00 00 00	 call	 hthread_get_thread_name

; 1350 :                         FormatTIMEVAL(  &ilk[i].il_cr_time, tod, sizeof( tod ));

  00495	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0049a	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0049e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ilk$[rsp]
  004a6	48 8d 44 01 50	 lea	 rax, QWORD PTR [rcx+rax+80]
  004ab	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  004b1	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR tod$3[rsp]
  004b9	48 8b c8	 mov	 rcx, rax
  004bc	e8 00 00 00 00	 call	 FormatTIMEVAL

; 1351 : 
; 1352 :                         // "Lock "PTR_FMTx" (%s) created by "TIDPAT" (%s) on %s at %s"
; 1353 :                         WRMSG( HHC90017, "I"

  004c1	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  004c6	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  004ca	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ilk$[rsp]
  004d2	48 8b 4c 01 48	 mov	 rcx, QWORD PTR [rcx+rax+72]
  004d7	e8 00 00 00 00	 call	 trimloc
  004dc	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv221[rsp], rax
  004e4	b9 01 00 00 00	 mov	 ecx, 1
  004e9	48 6b c9 0b	 imul	 rcx, rcx, 11
  004ed	48 8d 8c 0c 10
	01 00 00	 lea	 rcx, QWORD PTR tod$3[rsp+rcx]
  004f5	48 89 8c 24 a0
	00 00 00	 mov	 QWORD PTR tv242[rsp], rcx
  004fd	48 63 54 24 70	 movsxd	 rdx, DWORD PTR i$[rsp]
  00502	48 6b d2 60	 imul	 rdx, rdx, 96		; 00000060H
  00506	48 89 94 24 a8
	00 00 00	 mov	 QWORD PTR tv246[rsp], rdx
  0050e	4c 63 44 24 70	 movsxd	 r8, DWORD PTR i$[rsp]
  00513	4d 6b c0 60	 imul	 r8, r8, 96		; 00000060H
  00517	4c 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv251[rsp], r8
  0051f	4c 63 4c 24 70	 movsxd	 r9, DWORD PTR i$[rsp]
  00524	4d 6b c9 60	 imul	 r9, r9, 96		; 00000060H
  00528	4c 89 8c 24 b8
	00 00 00	 mov	 QWORD PTR tv256[rsp], r9
  00530	b9 01 00 00 00	 mov	 ecx, 1
  00535	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0053b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv221[rsp]
  00543	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00548	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv242[rsp]
  00550	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00555	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR threadname$2[rsp]
  0055d	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00562	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ilk$[rsp]
  0056a	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR tv246[rsp]
  00572	8b 4c 11 58	 mov	 ecx, DWORD PTR [rcx+rdx+88]
  00576	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0057a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ilk$[rsp]
  00582	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR tv251[rsp]
  0058a	48 8b 4c 11 18	 mov	 rcx, QWORD PTR [rcx+rdx+24]
  0058f	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00594	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ilk$[rsp]
  0059c	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR tv256[rsp]
  005a4	48 8b 4c 11 10	 mov	 rcx, QWORD PTR [rcx+rdx+16]
  005a9	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  005ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160040
  005b5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160041
  005c1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005c6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005cb	41 b9 03 00 00
	00		 mov	 r9d, 3
  005d1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160042
  005d8	ba 52 05 00 00	 mov	 edx, 1362		; 00000552H
  005dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160043
  005e4	e8 00 00 00 00	 call	 fwritemsg

; 1354 : 
; 1355 :                             , PTR_CAST( ilk[i].il_addr )
; 1356 :                             , ilk[i].il_name
; 1357 : 
; 1358 :                             , TID_CAST( ilk[i].il_cr_tid )
; 1359 :                             , threadname
; 1360 :                             , &tod[11]
; 1361 :                             , TRIMLOC( ilk[i].il_cr_locat )
; 1362 :                         );
; 1363 : 
; 1364 :                         if (ilk[i].il_ob_tid)

  005e9	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  005ee	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  005f2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ilk$[rsp]
  005fa	83 7c 01 30 00	 cmp	 DWORD PTR [rcx+rax+48], 0
  005ff	0f 84 76 01 00
	00		 je	 $LN46@locks_cmd

; 1365 :                         {
; 1366 :                             get_thread_name( ilk[i].il_ob_tid, threadname );

  00605	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0060a	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0060e	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR threadname$2[rsp]
  00616	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ilk$[rsp]
  0061e	8b 4c 01 30	 mov	 ecx, DWORD PTR [rcx+rax+48]
  00622	e8 00 00 00 00	 call	 hthread_get_thread_name

; 1367 :                             FormatTIMEVAL(  &ilk[i].il_ob_time, tod, sizeof( tod ));

  00627	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0062c	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00630	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ilk$[rsp]
  00638	48 8d 44 01 28	 lea	 rax, QWORD PTR [rcx+rax+40]
  0063d	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  00643	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR tod$3[rsp]
  0064b	48 8b c8	 mov	 rcx, rax
  0064e	e8 00 00 00 00	 call	 FormatTIMEVAL

; 1368 : 
; 1369 :                             // "Lock "PTR_FMTx" (%s) obtained by "TIDPAT" (%s) on %s at %s"
; 1370 :                             WRMSG( HHC90029, "I"

  00653	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00658	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0065c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ilk$[rsp]
  00664	48 8b 4c 01 20	 mov	 rcx, QWORD PTR [rcx+rax+32]
  00669	e8 00 00 00 00	 call	 trimloc
  0066e	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv274[rsp], rax
  00676	b9 01 00 00 00	 mov	 ecx, 1
  0067b	48 6b c9 0b	 imul	 rcx, rcx, 11
  0067f	48 8d 8c 0c 10
	01 00 00	 lea	 rcx, QWORD PTR tod$3[rsp+rcx]
  00687	48 89 8c 24 c8
	00 00 00	 mov	 QWORD PTR tv295[rsp], rcx
  0068f	48 63 54 24 70	 movsxd	 rdx, DWORD PTR i$[rsp]
  00694	48 6b d2 60	 imul	 rdx, rdx, 96		; 00000060H
  00698	48 89 94 24 d0
	00 00 00	 mov	 QWORD PTR tv299[rsp], rdx
  006a0	4c 63 44 24 70	 movsxd	 r8, DWORD PTR i$[rsp]
  006a5	4d 6b c0 60	 imul	 r8, r8, 96		; 00000060H
  006a9	4c 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv304[rsp], r8
  006b1	4c 63 4c 24 70	 movsxd	 r9, DWORD PTR i$[rsp]
  006b6	4d 6b c9 60	 imul	 r9, r9, 96		; 00000060H
  006ba	4c 89 8c 24 e0
	00 00 00	 mov	 QWORD PTR tv309[rsp], r9
  006c2	b9 01 00 00 00	 mov	 ecx, 1
  006c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006cd	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv274[rsp]
  006d5	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  006da	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv295[rsp]
  006e2	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  006e7	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR threadname$2[rsp]
  006ef	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  006f4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ilk$[rsp]
  006fc	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR tv299[rsp]
  00704	8b 4c 11 30	 mov	 ecx, DWORD PTR [rcx+rdx+48]
  00708	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0070c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ilk$[rsp]
  00714	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR tv304[rsp]
  0071c	48 8b 4c 11 18	 mov	 rcx, QWORD PTR [rcx+rdx+24]
  00721	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00726	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ilk$[rsp]
  0072e	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR tv309[rsp]
  00736	48 8b 4c 11 10	 mov	 rcx, QWORD PTR [rcx+rdx+16]
  0073b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00740	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160045
  00747	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0074c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160046
  00753	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00758	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0075d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00763	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160047
  0076a	ba 63 05 00 00	 mov	 edx, 1379		; 00000563H
  0076f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160048
  00776	e8 00 00 00 00	 call	 fwritemsg
$LN46@locks_cmd:
$LN43@locks_cmd:

; 1371 : 
; 1372 :                                 , PTR_CAST( ilk[i].il_addr )
; 1373 :                                 , ilk[i].il_name
; 1374 : 
; 1375 :                                 , TID_CAST( ilk[i].il_ob_tid )
; 1376 :                                 , threadname
; 1377 :                                 , &tod[11]
; 1378 :                                 , TRIMLOC( ilk[i].il_ob_locat )
; 1379 :                             );
; 1380 :                         }
; 1381 :                     }
; 1382 :                 }

  0077b	e9 6e fc ff ff	 jmp	 $LN5@locks_cmd
$LN6@locks_cmd:

; 1383 : 
; 1384 :                 /* Free our copy of the locks list */
; 1385 :                 for (i=0; i < k; i++)

  00780	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00788	eb 0a		 jmp	 SHORT $LN10@locks_cmd
$LN8@locks_cmd:
  0078a	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  0078e	ff c0		 inc	 eax
  00790	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
$LN10@locks_cmd:
  00794	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  0079b	39 44 24 70	 cmp	 DWORD PTR i$[rsp], eax
  0079f	7d 1e		 jge	 SHORT $LN9@locks_cmd

; 1386 :                     free( ilk[i].il_name );

  007a1	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  007a6	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  007aa	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ilk$[rsp]
  007b2	48 8b 4c 01 18	 mov	 rcx, QWORD PTR [rcx+rax+24]
  007b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  007bd	eb cb		 jmp	 SHORT $LN8@locks_cmd
$LN9@locks_cmd:

; 1387 :                 free( ilk );

  007bf	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ilk$[rsp]
  007c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1388 :             }

  007cd	eb 05		 jmp	 SHORT $LN42@locks_cmd
$LN41@locks_cmd:

; 1389 :             else
; 1390 :                 c = 1;

  007cf	c6 44 24 74 01	 mov	 BYTE PTR c$[rsp], 1
$LN42@locks_cmd:

; 1391 : 
; 1392 :             /* Print results */
; 1393 :             if (!c)

  007d4	0f be 44 24 74	 movsx	 eax, BYTE PTR c$[rsp]
  007d9	85 c0		 test	 eax, eax
  007db	75 50		 jne	 SHORT $LN47@locks_cmd

; 1394 :             {
; 1395 :                 // "No locks found for thread "TIDPAT"."
; 1396 :                 WRMSG( HHC90019, "W", TID_CAST( tid ));

  007dd	b9 01 00 00 00	 mov	 ecx, 1
  007e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007e8	8b 4c 24 78	 mov	 ecx, DWORD PTR tid$[rsp]
  007ec	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  007f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160051
  007f7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160052
  00803	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00808	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0080d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00813	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160053
  0081a	ba 74 05 00 00	 mov	 edx, 1396		; 00000574H
  0081f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160054
  00826	e8 00 00 00 00	 call	 fwritemsg

; 1397 :             }

  0082b	eb 58		 jmp	 SHORT $LN48@locks_cmd
$LN47@locks_cmd:

; 1398 :             else if (!tid)

  0082d	83 7c 24 78 00	 cmp	 DWORD PTR tid$[rsp], 0
  00832	75 51		 jne	 SHORT $LN49@locks_cmd

; 1399 :             {
; 1400 :                 // "Total locks defined: %d"
; 1401 :                 WRMSG( HHC90018, "I", k );

  00834	b9 01 00 00 00	 mov	 ecx, 1
  00839	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0083f	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR k$[rsp]
  00846	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0084a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160056
  00851	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00856	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160057
  0085d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00862	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00867	41 b9 03 00 00
	00		 mov	 r9d, 3
  0086d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160058
  00874	ba 79 05 00 00	 mov	 edx, 1401		; 00000579H
  00879	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160059
  00880	e8 00 00 00 00	 call	 fwritemsg
$LN49@locks_cmd:
$LN48@locks_cmd:
$LN40@locks_cmd:
$LN18@locks_cmd:

; 1402 :             }
; 1403 :         }
; 1404 :     }
; 1405 : 
; 1406 :     if (rc)

  00885	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  0088d	74 70		 je	 SHORT $LN50@locks_cmd

; 1407 :     {
; 1408 :         // "Invalid argument(s). Type 'help %s' for assistance."
; 1409 :         WRMSG( HHC02211, "E", argv[0] );

  0088f	b8 08 00 00 00	 mov	 eax, 8
  00894	48 6b c0 00	 imul	 rax, rax, 0
  00898	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv354[rsp], rax
  008a0	b9 01 00 00 00	 mov	 ecx, 1
  008a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  008ab	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  008b3	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR tv354[rsp]
  008bb	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  008bf	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  008c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160061
  008cb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160062
  008d7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008dc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008e1	41 b9 03 00 00
	00		 mov	 r9d, 3
  008e7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160063
  008ee	ba 81 05 00 00	 mov	 edx, 1409		; 00000581H
  008f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160064
  008fa	e8 00 00 00 00	 call	 fwritemsg
$LN50@locks_cmd:

; 1410 :     }
; 1411 : 
; 1412 :     return rc;

  008ff	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR rc$[rsp]

; 1413 : }

  00906	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0090e	48 33 cc	 xor	 rcx, rsp
  00911	e8 00 00 00 00	 call	 __security_check_cookie
  00916	48 81 c4 48 01
	00 00		 add	 rsp, 328		; 00000148H
  0091d	c3		 ret	 0
locks_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hthreads.c
_TEXT	SEGMENT
rc$1 = 32
attr$2 = 36
minprio$3 = 40
maxprio$4 = 44
ht$5 = 48
_EX_Head$6 = 56
_EX_Next$7 = 64
ht_cr_locat$8 = 72
hthreads_internal_init PROC

; 145  : {

$LN11:
  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 146  :     if (!inited)

  00004	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR inited
  0000b	85 c0		 test	 eax, eax
  0000d	0f 85 65 02 00
	00		 jne	 $LN2@hthreads_i

; 147  :     {
; 148  :         MATTR attr;
; 149  :         int rc, minprio, maxprio;
; 150  : 
; 151  : #if defined( OPTION_FTHREADS )
; 152  :         fthreads_internal_init();

  00013	e8 00 00 00 00	 call	 fthreads_internal_init

; 153  : #endif
; 154  :         /* Initialize our internal locks */
; 155  : 
; 156  :         rc = hthread_mutexattr_init( &attr );

  00018	48 8d 4c 24 24	 lea	 rcx, QWORD PTR attr$2[rsp]
  0001d	e8 00 00 00 00	 call	 fthread_mutexattr_init
  00022	89 44 24 20	 mov	 DWORD PTR rc$1[rsp], eax

; 157  :         if (rc)

  00026	83 7c 24 20 00	 cmp	 DWORD PTR rc$1[rsp], 0
  0002b	74 05		 je	 SHORT $LN3@hthreads_i

; 158  :             goto fatal;

  0002d	e9 2e 02 00 00	 jmp	 $fatal$12
$LN3@hthreads_i:

; 159  : 
; 160  :         rc = hthread_mutexattr_settype( &attr, HTHREAD_MUTEX_DEFAULT );

  00032	ba 65 63 6e 4f	 mov	 edx, 1332634469		; 4f6e6365H
  00037	48 8d 4c 24 24	 lea	 rcx, QWORD PTR attr$2[rsp]
  0003c	e8 00 00 00 00	 call	 fthread_mutexattr_settype
  00041	89 44 24 20	 mov	 DWORD PTR rc$1[rsp], eax

; 161  :         if (rc)

  00045	83 7c 24 20 00	 cmp	 DWORD PTR rc$1[rsp], 0
  0004a	74 05		 je	 SHORT $LN4@hthreads_i

; 162  :             goto fatal;

  0004c	e9 0f 02 00 00	 jmp	 $fatal$12
$LN4@hthreads_i:

; 163  : 
; 164  :         rc = hthread_mutex_init( &listlock, &attr );

  00051	48 8d 54 24 24	 lea	 rdx, QWORD PTR attr$2[rsp]
  00056	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:listlock
  0005d	e8 00 00 00 00	 call	 fthread_mutex_init
  00062	89 44 24 20	 mov	 DWORD PTR rc$1[rsp], eax

; 165  :         if (rc)

  00066	83 7c 24 20 00	 cmp	 DWORD PTR rc$1[rsp], 0
  0006b	74 05		 je	 SHORT $LN5@hthreads_i

; 166  :             goto fatal;

  0006d	e9 ee 01 00 00	 jmp	 $fatal$12
$LN5@hthreads_i:

; 167  : 
; 168  :         rc = hthread_mutex_init( &threadlock, &attr );

  00072	48 8d 54 24 24	 lea	 rdx, QWORD PTR attr$2[rsp]
  00077	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:threadlock
  0007e	e8 00 00 00 00	 call	 fthread_mutex_init
  00083	89 44 24 20	 mov	 DWORD PTR rc$1[rsp], eax

; 169  :         if (rc)

  00087	83 7c 24 20 00	 cmp	 DWORD PTR rc$1[rsp], 0
  0008c	74 05		 je	 SHORT $LN6@hthreads_i

; 170  :             goto fatal;

  0008e	e9 cd 01 00 00	 jmp	 $fatal$12
$LN6@hthreads_i:

; 171  : 
; 172  :         rc = hthread_mutexattr_destroy( &attr );

  00093	48 8d 4c 24 24	 lea	 rcx, QWORD PTR attr$2[rsp]
  00098	e8 00 00 00 00	 call	 fthread_mutexattr_destroy
  0009d	89 44 24 20	 mov	 DWORD PTR rc$1[rsp], eax

; 173  :         if (rc)

  000a1	83 7c 24 20 00	 cmp	 DWORD PTR rc$1[rsp], 0
  000a6	74 05		 je	 SHORT $LN7@hthreads_i

; 174  :             goto fatal;

  000a8	e9 b3 01 00 00	 jmp	 $fatal$12
$LN7@hthreads_i:

; 175  : 
; 176  :         /* Initialize our list anchors */
; 177  : 
; 178  :         InitializeListHead( &locklist );

  000ad	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:locklist
  000b4	48 89 05 08 00
	00 00		 mov	 QWORD PTR locklist+8, rax
  000bb	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR locklist+8
  000c2	48 89 05 00 00
	00 00		 mov	 QWORD PTR locklist, rax

; 179  :         lockcount = 0;

  000c9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR lockcount, 0

; 180  : 
; 181  :         InitializeListHead( &threadlist );

  000d3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:threadlist
  000da	48 89 05 08 00
	00 00		 mov	 QWORD PTR threadlist+8, rax
  000e1	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR threadlist+8
  000e8	48 89 05 00 00
	00 00		 mov	 QWORD PTR threadlist, rax

; 182  :         threadcount = 0;

  000ef	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR threadcount, 0

; 183  : 
; 184  :         /* Retrieve the minimum/maximum scheduling priority */
; 185  : 
; 186  :         minprio = hthread_get_priority_min( HTHREAD_POLICY );

  000f9	b9 01 00 00 00	 mov	 ecx, 1
  000fe	e8 00 00 00 00	 call	 fthread_get_priority_min
  00103	89 44 24 28	 mov	 DWORD PTR minprio$3[rsp], eax

; 187  :         maxprio = hthread_get_priority_max( HTHREAD_POLICY );

  00107	b9 01 00 00 00	 mov	 ecx, 1
  0010c	e8 00 00 00 00	 call	 fthread_get_priority_max
  00111	89 44 24 2c	 mov	 DWORD PTR maxprio$4[rsp], eax

; 188  : 
; 189  :         if (minprio >= 0 && maxprio >= 0 && maxprio >= minprio)

  00115	83 7c 24 28 00	 cmp	 DWORD PTR minprio$3[rsp], 0
  0011a	7c 4b		 jl	 SHORT $LN8@hthreads_i
  0011c	83 7c 24 2c 00	 cmp	 DWORD PTR maxprio$4[rsp], 0
  00121	7c 44		 jl	 SHORT $LN8@hthreads_i
  00123	8b 44 24 28	 mov	 eax, DWORD PTR minprio$3[rsp]
  00127	39 44 24 2c	 cmp	 DWORD PTR maxprio$4[rsp], eax
  0012b	7c 3a		 jl	 SHORT $LN8@hthreads_i

; 190  :         {
; 191  :             /* "The Open Group Base Specifications Issue 7"
; 192  :                "Scheduling Policies", "SCHED_RR": "[...] Conforming
; 193  :                implementations shall provide a priority range of at
; 194  :                least 32 priorities for this policy."
; 195  :             */
; 196  :             if (((maxprio - minprio) + 1) < 32)

  0012d	8b 44 24 28	 mov	 eax, DWORD PTR minprio$3[rsp]
  00131	8b 4c 24 2c	 mov	 ecx, DWORD PTR maxprio$4[rsp]
  00135	2b c8		 sub	 ecx, eax
  00137	8b c1		 mov	 eax, ecx
  00139	ff c0		 inc	 eax
  0013b	83 f8 20	 cmp	 eax, 32			; 00000020H
  0013e	7d 05		 jge	 SHORT $LN9@hthreads_i

; 197  :                 goto fatal;

  00140	e9 1b 01 00 00	 jmp	 $fatal$12
$LN9@hthreads_i:

; 198  : 
; 199  :             sysblk.minprio = minprio;

  00145	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0014c	8b 4c 24 28	 mov	 ecx, DWORD PTR minprio$3[rsp]
  00150	89 88 5c 13 00
	00		 mov	 DWORD PTR [rax+4956], ecx

; 200  :             sysblk.maxprio = maxprio;

  00156	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0015d	8b 4c 24 2c	 mov	 ecx, DWORD PTR maxprio$4[rsp]
  00161	89 88 60 13 00
	00		 mov	 DWORD PTR [rax+4960], ecx
$LN8@hthreads_i:

; 201  :         }
; 202  : 
; 203  :         /* Add an entry for the current thread to our threads list
; 204  :            since it was created by the operating system and not us */
; 205  :         {
; 206  :             const char* ht_cr_locat = PTT_LOC; // (where created)

  00167	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159157
  0016e	48 89 44 24 48	 mov	 QWORD PTR ht_cr_locat$8[rsp], rax

; 207  :             HTHREAD* ht = calloc_aligned( sizeof( HTHREAD ), 64 );

  00173	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00178	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  0017d	e8 00 00 00 00	 call	 calloc_aligned
  00182	48 89 44 24 30	 mov	 QWORD PTR ht$5[rsp], rax

; 208  : 
; 209  :             InitializeListLink( &ht->ht_link );

  00187	48 8b 44 24 30	 mov	 rax, QWORD PTR ht$5[rsp]
  0018c	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  00194	48 8b 44 24 30	 mov	 rax, QWORD PTR ht$5[rsp]
  00199	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 210  :             gettimeofday( &ht->ht_cr_time, NULL );

  001a0	48 8b 44 24 30	 mov	 rax, QWORD PTR ht$5[rsp]
  001a5	48 83 c0 18	 add	 rax, 24
  001a9	33 d2		 xor	 edx, edx
  001ab	48 8b c8	 mov	 rcx, rax
  001ae	e8 00 00 00 00	 call	 gettimeofday

; 211  : 
; 212  :             ht->ht_tid        =  hthread_self();

  001b3	e8 00 00 00 00	 call	 fthread_self
  001b8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ht$5[rsp]
  001bd	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 213  :             ht->ht_name       =  strdup( "main" );

  001c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159158
  001c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  001cd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ht$5[rsp]
  001d2	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax

; 214  :             ht->ht_cr_locat   =  ht_cr_locat;

  001d6	48 8b 44 24 30	 mov	 rax, QWORD PTR ht$5[rsp]
  001db	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ht_cr_locat$8[rsp]
  001e0	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 215  :             ht->ht_ob_lock    =  NULL;

  001e4	48 8b 44 24 30	 mov	 rax, QWORD PTR ht$5[rsp]
  001e9	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 216  :             ht->ht_footprint  =  false;

  001f1	48 8b 44 24 30	 mov	 rax, QWORD PTR ht$5[rsp]
  001f6	c6 40 48 00	 mov	 BYTE PTR [rax+72], 0

; 217  : 
; 218  :             InsertListHead( &threadlist, &ht->ht_link );

  001fa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:threadlist
  00201	48 89 44 24 38	 mov	 QWORD PTR _EX_Head$6[rsp], rax
  00206	48 8b 44 24 38	 mov	 rax, QWORD PTR _EX_Head$6[rsp]
  0020b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0020e	48 89 44 24 40	 mov	 QWORD PTR _EX_Next$7[rsp], rax
  00213	48 8b 44 24 30	 mov	 rax, QWORD PTR ht$5[rsp]
  00218	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _EX_Next$7[rsp]
  0021d	48 89 08	 mov	 QWORD PTR [rax], rcx
  00220	48 8b 44 24 30	 mov	 rax, QWORD PTR ht$5[rsp]
  00225	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _EX_Head$6[rsp]
  0022a	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  0022e	48 8b 44 24 30	 mov	 rax, QWORD PTR ht$5[rsp]
  00233	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _EX_Head$6[rsp]
  00238	48 89 01	 mov	 QWORD PTR [rcx], rax
  0023b	48 8b 44 24 30	 mov	 rax, QWORD PTR ht$5[rsp]
  00240	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _EX_Next$7[rsp]
  00245	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 219  :             threadcount++;

  00249	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR threadcount
  0024f	ff c0		 inc	 eax
  00251	89 05 00 00 00
	00		 mov	 DWORD PTR threadcount, eax

; 220  :         }
; 221  : 
; 222  :         /* One-time initialization completed */
; 223  : 
; 224  :         inited = true;

  00257	c6 05 00 00 00
	00 01		 mov	 BYTE PTR inited, 1

; 225  :         return;

  0025e	eb 18		 jmp	 SHORT $LN1@hthreads_i
$fatal$12:

; 226  : 
; 227  : fatal:
; 228  :         perror( "Fatal error in hthreads_internal_init function" );

  00260	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159159
  00267	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_perror

; 229  :         exit(1);

  0026d	b9 01 00 00 00	 mov	 ecx, 1
  00272	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN2@hthreads_i:
$LN1@hthreads_i:
$LN10@hthreads_i:

; 230  :     }
; 231  : }

  00278	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0027c	c3		 ret	 0
hthreads_internal_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
END
