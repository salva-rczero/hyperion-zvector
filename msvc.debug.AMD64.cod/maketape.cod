; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	awshdr
PUBLIC	pInFileID
PUBLIC	pVolSer
PUBLIC	datasetName
PUBLIC	outFileID
PUBLIC	pLRECL
PUBLIC	pBLOCK
PUBLIC	pCODEPAGE
PUBLIC	mode
PUBLIC	lrecl
PUBLIC	blkfactor
PUBLIC	outGLOBBING
PUBLIC	binary
PUBLIC	nltape
PUBLIC	ansi
_BSS	SEGMENT
awshdr	DB	06H DUP (?)
	ALIGN	8

pInFileID DQ	01H DUP (?)
pVolSer	DQ	01H DUP (?)
datasetName DQ	01H DUP (?)
outFileID DQ	01H DUP (?)
pLRECL	DQ	01H DUP (?)
pBLOCK	DQ	01H DUP (?)
pCODEPAGE DQ	01H DUP (?)
outGLOBBING DD	01H DUP (?)
binary	DB	01H DUP (?)
	ALIGN	4

nltape	DB	01H DUP (?)
	ALIGN	4

ansi	DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	inFileSeq:DWORD
COMM	blkSize:DWORD
COMM	blkCount:DWORD
COMM	inMeta:QWORD
COMM	inData:QWORD
COMM	outf:QWORD
COMM	julianToday:BYTE:06H
COMM	volSer:BYTE:06H
COMM	inFileID:BYTE:032faH
COMM	buf:BYTE:0ffffH
_DATA	ENDS
_DATA	SEGMENT
mode	DQ	FLAT:$SG169211
$SG169211 DB	'r', 00H
	ORG $+2
lrecl	DD	050H
blkfactor DD	01H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	main
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp_toupper:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp__strnicmp:PROC
EXTRN	__imp_strncpy:PROC
EXTRN	__imp_strtok:PROC
EXTRN	__imp_exit:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fgets:PROC
EXTRN	__imp_fopen:PROC
EXTRN	__imp_fread:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp__localtime64:PROC
EXTRN	__imp__time64:PROC
EXTRN	__imp_tzset:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_initialize_utility:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_w32_fwrite:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_fclose:PROC
EXTRN	__imp_valid_codepage_name:PROC
EXTRN	__imp_set_codepage:PROC
EXTRN	__imp_buf_host_to_guest:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	4

$SG169481 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$localtime DD imagerel localtime
	DD	imagerel localtime+25
	DD	imagerel $unwind$localtime
$pdata$time DD	imagerel time
	DD	imagerel time+25
	DD	imagerel $unwind$time
$pdata$ErrExit DD imagerel ErrExit
	DD	imagerel ErrExit+23
	DD	imagerel $unwind$ErrExit
$pdata$julianDate DD imagerel julianDate
	DD	imagerel julianDate+142
	DD	imagerel $unwind$julianDate
$pdata$valid_alpha DD imagerel valid_alpha
	DD	imagerel valid_alpha+85
	DD	imagerel $unwind$valid_alpha
$pdata$valid_numeric DD imagerel valid_numeric
	DD	imagerel valid_numeric+85
	DD	imagerel $unwind$valid_numeric
$pdata$valid_alphanumeric DD imagerel valid_alphanumeric
	DD	imagerel valid_alphanumeric+101
	DD	imagerel $unwind$valid_alphanumeric
$pdata$valid_national DD imagerel valid_national
	DD	imagerel valid_national+94
	DD	imagerel $unwind$valid_national
$pdata$valid_volser DD imagerel valid_volser
	DD	imagerel valid_volser+142
	DD	imagerel $unwind$valid_volser
$pdata$valid_dsn_first DD imagerel valid_dsn_first
	DD	imagerel valid_dsn_first+101
	DD	imagerel $unwind$valid_dsn_first
$pdata$valid_dsn_remaining DD imagerel valid_dsn_remaining
	DD	imagerel valid_dsn_remaining+111
	DD	imagerel $unwind$valid_dsn_remaining
$pdata$valid_dsn_segment DD imagerel valid_dsn_segment
	DD	imagerel valid_dsn_segment+146
	DD	imagerel $unwind$valid_dsn_segment
$pdata$valid_dataset DD imagerel valid_dataset
	DD	imagerel valid_dataset+172
	DD	imagerel $unwind$valid_dataset
$pdata$parseCommand DD imagerel parseCommand
	DD	imagerel parseCommand+6808
	DD	imagerel $unwind$parseCommand
$pdata$writeBuffer DD imagerel writeBuffer
	DD	imagerel writeBuffer+558
	DD	imagerel $unwind$writeBuffer
$pdata$writeLabel DD imagerel writeLabel
	DD	imagerel writeLabel+1338
	DD	imagerel $unwind$writeLabel
$pdata$writeTapeMark DD imagerel writeTapeMark
	DD	imagerel writeTapeMark+318
	DD	imagerel $unwind$writeTapeMark
$pdata$main DD	imagerel $LN40
	DD	imagerel $LN40+1831
	DD	imagerel $unwind$main
pdata	ENDS
_DATA	SEGMENT
$SG169238 DB	'%3.3i', 00H
	ORG $+2
$SG169239 DB	'%3.3i', 00H
	ORG $+2
$SG169303 DB	'.', 00H
	ORG $+2
$SG169305 DB	'.', 00H
	ORG $+2
$SG169350 DB	'I', 00H
	ORG $+2
$SG169351 DB	'HHC02770%s Usage:  ARG: value  [ARG: value]  [OPTION] ..'
	DB	'.', 0aH, 'HHC02770I', 0aH, 'HHC02770I      INPUT:    <input f'
	DB	'ile name>  |  @<file containing file list>', 0aH, 'HHC02770I '
	DB	'     VOLSER:   <1 to 6 character volume serial number>', 0aH, 'H'
	DB	'HC02770I      DATASET:  <1 to 17 character dataset label>', 0aH
	DB	'HHC02770I      OUTPUT:   <output file name>', 0aH, 'HHC02770I'
	DB	0aH, 'HHC02770I    [ LRECL:    <record length>    ]', 0aH, 'HH'
	DB	'C02770I    [ BLOCK:    <blocking factor>  ]', 0aH, 'HHC02770I'
	DB	'    [ CODEPAGE: <code page>        ]', 0aH, 'HHC02770I', 0aH, 'H'
	DB	'HC02770I    [ UNIQUE ]', 0aH, 'HHC02770I    [ BINARY ]', 0aH, 'H'
	DB	'HC02770I    [ NLTAPE ]', 0aH, 'HHC02770I    [ ANSI   ]', 0aH, 0aH
	DB	00H
$SG169352 DB	'parseCommand', 00H
	ORG $+3
$SG169353 DB	'maketape.c', 00H
	ORG $+1
$SG169356 DB	'input', 00H
	ORG $+2
$SG169357 DB	'input:', 00H
	ORG $+1
$SG169358 DB	'in', 00H
	ORG $+1
$SG169359 DB	'in:', 00H
$SG169360 DB	'i', 00H
	ORG $+2
$SG169361 DB	'i:', 00H
	ORG $+1
$SG169365 DB	'E', 00H
	ORG $+2
$SG169364 DB	'<input file name>', 00H
	ORG $+2
$SG169371 DB	'output', 00H
	ORG $+1
$SG169373 DB	'out', 00H
$SG169366 DB	'HHC02771%s %s missing following %s parameter', 0aH, 00H
	ORG $+2
$SG169367 DB	'parseCommand', 00H
	ORG $+3
$SG169368 DB	'maketape.c', 00H
	ORG $+1
$SG169375 DB	'o', 00H
	ORG $+2
$SG169372 DB	'output:', 00H
$SG169374 DB	'out:', 00H
	ORG $+3
$SG169376 DB	'o:', 00H
	ORG $+1
$SG169380 DB	'E', 00H
	ORG $+2
$SG169379 DB	'<output file name>', 00H
	ORG $+1
$SG169388 DB	'vol', 00H
$SG169381 DB	'HHC02771%s %s missing following %s parameter', 0aH, 00H
	ORG $+2
$SG169382 DB	'parseCommand', 00H
	ORG $+3
$SG169383 DB	'maketape.c', 00H
	ORG $+1
$SG169386 DB	'volser', 00H
	ORG $+1
$SG169390 DB	'v', 00H
	ORG $+2
$SG169387 DB	'volser:', 00H
$SG169389 DB	'vol:', 00H
	ORG $+3
$SG169391 DB	'v:', 00H
	ORG $+1
$SG169395 DB	'E', 00H
	ORG $+2
$SG169394 DB	'<serial number>', 00H
$SG169396 DB	'HHC02771%s %s missing following %s parameter', 0aH, 00H
	ORG $+2
$SG169397 DB	'parseCommand', 00H
	ORG $+3
$SG169398 DB	'maketape.c', 00H
	ORG $+1
$SG169405 DB	'dsn', 00H
$SG169401 DB	'dataset', 00H
$SG169402 DB	'dataset:', 00H
	ORG $+3
$SG169403 DB	'data', 00H
	ORG $+3
$SG169404 DB	'data:', 00H
	ORG $+2
$SG169406 DB	'dsn:', 00H
	ORG $+3
$SG169407 DB	'd', 00H
	ORG $+2
$SG169408 DB	'd:', 00H
	ORG $+1
$SG169412 DB	'E', 00H
	ORG $+2
$SG169411 DB	'<dataset name>', 00H
	ORG $+1
$SG169413 DB	'HHC02771%s %s missing following %s parameter', 0aH, 00H
	ORG $+2
$SG169414 DB	'parseCommand', 00H
	ORG $+3
$SG169415 DB	'maketape.c', 00H
	ORG $+1
$SG169418 DB	'lrecl', 00H
	ORG $+2
$SG169419 DB	'lrecl:', 00H
	ORG $+1
$SG169420 DB	'l', 00H
	ORG $+2
$SG169421 DB	'l:', 00H
	ORG $+1
$SG169425 DB	'E', 00H
	ORG $+2
$SG169424 DB	'<record length>', 00H
$SG169426 DB	'HHC02771%s %s missing following %s parameter', 0aH, 00H
	ORG $+2
$SG169427 DB	'parseCommand', 00H
	ORG $+3
$SG169428 DB	'maketape.c', 00H
	ORG $+1
$SG169431 DB	'block', 00H
	ORG $+2
$SG169432 DB	'block:', 00H
	ORG $+1
$SG169433 DB	'blk', 00H
$SG169434 DB	'blk:', 00H
	ORG $+3
$SG169435 DB	'b', 00H
	ORG $+2
$SG169436 DB	'b:', 00H
	ORG $+1
$SG169439 DB	'<blocking factor>', 00H
	ORG $+2
$SG169440 DB	'E', 00H
	ORG $+2
$SG169441 DB	'HHC02771%s %s missing following %s parameter', 0aH, 00H
	ORG $+2
$SG169442 DB	'parseCommand', 00H
	ORG $+3
$SG169443 DB	'maketape.c', 00H
	ORG $+1
$SG169448 DB	'cp', 00H
	ORG $+1
$SG169446 DB	'codepage', 00H
	ORG $+3
$SG169449 DB	'cp:', 00H
$SG169447 DB	'codepage:', 00H
	ORG $+2
$SG169450 DB	'c', 00H
	ORG $+2
$SG169451 DB	'c:', 00H
	ORG $+1
$SG169455 DB	'E', 00H
	ORG $+2
$SG169454 DB	'<code page>', 00H
$SG169462 DB	'u', 00H
	ORG $+2
$SG169456 DB	'HHC02771%s %s missing following %s parameter', 0aH, 00H
	ORG $+2
$SG169457 DB	'parseCommand', 00H
	ORG $+3
$SG169458 DB	'maketape.c', 00H
	ORG $+1
$SG169461 DB	'unique', 00H
	ORG $+1
$SG169465 DB	'binary', 00H
	ORG $+1
$SG169466 DB	'bin', 00H
$SG169467 DB	'rb', 00H
	ORG $+1
$SG169470 DB	'nltape', 00H
	ORG $+1
$SG169471 DB	'nl', 00H
	ORG $+1
$SG169472 DB	'n', 00H
	ORG $+2
$SG169475 DB	'ansi', 00H
	ORG $+3
$SG169476 DB	'a', 00H
	ORG $+2
$SG169477 DB	'E', 00H
	ORG $+2
$SG169484 DB	'@', 00H
	ORG $+2
$SG169478 DB	'HHC02780%s Unsupported parameter: %s', 0aH, 00H
	ORG $+2
$SG169479 DB	'parseCommand', 00H
	ORG $+3
$SG169480 DB	'maketape.c', 00H
	ORG $+1
$SG169487 DB	'r', 00H
	ORG $+2
$SG169488 DB	'input', 00H
	ORG $+2
$SG169489 DB	'E', 00H
	ORG $+2
$SG169495 DB	'r', 00H
	ORG $+2
$SG169490 DB	'HHC02772%s Error opening %s file ''%s'': %s', 0aH, 00H
	ORG $+1
$SG169497 DB	'E', 00H
	ORG $+2
$SG169491 DB	'parseCommand', 00H
	ORG $+3
$SG169492 DB	'maketape.c', 00H
	ORG $+1
$SG169505 DB	'r', 00H
	ORG $+2
$SG169496 DB	'input (meta)', 00H
	ORG $+3
$SG169498 DB	'HHC02772%s Error opening %s file ''%s'': %s', 0aH, 00H
	ORG $+1
$SG169507 DB	'E', 00H
	ORG $+2
$SG169499 DB	'parseCommand', 00H
	ORG $+3
$SG169500 DB	'maketape.c', 00H
	ORG $+1
$SG169513 DB	'W', 00H
	ORG $+2
$SG169506 DB	'included input', 00H
	ORG $+1
$SG169508 DB	'HHC02773%s Error opening %s file %i ''%s'': %s', 0aH, 00H
	ORG $+2
$SG169509 DB	'parseCommand', 00H
	ORG $+3
$SG169510 DB	'maketape.c', 00H
	ORG $+1
$SG169519 DB	'E', 00H
	ORG $+2
$SG169514 DB	'HHC02774%s Number of files in %s exceeds %d; excess igno'
	DB	'red', 0aH, 00H
	ORG $+3
$SG169515 DB	'parseCommand', 00H
	ORG $+3
$SG169516 DB	'maketape.c', 00H
	ORG $+1
$SG169525 DB	'E', 00H
	ORG $+2
$SG169518 DB	'INPUT: <input file name>', 00H
	ORG $+3
$SG169532 DB	'E', 00H
	ORG $+2
$SG169520 DB	'HHC02775%s Required %s omitted or not found', 0aH, 00H
	ORG $+3
$SG169521 DB	'parseCommand', 00H
	ORG $+3
$SG169522 DB	'maketape.c', 00H
	ORG $+1
$SG169541 DB	'E', 00H
	ORG $+2
$SG169524 DB	'OUTPUT: <output file name>', 00H
	ORG $+1
$SG169547 DB	'W', 00H
	ORG $+2
$SG169526 DB	'HHC02775%s Required %s omitted or not found', 0aH, 00H
	ORG $+3
$SG169527 DB	'parseCommand', 00H
	ORG $+3
$SG169528 DB	'maketape.c', 00H
	ORG $+1
$SG169554 DB	'E', 00H
	ORG $+2
$SG169531 DB	'VOLSER: <volume serial number>', 00H
	ORG $+1
$SG169533 DB	'HHC02775%s Required %s omitted or not found', 0aH, 00H
	ORG $+3
$SG169534 DB	'parseCommand', 00H
	ORG $+3
$SG169535 DB	'maketape.c', 00H
	ORG $+1
$SG169540 DB	'VOLSER', 00H
	ORG $+1
$SG169562 DB	'E', 00H
	ORG $+2
$SG169542 DB	'HHC02781%s Invalid %s parameter: %s', 0aH, 00H
	ORG $+3
$SG169543 DB	'parseCommand', 00H
	ORG $+3
$SG169544 DB	'maketape.c', 00H
	ORG $+1
$SG169546 DB	'VOLSER', 00H
	ORG $+1
$SG169568 DB	'W', 00H
	ORG $+2
$SG169548 DB	'HHC02783%s Parameter %s ignored due to NLTAPE option', 0aH
	DB	00H
	ORG $+2
$SG169549 DB	'parseCommand', 00H
	ORG $+3
$SG169550 DB	'maketape.c', 00H
	ORG $+1
$SG169574 DB	'W', 00H
	ORG $+2
$SG169553 DB	'DATASET: <dataset name>', 00H
$SG169555 DB	'HHC02775%s Required %s omitted or not found', 0aH, 00H
	ORG $+3
$SG169556 DB	'parseCommand', 00H
	ORG $+3
$SG169557 DB	'maketape.c', 00H
	ORG $+1
$SG169581 DB	'%5u', 00H
$SG169561 DB	'DATASET', 00H
$SG169563 DB	'HHC02781%s Invalid %s parameter: %s', 0aH, 00H
	ORG $+3
$SG169564 DB	'parseCommand', 00H
	ORG $+3
$SG169565 DB	'maketape.c', 00H
	ORG $+1
$SG169584 DB	'E', 00H
	ORG $+2
$SG169567 DB	'DATASET', 00H
$SG169569 DB	'HHC02783%s Parameter %s ignored due to NLTAPE option', 0aH
	DB	00H
	ORG $+2
$SG169570 DB	'parseCommand', 00H
	ORG $+3
$SG169571 DB	'maketape.c', 00H
	ORG $+1
$SG169573 DB	'ANSI', 00H
	ORG $+3
$SG169583 DB	'LRECL', 00H
	ORG $+2
$SG169591 DB	'%5u', 00H
$SG169575 DB	'HHC02783%s Parameter %s ignored due to NLTAPE option', 0aH
	DB	00H
	ORG $+2
$SG169576 DB	'parseCommand', 00H
	ORG $+3
$SG169577 DB	'maketape.c', 00H
	ORG $+1
$SG169594 DB	'E', 00H
	ORG $+2
$SG169585 DB	'HHC02781%s Invalid %s parameter: %s', 0aH, 00H
	ORG $+3
$SG169586 DB	'parseCommand', 00H
	ORG $+3
$SG169587 DB	'maketape.c', 00H
	ORG $+1
$SG169593 DB	'BLOCK', 00H
	ORG $+2
$SG169603 DB	'E', 00H
	ORG $+2
$SG169595 DB	'HHC02781%s Invalid %s parameter: %s', 0aH, 00H
	ORG $+3
$SG169596 DB	'parseCommand', 00H
	ORG $+3
$SG169597 DB	'maketape.c', 00H
	ORG $+1
$SG169608 DB	'E', 00H
	ORG $+2
$SG169602 DB	'CODEPAGE', 00H
	ORG $+3
$SG169621 DB	'header', 00H
	ORG $+1
$SG169622 DB	'E', 00H
	ORG $+2
$SG169604 DB	'HHC02781%s Invalid %s parameter: %s', 0aH, 00H
	ORG $+3
$SG169605 DB	'parseCommand', 00H
	ORG $+3
$SG169606 DB	'maketape.c', 00H
	ORG $+5
$SG169609 DB	'HHC02782%s LRECL %i and BLOCK %i exceeds maximum AWS blo'
	DB	'cksize of %i', 0aH, 00H
	ORG $+2
$SG169610 DB	'parseCommand', 00H
	ORG $+3
$SG169611 DB	'maketape.c', 00H
	ORG $+1
$SG169629 DB	'E', 00H
	ORG $+2
$SG169623 DB	'HHC02776%s Error writing %s to file'' %s'': %s', 0aH, 00H
	ORG $+2
$SG169624 DB	'writeBuffer', 00H
$SG169656 DB	'HDR', 00H
$SG169625 DB	'maketape.c', 00H
	ORG $+1
$SG169657 DB	'EOF', 00H
$SG169628 DB	'data record', 00H
$SG169671 DB	'  ', 00H
	ORG $+1
$SG169630 DB	'HHC02776%s Error writing %s to file'' %s'': %s', 0aH, 00H
	ORG $+2
$SG169631 DB	'writeBuffer', 00H
$SG169685 DB	'I', 00H
	ORG $+2
$SG169632 DB	'maketape.c', 00H
	ORG $+1
$SG169662 DB	'%4.4u', 00H
	ORG $+2
$SG169666 DB	'0001', 00H
	ORG $+3
$SG169669 DB	'0001', 00H
	ORG $+3
$SG169670 DB	'    ', 00H
	ORG $+3
$SG169672 DB	'99365', 00H
	ORG $+2
$SG169677 DB	'000000', 00H
	ORG $+1
$SG169678 DB	'%6.6i', 00H
	ORG $+2
$SG169679 DB	'%5.5i', 00H
	ORG $+2
$SG169680 DB	'%5.5i', 00H
	ORG $+2
$SG169693 DB	'E', 00H
	ORG $+2
$SG169681 DB	'HERCULES/MAKETAPE', 00H
	ORG $+6
$SG169687 DB	'writeLabel', 00H
	ORG $+5
$SG169694 DB	'HHC02776%s Error writing %s to file'' %s'': %s', 0aH, 00H
	ORG $+2
$SG169723 DB	'Create an .AWS tape file from data', 00H
	ORG $+5
$SG169686 DB	'HHC02778%s Wrote %i blocks to AWSTAPE file: ''%s'' (Seq '
	DB	'#%.4s Dataset:''%.17s'')', 0aH, 00H
	ORG $+2
$SG169688 DB	'maketape.c', 00H
	ORG $+1
$SG169725 DB	'I', 00H
	ORG $+2
$SG169692 DB	'tape mark', 00H
	ORG $+2
$SG169730 DB	'wb', 00H
	ORG $+1
$SG169695 DB	'writeTapeMark', 00H
	ORG $+2
$SG169696 DB	'maketape.c', 00H
	ORG $+1
$SG169732 DB	'E', 00H
	ORG $+2
$SG169724 DB	'maketape', 00H
	ORG $+3
$SG169731 DB	'output', 00H
	ORG $+1
$SG169741 DB	'I', 00H
	ORG $+2
$SG169726 DB	'HHC02779%s %s (C) copyright Jay Moseley, CCP 2000', 0aH, 00H
	ORG $+1
$SG169727 DB	'main', 00H
	ORG $+3
$SG169746 DB	'input', 00H
	ORG $+2
$SG169747 DB	'E', 00H
	ORG $+2
$SG169728 DB	'maketape.c', 00H
	ORG $+5
$SG169733 DB	'HHC02772%s Error opening %s file ''%s'': %s', 0aH, 00H
	ORG $+1
$SG169734 DB	'main', 00H
	ORG $+7
$SG169735 DB	'maketape.c', 00H
	ORG $+1
$SG169737 DB	'VOL1', 00H
	ORG $+7
$SG169742 DB	'HHC02777%s Processing input from: ''%s''', 0aH, 00H
$SG169743 DB	'main', 00H
	ORG $+3
$SG169744 DB	'maketape.c', 00H
	ORG $+5
$SG169748 DB	'HHC02773%s Error opening %s file %i ''%s'': %s', 0aH, 00H
	ORG $+2
$SG169749 DB	'main', 00H
	ORG $+3
$SG169750 DB	'maketape.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:writeLabel
	DD	01bH
	DD	0520H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:valid_dataset
	DD	013H
	DD	09aH
voltbl	ENDS
xdata	SEGMENT
$unwind$localtime DD 010901H
	DD	04209H
$unwind$time DD	010901H
	DD	04209H
$unwind$ErrExit DD 010801H
	DD	04208H
$unwind$julianDate DD 010401H
	DD	08204H
$unwind$valid_alpha DD 010801H
	DD	02208H
$unwind$valid_numeric DD 010801H
	DD	02208H
$unwind$valid_alphanumeric DD 010801H
	DD	06208H
$unwind$valid_national DD 010801H
	DD	02208H
$unwind$valid_volser DD 010901H
	DD	06209H
$unwind$valid_dsn_first DD 010801H
	DD	06208H
$unwind$valid_dsn_remaining DD 010801H
	DD	06208H
$unwind$valid_dsn_segment DD 010901H
	DD	06209H
$unwind$valid_dataset DD 011819H
	DD	0a209H
	DD	imagerel __GSHandlerCheck
	DD	048H
$unwind$parseCommand DD 021001H
	DD	01f0110H
$unwind$writeBuffer DD 010801H
	DD	0c208H
$unwind$writeLabel DD 042319H
	DD	0150111H
	DD	06009700aH
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$writeTapeMark DD 010401H
	DD	0c204H
$unwind$main DD	031101H
	DD	0140111H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\maketape.c
_TEXT	SEGMENT
i$ = 96
offset$ = 100
save$1 = 104
pgm$ = 112
tv86 = 120
tv180 = 128
tv198 = 136
tv204 = 144
tv274 = 152
argc$ = 176
argv$ = 184
main	PROC

; 820  : {

$LN40:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	57		 push	 rdi
  0000a	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H

; 821  : char   *pgm;                       /* less any extension (.ext)            */
; 822  : int     i;                         /* used to index string vars            */
; 823  : int     offset;                    /* used for building blocked records    */
; 824  : 
; 825  :     INITIALIZE_UTILITY( UTILITY_NAME, UTILITY_DESC, &pgm );

  00011	48 8d 44 24 70	 lea	 rax, QWORD PTR pgm$[rsp]
  00016	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169723
  00022	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169724
  00029	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00031	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_initialize_utility
  0003e	89 84 24 b0 00
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 826  : 
; 827  :     // "%s (C) copyright Jay Moseley, CCP 2000"
; 828  :     WRMSG( HHC02779, "I", pgm );

  00045	b9 01 00 00 00	 mov	 ecx, 1
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00050	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pgm$[rsp]
  00055	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169725
  00061	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169726
  0006d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00072	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00077	41 b9 03 00 00
	00		 mov	 r9d, 3
  0007d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169727
  00084	ba 3c 03 00 00	 mov	 edx, 828		; 0000033cH
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169728
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 829  : 
; 830  :     /* validate and extract submitted parameter values */
; 831  :     parseCommand( argc, argv );

  00096	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0009e	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  000a5	e8 00 00 00 00	 call	 parseCommand

; 832  : 
; 833  :     /* build julian date for standard labels */
; 834  :     julianDate();

  000aa	e8 00 00 00 00	 call	 julianDate

; 835  : 
; 836  :     /* open the AWSTAPE image file */
; 837  :     if (!(outf = fopen( outFileID, "wb" )))

  000af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169730
  000b6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR outFileID
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  000c3	48 89 05 00 00
	00 00		 mov	 QWORD PTR outf, rax
  000ca	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR outf, 0
  000d2	0f 85 86 00 00
	00		 jne	 $LN18@main

; 838  :     {
; 839  :         // "Error opening %s file '%s': %s"
; 840  :         FWRMSG( stderr, HHC02772, "E", "output", outFileID, strerror( errno ));

  000d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000de	8b 08		 mov	 ecx, DWORD PTR [rax]
  000e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000e6	48 89 44 24 78	 mov	 QWORD PTR tv86[rsp], rax
  000eb	b9 02 00 00 00	 mov	 ecx, 2
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000f6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv86[rsp]
  000fb	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00100	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR outFileID
  00107	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0010c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169731
  00113	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00118	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169732
  0011f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00124	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169733
  0012b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00130	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00135	41 b9 03 00 00
	00		 mov	 r9d, 3
  0013b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169734
  00142	ba 48 03 00 00	 mov	 edx, 840		; 00000348H
  00147	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169735
  0014e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 841  :         ErrExit( RC_OPEN_OUT );

  00154	b9 03 00 00 00	 mov	 ecx, 3
  00159	e8 00 00 00 00	 call	 ErrExit
$LN18@main:

; 842  :     }
; 843  : 
; 844  :     /* build and write VOLume 1 label */
; 845  :     if (!nltape)

  0015e	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR nltape
  00165	85 c0		 test	 eax, eax
  00167	0f 85 17 01 00
	00		 jne	 $LN19@main

; 846  :     {
; 847  :         bool save;
; 848  : 
; 849  :         for (i=0; i < 80; i++)

  0016d	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00175	eb 0a		 jmp	 SHORT $LN4@main
$LN2@main:
  00177	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0017b	ff c0		 inc	 eax
  0017d	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN4@main:
  00181	83 7c 24 60 50	 cmp	 DWORD PTR i$[rsp], 80	; 00000050H
  00186	7d 12		 jge	 SHORT $LN3@main

; 850  :             buf[i] = ' ';

  00188	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0018d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  00194	c6 04 01 20	 mov	 BYTE PTR [rcx+rax], 32	; 00000020H
  00198	eb dd		 jmp	 SHORT $LN2@main
$LN3@main:

; 851  : 
; 852  :         STRLCPY( buf, "VOL1" );

  0019a	41 b8 ff ff 00
	00		 mov	 r8d, 65535		; 0000ffffH
  001a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169737
  001a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  001ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 853  :         strncpy( buf+4, volSer, 6 );

  001b4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:buf
  001bb	48 83 c0 04	 add	 rax, 4
  001bf	41 b8 06 00 00
	00		 mov	 r8d, 6
  001c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:volSer
  001cc	48 8b c8	 mov	 rcx, rax
  001cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 854  : 
; 855  :         if (!ansi)

  001d5	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ansi
  001dc	85 c0		 test	 eax, eax
  001de	75 14		 jne	 SHORT $LN20@main

; 856  :             buf[10] = '0';

  001e0	b8 01 00 00 00	 mov	 eax, 1
  001e5	48 6b c0 0a	 imul	 rax, rax, 10
  001e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  001f0	c6 04 01 30	 mov	 BYTE PTR [rcx+rax], 48	; 00000030H
$LN20@main:

; 857  : 
; 858  :         /* ensure that label fields only contain upper case */
; 859  :         for (i=0; i < 80; i++)

  001f4	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001fc	eb 0a		 jmp	 SHORT $LN7@main
$LN5@main:
  001fe	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00202	ff c0		 inc	 eax
  00204	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN7@main:
  00208	83 7c 24 60 50	 cmp	 DWORD PTR i$[rsp], 80	; 00000050H
  0020d	7d 29		 jge	 SHORT $LN6@main

; 860  :             buf[i] = toupper( buf[i] );

  0020f	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00214	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  0021b	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0021f	8b c8		 mov	 ecx, eax
  00221	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  00227	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$[rsp]
  0022c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:buf
  00233	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00236	eb c6		 jmp	 SHORT $LN5@main
$LN6@main:

; 861  : 
; 862  :         if (ansi)

  00238	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ansi
  0023f	85 c0		 test	 eax, eax
  00241	74 14		 je	 SHORT $LN21@main

; 863  :             buf[79] = '1';

  00243	b8 01 00 00 00	 mov	 eax, 1
  00248	48 6b c0 4f	 imul	 rax, rax, 79		; 0000004fH
  0024c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  00253	c6 04 01 31	 mov	 BYTE PTR [rcx+rax], 49	; 00000031H
$LN21@main:

; 864  : 
; 865  :         save = binary;

  00257	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR binary
  0025e	88 44 24 68	 mov	 BYTE PTR save$1[rsp], al

; 866  :         binary = ansi;

  00262	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ansi
  00269	88 05 00 00 00
	00		 mov	 BYTE PTR binary, al

; 867  :         writeBuffer( 80 );

  0026f	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00274	e8 00 00 00 00	 call	 writeBuffer

; 868  :         binary = save;

  00279	0f b6 44 24 68	 movzx	 eax, BYTE PTR save$1[rsp]
  0027e	88 05 00 00 00
	00		 mov	 BYTE PTR binary, al
$LN19@main:

; 869  :     }
; 870  : 
; 871  :     inFileSeq = 0;                   /* index of input files        */

  00284	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR inFileSeq, 0

; 872  :     blkSize = lrecl * blkfactor;     /* compute physical block size */

  0028e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR lrecl
  00294	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR blkfactor
  0029b	89 05 00 00 00
	00		 mov	 DWORD PTR blkSize, eax

; 873  :     offset = 0;                      /* intrablock pointer          */

  002a1	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR offset$[rsp], 0

; 874  : 
; 875  :     /* if single output file specified, write header labels */
; 876  :     if ((outGLOBBING == outputGLOB) && !nltape)

  002a9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR outGLOBBING, 0
  002b0	75 22		 jne	 SHORT $LN22@main
  002b2	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR nltape
  002b9	85 c0		 test	 eax, eax
  002bb	75 17		 jne	 SHORT $LN22@main

; 877  :     {
; 878  :         writeLabel( 'H', '1' );

  002bd	b2 31		 mov	 dl, 49			; 00000031H
  002bf	b1 48		 mov	 cl, 72			; 00000048H
  002c1	e8 00 00 00 00	 call	 writeLabel

; 879  :         writeLabel( 'H', '2' );

  002c6	b2 32		 mov	 dl, 50			; 00000032H
  002c8	b1 48		 mov	 cl, 72			; 00000048H
  002ca	e8 00 00 00 00	 call	 writeLabel

; 880  :         writeTapeMark();

  002cf	e8 00 00 00 00	 call	 writeTapeMark
$LN22@main:
$LN8@main:

; 881  :     }
; 882  : 
; 883  :     /* loop for processing all specified input files */
; 884  :     while (1)

  002d4	33 c0		 xor	 eax, eax
  002d6	83 f8 01	 cmp	 eax, 1
  002d9	0f 84 dd 03 00
	00		 je	 $LN9@main

; 885  :     {
; 886  :         // "Processing input from: '%s'"
; 887  :         WRMSG( HHC02777, "I", inFileID[ inFileSeq ]);

  002df	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR inFileSeq
  002e6	48 69 c0 05 01
	00 00		 imul	 rax, rax, 261		; 00000105H
  002ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:inFileID
  002f4	48 03 c8	 add	 rcx, rax
  002f7	48 8b c1	 mov	 rax, rcx
  002fa	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv180[rsp], rax
  00302	b9 01 00 00 00	 mov	 ecx, 1
  00307	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0030d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv180[rsp]
  00315	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0031a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169741
  00321	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00326	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169742
  0032d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00332	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00337	41 b9 03 00 00
	00		 mov	 r9d, 3
  0033d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169743
  00344	ba 77 03 00 00	 mov	 edx, 887		; 00000377H
  00349	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169744
  00350	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 888  : 
; 889  :         if (!(inData = fopen( inFileID[ inFileSeq ], mode )))

  00356	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR inFileSeq
  0035d	48 69 c0 05 01
	00 00		 imul	 rax, rax, 261		; 00000105H
  00364	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:inFileID
  0036b	48 03 c8	 add	 rcx, rax
  0036e	48 8b c1	 mov	 rax, rcx
  00371	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR mode
  00378	48 8b c8	 mov	 rcx, rax
  0037b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  00381	48 89 05 00 00
	00 00		 mov	 QWORD PTR inData, rax
  00388	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR inData, 0
  00390	0f 85 b0 00 00
	00		 jne	 $LN23@main

; 890  :         {
; 891  :             // "Error opening %s file %i '%s': %s"
; 892  :             FWRMSG( stderr, HHC02773, "E", "input", inFileSeq, inFileID[ inFileSeq ], strerror( errno ));

  00396	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0039c	8b 08		 mov	 ecx, DWORD PTR [rax]
  0039e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  003a4	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv198[rsp], rax
  003ac	48 63 0d 00 00
	00 00		 movsxd	 rcx, DWORD PTR inFileSeq
  003b3	48 69 c9 05 01
	00 00		 imul	 rcx, rcx, 261		; 00000105H
  003ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:inFileID
  003c1	48 03 d1	 add	 rdx, rcx
  003c4	48 8b ca	 mov	 rcx, rdx
  003c7	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR tv204[rsp], rcx
  003cf	b9 02 00 00 00	 mov	 ecx, 2
  003d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003da	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv198[rsp]
  003e2	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  003e7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv204[rsp]
  003ef	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  003f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR inFileSeq
  003fa	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  003fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169746
  00405	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0040a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169747
  00411	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00416	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169748
  0041d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00422	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00427	41 b9 03 00 00
	00		 mov	 r9d, 3
  0042d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169749
  00434	ba 7c 03 00 00	 mov	 edx, 892		; 0000037cH
  00439	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169750
  00440	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN23@main:

; 893  :         }
; 894  : 
; 895  :         /* if multiple output files specified, write header labels */
; 896  :         if (!nltape && (outGLOBBING == outputUNIQUE))

  00446	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR nltape
  0044d	85 c0		 test	 eax, eax
  0044f	75 20		 jne	 SHORT $LN24@main
  00451	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR outGLOBBING, -1
  00458	75 17		 jne	 SHORT $LN24@main

; 897  :         {
; 898  :             writeLabel( 'H', '1' );

  0045a	b2 31		 mov	 dl, 49			; 00000031H
  0045c	b1 48		 mov	 cl, 72			; 00000048H
  0045e	e8 00 00 00 00	 call	 writeLabel

; 899  :             writeLabel( 'H', '2' );

  00463	b2 32		 mov	 dl, 50			; 00000032H
  00465	b1 48		 mov	 cl, 72			; 00000048H
  00467	e8 00 00 00 00	 call	 writeLabel

; 900  :             writeTapeMark();

  0046c	e8 00 00 00 00	 call	 writeTapeMark
$LN24@main:
$LN10@main:

; 901  :         }
; 902  : 
; 903  :         /* loop for processing records from current input file */
; 904  :         while (1)

  00471	33 c0		 xor	 eax, eax
  00473	83 f8 01	 cmp	 eax, 1
  00476	0f 84 87 01 00
	00		 je	 $LN11@main

; 905  :         {
; 906  :             if (binary)

  0047c	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR binary
  00483	85 c0		 test	 eax, eax
  00485	0f 84 92 00 00
	00		 je	 $LN25@main

; 907  :             {
; 908  :                 i = fread( &buf[ offset ], 1, lrecl, inData );

  0048b	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR lrecl
  00492	48 63 4c 24 64	 movsxd	 rcx, DWORD PTR offset$[rsp]
  00497	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:buf
  0049e	48 03 d1	 add	 rdx, rcx
  004a1	48 8b ca	 mov	 rcx, rdx
  004a4	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR inData
  004ab	4c 8b c0	 mov	 r8, rax
  004ae	ba 01 00 00 00	 mov	 edx, 1
  004b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  004b9	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax

; 909  : 
; 910  :                 if (!i)

  004bd	83 7c 24 60 00	 cmp	 DWORD PTR i$[rsp], 0
  004c2	75 05		 jne	 SHORT $LN27@main

; 911  :                     break;

  004c4	e9 3a 01 00 00	 jmp	 $LN11@main
$LN27@main:

; 912  : 
; 913  :                 /* auto-pad to LRECL */
; 914  :                 if (i < lrecl)

  004c9	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR lrecl
  004cf	39 44 24 60	 cmp	 DWORD PTR i$[rsp], eax
  004d3	7d 43		 jge	 SHORT $LN28@main

; 915  :                     memset( &buf[ offset + i ], 0, lrecl - i );

  004d5	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  004d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR lrecl
  004df	2b c8		 sub	 ecx, eax
  004e1	8b c1		 mov	 eax, ecx
  004e3	48 98		 cdqe
  004e5	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv274[rsp], rax
  004ed	8b 4c 24 60	 mov	 ecx, DWORD PTR i$[rsp]
  004f1	8b 54 24 64	 mov	 edx, DWORD PTR offset$[rsp]
  004f5	03 d1		 add	 edx, ecx
  004f7	8b ca		 mov	 ecx, edx
  004f9	48 63 c9	 movsxd	 rcx, ecx
  004fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:buf
  00503	48 03 d1	 add	 rdx, rcx
  00506	48 8b ca	 mov	 rcx, rdx
  00509	48 8b f9	 mov	 rdi, rcx
  0050c	33 c0		 xor	 eax, eax
  0050e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv274[rsp]
  00516	f3 aa		 rep stosb
$LN28@main:

; 916  :             }

  00518	e9 a4 00 00 00	 jmp	 $LN26@main
$LN25@main:

; 917  :             else
; 918  :             {
; 919  :                 /* exit inner loop when EOF reached on data file */
; 920  :                 if (!fgets( &buf[ offset ], MAXLRECL, inData ))

  0051d	48 63 44 24 64	 movsxd	 rax, DWORD PTR offset$[rsp]
  00522	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  00529	48 03 c8	 add	 rcx, rax
  0052c	48 8b c1	 mov	 rax, rcx
  0052f	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR inData
  00536	ba ff 7f 00 00	 mov	 edx, 32767		; 00007fffH
  0053b	48 8b c8	 mov	 rcx, rax
  0053e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgets
  00544	48 85 c0	 test	 rax, rax
  00547	75 05		 jne	 SHORT $LN29@main

; 921  :                     break;

  00549	e9 b5 00 00 00	 jmp	 $LN11@main
$LN29@main:

; 922  : 
; 923  :                 /* copy i/p to o/p buffer until newline or LRECL reached */
; 924  :                 for (i=0; i < lrecl && buf[offset+i] != '\n'; i++);

  0054e	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00556	eb 0a		 jmp	 SHORT $LN14@main
$LN12@main:
  00558	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0055c	ff c0		 inc	 eax
  0055e	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN14@main:
  00562	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR lrecl
  00568	39 44 24 60	 cmp	 DWORD PTR i$[rsp], eax
  0056c	7d 20		 jge	 SHORT $LN13@main
  0056e	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00572	8b 4c 24 64	 mov	 ecx, DWORD PTR offset$[rsp]
  00576	03 c8		 add	 ecx, eax
  00578	8b c1		 mov	 eax, ecx
  0057a	48 98		 cdqe
  0057c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  00583	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00587	83 f8 0a	 cmp	 eax, 10
  0058a	74 02		 je	 SHORT $LN13@main
  0058c	eb ca		 jmp	 SHORT $LN12@main
$LN13@main:

; 925  : 
; 926  :                 /* if i/p record length < LRECL, pad o/p buffer w/spaces */
; 927  :                 for ( ; i < lrecl ; i++)

  0058e	eb 0a		 jmp	 SHORT $LN17@main
$LN15@main:
  00590	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00594	ff c0		 inc	 eax
  00596	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN17@main:
  0059a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR lrecl
  005a0	39 44 24 60	 cmp	 DWORD PTR i$[rsp], eax
  005a4	7d 1b		 jge	 SHORT $LN16@main

; 928  :                     buf[ offset+i ] = ' ';

  005a6	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  005aa	8b 4c 24 64	 mov	 ecx, DWORD PTR offset$[rsp]
  005ae	03 c8		 add	 ecx, eax
  005b0	8b c1		 mov	 eax, ecx
  005b2	48 98		 cdqe
  005b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  005bb	c6 04 01 20	 mov	 BYTE PTR [rcx+rax], 32	; 00000020H
  005bf	eb cf		 jmp	 SHORT $LN15@main
$LN16@main:
$LN26@main:

; 929  :             }
; 930  : 
; 931  :             /* update block pointer and check for end of block */
; 932  :             offset += lrecl;

  005c1	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR lrecl
  005c7	8b 4c 24 64	 mov	 ecx, DWORD PTR offset$[rsp]
  005cb	03 c8		 add	 ecx, eax
  005cd	8b c1		 mov	 eax, ecx
  005cf	89 44 24 64	 mov	 DWORD PTR offset$[rsp], eax

; 933  : 
; 934  :             if (offset >= blkSize)

  005d3	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR blkSize
  005d9	39 44 24 64	 cmp	 DWORD PTR offset$[rsp], eax
  005dd	7c 1f		 jl	 SHORT $LN30@main

; 935  :             {
; 936  :                 writeBuffer( offset );

  005df	8b 4c 24 64	 mov	 ecx, DWORD PTR offset$[rsp]
  005e3	e8 00 00 00 00	 call	 writeBuffer

; 937  :                 blkCount++;

  005e8	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR blkCount
  005ee	ff c0		 inc	 eax
  005f0	89 05 00 00 00
	00		 mov	 DWORD PTR blkCount, eax

; 938  :                 offset = 0;

  005f6	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR offset$[rsp], 0
$LN30@main:

; 939  :             }
; 940  :         } /* while (processing current input data file) */

  005fe	e9 6e fe ff ff	 jmp	 $LN10@main
$LN11@main:

; 941  : 
; 942  :         fclose( inData );              /* close input data file */

  00603	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR inData
  0060a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose

; 943  : 
; 944  :         /* write trailing labels for multiple output files */
; 945  :         if (outGLOBBING == outputUNIQUE)

  00610	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR outGLOBBING, -1
  00617	75 57		 jne	 SHORT $LN31@main

; 946  :         {
; 947  :             /* if partial block at end of input data file, write it */
; 948  :             if (offset > 0)

  00619	83 7c 24 64 00	 cmp	 DWORD PTR offset$[rsp], 0
  0061e	7e 1f		 jle	 SHORT $LN32@main

; 949  :             {
; 950  :                 writeBuffer( offset );

  00620	8b 4c 24 64	 mov	 ecx, DWORD PTR offset$[rsp]
  00624	e8 00 00 00 00	 call	 writeBuffer

; 951  :                 blkCount++;

  00629	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR blkCount
  0062f	ff c0		 inc	 eax
  00631	89 05 00 00 00
	00		 mov	 DWORD PTR blkCount, eax

; 952  :                 offset = 0;

  00637	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR offset$[rsp], 0
$LN32@main:

; 953  :             }
; 954  : 
; 955  :             if (!nltape)

  0063f	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR nltape
  00646	85 c0		 test	 eax, eax
  00648	75 17		 jne	 SHORT $LN33@main

; 956  :             {
; 957  :                 writeTapeMark();

  0064a	e8 00 00 00 00	 call	 writeTapeMark

; 958  :                 writeLabel( 'E', '1' );

  0064f	b2 31		 mov	 dl, 49			; 00000031H
  00651	b1 45		 mov	 cl, 69			; 00000045H
  00653	e8 00 00 00 00	 call	 writeLabel

; 959  :                 writeLabel( 'E', '2' );

  00658	b2 32		 mov	 dl, 50			; 00000032H
  0065a	b1 45		 mov	 cl, 69			; 00000045H
  0065c	e8 00 00 00 00	 call	 writeLabel
$LN33@main:

; 960  :             }
; 961  : 
; 962  :             writeTapeMark();

  00661	e8 00 00 00 00	 call	 writeTapeMark

; 963  :             blkCount = 0;

  00666	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR blkCount, 0
$LN31@main:

; 964  :         } /* if (writing separate files) */
; 965  : 
; 966  :         inFileSeq++;    /* increment to next input file ID */

  00670	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR inFileSeq
  00676	ff c0		 inc	 eax
  00678	89 05 00 00 00
	00		 mov	 DWORD PTR inFileSeq, eax

; 967  : 
; 968  :         /* exit while if file ID blank or max input files processed */
; 969  :         if (0
; 970  :             || inFileSeq >= MAXFILES
; 971  :             || !strlen( inFileID[ inFileSeq ])

  0067e	33 c0		 xor	 eax, eax
  00680	85 c0		 test	 eax, eax
  00682	75 31		 jne	 SHORT $LN35@main
  00684	83 3d 00 00 00
	00 32		 cmp	 DWORD PTR inFileSeq, 50	; 00000032H
  0068b	7d 28		 jge	 SHORT $LN35@main
  0068d	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR inFileSeq
  00694	48 69 c0 05 01
	00 00		 imul	 rax, rax, 261		; 00000105H
  0069b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:inFileID
  006a2	48 03 c8	 add	 rcx, rax
  006a5	48 8b c1	 mov	 rax, rcx
  006a8	48 8b c8	 mov	 rcx, rax
  006ab	e8 00 00 00 00	 call	 strlen
  006b0	48 85 c0	 test	 rax, rax
  006b3	75 02		 jne	 SHORT $LN34@main
$LN35@main:

; 972  :         )
; 973  :             break;

  006b5	eb 05		 jmp	 SHORT $LN9@main
$LN34@main:

; 974  : 
; 975  :     } /* while (loop processing all input data files */

  006b7	e9 18 fc ff ff	 jmp	 $LN8@main
$LN9@main:

; 976  : 
; 977  :     /* if partial block at end of last input file, write it */
; 978  :     if (offset > 0)

  006bc	83 7c 24 64 00	 cmp	 DWORD PTR offset$[rsp], 0
  006c1	7e 17		 jle	 SHORT $LN36@main

; 979  :     {
; 980  :         writeBuffer( offset );

  006c3	8b 4c 24 64	 mov	 ecx, DWORD PTR offset$[rsp]
  006c7	e8 00 00 00 00	 call	 writeBuffer

; 981  :         blkCount++;

  006cc	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR blkCount
  006d2	ff c0		 inc	 eax
  006d4	89 05 00 00 00
	00		 mov	 DWORD PTR blkCount, eax
$LN36@main:

; 982  :     }
; 983  : 
; 984  :     /* write trailing labels for single output file */
; 985  :     if (outGLOBBING == outputGLOB)

  006da	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR outGLOBBING, 0
  006e1	75 27		 jne	 SHORT $LN37@main

; 986  :     {
; 987  :         writeTapeMark();

  006e3	e8 00 00 00 00	 call	 writeTapeMark

; 988  : 
; 989  :         if (!nltape)

  006e8	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR nltape
  006ef	85 c0		 test	 eax, eax
  006f1	75 17		 jne	 SHORT $LN38@main

; 990  :         {
; 991  :             writeLabel( 'E', '1' );

  006f3	b2 31		 mov	 dl, 49			; 00000031H
  006f5	b1 45		 mov	 cl, 69			; 00000045H
  006f7	e8 00 00 00 00	 call	 writeLabel

; 992  :             writeLabel( 'E', '2' );

  006fc	b2 32		 mov	 dl, 50			; 00000032H
  006fe	b1 45		 mov	 cl, 69			; 00000045H
  00700	e8 00 00 00 00	 call	 writeLabel

; 993  :             writeTapeMark();

  00705	e8 00 00 00 00	 call	 writeTapeMark
$LN38@main:
$LN37@main:

; 994  :         }
; 995  :     } /* if (writing single output file) */
; 996  : 
; 997  :     /* write closing tape mark for end of volume indication */
; 998  :     writeTapeMark();

  0070a	e8 00 00 00 00	 call	 writeTapeMark

; 999  : 
; 1000 :     /* Close output file and exit */
; 1001 :     fclose( outf );

  0070f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR outf
  00716	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose

; 1002 : 
; 1003 :     /* Success! */
; 1004 :     return 0;

  0071c	33 c0		 xor	 eax, eax

; 1005 : 
; 1006 : } /* end main */

  0071e	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  00725	5f		 pop	 rdi
  00726	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\maketape.c
_TEXT	SEGMENT
tv82 = 80
writeTapeMark PROC

; 796  : {

  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 797  :     /* set fields in header block for tape mark */
; 798  :     awshdr.prvblkl[0] = awshdr.curblkl[0];

  00004	b8 01 00 00 00	 mov	 eax, 1
  00009	48 6b c0 00	 imul	 rax, rax, 0
  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:awshdr
  00014	ba 01 00 00 00	 mov	 edx, 1
  00019	48 6b d2 00	 imul	 rdx, rdx, 0
  0001d	4c 8d 05 02 00
	00 00		 lea	 r8, OFFSET FLAT:awshdr+2
  00024	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00028	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al

; 799  :     awshdr.prvblkl[1] = awshdr.curblkl[1];

  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	48 6b c0 01	 imul	 rax, rax, 1
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:awshdr
  0003c	ba 01 00 00 00	 mov	 edx, 1
  00041	48 6b d2 01	 imul	 rdx, rdx, 1
  00045	4c 8d 05 02 00
	00 00		 lea	 r8, OFFSET FLAT:awshdr+2
  0004c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00050	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al

; 800  : 
; 801  :     awshdr.curblkl[0] = 0;

  00054	b8 01 00 00 00	 mov	 eax, 1
  00059	48 6b c0 00	 imul	 rax, rax, 0
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:awshdr
  00064	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 802  :     awshdr.curblkl[1] = 0;

  00068	b8 01 00 00 00	 mov	 eax, 1
  0006d	48 6b c0 01	 imul	 rax, rax, 1
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:awshdr
  00078	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 803  : 
; 804  :     awshdr.flags1 = AWSTAPE_FLAG1_TAPEMARK;

  0007c	c6 05 04 00 00
	00 40		 mov	 BYTE PTR awshdr+4, 64	; 00000040H

; 805  :     awshdr.flags2 = 0;

  00083	c6 05 05 00 00
	00 00		 mov	 BYTE PTR awshdr+5, 0

; 806  : 
; 807  :     /* write header block to AWSTAPE image file */
; 808  :     if (fwrite( &awshdr, 1, sizeof( awshdr ), outf ) != sizeof( awshdr ))

  0008a	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR outf
  00091	41 b8 06 00 00
	00		 mov	 r8d, 6
  00097	ba 01 00 00 00	 mov	 edx, 1
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:awshdr
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite
  000a9	48 83 f8 06	 cmp	 rax, 6
  000ad	0f 84 86 00 00
	00		 je	 $LN2@writeTapeM

; 809  :     {
; 810  :         // "Error writing %s to file' %s': %s"
; 811  :         FWRMSG( stderr, HHC02776, "E", "tape mark", outFileID, strerror( errno ));

  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000b9	8b 08		 mov	 ecx, DWORD PTR [rax]
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000c1	48 89 44 24 50	 mov	 QWORD PTR tv82[rsp], rax
  000c6	b9 02 00 00 00	 mov	 ecx, 2
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000d1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv82[rsp]
  000d6	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000db	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR outFileID
  000e2	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169692
  000ee	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169693
  000fa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169694
  00106	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0010b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00110	41 b9 03 00 00
	00		 mov	 r9d, 3
  00116	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169695
  0011d	ba 2b 03 00 00	 mov	 edx, 811		; 0000032bH
  00122	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169696
  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 812  :         ErrExit( RC_WTM_IOERR );

  0012f	b9 06 00 00 00	 mov	 ecx, 6
  00134	e8 00 00 00 00	 call	 ErrExit
$LN2@writeTapeM:

; 813  :     }
; 814  : }

  00139	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0013d	c3		 ret	 0
writeTapeMark ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\maketape.c
_TEXT	SEGMENT
i$ = 96
j$ = 100
save$1 = 104
$T2 = 112
fseq$ = 120
dsn$ = 128
__$ArrayPad$ = 152
ltype$ = 192
lseq$ = 200
writeLabel PROC

; 689  : {

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00008	56		 push	 rsi
  00009	57		 push	 rdi
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 690  : char    dsn[ MAXTAPEDSNLEN + 1 ];  /* temporary dataset name variable      */
; 691  : char    fseq[4+1];                 /* temporary file sequence variable     */
; 692  : int     i, j;                      /* used to index through string vars    */
; 693  : 
; 694  :     /* clear buffer to spaces to build label */
; 695  :     for (i=0; i < 80; i++)

  00023	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0002b	eb 0a		 jmp	 SHORT $LN4@writeLabel
$LN2@writeLabel:
  0002d	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00031	ff c0		 inc	 eax
  00033	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN4@writeLabel:
  00037	83 7c 24 60 50	 cmp	 DWORD PTR i$[rsp], 80	; 00000050H
  0003c	7d 12		 jge	 SHORT $LN3@writeLabel

; 696  :         buf[i] = ' ';

  0003e	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  0004a	c6 04 01 20	 mov	 BYTE PTR [rcx+rax], 32	; 00000020H
  0004e	eb dd		 jmp	 SHORT $LN2@writeLabel
$LN3@writeLabel:

; 697  : 
; 698  :     if (ltype == 'H')

  00050	0f be 84 24 c0
	00 00 00	 movsx	 eax, BYTE PTR ltype$[rsp]
  00058	83 f8 48	 cmp	 eax, 72			; 00000048H
  0005b	75 1c		 jne	 SHORT $LN11@writeLabel

; 699  :         STRLCPY( buf, "HDR" );     /* HeaDeR label requested */

  0005d	41 b8 ff ff 00
	00		 mov	 r8d, 65535		; 0000ffffH
  00063	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169656
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  00077	eb 1a		 jmp	 SHORT $LN12@writeLabel
$LN11@writeLabel:

; 700  :     else
; 701  :         STRLCPY( buf, "EOF" );     /* EndOfFile label requested */

  00079	41 b8 ff ff 00
	00		 mov	 r8d, 65535		; 0000ffffH
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169657
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN12@writeLabel:

; 702  : 
; 703  :     buf[3] = lseq;                 /* insert passed number into label */

  00093	b8 01 00 00 00	 mov	 eax, 1
  00098	48 6b c0 03	 imul	 rax, rax, 3
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  000a3	0f b6 94 24 c8
	00 00 00	 movzx	 edx, BYTE PTR lseq$[rsp]
  000ab	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 704  : 
; 705  :     /* copy dataset name parameter to work variable, at conclusion j will
; 706  :        contain the index to the first blank past the end of the label text */
; 707  :     STRLCPY( dsn, datasetName );

  000ae	41 b8 12 00 00
	00		 mov	 r8d, 18
  000b4	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR datasetName
  000bb	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR dsn$[rsp]
  000c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 708  :     for (i = j = 0; i < MAXTAPEDSNLEN; i++)

  000c9	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  000d1	8b 44 24 64	 mov	 eax, DWORD PTR j$[rsp]
  000d5	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
  000d9	eb 0a		 jmp	 SHORT $LN7@writeLabel
$LN5@writeLabel:
  000db	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  000df	ff c0		 inc	 eax
  000e1	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN7@writeLabel:
  000e5	83 7c 24 60 11	 cmp	 DWORD PTR i$[rsp], 17
  000ea	7d 3d		 jge	 SHORT $LN6@writeLabel

; 709  :     {
; 710  :         if (i && !j && !dsn[i])    /* first NULL reached yet? */

  000ec	83 7c 24 60 00	 cmp	 DWORD PTR i$[rsp], 0
  000f1	74 20		 je	 SHORT $LN13@writeLabel
  000f3	83 7c 24 64 00	 cmp	 DWORD PTR j$[rsp], 0
  000f8	75 19		 jne	 SHORT $LN13@writeLabel
  000fa	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  000ff	0f be 84 04 80
	00 00 00	 movsx	 eax, BYTE PTR dsn$[rsp+rax]
  00107	85 c0		 test	 eax, eax
  00109	75 08		 jne	 SHORT $LN13@writeLabel

; 711  :             j = i;                 /* save pos of first blank */

  0010b	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0010f	89 44 24 64	 mov	 DWORD PTR j$[rsp], eax
$LN13@writeLabel:

; 712  :         if (j)                     /* pad? */

  00113	83 7c 24 64 00	 cmp	 DWORD PTR j$[rsp], 0
  00118	74 0d		 je	 SHORT $LN14@writeLabel

; 713  :             dsn[i] = ' ';          /* yes */

  0011a	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0011f	c6 84 04 80 00
	00 00 20	 mov	 BYTE PTR dsn$[rsp+rax], 32 ; 00000020H
$LN14@writeLabel:

; 714  :     }

  00127	eb b2		 jmp	 SHORT $LN5@writeLabel
$LN6@writeLabel:

; 715  :     dsn[ MAXTAPEDSNLEN ] = 0;      /* NULL terminate string */

  00129	b8 01 00 00 00	 mov	 eax, 1
  0012e	48 6b c0 11	 imul	 rax, rax, 17
  00132	48 89 44 24 70	 mov	 QWORD PTR $T2[rsp], rax
  00137	48 83 7c 24 70
	12		 cmp	 QWORD PTR $T2[rsp], 18
  0013d	73 02		 jae	 SHORT $LN30@writeLabel
  0013f	eb 05		 jmp	 SHORT $LN31@writeLabel
$LN30@writeLabel:
  00141	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN31@writeLabel:
  00146	48 8b 44 24 70	 mov	 rax, QWORD PTR $T2[rsp]
  0014b	c6 84 04 80 00
	00 00 00	 mov	 BYTE PTR dsn$[rsp+rax], 0

; 716  : 
; 717  :     /* if each file is to be output discretely, manufacture unique dsn */
; 718  :     if (outGLOBBING == outputUNIQUE)

  00153	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR outGLOBBING, -1
  0015a	0f 85 9f 00 00
	00		 jne	 $LN15@writeLabel

; 719  :     {
; 720  :         /* copy input file sequence number to work variable */
; 721  :         MSGBUF( fseq, "%4.4u", (inFileSeq+1));

  00160	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR inFileSeq
  00166	ff c0		 inc	 eax
  00168	44 8b c8	 mov	 r9d, eax
  0016b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169662
  00172	ba 05 00 00 00	 mov	 edx, 5
  00177	48 8d 4c 24 78	 lea	 rcx, QWORD PTR fseq$[rsp]
  0017c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 722  : 
; 723  :         if (!j || j > 11)

  00182	83 7c 24 64 00	 cmp	 DWORD PTR j$[rsp], 0
  00187	74 07		 je	 SHORT $LN19@writeLabel
  00189	83 7c 24 64 0b	 cmp	 DWORD PTR j$[rsp], 11
  0018e	7e 2f		 jle	 SHORT $LN17@writeLabel
$LN19@writeLabel:

; 724  :         {
; 725  :             dsn[11] = '.';

  00190	b8 01 00 00 00	 mov	 eax, 1
  00195	48 6b c0 0b	 imul	 rax, rax, 11
  00199	c6 84 04 80 00
	00 00 2e	 mov	 BYTE PTR dsn$[rsp+rax], 46 ; 0000002eH

; 726  :             dsn[12] = 'F';

  001a1	b8 01 00 00 00	 mov	 eax, 1
  001a6	48 6b c0 0c	 imul	 rax, rax, 12
  001aa	c6 84 04 80 00
	00 00 46	 mov	 BYTE PTR dsn$[rsp+rax], 70 ; 00000046H

; 727  :             memcpy( dsn+13, fseq, 4 );

  001b2	8b 44 24 78	 mov	 eax, DWORD PTR fseq$[rsp]
  001b6	89 84 24 8d 00
	00 00		 mov	 DWORD PTR dsn$[rsp+13], eax

; 728  :         }

  001bd	eb 3e		 jmp	 SHORT $LN18@writeLabel
$LN17@writeLabel:

; 729  :         else
; 730  :         {
; 731  :             dsn[j] = '.'; j++;

  001bf	48 63 44 24 64	 movsxd	 rax, DWORD PTR j$[rsp]
  001c4	c6 84 04 80 00
	00 00 2e	 mov	 BYTE PTR dsn$[rsp+rax], 46 ; 0000002eH
  001cc	8b 44 24 64	 mov	 eax, DWORD PTR j$[rsp]
  001d0	ff c0		 inc	 eax
  001d2	89 44 24 64	 mov	 DWORD PTR j$[rsp], eax

; 732  :             dsn[j] = 'F'; j++;

  001d6	48 63 44 24 64	 movsxd	 rax, DWORD PTR j$[rsp]
  001db	c6 84 04 80 00
	00 00 46	 mov	 BYTE PTR dsn$[rsp+rax], 70 ; 00000046H
  001e3	8b 44 24 64	 mov	 eax, DWORD PTR j$[rsp]
  001e7	ff c0		 inc	 eax
  001e9	89 44 24 64	 mov	 DWORD PTR j$[rsp], eax

; 733  :             memcpy( dsn+j, fseq, 4 );

  001ed	48 63 44 24 64	 movsxd	 rax, DWORD PTR j$[rsp]
  001f2	8b 4c 24 78	 mov	 ecx, DWORD PTR fseq$[rsp]
  001f6	89 8c 04 80 00
	00 00		 mov	 DWORD PTR dsn$[rsp+rax], ecx
$LN18@writeLabel:

; 734  :         }
; 735  :     }

  001fd	eb 18		 jmp	 SHORT $LN16@writeLabel
$LN15@writeLabel:

; 736  :     else
; 737  :         STRLCPY( fseq, "0001" );         /* only 1 file on output tape */

  001ff	41 b8 05 00 00
	00		 mov	 r8d, 5
  00205	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169666
  0020c	48 8d 4c 24 78	 lea	 rcx, QWORD PTR fseq$[rsp]
  00211	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN16@writeLabel:

; 738  : 
; 739  :     /* format label based upon passed sequence number */
; 740  :     if (lseq == '1')                     /* -------- label #1 -------- */

  00217	0f be 84 24 c8
	00 00 00	 movsx	 eax, BYTE PTR lseq$[rsp]
  0021f	83 f8 31	 cmp	 eax, 49			; 00000031H
  00222	0f 85 28 01 00
	00		 jne	 $LN20@writeLabel

; 741  :     {
; 742  :         memcpy( buf+ 4, dsn, MAXTAPEDSNLEN); /* dataset name          */

  00228	48 8d 05 04 00
	00 00		 lea	 rax, OFFSET FLAT:buf+4
  0022f	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR dsn$[rsp]
  00237	48 8b f8	 mov	 rdi, rax
  0023a	48 8b f1	 mov	 rsi, rcx
  0023d	b9 11 00 00 00	 mov	 ecx, 17
  00242	f3 a4		 rep movsb

; 743  :         memcpy( buf+21, volSer,  6);    /* volume serial number       */

  00244	48 8d 05 15 00
	00 00		 lea	 rax, OFFSET FLAT:buf+21
  0024b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:volSer
  00252	48 8b f8	 mov	 rdi, rax
  00255	48 8b f1	 mov	 rsi, rcx
  00258	b9 06 00 00 00	 mov	 ecx, 6
  0025d	f3 a4		 rep movsb

; 744  :         memcpy( buf+27, "0001",  4);    /* volume sequence number     */

  0025f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR $SG169669
  00265	89 05 1b 00 00
	00		 mov	 DWORD PTR buf+27, eax

; 745  :         memcpy( buf+31, fseq,    4);    /* file number                */

  0026b	8b 44 24 78	 mov	 eax, DWORD PTR fseq$[rsp]
  0026f	89 05 1f 00 00
	00		 mov	 DWORD PTR buf+31, eax

; 746  :         memcpy( buf+35, "    ",  4);    /* generation number          */

  00275	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR $SG169670
  0027b	89 05 23 00 00
	00		 mov	 DWORD PTR buf+35, eax

; 747  :         memcpy( buf+39, "  ",    2);    /* version number             */

  00281	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR $SG169671
  00288	66 89 05 27 00
	00 00		 mov	 WORD PTR buf+39, ax

; 748  :         memcpy( buf+42, julianToday, 5);/* creation date              */

  0028f	48 8d 05 2a 00
	00 00		 lea	 rax, OFFSET FLAT:buf+42
  00296	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:julianToday
  0029d	48 8b f8	 mov	 rdi, rax
  002a0	48 8b f1	 mov	 rsi, rcx
  002a3	b9 05 00 00 00	 mov	 ecx, 5
  002a8	f3 a4		 rep movsb

; 749  :         memcpy( buf+48, "99365", 5);    /* expiration date            */

  002aa	48 8d 05 30 00
	00 00		 lea	 rax, OFFSET FLAT:buf+48
  002b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169672
  002b8	48 8b f8	 mov	 rdi, rax
  002bb	48 8b f1	 mov	 rsi, rcx
  002be	b9 05 00 00 00	 mov	 ecx, 5
  002c3	f3 a4		 rep movsb

; 750  : 
; 751  :         if (ansi)

  002c5	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ansi
  002cc	85 c0		 test	 eax, eax
  002ce	74 16		 je	 SHORT $LN22@writeLabel

; 752  :             buf[53] = ' ';

  002d0	b8 01 00 00 00	 mov	 eax, 1
  002d5	48 6b c0 35	 imul	 rax, rax, 53		; 00000035H
  002d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  002e0	c6 04 01 20	 mov	 BYTE PTR [rcx+rax], 32	; 00000020H
  002e4	eb 14		 jmp	 SHORT $LN23@writeLabel
$LN22@writeLabel:

; 753  :         else
; 754  :             buf[53] = '0';               /* security - 0 = none        */

  002e6	b8 01 00 00 00	 mov	 eax, 1
  002eb	48 6b c0 35	 imul	 rax, rax, 53		; 00000035H
  002ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  002f6	c6 04 01 30	 mov	 BYTE PTR [rcx+rax], 48	; 00000030H
$LN23@writeLabel:

; 755  : 
; 756  :         if (ltype == 'H')

  002fa	0f be 84 24 c0
	00 00 00	 movsx	 eax, BYTE PTR ltype$[rsp]
  00302	83 f8 48	 cmp	 eax, 72			; 00000048H
  00305	75 1d		 jne	 SHORT $LN24@writeLabel

; 757  :             memcpy( buf+54, "000000", 6 ); /* no blk count in hdr */

  00307	48 8d 05 36 00
	00 00		 lea	 rax, OFFSET FLAT:buf+54
  0030e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169677
  00315	48 8b f8	 mov	 rdi, rax
  00318	48 8b f1	 mov	 rsi, rcx
  0031b	b9 06 00 00 00	 mov	 ecx, 6
  00320	f3 a4		 rep movsb
  00322	eb 27		 jmp	 SHORT $LN25@writeLabel
$LN24@writeLabel:

; 758  :         else
; 759  :             snprintf( buf+54, 7, "%6.6i", blkCount );

  00324	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:buf
  0032b	48 83 c0 36	 add	 rax, 54			; 00000036H
  0032f	44 8b 0d 00 00
	00 00		 mov	 r9d, DWORD PTR blkCount
  00336	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169678
  0033d	ba 07 00 00 00	 mov	 edx, 7
  00342	48 8b c8	 mov	 rcx, rax
  00345	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN25@writeLabel:

; 760  :     }

  0034b	e9 c2 00 00 00	 jmp	 $LN21@writeLabel
$LN20@writeLabel:

; 761  :     else                                  /* ------- label #2 -------- */
; 762  :     {
; 763  :         buf[4] = 'F';                     /* record format - F = fixed */

  00350	b8 01 00 00 00	 mov	 eax, 1
  00355	48 6b c0 04	 imul	 rax, rax, 4
  00359	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  00360	c6 04 01 46	 mov	 BYTE PTR [rcx+rax], 70	; 00000046H

; 764  :         snprintf( buf+5,  6, "%5.5i", blkSize );

  00364	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:buf
  0036b	48 83 c0 05	 add	 rax, 5
  0036f	44 8b 0d 00 00
	00 00		 mov	 r9d, DWORD PTR blkSize
  00376	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169679
  0037d	ba 06 00 00 00	 mov	 edx, 6
  00382	48 8b c8	 mov	 rcx, rax
  00385	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 765  :         snprintf( buf+10, 6, "%5.5i", lrecl );

  0038b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:buf
  00392	48 83 c0 0a	 add	 rax, 10
  00396	44 8b 0d 00 00
	00 00		 mov	 r9d, DWORD PTR lrecl
  0039d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169680
  003a4	ba 06 00 00 00	 mov	 edx, 6
  003a9	48 8b c8	 mov	 rcx, rax
  003ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 766  :         buf[15] = '3';                    /* density                   */

  003b2	b8 01 00 00 00	 mov	 eax, 1
  003b7	48 6b c0 0f	 imul	 rax, rax, 15
  003bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  003c2	c6 04 01 33	 mov	 BYTE PTR [rcx+rax], 51	; 00000033H

; 767  :         buf[16] = '0';                    /* dataset position          */

  003c6	b8 01 00 00 00	 mov	 eax, 1
  003cb	48 6b c0 10	 imul	 rax, rax, 16
  003cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  003d6	c6 04 01 30	 mov	 BYTE PTR [rcx+rax], 48	; 00000030H

; 768  :         memcpy( buf+17, "HERCULES/MAKETAPE", 17 );/* job/step creating*/

  003da	48 8d 05 11 00
	00 00		 lea	 rax, OFFSET FLAT:buf+17
  003e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169681
  003e8	48 8b f8	 mov	 rdi, rax
  003eb	48 8b f1	 mov	 rsi, rcx
  003ee	b9 11 00 00 00	 mov	 ecx, 17
  003f3	f3 a4		 rep movsb

; 769  :         if (blkfactor != 1)

  003f5	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR blkfactor, 1
  003fc	74 14		 je	 SHORT $LN26@writeLabel

; 770  :             buf[38] = 'B';                /* blocked records           */

  003fe	b8 01 00 00 00	 mov	 eax, 1
  00403	48 6b c0 26	 imul	 rax, rax, 38		; 00000026H
  00407	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  0040e	c6 04 01 42	 mov	 BYTE PTR [rcx+rax], 66	; 00000042H
$LN26@writeLabel:
$LN21@writeLabel:

; 771  :     }
; 772  : 
; 773  :     /* ensure that label fields only contain upper case */
; 774  :     for (i=0; i < 80; i++)

  00412	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0041a	eb 0a		 jmp	 SHORT $LN10@writeLabel
$LN8@writeLabel:
  0041c	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00420	ff c0		 inc	 eax
  00422	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN10@writeLabel:
  00426	83 7c 24 60 50	 cmp	 DWORD PTR i$[rsp], 80	; 00000050H
  0042b	7d 29		 jge	 SHORT $LN9@writeLabel

; 775  :         buf[i] = toupper( buf[i] );

  0042d	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00432	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  00439	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0043d	8b c8		 mov	 ecx, eax
  0043f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  00445	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$[rsp]
  0044a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:buf
  00451	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00454	eb c6		 jmp	 SHORT $LN8@writeLabel
$LN9@writeLabel:

; 776  : 
; 777  :     if (!nltape)

  00456	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR nltape
  0045d	85 c0		 test	 eax, eax
  0045f	75 2d		 jne	 SHORT $LN27@writeLabel

; 778  :     {
; 779  :         bool save = binary;

  00461	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR binary
  00468	88 44 24 68	 mov	 BYTE PTR save$1[rsp], al

; 780  :         binary = ansi;

  0046c	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ansi
  00473	88 05 00 00 00
	00		 mov	 BYTE PTR binary, al

; 781  :         writeBuffer( 80 );

  00479	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  0047e	e8 00 00 00 00	 call	 writeBuffer

; 782  :         binary = save;

  00483	0f b6 44 24 68	 movzx	 eax, BYTE PTR save$1[rsp]
  00488	88 05 00 00 00
	00		 mov	 BYTE PTR binary, al
$LN27@writeLabel:

; 783  :     }
; 784  : 
; 785  :     /* show dataset info when last end label written for each file */
; 786  :     if (ltype == 'E' && lseq == '2')

  0048e	0f be 84 24 c0
	00 00 00	 movsx	 eax, BYTE PTR ltype$[rsp]
  00496	83 f8 45	 cmp	 eax, 69			; 00000045H
  00499	0f 85 81 00 00
	00		 jne	 $LN28@writeLabel
  0049f	0f be 84 24 c8
	00 00 00	 movsx	 eax, BYTE PTR lseq$[rsp]
  004a7	83 f8 32	 cmp	 eax, 50			; 00000032H
  004aa	75 74		 jne	 SHORT $LN28@writeLabel

; 787  :         // "Wrote %i blocks to AWSTAPE file: '%s' (Seq #%.4s Dataset:'%.17s')"
; 788  :         WRMSG( HHC02778, "I", blkCount, outFileID, fseq, dsn );

  004ac	b9 01 00 00 00	 mov	 ecx, 1
  004b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004b7	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR dsn$[rsp]
  004bf	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  004c4	48 8d 4c 24 78	 lea	 rcx, QWORD PTR fseq$[rsp]
  004c9	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  004ce	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR outFileID
  004d5	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  004da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR blkCount
  004e0	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  004e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169685
  004eb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169686
  004f7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004fc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00501	41 b9 03 00 00
	00		 mov	 r9d, 3
  00507	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169687
  0050e	ba 14 03 00 00	 mov	 edx, 788		; 00000314H
  00513	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169688
  0051a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN28@writeLabel:
$LN29@writeLabel:

; 789  : 
; 790  : } /* writeLabel */

  00520	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00528	48 33 cc	 xor	 rcx, rsp
  0052b	e8 00 00 00 00	 call	 __security_check_cookie
  00530	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00537	5f		 pop	 rdi
  00538	5e		 pop	 rsi
  00539	c3		 ret	 0
writeLabel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\maketape.c
_TEXT	SEGMENT
tv87 = 80
tv148 = 88
bufferLen$ = 112
writeBuffer PROC

; 653  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 654  :     /* set up fields in header block */
; 655  :     awshdr.prvblkl[0] = awshdr.curblkl[0];

  00008	b8 01 00 00 00	 mov	 eax, 1
  0000d	48 6b c0 00	 imul	 rax, rax, 0
  00011	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:awshdr
  00018	ba 01 00 00 00	 mov	 edx, 1
  0001d	48 6b d2 00	 imul	 rdx, rdx, 0
  00021	4c 8d 05 02 00
	00 00		 lea	 r8, OFFSET FLAT:awshdr+2
  00028	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0002c	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al

; 656  :     awshdr.prvblkl[1] = awshdr.curblkl[1];

  00030	b8 01 00 00 00	 mov	 eax, 1
  00035	48 6b c0 01	 imul	 rax, rax, 1
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:awshdr
  00040	ba 01 00 00 00	 mov	 edx, 1
  00045	48 6b d2 01	 imul	 rdx, rdx, 1
  00049	4c 8d 05 02 00
	00 00		 lea	 r8, OFFSET FLAT:awshdr+2
  00050	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00054	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al

; 657  : 
; 658  :     awshdr.curblkl[0] = (bufferLen     ) & 0xFF;

  00058	8b 44 24 70	 mov	 eax, DWORD PTR bufferLen$[rsp]
  0005c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00061	b9 01 00 00 00	 mov	 ecx, 1
  00066	48 6b c9 00	 imul	 rcx, rcx, 0
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:awshdr
  00071	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 659  :     awshdr.curblkl[1] = (bufferLen >> 8) & 0xFF;

  00074	8b 44 24 70	 mov	 eax, DWORD PTR bufferLen$[rsp]
  00078	c1 f8 08	 sar	 eax, 8
  0007b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00080	b9 01 00 00 00	 mov	 ecx, 1
  00085	48 6b c9 01	 imul	 rcx, rcx, 1
  00089	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:awshdr
  00090	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 660  : 
; 661  :     awshdr.flags1 = AWSTAPE_FLAG1_NEWREC | AWSTAPE_FLAG1_ENDREC;

  00093	c6 05 04 00 00
	00 a0		 mov	 BYTE PTR awshdr+4, 160	; 000000a0H

; 662  :     awshdr.flags2 = 0;

  0009a	c6 05 05 00 00
	00 00		 mov	 BYTE PTR awshdr+5, 0

; 663  : 
; 664  :     /* write header block to AWSTAPE image file */
; 665  :     if (fwrite( &awshdr, 1, sizeof( awshdr ), outf ) != sizeof( awshdr ))

  000a1	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR outf
  000a8	41 b8 06 00 00
	00		 mov	 r8d, 6
  000ae	ba 01 00 00 00	 mov	 edx, 1
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:awshdr
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite
  000c0	48 83 f8 06	 cmp	 rax, 6
  000c4	0f 84 86 00 00
	00		 je	 $LN2@writeBuffe

; 666  :     {
; 667  :         // "Error writing %s to file' %s': %s"
; 668  :         FWRMSG( stderr, HHC02776, "E", "header", outFileID, strerror( errno ));

  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000d0	8b 08		 mov	 ecx, DWORD PTR [rax]
  000d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000d8	48 89 44 24 50	 mov	 QWORD PTR tv87[rsp], rax
  000dd	b9 02 00 00 00	 mov	 ecx, 2
  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000e8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv87[rsp]
  000ed	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000f2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR outFileID
  000f9	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169621
  00105	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0010a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169622
  00111	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00116	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169623
  0011d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00122	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00127	41 b9 03 00 00
	00		 mov	 r9d, 3
  0012d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169624
  00134	ba 9c 02 00 00	 mov	 edx, 668		; 0000029cH
  00139	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169625
  00140	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 669  :         ErrExit( RC_HDR_IOERR );

  00146	b9 04 00 00 00	 mov	 ecx, 4
  0014b	e8 00 00 00 00	 call	 ErrExit
$LN2@writeBuffe:

; 670  :     }
; 671  : 
; 672  :     /* convert data in i/o buffer from ASCII to EBCDIC */
; 673  :     if (!binary)

  00150	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR binary
  00157	85 c0		 test	 eax, eax
  00159	75 19		 jne	 SHORT $LN3@writeBuffe

; 674  :         buf_host_to_guest( (BYTE*)buf, (BYTE*)buf, bufferLen );

  0015b	44 8b 44 24 70	 mov	 r8d, DWORD PTR bufferLen$[rsp]
  00160	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:buf
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  0016e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_buf_host_to_guest
$LN3@writeBuffe:

; 675  : 
; 676  :     /* write data block to AWSTAPE image file */
; 677  :     if (fwrite( buf, 1, bufferLen, outf ) != (size_t)bufferLen)

  00174	48 63 44 24 70	 movsxd	 rax, DWORD PTR bufferLen$[rsp]
  00179	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR outf
  00180	4c 8b c0	 mov	 r8, rax
  00183	ba 01 00 00 00	 mov	 edx, 1
  00188	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  0018f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite
  00195	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR bufferLen$[rsp]
  0019a	48 3b c1	 cmp	 rax, rcx
  0019d	0f 84 86 00 00
	00		 je	 $LN4@writeBuffe

; 678  :     {
; 679  :         // "Error writing %s to file' %s': %s"
; 680  :         FWRMSG( stderr, HHC02776, "E", "data record", outFileID, strerror( errno ));

  001a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001a9	8b 08		 mov	 ecx, DWORD PTR [rax]
  001ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  001b1	48 89 44 24 58	 mov	 QWORD PTR tv148[rsp], rax
  001b6	b9 02 00 00 00	 mov	 ecx, 2
  001bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001c1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv148[rsp]
  001c6	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001cb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR outFileID
  001d2	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169628
  001de	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169629
  001ea	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169630
  001f6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001fb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00200	41 b9 03 00 00
	00		 mov	 r9d, 3
  00206	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169631
  0020d	ba a8 02 00 00	 mov	 edx, 680		; 000002a8H
  00212	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169632
  00219	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 681  :         ErrExit( RC_DATA_IOERR );

  0021f	b9 05 00 00 00	 mov	 ecx, 5
  00224	e8 00 00 00 00	 call	 ErrExit
$LN4@writeBuffe:

; 682  :     }
; 683  : }

  00229	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0022d	c3		 ret	 0
writeBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\maketape.c
_TEXT	SEGMENT
i$ = 96
errors$ = 100
valid$1 = 101
valid$2 = 102
k$3 = 104
tv1074 = 108
tv1076 = 112
tv1111 = 116
tv1113 = 120
k$4 = 124
k$5 = 128
$T6 = 136
tv154 = 144
tv217 = 152
tv280 = 160
tv389 = 168
tv438 = 176
tv533 = 184
tv596 = 192
tv713 = 200
tv743 = 208
tv769 = 216
tv809 = 224
argc$ = 256
argv$ = 264
parseCommand PROC

; 217  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H

; 218  : int  i;                            /* index to parse arguments             */
; 219  : bool errors;                       /* indicate missing/invalid arguments   */
; 220  : 
; 221  :     /* if no parameters supplied, display syntax and exit */
; 222  :     if (argc <= 1)

  00010	83 bc 24 00 01
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  00018	7f 51		 jg	 SHORT $LN22@parseComma

; 223  :     {
; 224  :         WRMSG( HHC02770, "I" );

  0001a	b9 01 00 00 00	 mov	 ecx, 1
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169350
  0002c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169351
  00038	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0003d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00042	41 b9 03 00 00
	00		 mov	 r9d, 3
  00048	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169352
  0004f	ba e0 00 00 00	 mov	 edx, 224		; 000000e0H
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169353
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 225  :         ErrExit( RC_SYNTAX );

  00061	b9 01 00 00 00	 mov	 ecx, 1
  00066	e8 00 00 00 00	 call	 ErrExit
$LN22@parseComma:

; 226  :     }
; 227  : 
; 228  :     errors = false;

  0006b	c6 44 24 64 00	 mov	 BYTE PTR errors$[rsp], 0

; 229  : 
; 230  :     /* copy parameter values into global variables */
; 231  :     for (i = 1; i < argc; i++)

  00070	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  00078	eb 0a		 jmp	 SHORT $LN4@parseComma
$LN2@parseComma:
  0007a	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0007e	ff c0		 inc	 eax
  00080	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN4@parseComma:
  00084	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  0008b	39 44 24 60	 cmp	 DWORD PTR i$[rsp], eax
  0008f	0f 8d 4b 0d 00
	00		 jge	 $LN3@parseComma

; 232  :     {
; 233  :         /* looking for variations on INPUT: keyword */
; 234  :         if (0
; 235  :             || !strcasecmp( argv[i], "input"  )
; 236  :             || !strcasecmp( argv[i], "input:" )
; 237  :             || !strcasecmp( argv[i], "in"     )
; 238  :             || !strcasecmp( argv[i], "in:"    )
; 239  :             || !strcasecmp( argv[i], "i"      )
; 240  :             || !strcasecmp( argv[i], "i:"     )

  00095	33 c0		 xor	 eax, eax
  00097	85 c0		 test	 eax, eax
  00099	0f 85 d8 00 00
	00		 jne	 $LN24@parseComma
  0009f	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  000a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169356
  000ab	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000b3	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  000bd	85 c0		 test	 eax, eax
  000bf	0f 84 b2 00 00
	00		 je	 $LN24@parseComma
  000c5	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  000ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169357
  000d1	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000d9	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  000dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  000e3	85 c0		 test	 eax, eax
  000e5	0f 84 8c 00 00
	00		 je	 $LN24@parseComma
  000eb	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  000f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169358
  000f7	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000ff	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00103	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00109	85 c0		 test	 eax, eax
  0010b	74 6a		 je	 SHORT $LN24@parseComma
  0010d	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00112	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169359
  00119	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00121	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00125	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0012b	85 c0		 test	 eax, eax
  0012d	74 48		 je	 SHORT $LN24@parseComma
  0012f	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00134	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169360
  0013b	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00143	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00147	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0014d	85 c0		 test	 eax, eax
  0014f	74 26		 je	 SHORT $LN24@parseComma
  00151	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00156	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169361
  0015d	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00165	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00169	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0016f	85 c0		 test	 eax, eax
  00171	0f 85 ba 00 00
	00		 jne	 $LN23@parseComma
$LN24@parseComma:

; 241  :         )
; 242  :         {
; 243  :             if (i >= (argc-1))

  00177	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  0017e	ff c8		 dec	 eax
  00180	39 44 24 60	 cmp	 DWORD PTR i$[rsp], eax
  00184	0f 8c 80 00 00
	00		 jl	 $LN25@parseComma

; 244  :             {
; 245  :                 // "%s missing following %s parameter"
; 246  :                 FWRMSG( stderr, HHC02771, "E", "<input file name>", argv[i] );

  0018a	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0018f	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv154[rsp], rax
  00197	b9 02 00 00 00	 mov	 ecx, 2
  0019c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001a2	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001aa	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tv154[rsp]
  001b2	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  001b6	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169364
  001c2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169365
  001ce	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169366
  001da	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001df	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e4	41 b9 03 00 00
	00		 mov	 r9d, 3
  001ea	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169367
  001f1	ba f6 00 00 00	 mov	 edx, 246		; 000000f6H
  001f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169368
  001fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 247  :                 errors = true;

  00203	c6 44 24 64 01	 mov	 BYTE PTR errors$[rsp], 1

; 248  :             }

  00208	eb 22		 jmp	 SHORT $LN26@parseComma
$LN25@parseComma:

; 249  :             else
; 250  :                 pInFileID = argv[(++i)];

  0020a	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0020e	ff c0		 inc	 eax
  00210	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
  00214	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00219	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00221	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00225	48 89 05 00 00
	00 00		 mov	 QWORD PTR pInFileID, rax
$LN26@parseComma:

; 251  :             continue;

  0022c	e9 49 fe ff ff	 jmp	 $LN2@parseComma
$LN23@parseComma:

; 252  :         }
; 253  : 
; 254  :         /* looking for variations on OUTPUT: keyword */
; 255  :         if (0
; 256  :             || !strcasecmp( argv[i], "output"  )
; 257  :             || !strcasecmp( argv[i], "output:" )
; 258  :             || !strcasecmp( argv[i], "out"     )
; 259  :             || !strcasecmp( argv[i], "out:"    )
; 260  :             || !strcasecmp( argv[i], "o"       )
; 261  :             || !strcasecmp( argv[i], "o:"      )

  00231	33 c0		 xor	 eax, eax
  00233	85 c0		 test	 eax, eax
  00235	0f 85 d8 00 00
	00		 jne	 $LN28@parseComma
  0023b	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00240	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169371
  00247	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0024f	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00253	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00259	85 c0		 test	 eax, eax
  0025b	0f 84 b2 00 00
	00		 je	 $LN28@parseComma
  00261	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00266	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169372
  0026d	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00275	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00279	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0027f	85 c0		 test	 eax, eax
  00281	0f 84 8c 00 00
	00		 je	 $LN28@parseComma
  00287	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0028c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169373
  00293	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0029b	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0029f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  002a5	85 c0		 test	 eax, eax
  002a7	74 6a		 je	 SHORT $LN28@parseComma
  002a9	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  002ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169374
  002b5	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002bd	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  002c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  002c7	85 c0		 test	 eax, eax
  002c9	74 48		 je	 SHORT $LN28@parseComma
  002cb	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  002d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169375
  002d7	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002df	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  002e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  002e9	85 c0		 test	 eax, eax
  002eb	74 26		 je	 SHORT $LN28@parseComma
  002ed	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  002f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169376
  002f9	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00301	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00305	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0030b	85 c0		 test	 eax, eax
  0030d	0f 85 ba 00 00
	00		 jne	 $LN27@parseComma
$LN28@parseComma:

; 262  :         )
; 263  :         {
; 264  :             if (i >= (argc-1))

  00313	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  0031a	ff c8		 dec	 eax
  0031c	39 44 24 60	 cmp	 DWORD PTR i$[rsp], eax
  00320	0f 8c 80 00 00
	00		 jl	 $LN29@parseComma

; 265  :             {
; 266  :                 // "%s missing following %s parameter"
; 267  :                 FWRMSG( stderr, HHC02771, "E", "<output file name>", argv[i] );

  00326	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0032b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv217[rsp], rax
  00333	b9 02 00 00 00	 mov	 ecx, 2
  00338	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0033e	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00346	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR tv217[rsp]
  0034e	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  00352	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00357	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169379
  0035e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00363	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169380
  0036a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0036f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169381
  00376	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0037b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00380	41 b9 03 00 00
	00		 mov	 r9d, 3
  00386	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169382
  0038d	ba 0b 01 00 00	 mov	 edx, 267		; 0000010bH
  00392	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169383
  00399	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 268  :                 errors = true;

  0039f	c6 44 24 64 01	 mov	 BYTE PTR errors$[rsp], 1

; 269  :             }

  003a4	eb 22		 jmp	 SHORT $LN30@parseComma
$LN29@parseComma:

; 270  :             else
; 271  :                 outFileID = argv[(++i)];

  003a6	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  003aa	ff c0		 inc	 eax
  003ac	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
  003b0	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  003b5	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  003bd	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  003c1	48 89 05 00 00
	00 00		 mov	 QWORD PTR outFileID, rax
$LN30@parseComma:

; 272  :             continue;

  003c8	e9 ad fc ff ff	 jmp	 $LN2@parseComma
$LN27@parseComma:

; 273  :         }
; 274  : 
; 275  :         /* looking for variations on VOLSER: keyword */
; 276  :         if (0
; 277  :             || !strcasecmp( argv[i], "volser"  )
; 278  :             || !strcasecmp( argv[i], "volser:" )
; 279  :             || !strcasecmp( argv[i], "vol"     )
; 280  :             || !strcasecmp( argv[i], "vol:"    )
; 281  :             || !strcasecmp( argv[i], "v"       )
; 282  :             || !strcasecmp( argv[i], "v:"      )

  003cd	33 c0		 xor	 eax, eax
  003cf	85 c0		 test	 eax, eax
  003d1	0f 85 d8 00 00
	00		 jne	 $LN32@parseComma
  003d7	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  003dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169386
  003e3	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  003eb	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  003ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  003f5	85 c0		 test	 eax, eax
  003f7	0f 84 b2 00 00
	00		 je	 $LN32@parseComma
  003fd	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00402	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169387
  00409	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00411	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00415	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0041b	85 c0		 test	 eax, eax
  0041d	0f 84 8c 00 00
	00		 je	 $LN32@parseComma
  00423	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00428	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169388
  0042f	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00437	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0043b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00441	85 c0		 test	 eax, eax
  00443	74 6a		 je	 SHORT $LN32@parseComma
  00445	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0044a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169389
  00451	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00459	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0045d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00463	85 c0		 test	 eax, eax
  00465	74 48		 je	 SHORT $LN32@parseComma
  00467	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0046c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169390
  00473	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0047b	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0047f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00485	85 c0		 test	 eax, eax
  00487	74 26		 je	 SHORT $LN32@parseComma
  00489	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0048e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169391
  00495	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0049d	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  004a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  004a7	85 c0		 test	 eax, eax
  004a9	0f 85 ba 00 00
	00		 jne	 $LN31@parseComma
$LN32@parseComma:

; 283  :         )
; 284  :         {
; 285  :             if (i >= (argc-1))

  004af	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  004b6	ff c8		 dec	 eax
  004b8	39 44 24 60	 cmp	 DWORD PTR i$[rsp], eax
  004bc	0f 8c 80 00 00
	00		 jl	 $LN33@parseComma

; 286  :             {
; 287  :                 // "%s missing following %s parameter"
; 288  :                 FWRMSG( stderr, HHC02771, "E", "<serial number>", argv[i] );

  004c2	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  004c7	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv280[rsp], rax
  004cf	b9 02 00 00 00	 mov	 ecx, 2
  004d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004da	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  004e2	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR tv280[rsp]
  004ea	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  004ee	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  004f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169394
  004fa	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169395
  00506	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0050b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169396
  00512	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00517	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0051c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00522	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169397
  00529	ba 20 01 00 00	 mov	 edx, 288		; 00000120H
  0052e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169398
  00535	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 289  :                 errors = true;

  0053b	c6 44 24 64 01	 mov	 BYTE PTR errors$[rsp], 1

; 290  :             }

  00540	eb 22		 jmp	 SHORT $LN34@parseComma
$LN33@parseComma:

; 291  :             else
; 292  :                 pVolSer = argv[(++i)];

  00542	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00546	ff c0		 inc	 eax
  00548	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
  0054c	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00551	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00559	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0055d	48 89 05 00 00
	00 00		 mov	 QWORD PTR pVolSer, rax
$LN34@parseComma:

; 293  :             continue;

  00564	e9 11 fb ff ff	 jmp	 $LN2@parseComma
$LN31@parseComma:

; 294  :         }
; 295  : 
; 296  :         /* looking for variations on DATASET: keyword */
; 297  :         if (0
; 298  :             || !strcasecmp( argv[i], "dataset"  )
; 299  :             || !strcasecmp( argv[i], "dataset:" )
; 300  :             || !strcasecmp( argv[i], "data"     )
; 301  :             || !strcasecmp( argv[i], "data:"    )
; 302  :             || !strcasecmp( argv[i], "dsn"      )
; 303  :             || !strcasecmp( argv[i], "dsn:"     )
; 304  :             || !strcasecmp( argv[i], "d"        )
; 305  :             || !strcasecmp( argv[i], "d:"       )

  00569	33 c0		 xor	 eax, eax
  0056b	85 c0		 test	 eax, eax
  0056d	0f 85 24 01 00
	00		 jne	 $LN36@parseComma
  00573	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00578	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169401
  0057f	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00587	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0058b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00591	85 c0		 test	 eax, eax
  00593	0f 84 fe 00 00
	00		 je	 $LN36@parseComma
  00599	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0059e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169402
  005a5	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  005ad	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  005b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  005b7	85 c0		 test	 eax, eax
  005b9	0f 84 d8 00 00
	00		 je	 $LN36@parseComma
  005bf	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  005c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169403
  005cb	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  005d3	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  005d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  005dd	85 c0		 test	 eax, eax
  005df	0f 84 b2 00 00
	00		 je	 $LN36@parseComma
  005e5	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  005ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169404
  005f1	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  005f9	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  005fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00603	85 c0		 test	 eax, eax
  00605	0f 84 8c 00 00
	00		 je	 $LN36@parseComma
  0060b	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00610	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169405
  00617	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0061f	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00623	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00629	85 c0		 test	 eax, eax
  0062b	74 6a		 je	 SHORT $LN36@parseComma
  0062d	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00632	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169406
  00639	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00641	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00645	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0064b	85 c0		 test	 eax, eax
  0064d	74 48		 je	 SHORT $LN36@parseComma
  0064f	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00654	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169407
  0065b	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00663	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00667	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0066d	85 c0		 test	 eax, eax
  0066f	74 26		 je	 SHORT $LN36@parseComma
  00671	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00676	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169408
  0067d	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00685	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00689	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0068f	85 c0		 test	 eax, eax
  00691	0f 85 ba 00 00
	00		 jne	 $LN35@parseComma
$LN36@parseComma:

; 306  :         )
; 307  :         {
; 308  :             if (i >= (argc-1))

  00697	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  0069e	ff c8		 dec	 eax
  006a0	39 44 24 60	 cmp	 DWORD PTR i$[rsp], eax
  006a4	0f 8c 80 00 00
	00		 jl	 $LN37@parseComma

; 309  :             {
; 310  :                 // "%s missing following %s parameter"
; 311  :                 FWRMSG( stderr, HHC02771, "E", "<dataset name>", argv[i] );

  006aa	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  006af	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv389[rsp], rax
  006b7	b9 02 00 00 00	 mov	 ecx, 2
  006bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006c2	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  006ca	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR tv389[rsp]
  006d2	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  006d6	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  006db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169411
  006e2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  006e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169412
  006ee	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169413
  006fa	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006ff	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00704	41 b9 03 00 00
	00		 mov	 r9d, 3
  0070a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169414
  00711	ba 37 01 00 00	 mov	 edx, 311		; 00000137H
  00716	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169415
  0071d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 312  :                 errors = true;

  00723	c6 44 24 64 01	 mov	 BYTE PTR errors$[rsp], 1

; 313  :             }

  00728	eb 22		 jmp	 SHORT $LN38@parseComma
$LN37@parseComma:

; 314  :             else
; 315  :                 datasetName = argv[(++i)];

  0072a	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0072e	ff c0		 inc	 eax
  00730	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
  00734	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00739	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00741	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00745	48 89 05 00 00
	00 00		 mov	 QWORD PTR datasetName, rax
$LN38@parseComma:

; 316  :             continue;

  0074c	e9 29 f9 ff ff	 jmp	 $LN2@parseComma
$LN35@parseComma:

; 317  :         }
; 318  : 
; 319  :         /* looking for variations on LRECL: keyword */
; 320  :         if (0
; 321  :             || !strcasecmp( argv[i], "lrecl"  )
; 322  :             || !strcasecmp( argv[i], "lrecl:" )
; 323  :             || !strcasecmp( argv[i], "l"      )
; 324  :             || !strcasecmp( argv[i], "l:"     )

  00751	33 c0		 xor	 eax, eax
  00753	85 c0		 test	 eax, eax
  00755	0f 85 8c 00 00
	00		 jne	 $LN40@parseComma
  0075b	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00760	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169418
  00767	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0076f	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00773	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00779	85 c0		 test	 eax, eax
  0077b	74 6a		 je	 SHORT $LN40@parseComma
  0077d	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00782	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169419
  00789	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00791	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00795	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0079b	85 c0		 test	 eax, eax
  0079d	74 48		 je	 SHORT $LN40@parseComma
  0079f	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  007a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169420
  007ab	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  007b3	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  007b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  007bd	85 c0		 test	 eax, eax
  007bf	74 26		 je	 SHORT $LN40@parseComma
  007c1	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  007c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169421
  007cd	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  007d5	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  007d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  007df	85 c0		 test	 eax, eax
  007e1	0f 85 ba 00 00
	00		 jne	 $LN39@parseComma
$LN40@parseComma:

; 325  :         )
; 326  :         {
; 327  :             if (i >= (argc-1))

  007e7	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  007ee	ff c8		 dec	 eax
  007f0	39 44 24 60	 cmp	 DWORD PTR i$[rsp], eax
  007f4	0f 8c 80 00 00
	00		 jl	 $LN41@parseComma

; 328  :             {
; 329  :                 // "%s missing following %s parameter"
; 330  :                 FWRMSG( stderr, HHC02771, "E", "<record length>", argv[i] );

  007fa	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  007ff	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv438[rsp], rax
  00807	b9 02 00 00 00	 mov	 ecx, 2
  0080c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00812	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0081a	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR tv438[rsp]
  00822	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  00826	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0082b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169424
  00832	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00837	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169425
  0083e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00843	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169426
  0084a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0084f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00854	41 b9 03 00 00
	00		 mov	 r9d, 3
  0085a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169427
  00861	ba 4a 01 00 00	 mov	 edx, 330		; 0000014aH
  00866	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169428
  0086d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 331  :                 errors = true;

  00873	c6 44 24 64 01	 mov	 BYTE PTR errors$[rsp], 1

; 332  :             }

  00878	eb 22		 jmp	 SHORT $LN42@parseComma
$LN41@parseComma:

; 333  :             else
; 334  :                 pLRECL = argv[(++i)];

  0087a	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0087e	ff c0		 inc	 eax
  00880	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
  00884	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00889	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00891	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00895	48 89 05 00 00
	00 00		 mov	 QWORD PTR pLRECL, rax
$LN42@parseComma:

; 335  :             continue;

  0089c	e9 d9 f7 ff ff	 jmp	 $LN2@parseComma
$LN39@parseComma:

; 336  :         }
; 337  : 
; 338  :         /* looking for variations on BLOCK: keyword */
; 339  :         if (0
; 340  :             || !strcasecmp( argv[i], "block"  )
; 341  :             || !strcasecmp( argv[i], "block:" )
; 342  :             || !strcasecmp( argv[i], "blk"    )
; 343  :             || !strcasecmp( argv[i], "blk:"   )
; 344  :             || !strcasecmp( argv[i], "b"      )
; 345  :             || !strcasecmp( argv[i], "b:"     )

  008a1	33 c0		 xor	 eax, eax
  008a3	85 c0		 test	 eax, eax
  008a5	0f 85 d8 00 00
	00		 jne	 $LN44@parseComma
  008ab	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  008b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169431
  008b7	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  008bf	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  008c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  008c9	85 c0		 test	 eax, eax
  008cb	0f 84 b2 00 00
	00		 je	 $LN44@parseComma
  008d1	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  008d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169432
  008dd	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  008e5	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  008e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  008ef	85 c0		 test	 eax, eax
  008f1	0f 84 8c 00 00
	00		 je	 $LN44@parseComma
  008f7	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  008fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169433
  00903	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0090b	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0090f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00915	85 c0		 test	 eax, eax
  00917	74 6a		 je	 SHORT $LN44@parseComma
  00919	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0091e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169434
  00925	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0092d	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00931	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00937	85 c0		 test	 eax, eax
  00939	74 48		 je	 SHORT $LN44@parseComma
  0093b	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00940	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169435
  00947	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0094f	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00953	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00959	85 c0		 test	 eax, eax
  0095b	74 26		 je	 SHORT $LN44@parseComma
  0095d	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00962	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169436
  00969	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00971	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00975	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0097b	85 c0		 test	 eax, eax
  0097d	0f 85 ba 00 00
	00		 jne	 $LN43@parseComma
$LN44@parseComma:

; 346  :         )
; 347  :         {
; 348  :             if (i >= (argc-1))

  00983	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  0098a	ff c8		 dec	 eax
  0098c	39 44 24 60	 cmp	 DWORD PTR i$[rsp], eax
  00990	0f 8c 80 00 00
	00		 jl	 $LN45@parseComma

; 349  :             {
; 350  :                 // "%s missing following %s parameter"
; 351  :                 FWRMSG( stderr, HHC02771, "E", "<blocking factor>", argv[i] );

  00996	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0099b	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv533[rsp], rax
  009a3	b9 02 00 00 00	 mov	 ecx, 2
  009a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009ae	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  009b6	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR tv533[rsp]
  009be	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  009c2	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  009c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169439
  009ce	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  009d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169440
  009da	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169441
  009e6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  009eb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009f0	41 b9 03 00 00
	00		 mov	 r9d, 3
  009f6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169442
  009fd	ba 5f 01 00 00	 mov	 edx, 351		; 0000015fH
  00a02	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169443
  00a09	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 352  :                 errors = true;

  00a0f	c6 44 24 64 01	 mov	 BYTE PTR errors$[rsp], 1

; 353  :             }

  00a14	eb 22		 jmp	 SHORT $LN46@parseComma
$LN45@parseComma:

; 354  :             else
; 355  :                 pBLOCK = argv[(++i)];

  00a16	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00a1a	ff c0		 inc	 eax
  00a1c	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
  00a20	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00a25	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00a2d	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00a31	48 89 05 00 00
	00 00		 mov	 QWORD PTR pBLOCK, rax
$LN46@parseComma:

; 356  :             continue;

  00a38	e9 3d f6 ff ff	 jmp	 $LN2@parseComma
$LN43@parseComma:

; 357  :         }
; 358  : 
; 359  :         /* looking for variations on CODEPAGE: keyword */
; 360  :         if (0
; 361  :             || !strcasecmp( argv[i], "codepage"  )
; 362  :             || !strcasecmp( argv[i], "codepage:" )
; 363  :             || !strcasecmp( argv[i], "cp"    )
; 364  :             || !strcasecmp( argv[i], "cp:"   )
; 365  :             || !strcasecmp( argv[i], "c"      )
; 366  :             || !strcasecmp( argv[i], "c:"     )

  00a3d	33 c0		 xor	 eax, eax
  00a3f	85 c0		 test	 eax, eax
  00a41	0f 85 d8 00 00
	00		 jne	 $LN48@parseComma
  00a47	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00a4c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169446
  00a53	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00a5b	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00a5f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00a65	85 c0		 test	 eax, eax
  00a67	0f 84 b2 00 00
	00		 je	 $LN48@parseComma
  00a6d	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00a72	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169447
  00a79	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00a81	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00a85	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00a8b	85 c0		 test	 eax, eax
  00a8d	0f 84 8c 00 00
	00		 je	 $LN48@parseComma
  00a93	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00a98	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169448
  00a9f	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00aa7	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00aab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00ab1	85 c0		 test	 eax, eax
  00ab3	74 6a		 je	 SHORT $LN48@parseComma
  00ab5	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00aba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169449
  00ac1	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00ac9	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00acd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00ad3	85 c0		 test	 eax, eax
  00ad5	74 48		 je	 SHORT $LN48@parseComma
  00ad7	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00adc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169450
  00ae3	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00aeb	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00aef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00af5	85 c0		 test	 eax, eax
  00af7	74 26		 je	 SHORT $LN48@parseComma
  00af9	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00afe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169451
  00b05	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00b0d	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00b11	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00b17	85 c0		 test	 eax, eax
  00b19	0f 85 ba 00 00
	00		 jne	 $LN47@parseComma
$LN48@parseComma:

; 367  :         )
; 368  :         {
; 369  :             if (i >= (argc-1))

  00b1f	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00b26	ff c8		 dec	 eax
  00b28	39 44 24 60	 cmp	 DWORD PTR i$[rsp], eax
  00b2c	0f 8c 80 00 00
	00		 jl	 $LN49@parseComma

; 370  :             {
; 371  :                 // "%s missing following %s parameter"
; 372  :                 FWRMSG( stderr, HHC02771, "E", "<code page>", argv[i] );

  00b32	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00b37	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv596[rsp], rax
  00b3f	b9 02 00 00 00	 mov	 ecx, 2
  00b44	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b4a	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00b52	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR tv596[rsp]
  00b5a	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  00b5e	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00b63	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169454
  00b6a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00b6f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169455
  00b76	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b7b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169456
  00b82	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b87	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b8c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b92	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169457
  00b99	ba 74 01 00 00	 mov	 edx, 372		; 00000174H
  00b9e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169458
  00ba5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 373  :                 errors = true;

  00bab	c6 44 24 64 01	 mov	 BYTE PTR errors$[rsp], 1

; 374  :             }

  00bb0	eb 22		 jmp	 SHORT $LN50@parseComma
$LN49@parseComma:

; 375  :             else
; 376  :                 pCODEPAGE = argv[(++i)];

  00bb2	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00bb6	ff c0		 inc	 eax
  00bb8	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
  00bbc	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00bc1	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00bc9	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00bcd	48 89 05 00 00
	00 00		 mov	 QWORD PTR pCODEPAGE, rax
$LN50@parseComma:

; 377  :             continue;

  00bd4	e9 a1 f4 ff ff	 jmp	 $LN2@parseComma
$LN47@parseComma:

; 378  :         }
; 379  : 
; 380  :         /* looking for variations on UNIQUE keyword */
; 381  :         if (0
; 382  :             || !strcasecmp( argv[i], "unique" )
; 383  :             || !strcasecmp( argv[i], "u"      )

  00bd9	33 c0		 xor	 eax, eax
  00bdb	85 c0		 test	 eax, eax
  00bdd	75 44		 jne	 SHORT $LN52@parseComma
  00bdf	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00be4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169461
  00beb	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00bf3	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00bf7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00bfd	85 c0		 test	 eax, eax
  00bff	74 22		 je	 SHORT $LN52@parseComma
  00c01	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00c06	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169462
  00c0d	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00c15	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00c19	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00c1f	85 c0		 test	 eax, eax
  00c21	75 0f		 jne	 SHORT $LN51@parseComma
$LN52@parseComma:

; 384  :         )
; 385  :         {
; 386  :             outGLOBBING = outputUNIQUE;

  00c23	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR outGLOBBING, -1

; 387  :             continue;

  00c2d	e9 48 f4 ff ff	 jmp	 $LN2@parseComma
$LN51@parseComma:

; 388  :         }
; 389  : 
; 390  :         /* looking for variations on BINARY keyword */
; 391  :         if (0
; 392  :             || !strcasecmp( argv[i], "binary" )
; 393  :             || !strcasecmp( argv[i], "bin"    )

  00c32	33 c0		 xor	 eax, eax
  00c34	85 c0		 test	 eax, eax
  00c36	75 44		 jne	 SHORT $LN54@parseComma
  00c38	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00c3d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169465
  00c44	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00c4c	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00c50	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00c56	85 c0		 test	 eax, eax
  00c58	74 22		 je	 SHORT $LN54@parseComma
  00c5a	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00c5f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169466
  00c66	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00c6e	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00c72	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00c78	85 c0		 test	 eax, eax
  00c7a	75 1a		 jne	 SHORT $LN53@parseComma
$LN54@parseComma:

; 394  :         )
; 395  :         {
; 396  :             mode = "rb";

  00c7c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169467
  00c83	48 89 05 00 00
	00 00		 mov	 QWORD PTR mode, rax

; 397  :             binary = true;

  00c8a	c6 05 00 00 00
	00 01		 mov	 BYTE PTR binary, 1

; 398  :             continue;

  00c91	e9 e4 f3 ff ff	 jmp	 $LN2@parseComma
$LN53@parseComma:

; 399  :         }
; 400  : 
; 401  :         /* looking for variations on NLTAPE keyword */
; 402  :         if (0
; 403  :             || !strcasecmp( argv[i], "nltape" )
; 404  :             || !strcasecmp( argv[i], "nl"     )
; 405  :             || !strcasecmp( argv[i], "n"      )

  00c96	33 c0		 xor	 eax, eax
  00c98	85 c0		 test	 eax, eax
  00c9a	75 66		 jne	 SHORT $LN56@parseComma
  00c9c	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00ca1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169470
  00ca8	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00cb0	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00cb4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00cba	85 c0		 test	 eax, eax
  00cbc	74 44		 je	 SHORT $LN56@parseComma
  00cbe	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00cc3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169471
  00cca	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00cd2	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00cd6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00cdc	85 c0		 test	 eax, eax
  00cde	74 22		 je	 SHORT $LN56@parseComma
  00ce0	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00ce5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169472
  00cec	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00cf4	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00cf8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00cfe	85 c0		 test	 eax, eax
  00d00	75 0c		 jne	 SHORT $LN55@parseComma
$LN56@parseComma:

; 406  :         )
; 407  :         {
; 408  :             nltape = true;

  00d02	c6 05 00 00 00
	00 01		 mov	 BYTE PTR nltape, 1

; 409  :             continue;

  00d09	e9 6c f3 ff ff	 jmp	 $LN2@parseComma
$LN55@parseComma:

; 410  :         }
; 411  : 
; 412  :         /* looking for variations on ANSI keyword */
; 413  :         if (0
; 414  :             || !strcasecmp( argv[i], "ansi" )
; 415  :             || !strcasecmp( argv[i], "a"    )

  00d0e	33 c0		 xor	 eax, eax
  00d10	85 c0		 test	 eax, eax
  00d12	75 44		 jne	 SHORT $LN58@parseComma
  00d14	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00d19	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169475
  00d20	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00d28	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00d2c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00d32	85 c0		 test	 eax, eax
  00d34	74 22		 je	 SHORT $LN58@parseComma
  00d36	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00d3b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169476
  00d42	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00d4a	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00d4e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00d54	85 c0		 test	 eax, eax
  00d56	75 0c		 jne	 SHORT $LN57@parseComma
$LN58@parseComma:

; 416  :         )
; 417  :         {
; 418  :             ansi = true;

  00d58	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ansi, 1

; 419  :             continue;

  00d5f	e9 16 f3 ff ff	 jmp	 $LN2@parseComma
$LN57@parseComma:

; 420  :         }
; 421  : 
; 422  :         // "unsupported parameter: %s"
; 423  :         FWRMSG( stderr, HHC02780, "E", argv[i] );

  00d64	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00d69	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv713[rsp], rax
  00d71	b9 02 00 00 00	 mov	 ecx, 2
  00d76	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00d7c	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00d84	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR tv713[rsp]
  00d8c	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  00d90	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00d95	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169477
  00d9c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00da1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169478
  00da8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00dad	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00db2	41 b9 03 00 00
	00		 mov	 r9d, 3
  00db8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169479
  00dbf	ba a7 01 00 00	 mov	 edx, 423		; 000001a7H
  00dc4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169480
  00dcb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 424  :         errors = true;

  00dd1	c6 44 24 64 01	 mov	 BYTE PTR errors$[rsp], 1

; 425  :         continue;

  00dd6	e9 9f f2 ff ff	 jmp	 $LN2@parseComma

; 426  : 
; 427  :     } /* for args */

  00ddb	e9 9a f2 ff ff	 jmp	 $LN2@parseComma
$LN3@parseComma:

; 428  : 
; 429  :     /* Validate required argument values... */
; 430  : 
; 431  :     /* initialize input file path table to null values */
; 432  :     for (inFileSeq = 0; inFileSeq < MAXFILES; inFileSeq++)

  00de0	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR inFileSeq, 0
  00dea	eb 0e		 jmp	 SHORT $LN7@parseComma
$LN5@parseComma:
  00dec	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR inFileSeq
  00df2	ff c0		 inc	 eax
  00df4	89 05 00 00 00
	00		 mov	 DWORD PTR inFileSeq, eax
$LN7@parseComma:
  00dfa	83 3d 00 00 00
	00 32		 cmp	 DWORD PTR inFileSeq, 50	; 00000032H
  00e01	7d 33		 jge	 SHORT $LN6@parseComma

; 433  :         STRLCPY( inFileID[ inFileSeq ], "" );

  00e03	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR inFileSeq
  00e0a	48 69 c0 05 01
	00 00		 imul	 rax, rax, 261		; 00000105H
  00e11	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:inFileID
  00e18	48 03 c8	 add	 rcx, rax
  00e1b	48 8b c1	 mov	 rax, rcx
  00e1e	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  00e24	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169481
  00e2b	48 8b c8	 mov	 rcx, rax
  00e2e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  00e34	eb b6		 jmp	 SHORT $LN5@parseComma
$LN6@parseComma:

; 434  : 
; 435  :     /* if single input file specified */
; 436  :     if (strncasecmp( pInFileID, "@", 1 ) != 0)

  00e36	41 b8 01 00 00
	00		 mov	 r8d, 1
  00e3c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169484
  00e43	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pInFileID
  00e4a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00e50	85 c0		 test	 eax, eax
  00e52	0f 84 fb 00 00
	00		 je	 $LN59@parseComma

; 437  :     {
; 438  :         if (!(inData = fopen( pInFileID, "r" )))

  00e58	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169487
  00e5f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pInFileID
  00e66	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  00e6c	48 89 05 00 00
	00 00		 mov	 QWORD PTR inData, rax
  00e73	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR inData, 0
  00e7b	0f 85 89 00 00
	00		 jne	 $LN61@parseComma

; 439  :         {
; 440  :             // "Error opening %s file '%s': %s"
; 441  :             FWRMSG( stderr, HHC02772, "E", "input", pInFileID, strerror( errno ));

  00e81	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00e87	8b 08		 mov	 ecx, DWORD PTR [rax]
  00e89	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00e8f	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv743[rsp], rax
  00e97	b9 02 00 00 00	 mov	 ecx, 2
  00e9c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00ea2	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv743[rsp]
  00eaa	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00eaf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pInFileID
  00eb6	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00ebb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169488
  00ec2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00ec7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169489
  00ece	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00ed3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169490
  00eda	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00edf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ee4	41 b9 03 00 00
	00		 mov	 r9d, 3
  00eea	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169491
  00ef1	ba b9 01 00 00	 mov	 edx, 441		; 000001b9H
  00ef6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169492
  00efd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 442  :             errors = true;

  00f03	c6 44 24 64 01	 mov	 BYTE PTR errors$[rsp], 1

; 443  :         }

  00f08	eb 44		 jmp	 SHORT $LN62@parseComma
$LN61@parseComma:

; 444  :         else
; 445  :         {
; 446  :             fclose( inData );

  00f0a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR inData
  00f11	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose

; 447  :             inData = NULL;

  00f17	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR inData, 0

; 448  :             STRLCPY( inFileID[0], pInFileID );

  00f22	b8 05 01 00 00	 mov	 eax, 261		; 00000105H
  00f27	48 6b c0 00	 imul	 rax, rax, 0
  00f2b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:inFileID
  00f32	48 03 c8	 add	 rcx, rax
  00f35	48 8b c1	 mov	 rax, rcx
  00f38	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  00f3e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR pInFileID
  00f45	48 8b c8	 mov	 rcx, rax
  00f48	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN62@parseComma:

; 449  :         }
; 450  :     }

  00f4e	e9 05 03 00 00	 jmp	 $LN60@parseComma
$LN59@parseComma:

; 451  :     else /* specified file is a @meta file */
; 452  :     {
; 453  :         if (!(inMeta = fopen( pInFileID + 1, "r" )))

  00f53	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pInFileID
  00f5a	48 ff c0	 inc	 rax
  00f5d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169495
  00f64	48 8b c8	 mov	 rcx, rax
  00f67	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  00f6d	48 89 05 00 00
	00 00		 mov	 QWORD PTR inMeta, rax
  00f74	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR inMeta, 0
  00f7c	0f 85 8c 00 00
	00		 jne	 $LN63@parseComma

; 454  :         {
; 455  :             // "Error opening %s file '%s': %s"
; 456  :             FWRMSG( stderr, HHC02772, "E", "input (meta)", pInFileID, strerror( errno ));

  00f82	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00f88	8b 08		 mov	 ecx, DWORD PTR [rax]
  00f8a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00f90	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv769[rsp], rax
  00f98	b9 02 00 00 00	 mov	 ecx, 2
  00f9d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00fa3	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv769[rsp]
  00fab	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00fb0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pInFileID
  00fb7	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00fbc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169496
  00fc3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00fc8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169497
  00fcf	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00fd4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169498
  00fdb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00fe0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00fe5	41 b9 03 00 00
	00		 mov	 r9d, 3
  00feb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169499
  00ff2	ba c8 01 00 00	 mov	 edx, 456		; 000001c8H
  00ff7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169500
  00ffe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 457  :             errors = true;

  01004	c6 44 24 64 01	 mov	 BYTE PTR errors$[rsp], 1

; 458  :         }

  01009	e9 4a 02 00 00	 jmp	 $LN64@parseComma
$LN63@parseComma:

; 459  :         else
; 460  :         {
; 461  :             int k;
; 462  :             i = 0;

  0100e	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 463  :             inFileSeq = 0;

  01016	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR inFileSeq, 0
$LN8@parseComma:

; 464  : 
; 465  :             /* read meta file, validate file names and copy to table */
; 466  :             while (1)

  01020	33 c0		 xor	 eax, eax
  01022	83 f8 01	 cmp	 eax, 1
  01025	0f 84 15 02 00
	00		 je	 $LN9@parseComma

; 467  :             {
; 468  :                 i++;

  0102b	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0102f	ff c0		 inc	 eax
  01031	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax

; 469  : 
; 470  :                 /* exit while when EOF reached on META file */
; 471  :                 if (!fgets( buf, FILENAME_MAX, inMeta ))

  01035	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR inMeta
  0103c	ba 04 01 00 00	 mov	 edx, 260		; 00000104H
  01041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  01048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgets
  0104e	48 85 c0	 test	 rax, rax
  01051	75 05		 jne	 SHORT $LN65@parseComma

; 472  :                     break;

  01053	e9 e8 01 00 00	 jmp	 $LN9@parseComma
$LN65@parseComma:

; 473  : 
; 474  :                 /* replace newline character if present */
; 475  :                 k = (int) strlen( buf );

  01058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  0105f	e8 00 00 00 00	 call	 strlen
  01064	89 44 24 68	 mov	 DWORD PTR k$3[rsp], eax

; 476  :                 if (k >= 1 && buf[k-1] == '\n')

  01068	83 7c 24 68 01	 cmp	 DWORD PTR k$3[rsp], 1
  0106d	7c 50		 jl	 SHORT $LN66@parseComma
  0106f	8b 44 24 68	 mov	 eax, DWORD PTR k$3[rsp]
  01073	ff c8		 dec	 eax
  01075	48 98		 cdqe
  01077	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  0107e	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  01082	83 f8 0a	 cmp	 eax, 10
  01085	75 38		 jne	 SHORT $LN66@parseComma

; 477  :                     buf[k-1] = 0;

  01087	8b 44 24 68	 mov	 eax, DWORD PTR k$3[rsp]
  0108b	ff c8		 dec	 eax
  0108d	48 98		 cdqe
  0108f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR $T6[rsp], rax
  01097	48 81 bc 24 88
	00 00 00 ff ff
	00 00		 cmp	 QWORD PTR $T6[rsp], 65535 ; 0000ffffH
  010a3	73 02		 jae	 SHORT $LN102@parseComma
  010a5	eb 05		 jmp	 SHORT $LN103@parseComma
$LN102@parseComma:
  010a7	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN103@parseComma:
  010ac	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:buf
  010b3	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR $T6[rsp]
  010bb	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
$LN66@parseComma:

; 478  : 
; 479  :                 if (!(inData = fopen( buf, "r" )))

  010bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169505
  010c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  010cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  010d3	48 89 05 00 00
	00 00		 mov	 QWORD PTR inData, rax
  010da	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR inData, 0
  010e2	0f 85 94 00 00
	00		 jne	 $LN67@parseComma

; 480  :                 {
; 481  :                     // "Error opening %s file %i '%s': %s"
; 482  :                     FWRMSG( stderr, HHC02773, "E", "included input", i, buf, strerror( errno ));

  010e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  010ee	8b 08		 mov	 ecx, DWORD PTR [rax]
  010f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  010f6	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv809[rsp], rax
  010fe	b9 02 00 00 00	 mov	 ecx, 2
  01103	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01109	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv809[rsp]
  01111	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01116	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf
  0111d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01122	8b 4c 24 60	 mov	 ecx, DWORD PTR i$[rsp]
  01126	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0112a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169506
  01131	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01136	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169507
  0113d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01142	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169508
  01149	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0114e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01153	41 b9 03 00 00
	00		 mov	 r9d, 3
  01159	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169509
  01160	ba e2 01 00 00	 mov	 edx, 482		; 000001e2H
  01165	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169510
  0116c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 483  :                     errors = true;

  01172	c6 44 24 64 01	 mov	 BYTE PTR errors$[rsp], 1

; 484  :                 }

  01177	e9 bf 00 00 00	 jmp	 $LN68@parseComma
$LN67@parseComma:

; 485  :                 else
; 486  :                 {
; 487  :                     fclose( inData );

  0117c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR inData
  01183	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose

; 488  :                     inData = NULL;

  01189	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR inData, 0

; 489  : 
; 490  :                     if (inFileSeq >= MAXFILES)

  01194	83 3d 00 00 00
	00 32		 cmp	 DWORD PTR inFileSeq, 50	; 00000032H
  0119b	7c 5f		 jl	 SHORT $LN69@parseComma

; 491  :                     {
; 492  :                         // "number of files in %s exceeds %d; excess ignored"
; 493  :                         FWRMSG( stderr, HHC02774, "W", pInFileID, MAXFILES );

  0119d	b9 02 00 00 00	 mov	 ecx, 2
  011a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  011a8	c7 44 24 40 32
	00 00 00	 mov	 DWORD PTR [rsp+64], 50	; 00000032H
  011b0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pInFileID
  011b7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  011bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169513
  011c3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  011c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169514
  011cf	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  011d4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  011d9	41 b9 03 00 00
	00		 mov	 r9d, 3
  011df	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169515
  011e6	ba ed 01 00 00	 mov	 edx, 493		; 000001edH
  011eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169516
  011f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 494  :                         break;

  011f8	eb 46		 jmp	 SHORT $LN9@parseComma

; 495  :                     }

  011fa	eb 3f		 jmp	 SHORT $LN70@parseComma
$LN69@parseComma:

; 496  :                     else
; 497  :                     {
; 498  :                         STRLCPY( inFileID[ inFileSeq ], buf );

  011fc	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR inFileSeq
  01203	48 69 c0 05 01
	00 00		 imul	 rax, rax, 261		; 00000105H
  0120a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:inFileID
  01211	48 03 c8	 add	 rcx, rax
  01214	48 8b c1	 mov	 rax, rcx
  01217	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  0121d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:buf
  01224	48 8b c8	 mov	 rcx, rax
  01227	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 499  :                         inFileSeq++;

  0122d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR inFileSeq
  01233	ff c0		 inc	 eax
  01235	89 05 00 00 00
	00		 mov	 DWORD PTR inFileSeq, eax
$LN70@parseComma:
$LN68@parseComma:

; 500  :                     }
; 501  :                 }
; 502  :             } /* while (reading through meta file) */

  0123b	e9 e0 fd ff ff	 jmp	 $LN8@parseComma
$LN9@parseComma:

; 503  : 
; 504  :             fclose( inMeta );

  01240	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR inMeta
  01247	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose

; 505  :             inMeta = NULL;

  0124d	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR inMeta, 0
$LN64@parseComma:
$LN60@parseComma:

; 506  : 
; 507  :         } /* else (meta file open succeeded) */
; 508  :     } /* else (is a meta file) */
; 509  : 
; 510  :     if (!strlen( inFileID[0] ))

  01258	b8 05 01 00 00	 mov	 eax, 261		; 00000105H
  0125d	48 6b c0 00	 imul	 rax, rax, 0
  01261	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:inFileID
  01268	48 03 c8	 add	 rcx, rax
  0126b	48 8b c1	 mov	 rax, rcx
  0126e	48 8b c8	 mov	 rcx, rax
  01271	e8 00 00 00 00	 call	 strlen
  01276	48 85 c0	 test	 rax, rax
  01279	75 58		 jne	 SHORT $LN71@parseComma

; 511  :     {
; 512  :         // "required %s omitted or not found"
; 513  :         FWRMSG( stderr, HHC02775, "E", "INPUT: <input file name>" );

  0127b	b9 02 00 00 00	 mov	 ecx, 2
  01280	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01286	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169518
  0128d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01292	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169519
  01299	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0129e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169520
  012a5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  012aa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  012af	41 b9 03 00 00
	00		 mov	 r9d, 3
  012b5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169521
  012bc	ba 01 02 00 00	 mov	 edx, 513		; 00000201H
  012c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169522
  012c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 514  :         errors = true;

  012ce	c6 44 24 64 01	 mov	 BYTE PTR errors$[rsp], 1
$LN71@parseComma:

; 515  :     }
; 516  : 
; 517  :     if (!outFileID)

  012d3	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR outFileID, 0
  012db	75 58		 jne	 SHORT $LN72@parseComma

; 518  :     {
; 519  :         // "required %s omitted or not found"
; 520  :         FWRMSG( stderr, HHC02775, "E", "OUTPUT: <output file name>" );

  012dd	b9 02 00 00 00	 mov	 ecx, 2
  012e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  012e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169524
  012ef	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  012f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169525
  012fb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01300	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169526
  01307	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0130c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01311	41 b9 03 00 00
	00		 mov	 r9d, 3
  01317	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169527
  0131e	ba 08 02 00 00	 mov	 edx, 520		; 00000208H
  01323	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169528
  0132a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 521  :         errors = true;

  01330	c6 44 24 64 01	 mov	 BYTE PTR errors$[rsp], 1
$LN72@parseComma:

; 522  :     }
; 523  : 
; 524  :     if (!nltape && !pVolSer)

  01335	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR nltape
  0133c	85 c0		 test	 eax, eax
  0133e	75 67		 jne	 SHORT $LN73@parseComma
  01340	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR pVolSer, 0
  01348	75 5d		 jne	 SHORT $LN73@parseComma

; 525  :     {
; 526  :         // "required %s omitted or not found"
; 527  :         FWRMSG( stderr, HHC02775, "E", "VOLSER: <volume serial number>" );

  0134a	b9 02 00 00 00	 mov	 ecx, 2
  0134f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01355	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169531
  0135c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01361	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169532
  01368	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0136d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169533
  01374	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01379	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0137e	41 b9 03 00 00
	00		 mov	 r9d, 3
  01384	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169534
  0138b	ba 0f 02 00 00	 mov	 edx, 527		; 0000020fH
  01390	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169535
  01397	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 528  :         errors = true;

  0139d	c6 44 24 64 01	 mov	 BYTE PTR errors$[rsp], 1

; 529  :     }

  013a2	e9 68 01 00 00	 jmp	 $LN74@parseComma
$LN73@parseComma:

; 530  :     else if (!nltape)

  013a7	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR nltape
  013ae	85 c0		 test	 eax, eax
  013b0	0f 85 f1 00 00
	00		 jne	 $LN75@parseComma

; 531  :     {
; 532  :         if (!valid_volser( pVolSer ))

  013b6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pVolSer
  013bd	e8 00 00 00 00	 call	 valid_volser
  013c2	0f b6 c0	 movzx	 eax, al
  013c5	85 c0		 test	 eax, eax
  013c7	75 66		 jne	 SHORT $LN77@parseComma

; 533  :         {
; 534  :             // "invalid %s parameter: %s"
; 535  :             FWRMSG( stderr, HHC02781, "E", "VOLSER", pVolSer );

  013c9	b9 02 00 00 00	 mov	 ecx, 2
  013ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  013d4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pVolSer
  013db	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  013e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169540
  013e7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  013ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169541
  013f3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  013f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169542
  013ff	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01404	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01409	41 b9 03 00 00
	00		 mov	 r9d, 3
  0140f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169543
  01416	ba 17 02 00 00	 mov	 edx, 535		; 00000217H
  0141b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169544
  01422	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 536  :             errors = true;

  01428	c6 44 24 64 01	 mov	 BYTE PTR errors$[rsp], 1

; 537  :         }

  0142d	eb 76		 jmp	 SHORT $LN78@parseComma
$LN77@parseComma:

; 538  :         else // (save and blank pad)
; 539  :         {
; 540  :             for (i=0; i < 6 && pVolSer[i]; i++)

  0142f	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  01437	eb 0a		 jmp	 SHORT $LN12@parseComma
$LN10@parseComma:
  01439	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0143d	ff c0		 inc	 eax
  0143f	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN12@parseComma:
  01443	83 7c 24 60 06	 cmp	 DWORD PTR i$[rsp], 6
  01448	7d 36		 jge	 SHORT $LN11@parseComma
  0144a	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0144f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pVolSer
  01456	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0145a	85 c0		 test	 eax, eax
  0145c	74 22		 je	 SHORT $LN11@parseComma

; 541  :                 volSer[i] = pVolSer[i];

  0145e	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  01463	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$[rsp]
  01468	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:volSer
  0146f	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR pVolSer
  01476	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0147b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0147e	eb b9		 jmp	 SHORT $LN10@parseComma
$LN11@parseComma:

; 542  :             for (; i < 6; i++)

  01480	eb 0a		 jmp	 SHORT $LN15@parseComma
$LN13@parseComma:
  01482	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  01486	ff c0		 inc	 eax
  01488	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN15@parseComma:
  0148c	83 7c 24 60 06	 cmp	 DWORD PTR i$[rsp], 6
  01491	7d 12		 jge	 SHORT $LN14@parseComma

; 543  :                 volSer[i] = ' ';

  01493	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  01498	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:volSer
  0149f	c6 04 01 20	 mov	 BYTE PTR [rcx+rax], 32	; 00000020H
  014a3	eb dd		 jmp	 SHORT $LN13@parseComma
$LN14@parseComma:
$LN78@parseComma:

; 544  :         }
; 545  :     }

  014a5	eb 68		 jmp	 SHORT $LN76@parseComma
$LN75@parseComma:

; 546  :     else if (nltape && pVolSer)

  014a7	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR nltape
  014ae	85 c0		 test	 eax, eax
  014b0	74 5d		 je	 SHORT $LN79@parseComma
  014b2	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR pVolSer, 0
  014ba	74 53		 je	 SHORT $LN79@parseComma

; 547  :     {
; 548  :         // "Parameter %s ignored due to NLTAPE option"
; 549  :         FWRMSG( stderr, HHC02783, "W", "VOLSER" );

  014bc	b9 02 00 00 00	 mov	 ecx, 2
  014c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  014c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169546
  014ce	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  014d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169547
  014da	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  014df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169548
  014e6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  014eb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  014f0	41 b9 03 00 00
	00		 mov	 r9d, 3
  014f6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169549
  014fd	ba 25 02 00 00	 mov	 edx, 549		; 00000225H
  01502	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169550
  01509	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN79@parseComma:
$LN76@parseComma:
$LN74@parseComma:

; 550  :     }
; 551  : 
; 552  :     if (!nltape && !datasetName)

  0150f	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR nltape
  01516	85 c0		 test	 eax, eax
  01518	75 67		 jne	 SHORT $LN80@parseComma
  0151a	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR datasetName, 0
  01522	75 5d		 jne	 SHORT $LN80@parseComma

; 553  :     {
; 554  :         // "required %s omitted or not found"
; 555  :         FWRMSG( stderr, HHC02775, "E", "DATASET: <dataset name>" );

  01524	b9 02 00 00 00	 mov	 ecx, 2
  01529	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0152f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169553
  01536	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0153b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169554
  01542	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01547	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169555
  0154e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01553	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01558	41 b9 03 00 00
	00		 mov	 r9d, 3
  0155e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169556
  01565	ba 2b 02 00 00	 mov	 edx, 555		; 0000022bH
  0156a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169557
  01571	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 556  :         errors = true;

  01577	c6 44 24 64 01	 mov	 BYTE PTR errors$[rsp], 1

; 557  :     }

  0157c	e9 ec 00 00 00	 jmp	 $LN81@parseComma
$LN80@parseComma:

; 558  :     else if (!nltape)

  01581	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR nltape
  01588	85 c0		 test	 eax, eax
  0158a	75 79		 jne	 SHORT $LN82@parseComma

; 559  :     {
; 560  :         if (!valid_dataset( datasetName ))

  0158c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR datasetName
  01593	e8 00 00 00 00	 call	 valid_dataset
  01598	0f b6 c0	 movzx	 eax, al
  0159b	85 c0		 test	 eax, eax
  0159d	75 64		 jne	 SHORT $LN84@parseComma

; 561  :         {
; 562  :             // "invalid %s parameter: %s"
; 563  :             FWRMSG( stderr, HHC02781, "E", "DATASET", datasetName );

  0159f	b9 02 00 00 00	 mov	 ecx, 2
  015a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  015aa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR datasetName
  015b1	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  015b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169561
  015bd	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  015c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169562
  015c9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  015ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169563
  015d5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  015da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  015df	41 b9 03 00 00
	00		 mov	 r9d, 3
  015e5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169564
  015ec	ba 33 02 00 00	 mov	 edx, 563		; 00000233H
  015f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169565
  015f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 564  :             errors = true;

  015fe	c6 44 24 64 01	 mov	 BYTE PTR errors$[rsp], 1
$LN84@parseComma:

; 565  :         }
; 566  :     }

  01603	eb 68		 jmp	 SHORT $LN83@parseComma
$LN82@parseComma:

; 567  :     else if (nltape && datasetName)

  01605	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR nltape
  0160c	85 c0		 test	 eax, eax
  0160e	74 5d		 je	 SHORT $LN85@parseComma
  01610	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR datasetName, 0
  01618	74 53		 je	 SHORT $LN85@parseComma

; 568  :     {
; 569  :         // "Parameter %s ignored due to NLTAPE option"
; 570  :         FWRMSG( stderr, HHC02783, "W", "DATASET" );

  0161a	b9 02 00 00 00	 mov	 ecx, 2
  0161f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01625	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169567
  0162c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01631	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169568
  01638	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0163d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169569
  01644	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01649	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0164e	41 b9 03 00 00
	00		 mov	 r9d, 3
  01654	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169570
  0165b	ba 3a 02 00 00	 mov	 edx, 570		; 0000023aH
  01660	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169571
  01667	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN85@parseComma:
$LN83@parseComma:
$LN81@parseComma:

; 571  :     }
; 572  : 
; 573  :     /* Validate optional argument values... */
; 574  : 
; 575  :     if (nltape && ansi)

  0166d	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR nltape
  01674	85 c0		 test	 eax, eax
  01676	74 5e		 je	 SHORT $LN86@parseComma
  01678	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ansi
  0167f	85 c0		 test	 eax, eax
  01681	74 53		 je	 SHORT $LN86@parseComma

; 576  :     {
; 577  :         // "Parameter %s ignored due to NLTAPE option"
; 578  :         FWRMSG( stderr, HHC02783, "W", "ANSI" );

  01683	b9 02 00 00 00	 mov	 ecx, 2
  01688	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0168e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169573
  01695	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0169a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169574
  016a1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  016a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169575
  016ad	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  016b2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  016b7	41 b9 03 00 00
	00		 mov	 r9d, 3
  016bd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169576
  016c4	ba 42 02 00 00	 mov	 edx, 578		; 00000242H
  016c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169577
  016d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN86@parseComma:

; 579  :     }
; 580  : 
; 581  :     if (pLRECL)

  016d6	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR pLRECL, 0
  016de	0f 84 32 01 00
	00		 je	 $LN87@parseComma

; 582  :     {
; 583  :         bool valid = true; int k = (int) strlen( pLRECL );

  016e4	c6 44 24 65 01	 mov	 BYTE PTR valid$1[rsp], 1
  016e9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pLRECL
  016f0	e8 00 00 00 00	 call	 strlen
  016f5	89 44 24 7c	 mov	 DWORD PTR k$4[rsp], eax

; 584  :         for (i=0; i < k; i++)

  016f9	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  01701	eb 0a		 jmp	 SHORT $LN18@parseComma
$LN16@parseComma:
  01703	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  01707	ff c0		 inc	 eax
  01709	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN18@parseComma:
  0170d	8b 44 24 7c	 mov	 eax, DWORD PTR k$4[rsp]
  01711	39 44 24 60	 cmp	 DWORD PTR i$[rsp], eax
  01715	7d 26		 jge	 SHORT $LN17@parseComma

; 585  :             if (!(valid = valid_numeric( pLRECL[i] )))

  01717	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0171c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pLRECL
  01723	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  01727	e8 00 00 00 00	 call	 valid_numeric
  0172c	88 44 24 65	 mov	 BYTE PTR valid$1[rsp], al
  01730	0f b6 44 24 65	 movzx	 eax, BYTE PTR valid$1[rsp]
  01735	85 c0		 test	 eax, eax
  01737	75 02		 jne	 SHORT $LN88@parseComma

; 586  :                 break;

  01739	eb 02		 jmp	 SHORT $LN17@parseComma
$LN88@parseComma:
  0173b	eb c6		 jmp	 SHORT $LN16@parseComma
$LN17@parseComma:

; 587  :         if (valid)

  0173d	0f b6 44 24 65	 movzx	 eax, BYTE PTR valid$1[rsp]
  01742	85 c0		 test	 eax, eax
  01744	74 63		 je	 SHORT $LN89@parseComma

; 588  :         {
; 589  :             // 18 is the minimum tape blocksize.
; 590  :             // anything less is considered noise.
; 591  :             sscanf( pLRECL, "%5u", &lrecl );

  01746	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:lrecl
  0174d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169581
  01754	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pLRECL
  0175b	e8 00 00 00 00	 call	 sscanf

; 592  :             valid = (lrecl >= 18 && lrecl <= MAXLRECL);

  01760	83 3d 00 00 00
	00 12		 cmp	 DWORD PTR lrecl, 18
  01767	7c 16		 jl	 SHORT $LN104@parseComma
  01769	81 3d 00 00 00
	00 ff 7f 00 00	 cmp	 DWORD PTR lrecl, 32767	; 00007fffH
  01773	7f 0a		 jg	 SHORT $LN104@parseComma
  01775	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv1074[rsp], 1
  0177d	eb 08		 jmp	 SHORT $LN105@parseComma
$LN104@parseComma:
  0177f	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv1074[rsp], 0
$LN105@parseComma:
  01787	83 7c 24 6c 00	 cmp	 DWORD PTR tv1074[rsp], 0
  0178c	75 0a		 jne	 SHORT $LN106@parseComma
  0178e	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv1076[rsp], 0
  01796	eb 08		 jmp	 SHORT $LN107@parseComma
$LN106@parseComma:
  01798	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv1076[rsp], 1
$LN107@parseComma:
  017a0	0f b6 44 24 70	 movzx	 eax, BYTE PTR tv1076[rsp]
  017a5	88 44 24 65	 mov	 BYTE PTR valid$1[rsp], al
$LN89@parseComma:

; 593  :         }
; 594  :         if (!valid)

  017a9	0f b6 44 24 65	 movzx	 eax, BYTE PTR valid$1[rsp]
  017ae	85 c0		 test	 eax, eax
  017b0	75 64		 jne	 SHORT $LN90@parseComma

; 595  :         {
; 596  :             // "invalid %s parameter: %s"
; 597  :             FWRMSG( stderr, HHC02781, "E", "LRECL", pLRECL );

  017b2	b9 02 00 00 00	 mov	 ecx, 2
  017b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  017bd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pLRECL
  017c4	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  017c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169583
  017d0	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  017d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169584
  017dc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  017e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169585
  017e8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  017ed	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  017f2	41 b9 03 00 00
	00		 mov	 r9d, 3
  017f8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169586
  017ff	ba 55 02 00 00	 mov	 edx, 597		; 00000255H
  01804	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169587
  0180b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 598  :             errors = true;

  01811	c6 44 24 64 01	 mov	 BYTE PTR errors$[rsp], 1
$LN90@parseComma:
$LN87@parseComma:

; 599  :         }
; 600  :     }
; 601  : 
; 602  :     if (pBLOCK)

  01816	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR pBLOCK, 0
  0181e	0f 84 38 01 00
	00		 je	 $LN91@parseComma

; 603  :     {
; 604  :         bool valid = true; int k = (int) strlen( pBLOCK );

  01824	c6 44 24 66 01	 mov	 BYTE PTR valid$2[rsp], 1
  01829	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pBLOCK
  01830	e8 00 00 00 00	 call	 strlen
  01835	89 84 24 80 00
	00 00		 mov	 DWORD PTR k$5[rsp], eax

; 605  :         for (i=0; i < k; i++)

  0183c	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  01844	eb 0a		 jmp	 SHORT $LN21@parseComma
$LN19@parseComma:
  01846	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0184a	ff c0		 inc	 eax
  0184c	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN21@parseComma:
  01850	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR k$5[rsp]
  01857	39 44 24 60	 cmp	 DWORD PTR i$[rsp], eax
  0185b	7d 26		 jge	 SHORT $LN20@parseComma

; 606  :             if (!(valid = valid_numeric( pBLOCK[i] )))

  0185d	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  01862	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pBLOCK
  01869	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  0186d	e8 00 00 00 00	 call	 valid_numeric
  01872	88 44 24 66	 mov	 BYTE PTR valid$2[rsp], al
  01876	0f b6 44 24 66	 movzx	 eax, BYTE PTR valid$2[rsp]
  0187b	85 c0		 test	 eax, eax
  0187d	75 02		 jne	 SHORT $LN92@parseComma

; 607  :                 break;

  0187f	eb 02		 jmp	 SHORT $LN20@parseComma
$LN92@parseComma:
  01881	eb c3		 jmp	 SHORT $LN19@parseComma
$LN20@parseComma:

; 608  :         if (valid)

  01883	0f b6 44 24 66	 movzx	 eax, BYTE PTR valid$2[rsp]
  01888	85 c0		 test	 eax, eax
  0188a	74 63		 je	 SHORT $LN93@parseComma

; 609  :         {
; 610  :             sscanf( pBLOCK, "%5u", &blkfactor );

  0188c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:blkfactor
  01893	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169591
  0189a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pBLOCK
  018a1	e8 00 00 00 00	 call	 sscanf

; 611  :             valid = (blkfactor >= 1 && blkfactor <= MAXLRECL);

  018a6	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR blkfactor, 1
  018ad	7c 16		 jl	 SHORT $LN108@parseComma
  018af	81 3d 00 00 00
	00 ff 7f 00 00	 cmp	 DWORD PTR blkfactor, 32767 ; 00007fffH
  018b9	7f 0a		 jg	 SHORT $LN108@parseComma
  018bb	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv1111[rsp], 1
  018c3	eb 08		 jmp	 SHORT $LN109@parseComma
$LN108@parseComma:
  018c5	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv1111[rsp], 0
$LN109@parseComma:
  018cd	83 7c 24 74 00	 cmp	 DWORD PTR tv1111[rsp], 0
  018d2	75 0a		 jne	 SHORT $LN110@parseComma
  018d4	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv1113[rsp], 0
  018dc	eb 08		 jmp	 SHORT $LN111@parseComma
$LN110@parseComma:
  018de	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv1113[rsp], 1
$LN111@parseComma:
  018e6	0f b6 44 24 78	 movzx	 eax, BYTE PTR tv1113[rsp]
  018eb	88 44 24 66	 mov	 BYTE PTR valid$2[rsp], al
$LN93@parseComma:

; 612  :         }
; 613  :         if (!valid)

  018ef	0f b6 44 24 66	 movzx	 eax, BYTE PTR valid$2[rsp]
  018f4	85 c0		 test	 eax, eax
  018f6	75 64		 jne	 SHORT $LN94@parseComma

; 614  :         {
; 615  :             // "invalid %s parameter: %s"
; 616  :             FWRMSG( stderr, HHC02781, "E", "BLOCK", pBLOCK );

  018f8	b9 02 00 00 00	 mov	 ecx, 2
  018fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01903	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pBLOCK
  0190a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0190f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169593
  01916	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0191b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169594
  01922	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01927	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169595
  0192e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01933	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01938	41 b9 03 00 00
	00		 mov	 r9d, 3
  0193e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169596
  01945	ba 68 02 00 00	 mov	 edx, 616		; 00000268H
  0194a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169597
  01951	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 617  :             errors = true;

  01957	c6 44 24 64 01	 mov	 BYTE PTR errors$[rsp], 1
$LN94@parseComma:
$LN91@parseComma:

; 618  :         }
; 619  :     }
; 620  : 
; 621  :     if (pCODEPAGE)

  0195c	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR pCODEPAGE, 0
  01964	0f 84 89 00 00
	00		 je	 $LN95@parseComma

; 622  :     {
; 623  :         if (!valid_codepage_name( pCODEPAGE ))

  0196a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pCODEPAGE
  01971	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_valid_codepage_name
  01977	0f b6 c0	 movzx	 eax, al
  0197a	85 c0		 test	 eax, eax
  0197c	75 66		 jne	 SHORT $LN97@parseComma

; 624  :         {
; 625  :             // "invalid %s parameter: %s"
; 626  :             FWRMSG( stderr, HHC02781, "E", "CODEPAGE", pCODEPAGE );

  0197e	b9 02 00 00 00	 mov	 ecx, 2
  01983	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01989	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pCODEPAGE
  01990	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01995	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169602
  0199c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  019a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169603
  019a8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  019ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169604
  019b4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  019b9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  019be	41 b9 03 00 00
	00		 mov	 r9d, 3
  019c4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169605
  019cb	ba 72 02 00 00	 mov	 edx, 626		; 00000272H
  019d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169606
  019d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 627  :             errors = true;

  019dd	c6 44 24 64 01	 mov	 BYTE PTR errors$[rsp], 1

; 628  :         }

  019e2	eb 0d		 jmp	 SHORT $LN98@parseComma
$LN97@parseComma:

; 629  :         else
; 630  :             set_codepage( pCODEPAGE );

  019e4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pCODEPAGE
  019eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_codepage
$LN98@parseComma:

; 631  :     }

  019f1	eb 08		 jmp	 SHORT $LN96@parseComma
$LN95@parseComma:

; 632  :     else
; 633  :         set_codepage( NULL );

  019f3	33 c9		 xor	 ecx, ecx
  019f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_codepage
$LN96@parseComma:

; 634  : 
; 635  :     /* Verify lrecl * blocking factor doesn't exceed maximum block size */
; 636  : 
; 637  :     if (((U64)lrecl * blkfactor) > (U64)MAXAWSBUFF)

  019fb	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR lrecl
  01a02	48 63 0d 00 00
	00 00		 movsxd	 rcx, DWORD PTR blkfactor
  01a09	48 0f af c1	 imul	 rax, rcx
  01a0d	48 3d ff ff 00
	00		 cmp	 rax, 65535		; 0000ffffH
  01a13	76 68		 jbe	 SHORT $LN99@parseComma

; 638  :     {
; 639  :         // "LRECL %i and BLOCK %i exceeds maximum AWS blocksize of %i"
; 640  :         FWRMSG( stderr, HHC02782, "E", lrecl, blkfactor, MAXAWSBUFF );

  01a15	b9 02 00 00 00	 mov	 ecx, 2
  01a1a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01a20	c7 44 24 48 ff
	ff 00 00	 mov	 DWORD PTR [rsp+72], 65535 ; 0000ffffH
  01a28	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR blkfactor
  01a2e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01a32	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR lrecl
  01a38	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01a3c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169608
  01a43	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01a48	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169609
  01a4f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01a54	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01a59	41 b9 03 00 00
	00		 mov	 r9d, 3
  01a5f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169610
  01a66	ba 80 02 00 00	 mov	 edx, 640		; 00000280H
  01a6b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169611
  01a72	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 641  :         errors = true;

  01a78	c6 44 24 64 01	 mov	 BYTE PTR errors$[rsp], 1
$LN99@parseComma:

; 642  :     }
; 643  : 
; 644  :     if (errors)

  01a7d	0f b6 44 24 64	 movzx	 eax, BYTE PTR errors$[rsp]
  01a82	85 c0		 test	 eax, eax
  01a84	74 0a		 je	 SHORT $LN100@parseComma

; 645  :         ErrExit( RC_ARG_ERRS );

  01a86	b9 02 00 00 00	 mov	 ecx, 2
  01a8b	e8 00 00 00 00	 call	 ErrExit
$LN100@parseComma:
$LN101@parseComma:

; 646  : 
; 647  : } /* parseCommand */

  01a90	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  01a97	c3		 ret	 0
parseCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\maketape.c
_TEXT	SEGMENT
k$ = 32
segment$ = 40
dsn$ = 48
__$ArrayPad$ = 72
dataset$ = 96
valid_dataset PROC

; 197  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 198  :     char dsn[ MAXTAPEDSNLEN + 1 ]; char* segment;
; 199  :     int k = (int) strlen( dataset );

  00018	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dataset$[rsp]
  0001d	e8 00 00 00 00	 call	 strlen
  00022	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 200  :     if (k < 1 || k > MAXTAPEDSNLEN)

  00026	83 7c 24 20 01	 cmp	 DWORD PTR k$[rsp], 1
  0002b	7c 07		 jl	 SHORT $LN5@valid_data
  0002d	83 7c 24 20 11	 cmp	 DWORD PTR k$[rsp], 17
  00032	7e 04		 jle	 SHORT $LN4@valid_data
$LN5@valid_data:

; 201  :         return false;

  00034	32 c0		 xor	 al, al
  00036	eb 62		 jmp	 SHORT $LN1@valid_data
$LN4@valid_data:

; 202  :     STRLCPY( dsn, dataset );

  00038	41 b8 12 00 00
	00		 mov	 r8d, 18
  0003e	48 8b 54 24 60	 mov	 rdx, QWORD PTR dataset$[rsp]
  00043	48 8d 4c 24 30	 lea	 rcx, QWORD PTR dsn$[rsp]
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 203  :     segment = strtok( dsn, "." );

  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169303
  00055	48 8d 4c 24 30	 lea	 rcx, QWORD PTR dsn$[rsp]
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok
  00060	48 89 44 24 28	 mov	 QWORD PTR segment$[rsp], rax
$LN2@valid_data:

; 204  :     while (segment)

  00065	48 83 7c 24 28
	00		 cmp	 QWORD PTR segment$[rsp], 0
  0006b	74 2b		 je	 SHORT $LN3@valid_data

; 205  :     {
; 206  :         if (!valid_dsn_segment( segment ))

  0006d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR segment$[rsp]
  00072	e8 00 00 00 00	 call	 valid_dsn_segment
  00077	0f b6 c0	 movzx	 eax, al
  0007a	85 c0		 test	 eax, eax
  0007c	75 04		 jne	 SHORT $LN6@valid_data

; 207  :             return false;

  0007e	32 c0		 xor	 al, al
  00080	eb 18		 jmp	 SHORT $LN1@valid_data
$LN6@valid_data:

; 208  :         segment = strtok( NULL, "." );

  00082	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169305
  00089	33 c9		 xor	 ecx, ecx
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok
  00091	48 89 44 24 28	 mov	 QWORD PTR segment$[rsp], rax

; 209  :     }

  00096	eb cd		 jmp	 SHORT $LN2@valid_data
$LN3@valid_data:

; 210  :     return true;

  00098	b0 01		 mov	 al, 1
$LN1@valid_data:

; 211  : }

  0009a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0009f	48 33 cc	 xor	 rcx, rsp
  000a2	e8 00 00 00 00	 call	 __security_check_cookie
  000a7	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000ab	c3		 ret	 0
valid_dataset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\maketape.c
_TEXT	SEGMENT
i$ = 32
k$ = 36
segment$ = 64
valid_dsn_segment PROC

; 183  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 184  :     int i, k = (int) strlen( segment );

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR segment$[rsp]
  0000e	e8 00 00 00 00	 call	 strlen
  00013	89 44 24 24	 mov	 DWORD PTR k$[rsp], eax

; 185  :     if (0
; 186  :         || k < 1
; 187  :         || k > 8
; 188  :         || !valid_dsn_first( segment[0] )

  00017	33 c0		 xor	 eax, eax
  00019	85 c0		 test	 eax, eax
  0001b	75 2c		 jne	 SHORT $LN6@valid_dsn_
  0001d	83 7c 24 24 01	 cmp	 DWORD PTR k$[rsp], 1
  00022	7c 25		 jl	 SHORT $LN6@valid_dsn_
  00024	83 7c 24 24 08	 cmp	 DWORD PTR k$[rsp], 8
  00029	7f 1e		 jg	 SHORT $LN6@valid_dsn_
  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	48 6b c0 00	 imul	 rax, rax, 0
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR segment$[rsp]
  00039	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  0003d	e8 00 00 00 00	 call	 valid_dsn_first
  00042	0f b6 c0	 movzx	 eax, al
  00045	85 c0		 test	 eax, eax
  00047	75 04		 jne	 SHORT $LN5@valid_dsn_
$LN6@valid_dsn_:

; 189  :     )
; 190  :         return false;

  00049	32 c0		 xor	 al, al
  0004b	eb 40		 jmp	 SHORT $LN1@valid_dsn_
$LN5@valid_dsn_:

; 191  :     for (i=1; i < k; i++)

  0004d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  00055	eb 0a		 jmp	 SHORT $LN4@valid_dsn_
$LN2@valid_dsn_:
  00057	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0005b	ff c0		 inc	 eax
  0005d	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@valid_dsn_:
  00061	8b 44 24 24	 mov	 eax, DWORD PTR k$[rsp]
  00065	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00069	7d 20		 jge	 SHORT $LN3@valid_dsn_

; 192  :         if (!valid_dsn_remaining( segment[i] ))

  0006b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00070	48 8b 4c 24 40	 mov	 rcx, QWORD PTR segment$[rsp]
  00075	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00079	e8 00 00 00 00	 call	 valid_dsn_remaining
  0007e	0f b6 c0	 movzx	 eax, al
  00081	85 c0		 test	 eax, eax
  00083	75 04		 jne	 SHORT $LN7@valid_dsn_

; 193  :             return false;

  00085	32 c0		 xor	 al, al
  00087	eb 04		 jmp	 SHORT $LN1@valid_dsn_
$LN7@valid_dsn_:
  00089	eb cc		 jmp	 SHORT $LN2@valid_dsn_
$LN3@valid_dsn_:

; 194  :     return true;

  0008b	b0 01		 mov	 al, 1
$LN1@valid_dsn_:

; 195  : }

  0008d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00091	c3		 ret	 0
valid_dsn_segment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\maketape.c
_TEXT	SEGMENT
tv75 = 32
tv77 = 36
ch$ = 64
valid_dsn_remaining PROC

; 174  : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 175  :     return

  00008	33 c0		 xor	 eax, eax
  0000a	85 c0		 test	 eax, eax
  0000c	75 36		 jne	 SHORT $LN3@valid_dsn_
  0000e	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR ch$[rsp]
  00013	e8 00 00 00 00	 call	 valid_alphanumeric
  00018	0f b6 c0	 movzx	 eax, al
  0001b	85 c0		 test	 eax, eax
  0001d	75 25		 jne	 SHORT $LN3@valid_dsn_
  0001f	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR ch$[rsp]
  00024	e8 00 00 00 00	 call	 valid_national
  00029	0f b6 c0	 movzx	 eax, al
  0002c	85 c0		 test	 eax, eax
  0002e	75 14		 jne	 SHORT $LN3@valid_dsn_
  00030	0f be 44 24 40	 movsx	 eax, BYTE PTR ch$[rsp]
  00035	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00038	74 0a		 je	 SHORT $LN3@valid_dsn_
  0003a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
  00042	eb 08		 jmp	 SHORT $LN4@valid_dsn_
$LN3@valid_dsn_:
  00044	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
$LN4@valid_dsn_:
  0004c	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00051	75 0a		 jne	 SHORT $LN5@valid_dsn_
  00053	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv77[rsp], 0
  0005b	eb 08		 jmp	 SHORT $LN6@valid_dsn_
$LN5@valid_dsn_:
  0005d	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv77[rsp], 1
$LN6@valid_dsn_:
  00065	0f b6 44 24 24	 movzx	 eax, BYTE PTR tv77[rsp]

; 176  :     (0
; 177  :         || valid_alphanumeric ( ch )
; 178  :         || valid_national     ( ch )
; 179  :         || '-'       ==       ( ch )
; 180  :     );
; 181  : }

  0006a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006e	c3		 ret	 0
valid_dsn_remaining ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\maketape.c
_TEXT	SEGMENT
tv73 = 32
tv75 = 36
ch$ = 64
valid_dsn_first PROC

; 166  : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 167  :     return

  00008	33 c0		 xor	 eax, eax
  0000a	85 c0		 test	 eax, eax
  0000c	75 2c		 jne	 SHORT $LN3@valid_dsn_
  0000e	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR ch$[rsp]
  00013	e8 00 00 00 00	 call	 valid_alpha
  00018	0f b6 c0	 movzx	 eax, al
  0001b	85 c0		 test	 eax, eax
  0001d	75 1b		 jne	 SHORT $LN3@valid_dsn_
  0001f	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR ch$[rsp]
  00024	e8 00 00 00 00	 call	 valid_national
  00029	0f b6 c0	 movzx	 eax, al
  0002c	85 c0		 test	 eax, eax
  0002e	75 0a		 jne	 SHORT $LN3@valid_dsn_
  00030	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
  00038	eb 08		 jmp	 SHORT $LN4@valid_dsn_
$LN3@valid_dsn_:
  0003a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
$LN4@valid_dsn_:
  00042	83 7c 24 20 00	 cmp	 DWORD PTR tv73[rsp], 0
  00047	75 0a		 jne	 SHORT $LN5@valid_dsn_
  00049	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
  00051	eb 08		 jmp	 SHORT $LN6@valid_dsn_
$LN5@valid_dsn_:
  00053	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
$LN6@valid_dsn_:
  0005b	0f b6 44 24 24	 movzx	 eax, BYTE PTR tv75[rsp]

; 168  :     (0
; 169  :         || valid_alpha    ( ch )
; 170  :         || valid_national ( ch )
; 171  :     );
; 172  : }

  00060	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00064	c3		 ret	 0
valid_dsn_first ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\maketape.c
_TEXT	SEGMENT
i$ = 32
k$ = 36
volser$ = 64
valid_volser PROC

; 151  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 152  :     int i, k = (int) strlen( volser );

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR volser$[rsp]
  0000e	e8 00 00 00 00	 call	 strlen
  00013	89 44 24 24	 mov	 DWORD PTR k$[rsp], eax

; 153  :     if (k < 1 || k > 6)

  00017	83 7c 24 24 01	 cmp	 DWORD PTR k$[rsp], 1
  0001c	7c 07		 jl	 SHORT $LN6@valid_vols
  0001e	83 7c 24 24 06	 cmp	 DWORD PTR k$[rsp], 6
  00023	7e 04		 jle	 SHORT $LN5@valid_vols
$LN6@valid_vols:

; 154  :         return false;

  00025	32 c0		 xor	 al, al
  00027	eb 60		 jmp	 SHORT $LN1@valid_vols
$LN5@valid_vols:

; 155  :     for (i=0; i < k; i++)

  00029	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00031	eb 0a		 jmp	 SHORT $LN4@valid_vols
$LN2@valid_vols:
  00033	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00037	ff c0		 inc	 eax
  00039	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@valid_vols:
  0003d	8b 44 24 24	 mov	 eax, DWORD PTR k$[rsp]
  00041	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00045	7d 40		 jge	 SHORT $LN3@valid_vols

; 156  :     {
; 157  :         if (!(0

  00047	33 c0		 xor	 eax, eax
  00049	85 c0		 test	 eax, eax
  0004b	75 38		 jne	 SHORT $LN7@valid_vols
  0004d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00052	48 8b 4c 24 40	 mov	 rcx, QWORD PTR volser$[rsp]
  00057	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  0005b	e8 00 00 00 00	 call	 valid_alphanumeric
  00060	0f b6 c0	 movzx	 eax, al
  00063	85 c0		 test	 eax, eax
  00065	75 1e		 jne	 SHORT $LN7@valid_vols
  00067	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0006c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR volser$[rsp]
  00071	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00075	e8 00 00 00 00	 call	 valid_national
  0007a	0f b6 c0	 movzx	 eax, al
  0007d	85 c0		 test	 eax, eax
  0007f	75 04		 jne	 SHORT $LN7@valid_vols

; 158  :             || valid_alphanumeric ( volser[i] )
; 159  :             || valid_national     ( volser[i] )
; 160  :         ))
; 161  :             return false;

  00081	32 c0		 xor	 al, al
  00083	eb 04		 jmp	 SHORT $LN1@valid_vols
$LN7@valid_vols:

; 162  :     }

  00085	eb ac		 jmp	 SHORT $LN2@valid_vols
$LN3@valid_vols:

; 163  :     return true;

  00087	b0 01		 mov	 al, 1
$LN1@valid_vols:

; 164  : }

  00089	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008d	c3		 ret	 0
valid_volser ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\maketape.c
_TEXT	SEGMENT
tv71 = 0
tv73 = 4
ch$ = 32
valid_national PROC

; 142  : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	48 83 ec 18	 sub	 rsp, 24

; 143  :     return

  00008	33 c0		 xor	 eax, eax
  0000a	85 c0		 test	 eax, eax
  0000c	75 27		 jne	 SHORT $LN3@valid_nati
  0000e	0f be 44 24 20	 movsx	 eax, BYTE PTR ch$[rsp]
  00013	83 f8 40	 cmp	 eax, 64			; 00000040H
  00016	74 1d		 je	 SHORT $LN3@valid_nati
  00018	0f be 44 24 20	 movsx	 eax, BYTE PTR ch$[rsp]
  0001d	83 f8 24	 cmp	 eax, 36			; 00000024H
  00020	74 13		 je	 SHORT $LN3@valid_nati
  00022	0f be 44 24 20	 movsx	 eax, BYTE PTR ch$[rsp]
  00027	83 f8 23	 cmp	 eax, 35			; 00000023H
  0002a	74 09		 je	 SHORT $LN3@valid_nati
  0002c	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv71[rsp], 0
  00033	eb 07		 jmp	 SHORT $LN4@valid_nati
$LN3@valid_nati:
  00035	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv71[rsp], 1
$LN4@valid_nati:
  0003c	83 3c 24 00	 cmp	 DWORD PTR tv71[rsp], 0
  00040	75 0a		 jne	 SHORT $LN5@valid_nati
  00042	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
  0004a	eb 08		 jmp	 SHORT $LN6@valid_nati
$LN5@valid_nati:
  0004c	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
$LN6@valid_nati:
  00054	0f b6 44 24 04	 movzx	 eax, BYTE PTR tv73[rsp]

; 144  :     (0
; 145  :         || '@' == ch
; 146  :         || '$' == ch
; 147  :         || '#' == ch
; 148  :     );
; 149  : }

  00059	48 83 c4 18	 add	 rsp, 24
  0005d	c3		 ret	 0
valid_national ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\maketape.c
_TEXT	SEGMENT
tv73 = 32
tv75 = 36
ch$ = 64
valid_alphanumeric PROC

; 134  : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 135  :     return

  00008	33 c0		 xor	 eax, eax
  0000a	85 c0		 test	 eax, eax
  0000c	75 2c		 jne	 SHORT $LN3@valid_alph
  0000e	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR ch$[rsp]
  00013	e8 00 00 00 00	 call	 valid_alpha
  00018	0f b6 c0	 movzx	 eax, al
  0001b	85 c0		 test	 eax, eax
  0001d	75 1b		 jne	 SHORT $LN3@valid_alph
  0001f	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR ch$[rsp]
  00024	e8 00 00 00 00	 call	 valid_numeric
  00029	0f b6 c0	 movzx	 eax, al
  0002c	85 c0		 test	 eax, eax
  0002e	75 0a		 jne	 SHORT $LN3@valid_alph
  00030	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
  00038	eb 08		 jmp	 SHORT $LN4@valid_alph
$LN3@valid_alph:
  0003a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
$LN4@valid_alph:
  00042	83 7c 24 20 00	 cmp	 DWORD PTR tv73[rsp], 0
  00047	75 0a		 jne	 SHORT $LN5@valid_alph
  00049	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
  00051	eb 08		 jmp	 SHORT $LN6@valid_alph
$LN5@valid_alph:
  00053	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
$LN6@valid_alph:
  0005b	0f b6 44 24 24	 movzx	 eax, BYTE PTR tv75[rsp]

; 136  :     (0
; 137  :         || valid_alpha   ( ch )
; 138  :         || valid_numeric ( ch )
; 139  :     );
; 140  : }

  00060	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00064	c3		 ret	 0
valid_alphanumeric ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\maketape.c
_TEXT	SEGMENT
tv69 = 0
tv71 = 4
ch$ = 32
valid_numeric PROC

; 126  : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	48 83 ec 18	 sub	 rsp, 24

; 127  :     return

  00008	33 c0		 xor	 eax, eax
  0000a	83 f8 01	 cmp	 eax, 1
  0000d	74 1d		 je	 SHORT $LN3@valid_nume
  0000f	0f be 44 24 20	 movsx	 eax, BYTE PTR ch$[rsp]
  00014	83 f8 30	 cmp	 eax, 48			; 00000030H
  00017	7c 13		 jl	 SHORT $LN3@valid_nume
  00019	0f be 44 24 20	 movsx	 eax, BYTE PTR ch$[rsp]
  0001e	83 f8 39	 cmp	 eax, 57			; 00000039H
  00021	7f 09		 jg	 SHORT $LN3@valid_nume
  00023	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv69[rsp], 1
  0002a	eb 07		 jmp	 SHORT $LN4@valid_nume
$LN3@valid_nume:
  0002c	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv69[rsp], 0
$LN4@valid_nume:
  00033	83 3c 24 00	 cmp	 DWORD PTR tv69[rsp], 0
  00037	75 0a		 jne	 SHORT $LN5@valid_nume
  00039	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
  00041	eb 08		 jmp	 SHORT $LN6@valid_nume
$LN5@valid_nume:
  00043	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv71[rsp], 1
$LN6@valid_nume:
  0004b	0f b6 44 24 04	 movzx	 eax, BYTE PTR tv71[rsp]

; 128  :     (1
; 129  :         && '0' <= ch
; 130  :         && '9' >= ch
; 131  :     );
; 132  : }

  00050	48 83 c4 18	 add	 rsp, 24
  00054	c3		 ret	 0
valid_numeric ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\maketape.c
_TEXT	SEGMENT
tv69 = 0
tv71 = 4
ch$ = 32
valid_alpha PROC

; 118  : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	48 83 ec 18	 sub	 rsp, 24

; 119  :     return

  00008	33 c0		 xor	 eax, eax
  0000a	83 f8 01	 cmp	 eax, 1
  0000d	74 1d		 je	 SHORT $LN3@valid_alph
  0000f	0f be 44 24 20	 movsx	 eax, BYTE PTR ch$[rsp]
  00014	83 f8 41	 cmp	 eax, 65			; 00000041H
  00017	7c 13		 jl	 SHORT $LN3@valid_alph
  00019	0f be 44 24 20	 movsx	 eax, BYTE PTR ch$[rsp]
  0001e	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  00021	7f 09		 jg	 SHORT $LN3@valid_alph
  00023	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv69[rsp], 1
  0002a	eb 07		 jmp	 SHORT $LN4@valid_alph
$LN3@valid_alph:
  0002c	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv69[rsp], 0
$LN4@valid_alph:
  00033	83 3c 24 00	 cmp	 DWORD PTR tv69[rsp], 0
  00037	75 0a		 jne	 SHORT $LN5@valid_alph
  00039	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
  00041	eb 08		 jmp	 SHORT $LN6@valid_alph
$LN5@valid_alph:
  00043	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv71[rsp], 1
$LN6@valid_alph:
  0004b	0f b6 44 24 04	 movzx	 eax, BYTE PTR tv71[rsp]

; 120  :     (1
; 121  :         && 'A' <= ch
; 122  :         && 'Z' >= ch
; 123  :     );
; 124  : }

  00050	48 83 c4 18	 add	 rsp, 24
  00054	c3		 ret	 0
valid_alpha ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\maketape.c
_TEXT	SEGMENT
year$ = 32
tm$ = 40
timer$ = 48
julianDate PROC

; 100  : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 101  : time_t      timer;
; 102  : struct tm*  tm;
; 103  : char        year[3+1];             /* y2k compensation             */
; 104  : 
; 105  :     timer = time( NULL );          /* get time of day from system  */

  00004	33 c9		 xor	 ecx, ecx
  00006	e8 00 00 00 00	 call	 time
  0000b	48 89 44 24 30	 mov	 QWORD PTR timer$[rsp], rax

; 106  :     tzset();                       /* read TZ environment variable */

  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tzset

; 107  :     tm = localtime( &timer );      /* convert to date/time block   */

  00016	48 8d 4c 24 30	 lea	 rcx, QWORD PTR timer$[rsp]
  0001b	e8 00 00 00 00	 call	 localtime
  00020	48 89 44 24 28	 mov	 QWORD PTR tm$[rsp], rax

; 108  : 
; 109  :     MSGBUF( year, "%3.3i", tm->tm_year );

  00025	48 8b 44 24 28	 mov	 rax, QWORD PTR tm$[rsp]
  0002a	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  0002e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169238
  00035	ba 04 00 00 00	 mov	 edx, 4
  0003a	48 8d 4c 24 20	 lea	 rcx, QWORD PTR year$[rsp]
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 110  :     strncpy( julianToday, year+1, 2 );

  00045	48 8d 44 24 21	 lea	 rax, QWORD PTR year$[rsp+1]
  0004a	41 b8 02 00 00
	00		 mov	 r8d, 2
  00050	48 8b d0	 mov	 rdx, rax
  00053	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:julianToday
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 111  :     snprintf(  julianToday+2, 4, "%3.3i", tm->tm_yday );

  00060	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:julianToday
  00067	48 83 c0 02	 add	 rax, 2
  0006b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tm$[rsp]
  00070	44 8b 49 1c	 mov	 r9d, DWORD PTR [rcx+28]
  00074	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169239
  0007b	ba 04 00 00 00	 mov	 edx, 4
  00080	48 8b c8	 mov	 rcx, rax
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 112  : }

  00089	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0008d	c3		 ret	 0
julianDate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\maketape.c
_TEXT	SEGMENT
rc$ = 48
ErrExit	PROC

; 92   : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 93   :     exit( rc );                 /* (common breakpoint location) */

  00008	8b 4c 24 30	 mov	 ecx, DWORD PTR rc$[rsp]
  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN2@ErrExit:

; 94   : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
ErrExit	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
time	PROC

; 521  :         {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 522  :             return _time64(_Time);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Time$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__time64

; 523  :         }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
localtime PROC

; 498  :         {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 499  :             return _localtime64(_Time);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Time$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__localtime64

; 500  :         }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
localtime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
END
