; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	ThreadListHead:BYTE:010H
COMM	ThreadListLock:BYTE:028H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	fthreads_internal_init
PUBLIC	fthread_getschedparam
PUBLIC	fthread_setschedparam
PUBLIC	fthread_get_priority_min
PUBLIC	fthread_get_priority_max
PUBLIC	fthread_attr_init
PUBLIC	fthread_attr_destroy
PUBLIC	fthread_attr_setdetachstate
PUBLIC	fthread_attr_getdetachstate
PUBLIC	fthread_attr_setstacksize
PUBLIC	fthread_attr_getstacksize
PUBLIC	fthread_join
PUBLIC	fthread_detach
PUBLIC	fthread_get_handle
PUBLIC	fthread_create
PUBLIC	fthread_exit
PUBLIC	fthread_self
PUBLIC	fthread_equal
PUBLIC	fthread_mutex_init
PUBLIC	fthread_mutex_destroy
PUBLIC	fthread_mutex_lock
PUBLIC	fthread_mutex_trylock
PUBLIC	fthread_mutex_unlock
PUBLIC	fthread_cond_init
PUBLIC	fthread_cond_destroy
PUBLIC	fthread_cond_signal
PUBLIC	fthread_cond_broadcast
PUBLIC	fthread_cond_wait
PUBLIC	fthread_cond_timedwait
PUBLIC	fthread_mutexattr_init
PUBLIC	fthread_mutexattr_destroy
PUBLIC	fthread_mutexattr_gettype
PUBLIC	fthread_mutexattr_settype
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_CloseHandle:PROC
EXTRN	__imp_InitializeCriticalSection:PROC
EXTRN	__imp_EnterCriticalSection:PROC
EXTRN	__imp_LeaveCriticalSection:PROC
EXTRN	__imp_InitializeCriticalSectionAndSpinCount:PROC
EXTRN	__imp_TryEnterCriticalSection:PROC
EXTRN	__imp_DeleteCriticalSection:PROC
EXTRN	__imp_SetEvent:PROC
EXTRN	__imp_ResetEvent:PROC
EXTRN	__imp_WaitForSingleObject:PROC
EXTRN	__imp_CreateEventA:PROC
EXTRN	__imp_GetCurrentThread:PROC
EXTRN	__imp_GetCurrentThreadId:PROC
EXTRN	__imp_SetThreadPriority:PROC
EXTRN	__imp_GetThreadPriority:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	longjmp:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp__beginthreadex:PROC
EXTRN	__imp__endthreadex:PROC
EXTRN	gettimeofday:PROC
EXTRN	logmsg:PROC
EXTRN	_setjmp:PROC
EXTRN	hostinfo:BYTE
EXTRN	__ImageBase:BYTE
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
?bDidThis@?1??fthreads_internal_init@@9@9 DD 01H DUP (?) ; `fthreads_internal_init'::`2'::bDidThis
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
$pdata$fthreads_internal_init DD imagerel $LN4
	DD	imagerel $LN4+288
	DD	imagerel $unwind$fthreads_internal_init
$pdata$fthread_getschedparam DD imagerel $LN9
	DD	imagerel $LN9+205
	DD	imagerel $unwind$fthread_getschedparam
$pdata$fthread_setschedparam DD imagerel $LN15
	DD	imagerel $LN15+283
	DD	imagerel $unwind$fthread_setschedparam
$pdata$fthread_join DD imagerel $LN26
	DD	imagerel $LN26+556
	DD	imagerel $unwind$fthread_join
$pdata$fthread_detach DD imagerel $LN6
	DD	imagerel $LN6+218
	DD	imagerel $unwind$fthread_detach
$pdata$fthread_get_handle DD imagerel $LN6
	DD	imagerel $LN6+97
	DD	imagerel $unwind$fthread_get_handle
$pdata$fthread_create DD imagerel $LN13
	DD	imagerel $LN13+708
	DD	imagerel $unwind$fthread_create
$pdata$fthread_exit DD imagerel $LN12
	DD	imagerel $LN12+186
	DD	imagerel $unwind$fthread_exit
$pdata$fthread_self DD imagerel $LN3
	DD	imagerel $LN3+15
	DD	imagerel $unwind$fthread_self
$pdata$fthread_equal DD imagerel $LN5
	DD	imagerel $LN5+46
	DD	imagerel $unwind$fthread_equal
$pdata$fthread_mutex_init DD imagerel $LN9
	DD	imagerel $LN9+204
	DD	imagerel $unwind$fthread_mutex_init
$pdata$fthread_mutex_destroy DD imagerel $LN5
	DD	imagerel $LN5+81
	DD	imagerel $unwind$fthread_mutex_destroy
$pdata$fthread_mutex_lock DD imagerel $LN17
	DD	imagerel $LN17+259
	DD	imagerel $unwind$fthread_mutex_lock
$pdata$fthread_mutex_trylock DD imagerel $LN17
	DD	imagerel $LN17+249
	DD	imagerel $unwind$fthread_mutex_trylock
$pdata$fthread_mutex_unlock DD imagerel $LN15
	DD	imagerel $LN15+224
	DD	imagerel $unwind$fthread_mutex_unlock
$pdata$fthread_cond_init DD imagerel $LN6
	DD	imagerel $LN6+119
	DD	imagerel $unwind$fthread_cond_init
$pdata$fthread_cond_destroy DD imagerel $LN5
	DD	imagerel $LN5+81
	DD	imagerel $unwind$fthread_cond_destroy
$pdata$fthread_cond_signal DD imagerel $LN4
	DD	imagerel $LN4+44
	DD	imagerel $unwind$fthread_cond_signal
$pdata$fthread_cond_broadcast DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$fthread_cond_broadcast
$pdata$fthread_cond_wait DD imagerel $LN6
	DD	imagerel $LN6+138
	DD	imagerel $unwind$fthread_cond_wait
$pdata$fthread_cond_timedwait DD imagerel $LN6
	DD	imagerel $LN6+154
	DD	imagerel $unwind$fthread_cond_timedwait
$pdata$fthread_mutexattr_gettype DD imagerel $LN5
	DD	imagerel $LN5+79
	DD	imagerel $unwind$fthread_mutexattr_gettype
$pdata$fthread_mutexattr_settype DD imagerel $LN5
	DD	imagerel $LN5+59
	DD	imagerel $unwind$fthread_mutexattr_settype
$pdata$IsValidMutexType DD imagerel IsValidMutexType
	DD	imagerel IsValidMutexType+58
	DD	imagerel $unwind$IsValidMutexType
$pdata$MallocFT_MUTEX DD imagerel MallocFT_MUTEX
	DD	imagerel MallocFT_MUTEX+62
	DD	imagerel $unwind$MallocFT_MUTEX
$pdata$InitializeFT_MUTEX DD imagerel InitializeFT_MUTEX
	DD	imagerel InitializeFT_MUTEX+150
	DD	imagerel $unwind$InitializeFT_MUTEX
$pdata$UninitializeFT_MUTEX DD imagerel UninitializeFT_MUTEX
	DD	imagerel UninitializeFT_MUTEX+203
	DD	imagerel $unwind$UninitializeFT_MUTEX
$pdata$MallocFT_COND_VAR DD imagerel MallocFT_COND_VAR
	DD	imagerel MallocFT_COND_VAR+62
	DD	imagerel $unwind$MallocFT_COND_VAR
$pdata$InitializeFT_COND_VAR DD imagerel InitializeFT_COND_VAR
	DD	imagerel InitializeFT_COND_VAR+195
	DD	imagerel $unwind$InitializeFT_COND_VAR
$pdata$UninitializeFT_COND_VAR DD imagerel UninitializeFT_COND_VAR
	DD	imagerel UninitializeFT_COND_VAR+145
	DD	imagerel $unwind$UninitializeFT_COND_VAR
$pdata$TryEnterFT_MUTEX DD imagerel TryEnterFT_MUTEX
	DD	imagerel TryEnterFT_MUTEX+564
	DD	imagerel $unwind$TryEnterFT_MUTEX
$pdata$EnterFT_MUTEX DD imagerel EnterFT_MUTEX
	DD	imagerel EnterFT_MUTEX+549
	DD	imagerel $unwind$EnterFT_MUTEX
$pdata$LeaveFT_MUTEX DD imagerel LeaveFT_MUTEX
	DD	imagerel LeaveFT_MUTEX+387
	DD	imagerel $unwind$LeaveFT_MUTEX
$pdata$BeginWait DD imagerel BeginWait
	DD	imagerel BeginWait+431
	DD	imagerel $unwind$BeginWait
$pdata$WaitForTransmission DD imagerel WaitForTransmission
	DD	imagerel WaitForTransmission+353
	DD	imagerel $unwind$WaitForTransmission
$pdata$QueueTransmission DD imagerel QueueTransmission
	DD	imagerel QueueTransmission+178
	DD	imagerel $unwind$QueueTransmission
$pdata$ReceiveXmission DD imagerel ReceiveXmission
	DD	imagerel ReceiveXmission+90
	DD	imagerel $unwind$ReceiveXmission
$pdata$ReturnFromWait DD imagerel ReturnFromWait
	DD	imagerel ReturnFromWait+135
	DD	imagerel $unwind$ReturnFromWait
$pdata$FindFTHREAD DD imagerel FindFTHREAD
	DD	imagerel FindFTHREAD+115
	DD	imagerel $unwind$FindFTHREAD
$pdata$FTWin32ThreadFunc DD imagerel FTWin32ThreadFunc
	DD	imagerel FTWin32ThreadFunc+256
	DD	imagerel $unwind$FTWin32ThreadFunc
$pdata$W2FPriority DD imagerel W2FPriority
	DD	imagerel W2FPriority+203
	DD	imagerel $unwind$W2FPriority
pdata	ENDS
_DATA	SEGMENT
$SG159105 DB	'UninitializeFT_MUTEX', 00H
	ORG $+3
$SG159106 DB	'fthreads.c', 00H
	ORG $+13
$SG159107 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159109 DB	'UninitializeFT_MUTEX', 00H
	ORG $+3
$SG159110 DB	'fthreads.c', 00H
	ORG $+5
$SG159111 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159174 DB	'TryEnterFT_MUTEX', 00H
	ORG $+7
$SG159175 DB	'fthreads.c', 00H
	ORG $+5
$SG159176 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159178 DB	'TryEnterFT_MUTEX', 00H
	ORG $+7
$SG159179 DB	'fthreads.c', 00H
	ORG $+5
$SG159180 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159183 DB	'TryEnterFT_MUTEX', 00H
	ORG $+7
$SG159184 DB	'fthreads.c', 00H
	ORG $+5
$SG159185 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159187 DB	'TryEnterFT_MUTEX', 00H
	ORG $+7
$SG159188 DB	'fthreads.c', 00H
	ORG $+5
$SG159189 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159193 DB	'TryEnterFT_MUTEX', 00H
	ORG $+7
$SG159194 DB	'fthreads.c', 00H
	ORG $+5
$SG159195 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159197 DB	'TryEnterFT_MUTEX', 00H
	ORG $+7
$SG159198 DB	'fthreads.c', 00H
	ORG $+5
$SG159199 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159234 DB	'EnterFT_MUTEX', 00H
	ORG $+2
$SG159235 DB	'fthreads.c', 00H
	ORG $+13
$SG159236 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159238 DB	'EnterFT_MUTEX', 00H
	ORG $+2
$SG159239 DB	'fthreads.c', 00H
	ORG $+13
$SG159240 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159243 DB	'EnterFT_MUTEX', 00H
	ORG $+2
$SG159244 DB	'fthreads.c', 00H
	ORG $+13
$SG159245 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159247 DB	'EnterFT_MUTEX', 00H
	ORG $+2
$SG159248 DB	'fthreads.c', 00H
	ORG $+13
$SG159249 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159254 DB	'EnterFT_MUTEX', 00H
	ORG $+2
$SG159255 DB	'fthreads.c', 00H
	ORG $+13
$SG159256 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159258 DB	'EnterFT_MUTEX', 00H
	ORG $+2
$SG159259 DB	'fthreads.c', 00H
	ORG $+13
$SG159260 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159284 DB	'LeaveFT_MUTEX', 00H
	ORG $+2
$SG159285 DB	'fthreads.c', 00H
	ORG $+13
$SG159286 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159288 DB	'LeaveFT_MUTEX', 00H
	ORG $+2
$SG159289 DB	'fthreads.c', 00H
	ORG $+13
$SG159290 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159294 DB	'LeaveFT_MUTEX', 00H
	ORG $+2
$SG159295 DB	'fthreads.c', 00H
	ORG $+13
$SG159296 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159298 DB	'LeaveFT_MUTEX', 00H
	ORG $+2
$SG159299 DB	'fthreads.c', 00H
	ORG $+13
$SG159300 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159331 DB	'BeginWait', 00H
	ORG $+6
$SG159332 DB	'fthreads.c', 00H
	ORG $+13
$SG159333 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159335 DB	'BeginWait', 00H
	ORG $+6
$SG159336 DB	'fthreads.c', 00H
	ORG $+13
$SG159337 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159342 DB	'fthreads: BeginWait: fthread_mutex_unlock failed! rc=%d', 0aH
	DB	00H
	ORG $+7
$SG159408 DB	'fthreads: ReturnFromWait: fthread_mutex_lock failed! rc='
	DB	'%d', 0aH, 00H
	ORG $+12
$SG159371 DB	'fthreads: WaitForTransmission: MyWaitForSingleObject fai'
	DB	'led! dwWaitRetCode=%d (0x%8.8X)', 0aH, 00H
	ORG $+7
$SG159503 DB	'fthread_create: malloc(FT_CALL_THREAD_PARMS) failed', 0aH
	DB	00H
	ORG $+3
$SG159505 DB	'fthread_create: malloc(FTHREAD) failed', 0aH, 00H
$SG159507 DB	'fthread_create: MyCreateThread failed', 0aH, 00H
	ORG $+1
$SG159519 DB	'fthread_exit', 00H
	ORG $+3
$SG159520 DB	'fthreads.c', 00H
	ORG $+13
$SG159521 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159523 DB	'fthread_exit', 00H
	ORG $+3
$SG159524 DB	'fthreads.c', 00H
	ORG $+13
$SG159525 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159553 DB	'fthread_join', 00H
	ORG $+3
$SG159554 DB	'fthreads.c', 00H
	ORG $+13
$SG159555 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159557 DB	'fthread_join', 00H
	ORG $+3
$SG159558 DB	'fthreads.c', 00H
	ORG $+13
$SG159559 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159563 DB	'fthread_join', 00H
	ORG $+3
$SG159564 DB	'fthreads.c', 00H
	ORG $+13
$SG159565 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159567 DB	'fthread_join', 00H
	ORG $+3
$SG159568 DB	'fthreads.c', 00H
	ORG $+13
$SG159569 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159663 DB	'fthread_mutex_trylock', 00H
	ORG $+2
$SG159664 DB	'fthreads.c', 00H
	ORG $+5
$SG159665 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159667 DB	'fthread_mutex_trylock', 00H
	ORG $+2
$SG159668 DB	'fthreads.c', 00H
	ORG $+5
$SG159669 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159690 DB	'fthread_mutex_lock', 00H
	ORG $+5
$SG159691 DB	'fthreads.c', 00H
	ORG $+5
$SG159692 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159694 DB	'fthread_mutex_lock', 00H
	ORG $+5
$SG159695 DB	'fthreads.c', 00H
	ORG $+5
$SG159696 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159715 DB	'fthread_mutex_unlock', 00H
	ORG $+3
$SG159716 DB	'fthreads.c', 00H
	ORG $+5
$SG159717 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159719 DB	'fthread_mutex_unlock', 00H
	ORG $+3
$SG159720 DB	'fthreads.c', 00H
	ORG $+5
$SG159721 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159857 DB	'fthread_setschedparam', 00H
	ORG $+2
$SG159858 DB	'fthreads.c', 00H
	ORG $+5
$SG159859 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159861 DB	'fthread_setschedparam', 00H
	ORG $+2
$SG159862 DB	'fthreads.c', 00H
	ORG $+5
$SG159863 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
_DATA	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$fthreads_internal_init DD 020601H
	DD	070027206H
$unwind$fthread_getschedparam DD 011201H
	DD	08212H
$unwind$fthread_setschedparam DD 011101H
	DD	06211H
$unwind$fthread_join DD 010d01H
	DD	0820dH
$unwind$fthread_detach DD 010801H
	DD	08208H
$unwind$fthread_get_handle DD 010801H
	DD	06208H
$unwind$fthread_create DD 011801H
	DD	0e218H
$unwind$fthread_exit DD 010901H
	DD	06209H
$unwind$fthread_self DD 010401H
	DD	04204H
$unwind$fthread_equal DD 010c01H
	DD	0220cH
$unwind$fthread_mutex_init DD 010e01H
	DD	0620eH
$unwind$fthread_mutex_destroy DD 010901H
	DD	04209H
$unwind$fthread_mutex_lock DD 010901H
	DD	04209H
$unwind$fthread_mutex_trylock DD 010901H
	DD	04209H
$unwind$fthread_mutex_unlock DD 010901H
	DD	04209H
$unwind$fthread_cond_init DD 010901H
	DD	06209H
$unwind$fthread_cond_destroy DD 010901H
	DD	04209H
$unwind$fthread_cond_signal DD 010901H
	DD	04209H
$unwind$fthread_cond_broadcast DD 010901H
	DD	04209H
$unwind$fthread_cond_wait DD 010e01H
	DD	0620eH
$unwind$fthread_cond_timedwait DD 011301H
	DD	06213H
$unwind$fthread_mutexattr_gettype DD 010e01H
	DD	0620eH
$unwind$fthread_mutexattr_settype DD 010d01H
	DD	0420dH
$unwind$IsValidMutexType DD 010801H
	DD	02208H
$unwind$MallocFT_MUTEX DD 020601H
	DD	070025206H
$unwind$InitializeFT_MUTEX DD 020e01H
	DD	0700a520eH
$unwind$UninitializeFT_MUTEX DD 020a01H
	DD	07006320aH
$unwind$MallocFT_COND_VAR DD 020601H
	DD	070025206H
$unwind$InitializeFT_COND_VAR DD 020a01H
	DD	07006520aH
$unwind$UninitializeFT_COND_VAR DD 020a01H
	DD	07006320aH
$unwind$TryEnterFT_MUTEX DD 010901H
	DD	06209H
$unwind$EnterFT_MUTEX DD 010901H
	DD	06209H
$unwind$LeaveFT_MUTEX DD 010901H
	DD	04209H
$unwind$BeginWait DD 010e01H
	DD	0620eH
$unwind$WaitForTransmission DD 010e01H
	DD	0820eH
$unwind$QueueTransmission DD 010d01H
	DD	0420dH
$unwind$ReceiveXmission DD 010901H
	DD	04209H
$unwind$ReturnFromWait DD 011301H
	DD	06213H
$unwind$FindFTHREAD DD 010801H
	DD	06208H
$unwind$FTWin32ThreadFunc DD 010901H
	DD	0a209H
$unwind$W2FPriority DD 010801H
	DD	02208H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
nFthreadPriority$ = 8
F2WPriority PROC

; 1786 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 1787 :     if (nFthreadPriority <= FTHREAD_IDLE         ) return THREAD_PRIORITY_IDLE;

  00004	83 7c 24 08 01	 cmp	 DWORD PTR nFthreadPriority$[rsp], 1
  00009	7f 07		 jg	 SHORT $LN2@F2WPriorit
  0000b	b8 f1 ff ff ff	 mov	 eax, -15
  00010	eb 48		 jmp	 SHORT $LN1@F2WPriorit
$LN2@F2WPriorit:

; 1788 :     if (nFthreadPriority <= FTHREAD_LOWEST       ) return THREAD_PRIORITY_LOWEST;

  00012	83 7c 24 08 02	 cmp	 DWORD PTR nFthreadPriority$[rsp], 2
  00017	7f 07		 jg	 SHORT $LN3@F2WPriorit
  00019	b8 fe ff ff ff	 mov	 eax, -2
  0001e	eb 3a		 jmp	 SHORT $LN1@F2WPriorit
$LN3@F2WPriorit:

; 1789 :     if (nFthreadPriority <= FTHREAD_BELOW_NORMAL ) return THREAD_PRIORITY_BELOW_NORMAL;

  00020	83 7c 24 08 03	 cmp	 DWORD PTR nFthreadPriority$[rsp], 3
  00025	7f 07		 jg	 SHORT $LN4@F2WPriorit
  00027	b8 ff ff ff ff	 mov	 eax, -1
  0002c	eb 2c		 jmp	 SHORT $LN1@F2WPriorit
$LN4@F2WPriorit:

; 1790 :     if (nFthreadPriority <= FTHREAD_NORMAL       ) return THREAD_PRIORITY_NORMAL;

  0002e	83 7c 24 08 04	 cmp	 DWORD PTR nFthreadPriority$[rsp], 4
  00033	7f 04		 jg	 SHORT $LN5@F2WPriorit
  00035	33 c0		 xor	 eax, eax
  00037	eb 21		 jmp	 SHORT $LN1@F2WPriorit
$LN5@F2WPriorit:

; 1791 :     if (nFthreadPriority <= FTHREAD_ABOVE_NORMAL ) return THREAD_PRIORITY_ABOVE_NORMAL;

  00039	83 7c 24 08 05	 cmp	 DWORD PTR nFthreadPriority$[rsp], 5
  0003e	7f 07		 jg	 SHORT $LN6@F2WPriorit
  00040	b8 01 00 00 00	 mov	 eax, 1
  00045	eb 13		 jmp	 SHORT $LN1@F2WPriorit
$LN6@F2WPriorit:

; 1792 :     if (nFthreadPriority <= FTHREAD_HIGHEST      ) return THREAD_PRIORITY_HIGHEST;

  00047	83 7c 24 08 06	 cmp	 DWORD PTR nFthreadPriority$[rsp], 6
  0004c	7f 07		 jg	 SHORT $LN7@F2WPriorit
  0004e	b8 02 00 00 00	 mov	 eax, 2
  00053	eb 05		 jmp	 SHORT $LN1@F2WPriorit
$LN7@F2WPriorit:

; 1793 :                                                    return THREAD_PRIORITY_TIME_CRITICAL;

  00055	b8 0f 00 00 00	 mov	 eax, 15
$LN1@F2WPriorit:

; 1794 : }

  0005a	c3		 ret	 0
F2WPriority ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
tv64 = 0
p$1 = 8
nWindowsPriority$ = 32
W2FPriority PROC

; 1767 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 1768 :     switch (nWindowsPriority)

  00008	8b 44 24 20	 mov	 eax, DWORD PTR nWindowsPriority$[rsp]
  0000c	89 04 24	 mov	 DWORD PTR tv64[rsp], eax
  0000f	8b 04 24	 mov	 eax, DWORD PTR tv64[rsp]
  00012	83 c0 0f	 add	 eax, 15
  00015	89 04 24	 mov	 DWORD PTR tv64[rsp], eax
  00018	83 3c 24 1e	 cmp	 DWORD PTR tv64[rsp], 30
  0001c	77 50		 ja	 SHORT $LN14@W2FPriorit
  0001e	48 63 04 24	 movsxd	 rax, DWORD PTR tv64[rsp]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00029	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN16@W2FPriorit[rcx+rax]
  00031	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN17@W2FPriorit[rcx+rax*4]
  00038	48 03 c1	 add	 rax, rcx
  0003b	ff e0		 jmp	 rax
$LN7@W2FPriorit:

; 1769 :     {
; 1770 :         case  THREAD_PRIORITY_IDLE:           return  FTHREAD_IDLE;

  0003d	b8 01 00 00 00	 mov	 eax, 1
  00042	eb 41		 jmp	 SHORT $LN1@W2FPriorit
$LN8@W2FPriorit:

; 1771 :         case  THREAD_PRIORITY_LOWEST:         return  FTHREAD_LOWEST;

  00044	b8 02 00 00 00	 mov	 eax, 2
  00049	eb 3a		 jmp	 SHORT $LN1@W2FPriorit
$LN9@W2FPriorit:

; 1772 :         case  THREAD_PRIORITY_BELOW_NORMAL:   return  FTHREAD_BELOW_NORMAL;

  0004b	b8 03 00 00 00	 mov	 eax, 3
  00050	eb 33		 jmp	 SHORT $LN1@W2FPriorit
$LN10@W2FPriorit:

; 1773 :         case  THREAD_PRIORITY_NORMAL:         return  FTHREAD_NORMAL;

  00052	b8 04 00 00 00	 mov	 eax, 4
  00057	eb 2c		 jmp	 SHORT $LN1@W2FPriorit
$LN11@W2FPriorit:

; 1774 :         case  THREAD_PRIORITY_ABOVE_NORMAL:   return  FTHREAD_ABOVE_NORMAL;

  00059	b8 05 00 00 00	 mov	 eax, 5
  0005e	eb 25		 jmp	 SHORT $LN1@W2FPriorit
$LN12@W2FPriorit:

; 1775 :         case  THREAD_PRIORITY_HIGHEST:        return  FTHREAD_HIGHEST;

  00060	b8 06 00 00 00	 mov	 eax, 6
  00065	eb 1e		 jmp	 SHORT $LN1@W2FPriorit
$LN13@W2FPriorit:

; 1776 :         case  THREAD_PRIORITY_TIME_CRITICAL:  return  FTHREAD_TIME_CRITICAL;

  00067	b8 07 00 00 00	 mov	 eax, 7
  0006c	eb 17		 jmp	 SHORT $LN1@W2FPriorit
$LN14@W2FPriorit:
$LN6@W2FPriorit:

; 1777 :         default:
; 1778 :         {
; 1779 :             CRASH();    // (WINDOWS OPERATING SYSTEM BUG!)

  0006e	48 c7 44 24 08
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00077	48 8b 44 24 08	 mov	 rax, QWORD PTR p$1[rsp]
  0007c	c6 00 00	 mov	 BYTE PTR [rax], 0
  0007f	33 c0		 xor	 eax, eax
  00081	85 c0		 test	 eax, eax
  00083	75 e9		 jne	 SHORT $LN6@W2FPriorit
$LN1@W2FPriorit:
$LN15@W2FPriorit:

; 1780 :         }
; 1781 :     }
; 1782 :     UNREACHABLE_CODE( return DEFAULT_HERC_PRIO );
; 1783 : }

  00085	48 83 c4 18	 add	 rsp, 24
  00089	c3		 ret	 0
  0008a	66 90		 npad	 2
$LN17@W2FPriorit:
  0008c	00 00 00 00	 DD	 $LN7@W2FPriorit
  00090	00 00 00 00	 DD	 $LN8@W2FPriorit
  00094	00 00 00 00	 DD	 $LN9@W2FPriorit
  00098	00 00 00 00	 DD	 $LN10@W2FPriorit
  0009c	00 00 00 00	 DD	 $LN11@W2FPriorit
  000a0	00 00 00 00	 DD	 $LN12@W2FPriorit
  000a4	00 00 00 00	 DD	 $LN13@W2FPriorit
  000a8	00 00 00 00	 DD	 $LN14@W2FPriorit
$LN16@W2FPriorit:
  000ac	00		 DB	 0
  000ad	07		 DB	 7
  000ae	07		 DB	 7
  000af	07		 DB	 7
  000b0	07		 DB	 7
  000b1	07		 DB	 7
  000b2	07		 DB	 7
  000b3	07		 DB	 7
  000b4	07		 DB	 7
  000b5	07		 DB	 7
  000b6	07		 DB	 7
  000b7	07		 DB	 7
  000b8	07		 DB	 7
  000b9	01		 DB	 1
  000ba	02		 DB	 2
  000bb	03		 DB	 3
  000bc	04		 DB	 4
  000bd	05		 DB	 5
  000be	07		 DB	 7
  000bf	07		 DB	 7
  000c0	07		 DB	 7
  000c1	07		 DB	 7
  000c2	07		 DB	 7
  000c3	07		 DB	 7
  000c4	07		 DB	 7
  000c5	07		 DB	 7
  000c6	07		 DB	 7
  000c7	07		 DB	 7
  000c8	07		 DB	 7
  000c9	07		 DB	 7
  000ca	06		 DB	 6
W2FPriority ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pFTHREAD$ = 32
pCallTheirThreadParms$ = 40
_EX_Flink$1 = 48
_EX_Blink$2 = 56
pvTheirThreadArgs$ = 64
pfnTheirThreadFunc$ = 72
pMyArgs$ = 96
FTWin32ThreadFunc PROC

; 794  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 795  :     FT_CALL_THREAD_PARMS*  pCallTheirThreadParms;
; 796  :     PFT_THREAD_FUNC        pfnTheirThreadFunc;
; 797  :     void*                  pvTheirThreadArgs;
; 798  :     FTHREAD*               pFTHREAD;
; 799  : 
; 800  :     pCallTheirThreadParms = (FT_CALL_THREAD_PARMS*) pMyArgs;

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR pMyArgs$[rsp]
  0000e	48 89 44 24 28	 mov	 QWORD PTR pCallTheirThreadParms$[rsp], rax

; 801  : 
; 802  :     pfnTheirThreadFunc = pCallTheirThreadParms->pfnTheirThreadFunc;

  00013	48 8b 44 24 28	 mov	 rax, QWORD PTR pCallTheirThreadParms$[rsp]
  00018	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001b	48 89 44 24 48	 mov	 QWORD PTR pfnTheirThreadFunc$[rsp], rax

; 803  :     pvTheirThreadArgs  = pCallTheirThreadParms->pvTheirThreadArgs;

  00020	48 8b 44 24 28	 mov	 rax, QWORD PTR pCallTheirThreadParms$[rsp]
  00025	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00029	48 89 44 24 40	 mov	 QWORD PTR pvTheirThreadArgs$[rsp], rax

; 804  :     pFTHREAD           = pCallTheirThreadParms->pFTHREAD;

  0002e	48 8b 44 24 28	 mov	 rax, QWORD PTR pCallTheirThreadParms$[rsp]
  00033	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00037	48 89 44 24 20	 mov	 QWORD PTR pFTHREAD$[rsp], rax

; 805  : 
; 806  :     free ( pCallTheirThreadParms );

  0003c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCallTheirThreadParms$[rsp]
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 807  : 
; 808  :     if ( setjmp ( pFTHREAD->JumpBuf ) == 0 )

  00047	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  0004c	48 83 c0 40	 add	 rax, 64			; 00000040H
  00050	48 8b c8	 mov	 rcx, rax
  00053	48 8b d4	 mov	 rdx, rsp
  00056	e8 00 00 00 00	 call	 _setjmp
  0005b	85 c0		 test	 eax, eax
  0005d	75 12		 jne	 SHORT $LN2@FTWin32Thr

; 809  :         pFTHREAD->ExitVal = pfnTheirThreadFunc ( pvTheirThreadArgs );

  0005f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pvTheirThreadArgs$[rsp]
  00064	ff 54 24 48	 call	 QWORD PTR pfnTheirThreadFunc$[rsp]
  00068	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pFTHREAD$[rsp]
  0006d	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
$LN2@FTWin32Thr:

; 810  : 
; 811  :     LockThreadsList();

  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ThreadListLock
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 812  : 
; 813  :     if ( !pFTHREAD->bJoinable )

  0007e	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  00083	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  00087	75 5b		 jne	 SHORT $LN3@FTWin32Thr

; 814  :     {
; 815  :         // If we are not a joinable thread, we must free our
; 816  :         // own resources ourselves, but ONLY IF the 'joined'
; 817  :         // count is zero. If the 'joined' count is NOT zero,
; 818  :         // then, however it occurred, there is still someone
; 819  :         // waiting in the join function for us to exit, and
; 820  :         // thus, we cannot free our resources at this time
; 821  :         // (since the thread that did the join and which is
; 822  :         // waiting for us to exit still needs access to our
; 823  :         // resources). In such a situation the actual freeing
; 824  :         // of resources is deferred and will be done by the
; 825  :         // join function itself whenever it's done with them.
; 826  : 
; 827  :         if ( pFTHREAD->nJoinedCount <= 0 )

  00089	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  0008e	83 78 24 00	 cmp	 DWORD PTR [rax+36], 0
  00092	7f 50		 jg	 SHORT $LN4@FTWin32Thr

; 828  :         {
; 829  :             CloseHandle ( pFTHREAD->hThreadHandle );

  00094	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  00099	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 830  :             RemoveListEntry ( &pFTHREAD->ThreadListLink );

  000a3	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  000a8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ab	48 89 44 24 30	 mov	 QWORD PTR _EX_Flink$1[rsp], rax
  000b0	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  000b5	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000b9	48 89 44 24 38	 mov	 QWORD PTR _EX_Blink$2[rsp], rax
  000be	48 8b 44 24 38	 mov	 rax, QWORD PTR _EX_Blink$2[rsp]
  000c3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _EX_Flink$1[rsp]
  000c8	48 89 08	 mov	 QWORD PTR [rax], rcx
  000cb	48 8b 44 24 30	 mov	 rax, QWORD PTR _EX_Flink$1[rsp]
  000d0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _EX_Blink$2[rsp]
  000d5	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 831  :             free ( pFTHREAD );

  000d9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pFTHREAD$[rsp]
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN4@FTWin32Thr:
$LN3@FTWin32Thr:

; 832  :         }
; 833  :     }
; 834  : 
; 835  :     UnlockThreadsList();

  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ThreadListLock
  000eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 836  : 
; 837  :     MyExitThread ( 0 );

  000f1	33 c9		 xor	 ecx, ecx
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__endthreadex

; 838  : 
; 839  :     return 0;   // (make compiler happy)

  000f9	33 c0		 xor	 eax, eax

; 840  : }

  000fb	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000ff	c3		 ret	 0
FTWin32ThreadFunc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pListEntry$ = 32
pFTHREAD$ = 40
dwThreadID$ = 64
FindFTHREAD PROC

; 753  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 754  :     FTHREAD*     pFTHREAD;
; 755  :     LIST_ENTRY*  pListEntry;
; 756  : 
; 757  :     LockThreadsList();      // (acquire thread list lock)

  00008	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ThreadListLock
  0000f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 758  : 
; 759  :     pListEntry = ThreadListHead.Flink;

  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ThreadListHead
  0001c	48 89 44 24 20	 mov	 QWORD PTR pListEntry$[rsp], rax
$LN2@FindFTHREA:

; 760  : 
; 761  :     while ( pListEntry != &ThreadListHead )

  00021	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ThreadListHead
  00028	48 39 44 24 20	 cmp	 QWORD PTR pListEntry$[rsp], rax
  0002d	74 30		 je	 SHORT $LN3@FindFTHREA

; 762  :     {
; 763  :         pFTHREAD = CONTAINING_RECORD ( pListEntry, FTHREAD, ThreadListLink );

  0002f	48 8b 44 24 20	 mov	 rax, QWORD PTR pListEntry$[rsp]
  00034	48 89 44 24 28	 mov	 QWORD PTR pFTHREAD$[rsp], rax

; 764  : 
; 765  :         pListEntry = pListEntry->Flink;

  00039	48 8b 44 24 20	 mov	 rax, QWORD PTR pListEntry$[rsp]
  0003e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00041	48 89 44 24 20	 mov	 QWORD PTR pListEntry$[rsp], rax

; 766  : 
; 767  :         if ( pFTHREAD->dwThreadID != dwThreadID )

  00046	48 8b 44 24 28	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  0004b	8b 4c 24 40	 mov	 ecx, DWORD PTR dwThreadID$[rsp]
  0004f	39 48 10	 cmp	 DWORD PTR [rax+16], ecx
  00052	74 02		 je	 SHORT $LN4@FindFTHREA

; 768  :             continue;

  00054	eb cb		 jmp	 SHORT $LN2@FindFTHREA
$LN4@FindFTHREA:

; 769  : 
; 770  :         return pFTHREAD;    // (return with thread list lock still held)

  00056	48 8b 44 24 28	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  0005b	eb 11		 jmp	 SHORT $LN1@FindFTHREA

; 771  :     }

  0005d	eb c2		 jmp	 SHORT $LN2@FindFTHREA
$LN3@FindFTHREA:

; 772  : 
; 773  :     UnlockThreadsList();    // (release thread list lock)

  0005f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ThreadListLock
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 774  : 
; 775  :     return NULL;            // (not found)

  0006c	33 c0		 xor	 eax, eax
$LN1@FindFTHREA:

; 776  : }

  0006e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00072	c3		 ret	 0
FindFTHREAD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
rc$ = 32
pFT_MUTEX$ = 40
pFT_COND_VAR$ = 64
pFTUSER_MUTEX$ = 72
nRetCode$ = 80
ReturnFromWait PROC

; 673  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 674  :     int        rc;
; 675  :     FT_MUTEX*  pFT_MUTEX;
; 676  : 
; 677  :     if (0
; 678  :         || !pFT_COND_VAR                                          // (invalid ptr)
; 679  :         || !pFTUSER_MUTEX                                         // (invalid ptr)
; 680  :         || !(pFT_MUTEX = pFTUSER_MUTEX->hMutex)                   // (invalid ptr)

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	75 25		 jne	 SHORT $LN3@ReturnFrom
  00019	48 83 7c 24 40
	00		 cmp	 QWORD PTR pFT_COND_VAR$[rsp], 0
  0001f	74 1d		 je	 SHORT $LN3@ReturnFrom
  00021	48 83 7c 24 48
	00		 cmp	 QWORD PTR pFTUSER_MUTEX$[rsp], 0
  00027	74 15		 je	 SHORT $LN3@ReturnFrom
  00029	48 8b 44 24 48	 mov	 rax, QWORD PTR pFTUSER_MUTEX$[rsp]
  0002e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00031	48 89 44 24 28	 mov	 QWORD PTR pFT_MUTEX$[rsp], rax
  00036	48 83 7c 24 28
	00		 cmp	 QWORD PTR pFT_MUTEX$[rsp], 0
  0003c	75 07		 jne	 SHORT $LN2@ReturnFrom
$LN3@ReturnFrom:

; 681  :     )
; 682  :         return RC(EINVAL);

  0003e	b8 16 00 00 00	 mov	 eax, 22
  00043	eb 3d		 jmp	 SHORT $LN1@ReturnFrom
$LN2@ReturnFrom:

; 683  : 
; 684  :     // (let other threads access this condition variable now...)
; 685  : 
; 686  :     MyLeaveCriticalSection ( &pFT_COND_VAR->CondVarLock );

  00045	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  0004a	48 8b c8	 mov	 rcx, rax
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 687  : 
; 688  :     // (reacquire original mutex before returning back to the original caller...)
; 689  : 
; 690  :     if
; 691  :     (
; 692  :         (
; 693  :             rc = fthread_mutex_lock
; 694  :             (
; 695  :                 pFTUSER_MUTEX
; 696  :             )
; 697  :         )
; 698  :         != 0

  00053	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pFTUSER_MUTEX$[rsp]
  00058	e8 00 00 00 00	 call	 fthread_mutex_lock
  0005d	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
  00061	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00066	74 16		 je	 SHORT $LN4@ReturnFrom

; 699  :     )
; 700  :     {
; 701  :         // Oops! We were unable to reacquire the caller's original mutex! This
; 702  :         // is actually a catastrophic type of error! The caller expects their
; 703  :         // mutex to still be owned (locked) by themselves upon return, but we
; 704  :         // were unable to reacquire it for them! Unfortunately there's nothing
; 705  :         // we can do about this; the system is essentially hosed at this point.
; 706  :         // Just log the fact that something went wrong and return. <shrug>
; 707  : 
; 708  :         logmsg("fthreads: ReturnFromWait: fthread_mutex_lock failed! rc=%d\n"

  00068	8b 54 24 20	 mov	 edx, DWORD PTR rc$[rsp]
  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159408
  00073	e8 00 00 00 00	 call	 logmsg

; 709  :             ,rc );
; 710  : 
; 711  :         return RC(rc);        // (what went wrong)

  00078	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  0007c	eb 04		 jmp	 SHORT $LN1@ReturnFrom
$LN4@ReturnFrom:

; 712  :     }
; 713  : 
; 714  :     // Return to caller with the requested return code. (The caller passes to us
; 715  :     // the return code they wish to pass back to the original caller, so we just
; 716  :     // return that same return code back to OUR caller (so they can then pass it
; 717  :     // back to the original fthreads caller)).
; 718  : 
; 719  :     return RC(nRetCode);      // (as requested)

  0007e	8b 44 24 50	 mov	 eax, DWORD PTR nRetCode$[rsp]
$LN1@ReturnFrom:

; 720  : }

  00082	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00086	c3		 ret	 0
ReturnFromWait ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pFT_COND_VAR$ = 48
ReceiveXmission PROC

; 624  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 625  :     // If we were the only ones supposed to receive the transmission, (or
; 626  :     // if no one remains to receive any transmissions), then turn off the
; 627  :     // transmitter (i.e. stop sending the signal) and indicate that it has
; 628  :     // been completely received all interested parties (i.e. by everyone
; 629  :     // who was supposed to receive it)...
; 630  : 
; 631  :     pFT_COND_VAR->nNumWaiting--;    // (de-register wait since transmission

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  0000e	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00011	ff c8		 dec	 eax
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pFT_COND_VAR$[rsp]
  00018	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 632  :                                     //  has been successfully received now)
; 633  : 
; 634  :     // Determine whether any more waiters (threads) should also receive
; 635  :     // this transmission (i.e. also be released) or whether we should
; 636  :     // reset (turn off) our transmitter so as to not release any other
; 637  :     // thread(s) besides ourselves...
; 638  : 
; 639  :     if (0
; 640  :         || !pFT_COND_VAR->bBroadcastSig         // ("signal" == only us)
; 641  :         ||  pFT_COND_VAR->nNumWaiting <= 0      // (no one else == only us)

  0001b	33 c0		 xor	 eax, eax
  0001d	85 c0		 test	 eax, eax
  0001f	75 16		 jne	 SHORT $LN3@ReceiveXmi
  00021	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00026	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  0002a	74 0b		 je	 SHORT $LN3@ReceiveXmi
  0002c	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00031	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00035	7f 1e		 jg	 SHORT $LN2@ReceiveXmi
$LN3@ReceiveXmi:

; 642  :     )
; 643  :     {
; 644  :         MyResetEvent ( pFT_COND_VAR->hSigXmitEvent  );   // (turn off transmitter)

  00037	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  0003c	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ResetEvent

; 645  :         MySetEvent   ( pFT_COND_VAR->hSigRecvdEvent );   // (transmission complete)

  00046	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  0004b	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetEvent
$LN2@ReceiveXmi:

; 646  :     }
; 647  : }

  00055	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00059	c3		 ret	 0
ReceiveXmission ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pFT_COND_VAR$ = 48
bXmitType$ = 56
QueueTransmission PROC

; 575  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 576  :     if (!pFT_COND_VAR)

  0000d	48 83 7c 24 30
	00		 cmp	 QWORD PTR pFT_COND_VAR$[rsp], 0
  00013	75 0a		 jne	 SHORT $LN5@QueueTrans

; 577  :         return RC(EINVAL);    // (invalid parameters were passed)

  00015	b8 16 00 00 00	 mov	 eax, 22
  0001a	e9 8e 00 00 00	 jmp	 $LN1@QueueTrans
$LN5@QueueTrans:
$LN2@QueueTrans:

; 578  : 
; 579  :     // Wait for the condition variable to become free so we can begin transmitting
; 580  :     // our signal... If the condition variable is still "busy" (in use), then that
; 581  :     // means threads are still in the process of being released as a result of some
; 582  :     // prior signal (transmission). Thus we must wait until that work is completed
; 583  :     // first before we can send our new signal (transmission)...
; 584  : 
; 585  :     for (;;)
; 586  :     {
; 587  :         MyEnterCriticalSection ( &pFT_COND_VAR->CondVarLock );

  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00024	48 8b c8	 mov	 rcx, rax
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 588  :         if ( IsEventSet ( pFT_COND_VAR->hSigRecvdEvent ) ) break;

  0002d	33 d2		 xor	 edx, edx
  0002f	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00034	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
  0003e	85 c0		 test	 eax, eax
  00040	75 02		 jne	 SHORT $LN6@QueueTrans
  00042	eb 24		 jmp	 SHORT $LN3@QueueTrans
$LN6@QueueTrans:

; 589  :         MyLeaveCriticalSection ( &pFT_COND_VAR->CondVarLock );

  00044	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00049	48 8b c8	 mov	 rcx, rax
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 590  :         MyWaitForSingleObject ( pFT_COND_VAR->hSigRecvdEvent, INFINITE );

  00052	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  00057	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  0005c	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject

; 591  :     }

  00066	eb b7		 jmp	 SHORT $LN2@QueueTrans
$LN3@QueueTrans:

; 592  : 
; 593  :     // Turn on our transmitter...  (i.e. start transmitting our "signal" to
; 594  :     // all threads who might be waiting to receive it (if there are any)...
; 595  : 
; 596  :     // If no one has registered their interest in receiving any transmissions
; 597  :     // associated with this particular condition variable, then they are unfor-
; 598  :     // tunately a little too late in doing so because we're ready to start our
; 599  :     // transmission right now! If there's no one to receive our transmission,
; 600  :     // then it simply gets lost (i.e. a "missed signal" situation has essenti-
; 601  :     // ally occurred), but then that's not our concern here; our only concern
; 602  :     // here is to transmit the signal (transmission) and nothing more. Tough
; 603  :     // beans if there's no one listening to receive it... <shrug>
; 604  : 
; 605  :     if ( pFT_COND_VAR->nNumWaiting )                    // (anyone interested?)

  00068	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  0006d	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00071	74 2a		 je	 SHORT $LN7@QueueTrans

; 606  :     {
; 607  :         pFT_COND_VAR->bBroadcastSig = bXmitType;        // (yep! set xmit type)

  00073	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00078	8b 4c 24 38	 mov	 ecx, DWORD PTR bXmitType$[rsp]
  0007c	89 48 38	 mov	 DWORD PTR [rax+56], ecx

; 608  :         MySetEvent   ( pFT_COND_VAR->hSigXmitEvent  );  // (turn on transmitter)

  0007f	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00084	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetEvent

; 609  :         MyResetEvent ( pFT_COND_VAR->hSigRecvdEvent );  // (serialize reception)

  0008e	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00093	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ResetEvent
$LN7@QueueTrans:

; 610  :     }
; 611  : 
; 612  :     MyLeaveCriticalSection ( &pFT_COND_VAR->CondVarLock );

  0009d	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  000a2	48 8b c8	 mov	 rcx, rax
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 613  : 
; 614  :     return RC(0);

  000ab	33 c0		 xor	 eax, eax
$LN1@QueueTrans:

; 615  : }

  000ad	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b1	c3		 ret	 0
QueueTransmission ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
dwWaitRetCode$ = 32
dwWaitMilliSecs$ = 36
TimeNow$1 = 40
tv86 = 48
pFT_COND_VAR$ = 80
pTimeTimeout$ = 88
WaitForTransmission PROC

; 458  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 459  :     DWORD  dwWaitRetCode, dwWaitMilliSecs;
; 460  : 
; 461  :     // If the signal has already arrived (i.e. is still being transmitted)
; 462  :     // then there's no need to wait for it. Simply return success with the
; 463  :     // condition variable still locked...
; 464  : 
; 465  :     if ( IsEventSet ( pFT_COND_VAR->hSigXmitEvent ) )

  0000e	33 d2		 xor	 edx, edx
  00010	48 8b 44 24 50	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00015	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
  0001f	85 c0		 test	 eax, eax
  00021	75 07		 jne	 SHORT $LN5@WaitForTra

; 466  :     {
; 467  :         // There's no need to wait for the signal (transmission)
; 468  :         // to arrive because it's already been sent! Just return.
; 469  : 
; 470  :         return 0;           // (transmission received!)

  00023	33 c0		 xor	 eax, eax
  00025	e9 32 01 00 00	 jmp	 $LN1@WaitForTra
$LN5@WaitForTra:
$LN4@WaitForTra:

; 471  :     }
; 472  : 
; 473  :     // Our loop to wait for our transmission to arrive...
; 474  : 
; 475  :     do
; 476  :     {
; 477  :         // Release condition var lock (so signal (transmission) can
; 478  :         // be sent) and then wait for the signal (transmission)...
; 479  : 
; 480  :         MyLeaveCriticalSection ( &pFT_COND_VAR->CondVarLock );

  0002a	48 8b 44 24 50	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  0002f	48 8b c8	 mov	 rcx, rax
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 481  : 
; 482  :         // Need to calculate a timeout value if this is a
; 483  :         // timed condition wait as opposed to a normal wait...
; 484  : 
; 485  :         // Note that we unfortunately need to do this on each iteration
; 486  :         // because Window's wait API requires a relative timeout value
; 487  :         // rather than an absolute TOD timeout value like pthreads...
; 488  : 
; 489  :         if ( !pTimeTimeout )

  00038	48 83 7c 24 58
	00		 cmp	 QWORD PTR pTimeTimeout$[rsp], 0
  0003e	75 0d		 jne	 SHORT $LN6@WaitForTra

; 490  :         {
; 491  :             dwWaitMilliSecs = INFINITE;

  00040	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR dwWaitMilliSecs$[rsp], -1 ; ffffffffH

; 492  :         }

  00048	e9 94 00 00 00	 jmp	 $LN7@WaitForTra
$LN6@WaitForTra:

; 493  :         else
; 494  :         {
; 495  :             struct timeval  TimeNow;
; 496  : 
; 497  :             gettimeofday ( &TimeNow, NULL );

  0004d	33 d2		 xor	 edx, edx
  0004f	48 8d 4c 24 28	 lea	 rcx, QWORD PTR TimeNow$1[rsp]
  00054	e8 00 00 00 00	 call	 gettimeofday

; 498  : 
; 499  :             if (TimeNow.tv_sec >  pTimeTimeout->tv_sec
; 500  :                 ||

  00059	48 63 44 24 28	 movsxd	 rax, DWORD PTR TimeNow$1[rsp]
  0005e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pTimeTimeout$[rsp]
  00063	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  00066	7f 21		 jg	 SHORT $LN10@WaitForTra
  00068	48 63 44 24 28	 movsxd	 rax, DWORD PTR TimeNow$1[rsp]
  0006d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pTimeTimeout$[rsp]
  00072	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  00075	75 1c		 jne	 SHORT $LN8@WaitForTra
  00077	69 44 24 2c e8
	03 00 00	 imul	 eax, DWORD PTR TimeNow$1[rsp+4], 1000 ; 000003e8H
  0007f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pTimeTimeout$[rsp]
  00084	3b 41 08	 cmp	 eax, DWORD PTR [rcx+8]
  00087	7e 0a		 jle	 SHORT $LN8@WaitForTra
$LN10@WaitForTra:

; 501  :                 (
; 502  :                     TimeNow.tv_sec == pTimeTimeout->tv_sec
; 503  :                     &&
; 504  :                     (TimeNow.tv_usec * 1000) > pTimeTimeout->tv_nsec
; 505  :                 )
; 506  :             )
; 507  :             {
; 508  :                 dwWaitMilliSecs = 0;

  00089	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR dwWaitMilliSecs$[rsp], 0

; 509  :             }

  00091	eb 4e		 jmp	 SHORT $LN9@WaitForTra
$LN8@WaitForTra:

; 510  :             else
; 511  :             {
; 512  :                 dwWaitMilliSecs =

  00093	48 63 44 24 28	 movsxd	 rax, DWORD PTR TimeNow$1[rsp]
  00098	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pTimeTimeout$[rsp]
  0009d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000a0	48 2b c8	 sub	 rcx, rax
  000a3	48 8b c1	 mov	 rax, rcx
  000a6	48 69 c0 e8 03
	00 00		 imul	 rax, rax, 1000		; 000003e8H
  000ad	48 89 44 24 30	 mov	 QWORD PTR tv86[rsp], rax
  000b2	69 4c 24 2c e8
	03 00 00	 imul	 ecx, DWORD PTR TimeNow$1[rsp+4], 1000 ; 000003e8H
  000ba	48 8b 54 24 58	 mov	 rdx, QWORD PTR pTimeTimeout$[rsp]
  000bf	8b 52 08	 mov	 edx, DWORD PTR [rdx+8]
  000c2	2b d1		 sub	 edx, ecx
  000c4	8b ca		 mov	 ecx, edx
  000c6	8b c1		 mov	 eax, ecx
  000c8	99		 cdq
  000c9	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  000ce	f7 f9		 idiv	 ecx
  000d0	48 98		 cdqe
  000d2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv86[rsp]
  000d7	48 03 c8	 add	 rcx, rax
  000da	48 8b c1	 mov	 rax, rcx
  000dd	89 44 24 24	 mov	 DWORD PTR dwWaitMilliSecs$[rsp], eax
$LN9@WaitForTra:
$LN7@WaitForTra:

; 513  :                     ((pTimeTimeout->tv_sec - TimeNow.tv_sec) * 1000) +
; 514  :                     ((pTimeTimeout->tv_nsec - (TimeNow.tv_usec * 1000)) / 1000000);
; 515  :             }
; 516  :         }
; 517  : 
; 518  :         // Finally we get to do the actual wait...
; 519  : 
; 520  :         dwWaitRetCode =

  000e1	8b 54 24 24	 mov	 edx, DWORD PTR dwWaitMilliSecs$[rsp]
  000e5	48 8b 44 24 50	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  000ea	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
  000f4	89 44 24 20	 mov	 DWORD PTR dwWaitRetCode$[rsp], eax

; 521  :             MyWaitForSingleObject ( pFT_COND_VAR->hSigXmitEvent, dwWaitMilliSecs );
; 522  : 
; 523  :         // A signal (transmission) has been sent; reacquire our condition var lock
; 524  :         // and receive the transmission (if it's still being transmitted that is)...
; 525  : 
; 526  :         MyEnterCriticalSection ( &pFT_COND_VAR->CondVarLock );

  000f8	48 8b 44 24 50	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  000fd	48 8b c8	 mov	 rcx, rax
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 527  : 
; 528  :         // The "WAIT_OBJECT_0 == dwWaitRetCode && ..." clause in the below 'while'
; 529  :         // statement ensures that we will always break out of our wait loop whenever
; 530  :         // either a timeout occurs or our actual MyWaitForSingleObject call fails
; 531  :         // for any reason. As long as dwWaitRetCode is WAIT_OBJECT_0 though *AND*
; 532  :         // our event has still not been signaled yet, then we'll continue looping
; 533  :         // to wait for a signal (transmission) that we're supposed to receive...
; 534  : 
; 535  :         // Also note that one might at first think/ask: "Gee, Fish, why do we need
; 536  :         // to check to see if the condition variable's "hSigXmitEvent" event has
; 537  :         // been set each time (via the 'IsEventSet' macro)? Shouldn't it *always*
; 538  :         // be set if the above MyWaitForSingleObject call returns??" The answer is
; 539  :         // of course no, it might NOT [still] be signaled. This is because whenever
; 540  :         // someone *does* happen to signal it, we will of course be released from
; 541  :         // our wait (the above MyWaitForSingleObject call) BUT... someone else who
; 542  :         // was also waiting for it may have managed to grab our condition variable
; 543  :         // lock before we could and they could have reset it. Thus we need to check
; 544  :         // it again each time.
; 545  :     }
; 546  :     while ( WAIT_OBJECT_0 == dwWaitRetCode && !IsEventSet( pFT_COND_VAR->hSigXmitEvent ) );

  00106	83 7c 24 20 00	 cmp	 DWORD PTR dwWaitRetCode$[rsp], 0
  0010b	75 19		 jne	 SHORT $LN11@WaitForTra
  0010d	33 d2		 xor	 edx, edx
  0010f	48 8b 44 24 50	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00114	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
  0011e	85 c0		 test	 eax, eax
  00120	0f 85 04 ff ff
	ff		 jne	 $LN4@WaitForTra
$LN11@WaitForTra:

; 547  : 
; 548  :     // Our signal (transmission) has either [finally] arrived or else we got
; 549  :     // tired of waiting for it (i.e. we timed out) or else there was an error...
; 550  : 
; 551  :     if ( WAIT_OBJECT_0 == dwWaitRetCode ) return RC(0);

  00126	83 7c 24 20 00	 cmp	 DWORD PTR dwWaitRetCode$[rsp], 0
  0012b	75 04		 jne	 SHORT $LN12@WaitForTra
  0012d	33 c0		 xor	 eax, eax
  0012f	eb 2b		 jmp	 SHORT $LN1@WaitForTra
$LN12@WaitForTra:

; 552  :     if ( WAIT_TIMEOUT  == dwWaitRetCode ) return RC(ETIMEDOUT);

  00131	81 7c 24 20 02
	01 00 00	 cmp	 DWORD PTR dwWaitRetCode$[rsp], 258 ; 00000102H
  00139	75 07		 jne	 SHORT $LN13@WaitForTra
  0013b	b8 8a 00 00 00	 mov	 eax, 138		; 0000008aH
  00140	eb 1a		 jmp	 SHORT $LN1@WaitForTra
$LN13@WaitForTra:

; 553  : 
; 554  :     // Our wait failed! Something is VERY wrong! Maybe the condition variable
; 555  :     // was prematurely destroyed by someone? <shrug> In any case there's not
; 556  :     // much we can do about it other than log the fact that it occurred and
; 557  :     // return the error back to the caller. Their wait request has, believe
; 558  :     // it or not, actually been completed (although not as they expected it
; 559  :     // would in all likelihood!)...
; 560  : 
; 561  :     logmsg ( "fthreads: WaitForTransmission: MyWaitForSingleObject failed! dwWaitRetCode=%d (0x%8.8X)\n"

  00142	44 8b 44 24 20	 mov	 r8d, DWORD PTR dwWaitRetCode$[rsp]
  00147	8b 54 24 20	 mov	 edx, DWORD PTR dwWaitRetCode$[rsp]
  0014b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159371
  00152	e8 00 00 00 00	 call	 logmsg

; 562  :         ,dwWaitRetCode ,dwWaitRetCode );
; 563  : 
; 564  :     return RC(EFAULT);

  00157	b8 0e 00 00 00	 mov	 eax, 14
$LN1@WaitForTra:

; 565  : }

  0015c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00160	c3		 ret	 0
WaitForTransmission ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
rc$ = 32
pFT_MUTEX$ = 40
pFT_COND_VAR$ = 64
pFTUSER_MUTEX$ = 72
BeginWait PROC

; 327  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 328  :     int        rc;
; 329  :     FT_MUTEX*  pFT_MUTEX;
; 330  : 
; 331  :     if (0
; 332  :         || !pFT_COND_VAR                                          // (invalid ptr)
; 333  :         || !pFTUSER_MUTEX                                         // (invalid ptr)
; 334  :         || !(pFT_MUTEX = pFTUSER_MUTEX->hMutex)                   // (invalid ptr)

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 25		 jne	 SHORT $LN12@BeginWait
  00014	48 83 7c 24 40
	00		 cmp	 QWORD PTR pFT_COND_VAR$[rsp], 0
  0001a	74 1d		 je	 SHORT $LN12@BeginWait
  0001c	48 83 7c 24 48
	00		 cmp	 QWORD PTR pFTUSER_MUTEX$[rsp], 0
  00022	74 15		 je	 SHORT $LN12@BeginWait
  00024	48 8b 44 24 48	 mov	 rax, QWORD PTR pFTUSER_MUTEX$[rsp]
  00029	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002c	48 89 44 24 28	 mov	 QWORD PTR pFT_MUTEX$[rsp], rax
  00031	48 83 7c 24 28
	00		 cmp	 QWORD PTR pFT_MUTEX$[rsp], 0
  00037	75 0a		 jne	 SHORT $LN11@BeginWait
$LN12@BeginWait:

; 335  :     )
; 336  :         return RC(EINVAL);

  00039	b8 16 00 00 00	 mov	 eax, 22
  0003e	e9 67 01 00 00	 jmp	 $LN1@BeginWait
$LN11@BeginWait:

; 337  : 
; 338  :     if (0
; 339  :         ||  pFT_MUTEX    -> dwLockOwner  != GetCurrentThreadId()  // (mutex not owned)
; 340  :         ||  pFT_MUTEX    -> nLockedCount <= 0                     // (mutex not locked)

  00043	33 c0		 xor	 eax, eax
  00045	85 c0		 test	 eax, eax
  00047	75 1b		 jne	 SHORT $LN14@BeginWait
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  0004f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pFT_MUTEX$[rsp]
  00054	39 41 34	 cmp	 DWORD PTR [rcx+52], eax
  00057	75 0b		 jne	 SHORT $LN14@BeginWait
  00059	48 8b 44 24 28	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  0005e	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  00062	7f 0a		 jg	 SHORT $LN13@BeginWait
$LN14@BeginWait:

; 341  :     )
; 342  :         return RC(EPERM);

  00064	b8 01 00 00 00	 mov	 eax, 1
  00069	e9 3c 01 00 00	 jmp	 $LN1@BeginWait
$LN13@BeginWait:
$LN2@BeginWait:

; 343  : 
; 344  :     // First, acquire the fthreads condition variable lock...
; 345  : 
; 346  :     for (;;)
; 347  :     {
; 348  :         MyEnterCriticalSection ( &pFT_COND_VAR->CondVarLock );

  0006e	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00073	48 8b c8	 mov	 rcx, rax
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 349  : 
; 350  :         // It is always safe to proceed if the prior signal was completely
; 351  :         // processed (received by everyone who was supposed to receive it)
; 352  : 
; 353  :         if ( IsEventSet ( pFT_COND_VAR->hSigRecvdEvent ) )

  0007c	33 d2		 xor	 edx, edx
  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00083	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
  0008d	85 c0		 test	 eax, eax
  0008f	75 05		 jne	 SHORT $LN15@BeginWait

; 354  :             break;

  00091	e9 b5 00 00 00	 jmp	 $LN3@BeginWait
$LN15@BeginWait:
$LN7@BeginWait:

; 355  : 
; 356  :         // Prior signal not completely received yet... Verify that it is
; 357  :         // still being transmitted...
; 358  : 
; 359  :         ASSERT ( IsEventSet ( pFT_COND_VAR->hSigXmitEvent ) );

  00096	33 d2		 xor	 edx, edx
  00098	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  0009d	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
  000a7	85 c0		 test	 eax, eax
  000a9	74 5b		 je	 SHORT $LN16@BeginWait
$LN10@BeginWait:
  000ab	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159331
  000b2	41 b8 67 01 00
	00		 mov	 r8d, 359		; 00000167H
  000b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159332
  000bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159333
  000c6	e8 00 00 00 00	 call	 logmsg
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000d1	85 c0		 test	 eax, eax
  000d3	74 20		 je	 SHORT $LN17@BeginWait
  000d5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159335
  000dc	41 b8 67 01 00
	00		 mov	 r8d, 359		; 00000167H
  000e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159336
  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159337
  000f0	e8 00 00 00 00	 call	 DebuggerTrace
$LN17@BeginWait:
  000f5	33 c0		 xor	 eax, eax
  000f7	85 c0		 test	 eax, eax
  000f9	75 b0		 jne	 SHORT $LN10@BeginWait
  000fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00101	85 c0		 test	 eax, eax
  00103	74 01		 je	 SHORT $LN18@BeginWait
  00105	cc		 int	 3
$LN18@BeginWait:
$LN16@BeginWait:
  00106	33 c0		 xor	 eax, eax
  00108	85 c0		 test	 eax, eax
  0010a	75 8a		 jne	 SHORT $LN7@BeginWait

; 360  : 
; 361  :         // If no one is currently waiting to receive [this signal not yet
; 362  :         // completely received and still being transmitted], then we can
; 363  :         // go ahead and receive it right now *regardless* of what type of
; 364  :         // signal it is ("signal" or "broadcast") since we're *obviously*
; 365  :         // the one who is supposed to receive it (since we ARE trying to
; 366  :         // wait on it after all and it IS being transmitted. The 'xmit'
; 367  :         // event is *always* turned off once everyone [who is *supposed*
; 368  :         // to receive the signal] *has* received the signal. Thus, since
; 369  :         // it's still being transmitted, that means *not* everyone who
; 370  :         // *should* receive it *has* received it yet, and thus we can be
; 371  :         // absolutely certain that we indeed *should* therefore receive it
; 372  :         // since we *are* after all waiting for it).
; 373  : 
; 374  :         // Otherwise (prior signal not completely processed AND there are
; 375  :         // still others waiting to receive it too (as well as us)), then if
; 376  :         // it's a "broadcast" type signal, we can go ahead and receive that
; 377  :         // type of signal too as well (along with the others); we just came
; 378  :         // to the party a little bit late (but nevertheless in the nick of
; 379  :         // time!), that's all...
; 380  : 
; 381  :         if ( !pFT_COND_VAR->nNumWaiting || pFT_COND_VAR->bBroadcastSig )

  0010c	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00111	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00115	74 0b		 je	 SHORT $LN20@BeginWait
  00117	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  0011c	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  00120	74 02		 je	 SHORT $LN19@BeginWait
$LN20@BeginWait:

; 382  :             break;

  00122	eb 27		 jmp	 SHORT $LN3@BeginWait
$LN19@BeginWait:

; 383  : 
; 384  :         // Otherwise it's a "signal" type signal (and not a broadcast type)
; 385  :         // that hasn't been completely received yet, meaning only ONE thread
; 386  :         // should be released. Thus, since there's already a thread (or more
; 387  :         // than one thread) already waiting/trying to receive it, we need to
; 388  :         // let [one of] THEM receive it and NOT US. Thus we go back to sleep
; 389  :         // and wait for the signal processing currently in progress to finish
; 390  :         // releasing the proper number of threads first. Only once that has
; 391  :         // happened can we then be allowed to try and catch whatever signal
; 392  :         // happens to come along next...
; 393  : 
; 394  :         MyLeaveCriticalSection ( &pFT_COND_VAR->CondVarLock );

  00124	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00129	48 8b c8	 mov	 rcx, rax
  0012c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 395  : 
; 396  :         // (Programming Note: technically we should really be checking our
; 397  :         // return code from the below wait call too)
; 398  : 
; 399  :         MyWaitForSingleObject ( pFT_COND_VAR->hSigRecvdEvent, INFINITE );

  00132	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  00137	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  0013c	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00140	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject

; 400  :     }

  00146	e9 23 ff ff ff	 jmp	 $LN2@BeginWait
$LN3@BeginWait:

; 401  : 
; 402  :     // Register the caller's wait request while we still have control
; 403  :     // over this condition variable...
; 404  : 
; 405  :     pFT_COND_VAR->nNumWaiting++;        // (register wait request)

  0014b	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00150	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00153	ff c0		 inc	 eax
  00155	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pFT_COND_VAR$[rsp]
  0015a	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 406  : 
; 407  :     // Now release the original mutex and thus any potential signalers...
; 408  :     // (but note that no signal can actually ever be sent per se until
; 409  :     // the condition variable which we currently have locked is first
; 410  :     // released, which gets done in the WaitForTransmission function).
; 411  : 
; 412  :     if
; 413  :     (
; 414  :         (
; 415  :             rc = fthread_mutex_unlock
; 416  :             (
; 417  :                 pFTUSER_MUTEX
; 418  :             )
; 419  :         )
; 420  :         != 0

  0015d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pFTUSER_MUTEX$[rsp]
  00162	e8 00 00 00 00	 call	 fthread_mutex_unlock
  00167	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
  0016b	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00170	74 36		 je	 SHORT $LN21@BeginWait

; 421  :     )
; 422  :     {
; 423  :         // Oops! Something went wrong. We couldn't release the original
; 424  :         // caller's original mutex. Since we've already registered their
; 425  :         // wait and already have the condition variable locked, we need
; 426  :         // to first de-register their wait and release the condition var-
; 427  :         // iable lock before returning our error (i.e. we essentially
; 428  :         // need to back out what we previously did just above).
; 429  : 
; 430  :         logmsg("fthreads: BeginWait: fthread_mutex_unlock failed! rc=%d\n"

  00172	8b 54 24 20	 mov	 edx, DWORD PTR rc$[rsp]
  00176	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159342
  0017d	e8 00 00 00 00	 call	 logmsg

; 431  :             ,rc );
; 432  : 
; 433  :         pFT_COND_VAR->nNumWaiting--;    // (de-register wait request)

  00182	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00187	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0018a	ff c8		 dec	 eax
  0018c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pFT_COND_VAR$[rsp]
  00191	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 434  : 
; 435  :         MyLeaveCriticalSection ( &pFT_COND_VAR->CondVarLock );

  00194	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00199	48 8b c8	 mov	 rcx, rax
  0019c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 436  : 
; 437  :         return RC(rc);

  001a2	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  001a6	eb 02		 jmp	 SHORT $LN1@BeginWait
$LN21@BeginWait:

; 438  :     }
; 439  : 
; 440  :     // Our "begin-to-wait-on-condition-variable" task has been successfully
; 441  :     // completed. We have essentially atomically released the originally mutex
; 442  :     // and "begun our wait" on it (by registering the fact that there's someone
; 443  :     // wanting to wait on it). Return to OUR caller with the condition variable
; 444  :     // still locked (so no signals can be sent nor any threads released until
; 445  :     // our caller calls the below WaitForTransmission function)...
; 446  : 
; 447  :     return RC(0);   // (success)

  001a8	33 c0		 xor	 eax, eax
$LN1@BeginWait:

; 448  : }

  001aa	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001ae	c3		 ret	 0
BeginWait ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pFT_MUTEX$ = 48
LeaveFT_MUTEX PROC

; 284  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 285  :     if ( hostinfo.trycritsec_avail )

  00009	83 3d b0 01 00
	00 00		 cmp	 DWORD PTR hostinfo+432, 0
  00010	0f 84 a8 00 00
	00		 je	 $LN14@LeaveFT_MU
$LN4@LeaveFT_MU:

; 286  :     {
; 287  :         ASSERT ( pFT_MUTEX->nLockedCount > 0 );

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  0001b	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  0001f	7f 5b		 jg	 SHORT $LN16@LeaveFT_MU
$LN7@LeaveFT_MU:
  00021	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159284
  00028	41 b8 1f 01 00
	00		 mov	 r8d, 287		; 0000011fH
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159285
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159286
  0003c	e8 00 00 00 00	 call	 logmsg
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00047	85 c0		 test	 eax, eax
  00049	74 20		 je	 SHORT $LN17@LeaveFT_MU
  0004b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159288
  00052	41 b8 1f 01 00
	00		 mov	 r8d, 287		; 0000011fH
  00058	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159289
  0005f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159290
  00066	e8 00 00 00 00	 call	 DebuggerTrace
$LN17@LeaveFT_MU:
  0006b	33 c0		 xor	 eax, eax
  0006d	85 c0		 test	 eax, eax
  0006f	75 b0		 jne	 SHORT $LN7@LeaveFT_MU
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00077	85 c0		 test	 eax, eax
  00079	74 01		 je	 SHORT $LN18@LeaveFT_MU
  0007b	cc		 int	 3
$LN18@LeaveFT_MU:
$LN16@LeaveFT_MU:
  0007c	33 c0		 xor	 eax, eax
  0007e	85 c0		 test	 eax, eax
  00080	75 94		 jne	 SHORT $LN4@LeaveFT_MU

; 288  :         pFT_MUTEX->nLockedCount--;

  00082	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  00087	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  0008a	ff c8		 dec	 eax
  0008c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pFT_MUTEX$[rsp]
  00091	89 41 38	 mov	 DWORD PTR [rcx+56], eax

; 289  :         if ( pFT_MUTEX->nLockedCount <= 0 )

  00094	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  00099	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  0009d	7f 0c		 jg	 SHORT $LN19@LeaveFT_MU

; 290  :             pFT_MUTEX->dwLockOwner = 0;

  0009f	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  000a4	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [rax+52], 0
$LN19@LeaveFT_MU:

; 291  :         MyLeaveCriticalSection ( &pFT_MUTEX->MutexLock );

  000ab	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  000b0	48 8b c8	 mov	 rcx, rax
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 292  :     }

  000b9	e9 c0 00 00 00	 jmp	 $LN15@LeaveFT_MU
$LN14@LeaveFT_MU:

; 293  :     else
; 294  :     {
; 295  :         MyEnterCriticalSection ( &pFT_MUTEX->MutexLock );

  000be	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  000c3	48 8b c8	 mov	 rcx, rax
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
$LN10@LeaveFT_MU:

; 296  :         ASSERT ( pFT_MUTEX->nLockedCount > 0 );

  000cc	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  000d1	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  000d5	7f 5b		 jg	 SHORT $LN20@LeaveFT_MU
$LN13@LeaveFT_MU:
  000d7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159294
  000de	41 b8 28 01 00
	00		 mov	 r8d, 296		; 00000128H
  000e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159295
  000eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159296
  000f2	e8 00 00 00 00	 call	 logmsg
  000f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000fd	85 c0		 test	 eax, eax
  000ff	74 20		 je	 SHORT $LN21@LeaveFT_MU
  00101	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159298
  00108	41 b8 28 01 00
	00		 mov	 r8d, 296		; 00000128H
  0010e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159299
  00115	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159300
  0011c	e8 00 00 00 00	 call	 DebuggerTrace
$LN21@LeaveFT_MU:
  00121	33 c0		 xor	 eax, eax
  00123	85 c0		 test	 eax, eax
  00125	75 b0		 jne	 SHORT $LN13@LeaveFT_MU
  00127	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0012d	85 c0		 test	 eax, eax
  0012f	74 01		 je	 SHORT $LN22@LeaveFT_MU
  00131	cc		 int	 3
$LN22@LeaveFT_MU:
$LN20@LeaveFT_MU:
  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	75 94		 jne	 SHORT $LN10@LeaveFT_MU

; 297  :         pFT_MUTEX->nLockedCount--;

  00138	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  0013d	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00140	ff c8		 dec	 eax
  00142	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pFT_MUTEX$[rsp]
  00147	89 41 38	 mov	 DWORD PTR [rcx+56], eax

; 298  :         if ( pFT_MUTEX->nLockedCount <= 0 )

  0014a	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  0014f	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  00153	7f 1b		 jg	 SHORT $LN23@LeaveFT_MU

; 299  :         {
; 300  :             pFT_MUTEX->dwLockOwner = 0;

  00155	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  0015a	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [rax+52], 0

; 301  :             MySetEvent ( pFT_MUTEX->hUnlockedEvent );

  00161	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  00166	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  0016a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetEvent
$LN23@LeaveFT_MU:

; 302  :         }
; 303  :         MyLeaveCriticalSection ( &pFT_MUTEX->MutexLock );

  00170	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  00175	48 8b c8	 mov	 rcx, rax
  00178	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
$LN15@LeaveFT_MU:

; 304  :     }
; 305  : }

  0017e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00182	c3		 ret	 0
LeaveFT_MUTEX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
dwThreadId$ = 32
pFT_MUTEX$ = 64
EnterFT_MUTEX PROC

; 249  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 250  :     DWORD  dwThreadId = GetCurrentThreadId();

  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  0000f	89 44 24 20	 mov	 DWORD PTR dwThreadId$[rsp], eax

; 251  : 
; 252  :     if ( hostinfo.trycritsec_avail )

  00013	83 3d b0 01 00
	00 00		 cmp	 DWORD PTR hostinfo+432, 0
  0001a	0f 84 9d 00 00
	00		 je	 $LN23@EnterFT_MU

; 253  :     {
; 254  :         MyEnterCriticalSection ( &pFT_MUTEX->MutexLock );

  00020	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  00025	48 8b c8	 mov	 rcx, rax
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 255  :         pFT_MUTEX->dwLockOwner = dwThreadId;

  0002e	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  00033	8b 4c 24 20	 mov	 ecx, DWORD PTR dwThreadId$[rsp]
  00037	89 48 34	 mov	 DWORD PTR [rax+52], ecx

; 256  :         pFT_MUTEX->nLockedCount++;

  0003a	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  0003f	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00042	ff c0		 inc	 eax
  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pFT_MUTEX$[rsp]
  00049	89 41 38	 mov	 DWORD PTR [rcx+56], eax
$LN4@EnterFT_MU:

; 257  :         ASSERT ( pFT_MUTEX->nLockedCount > 0 );

  0004c	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  00051	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  00055	7f 5b		 jg	 SHORT $LN25@EnterFT_MU
$LN7@EnterFT_MU:
  00057	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159234
  0005e	41 b8 01 01 00
	00		 mov	 r8d, 257		; 00000101H
  00064	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159235
  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159236
  00072	e8 00 00 00 00	 call	 logmsg
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0007d	85 c0		 test	 eax, eax
  0007f	74 20		 je	 SHORT $LN26@EnterFT_MU
  00081	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159238
  00088	41 b8 01 01 00
	00		 mov	 r8d, 257		; 00000101H
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159239
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159240
  0009c	e8 00 00 00 00	 call	 DebuggerTrace
$LN26@EnterFT_MU:
  000a1	33 c0		 xor	 eax, eax
  000a3	85 c0		 test	 eax, eax
  000a5	75 b0		 jne	 SHORT $LN7@EnterFT_MU
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000ad	85 c0		 test	 eax, eax
  000af	74 01		 je	 SHORT $LN27@EnterFT_MU
  000b1	cc		 int	 3
$LN27@EnterFT_MU:
$LN25@EnterFT_MU:
  000b2	33 c0		 xor	 eax, eax
  000b4	85 c0		 test	 eax, eax
  000b6	75 94		 jne	 SHORT $LN4@EnterFT_MU

; 258  :     }

  000b8	e9 63 01 00 00	 jmp	 $LN24@EnterFT_MU
$LN23@EnterFT_MU:
$LN8@EnterFT_MU:

; 259  :     else
; 260  :     {
; 261  :         for (;;)
; 262  :         {
; 263  :             MyEnterCriticalSection ( &pFT_MUTEX->MutexLock );

  000bd	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  000c2	48 8b c8	 mov	 rcx, rax
  000c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
$LN13@EnterFT_MU:

; 264  :             ASSERT ( pFT_MUTEX->nLockedCount >= 0 );

  000cb	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  000d0	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  000d4	7d 5b		 jge	 SHORT $LN28@EnterFT_MU
$LN16@EnterFT_MU:
  000d6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159243
  000dd	41 b8 08 01 00
	00		 mov	 r8d, 264		; 00000108H
  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159244
  000ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159245
  000f1	e8 00 00 00 00	 call	 logmsg
  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000fc	85 c0		 test	 eax, eax
  000fe	74 20		 je	 SHORT $LN29@EnterFT_MU
  00100	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159247
  00107	41 b8 08 01 00
	00		 mov	 r8d, 264		; 00000108H
  0010d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159248
  00114	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159249
  0011b	e8 00 00 00 00	 call	 DebuggerTrace
$LN29@EnterFT_MU:
  00120	33 c0		 xor	 eax, eax
  00122	85 c0		 test	 eax, eax
  00124	75 b0		 jne	 SHORT $LN16@EnterFT_MU
  00126	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0012c	85 c0		 test	 eax, eax
  0012e	74 01		 je	 SHORT $LN30@EnterFT_MU
  00130	cc		 int	 3
$LN30@EnterFT_MU:
$LN28@EnterFT_MU:
  00131	33 c0		 xor	 eax, eax
  00133	85 c0		 test	 eax, eax
  00135	75 94		 jne	 SHORT $LN13@EnterFT_MU

; 265  :             if ( pFT_MUTEX->nLockedCount <= 0 || pFT_MUTEX->dwLockOwner == dwThreadId ) break;

  00137	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  0013c	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  00140	7e 0e		 jle	 SHORT $LN32@EnterFT_MU
  00142	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  00147	8b 4c 24 20	 mov	 ecx, DWORD PTR dwThreadId$[rsp]
  0014b	39 48 34	 cmp	 DWORD PTR [rax+52], ecx
  0014e	75 02		 jne	 SHORT $LN31@EnterFT_MU
$LN32@EnterFT_MU:
  00150	eb 27		 jmp	 SHORT $LN9@EnterFT_MU
$LN31@EnterFT_MU:

; 266  :             MyLeaveCriticalSection ( &pFT_MUTEX->MutexLock );

  00152	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  00157	48 8b c8	 mov	 rcx, rax
  0015a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 267  :             MyWaitForSingleObject ( pFT_MUTEX->hUnlockedEvent, INFINITE );

  00160	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  00165	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  0016a	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  0016e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject

; 268  :         }

  00174	e9 44 ff ff ff	 jmp	 $LN8@EnterFT_MU
$LN9@EnterFT_MU:

; 269  : 
; 270  :         MyResetEvent ( pFT_MUTEX->hUnlockedEvent );

  00179	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  0017e	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00182	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ResetEvent

; 271  :         pFT_MUTEX->dwLockOwner = dwThreadId;

  00188	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  0018d	8b 4c 24 20	 mov	 ecx, DWORD PTR dwThreadId$[rsp]
  00191	89 48 34	 mov	 DWORD PTR [rax+52], ecx

; 272  :         pFT_MUTEX->nLockedCount++;

  00194	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  00199	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  0019c	ff c0		 inc	 eax
  0019e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pFT_MUTEX$[rsp]
  001a3	89 41 38	 mov	 DWORD PTR [rcx+56], eax
$LN19@EnterFT_MU:

; 273  :         ASSERT ( pFT_MUTEX->nLockedCount > 0 );

  001a6	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  001ab	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  001af	7f 5b		 jg	 SHORT $LN33@EnterFT_MU
$LN22@EnterFT_MU:
  001b1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159254
  001b8	41 b8 11 01 00
	00		 mov	 r8d, 273		; 00000111H
  001be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159255
  001c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159256
  001cc	e8 00 00 00 00	 call	 logmsg
  001d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001d7	85 c0		 test	 eax, eax
  001d9	74 20		 je	 SHORT $LN34@EnterFT_MU
  001db	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159258
  001e2	41 b8 11 01 00
	00		 mov	 r8d, 273		; 00000111H
  001e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159259
  001ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159260
  001f6	e8 00 00 00 00	 call	 DebuggerTrace
$LN34@EnterFT_MU:
  001fb	33 c0		 xor	 eax, eax
  001fd	85 c0		 test	 eax, eax
  001ff	75 b0		 jne	 SHORT $LN22@EnterFT_MU
  00201	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00207	85 c0		 test	 eax, eax
  00209	74 01		 je	 SHORT $LN35@EnterFT_MU
  0020b	cc		 int	 3
$LN35@EnterFT_MU:
$LN33@EnterFT_MU:
  0020c	33 c0		 xor	 eax, eax
  0020e	85 c0		 test	 eax, eax
  00210	75 94		 jne	 SHORT $LN19@EnterFT_MU

; 274  :         MyLeaveCriticalSection ( &pFT_MUTEX->MutexLock );

  00212	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  00217	48 8b c8	 mov	 rcx, rax
  0021a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
$LN24@EnterFT_MU:

; 275  :     }
; 276  : }

  00220	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00224	c3		 ret	 0
EnterFT_MUTEX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
bSuccess$ = 32
dwThreadId$ = 36
tv145 = 40
pFT_MUTEX$ = 64
TryEnterFT_MUTEX PROC

; 206  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 207  :     BOOL   bSuccess;
; 208  :     DWORD  dwThreadId = GetCurrentThreadId();

  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  0000f	89 44 24 24	 mov	 DWORD PTR dwThreadId$[rsp], eax

; 209  : 
; 210  :     if ( hostinfo.trycritsec_avail )

  00013	83 3d b0 01 00
	00 00		 cmp	 DWORD PTR hostinfo+432, 0
  0001a	0f 84 ac 00 00
	00		 je	 $LN20@TryEnterFT

; 211  :     {
; 212  :         bSuccess = MyTryEnterCriticalSection ( &pFT_MUTEX->MutexLock );

  00020	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  00025	48 8b c8	 mov	 rcx, rax
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_TryEnterCriticalSection
  0002e	89 44 24 20	 mov	 DWORD PTR bSuccess$[rsp], eax

; 213  : 
; 214  :         if ( bSuccess )

  00032	83 7c 24 20 00	 cmp	 DWORD PTR bSuccess$[rsp], 0
  00037	0f 84 8a 00 00
	00		 je	 $LN22@TryEnterFT

; 215  :         {
; 216  :             pFT_MUTEX->nLockedCount++;

  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  00042	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00045	ff c0		 inc	 eax
  00047	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pFT_MUTEX$[rsp]
  0004c	89 41 38	 mov	 DWORD PTR [rcx+56], eax
$LN4@TryEnterFT:

; 217  :             ASSERT( pFT_MUTEX->nLockedCount > 0 );

  0004f	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  00054	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  00058	7f 5b		 jg	 SHORT $LN23@TryEnterFT
$LN7@TryEnterFT:
  0005a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159174
  00061	41 b8 d9 00 00
	00		 mov	 r8d, 217		; 000000d9H
  00067	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159175
  0006e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159176
  00075	e8 00 00 00 00	 call	 logmsg
  0007a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00080	85 c0		 test	 eax, eax
  00082	74 20		 je	 SHORT $LN24@TryEnterFT
  00084	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159178
  0008b	41 b8 d9 00 00
	00		 mov	 r8d, 217		; 000000d9H
  00091	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159179
  00098	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159180
  0009f	e8 00 00 00 00	 call	 DebuggerTrace
$LN24@TryEnterFT:
  000a4	33 c0		 xor	 eax, eax
  000a6	85 c0		 test	 eax, eax
  000a8	75 b0		 jne	 SHORT $LN7@TryEnterFT
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000b0	85 c0		 test	 eax, eax
  000b2	74 01		 je	 SHORT $LN25@TryEnterFT
  000b4	cc		 int	 3
$LN25@TryEnterFT:
$LN23@TryEnterFT:
  000b5	33 c0		 xor	 eax, eax
  000b7	85 c0		 test	 eax, eax
  000b9	75 94		 jne	 SHORT $LN4@TryEnterFT

; 218  :             pFT_MUTEX->dwLockOwner = dwThreadId;

  000bb	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  000c0	8b 4c 24 24	 mov	 ecx, DWORD PTR dwThreadId$[rsp]
  000c4	89 48 34	 mov	 DWORD PTR [rax+52], ecx
$LN22@TryEnterFT:

; 219  :         }
; 220  :     }

  000c7	e9 5f 01 00 00	 jmp	 $LN21@TryEnterFT
$LN20@TryEnterFT:

; 221  :     else
; 222  :     {
; 223  :         MyEnterCriticalSection ( &pFT_MUTEX->MutexLock );

  000cc	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  000d1	48 8b c8	 mov	 rcx, rax
  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
$LN10@TryEnterFT:

; 224  : 
; 225  :         ASSERT ( pFT_MUTEX->nLockedCount >= 0 );

  000da	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  000df	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  000e3	7d 5b		 jge	 SHORT $LN26@TryEnterFT
$LN13@TryEnterFT:
  000e5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159183
  000ec	41 b8 e1 00 00
	00		 mov	 r8d, 225		; 000000e1H
  000f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159184
  000f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159185
  00100	e8 00 00 00 00	 call	 logmsg
  00105	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0010b	85 c0		 test	 eax, eax
  0010d	74 20		 je	 SHORT $LN27@TryEnterFT
  0010f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159187
  00116	41 b8 e1 00 00
	00		 mov	 r8d, 225		; 000000e1H
  0011c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159188
  00123	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159189
  0012a	e8 00 00 00 00	 call	 DebuggerTrace
$LN27@TryEnterFT:
  0012f	33 c0		 xor	 eax, eax
  00131	85 c0		 test	 eax, eax
  00133	75 b0		 jne	 SHORT $LN13@TryEnterFT
  00135	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0013b	85 c0		 test	 eax, eax
  0013d	74 01		 je	 SHORT $LN28@TryEnterFT
  0013f	cc		 int	 3
$LN28@TryEnterFT:
$LN26@TryEnterFT:
  00140	33 c0		 xor	 eax, eax
  00142	85 c0		 test	 eax, eax
  00144	75 94		 jne	 SHORT $LN10@TryEnterFT

; 226  : 
; 227  :         bSuccess = ( pFT_MUTEX->nLockedCount <= 0 || pFT_MUTEX->dwLockOwner == dwThreadId );

  00146	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  0014b	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  0014f	7e 18		 jle	 SHORT $LN34@TryEnterFT
  00151	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  00156	8b 4c 24 24	 mov	 ecx, DWORD PTR dwThreadId$[rsp]
  0015a	39 48 34	 cmp	 DWORD PTR [rax+52], ecx
  0015d	74 0a		 je	 SHORT $LN34@TryEnterFT
  0015f	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
  00167	eb 08		 jmp	 SHORT $LN35@TryEnterFT
$LN34@TryEnterFT:
  00169	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv145[rsp], 1
$LN35@TryEnterFT:
  00171	8b 44 24 28	 mov	 eax, DWORD PTR tv145[rsp]
  00175	89 44 24 20	 mov	 DWORD PTR bSuccess$[rsp], eax

; 228  : 
; 229  :         if ( bSuccess )

  00179	83 7c 24 20 00	 cmp	 DWORD PTR bSuccess$[rsp], 0
  0017e	0f 84 99 00 00
	00		 je	 $LN29@TryEnterFT

; 230  :         {
; 231  :             pFT_MUTEX->nLockedCount++;

  00184	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  00189	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  0018c	ff c0		 inc	 eax
  0018e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pFT_MUTEX$[rsp]
  00193	89 41 38	 mov	 DWORD PTR [rcx+56], eax
$LN16@TryEnterFT:

; 232  :             ASSERT ( pFT_MUTEX->nLockedCount > 0 );

  00196	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  0019b	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  0019f	7f 5b		 jg	 SHORT $LN30@TryEnterFT
$LN19@TryEnterFT:
  001a1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159193
  001a8	41 b8 e8 00 00
	00		 mov	 r8d, 232		; 000000e8H
  001ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159194
  001b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159195
  001bc	e8 00 00 00 00	 call	 logmsg
  001c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001c7	85 c0		 test	 eax, eax
  001c9	74 20		 je	 SHORT $LN31@TryEnterFT
  001cb	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159197
  001d2	41 b8 e8 00 00
	00		 mov	 r8d, 232		; 000000e8H
  001d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159198
  001df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159199
  001e6	e8 00 00 00 00	 call	 DebuggerTrace
$LN31@TryEnterFT:
  001eb	33 c0		 xor	 eax, eax
  001ed	85 c0		 test	 eax, eax
  001ef	75 b0		 jne	 SHORT $LN19@TryEnterFT
  001f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001f7	85 c0		 test	 eax, eax
  001f9	74 01		 je	 SHORT $LN32@TryEnterFT
  001fb	cc		 int	 3
$LN32@TryEnterFT:
$LN30@TryEnterFT:
  001fc	33 c0		 xor	 eax, eax
  001fe	85 c0		 test	 eax, eax
  00200	75 94		 jne	 SHORT $LN16@TryEnterFT

; 233  :             pFT_MUTEX->dwLockOwner = dwThreadId;

  00202	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  00207	8b 4c 24 24	 mov	 ecx, DWORD PTR dwThreadId$[rsp]
  0020b	89 48 34	 mov	 DWORD PTR [rax+52], ecx

; 234  :             MyResetEvent ( pFT_MUTEX->hUnlockedEvent );

  0020e	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  00213	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00217	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ResetEvent
$LN29@TryEnterFT:

; 235  :         }
; 236  : 
; 237  :         MyLeaveCriticalSection ( &pFT_MUTEX->MutexLock );

  0021d	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  00222	48 8b c8	 mov	 rcx, rax
  00225	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
$LN21@TryEnterFT:

; 238  :     }
; 239  : 
; 240  :     return bSuccess;

  0022b	8b 44 24 20	 mov	 eax, DWORD PTR bSuccess$[rsp]

; 241  : }

  0022f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00233	c3		 ret	 0
TryEnterFT_MUTEX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pFT_COND_VAR$ = 48
UninitializeFT_COND_VAR PROC

; 182  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 183  :     if (0
; 184  :         ||  pFT_COND_VAR->nNumWaiting
; 185  :         ||  IsEventSet ( pFT_COND_VAR->hSigXmitEvent  )
; 186  :         || !IsEventSet ( pFT_COND_VAR->hSigRecvdEvent )

  0000a	33 c0		 xor	 eax, eax
  0000c	85 c0		 test	 eax, eax
  0000e	75 35		 jne	 SHORT $LN3@Uninitiali
  00010	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00015	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00019	75 2a		 jne	 SHORT $LN3@Uninitiali
  0001b	33 d2		 xor	 edx, edx
  0001d	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00022	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
  0002c	85 c0		 test	 eax, eax
  0002e	74 15		 je	 SHORT $LN3@Uninitiali
  00030	33 d2		 xor	 edx, edx
  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00037	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
  00041	85 c0		 test	 eax, eax
  00043	74 04		 je	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 187  :     )
; 188  :         return FALSE;

  00045	33 c0		 xor	 eax, eax
  00047	eb 42		 jmp	 SHORT $LN1@Uninitiali
$LN2@Uninitiali:

; 189  : 
; 190  :     MyDeleteEvent ( pFT_COND_VAR->hSigXmitEvent  );

  00049	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  0004e	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 191  :     MyDeleteEvent ( pFT_COND_VAR->hSigRecvdEvent );

  00058	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  0005d	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 192  : 
; 193  :     MyDeleteCriticalSection ( &pFT_COND_VAR->CondVarLock );

  00067	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  0006c	48 8b c8	 mov	 rcx, rax
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeleteCriticalSection

; 194  : 
; 195  :     memset ( pFT_COND_VAR, 0xCD, sizeof ( FT_COND_VAR ) );

  00075	48 8b 7c 24 30	 mov	 rdi, QWORD PTR pFT_COND_VAR$[rsp]
  0007a	b8 cd 00 00 00	 mov	 eax, 205		; 000000cdH
  0007f	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00084	f3 aa		 rep stosb

; 196  : 
; 197  :     return TRUE;

  00086	b8 01 00 00 00	 mov	 eax, 1
$LN1@Uninitiali:

; 198  : }

  0008b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008f	5f		 pop	 rdi
  00090	c3		 ret	 0
UninitializeFT_COND_VAR ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
tv65 = 32
tv72 = 40
pFT_COND_VAR$ = 64
InitializeFT_COND_VAR PROC

; 153  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 154  :     if ( ( pFT_COND_VAR->hSigXmitEvent = MyCreateEvent ( NULL, TRUE, FALSE, NULL ) ) )

  0000a	45 33 c9	 xor	 r9d, r9d
  0000d	45 33 c0	 xor	 r8d, r8d
  00010	ba 01 00 00 00	 mov	 edx, 1
  00015	33 c9		 xor	 ecx, ecx
  00017	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateEventA
  0001d	48 89 44 24 20	 mov	 QWORD PTR tv65[rsp], rax
  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00027	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv65[rsp]
  0002c	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx
  00030	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv65[rsp], 0
  00036	74 72		 je	 SHORT $LN2@Initialize

; 155  :     {
; 156  :         // Note: hSigRecvdEvent created initially signaled
; 157  : 
; 158  :         if ( ( pFT_COND_VAR->hSigRecvdEvent = MyCreateEvent ( NULL, TRUE, TRUE, NULL ) ) )

  00038	45 33 c9	 xor	 r9d, r9d
  0003b	41 b8 01 00 00
	00		 mov	 r8d, 1
  00041	ba 01 00 00 00	 mov	 edx, 1
  00046	33 c9		 xor	 ecx, ecx
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateEventA
  0004e	48 89 44 24 28	 mov	 QWORD PTR tv72[rsp], rax
  00053	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00058	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv72[rsp]
  0005d	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx
  00061	48 83 7c 24 28
	00		 cmp	 QWORD PTR tv72[rsp], 0
  00067	74 32		 je	 SHORT $LN3@Initialize

; 159  :         {
; 160  :             MyInitializeCriticalSection ( &pFT_COND_VAR->CondVarLock );

  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  0006e	ba b8 0b 00 00	 mov	 edx, 3000		; 00000bb8H
  00073	48 8b c8	 mov	 rcx, rax
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InitializeCriticalSectionAndSpinCount

; 161  : 
; 162  :             pFT_COND_VAR->bBroadcastSig = FALSE;

  0007c	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00081	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0

; 163  :             pFT_COND_VAR->nNumWaiting   = 0;

  00088	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  0008d	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [rax+60], 0

; 164  : 
; 165  :             return TRUE;

  00094	b8 01 00 00 00	 mov	 eax, 1
  00099	eb 22		 jmp	 SHORT $LN1@Initialize
$LN3@Initialize:

; 166  :         }
; 167  : 
; 168  :         MyDeleteEvent ( pFT_COND_VAR->hSigXmitEvent );

  0009b	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  000a0	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
$LN2@Initialize:

; 169  :     }
; 170  : 
; 171  :     memset ( pFT_COND_VAR, 0xCD, sizeof ( FT_COND_VAR ) );

  000aa	48 8b 7c 24 40	 mov	 rdi, QWORD PTR pFT_COND_VAR$[rsp]
  000af	b8 cd 00 00 00	 mov	 eax, 205		; 000000cdH
  000b4	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000b9	f3 aa		 rep stosb

; 172  : 
; 173  :     return FALSE;

  000bb	33 c0		 xor	 eax, eax
$LN1@Initialize:

; 174  : }

  000bd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c1	5f		 pop	 rdi
  000c2	c3		 ret	 0
InitializeFT_COND_VAR ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pFT_COND_VAR$ = 32
MallocFT_COND_VAR PROC

; 140  : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 141  :     FT_COND_VAR*  pFT_COND_VAR = (FT_COND_VAR*) malloc ( sizeof ( FT_COND_VAR ) );

  00006	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0000b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00011	48 89 44 24 20	 mov	 QWORD PTR pFT_COND_VAR$[rsp], rax

; 142  :     if ( !pFT_COND_VAR ) return NULL;

  00016	48 83 7c 24 20
	00		 cmp	 QWORD PTR pFT_COND_VAR$[rsp], 0
  0001c	75 04		 jne	 SHORT $LN2@MallocFT_C
  0001e	33 c0		 xor	 eax, eax
  00020	eb 16		 jmp	 SHORT $LN1@MallocFT_C
$LN2@MallocFT_C:

; 143  :     memset ( pFT_COND_VAR, 0xCD, sizeof ( FT_COND_VAR ) );

  00022	48 8b 7c 24 20	 mov	 rdi, QWORD PTR pFT_COND_VAR$[rsp]
  00027	b8 cd 00 00 00	 mov	 eax, 205		; 000000cdH
  0002c	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00031	f3 aa		 rep stosb

; 144  :     return pFT_COND_VAR;

  00033	48 8b 44 24 20	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
$LN1@MallocFT_C:

; 145  : }

  00038	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003c	5f		 pop	 rdi
  0003d	c3		 ret	 0
MallocFT_COND_VAR ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pFT_MUTEX$ = 48
UninitializeFT_MUTEX PROC

; 123  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 124  :     if ( pFT_MUTEX->nLockedCount > 0 )

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  0000f	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  00013	7e 07		 jle	 SHORT $LN8@Uninitiali

; 125  :         return FALSE;   // (still in use)

  00015	33 c0		 xor	 eax, eax
  00017	e9 a9 00 00 00	 jmp	 $LN1@Uninitiali
$LN8@Uninitiali:
$LN4@Uninitiali:

; 126  : 
; 127  :     ASSERT( IsEventSet ( pFT_MUTEX->hUnlockedEvent ) );

  0001c	33 d2		 xor	 edx, edx
  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  00023	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
  0002d	85 c0		 test	 eax, eax
  0002f	74 5b		 je	 SHORT $LN9@Uninitiali
$LN7@Uninitiali:
  00031	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159105
  00038	41 b8 7f 00 00
	00		 mov	 r8d, 127		; 0000007fH
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159106
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159107
  0004c	e8 00 00 00 00	 call	 logmsg
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00057	85 c0		 test	 eax, eax
  00059	74 20		 je	 SHORT $LN10@Uninitiali
  0005b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159109
  00062	41 b8 7f 00 00
	00		 mov	 r8d, 127		; 0000007fH
  00068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159110
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159111
  00076	e8 00 00 00 00	 call	 DebuggerTrace
$LN10@Uninitiali:
  0007b	33 c0		 xor	 eax, eax
  0007d	85 c0		 test	 eax, eax
  0007f	75 b0		 jne	 SHORT $LN7@Uninitiali
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00087	85 c0		 test	 eax, eax
  00089	74 01		 je	 SHORT $LN11@Uninitiali
  0008b	cc		 int	 3
$LN11@Uninitiali:
$LN9@Uninitiali:
  0008c	33 c0		 xor	 eax, eax
  0008e	85 c0		 test	 eax, eax
  00090	75 8a		 jne	 SHORT $LN4@Uninitiali

; 128  : 
; 129  :     MyDeleteEvent ( pFT_MUTEX->hUnlockedEvent );

  00092	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  00097	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 130  :     MyDeleteCriticalSection ( &pFT_MUTEX->MutexLock );

  000a1	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  000a6	48 8b c8	 mov	 rcx, rax
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeleteCriticalSection

; 131  : 
; 132  :     memset ( pFT_MUTEX, 0xCD, sizeof ( FT_MUTEX ) );

  000af	48 8b 7c 24 30	 mov	 rdi, QWORD PTR pFT_MUTEX$[rsp]
  000b4	b8 cd 00 00 00	 mov	 eax, 205		; 000000cdH
  000b9	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000be	f3 aa		 rep stosb

; 133  : 
; 134  :     return TRUE;

  000c0	b8 01 00 00 00	 mov	 eax, 1
$LN1@Uninitiali:

; 135  : }

  000c5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c9	5f		 pop	 rdi
  000ca	c3		 ret	 0
UninitializeFT_MUTEX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
tv65 = 32
pFT_MUTEX$ = 64
dwMutexType$ = 72
InitializeFT_MUTEX PROC

; 99   : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 100  :     // Note: UnlockedEvent created initially signalled
; 101  : 
; 102  :     if ( !(pFT_MUTEX->hUnlockedEvent = MyCreateEvent ( NULL, TRUE, TRUE, NULL )) )

  0000e	45 33 c9	 xor	 r9d, r9d
  00011	41 b8 01 00 00
	00		 mov	 r8d, 1
  00017	ba 01 00 00 00	 mov	 edx, 1
  0001c	33 c9		 xor	 ecx, ecx
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateEventA
  00024	48 89 44 24 20	 mov	 QWORD PTR tv65[rsp], rax
  00029	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  0002e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv65[rsp]
  00033	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx
  00037	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv65[rsp], 0
  0003d	75 15		 jne	 SHORT $LN2@Initialize

; 103  :     {
; 104  :         memset ( pFT_MUTEX, 0xCD, sizeof ( FT_MUTEX ) );

  0003f	48 8b 7c 24 40	 mov	 rdi, QWORD PTR pFT_MUTEX$[rsp]
  00044	b8 cd 00 00 00	 mov	 eax, 205		; 000000cdH
  00049	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0004e	f3 aa		 rep stosb

; 105  :         return FALSE;

  00050	33 c0		 xor	 eax, eax
  00052	eb 3c		 jmp	 SHORT $LN1@Initialize
$LN2@Initialize:

; 106  :     }
; 107  : 
; 108  :     MyInitializeCriticalSection ( &pFT_MUTEX->MutexLock );

  00054	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  00059	ba b8 0b 00 00	 mov	 edx, 3000		; 00000bb8H
  0005e	48 8b c8	 mov	 rcx, rax
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InitializeCriticalSectionAndSpinCount

; 109  : 
; 110  :     pFT_MUTEX->dwMutexType    = dwMutexType;

  00067	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  0006c	8b 4c 24 48	 mov	 ecx, DWORD PTR dwMutexType$[rsp]
  00070	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 111  :     pFT_MUTEX->dwLockOwner    = 0;

  00073	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  00078	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [rax+52], 0

; 112  :     pFT_MUTEX->nLockedCount   = 0;

  0007f	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
  00084	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0

; 113  : 
; 114  :     return TRUE;

  0008b	b8 01 00 00 00	 mov	 eax, 1
$LN1@Initialize:

; 115  : }

  00090	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00094	5f		 pop	 rdi
  00095	c3		 ret	 0
InitializeFT_MUTEX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pFT_MUTEX$ = 32
MallocFT_MUTEX PROC

; 85   : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 86   :     FT_MUTEX*  pFT_MUTEX = (FT_MUTEX*) malloc ( sizeof ( FT_MUTEX ) );

  00006	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0000b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00011	48 89 44 24 20	 mov	 QWORD PTR pFT_MUTEX$[rsp], rax

; 87   :     if ( !pFT_MUTEX ) return NULL;

  00016	48 83 7c 24 20
	00		 cmp	 QWORD PTR pFT_MUTEX$[rsp], 0
  0001c	75 04		 jne	 SHORT $LN2@MallocFT_M
  0001e	33 c0		 xor	 eax, eax
  00020	eb 16		 jmp	 SHORT $LN1@MallocFT_M
$LN2@MallocFT_M:

; 88   :     memset ( pFT_MUTEX, 0xCD, sizeof ( FT_MUTEX ) );

  00022	48 8b 7c 24 20	 mov	 rdi, QWORD PTR pFT_MUTEX$[rsp]
  00027	b8 cd 00 00 00	 mov	 eax, 205		; 000000cdH
  0002c	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00031	f3 aa		 rep stosb

; 89   :     return pFT_MUTEX;

  00033	48 8b 44 24 20	 mov	 rax, QWORD PTR pFT_MUTEX$[rsp]
$LN1@MallocFT_M:

; 90   : }

  00038	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003c	5f		 pop	 rdi
  0003d	c3		 ret	 0
MallocFT_MUTEX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
tv67 = 0
dwMutexType$ = 32
IsValidMutexType PROC

; 73   : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 74   :     return (0

  00008	33 c0		 xor	 eax, eax
  0000a	85 c0		 test	 eax, eax
  0000c	75 1d		 jne	 SHORT $LN3@IsValidMut
  0000e	81 7c 24 20 79
	6e 61 4d	 cmp	 DWORD PTR dwMutexType$[rsp], 1298230905 ; 4d616e79H
  00016	74 13		 je	 SHORT $LN3@IsValidMut
  00018	81 7c 24 20 65
	63 6e 4f	 cmp	 DWORD PTR dwMutexType$[rsp], 1332634469 ; 4f6e6365H
  00020	74 09		 je	 SHORT $LN3@IsValidMut
  00022	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv67[rsp], 0
  00029	eb 07		 jmp	 SHORT $LN4@IsValidMut
$LN3@IsValidMut:
  0002b	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv67[rsp], 1
$LN4@IsValidMut:
  00032	8b 04 24	 mov	 eax, DWORD PTR tv67[rsp]

; 75   : //      || FTHREAD_MUTEX_NORMAL     == dwMutexType  // (*UNSUPPORTED*)
; 76   :         || FTHREAD_MUTEX_RECURSIVE  == dwMutexType
; 77   :         || FTHREAD_MUTEX_ERRORCHECK == dwMutexType
; 78   : //      || FTHREAD_MUTEX_DEFAULT    == dwMutexType  // (FTHREAD_MUTEX_RECURSIVE)
; 79   :     );
; 80   : }

  00035	48 83 c4 18	 add	 rsp, 24
  00039	c3		 ret	 0
IsValidMutexType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pFT_MUTEX_ATTR$ = 48
nMutexType$ = 56
fthread_mutexattr_settype PROC

; 1752 : {

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1753 :     if ( !pFT_MUTEX_ATTR || !IsValidMutexType ( (DWORD) nMutexType ) )

  0000d	48 83 7c 24 30
	00		 cmp	 QWORD PTR pFT_MUTEX_ATTR$[rsp], 0
  00013	74 0d		 je	 SHORT $LN3@fthread_mu
  00015	8b 4c 24 38	 mov	 ecx, DWORD PTR nMutexType$[rsp]
  00019	e8 00 00 00 00	 call	 IsValidMutexType
  0001e	85 c0		 test	 eax, eax
  00020	75 07		 jne	 SHORT $LN2@fthread_mu
$LN3@fthread_mu:

; 1754 :         return RC(EINVAL);

  00022	b8 16 00 00 00	 mov	 eax, 22
  00027	eb 0d		 jmp	 SHORT $LN1@fthread_mu
$LN2@fthread_mu:

; 1755 :     *pFT_MUTEX_ATTR = (DWORD) nMutexType;

  00029	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_MUTEX_ATTR$[rsp]
  0002e	8b 4c 24 38	 mov	 ecx, DWORD PTR nMutexType$[rsp]
  00032	89 08		 mov	 DWORD PTR [rax], ecx

; 1756 :     return RC(0);

  00034	33 c0		 xor	 eax, eax
$LN1@fthread_mu:

; 1757 : }

  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
fthread_mutexattr_settype ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
dwMutexType$ = 32
pFT_MUTEX_ATTR$ = 64
pnMutexType$ = 72
fthread_mutexattr_gettype PROC

; 1735 : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1736 :     DWORD  dwMutexType;
; 1737 :     if ( !pFT_MUTEX_ATTR || !pnMutexType || !IsValidMutexType ( dwMutexType = *pFT_MUTEX_ATTR ) )

  0000e	48 83 7c 24 40
	00		 cmp	 QWORD PTR pFT_MUTEX_ATTR$[rsp], 0
  00014	74 20		 je	 SHORT $LN3@fthread_mu
  00016	48 83 7c 24 48
	00		 cmp	 QWORD PTR pnMutexType$[rsp], 0
  0001c	74 18		 je	 SHORT $LN3@fthread_mu
  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_MUTEX_ATTR$[rsp]
  00023	8b 00		 mov	 eax, DWORD PTR [rax]
  00025	89 44 24 20	 mov	 DWORD PTR dwMutexType$[rsp], eax
  00029	8b 4c 24 20	 mov	 ecx, DWORD PTR dwMutexType$[rsp]
  0002d	e8 00 00 00 00	 call	 IsValidMutexType
  00032	85 c0		 test	 eax, eax
  00034	75 07		 jne	 SHORT $LN2@fthread_mu
$LN3@fthread_mu:

; 1738 :         return RC(EINVAL);

  00036	b8 16 00 00 00	 mov	 eax, 22
  0003b	eb 0d		 jmp	 SHORT $LN1@fthread_mu
$LN2@fthread_mu:

; 1739 :     *pnMutexType = (int) dwMutexType;

  0003d	48 8b 44 24 48	 mov	 rax, QWORD PTR pnMutexType$[rsp]
  00042	8b 4c 24 20	 mov	 ecx, DWORD PTR dwMutexType$[rsp]
  00046	89 08		 mov	 DWORD PTR [rax], ecx

; 1740 :     return RC(0);

  00048	33 c0		 xor	 eax, eax
$LN1@fthread_mu:

; 1741 : }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
fthread_mutexattr_gettype ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pFT_MUTEX_ATTR$ = 8
fthread_mutexattr_destroy PROC

; 1719 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1720 :     if ( !pFT_MUTEX_ATTR )

  00005	48 83 7c 24 08
	00		 cmp	 QWORD PTR pFT_MUTEX_ATTR$[rsp], 0
  0000b	75 07		 jne	 SHORT $LN2@fthread_mu

; 1721 :         return RC(EINVAL);

  0000d	b8 16 00 00 00	 mov	 eax, 22
  00012	eb 0d		 jmp	 SHORT $LN1@fthread_mu
$LN2@fthread_mu:

; 1722 :     *pFT_MUTEX_ATTR = 0xCDCDCDCD;

  00014	48 8b 44 24 08	 mov	 rax, QWORD PTR pFT_MUTEX_ATTR$[rsp]
  00019	c7 00 cd cd cd
	cd		 mov	 DWORD PTR [rax], -842150451 ; cdcdcdcdH

; 1723 :     return RC(0);

  0001f	33 c0		 xor	 eax, eax
$LN1@fthread_mu:

; 1724 : }

  00021	c3		 ret	 0
fthread_mutexattr_destroy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pFT_MUTEX_ATTR$ = 8
fthread_mutexattr_init PROC

; 1707 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1708 :     if ( !pFT_MUTEX_ATTR )

  00005	48 83 7c 24 08
	00		 cmp	 QWORD PTR pFT_MUTEX_ATTR$[rsp], 0
  0000b	75 07		 jne	 SHORT $LN2@fthread_mu

; 1709 :         return RC(EINVAL);

  0000d	b8 16 00 00 00	 mov	 eax, 22
  00012	eb 0d		 jmp	 SHORT $LN1@fthread_mu
$LN2@fthread_mu:

; 1710 :     *pFT_MUTEX_ATTR = FTHREAD_MUTEX_DEFAULT;

  00014	48 8b 44 24 08	 mov	 rax, QWORD PTR pFT_MUTEX_ATTR$[rsp]
  00019	c7 00 65 63 6e
	4f		 mov	 DWORD PTR [rax], 1332634469 ; 4f6e6365H

; 1711 :     return RC(0);

  0001f	33 c0		 xor	 eax, eax
$LN1@fthread_mu:

; 1712 : }

  00021	c3		 ret	 0
fthread_mutexattr_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
rc$ = 32
pFT_COND_VAR$ = 64
pFTUSER_MUTEX$ = 72
pTimeTimeout$ = 80
fthread_cond_timedwait PROC

; 1658 : {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1659 :     int rc;
; 1660 : 
; 1661 :     if (0
; 1662 :         || !pFT_COND_VAR
; 1663 :         || !pFTUSER_MUTEX
; 1664 :         || !pTimeTimeout

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	75 18		 jne	 SHORT $LN3@fthread_co
  00019	48 83 7c 24 40
	00		 cmp	 QWORD PTR pFT_COND_VAR$[rsp], 0
  0001f	74 10		 je	 SHORT $LN3@fthread_co
  00021	48 83 7c 24 48
	00		 cmp	 QWORD PTR pFTUSER_MUTEX$[rsp], 0
  00027	74 08		 je	 SHORT $LN3@fthread_co
  00029	48 83 7c 24 50
	00		 cmp	 QWORD PTR pTimeTimeout$[rsp], 0
  0002f	75 07		 jne	 SHORT $LN2@fthread_co
$LN3@fthread_co:

; 1665 :     )
; 1666 :         return RC(EINVAL);

  00031	b8 16 00 00 00	 mov	 eax, 22
  00036	eb 5d		 jmp	 SHORT $LN1@fthread_co
$LN2@fthread_co:

; 1667 : 
; 1668 :     if
; 1669 :     (
; 1670 :         (
; 1671 :             rc = BeginWait
; 1672 :             (
; 1673 :                 pFT_COND_VAR -> hCondVar,
; 1674 :                 pFTUSER_MUTEX
; 1675 :             )
; 1676 :         )
; 1677 :         != 0

  00038	48 8b 54 24 48	 mov	 rdx, QWORD PTR pFTUSER_MUTEX$[rsp]
  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	e8 00 00 00 00	 call	 BeginWait
  0004a	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
  0004e	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00053	74 06		 je	 SHORT $LN4@fthread_co

; 1678 :     )
; 1679 :         return rc;

  00055	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  00059	eb 3a		 jmp	 SHORT $LN1@fthread_co
$LN4@fthread_co:

; 1680 : 
; 1681 :     rc = WaitForTransmission

  0005b	48 8b 54 24 50	 mov	 rdx, QWORD PTR pTimeTimeout$[rsp]
  00060	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00065	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00068	e8 00 00 00 00	 call	 WaitForTransmission
  0006d	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1682 :     (
; 1683 :         pFT_COND_VAR->hCondVar,
; 1684 :         pTimeTimeout
; 1685 :     );
; 1686 : 
; 1687 :     ReceiveXmission

  00071	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00076	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00079	e8 00 00 00 00	 call	 ReceiveXmission

; 1688 :     (
; 1689 :         pFT_COND_VAR->hCondVar
; 1690 :     );
; 1691 : 
; 1692 :     return ReturnFromWait

  0007e	44 8b 44 24 20	 mov	 r8d, DWORD PTR rc$[rsp]
  00083	48 8b 54 24 48	 mov	 rdx, QWORD PTR pFTUSER_MUTEX$[rsp]
  00088	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  0008d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00090	e8 00 00 00 00	 call	 ReturnFromWait
$LN1@fthread_co:

; 1693 :     (
; 1694 :         pFT_COND_VAR -> hCondVar,
; 1695 :         pFTUSER_MUTEX,
; 1696 :         rc
; 1697 :     );
; 1698 : }

  00095	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00099	c3		 ret	 0
fthread_cond_timedwait ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
rc$ = 32
pFT_COND_VAR$ = 64
pFTUSER_MUTEX$ = 72
fthread_cond_wait PROC

; 1560 : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1561 :     int rc;
; 1562 : 
; 1563 :     if (0
; 1564 :         || !pFT_COND_VAR        // (invalid ptr)
; 1565 :         || !pFTUSER_MUTEX       // (invalid ptr)

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 10		 jne	 SHORT $LN3@fthread_co
  00014	48 83 7c 24 40
	00		 cmp	 QWORD PTR pFT_COND_VAR$[rsp], 0
  0001a	74 08		 je	 SHORT $LN3@fthread_co
  0001c	48 83 7c 24 48
	00		 cmp	 QWORD PTR pFTUSER_MUTEX$[rsp], 0
  00022	75 07		 jne	 SHORT $LN2@fthread_co
$LN3@fthread_co:

; 1566 :     )
; 1567 :         return RC(EINVAL);

  00024	b8 16 00 00 00	 mov	 eax, 22
  00029	eb 5a		 jmp	 SHORT $LN1@fthread_co
$LN2@fthread_co:

; 1568 : 
; 1569 :     // The following call essentially atomically releases the caller's mutex
; 1570 :     // and does a wait. Of course, it doesn't really do the wait though; that's
; 1571 :     // actually done further below. BUT, it does atomically register the fact
; 1572 :     // that this thread *wishes* to do a wait by acquiring the condition variable
; 1573 :     // lock and then incrementing the #of waiters counter before it releases the
; 1574 :     // original mutex. Thus, whenever the below function call returns back to us,
; 1575 :     // we can be assured that: 1) our request to wait on this condition variable
; 1576 :     // has been registered AND 2) we have control of the condition variable in
; 1577 :     // question (i.e. we still hold the condition variable lock thus preventing
; 1578 :     // anyone from trying to send a signal just yet)...
; 1579 : 
; 1580 :     if
; 1581 :     (
; 1582 :         (
; 1583 :             rc = BeginWait
; 1584 :             (
; 1585 :                 pFT_COND_VAR -> hCondVar,
; 1586 :                 pFTUSER_MUTEX
; 1587 :             )
; 1588 :         )
; 1589 :         != 0

  0002b	48 8b 54 24 48	 mov	 rdx, QWORD PTR pFTUSER_MUTEX$[rsp]
  00030	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00035	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00038	e8 00 00 00 00	 call	 BeginWait
  0003d	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
  00041	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00046	74 06		 je	 SHORT $LN4@fthread_co

; 1590 :     )
; 1591 :     {
; 1592 :         // OOPS! Something went wrong. The original mutex has NOT been released
; 1593 :         // and we did NOT acquire our condition variable lock (and thus our wait
; 1594 :         // was not registered). Thus we can safely return back to the caller with
; 1595 :         // the original mutex still owned (held) by the caller.
; 1596 : 
; 1597 :         return RC(rc); // (return error code to caller; their wait failed)

  00048	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  0004c	eb 37		 jmp	 SHORT $LN1@fthread_co
$LN4@fthread_co:

; 1598 :     }
; 1599 : 
; 1600 :     // We only reach here if the condition var was successfully acquired AND our
; 1601 :     // wait was registered AND the original mutex was released so the signal can
; 1602 :     // be sent (but the signal (transmission) of course cannot ever be sent until
; 1603 :     // we first release our lock on our condition variable, which is of course is
; 1604 :     // what the below WaitForTransmission function call does within its wait loop)...
; 1605 : 
; 1606 :     rc = WaitForTransmission    // (wait for "signal" or "broadcast"...)

  0004e	33 d2		 xor	 edx, edx
  00050	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00055	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00058	e8 00 00 00 00	 call	 WaitForTransmission
  0005d	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1607 :     (
; 1608 :         pFT_COND_VAR->hCondVar,
; 1609 :         NULL
; 1610 :     );
; 1611 : 
; 1612 :     // A signal (transmission) was sent and we're one of the ones (or the
; 1613 :     // only one) that's supposed to receive it...
; 1614 : 
; 1615 :     // If we're the only one that's supposed to receive this transmission,
; 1616 :     // then we need to turn off the transmitter (stop "sending" the signal)
; 1617 :     // so that no other threads get "woken up" (released) as a result of
; 1618 :     // this particular "signal" (transmission)...
; 1619 : 
; 1620 :     // (Note that the below call also de-registers our wait too)
; 1621 : 
; 1622 :     ReceiveXmission         // (reset transmitter)

  00061	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00066	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00069	e8 00 00 00 00	 call	 ReceiveXmission

; 1623 :     (
; 1624 :         pFT_COND_VAR->hCondVar
; 1625 :     );
; 1626 : 
; 1627 :     // Release the condition var lock (since we're done with it) and then
; 1628 :     // reacquire the caller's original mutex (if possible) and then return
; 1629 :     // back to the original caller with their original mutex held with what-
; 1630 :     // ever return code got set by the above wait call...
; 1631 : 
; 1632 :     return ReturnFromWait

  0006e	44 8b 44 24 20	 mov	 r8d, DWORD PTR rc$[rsp]
  00073	48 8b 54 24 48	 mov	 rdx, QWORD PTR pFTUSER_MUTEX$[rsp]
  00078	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  0007d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00080	e8 00 00 00 00	 call	 ReturnFromWait
$LN1@fthread_co:

; 1633 :     (
; 1634 :         pFT_COND_VAR -> hCondVar,
; 1635 :         pFTUSER_MUTEX,
; 1636 :         rc
; 1637 :     );
; 1638 : }

  00085	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00089	c3		 ret	 0
fthread_cond_wait ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pFT_COND_VAR$ = 48
fthread_cond_broadcast PROC

; 1540 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1541 :     if ( !pFT_COND_VAR )

  00009	48 83 7c 24 30
	00		 cmp	 QWORD PTR pFT_COND_VAR$[rsp], 0
  0000f	75 07		 jne	 SHORT $LN2@fthread_co

; 1542 :         return RC(EINVAL);      // (invalid ptr)

  00011	b8 16 00 00 00	 mov	 eax, 22
  00016	eb 12		 jmp	 SHORT $LN1@fthread_co
$LN2@fthread_co:

; 1543 : 
; 1544 :     return QueueTransmission

  00018	ba 01 00 00 00	 mov	 edx, 1
  0001d	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00022	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00025	e8 00 00 00 00	 call	 QueueTransmission
$LN1@fthread_co:

; 1545 :     (
; 1546 :         pFT_COND_VAR->hCondVar,
; 1547 :         TRUE                // (TRUE == "broadcast" type)
; 1548 :     );
; 1549 : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
fthread_cond_broadcast ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pFT_COND_VAR$ = 48
fthread_cond_signal PROC

; 1521 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1522 :     if ( !pFT_COND_VAR )

  00009	48 83 7c 24 30
	00		 cmp	 QWORD PTR pFT_COND_VAR$[rsp], 0
  0000f	75 07		 jne	 SHORT $LN2@fthread_co

; 1523 :         return RC(EINVAL);      // (invalid ptr)

  00011	b8 16 00 00 00	 mov	 eax, 22
  00016	eb 0f		 jmp	 SHORT $LN1@fthread_co
$LN2@fthread_co:

; 1524 : 
; 1525 :     return QueueTransmission

  00018	33 d2		 xor	 edx, edx
  0001a	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  0001f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00022	e8 00 00 00 00	 call	 QueueTransmission
$LN1@fthread_co:

; 1526 :     (
; 1527 :         pFT_COND_VAR->hCondVar,
; 1528 :         FALSE               // (FALSE == not "broadcast")
; 1529 :     );
; 1530 : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
fthread_cond_signal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pFT_COND_VAR$ = 48
fthread_cond_destroy PROC

; 1498 : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1499 :     if ( !pFT_COND_VAR )

  00009	48 83 7c 24 30
	00		 cmp	 QWORD PTR pFT_COND_VAR$[rsp], 0
  0000f	75 07		 jne	 SHORT $LN2@fthread_co

; 1500 :         return RC(EINVAL);      // (invalid ptr)

  00011	b8 16 00 00 00	 mov	 eax, 22
  00016	eb 34		 jmp	 SHORT $LN1@fthread_co
$LN2@fthread_co:

; 1501 : 
; 1502 :     if ( !UninitializeFT_COND_VAR

  00018	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  0001d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00020	e8 00 00 00 00	 call	 UninitializeFT_COND_VAR
  00025	85 c0		 test	 eax, eax
  00027	75 07		 jne	 SHORT $LN3@fthread_co

; 1503 :     (
; 1504 :         pFT_COND_VAR->hCondVar
; 1505 :     ))
; 1506 :         return RC(EBUSY);       // (still in use)

  00029	b8 10 00 00 00	 mov	 eax, 16
  0002e	eb 1c		 jmp	 SHORT $LN1@fthread_co
$LN3@fthread_co:

; 1507 : 
; 1508 :     free ( pFT_COND_VAR->hCondVar );

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00035	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1509 :     pFT_COND_VAR->hCondVar = NULL;

  0003e	48 8b 44 24 30	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00043	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1510 :     return RC(0);

  0004a	33 c0		 xor	 eax, eax
$LN1@fthread_co:

; 1511 : }

  0004c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00050	c3		 ret	 0
fthread_cond_destroy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
tv66 = 32
pFT_COND_VAR$ = 64
fthread_cond_init PROC

; 1470 : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1471 :     if ( !pFT_COND_VAR )

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR pFT_COND_VAR$[rsp], 0
  0000f	75 07		 jne	 SHORT $LN2@fthread_co

; 1472 :         return RC(EINVAL);      // (invalid ptr)

  00011	b8 16 00 00 00	 mov	 eax, 22
  00016	eb 5a		 jmp	 SHORT $LN1@fthread_co
$LN2@fthread_co:

; 1473 : 
; 1474 :     if ( !(pFT_COND_VAR->hCondVar = MallocFT_COND_VAR()) )

  00018	e8 00 00 00 00	 call	 MallocFT_COND_VAR
  0001d	48 89 44 24 20	 mov	 QWORD PTR tv66[rsp], rax
  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00027	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv66[rsp]
  0002c	48 89 08	 mov	 QWORD PTR [rax], rcx
  0002f	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv66[rsp], 0
  00035	75 07		 jne	 SHORT $LN3@fthread_co

; 1475 :         return RC(ENOMEM);      // (out of memory)

  00037	b8 0c 00 00 00	 mov	 eax, 12
  0003c	eb 34		 jmp	 SHORT $LN1@fthread_co
$LN3@fthread_co:

; 1476 : 
; 1477 :     if ( !InitializeFT_COND_VAR

  0003e	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00043	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00046	e8 00 00 00 00	 call	 InitializeFT_COND_VAR
  0004b	85 c0		 test	 eax, eax
  0004d	75 21		 jne	 SHORT $LN4@fthread_co

; 1478 :     (
; 1479 :         pFT_COND_VAR->hCondVar
; 1480 :     ))
; 1481 :     {
; 1482 :         free ( pFT_COND_VAR->hCondVar );

  0004f	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00054	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1483 :         pFT_COND_VAR->hCondVar = NULL;

  0005d	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT_COND_VAR$[rsp]
  00062	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1484 :         return RC(EAGAIN);      // (unable to obtain required resources)

  00069	b8 0b 00 00 00	 mov	 eax, 11
  0006e	eb 02		 jmp	 SHORT $LN1@fthread_co
$LN4@fthread_co:

; 1485 :     }
; 1486 : 
; 1487 :     return RC(0);

  00070	33 c0		 xor	 eax, eax
$LN1@fthread_co:

; 1488 : }

  00072	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00076	c3		 ret	 0
fthread_cond_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pFTUSER_MUTEX$ = 48
fthread_mutex_unlock PROC

; 1441 : {

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1442 :     if (!pFTUSER_MUTEX)

  00009	48 83 7c 24 30
	00		 cmp	 QWORD PTR pFTUSER_MUTEX$[rsp], 0
  0000f	75 0a		 jne	 SHORT $LN8@fthread_mu

; 1443 :         return RC(EINVAL); // (invalid ptr)

  00011	b8 16 00 00 00	 mov	 eax, 22
  00016	e9 c0 00 00 00	 jmp	 $LN1@fthread_mu
$LN8@fthread_mu:

; 1444 : 
; 1445 :     if (0
; 1446 :         || GetCurrentThreadId() != ((PFT_MUTEX)pFTUSER_MUTEX->hMutex)->dwLockOwner  // (not owned)
; 1447 :         || ((PFT_MUTEX)pFTUSER_MUTEX->hMutex)->nLockedCount <= 0                    // (not locked)

  0001b	33 c0		 xor	 eax, eax
  0001d	85 c0		 test	 eax, eax
  0001f	75 21		 jne	 SHORT $LN10@fthread_mu
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pFTUSER_MUTEX$[rsp]
  0002c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002f	3b 41 34	 cmp	 eax, DWORD PTR [rcx+52]
  00032	75 0e		 jne	 SHORT $LN10@fthread_mu
  00034	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTUSER_MUTEX$[rsp]
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003c	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  00040	7f 0a		 jg	 SHORT $LN9@fthread_mu
$LN10@fthread_mu:

; 1448 :     )
; 1449 :         return RC(EPERM);

  00042	b8 01 00 00 00	 mov	 eax, 1
  00047	e9 8f 00 00 00	 jmp	 $LN1@fthread_mu
$LN9@fthread_mu:
$LN4@fthread_mu:

; 1450 : 
; 1451 :     ASSERT ( ((FT_MUTEX*)pFTUSER_MUTEX->hMutex)->nLockedCount <= 1

  0004c	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTUSER_MUTEX$[rsp]
  00051	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00054	83 78 38 01	 cmp	 DWORD PTR [rax+56], 1
  00058	7e 6c		 jle	 SHORT $LN11@fthread_mu
  0005a	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTUSER_MUTEX$[rsp]
  0005f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00062	81 78 30 79 6e
	61 4d		 cmp	 DWORD PTR [rax+48], 1298230905 ; 4d616e79H
  00069	74 5b		 je	 SHORT $LN11@fthread_mu
$LN7@fthread_mu:
  0006b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159715
  00072	41 b8 ac 05 00
	00		 mov	 r8d, 1452		; 000005acH
  00078	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159716
  0007f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159717
  00086	e8 00 00 00 00	 call	 logmsg
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00091	85 c0		 test	 eax, eax
  00093	74 20		 je	 SHORT $LN12@fthread_mu
  00095	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159719
  0009c	41 b8 ac 05 00
	00		 mov	 r8d, 1452		; 000005acH
  000a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159720
  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159721
  000b0	e8 00 00 00 00	 call	 DebuggerTrace
$LN12@fthread_mu:
  000b5	33 c0		 xor	 eax, eax
  000b7	85 c0		 test	 eax, eax
  000b9	75 b0		 jne	 SHORT $LN7@fthread_mu
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000c1	85 c0		 test	 eax, eax
  000c3	74 01		 je	 SHORT $LN13@fthread_mu
  000c5	cc		 int	 3
$LN13@fthread_mu:
$LN11@fthread_mu:
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 80		 jne	 SHORT $LN4@fthread_mu

; 1452 :         || FTHREAD_MUTEX_RECURSIVE == ((FT_MUTEX*)pFTUSER_MUTEX->hMutex)->dwMutexType );
; 1453 : 
; 1454 :     LeaveFT_MUTEX

  000cc	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTUSER_MUTEX$[rsp]
  000d1	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000d4	e8 00 00 00 00	 call	 LeaveFT_MUTEX

; 1455 :     (
; 1456 :         pFTUSER_MUTEX->hMutex
; 1457 :     );
; 1458 : 
; 1459 :     return RC(0);

  000d9	33 c0		 xor	 eax, eax
$LN1@fthread_mu:

; 1460 : }

  000db	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000df	c3		 ret	 0
fthread_mutex_unlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pFTUSER_MUTEX$ = 48
fthread_mutex_trylock PROC

; 1330 : {

$LN17:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1331 :     if ( !pFTUSER_MUTEX )

  00009	48 83 7c 24 30
	00		 cmp	 QWORD PTR pFTUSER_MUTEX$[rsp], 0
  0000f	75 0a		 jne	 SHORT $LN8@fthread_mu

; 1332 :         return RC(EINVAL);      // (invalid ptr)

  00011	b8 16 00 00 00	 mov	 eax, 22
  00016	e9 d9 00 00 00	 jmp	 $LN1@fthread_mu
$LN8@fthread_mu:

; 1333 : 
; 1334 :     // Try to acquire the requested mutex...
; 1335 : 
; 1336 :     if
; 1337 :     (
; 1338 :         !TryEnterFT_MUTEX

  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTUSER_MUTEX$[rsp]
  00020	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00023	e8 00 00 00 00	 call	 TryEnterFT_MUTEX
  00028	85 c0		 test	 eax, eax
  0002a	75 0a		 jne	 SHORT $LN9@fthread_mu

; 1339 :         (
; 1340 :             pFTUSER_MUTEX->hMutex
; 1341 :         )
; 1342 :     )
; 1343 :         // We could not acquire the mutex; return 'busy'...
; 1344 : 
; 1345 :         return RC(EBUSY);

  0002c	b8 10 00 00 00	 mov	 eax, 16
  00031	e9 be 00 00 00	 jmp	 $LN1@fthread_mu
$LN9@fthread_mu:

; 1346 : 
; 1347 :     // We successfully acquired the mutex... If the mutex type is recursive,
; 1348 :     // or, if not recursive (i.e. error-check), if this was the first/initial
; 1349 :     // lock on the mutex, then return success...
; 1350 : 
; 1351 :     if (0
; 1352 :         || FTHREAD_MUTEX_RECURSIVE == ((FT_MUTEX*)pFTUSER_MUTEX->hMutex)->dwMutexType
; 1353 :         || ((FT_MUTEX*)pFTUSER_MUTEX->hMutex)->nLockedCount <= 1

  00036	33 c0		 xor	 eax, eax
  00038	85 c0		 test	 eax, eax
  0003a	75 1f		 jne	 SHORT $LN11@fthread_mu
  0003c	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTUSER_MUTEX$[rsp]
  00041	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00044	81 78 30 79 6e
	61 4d		 cmp	 DWORD PTR [rax+48], 1298230905 ; 4d616e79H
  0004b	74 0e		 je	 SHORT $LN11@fthread_mu
  0004d	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTUSER_MUTEX$[rsp]
  00052	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00055	83 78 38 01	 cmp	 DWORD PTR [rax+56], 1
  00059	7f 07		 jg	 SHORT $LN10@fthread_mu
$LN11@fthread_mu:

; 1354 :     )
; 1355 :         return RC(0);

  0005b	33 c0		 xor	 eax, eax
  0005d	e9 92 00 00 00	 jmp	 $LN1@fthread_mu
$LN10@fthread_mu:
$LN4@fthread_mu:

; 1356 : 
; 1357 :     ASSERT ( FTHREAD_MUTEX_ERRORCHECK == ((FT_MUTEX*)pFTUSER_MUTEX->hMutex)->dwMutexType

  00062	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTUSER_MUTEX$[rsp]
  00067	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006a	81 78 30 65 63
	6e 4f		 cmp	 DWORD PTR [rax+48], 1332634469 ; 4f6e6365H
  00071	75 0e		 jne	 SHORT $LN13@fthread_mu
  00073	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTUSER_MUTEX$[rsp]
  00078	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007b	83 78 38 01	 cmp	 DWORD PTR [rax+56], 1
  0007f	7f 5b		 jg	 SHORT $LN12@fthread_mu
$LN13@fthread_mu:
$LN7@fthread_mu:
  00081	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159663
  00088	41 b8 4e 05 00
	00		 mov	 r8d, 1358		; 0000054eH
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159664
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159665
  0009c	e8 00 00 00 00	 call	 logmsg
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000a7	85 c0		 test	 eax, eax
  000a9	74 20		 je	 SHORT $LN14@fthread_mu
  000ab	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159667
  000b2	41 b8 4e 05 00
	00		 mov	 r8d, 1358		; 0000054eH
  000b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159668
  000bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159669
  000c6	e8 00 00 00 00	 call	 DebuggerTrace
$LN14@fthread_mu:
  000cb	33 c0		 xor	 eax, eax
  000cd	85 c0		 test	 eax, eax
  000cf	75 b0		 jne	 SHORT $LN7@fthread_mu
  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000d7	85 c0		 test	 eax, eax
  000d9	74 01		 je	 SHORT $LN15@fthread_mu
  000db	cc		 int	 3
$LN15@fthread_mu:
$LN12@fthread_mu:
  000dc	33 c0		 xor	 eax, eax
  000de	85 c0		 test	 eax, eax
  000e0	75 80		 jne	 SHORT $LN4@fthread_mu

; 1358 :         && ((FT_MUTEX*)pFTUSER_MUTEX->hMutex)->nLockedCount > 1 );
; 1359 : 
; 1360 :     // The mutex type is error-check and we already previously had the mutex locked
; 1361 :     // before (i.e. this was the *second* time we acquired this same mutex). Return
; 1362 :     // 'busy' after first releasing the mutex once (to decrement the locked count
; 1363 :     // back down to what it was (i.e. 1 (one))).
; 1364 : 
; 1365 :     LeaveFT_MUTEX

  000e2	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTUSER_MUTEX$[rsp]
  000e7	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000ea	e8 00 00 00 00	 call	 LeaveFT_MUTEX

; 1366 :     (
; 1367 :         pFTUSER_MUTEX->hMutex
; 1368 :     );
; 1369 : 
; 1370 :     return RC(EBUSY);

  000ef	b8 10 00 00 00	 mov	 eax, 16
$LN1@fthread_mu:

; 1371 : }

  000f4	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000f8	c3		 ret	 0
fthread_mutex_trylock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pFTUSER_MUTEX$ = 48
fthread_mutex_lock PROC

; 1381 : {

$LN17:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1382 :     if ( !pFTUSER_MUTEX )

  00009	48 83 7c 24 30
	00		 cmp	 QWORD PTR pFTUSER_MUTEX$[rsp], 0
  0000f	75 0a		 jne	 SHORT $LN8@fthread_mu

; 1383 :         return RC(EINVAL);      // (invalid ptr)

  00011	b8 16 00 00 00	 mov	 eax, 22
  00016	e9 e3 00 00 00	 jmp	 $LN1@fthread_mu
$LN8@fthread_mu:

; 1384 : 
; 1385 :     // Try to acquire the requested mutex...
; 1386 : 
; 1387 :     if
; 1388 :     (
; 1389 :         !TryEnterFT_MUTEX

  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTUSER_MUTEX$[rsp]
  00020	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00023	e8 00 00 00 00	 call	 TryEnterFT_MUTEX
  00028	85 c0		 test	 eax, eax
  0002a	75 14		 jne	 SHORT $LN9@fthread_mu

; 1390 :         (
; 1391 :             pFTUSER_MUTEX->hMutex
; 1392 :         )
; 1393 :     )
; 1394 :     {
; 1395 :         // We could not acquire the mutex. This means someone already owns the mutex,
; 1396 :         // so just do a normal acquire on the mutex. Both recursive and error-check
; 1397 :         // types will block until such time as the mutex is successfully acquired...
; 1398 : 
; 1399 :         EnterFT_MUTEX

  0002c	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTUSER_MUTEX$[rsp]
  00031	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00034	e8 00 00 00 00	 call	 EnterFT_MUTEX

; 1400 :         (
; 1401 :             pFTUSER_MUTEX->hMutex
; 1402 :         );
; 1403 : 
; 1404 :         return RC(0);

  00039	33 c0		 xor	 eax, eax
  0003b	e9 be 00 00 00	 jmp	 $LN1@fthread_mu
$LN9@fthread_mu:

; 1405 :     }
; 1406 : 
; 1407 :     // We successfully acquired the mutex... If the mutex type is recursive,
; 1408 :     // or, if not recursive (i.e. error-check), if this was the first/initial
; 1409 :     // lock on the mutex, then return success...
; 1410 : 
; 1411 :     if (0
; 1412 :         || FTHREAD_MUTEX_RECURSIVE == ((FT_MUTEX*)pFTUSER_MUTEX->hMutex)->dwMutexType
; 1413 :         || ((FT_MUTEX*)pFTUSER_MUTEX->hMutex)->nLockedCount <= 1

  00040	33 c0		 xor	 eax, eax
  00042	85 c0		 test	 eax, eax
  00044	75 1f		 jne	 SHORT $LN11@fthread_mu
  00046	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTUSER_MUTEX$[rsp]
  0004b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004e	81 78 30 79 6e
	61 4d		 cmp	 DWORD PTR [rax+48], 1298230905 ; 4d616e79H
  00055	74 0e		 je	 SHORT $LN11@fthread_mu
  00057	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTUSER_MUTEX$[rsp]
  0005c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005f	83 78 38 01	 cmp	 DWORD PTR [rax+56], 1
  00063	7f 07		 jg	 SHORT $LN10@fthread_mu
$LN11@fthread_mu:

; 1414 :     )
; 1415 :         return RC(0);

  00065	33 c0		 xor	 eax, eax
  00067	e9 92 00 00 00	 jmp	 $LN1@fthread_mu
$LN10@fthread_mu:
$LN4@fthread_mu:

; 1416 : 
; 1417 :     ASSERT ( FTHREAD_MUTEX_ERRORCHECK == ((FT_MUTEX*)pFTUSER_MUTEX->hMutex)->dwMutexType

  0006c	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTUSER_MUTEX$[rsp]
  00071	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00074	81 78 30 65 63
	6e 4f		 cmp	 DWORD PTR [rax+48], 1332634469 ; 4f6e6365H
  0007b	75 0e		 jne	 SHORT $LN13@fthread_mu
  0007d	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTUSER_MUTEX$[rsp]
  00082	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00085	83 78 38 01	 cmp	 DWORD PTR [rax+56], 1
  00089	7f 5b		 jg	 SHORT $LN12@fthread_mu
$LN13@fthread_mu:
$LN7@fthread_mu:
  0008b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159690
  00092	41 b8 8a 05 00
	00		 mov	 r8d, 1418		; 0000058aH
  00098	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159691
  0009f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159692
  000a6	e8 00 00 00 00	 call	 logmsg
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000b1	85 c0		 test	 eax, eax
  000b3	74 20		 je	 SHORT $LN14@fthread_mu
  000b5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159694
  000bc	41 b8 8a 05 00
	00		 mov	 r8d, 1418		; 0000058aH
  000c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159695
  000c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159696
  000d0	e8 00 00 00 00	 call	 DebuggerTrace
$LN14@fthread_mu:
  000d5	33 c0		 xor	 eax, eax
  000d7	85 c0		 test	 eax, eax
  000d9	75 b0		 jne	 SHORT $LN7@fthread_mu
  000db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000e1	85 c0		 test	 eax, eax
  000e3	74 01		 je	 SHORT $LN15@fthread_mu
  000e5	cc		 int	 3
$LN15@fthread_mu:
$LN12@fthread_mu:
  000e6	33 c0		 xor	 eax, eax
  000e8	85 c0		 test	 eax, eax
  000ea	75 80		 jne	 SHORT $LN4@fthread_mu

; 1418 :         && ((FT_MUTEX*)pFTUSER_MUTEX->hMutex)->nLockedCount > 1 );
; 1419 : 
; 1420 :     // The mutex type is error-check and we already previously had the mutex locked
; 1421 :     // before (i.e. this was the *second* time we acquired this same mutex). Return
; 1422 :     // 'deadlock' after first releasing the mutex once (to decrement the locked count
; 1423 :     // back down to what it was (i.e. 1 (one))).
; 1424 : 
; 1425 :     LeaveFT_MUTEX

  000ec	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTUSER_MUTEX$[rsp]
  000f1	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000f4	e8 00 00 00 00	 call	 LeaveFT_MUTEX

; 1426 :     (
; 1427 :         pFTUSER_MUTEX->hMutex
; 1428 :     );
; 1429 : 
; 1430 :     return RC(EDEADLK);

  000f9	b8 24 00 00 00	 mov	 eax, 36			; 00000024H
$LN1@fthread_mu:

; 1431 : }

  000fe	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00102	c3		 ret	 0
fthread_mutex_lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pFTUSER_MUTEX$ = 48
fthread_mutex_destroy PROC

; 1305 : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1306 :     if ( !pFTUSER_MUTEX )

  00009	48 83 7c 24 30
	00		 cmp	 QWORD PTR pFTUSER_MUTEX$[rsp], 0
  0000f	75 07		 jne	 SHORT $LN2@fthread_mu

; 1307 :         return RC(EINVAL);      // (invalid ptr)

  00011	b8 16 00 00 00	 mov	 eax, 22
  00016	eb 34		 jmp	 SHORT $LN1@fthread_mu
$LN2@fthread_mu:

; 1308 : 
; 1309 :     if ( !UninitializeFT_MUTEX

  00018	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTUSER_MUTEX$[rsp]
  0001d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00020	e8 00 00 00 00	 call	 UninitializeFT_MUTEX
  00025	85 c0		 test	 eax, eax
  00027	75 07		 jne	 SHORT $LN3@fthread_mu

; 1310 :     (
; 1311 :         pFTUSER_MUTEX->hMutex
; 1312 :     ))
; 1313 :         return RC(EBUSY);       // (still in use)

  00029	b8 10 00 00 00	 mov	 eax, 16
  0002e	eb 1c		 jmp	 SHORT $LN1@fthread_mu
$LN3@fthread_mu:

; 1314 : 
; 1315 :     free ( pFTUSER_MUTEX->hMutex );

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTUSER_MUTEX$[rsp]
  00035	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1316 : 
; 1317 :     pFTUSER_MUTEX->hMutex = NULL;

  0003e	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTUSER_MUTEX$[rsp]
  00043	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1318 : 
; 1319 :     return RC(0);

  0004a	33 c0		 xor	 eax, eax
$LN1@fthread_mu:

; 1320 : }

  0004c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00050	c3		 ret	 0
fthread_mutex_destroy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
dwMutexType$ = 32
tv74 = 36
tv70 = 40
pFTUSER_MUTEX$ = 64
pFT_MUTEX_ATTR$ = 72
fthread_mutex_init PROC

; 1270 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1271 :     DWORD  dwMutexType = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR dwMutexType$[rsp], 0

; 1272 : 
; 1273 :     if ( !pFTUSER_MUTEX )

  00016	48 83 7c 24 40
	00		 cmp	 QWORD PTR pFTUSER_MUTEX$[rsp], 0
  0001c	75 0a		 jne	 SHORT $LN2@fthread_mu

; 1274 :         return RC(EINVAL);      // (invalid mutex ptr)

  0001e	b8 16 00 00 00	 mov	 eax, 22
  00023	e9 9f 00 00 00	 jmp	 $LN1@fthread_mu
$LN2@fthread_mu:

; 1275 : 
; 1276 :     if ( pFT_MUTEX_ATTR && !IsValidMutexType ( dwMutexType = *pFT_MUTEX_ATTR ) )

  00028	48 83 7c 24 48
	00		 cmp	 QWORD PTR pFT_MUTEX_ATTR$[rsp], 0
  0002e	74 1f		 je	 SHORT $LN3@fthread_mu
  00030	48 8b 44 24 48	 mov	 rax, QWORD PTR pFT_MUTEX_ATTR$[rsp]
  00035	8b 00		 mov	 eax, DWORD PTR [rax]
  00037	89 44 24 20	 mov	 DWORD PTR dwMutexType$[rsp], eax
  0003b	8b 4c 24 20	 mov	 ecx, DWORD PTR dwMutexType$[rsp]
  0003f	e8 00 00 00 00	 call	 IsValidMutexType
  00044	85 c0		 test	 eax, eax
  00046	75 07		 jne	 SHORT $LN3@fthread_mu

; 1277 :         return RC(EINVAL);      // (invalid mutex attr ptr or mutex attr type)

  00048	b8 16 00 00 00	 mov	 eax, 22
  0004d	eb 78		 jmp	 SHORT $LN1@fthread_mu
$LN3@fthread_mu:

; 1278 : 
; 1279 :     if ( !(pFTUSER_MUTEX->hMutex = MallocFT_MUTEX()) )

  0004f	e8 00 00 00 00	 call	 MallocFT_MUTEX
  00054	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR pFTUSER_MUTEX$[rsp]
  0005e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv70[rsp]
  00063	48 89 08	 mov	 QWORD PTR [rax], rcx
  00066	48 83 7c 24 28
	00		 cmp	 QWORD PTR tv70[rsp], 0
  0006c	75 07		 jne	 SHORT $LN4@fthread_mu

; 1280 :         return RC(ENOMEM);      // (out of memory)

  0006e	b8 0c 00 00 00	 mov	 eax, 12
  00073	eb 52		 jmp	 SHORT $LN1@fthread_mu
$LN4@fthread_mu:

; 1281 : 
; 1282 :     if ( !InitializeFT_MUTEX

  00075	48 83 7c 24 48
	00		 cmp	 QWORD PTR pFT_MUTEX_ATTR$[rsp], 0
  0007b	74 0a		 je	 SHORT $LN7@fthread_mu
  0007d	8b 44 24 20	 mov	 eax, DWORD PTR dwMutexType$[rsp]
  00081	89 44 24 24	 mov	 DWORD PTR tv74[rsp], eax
  00085	eb 08		 jmp	 SHORT $LN8@fthread_mu
$LN7@fthread_mu:
  00087	c7 44 24 24 65
	63 6e 4f	 mov	 DWORD PTR tv74[rsp], 1332634469 ; 4f6e6365H
$LN8@fthread_mu:
  0008f	8b 54 24 24	 mov	 edx, DWORD PTR tv74[rsp]
  00093	48 8b 44 24 40	 mov	 rax, QWORD PTR pFTUSER_MUTEX$[rsp]
  00098	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0009b	e8 00 00 00 00	 call	 InitializeFT_MUTEX
  000a0	85 c0		 test	 eax, eax
  000a2	75 21		 jne	 SHORT $LN5@fthread_mu

; 1283 :     (
; 1284 :         pFTUSER_MUTEX->hMutex,
; 1285 :         pFT_MUTEX_ATTR ? dwMutexType : FTHREAD_MUTEX_DEFAULT
; 1286 :     ))
; 1287 :     {
; 1288 :         free ( pFTUSER_MUTEX->hMutex );

  000a4	48 8b 44 24 40	 mov	 rax, QWORD PTR pFTUSER_MUTEX$[rsp]
  000a9	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1289 :         pFTUSER_MUTEX->hMutex       = NULL;

  000b2	48 8b 44 24 40	 mov	 rax, QWORD PTR pFTUSER_MUTEX$[rsp]
  000b7	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1290 : 
; 1291 :         return RC(EAGAIN);      // (unable to obtain required resources)

  000be	b8 0b 00 00 00	 mov	 eax, 11
  000c3	eb 02		 jmp	 SHORT $LN1@fthread_mu
$LN5@fthread_mu:

; 1292 :     }
; 1293 : 
; 1294 :     return RC(0);

  000c5	33 c0		 xor	 eax, eax
$LN1@fthread_mu:

; 1295 : }

  000c7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cb	c3		 ret	 0
fthread_mutex_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
tv65 = 0
dwThreadID_1$ = 32
dwThreadID_2$ = 40
fthread_equal PROC

; 1255 : {

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 18	 sub	 rsp, 24

; 1256 :     return ( dwThreadID_1 == dwThreadID_2 );

  0000c	8b 44 24 28	 mov	 eax, DWORD PTR dwThreadID_2$[rsp]
  00010	39 44 24 20	 cmp	 DWORD PTR dwThreadID_1$[rsp], eax
  00014	75 09		 jne	 SHORT $LN3@fthread_eq
  00016	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv65[rsp], 1
  0001d	eb 07		 jmp	 SHORT $LN4@fthread_eq
$LN3@fthread_eq:
  0001f	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv65[rsp], 0
$LN4@fthread_eq:
  00026	8b 04 24	 mov	 eax, DWORD PTR tv65[rsp]

; 1257 : }

  00029	48 83 c4 18	 add	 rsp, 24
  0002d	c3		 ret	 0
fthread_equal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
fthread_self PROC

; 1242 : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1243 :     return GetCurrentThreadId();

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId

; 1244 : }

  0000a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0000e	c3		 ret	 0
fthread_self ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pFTHREAD$ = 32
ExitVal$ = 64
fthread_exit PROC

; 978  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@fthread_ex:

; 979  :     FTHREAD* pFTHREAD;
; 980  :     VERIFY ( pFTHREAD = FindFTHREAD ( GetCurrentThreadId() ) );

  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  0000f	8b c8		 mov	 ecx, eax
  00011	e8 00 00 00 00	 call	 FindFTHREAD
  00016	48 89 44 24 20	 mov	 QWORD PTR pFTHREAD$[rsp], rax
  0001b	48 83 7c 24 20
	00		 cmp	 QWORD PTR pFTHREAD$[rsp], 0
  00021	75 5b		 jne	 SHORT $LN8@fthread_ex
$LN7@fthread_ex:
  00023	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159519
  0002a	41 b8 d4 03 00
	00		 mov	 r8d, 980		; 000003d4H
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159520
  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159521
  0003e	e8 00 00 00 00	 call	 logmsg
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00049	85 c0		 test	 eax, eax
  0004b	74 20		 je	 SHORT $LN9@fthread_ex
  0004d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159523
  00054	41 b8 d4 03 00
	00		 mov	 r8d, 980		; 000003d4H
  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159524
  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159525
  00068	e8 00 00 00 00	 call	 DebuggerTrace
$LN9@fthread_ex:
  0006d	33 c0		 xor	 eax, eax
  0006f	85 c0		 test	 eax, eax
  00071	75 b0		 jne	 SHORT $LN7@fthread_ex
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00079	85 c0		 test	 eax, eax
  0007b	74 01		 je	 SHORT $LN10@fthread_ex
  0007d	cc		 int	 3
$LN10@fthread_ex:
$LN8@fthread_ex:
  0007e	33 c0		 xor	 eax, eax
  00080	85 c0		 test	 eax, eax
  00082	75 85		 jne	 SHORT $LN4@fthread_ex

; 981  :     pFTHREAD->ExitVal = ExitVal;

  00084	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  00089	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ExitVal$[rsp]
  0008e	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 982  :     UnlockThreadsList();

  00092	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ThreadListLock
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 983  :     longjmp ( pFTHREAD->JumpBuf, 1 );

  0009f	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  000a4	48 83 c0 40	 add	 rax, 64			; 00000040H
  000a8	ba 01 00 00 00	 mov	 edx, 1
  000ad	48 8b c8	 mov	 rcx, rax
  000b0	e8 00 00 00 00	 call	 longjmp
$LN11@fthread_ex:

; 984  : }

  000b5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b9	c3		 ret	 0
fthread_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pFTHREAD$ = 48
pCallTheirThreadParms$ = 56
nDetachState$ = 64
tv130 = 68
dwThreadID$ = 72
_EX_Head$1 = 80
nStackSize$ = 88
hThread$ = 96
_EX_Next$2 = 104
pdwThreadID$ = 128
pThreadAttr$ = 136
pfnThreadFunc$ = 144
pvThreadArgs$ = 152
fthread_create PROC

; 884  : {

$LN13:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 885  :     FT_CALL_THREAD_PARMS*  pCallTheirThreadParms;
; 886  :     size_t                 nStackSize;
; 887  :     int                    nDetachState;
; 888  :     FTHREAD*               pFTHREAD;
; 889  :     HANDLE                 hThread;
; 890  :     DWORD                  dwThreadID;
; 891  : 
; 892  :     if (0
; 893  :         || !pdwThreadID
; 894  :         || !pfnThreadFunc

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	75 16		 jne	 SHORT $LN3@fthread_cr
  0001e	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR pdwThreadID$[rsp], 0
  00027	74 0b		 je	 SHORT $LN3@fthread_cr
  00029	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR pfnThreadFunc$[rsp], 0
  00032	75 0a		 jne	 SHORT $LN2@fthread_cr
$LN3@fthread_cr:

; 895  :     )
; 896  :         return RC(EINVAL);

  00034	b8 16 00 00 00	 mov	 eax, 22
  00039	e9 81 02 00 00	 jmp	 $LN1@fthread_cr
$LN2@fthread_cr:

; 897  : 
; 898  :     if ( pThreadAttr )

  0003e	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR pThreadAttr$[rsp], 0
  00047	74 4d		 je	 SHORT $LN4@fthread_cr

; 899  :     {
; 900  :         if (pThreadAttr->nDetachState != FTHREAD_CREATE_DETACHED &&

  00049	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pThreadAttr$[rsp]
  00051	81 78 08 63 73
	69 44		 cmp	 DWORD PTR [rax+8], 1147761507 ; 44697363H
  00058	74 1b		 je	 SHORT $LN6@fthread_cr
  0005a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pThreadAttr$[rsp]
  00062	81 78 08 6e 69
	6f 4a		 cmp	 DWORD PTR [rax+8], 1248815470 ; 4a6f696eH
  00069	74 0a		 je	 SHORT $LN6@fthread_cr

; 901  :             pThreadAttr->nDetachState != FTHREAD_CREATE_JOINABLE)
; 902  :             return RC(EINVAL);

  0006b	b8 16 00 00 00	 mov	 eax, 22
  00070	e9 4a 02 00 00	 jmp	 $LN1@fthread_cr
$LN6@fthread_cr:

; 903  : 
; 904  :         nStackSize   = pThreadAttr->nStackSize;

  00075	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pThreadAttr$[rsp]
  0007d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00080	48 89 44 24 58	 mov	 QWORD PTR nStackSize$[rsp], rax

; 905  :         nDetachState = pThreadAttr->nDetachState;

  00085	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pThreadAttr$[rsp]
  0008d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00090	89 44 24 40	 mov	 DWORD PTR nDetachState$[rsp], eax

; 906  :     }

  00094	eb 11		 jmp	 SHORT $LN5@fthread_cr
$LN4@fthread_cr:

; 907  :     else
; 908  :     {
; 909  :         nStackSize   = 0;

  00096	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR nStackSize$[rsp], 0

; 910  :         nDetachState = FTHREAD_CREATE_DEFAULT;

  0009f	c7 44 24 40 6e
	69 6f 4a	 mov	 DWORD PTR nDetachState$[rsp], 1248815470 ; 4a6f696eH
$LN5@fthread_cr:

; 911  :     }
; 912  : 
; 913  :     pCallTheirThreadParms = (FT_CALL_THREAD_PARMS*)

  000a7	b9 18 00 00 00	 mov	 ecx, 24
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000b2	48 89 44 24 38	 mov	 QWORD PTR pCallTheirThreadParms$[rsp], rax

; 914  :         malloc ( sizeof ( FT_CALL_THREAD_PARMS ) );
; 915  : 
; 916  :     if ( !pCallTheirThreadParms )

  000b7	48 83 7c 24 38
	00		 cmp	 QWORD PTR pCallTheirThreadParms$[rsp], 0
  000bd	75 16		 jne	 SHORT $LN7@fthread_cr

; 917  :     {
; 918  :         logmsg("fthread_create: malloc(FT_CALL_THREAD_PARMS) failed\n");

  000bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159503
  000c6	e8 00 00 00 00	 call	 logmsg

; 919  :         return RC(ENOMEM);      // (out of memory)

  000cb	b8 0c 00 00 00	 mov	 eax, 12
  000d0	e9 ea 01 00 00	 jmp	 $LN1@fthread_cr
$LN7@fthread_cr:

; 920  :     }
; 921  : 
; 922  :     pFTHREAD = (FTHREAD*)

  000d5	b9 40 01 00 00	 mov	 ecx, 320		; 00000140H
  000da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000e0	48 89 44 24 30	 mov	 QWORD PTR pFTHREAD$[rsp], rax

; 923  :         malloc ( sizeof( FTHREAD ) );
; 924  : 
; 925  :     if ( !pFTHREAD )

  000e5	48 83 7c 24 30
	00		 cmp	 QWORD PTR pFTHREAD$[rsp], 0
  000eb	75 21		 jne	 SHORT $LN8@fthread_cr

; 926  :     {
; 927  :         logmsg("fthread_create: malloc(FTHREAD) failed\n");

  000ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159505
  000f4	e8 00 00 00 00	 call	 logmsg

; 928  :         free ( pCallTheirThreadParms );

  000f9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pCallTheirThreadParms$[rsp]
  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 929  :         return RC(ENOMEM);      // (out of memory)

  00104	b8 0c 00 00 00	 mov	 eax, 12
  00109	e9 b1 01 00 00	 jmp	 $LN1@fthread_cr
$LN8@fthread_cr:

; 930  :     }
; 931  : 
; 932  :     pCallTheirThreadParms->pfnTheirThreadFunc = pfnThreadFunc;

  0010e	48 8b 44 24 38	 mov	 rax, QWORD PTR pCallTheirThreadParms$[rsp]
  00113	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pfnThreadFunc$[rsp]
  0011b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 933  :     pCallTheirThreadParms->pvTheirThreadArgs  = pvThreadArgs;

  0011e	48 8b 44 24 38	 mov	 rax, QWORD PTR pCallTheirThreadParms$[rsp]
  00123	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pvThreadArgs$[rsp]
  0012b	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 934  :     pCallTheirThreadParms->pFTHREAD           = pFTHREAD;

  0012f	48 8b 44 24 38	 mov	 rax, QWORD PTR pCallTheirThreadParms$[rsp]
  00134	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pFTHREAD$[rsp]
  00139	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 935  : 
; 936  :     InitializeListLink(&pFTHREAD->ThreadListLink);

  0013d	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  00142	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  0014a	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  0014f	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 937  : 
; 938  :     pFTHREAD->dwThreadID    = 0;

  00156	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  0015b	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 939  :     pFTHREAD->hThreadHandle = NULL;

  00162	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  00167	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 940  :     pFTHREAD->bJoinable     = ((FTHREAD_CREATE_JOINABLE == nDetachState) ? (TRUE) : (FALSE));

  0016f	81 7c 24 40 6e
	69 6f 4a	 cmp	 DWORD PTR nDetachState$[rsp], 1248815470 ; 4a6f696eH
  00177	75 0a		 jne	 SHORT $LN11@fthread_cr
  00179	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv130[rsp], 1
  00181	eb 08		 jmp	 SHORT $LN12@fthread_cr
$LN11@fthread_cr:
  00183	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv130[rsp], 0
$LN12@fthread_cr:
  0018b	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  00190	8b 4c 24 44	 mov	 ecx, DWORD PTR tv130[rsp]
  00194	89 48 20	 mov	 DWORD PTR [rax+32], ecx

; 941  :     pFTHREAD->nJoinedCount  = 0;

  00197	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  0019c	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [rax+36], 0

; 942  :     pFTHREAD->nPriority     = -1;

  001a3	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  001a8	c7 40 28 ff ff
	ff ff		 mov	 DWORD PTR [rax+40], -1

; 943  :     pFTHREAD->ExitVal       = NULL;

  001af	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  001b4	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 944  : 
; 945  :     LockThreadsList();

  001bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ThreadListLock
  001c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 946  : 
; 947  :     hThread =

  001c9	48 8d 44 24 48	 lea	 rax, QWORD PTR dwThreadID$[rsp]
  001ce	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001d3	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  001db	4c 8b 4c 24 38	 mov	 r9, QWORD PTR pCallTheirThreadParms$[rsp]
  001e0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:FTWin32ThreadFunc
  001e7	8b 54 24 58	 mov	 edx, DWORD PTR nStackSize$[rsp]
  001eb	33 c9		 xor	 ecx, ecx
  001ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__beginthreadex
  001f3	48 89 44 24 60	 mov	 QWORD PTR hThread$[rsp], rax

; 948  :         MyCreateThread ( NULL, nStackSize, FTWin32ThreadFunc, pCallTheirThreadParms, 0, &dwThreadID );
; 949  : 
; 950  :     if ( !hThread )

  001f8	48 83 7c 24 60
	00		 cmp	 QWORD PTR hThread$[rsp], 0
  001fe	75 39		 jne	 SHORT $LN9@fthread_cr

; 951  :     {
; 952  :         UnlockThreadsList();

  00200	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ThreadListLock
  00207	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 953  :         logmsg("fthread_create: MyCreateThread failed\n");

  0020d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159507
  00214	e8 00 00 00 00	 call	 logmsg

; 954  :         free ( pCallTheirThreadParms );

  00219	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pCallTheirThreadParms$[rsp]
  0021e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 955  :         free ( pFTHREAD );

  00224	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pFTHREAD$[rsp]
  00229	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 956  :         return RC(EAGAIN);      // (unable to obtain required resources)

  0022f	b8 0b 00 00 00	 mov	 eax, 11
  00234	e9 86 00 00 00	 jmp	 $LN1@fthread_cr
$LN9@fthread_cr:

; 957  :     }
; 958  : 
; 959  :     pFTHREAD->hThreadHandle = hThread;

  00239	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  0023e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR hThread$[rsp]
  00243	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 960  :     pFTHREAD->dwThreadID    = dwThreadID;

  00247	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  0024c	8b 4c 24 48	 mov	 ecx, DWORD PTR dwThreadID$[rsp]
  00250	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 961  :     *pdwThreadID            = dwThreadID;

  00253	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pdwThreadID$[rsp]
  0025b	8b 4c 24 48	 mov	 ecx, DWORD PTR dwThreadID$[rsp]
  0025f	89 08		 mov	 DWORD PTR [rax], ecx

; 962  : 
; 963  :     InsertListHead ( &ThreadListHead, &pFTHREAD->ThreadListLink );

  00261	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ThreadListHead
  00268	48 89 44 24 50	 mov	 QWORD PTR _EX_Head$1[rsp], rax
  0026d	48 8b 44 24 50	 mov	 rax, QWORD PTR _EX_Head$1[rsp]
  00272	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00275	48 89 44 24 68	 mov	 QWORD PTR _EX_Next$2[rsp], rax
  0027a	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  0027f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _EX_Next$2[rsp]
  00284	48 89 08	 mov	 QWORD PTR [rax], rcx
  00287	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  0028c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _EX_Head$1[rsp]
  00291	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00295	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  0029a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _EX_Head$1[rsp]
  0029f	48 89 01	 mov	 QWORD PTR [rcx], rax
  002a2	48 8b 44 24 30	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  002a7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _EX_Next$2[rsp]
  002ac	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 964  : 
; 965  :     UnlockThreadsList();

  002b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ThreadListLock
  002b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 966  : 
; 967  :     return RC(0);

  002bd	33 c0		 xor	 eax, eax
$LN1@fthread_cr:

; 968  : }

  002bf	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002c3	c3		 ret	 0
fthread_create ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pFTHREAD$ = 32
dwThreadID$ = 64
fthread_get_handle PROC

; 850  : {

$LN6:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 851  :     FTHREAD*      pFTHREAD = NULL;          // Local pointer storage

  00008	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR pFTHREAD$[rsp], 0

; 852  : 
; 853  :     if ( dwThreadID != 0 )

  00011	83 7c 24 40 00	 cmp	 DWORD PTR dwThreadID$[rsp], 0
  00016	74 22		 je	 SHORT $LN2@fthread_ge

; 854  :     {
; 855  :         // If request is for current thread then it's easy
; 856  : 
; 857  :         if (GetCurrentThreadId() == dwThreadID)

  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  0001e	3b 44 24 40	 cmp	 eax, DWORD PTR dwThreadID$[rsp]
  00022	75 08		 jne	 SHORT $LN3@fthread_ge

; 858  :             return GetCurrentThread();

  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThread
  0002a	eb 30		 jmp	 SHORT $LN1@fthread_ge
$LN3@fthread_ge:

; 859  : 
; 860  :         // Otherwise we need to look in our list
; 861  : 
; 862  :         pFTHREAD = FindFTHREAD( dwThreadID );

  0002c	8b 4c 24 40	 mov	 ecx, DWORD PTR dwThreadID$[rsp]
  00030	e8 00 00 00 00	 call	 FindFTHREAD
  00035	48 89 44 24 20	 mov	 QWORD PTR pFTHREAD$[rsp], rax
$LN2@fthread_ge:

; 863  :     }
; 864  : 
; 865  :     if ( pFTHREAD != NULL )

  0003a	48 83 7c 24 20
	00		 cmp	 QWORD PTR pFTHREAD$[rsp], 0
  00040	74 18		 je	 SHORT $LN4@fthread_ge

; 866  :     {
; 867  :         UnlockThreadsList();    // (release thread list lock

  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ThreadListLock
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 868  :         return pFTHREAD->hThreadHandle;

  0004f	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  00054	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00058	eb 02		 jmp	 SHORT $LN1@fthread_ge
$LN4@fthread_ge:

; 869  :     }
; 870  : 
; 871  :     return NULL;

  0005a	33 c0		 xor	 eax, eax
$LN1@fthread_ge:

; 872  : }

  0005c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00060	c3		 ret	 0
fthread_get_handle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pFTHREAD$ = 32
_EX_Flink$1 = 40
_EX_Blink$2 = 48
dwThreadID$ = 80
fthread_detach PROC

; 1069 : {

$LN6:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1070 :     FTHREAD*  pFTHREAD;
; 1071 : 
; 1072 :     if ( !( pFTHREAD = FindFTHREAD ( dwThreadID ) ) )

  00008	8b 4c 24 50	 mov	 ecx, DWORD PTR dwThreadID$[rsp]
  0000c	e8 00 00 00 00	 call	 FindFTHREAD
  00011	48 89 44 24 20	 mov	 QWORD PTR pFTHREAD$[rsp], rax
  00016	48 83 7c 24 20
	00		 cmp	 QWORD PTR pFTHREAD$[rsp], 0
  0001c	75 0a		 jne	 SHORT $LN2@fthread_de

; 1073 :         return RC(ESRCH);           // (thread not found)

  0001e	b8 03 00 00 00	 mov	 eax, 3
  00023	e9 ad 00 00 00	 jmp	 $LN1@fthread_de
$LN2@fthread_de:

; 1074 : 
; 1075 :     // (Note: threads list lock still held at this point
; 1076 :     //  since thread was found...)
; 1077 : 
; 1078 :     if ( !pFTHREAD->bJoinable )

  00028	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  0002d	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  00031	75 17		 jne	 SHORT $LN3@fthread_de

; 1079 :     {
; 1080 :         UnlockThreadsList();

  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ThreadListLock
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 1081 :         return RC(EINVAL);          // (not a joinable thread)

  00040	b8 16 00 00 00	 mov	 eax, 22
  00045	e9 8b 00 00 00	 jmp	 $LN1@fthread_de
$LN3@fthread_de:

; 1082 :     }
; 1083 : 
; 1084 :     // If the thread has not yet exited, then IT will free its
; 1085 :     // own resources itself whenever it eventually does exit by
; 1086 :     // virtue of our changing it to a non-joinable thread type.
; 1087 : 
; 1088 :     pFTHREAD->bJoinable = FALSE;    // (indicate detach was done)

  0004a	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  0004f	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 1089 : 
; 1090 :     // Otherwise we need to free its resources ourselves since
; 1091 :     // it obviously can't (since it has already exited).
; 1092 : 
; 1093 :     // Note that we cannot free the resources ourselves even if the
; 1094 :     // thread has already exited if there are still other threads
; 1095 :     // waiting to be woken up from their own join (since they will
; 1096 :     // still need to have access to the resources). In other words,
; 1097 :     // even if the thread has already exited (and thus it would seem
; 1098 :     // that our freeing the resources would be the proper thing to
; 1099 :     // do), we CANNOT do so if the 'join' count is non-zero.
; 1100 : 
; 1101 :     // In such a situation (the join count being non-zero indicating
; 1102 :     // there is still another thread waiting to be resumed from its
; 1103 :     // own join), we simply defer the actual freeing of resources to
; 1104 :     // the thread still waiting to be woken up from its join. Whenever
; 1105 :     // it does eventually wake up from its join, it will free the
; 1106 :     // resources for us, as long as we remember to reset the 'joinable'
; 1107 :     // flag back to non-joinable (which we've already done just above).
; 1108 : 
; 1109 :     if ( IsEventSet ( pFTHREAD->hThreadHandle ) && pFTHREAD->nJoinedCount <= 0 )

  00056	33 d2		 xor	 edx, edx
  00058	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  0005d	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
  00067	85 c0		 test	 eax, eax
  00069	75 5b		 jne	 SHORT $LN4@fthread_de
  0006b	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  00070	83 78 24 00	 cmp	 DWORD PTR [rax+36], 0
  00074	7f 50		 jg	 SHORT $LN4@fthread_de

; 1110 :     {
; 1111 :         CloseHandle ( pFTHREAD->hThreadHandle );

  00076	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  0007b	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 1112 :         RemoveListEntry ( &pFTHREAD->ThreadListLink );

  00085	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  0008a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008d	48 89 44 24 28	 mov	 QWORD PTR _EX_Flink$1[rsp], rax
  00092	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  00097	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0009b	48 89 44 24 30	 mov	 QWORD PTR _EX_Blink$2[rsp], rax
  000a0	48 8b 44 24 30	 mov	 rax, QWORD PTR _EX_Blink$2[rsp]
  000a5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _EX_Flink$1[rsp]
  000aa	48 89 08	 mov	 QWORD PTR [rax], rcx
  000ad	48 8b 44 24 28	 mov	 rax, QWORD PTR _EX_Flink$1[rsp]
  000b2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _EX_Blink$2[rsp]
  000b7	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1113 :         free ( pFTHREAD );

  000bb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pFTHREAD$[rsp]
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN4@fthread_de:

; 1114 :     }
; 1115 : 
; 1116 :     UnlockThreadsList();

  000c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ThreadListLock
  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 1117 : 
; 1118 :     return RC(0);

  000d3	33 c0		 xor	 eax, eax
$LN1@fthread_de:

; 1119 : }

  000d5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000d9	c3		 ret	 0
fthread_detach ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pFTHREAD$ = 32
_EX_Flink$1 = 40
_EX_Blink$2 = 48
hThread$ = 56
dwThreadID$ = 80
pExitVal$ = 88
fthread_join PROC

; 995  : {

$LN26:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 996  :     HANDLE    hThread;
; 997  :     FTHREAD*  pFTHREAD;
; 998  : 
; 999  :     if ( GetCurrentThreadId() == dwThreadID )

  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  00013	3b 44 24 50	 cmp	 eax, DWORD PTR dwThreadID$[rsp]
  00017	75 0a		 jne	 SHORT $LN14@fthread_jo

; 1000 :         return RC(EDEADLK);             // (can't join self!)

  00019	b8 24 00 00 00	 mov	 eax, 36			; 00000024H
  0001e	e9 04 02 00 00	 jmp	 $LN1@fthread_jo
$LN14@fthread_jo:

; 1001 : 
; 1002 :     if ( !(pFTHREAD = FindFTHREAD ( dwThreadID ) ) )

  00023	8b 4c 24 50	 mov	 ecx, DWORD PTR dwThreadID$[rsp]
  00027	e8 00 00 00 00	 call	 FindFTHREAD
  0002c	48 89 44 24 20	 mov	 QWORD PTR pFTHREAD$[rsp], rax
  00031	48 83 7c 24 20
	00		 cmp	 QWORD PTR pFTHREAD$[rsp], 0
  00037	75 0a		 jne	 SHORT $LN15@fthread_jo

; 1003 :         return RC(ESRCH);               // (thread not found)

  00039	b8 03 00 00 00	 mov	 eax, 3
  0003e	e9 e4 01 00 00	 jmp	 $LN1@fthread_jo
$LN15@fthread_jo:

; 1004 : 
; 1005 :     // (Note: threads list lock still held at this point
; 1006 :     //  since thread was found...)
; 1007 : 
; 1008 :     if ( !pFTHREAD->bJoinable )

  00043	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  00048	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  0004c	75 17		 jne	 SHORT $LN16@fthread_jo

; 1009 :     {
; 1010 :         UnlockThreadsList();

  0004e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ThreadListLock
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 1011 :         return RC(EINVAL);              // (not a joinable thread)

  0005b	b8 16 00 00 00	 mov	 eax, 22
  00060	e9 c2 01 00 00	 jmp	 $LN1@fthread_jo
$LN16@fthread_jo:
$LN4@fthread_jo:

; 1012 :     }
; 1013 : 
; 1014 :     ASSERT ( pFTHREAD->nJoinedCount >= 0 );

  00065	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  0006a	83 78 24 00	 cmp	 DWORD PTR [rax+36], 0
  0006e	7d 5b		 jge	 SHORT $LN17@fthread_jo
$LN7@fthread_jo:
  00070	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159553
  00077	41 b8 f6 03 00
	00		 mov	 r8d, 1014		; 000003f6H
  0007d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159554
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159555
  0008b	e8 00 00 00 00	 call	 logmsg
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00096	85 c0		 test	 eax, eax
  00098	74 20		 je	 SHORT $LN18@fthread_jo
  0009a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159557
  000a1	41 b8 f6 03 00
	00		 mov	 r8d, 1014		; 000003f6H
  000a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159558
  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159559
  000b5	e8 00 00 00 00	 call	 DebuggerTrace
$LN18@fthread_jo:
  000ba	33 c0		 xor	 eax, eax
  000bc	85 c0		 test	 eax, eax
  000be	75 b0		 jne	 SHORT $LN7@fthread_jo
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000c6	85 c0		 test	 eax, eax
  000c8	74 01		 je	 SHORT $LN19@fthread_jo
  000ca	cc		 int	 3
$LN19@fthread_jo:
$LN17@fthread_jo:
  000cb	33 c0		 xor	 eax, eax
  000cd	85 c0		 test	 eax, eax
  000cf	75 94		 jne	 SHORT $LN4@fthread_jo

; 1015 :     pFTHREAD->nJoinedCount++;

  000d1	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  000d6	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  000d9	ff c0		 inc	 eax
  000db	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pFTHREAD$[rsp]
  000e0	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 1016 :     hThread = pFTHREAD->hThreadHandle;

  000e3	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  000e8	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000ec	48 89 44 24 38	 mov	 QWORD PTR hThread$[rsp], rax

; 1017 : 
; 1018 :     // Wait for thread to exit...
; 1019 : 
; 1020 :     UnlockThreadsList();

  000f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ThreadListLock
  000f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 1021 :     {
; 1022 :         WaitForSingleObject ( hThread, INFINITE );

  000fe	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  00103	48 8b 4c 24 38	 mov	 rcx, QWORD PTR hThread$[rsp]
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject

; 1023 :     }
; 1024 :     LockThreadsList();

  0010e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ThreadListLock
  00115	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 1025 : 
; 1026 :     if ( pExitVal )

  0011b	48 83 7c 24 58
	00		 cmp	 QWORD PTR pExitVal$[rsp], 0
  00121	74 11		 je	 SHORT $LN20@fthread_jo

; 1027 :         *pExitVal = pFTHREAD->ExitVal;  // (pass back thread's exit value)

  00123	48 8b 44 24 58	 mov	 rax, QWORD PTR pExitVal$[rsp]
  00128	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pFTHREAD$[rsp]
  0012d	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00131	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN20@fthread_jo:
$LN10@fthread_jo:

; 1028 : 
; 1029 :     ASSERT ( pFTHREAD->nJoinedCount > 0 );

  00134	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  00139	83 78 24 00	 cmp	 DWORD PTR [rax+36], 0
  0013d	7f 5b		 jg	 SHORT $LN21@fthread_jo
$LN13@fthread_jo:
  0013f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159563
  00146	41 b8 05 04 00
	00		 mov	 r8d, 1029		; 00000405H
  0014c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159564
  00153	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159565
  0015a	e8 00 00 00 00	 call	 logmsg
  0015f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00165	85 c0		 test	 eax, eax
  00167	74 20		 je	 SHORT $LN22@fthread_jo
  00169	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159567
  00170	41 b8 05 04 00
	00		 mov	 r8d, 1029		; 00000405H
  00176	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159568
  0017d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159569
  00184	e8 00 00 00 00	 call	 DebuggerTrace
$LN22@fthread_jo:
  00189	33 c0		 xor	 eax, eax
  0018b	85 c0		 test	 eax, eax
  0018d	75 b0		 jne	 SHORT $LN13@fthread_jo
  0018f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00195	85 c0		 test	 eax, eax
  00197	74 01		 je	 SHORT $LN23@fthread_jo
  00199	cc		 int	 3
$LN23@fthread_jo:
$LN21@fthread_jo:
  0019a	33 c0		 xor	 eax, eax
  0019c	85 c0		 test	 eax, eax
  0019e	75 94		 jne	 SHORT $LN10@fthread_jo

; 1030 :     pFTHREAD->nJoinedCount--;

  001a0	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  001a5	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  001a8	ff c8		 dec	 eax
  001aa	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pFTHREAD$[rsp]
  001af	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 1031 : 
; 1032 :     // If this is the last thread to be resumed after having been suspended
; 1033 :     // (as a result of doing the join), then we need to do the detach (i.e.
; 1034 :     // to free resources), BUT ONLY IF the detach for the thread in question
; 1035 :     // has already been done by someone (which can be determined by virtue of
; 1036 :     // the "joinable" flag having already been changed back to non-joinable).
; 1037 : 
; 1038 :     // The idea here is that the 'detach' function purposely does not free
; 1039 :     // the resources unless the 'joined' count is zero. If the joined count
; 1040 :     // is NOT zero whenever the detach function is called, then the resources
; 1041 :     // cannot be freed since there's still a thread waiting to be resumed
; 1042 :     // from its join (perhaps us!), and it obviously still needs access to
; 1043 :     // the resources in question. Thus, in such a situation (i.e. there still
; 1044 :     // being a thread remaining to be woken up from its join when the detach
; 1045 :     // is done), the freeing of resources normally done by the detach function
; 1046 :     // is deferred so that WE can do the resource freeing ourselves once we
; 1047 :     // are done with them.
; 1048 : 
; 1049 :     if ( !pFTHREAD->bJoinable && pFTHREAD->nJoinedCount <= 0 )

  001b2	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  001b7	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  001bb	75 5b		 jne	 SHORT $LN24@fthread_jo
  001bd	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  001c2	83 78 24 00	 cmp	 DWORD PTR [rax+36], 0
  001c6	7f 50		 jg	 SHORT $LN24@fthread_jo

; 1050 :     {
; 1051 :         CloseHandle ( pFTHREAD->hThreadHandle );

  001c8	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  001cd	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  001d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 1052 :         RemoveListEntry ( &pFTHREAD->ThreadListLink );

  001d7	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  001dc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001df	48 89 44 24 28	 mov	 QWORD PTR _EX_Flink$1[rsp], rax
  001e4	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  001e9	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001ed	48 89 44 24 30	 mov	 QWORD PTR _EX_Blink$2[rsp], rax
  001f2	48 8b 44 24 30	 mov	 rax, QWORD PTR _EX_Blink$2[rsp]
  001f7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _EX_Flink$1[rsp]
  001fc	48 89 08	 mov	 QWORD PTR [rax], rcx
  001ff	48 8b 44 24 28	 mov	 rax, QWORD PTR _EX_Flink$1[rsp]
  00204	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _EX_Blink$2[rsp]
  00209	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1053 :         free ( pFTHREAD );

  0020d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pFTHREAD$[rsp]
  00212	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN24@fthread_jo:

; 1054 :     }
; 1055 : 
; 1056 :     UnlockThreadsList();

  00218	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ThreadListLock
  0021f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 1057 : 
; 1058 :     return RC(0);

  00225	33 c0		 xor	 eax, eax
$LN1@fthread_jo:

; 1059 : }

  00227	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0022b	c3		 ret	 0
fthread_join ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pThreadAttr$ = 8
pnStackSize$ = 16
fthread_attr_getstacksize PROC

; 1228 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1229 :     if ( !pThreadAttr || !pnStackSize )

  0000a	48 83 7c 24 08
	00		 cmp	 QWORD PTR pThreadAttr$[rsp], 0
  00010	74 08		 je	 SHORT $LN3@fthread_at
  00012	48 83 7c 24 10
	00		 cmp	 QWORD PTR pnStackSize$[rsp], 0
  00018	75 07		 jne	 SHORT $LN2@fthread_at
$LN3@fthread_at:

; 1230 :         return RC(EINVAL);          // (invalid ptr)

  0001a	b8 16 00 00 00	 mov	 eax, 22
  0001f	eb 12		 jmp	 SHORT $LN1@fthread_at
$LN2@fthread_at:

; 1231 : 
; 1232 :     *pnStackSize = pThreadAttr->nStackSize;

  00021	48 8b 44 24 10	 mov	 rax, QWORD PTR pnStackSize$[rsp]
  00026	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pThreadAttr$[rsp]
  0002b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002e	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1233 : 
; 1234 :     return RC(0);

  00031	33 c0		 xor	 eax, eax
$LN1@fthread_at:

; 1235 : }

  00033	c3		 ret	 0
fthread_attr_getstacksize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pThreadAttr$ = 8
nStackSize$ = 16
fthread_attr_setstacksize PROC

; 1210 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1211 :     if ( !pThreadAttr )

  0000a	48 83 7c 24 08
	00		 cmp	 QWORD PTR pThreadAttr$[rsp], 0
  00010	75 07		 jne	 SHORT $LN2@fthread_at

; 1212 :         return RC(EINVAL);          // (invalid ptr)

  00012	b8 16 00 00 00	 mov	 eax, 22
  00017	eb 0f		 jmp	 SHORT $LN1@fthread_at
$LN2@fthread_at:

; 1213 : 
; 1214 :     pThreadAttr->nStackSize = nStackSize;

  00019	48 8b 44 24 08	 mov	 rax, QWORD PTR pThreadAttr$[rsp]
  0001e	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nStackSize$[rsp]
  00023	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1215 : 
; 1216 :     return RC(0);

  00026	33 c0		 xor	 eax, eax
$LN1@fthread_at:

; 1217 : }

  00028	c3		 ret	 0
fthread_attr_setstacksize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pThreadAttr$ = 8
pnDetachState$ = 16
fthread_attr_getdetachstate PROC

; 1188 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1189 :     if ( !pThreadAttr || !pnDetachState )

  0000a	48 83 7c 24 08
	00		 cmp	 QWORD PTR pThreadAttr$[rsp], 0
  00010	74 08		 je	 SHORT $LN3@fthread_at
  00012	48 83 7c 24 10
	00		 cmp	 QWORD PTR pnDetachState$[rsp], 0
  00018	75 07		 jne	 SHORT $LN2@fthread_at
$LN3@fthread_at:

; 1190 :         return RC(EINVAL);          // (invalid ptr)

  0001a	b8 16 00 00 00	 mov	 eax, 22
  0001f	eb 34		 jmp	 SHORT $LN1@fthread_at
$LN2@fthread_at:

; 1191 : 
; 1192 :     if ( FTHREAD_CREATE_DETACHED != pThreadAttr->nDetachState &&

  00021	48 8b 44 24 08	 mov	 rax, QWORD PTR pThreadAttr$[rsp]
  00026	81 78 08 63 73
	69 44		 cmp	 DWORD PTR [rax+8], 1147761507 ; 44697363H
  0002d	74 15		 je	 SHORT $LN4@fthread_at
  0002f	48 8b 44 24 08	 mov	 rax, QWORD PTR pThreadAttr$[rsp]
  00034	81 78 08 6e 69
	6f 4a		 cmp	 DWORD PTR [rax+8], 1248815470 ; 4a6f696eH
  0003b	74 07		 je	 SHORT $LN4@fthread_at

; 1193 :          FTHREAD_CREATE_JOINABLE != pThreadAttr->nDetachState )
; 1194 :         return RC(EINVAL);          // (invalid detach state)

  0003d	b8 16 00 00 00	 mov	 eax, 22
  00042	eb 11		 jmp	 SHORT $LN1@fthread_at
$LN4@fthread_at:

; 1195 : 
; 1196 :     *pnDetachState = pThreadAttr->nDetachState;

  00044	48 8b 44 24 10	 mov	 rax, QWORD PTR pnDetachState$[rsp]
  00049	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pThreadAttr$[rsp]
  0004e	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00051	89 08		 mov	 DWORD PTR [rax], ecx

; 1197 : 
; 1198 :     return RC(0);

  00053	33 c0		 xor	 eax, eax
$LN1@fthread_at:

; 1199 : }

  00055	c3		 ret	 0
fthread_attr_getdetachstate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pThreadAttr$ = 8
nDetachState$ = 16
fthread_attr_setdetachstate PROC

; 1166 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1167 :     if ( !pThreadAttr )

  00009	48 83 7c 24 08
	00		 cmp	 QWORD PTR pThreadAttr$[rsp], 0
  0000f	75 07		 jne	 SHORT $LN2@fthread_at

; 1168 :         return RC(EINVAL);          // (invalid ptr)

  00011	b8 16 00 00 00	 mov	 eax, 22
  00016	eb 29		 jmp	 SHORT $LN1@fthread_at
$LN2@fthread_at:

; 1169 : 
; 1170 :     if ( FTHREAD_CREATE_DETACHED != nDetachState &&

  00018	81 7c 24 10 63
	73 69 44	 cmp	 DWORD PTR nDetachState$[rsp], 1147761507 ; 44697363H
  00020	74 11		 je	 SHORT $LN3@fthread_at
  00022	81 7c 24 10 6e
	69 6f 4a	 cmp	 DWORD PTR nDetachState$[rsp], 1248815470 ; 4a6f696eH
  0002a	74 07		 je	 SHORT $LN3@fthread_at

; 1171 :          FTHREAD_CREATE_JOINABLE != nDetachState )
; 1172 :         return RC(EINVAL);          // (invalid detach state)

  0002c	b8 16 00 00 00	 mov	 eax, 22
  00031	eb 0e		 jmp	 SHORT $LN1@fthread_at
$LN3@fthread_at:

; 1173 : 
; 1174 :     pThreadAttr->nDetachState = nDetachState;

  00033	48 8b 44 24 08	 mov	 rax, QWORD PTR pThreadAttr$[rsp]
  00038	8b 4c 24 10	 mov	 ecx, DWORD PTR nDetachState$[rsp]
  0003c	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 1175 : 
; 1176 :     return RC(0);

  0003f	33 c0		 xor	 eax, eax
$LN1@fthread_at:

; 1177 : }

  00041	c3		 ret	 0
fthread_attr_setdetachstate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pThreadAttr$ = 8
fthread_attr_destroy PROC

; 1147 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1148 :     if ( !pThreadAttr )

  00005	48 83 7c 24 08
	00		 cmp	 QWORD PTR pThreadAttr$[rsp], 0
  0000b	75 07		 jne	 SHORT $LN2@fthread_at

; 1149 :         return RC(EINVAL);      // (invalid ptr)

  0000d	b8 16 00 00 00	 mov	 eax, 22
  00012	eb 1a		 jmp	 SHORT $LN1@fthread_at
$LN2@fthread_at:

; 1150 : 
; 1151 :     pThreadAttr->nDetachState = 0;

  00014	48 8b 44 24 08	 mov	 rax, QWORD PTR pThreadAttr$[rsp]
  00019	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 1152 :     pThreadAttr->nStackSize   = 0;

  00020	48 8b 44 24 08	 mov	 rax, QWORD PTR pThreadAttr$[rsp]
  00025	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1153 : 
; 1154 :     return RC(0);

  0002c	33 c0		 xor	 eax, eax
$LN1@fthread_at:

; 1155 : }

  0002e	c3		 ret	 0
fthread_attr_destroy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pThreadAttr$ = 8
fthread_attr_init PROC

; 1129 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1130 :     if ( !pThreadAttr )

  00005	48 83 7c 24 08
	00		 cmp	 QWORD PTR pThreadAttr$[rsp], 0
  0000b	75 07		 jne	 SHORT $LN2@fthread_at

; 1131 :         return RC(EINVAL);          // (invalid ptr)

  0000d	b8 16 00 00 00	 mov	 eax, 22
  00012	eb 1a		 jmp	 SHORT $LN1@fthread_at
$LN2@fthread_at:

; 1132 : 
; 1133 :     pThreadAttr->nDetachState = FTHREAD_CREATE_DEFAULT;

  00014	48 8b 44 24 08	 mov	 rax, QWORD PTR pThreadAttr$[rsp]
  00019	c7 40 08 6e 69
	6f 4a		 mov	 DWORD PTR [rax+8], 1248815470 ; 4a6f696eH

; 1134 :     pThreadAttr->nStackSize   = 0;

  00020	48 8b 44 24 08	 mov	 rax, QWORD PTR pThreadAttr$[rsp]
  00025	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1135 : 
; 1136 :     return RC(0);

  0002c	33 c0		 xor	 eax, eax
$LN1@fthread_at:

; 1137 : }

  0002e	c3		 ret	 0
fthread_attr_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
nPolicy$ = 8
fthread_get_priority_max PROC

; 1861 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 1862 :     if (nPolicy != FTHREAD_POLICY)

  00004	83 7c 24 08 01	 cmp	 DWORD PTR nPolicy$[rsp], 1
  00009	74 07		 je	 SHORT $LN2@fthread_ge

; 1863 :         return RC(ENOTSUP);

  0000b	b8 81 00 00 00	 mov	 eax, 129		; 00000081H
  00010	eb 05		 jmp	 SHORT $LN1@fthread_ge
$LN2@fthread_ge:

; 1864 :     return FTHREAD_MAX_PRIO;

  00012	b8 1f 00 00 00	 mov	 eax, 31
$LN1@fthread_ge:

; 1865 : }

  00017	c3		 ret	 0
fthread_get_priority_max ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
nPolicy$ = 8
fthread_get_priority_min PROC

; 1854 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 1855 :     if (nPolicy != FTHREAD_POLICY)

  00004	83 7c 24 08 01	 cmp	 DWORD PTR nPolicy$[rsp], 1
  00009	74 07		 je	 SHORT $LN2@fthread_ge

; 1856 :         return RC(ENOTSUP);

  0000b	b8 81 00 00 00	 mov	 eax, 129		; 00000081H
  00010	eb 02		 jmp	 SHORT $LN1@fthread_ge
$LN2@fthread_ge:

; 1857 :     return FTHREAD_MIN_PRIO;

  00012	33 c0		 xor	 eax, eax
$LN1@fthread_ge:

; 1858 : }

  00014	c3		 ret	 0
fthread_get_priority_min ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
hThread$ = 32
pFTHREAD$ = 40
dwThreadID$ = 64
nPolicy$ = 72
pSCHPARM$ = 80
fthread_setschedparam PROC

; 1829 : {

$LN15:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1830 :     FTHREAD*  pFTHREAD;
; 1831 :     HANDLE    hThread;
; 1832 : 
; 1833 :     if (nPolicy != FTHREAD_POLICY)

  00011	83 7c 24 48 01	 cmp	 DWORD PTR nPolicy$[rsp], 1
  00016	74 0a		 je	 SHORT $LN8@fthread_se

; 1834 :         return RC(ENOTSUP);

  00018	b8 81 00 00 00	 mov	 eax, 129		; 00000081H
  0001d	e9 f4 00 00 00	 jmp	 $LN1@fthread_se
$LN8@fthread_se:

; 1835 : 
; 1836 :     if (0
; 1837 :         || !pSCHPARM
; 1838 :         ||  pSCHPARM->sched_priority < FTHREAD_MIN_PRIO
; 1839 :         ||  pSCHPARM->sched_priority > FTHREAD_MAX_PRIO
; 1840 :         || !(hThread = fthread_get_handle( dwThreadID ))
; 1841 :         || !SetThreadPriority( hThread, F2WPriority( pSCHPARM->sched_priority ))

  00022	33 c0		 xor	 eax, eax
  00024	85 c0		 test	 eax, eax
  00026	75 4f		 jne	 SHORT $LN10@fthread_se
  00028	48 83 7c 24 50
	00		 cmp	 QWORD PTR pSCHPARM$[rsp], 0
  0002e	74 47		 je	 SHORT $LN10@fthread_se
  00030	48 8b 44 24 50	 mov	 rax, QWORD PTR pSCHPARM$[rsp]
  00035	83 38 00	 cmp	 DWORD PTR [rax], 0
  00038	7c 3d		 jl	 SHORT $LN10@fthread_se
  0003a	48 8b 44 24 50	 mov	 rax, QWORD PTR pSCHPARM$[rsp]
  0003f	83 38 1f	 cmp	 DWORD PTR [rax], 31
  00042	7f 33		 jg	 SHORT $LN10@fthread_se
  00044	8b 4c 24 40	 mov	 ecx, DWORD PTR dwThreadID$[rsp]
  00048	e8 00 00 00 00	 call	 fthread_get_handle
  0004d	48 89 44 24 20	 mov	 QWORD PTR hThread$[rsp], rax
  00052	48 83 7c 24 20
	00		 cmp	 QWORD PTR hThread$[rsp], 0
  00058	74 1d		 je	 SHORT $LN10@fthread_se
  0005a	48 8b 44 24 50	 mov	 rax, QWORD PTR pSCHPARM$[rsp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [rax]
  00061	e8 00 00 00 00	 call	 F2WPriority
  00066	8b d0		 mov	 edx, eax
  00068	48 8b 4c 24 20	 mov	 rcx, QWORD PTR hThread$[rsp]
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetThreadPriority
  00073	85 c0		 test	 eax, eax
  00075	75 0a		 jne	 SHORT $LN9@fthread_se
$LN10@fthread_se:

; 1842 :     )
; 1843 :         return RC(EINVAL);

  00077	b8 16 00 00 00	 mov	 eax, 22
  0007c	e9 95 00 00 00	 jmp	 $LN1@fthread_se
$LN9@fthread_se:
$LN4@fthread_se:

; 1844 : 
; 1845 :     VERIFY((pFTHREAD = FindFTHREAD( dwThreadID )));

  00081	8b 4c 24 40	 mov	 ecx, DWORD PTR dwThreadID$[rsp]
  00085	e8 00 00 00 00	 call	 FindFTHREAD
  0008a	48 89 44 24 28	 mov	 QWORD PTR pFTHREAD$[rsp], rax
  0008f	48 83 7c 24 28
	00		 cmp	 QWORD PTR pFTHREAD$[rsp], 0
  00095	75 5b		 jne	 SHORT $LN11@fthread_se
$LN7@fthread_se:
  00097	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159857
  0009e	41 b8 35 07 00
	00		 mov	 r8d, 1845		; 00000735H
  000a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159858
  000ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159859
  000b2	e8 00 00 00 00	 call	 logmsg
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000bd	85 c0		 test	 eax, eax
  000bf	74 20		 je	 SHORT $LN12@fthread_se
  000c1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159861
  000c8	41 b8 35 07 00
	00		 mov	 r8d, 1845		; 00000735H
  000ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159862
  000d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159863
  000dc	e8 00 00 00 00	 call	 DebuggerTrace
$LN12@fthread_se:
  000e1	33 c0		 xor	 eax, eax
  000e3	85 c0		 test	 eax, eax
  000e5	75 b0		 jne	 SHORT $LN7@fthread_se
  000e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000ed	85 c0		 test	 eax, eax
  000ef	74 01		 je	 SHORT $LN13@fthread_se
  000f1	cc		 int	 3
$LN13@fthread_se:
$LN11@fthread_se:
  000f2	33 c0		 xor	 eax, eax
  000f4	85 c0		 test	 eax, eax
  000f6	75 89		 jne	 SHORT $LN4@fthread_se

; 1846 :     pFTHREAD->nPriority = pSCHPARM->sched_priority;

  000f8	48 8b 44 24 28	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  000fd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pSCHPARM$[rsp]
  00102	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00104	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 1847 :     UnlockThreadsList();

  00107	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ThreadListLock
  0010e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 1848 :     return RC(0);

  00114	33 c0		 xor	 eax, eax
$LN1@fthread_se:

; 1849 : }

  00116	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0011a	c3		 ret	 0
fthread_setschedparam ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
nWindowsPriority$ = 32
pFTHREAD$ = 40
hThread$ = 48
dwThreadID$ = 80
pnPolicy$ = 88
pSCHPARM$ = 96
fthread_getschedparam PROC

; 1799 : {

$LN9:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1800 :     FTHREAD*  pFTHREAD;
; 1801 :     HANDLE    hThread;
; 1802 :     int       nWindowsPriority;
; 1803 : 
; 1804 :     if (0
; 1805 :         || !pnPolicy
; 1806 :         || !pSCHPARM
; 1807 :         || !(hThread = fthread_get_handle( dwThreadID ))
; 1808 :         || THREAD_PRIORITY_ERROR_RETURN == (nWindowsPriority = GetThreadPriority( hThread ))

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 3f		 jne	 SHORT $LN3@fthread_ge
  00018	48 83 7c 24 58
	00		 cmp	 QWORD PTR pnPolicy$[rsp], 0
  0001e	74 37		 je	 SHORT $LN3@fthread_ge
  00020	48 83 7c 24 60
	00		 cmp	 QWORD PTR pSCHPARM$[rsp], 0
  00026	74 2f		 je	 SHORT $LN3@fthread_ge
  00028	8b 4c 24 50	 mov	 ecx, DWORD PTR dwThreadID$[rsp]
  0002c	e8 00 00 00 00	 call	 fthread_get_handle
  00031	48 89 44 24 30	 mov	 QWORD PTR hThread$[rsp], rax
  00036	48 83 7c 24 30
	00		 cmp	 QWORD PTR hThread$[rsp], 0
  0003c	74 19		 je	 SHORT $LN3@fthread_ge
  0003e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hThread$[rsp]
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetThreadPriority
  00049	89 44 24 20	 mov	 DWORD PTR nWindowsPriority$[rsp], eax
  0004d	81 7c 24 20 ff
	ff ff 7f	 cmp	 DWORD PTR nWindowsPriority$[rsp], 2147483647 ; 7fffffffH
  00055	75 07		 jne	 SHORT $LN2@fthread_ge
$LN3@fthread_ge:

; 1809 :     )
; 1810 :         return RC(EINVAL);

  00057	b8 16 00 00 00	 mov	 eax, 22
  0005c	eb 6a		 jmp	 SHORT $LN1@fthread_ge
$LN2@fthread_ge:

; 1811 : 
; 1812 :     *pnPolicy = FTHREAD_POLICY;

  0005e	48 8b 44 24 58	 mov	 rax, QWORD PTR pnPolicy$[rsp]
  00063	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 1813 : 
; 1814 :     if (0
; 1815 :         || !(pFTHREAD = FindFTHREAD( dwThreadID ))
; 1816 :         ||   pFTHREAD->nPriority < 0

  00069	33 c0		 xor	 eax, eax
  0006b	85 c0		 test	 eax, eax
  0006d	75 21		 jne	 SHORT $LN6@fthread_ge
  0006f	8b 4c 24 50	 mov	 ecx, DWORD PTR dwThreadID$[rsp]
  00073	e8 00 00 00 00	 call	 FindFTHREAD
  00078	48 89 44 24 28	 mov	 QWORD PTR pFTHREAD$[rsp], rax
  0007d	48 83 7c 24 28
	00		 cmp	 QWORD PTR pFTHREAD$[rsp], 0
  00083	74 0b		 je	 SHORT $LN6@fthread_ge
  00085	48 8b 44 24 28	 mov	 rax, QWORD PTR pFTHREAD$[rsp]
  0008a	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  0008e	7d 12		 jge	 SHORT $LN4@fthread_ge
$LN6@fthread_ge:

; 1817 :     )
; 1818 :         pSCHPARM->sched_priority = W2FPriority( nWindowsPriority );

  00090	8b 4c 24 20	 mov	 ecx, DWORD PTR nWindowsPriority$[rsp]
  00094	e8 00 00 00 00	 call	 W2FPriority
  00099	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pSCHPARM$[rsp]
  0009e	89 01		 mov	 DWORD PTR [rcx], eax
  000a0	eb 0f		 jmp	 SHORT $LN5@fthread_ge
$LN4@fthread_ge:

; 1819 :     else
; 1820 :         pSCHPARM->sched_priority = pFTHREAD->nPriority;

  000a2	48 8b 44 24 60	 mov	 rax, QWORD PTR pSCHPARM$[rsp]
  000a7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pFTHREAD$[rsp]
  000ac	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  000af	89 08		 mov	 DWORD PTR [rax], ecx
$LN5@fthread_ge:

; 1821 : 
; 1822 :     if (pFTHREAD)

  000b1	48 83 7c 24 28
	00		 cmp	 QWORD PTR pFTHREAD$[rsp], 0
  000b7	74 0d		 je	 SHORT $LN7@fthread_ge

; 1823 :         UnlockThreadsList();

  000b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ThreadListLock
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
$LN7@fthread_ge:

; 1824 : 
; 1825 :     return RC(0);

  000c6	33 c0		 xor	 eax, eax
$LN1@fthread_ge:

; 1826 : }

  000c8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000cc	c3		 ret	 0
fthread_getschedparam ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fthreads.c
_TEXT	SEGMENT
pFTHREAD$1 = 32
_EX_Head$2 = 40
_EX_Next$3 = 48
fthreads_internal_init PROC

; 1870 : {

$LN4:
  00000	40 57		 push	 rdi
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1871 :     static BOOL bDidThis  = FALSE;
; 1872 : 
; 1873 :     if (!bDidThis)

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDidThis@?1??fthreads_internal_init@@9@9, 0
  0000d	0f 85 07 01 00
	00		 jne	 $LN2@fthreads_i

; 1874 :     {
; 1875 :         FTHREAD* pFTHREAD;
; 1876 :         bDidThis = TRUE;

  00013	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bDidThis@?1??fthreads_internal_init@@9@9, 1

; 1877 : 
; 1878 :         // Global initialization
; 1879 : 
; 1880 :         InitializeListHead ( &ThreadListHead );

  0001d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ThreadListHead
  00024	48 89 05 08 00
	00 00		 mov	 QWORD PTR ThreadListHead+8, rax
  0002b	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR ThreadListHead+8
  00032	48 89 05 00 00
	00 00		 mov	 QWORD PTR ThreadListHead, rax

; 1881 :         InitializeCriticalSection ( &ThreadListLock );

  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ThreadListLock
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InitializeCriticalSection

; 1882 : 
; 1883 :         // Add the current thread (impl = main startup thread) to our list
; 1884 :         // so fthread_getschedparam/fthread_setschedparam lookup succeeds.
; 1885 : 
; 1886 :         pFTHREAD = (FTHREAD*) malloc( sizeof( FTHREAD ));

  00046	b9 40 01 00 00	 mov	 ecx, 320		; 00000140H
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00051	48 89 44 24 20	 mov	 QWORD PTR pFTHREAD$1[rsp], rax

; 1887 :         memset( pFTHREAD, 0, sizeof( FTHREAD ));

  00056	48 8b 7c 24 20	 mov	 rdi, QWORD PTR pFTHREAD$1[rsp]
  0005b	33 c0		 xor	 eax, eax
  0005d	b9 40 01 00 00	 mov	 ecx, 320		; 00000140H
  00062	f3 aa		 rep stosb

; 1888 : 
; 1889 :         InitializeListLink( &pFTHREAD->ThreadListLink );

  00064	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$1[rsp]
  00069	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  00071	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$1[rsp]
  00076	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1890 : 
; 1891 :         pFTHREAD->dwThreadID    = GetCurrentThreadId();

  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  00083	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pFTHREAD$1[rsp]
  00088	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 1892 :         pFTHREAD->hThreadHandle = GetCurrentThread();

  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThread
  00091	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pFTHREAD$1[rsp]
  00096	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 1893 :         pFTHREAD->bJoinable     = FALSE; // (main thread cannot be joined)

  0009a	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$1[rsp]
  0009f	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 1894 :         pFTHREAD->nJoinedCount  = 0;

  000a6	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$1[rsp]
  000ab	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [rax+36], 0

; 1895 :         pFTHREAD->nPriority     = -1;

  000b2	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$1[rsp]
  000b7	c7 40 28 ff ff
	ff ff		 mov	 DWORD PTR [rax+40], -1

; 1896 :         pFTHREAD->ExitVal       = NULL;

  000be	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$1[rsp]
  000c3	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 1897 : 
; 1898 :         // (no need to lock list during initialization)
; 1899 :         InsertListHead( &ThreadListHead, &pFTHREAD->ThreadListLink );

  000cb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ThreadListHead
  000d2	48 89 44 24 28	 mov	 QWORD PTR _EX_Head$2[rsp], rax
  000d7	48 8b 44 24 28	 mov	 rax, QWORD PTR _EX_Head$2[rsp]
  000dc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000df	48 89 44 24 30	 mov	 QWORD PTR _EX_Next$3[rsp], rax
  000e4	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$1[rsp]
  000e9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _EX_Next$3[rsp]
  000ee	48 89 08	 mov	 QWORD PTR [rax], rcx
  000f1	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$1[rsp]
  000f6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _EX_Head$2[rsp]
  000fb	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  000ff	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$1[rsp]
  00104	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _EX_Head$2[rsp]
  00109	48 89 01	 mov	 QWORD PTR [rcx], rax
  0010c	48 8b 44 24 20	 mov	 rax, QWORD PTR pFTHREAD$1[rsp]
  00111	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _EX_Next$3[rsp]
  00116	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
$LN2@fthreads_i:

; 1900 :     }
; 1901 : }

  0011a	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0011e	5f		 pop	 rdi
  0011f	c3		 ret	 0
fthreads_internal_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
