; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG159422 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG159408 DB	'regutil.dll', 00H
$SG159413 DB	'Regina', 00H
	ORG $+5
$SG159420 DB	'regina.dll', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
?maxlen@?1??rx_sprintf@@9@9 DD 010000H			; `rx_sprintf'::`2'::maxlen
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	ReginaLoadExtra
PUBLIC	ReginaLoad
PUBLIC	ReginaEnable
EXTRN	strchr:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strtok:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_GetLastError:PROC
EXTRN	__imp_FreeLibrary:PROC
EXTRN	__imp_GetModuleHandleA:PROC
EXTRN	__imp_GetProcAddress:PROC
EXTRN	__imp_LoadLibraryA:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp_fthread_self:PROC
EXTRN	__imp_hthread_equal_threads:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_rtrim:PROC
EXTRN	__imp_trim:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_w32_vsnprintf:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	__imp_panel_command_capture:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	PackageName:QWORD
EXTRN	PackageVersion:QWORD
EXTRN	PackageSource:QWORD
EXTRN	MsgLevel:BYTE
EXTRN	MsgPrefix:BYTE
EXTRN	ErrPrefix:BYTE
EXTRN	ExecCmd:QWORD
EXTRN	ExecSub:QWORD
EXTRN	HaltExec:QWORD
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	8

ReginaPackageVersion DQ 01H DUP (?)
ReginaPackageSource DQ 01H DUP (?)
LibHandle DQ	01H DUP (?)
ApiLibHandle DQ	01H DUP (?)
ReginaRexxStart DQ 01H DUP (?)
ReginaRegisterFunction DQ 01H DUP (?)
ReginaRegisterSubcom DQ 01H DUP (?)
ReginaRegisterExit DQ 01H DUP (?)
ReginaAllocateMemory DQ 01H DUP (?)
ReginaFreeMemory DQ 01H DUP (?)
ReginaVariablePool DQ 01H DUP (?)
ReginaSetHalt DQ 01H DUP (?)
?user_info@?1??RegisterRexxHandlersAndFunctions@@9@9 DQ 01H DUP (?) ; `RegisterRexxHandlersAndFunctions'::`2'::user_info
$SG160277 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
$pdata$ExitHandler DD imagerel ExitHandler
	DD	imagerel ExitHandler+535
	DD	imagerel $unwind$ExitHandler
$pdata$SubComHandler DD imagerel SubComHandler
	DD	imagerel SubComHandler+473
	DD	imagerel $unwind$SubComHandler
$pdata$AWSCmd DD imagerel AWSCmd
	DD	imagerel AWSCmd+681
	DD	imagerel $unwind$AWSCmd
$pdata$RegisterRexxHandlersAndFunctions DD imagerel RegisterRexxHandlersAndFunctions
	DD	imagerel RegisterRexxHandlersAndFunctions+481
	DD	imagerel $unwind$RegisterRexxHandlersAndFunctions
$pdata$rx_sprintf DD imagerel rx_sprintf
	DD	imagerel rx_sprintf+557
	DD	imagerel $unwind$rx_sprintf
$pdata$rx_strdup DD imagerel rx_strdup
	DD	imagerel rx_strdup+125
	DD	imagerel $unwind$rx_strdup
$pdata$VariablePool DD imagerel VariablePool
	DD	imagerel VariablePool+33
	DD	imagerel $unwind$VariablePool
$pdata$SetVar DD imagerel SetVar
	DD	imagerel SetVar+334
	DD	imagerel $unwind$SetVar
$pdata$DropVar DD imagerel DropVar
	DD	imagerel DropVar+273
	DD	imagerel $unwind$DropVar
$pdata$FetchVar DD imagerel FetchVar
	DD	imagerel FetchVar+386
	DD	imagerel $unwind$FetchVar
$pdata$Shv2Err DD imagerel Shv2Err
	DD	imagerel Shv2Err+249
	DD	imagerel $unwind$Shv2Err
$pdata$Err2SubComm DD imagerel Err2SubComm
	DD	imagerel Err2SubComm+138
	DD	imagerel $unwind$Err2SubComm
$pdata$Err2ExtFunc DD imagerel Err2ExtFunc
	DD	imagerel Err2ExtFunc+121
	DD	imagerel $unwind$Err2ExtFunc
$pdata$FmtSubCommRV DD imagerel FmtSubCommRV
	DD	imagerel FmtSubCommRV+75
	DD	imagerel $unwind$FmtSubCommRV
$pdata$FmtExtFuncRV DD imagerel FmtExtFuncRV
	DD	imagerel FmtExtFuncRV+75
	DD	imagerel $unwind$FmtExtFuncRV
$pdata$SubCommRC DD imagerel SubCommRC
	DD	imagerel SubCommRC+69
	DD	imagerel $unwind$SubCommRC
$pdata$ExtFuncRC DD imagerel ExtFuncRC
	DD	imagerel ExtFuncRC+59
	DD	imagerel $unwind$ExtFuncRC
$pdata$HerculesCommand DD imagerel HerculesCommand
	DD	imagerel HerculesCommand+679
	DD	imagerel $unwind$HerculesCommand
$pdata$HRexxStart DD imagerel HRexxStart
	DD	imagerel HRexxStart+166
	DD	imagerel $unwind$HRexxStart
$pdata$ExecRet DD imagerel ExecRet
	DD	imagerel ExecRet+585
	DD	imagerel $unwind$ExecRet
$pdata$ReginaExecCmd DD imagerel ReginaExecCmd
	DD	imagerel ReginaExecCmd+348
	DD	imagerel $unwind$ReginaExecCmd
$pdata$ReginaExecSub DD imagerel ReginaExecSub
	DD	imagerel ReginaExecSub+401
	DD	imagerel $unwind$ReginaExecSub
$pdata$ReginaExecInStoreCmd DD imagerel ReginaExecInStoreCmd
	DD	imagerel ReginaExecInStoreCmd+823
	DD	imagerel $unwind$ReginaExecInStoreCmd
$pdata$ReginaHaltExec DD imagerel ReginaHaltExec
	DD	imagerel ReginaHaltExec+356
	DD	imagerel $unwind$ReginaHaltExec
$pdata$GetRexxVersionSource DD imagerel GetRexxVersionSource
	DD	imagerel GetRexxVersionSource+476
	DD	imagerel $unwind$GetRexxVersionSource
$pdata$ResolveLibSym DD imagerel ResolveLibSym
	DD	imagerel ResolveLibSym+211
	DD	imagerel $unwind$ResolveLibSym
$pdata$ReginaLoadExtra DD imagerel $LN15
	DD	imagerel $LN15+389
	DD	imagerel $unwind$ReginaLoadExtra
$pdata$ReginaLoad DD imagerel $LN20
	DD	imagerel $LN20+1207
	DD	imagerel $unwind$ReginaLoad
$pdata$ReginaEnable DD imagerel $LN4
	DD	imagerel $LN4+189
	DD	imagerel $unwind$ReginaEnable
pdata	ENDS
_DATA	SEGMENT
ReginaPackageMajorVers DB 030H
$SG159528 DB	'E', 00H
	ORG $+2
ReginaExtraLibs DQ FLAT:$SG159408
ReginaPackageName DQ FLAT:$SG159413
LibName	DQ	FLAT:$SG159420
ApiLibName DQ	FLAT:$SG159422
$SG159526 DB	'ReginaAllocateMemory', 00H
	ORG $+3
$SG159527 DB	'rx_sprintf', 00H
	ORG $+1
$SG159567 DB	'D', 00H
	ORG $+2
$SG159529 DB	'HHC17512%s REXX(%s) %s: return code 0x%8.8X from %s', 0aH
	DB	00H
	ORG $+3
$SG159530 DB	'rx_sprintf', 00H
	ORG $+1
$SG159586 DB	'D', 00H
	ORG $+2
$SG159531 DB	'C:\papa\MyGit\hyperion-zvector\hRexxapi.c', 00H
	ORG $+2
$SG159566 DB	'SetVar', 00H
	ORG $+1
$SG159612 DB	'D', 00H
	ORG $+2
$SG159565 DB	'ReginaVariablePool', 00H
	ORG $+1
$SG159649 DB	'I', 00H
	ORG $+2
$SG159568 DB	'HHC17512%s REXX(%s) %s: return code 0x%8.8X from %s', 0aH
	DB	00H
	ORG $+3
$SG159569 DB	'SetVar', 00H
	ORG $+1
$SG159570 DB	'C:\papa\MyGit\hyperion-zvector\hRexxapi.c', 00H
	ORG $+2
$SG159653 DB	'%s', 0aH, 00H
$SG159584 DB	'ReginaVariablePool', 00H
	ORG $+1
$SG159659 DB	'D', 00H
	ORG $+2
$SG159585 DB	'DropVar', 00H
$SG159587 DB	'HHC17512%s REXX(%s) %s: return code 0x%8.8X from %s', 0aH
	DB	00H
	ORG $+3
$SG159588 DB	'DropVar', 00H
$SG159589 DB	'C:\papa\MyGit\hyperion-zvector\hRexxapi.c', 00H
	ORG $+2
$SG159663 DB	'%s', 0aH, 00H
$SG159610 DB	'ReginaVariablePool', 00H
	ORG $+1
$SG159723 DB	'%d', 00H
	ORG $+1
$SG159611 DB	'FetchVar', 00H
	ORG $+3
$SG159724 DB	'%u', 00H
	ORG $+1
$SG159613 DB	'HHC17512%s REXX(%s) %s: return code 0x%8.8X from %s', 0aH
	DB	00H
	ORG $+3
$SG159614 DB	'FetchVar', 00H
	ORG $+3
$SG159735 DB	'%d', 00H
	ORG $+1
$SG159615 DB	'C:\papa\MyGit\hyperion-zvector\hRexxapi.c', 00H
	ORG $+2
$SG159736 DB	'%u', 00H
	ORG $+1
$SG159650 DB	'HHC17540%s %s', 0aH, 00H
	ORG $+1
$SG159651 DB	'ExitHandler', 00H
$SG159797 DB	'.', 00H
	ORG $+2
$SG159652 DB	'C:\papa\MyGit\hyperion-zvector\hRexxapi.c', 00H
	ORG $+2
$SG159792 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+1
$SG159801 DB	0aH, 00H
	ORG $+2
$SG159654 DB	'ExitHandler', 00H
$SG159802 DB	0aH, 00H
	ORG $+2
$SG159655 DB	'C:\papa\MyGit\hyperion-zvector\hRexxapi.c', 00H
	ORG $+2
$SG159806 DB	'%d', 00H
	ORG $+1
$SG159660 DB	'HHC17541%s %s', 0aH, 00H
	ORG $+1
$SG159661 DB	'ExitHandler', 00H
$SG159955 DB	'E', 00H
	ORG $+2
$SG159662 DB	'C:\papa\MyGit\hyperion-zvector\hRexxapi.c', 00H
	ORG $+2
$SG159843 DB	'system', 00H
	ORG $+1
$SG159960 DB	'I', 00H
	ORG $+2
$SG159664 DB	'ExitHandler', 00H
$SG159965 DB	'I', 00H
	ORG $+2
$SG159665 DB	'C:\papa\MyGit\hyperion-zvector\hRexxapi.c', 00H
	ORG $+2
$SG159803 DB	'%s.%d', 00H
	ORG $+2
$SG159805 DB	'%s.%d', 00H
	ORG $+2
$SG159900 DB	'AWSCmd', 00H
	ORG $+1
$SG160064 DB	'E', 00H
	ORG $+2
$SG159840 DB	'HREXX.ERRORHANDLER', 00H
	ORG $+1
$SG160083 DB	'I', 00H
	ORG $+2
$SG159845 DB	'HREXX.RESPSTEMNAME', 00H
	ORG $+1
$SG160090 DB	'E', 00H
	ORG $+2
$SG159849 DB	'HREXX.RESPSTEMNAME', 00H
	ORG $+1
$SG160095 DB	'E', 00H
	ORG $+2
$SG159851 DB	'HREXX.PERSISTENTRESPSTEMNAME', 00H
	ORG $+3
$SG159901 DB	'C:\papa\MyGit\hyperion-zvector\hRexxapi.c', 00H
	ORG $+2
$SG159904 DB	'AWSCmd', 00H
	ORG $+5
$SG159902 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159905 DB	'C:\papa\MyGit\hyperion-zvector\hRexxapi.c', 00H
	ORG $+2
$SG159911 DB	'system', 00H
	ORG $+5
$SG159906 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159951 DB	'ReginaRexxStart', 00H
$SG159954 DB	'%s %s', 00H
	ORG $+2
$SG159956 DB	'HHC17502%s REXX(%s) %s RC(%d)', 0aH, 00H
	ORG $+1
$SG159957 DB	'ExecRet', 00H
$SG159958 DB	'C:\papa\MyGit\hyperion-zvector\hRexxapi.c', 00H
	ORG $+2
$SG160114 DB	'E', 00H
	ORG $+2
$SG159961 DB	'HHC17503%s REXX(%s) %s %s RetRC(%hd)', 0aH, 00H
	ORG $+2
$SG159962 DB	'ExecRet', 00H
$SG159963 DB	'C:\papa\MyGit\hyperion-zvector\hRexxapi.c', 00H
	ORG $+2
$SG160122 DB	'E', 00H
	ORG $+2
$SG159966 DB	'HHC17504%s REXX(%s) %s %s RetValue("%s")', 0aH, 00H
	ORG $+2
$SG160126 DB	'AWSCMD', 00H
	ORG $+1
$SG160130 DB	'E', 00H
	ORG $+2
$SG159967 DB	'ExecRet', 00H
$SG159968 DB	'C:\papa\MyGit\hyperion-zvector\hRexxapi.c', 00H
	ORG $+2
$SG160151 DB	'E', 00H
	ORG $+2
$SG159990 DB	'HERCSIOE', 00H
	ORG $+3
$SG160063 DB	'%s %s', 00H
	ORG $+2
$SG160171 DB	'E', 00H
	ORG $+2
$SG159991 DB	'HERCULES', 00H
	ORG $+3
$SG160196 DB	'W', 00H
	ORG $+2
$SG159992 DB	'ExecCmd', 00H
$SG160018 DB	'HERCSIOE', 00H
	ORG $+3
$SG160242 DB	'W', 00H
	ORG $+2
$SG160019 DB	'HERCULES', 00H
	ORG $+3
$SG160250 DB	'E', 00H
	ORG $+2
$SG160020 DB	'ExecSub', 00H
$SG160056 DB	'ReginaRexxStart', 00H
$SG160057 DB	'HERCSIOE', 00H
	ORG $+7
$SG160058 DB	'HERCULES', 00H
	ORG $+7
$SG160059 DB	'(instore)', 00H
	ORG $+6
$SG160062 DB	'ExecInStoreCmd', 00H
	ORG $+1
$SG160065 DB	'HHC17502%s REXX(%s) %s RC(%d)', 0aH, 00H
	ORG $+1
$SG160066 DB	'ReginaExecInStoreCmd', 00H
	ORG $+3
$SG160067 DB	'C:\papa\MyGit\hyperion-zvector\hRexxapi.c', 00H
	ORG $+6
$SG160082 DB	'success', 00H
$SG160084 DB	'HHC17520%s REXX(%s) Signal HALT %8.8x %s', 0aH, 00H
	ORG $+6
$SG160085 DB	'ReginaHaltExec', 00H
	ORG $+1
$SG160086 DB	'C:\papa\MyGit\hyperion-zvector\hRexxapi.c', 00H
	ORG $+6
$SG160089 DB	'HaltExec', 00H
	ORG $+7
$SG160091 DB	'HHC17518%s REXX(%s) %s: The target Rexx procedure was no'
	DB	't found', 0aH, 00H
	ORG $+7
$SG160092 DB	'ReginaHaltExec', 00H
	ORG $+1
$SG160093 DB	'C:\papa\MyGit\hyperion-zvector\hRexxapi.c', 00H
	ORG $+6
$SG160094 DB	'HaltExec', 00H
	ORG $+7
$SG160097 DB	'ReginaHaltExec', 00H
	ORG $+1
$SG160112 DB	'ReginaRegisterExit', 00H
	ORG $+5
$SG160096 DB	'HHC17519%s REXX(%s) %s: A failure in Rexx processing has'
	DB	' occurred', 0aH, 00H
	ORG $+5
$SG160098 DB	'C:\papa\MyGit\hyperion-zvector\hRexxapi.c', 00H
	ORG $+6
$SG160110 DB	'HERCSIOE', 00H
	ORG $+7
$SG160113 DB	'RegisterHandlers', 00H
	ORG $+7
$SG160115 DB	'HHC17512%s REXX(%s) %s: return code 0x%8.8X from %s', 0aH
	DB	00H
	ORG $+3
$SG160116 DB	'RegisterRexxHandlersAndFunctions', 00H
	ORG $+7
$SG160117 DB	'C:\papa\MyGit\hyperion-zvector\hRexxapi.c', 00H
	ORG $+6
$SG160118 DB	'HERCULES', 00H
	ORG $+7
$SG160120 DB	'ReginaRegisterSubcom', 00H
	ORG $+3
$SG160121 DB	'RegisterHandlers', 00H
	ORG $+7
$SG160123 DB	'HHC17512%s REXX(%s) %s: return code 0x%8.8X from %s', 0aH
	DB	00H
	ORG $+3
$SG160124 DB	'RegisterRexxHandlersAndFunctions', 00H
	ORG $+7
$SG160125 DB	'C:\papa\MyGit\hyperion-zvector\hRexxapi.c', 00H
	ORG $+6
$SG160128 DB	'ReginaRegisterFunction', 00H
	ORG $+1
$SG160129 DB	'RegisterFunctions', 00H
	ORG $+6
$SG160131 DB	'HHC17512%s REXX(%s) %s: return code 0x%8.8X from %s', 0aH
	DB	00H
	ORG $+3
$SG160132 DB	'RegisterRexxHandlersAndFunctions', 00H
	ORG $+7
$SG160133 DB	'C:\papa\MyGit\hyperion-zvector\hRexxapi.c', 00H
	ORG $+6
$SG160150 DB	'parse version ver', 0aH, 'parse source  src .', 0aH, 're'
	DB	'turn ver || ''0a''x || src', 0aH, 00H
	ORG $+6
$SG160153 DB	'GetRexxVersionSource', 00H
	ORG $+3
$SG160152 DB	'HHC17501%s REXX(%s) Rexx version/source retrieval failed'
	DB	': RC(%d)', 0aH, 00H
	ORG $+6
$SG160154 DB	'C:\papa\MyGit\hyperion-zvector\hRexxapi.c', 00H
	ORG $+6
$SG160155 DB	'unknown', 00H
$SG160156 DB	'unknown', 00H
$SG160172 DB	'HHC17533%s REXX(%s) dlsym ''%s'' failed: %s', 0aH, 00H
	ORG $+5
$SG160173 DB	'ResolveLibSym', 00H
	ORG $+2
$SG160174 DB	'C:\papa\MyGit\hyperion-zvector\hRexxapi.c', 00H
	ORG $+6
$SG160197 DB	'HHC17531%s REXX(%s) dlopen ''%s'' failed: %s', 0aH, 00H
	ORG $+4
$SG160198 DB	'ReginaLoadExtra', 00H
$SG160199 DB	'C:\papa\MyGit\hyperion-zvector\hRexxapi.c', 00H
	ORG $+6
$SG160243 DB	'HHC17531%s REXX(%s) dlopen ''%s'' failed: %s', 0aH, 00H
	ORG $+4
$SG160244 DB	'ReginaLoad', 00H
	ORG $+5
$SG160245 DB	'C:\papa\MyGit\hyperion-zvector\hRexxapi.c', 00H
	ORG $+6
$SG160251 DB	'HHC17531%s REXX(%s) dlopen ''%s'' failed: %s', 0aH, 00H
	ORG $+4
$SG160252 DB	'ReginaLoad', 00H
	ORG $+5
$SG160253 DB	'C:\papa\MyGit\hyperion-zvector\hRexxapi.c', 00H
	ORG $+6
$SG160256 DB	'RexxStart', 00H
	ORG $+6
$SG160257 DB	'RexxVariablePool', 00H
	ORG $+7
$SG160258 DB	'RexxSetHalt', 00H
	ORG $+4
$SG160259 DB	'RexxRegisterFunctionExe', 00H
$SG160260 DB	'RexxRegisterSubcomExe', 00H
	ORG $+2
$SG160261 DB	'RexxRegisterExitExe', 00H
	ORG $+4
$SG160262 DB	'RexxAllocateMemory', 00H
	ORG $+5
$SG160263 DB	'RexxFreeMemory', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:GetRexxVersionSource
	DD	013H
	DD	01c3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:ReginaExecInStoreCmd
	DD	024H
	DD	031fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:ReginaExecSub
	DD	01fH
	DD	0179H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:ExecRet
	DD	025H
	DD	0231H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:HerculesCommand
	DD	020H
	DD	0292H
voltbl	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$ExitHandler DD 011101H
	DD	0a211H
$unwind$SubComHandler DD 011301H
	DD	0a213H
$unwind$AWSCmd DD 011701H
	DD	0a217H
$unwind$RegisterRexxHandlersAndFunctions DD 010401H
	DD	0e204H
$unwind$rx_sprintf DD 021b01H
	DD	011011bH
$unwind$rx_strdup DD 010901H
	DD	06209H
$unwind$VariablePool DD 010901H
	DD	06209H
$unwind$SetVar DD 021101H
	DD	0150111H
$unwind$DropVar DD 020c01H
	DD	015010cH
$unwind$FetchVar DD 021101H
	DD	0150111H
$unwind$Shv2Err DD 010901H
	DD	02209H
$unwind$Err2SubComm DD 010e01H
	DD	0220eH
$unwind$Err2ExtFunc DD 010901H
	DD	02209H
$unwind$FmtSubCommRV DD 011101H
	DD	04211H
$unwind$FmtExtFuncRV DD 011101H
	DD	04211H
$unwind$SubCommRC DD 011701H
	DD	06217H
$unwind$ExtFuncRC DD 011201H
	DD	06212H
$unwind$HerculesCommand DD 022519H
	DD	0110116H
	DD	imagerel __GSHandlerCheck
	DD	078H
$unwind$HRexxStart DD 011701H
	DD	0c217H
$unwind$ExecRet DD 022d19H
	DD	01b011bH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$ReginaExecCmd DD 021101H
	DD	0170111H
$unwind$ReginaExecSub DD 022719H
	DD	0970115H
	DD	imagerel __GSHandlerCheck
	DD	04a0H
$unwind$ReginaExecInStoreCmd DD 022c19H
	DD	0a5011aH
	DD	imagerel __GSHandlerCheck
	DD	0510H
$unwind$ReginaHaltExec DD 010c01H
	DD	0c20cH
$unwind$GetRexxVersionSource DD 031b19H
	DD	0300109H
	DD	07002H
	DD	imagerel __GSHandlerCheck
	DD	0170H
$unwind$ResolveLibSym DD 011801H
	DD	0c218H
$unwind$ReginaLoadExtra DD 020c01H
	DD	07005f20cH
$unwind$ReginaLoad DD 010801H
	DD	0e208H
$unwind$ReginaEnable DD 010801H
	DD	04208H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
verbose$ = 48
ReginaEnable PROC

; 1449 : {

$LN4:
  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1450 :     PackageName       = "";

  00008	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160277
  0000f	48 89 05 00 00
	00 00		 mov	 QWORD PTR PackageName, rax

; 1451 :     PackageVersion    = NULL;

  00016	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR PackageVersion, 0

; 1452 :     PackageSource     = NULL;

  00021	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR PackageSource, 0

; 1453 :     ExecCmd           = NULL;

  0002c	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR ExecCmd, 0

; 1454 :     ExecSub           = NULL;

  00037	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR ExecSub, 0

; 1455 :     HaltExec          = NULL;

  00042	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR HaltExec, 0

; 1456 : 
; 1457 :     if (!REXX_DEP( Load )( verbose ))

  0004d	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR verbose$[rsp]
  00052	e8 00 00 00 00	 call	 ReginaLoad
  00057	0f b6 c0	 movzx	 eax, al
  0005a	85 c0		 test	 eax, eax
  0005c	75 04		 jne	 SHORT $LN2@ReginaEnab

; 1458 :         return FALSE;

  0005e	32 c0		 xor	 al, al
  00060	eb 56		 jmp	 SHORT $LN1@ReginaEnab
$LN2@ReginaEnab:

; 1459 : 
; 1460 :     PackageName       = REXX_DEP( PackageName    );

  00062	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ReginaPackageName
  00069	48 89 05 00 00
	00 00		 mov	 QWORD PTR PackageName, rax

; 1461 :     PackageVersion    = REXX_DEP( PackageVersion );

  00070	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ReginaPackageVersion
  00077	48 89 05 00 00
	00 00		 mov	 QWORD PTR PackageVersion, rax

; 1462 :     PackageSource     = REXX_DEP( PackageSource  );

  0007e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ReginaPackageSource
  00085	48 89 05 00 00
	00 00		 mov	 QWORD PTR PackageSource, rax

; 1463 :     ExecCmd           = REXX_DEP( ExecCmd        );

  0008c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ReginaExecCmd
  00093	48 89 05 00 00
	00 00		 mov	 QWORD PTR ExecCmd, rax

; 1464 :     ExecSub           = REXX_DEP( ExecSub        );

  0009a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ReginaExecSub
  000a1	48 89 05 00 00
	00 00		 mov	 QWORD PTR ExecSub, rax

; 1465 :     HaltExec          = REXX_DEP( HaltExec       );

  000a8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ReginaHaltExec
  000af	48 89 05 00 00
	00 00		 mov	 QWORD PTR HaltExec, rax

; 1466 : 
; 1467 :     return TRUE;

  000b6	b0 01		 mov	 al, 1
$LN1@ReginaEnab:

; 1468 : }

  000b8	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000bc	c3		 ret	 0
ReginaEnable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
tv71 = 80
tv129 = 88
tv75 = 96
tv133 = 104
verbose$ = 128
ReginaLoad PROC

; 1328 : {

$LN20:
  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1329 :     /* Load PRIMARY libraries first, and resolve needed entry-points */
; 1330 : 
; 1331 :     if (LibHandle && ApiLibHandle)

  00008	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR LibHandle, 0
  00010	74 11		 je	 SHORT $LN2@ReginaLoad
  00012	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ApiLibHandle, 0
  0001a	74 07		 je	 SHORT $LN2@ReginaLoad

; 1332 :         return TRUE; // (we already did this)

  0001c	b0 01		 mov	 al, 1
  0001e	e9 8f 04 00 00	 jmp	 $LN1@ReginaLoad
$LN2@ReginaLoad:

; 1333 : 
; 1334 :     if (!(LibHandle = dlopen( LibName, RTLD_NOW )))

  00023	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR LibName, 0
  0002b	74 14		 je	 SHORT $LN16@ReginaLoad
  0002d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR LibName
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryA
  0003a	48 89 44 24 50	 mov	 QWORD PTR tv71[rsp], rax
  0003f	eb 0d		 jmp	 SHORT $LN17@ReginaLoad
$LN16@ReginaLoad:
  00041	33 c9		 xor	 ecx, ecx
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleA
  00049	48 89 44 24 50	 mov	 QWORD PTR tv71[rsp], rax
$LN17@ReginaLoad:
  0004e	48 8b 44 24 50	 mov	 rax, QWORD PTR tv71[rsp]
  00053	48 89 05 00 00
	00 00		 mov	 QWORD PTR LibHandle, rax
  0005a	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR LibHandle, 0
  00062	0f 85 a5 00 00
	00		 jne	 $LN3@ReginaLoad

; 1335 :     {
; 1336 :         if (verbose)

  00068	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR verbose$[rsp]
  00070	85 c0		 test	 eax, eax
  00072	74 7c		 je	 SHORT $LN4@ReginaLoad

; 1337 :         {
; 1338 :             // "REXX(%s) dlopen '%s' failed: %s"
; 1339 :             WRMSG( HHC17531, "W", REXX_DEP( PackageName ),

  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  0007a	8b c8		 mov	 ecx, eax
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00082	48 89 44 24 60	 mov	 QWORD PTR tv75[rsp], rax
  00087	b9 01 00 00 00	 mov	 ecx, 1
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00092	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv75[rsp]
  00097	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0009c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR LibName
  000a3	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000a8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ReginaPackageName
  000af	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160242
  000bb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160243
  000c7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000cc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d1	41 b9 03 00 00
	00		 mov	 r9d, 3
  000d7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160244
  000de	ba 3c 05 00 00	 mov	 edx, 1340		; 0000053cH
  000e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160245
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@ReginaLoad:

; 1340 :                 LibName, dlerror());
; 1341 :         }
; 1342 :         LibHandle    = NULL;

  000f0	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR LibHandle, 0

; 1343 :         ApiLibHandle = NULL;

  000fb	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR ApiLibHandle, 0

; 1344 :         return FALSE;

  00106	32 c0		 xor	 al, al
  00108	e9 a5 03 00 00	 jmp	 $LN1@ReginaLoad
$LN3@ReginaLoad:

; 1345 :     }
; 1346 : 
; 1347 :     if (*ApiLibName)

  0010d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ApiLibName
  00114	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00117	85 c0		 test	 eax, eax
  00119	0f 84 f9 00 00
	00		 je	 $LN5@ReginaLoad

; 1348 :     {
; 1349 :         if (!(ApiLibHandle = dlopen( ApiLibName, RTLD_NOW )))

  0011f	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ApiLibName, 0
  00127	74 14		 je	 SHORT $LN18@ReginaLoad
  00129	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ApiLibName
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryA
  00136	48 89 44 24 58	 mov	 QWORD PTR tv129[rsp], rax
  0013b	eb 0d		 jmp	 SHORT $LN19@ReginaLoad
$LN18@ReginaLoad:
  0013d	33 c9		 xor	 ecx, ecx
  0013f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleA
  00145	48 89 44 24 58	 mov	 QWORD PTR tv129[rsp], rax
$LN19@ReginaLoad:
  0014a	48 8b 44 24 58	 mov	 rax, QWORD PTR tv129[rsp]
  0014f	48 89 05 00 00
	00 00		 mov	 QWORD PTR ApiLibHandle, rax
  00156	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ApiLibHandle, 0
  0015e	0f 85 b2 00 00
	00		 jne	 $LN7@ReginaLoad

; 1350 :         {
; 1351 :             if (verbose)

  00164	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR verbose$[rsp]
  0016c	85 c0		 test	 eax, eax
  0016e	74 7c		 je	 SHORT $LN8@ReginaLoad

; 1352 :             {
; 1353 :                 // "REXX(%s) dlopen '%s' failed: %s"
; 1354 :                 WRMSG( HHC17531, "E", REXX_DEP( PackageName ),

  00170	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00176	8b c8		 mov	 ecx, eax
  00178	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0017e	48 89 44 24 68	 mov	 QWORD PTR tv133[rsp], rax
  00183	b9 01 00 00 00	 mov	 ecx, 1
  00188	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0018e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv133[rsp]
  00193	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00198	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ApiLibName
  0019f	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001a4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ReginaPackageName
  001ab	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160250
  001b7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160251
  001c3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001c8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001cd	41 b9 03 00 00
	00		 mov	 r9d, 3
  001d3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160252
  001da	ba 4b 05 00 00	 mov	 edx, 1355		; 0000054bH
  001df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160253
  001e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN8@ReginaLoad:

; 1355 :                     ApiLibName, dlerror());
; 1356 :             }
; 1357 :             dlclose( LibHandle );

  001ec	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR LibHandle
  001f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FreeLibrary

; 1358 :             LibHandle    = NULL;

  001f9	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR LibHandle, 0

; 1359 :             ApiLibHandle = NULL;

  00204	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR ApiLibHandle, 0

; 1360 :             return FALSE;

  0020f	32 c0		 xor	 al, al
  00211	e9 9c 02 00 00	 jmp	 $LN1@ReginaLoad
$LN7@ReginaLoad:

; 1361 :         }
; 1362 :     }

  00216	eb 0e		 jmp	 SHORT $LN6@ReginaLoad
$LN5@ReginaLoad:

; 1363 :     else
; 1364 :         ApiLibHandle = LibHandle;

  00218	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR LibHandle
  0021f	48 89 05 00 00
	00 00		 mov	 QWORD PTR ApiLibHandle, rax
$LN6@ReginaLoad:

; 1365 : 
; 1366 :     if (0
; 1367 :         || !ResolveLibSym( (void**) &REXX_DEP( RexxStart        ), REXX_START,                LibHandle, verbose )
; 1368 :         || !ResolveLibSym( (void**) &REXX_DEP( VariablePool     ), REXX_VARIABLE_POOL,        LibHandle, verbose )
; 1369 :         || !ResolveLibSym( (void**) &REXX_DEP( SetHalt          ), REXX_SETHALT,              LibHandle, verbose )
; 1370 : 
; 1371 :         || !ResolveLibSym( (void**) &REXX_DEP( RegisterFunction ), REXX_REGISTER_FUNCTION, ApiLibHandle, verbose )
; 1372 :         || !ResolveLibSym( (void**) &REXX_DEP( RegisterSubcom   ), REXX_REGISTER_SUBCOM,   ApiLibHandle, verbose )
; 1373 :         || !ResolveLibSym( (void**) &REXX_DEP( RegisterExit     ), REXX_REGISTER_EXIT,     ApiLibHandle, verbose )
; 1374 :         || !ResolveLibSym( (void**) &REXX_DEP( AllocateMemory   ), REXX_ALLOCATE_MEMORY,   ApiLibHandle, verbose )
; 1375 :         || !ResolveLibSym( (void**) &REXX_DEP( FreeMemory       ), REXX_FREE_MEMORY,       ApiLibHandle, verbose )
; 1376 : 
; 1377 :         || !RegisterRexxHandlersAndFunctions()
; 1378 :         || !GetRexxVersionSource()

  00226	33 c0		 xor	 eax, eax
  00228	85 c0		 test	 eax, eax
  0022a	0f 85 80 01 00
	00		 jne	 $LN10@ReginaLoad
  00230	44 0f b6 8c 24
	80 00 00 00	 movzx	 r9d, BYTE PTR verbose$[rsp]
  00239	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR LibHandle
  00240	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160256
  00247	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ReginaRexxStart
  0024e	e8 00 00 00 00	 call	 ResolveLibSym
  00253	0f b6 c0	 movzx	 eax, al
  00256	85 c0		 test	 eax, eax
  00258	0f 84 52 01 00
	00		 je	 $LN10@ReginaLoad
  0025e	44 0f b6 8c 24
	80 00 00 00	 movzx	 r9d, BYTE PTR verbose$[rsp]
  00267	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR LibHandle
  0026e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160257
  00275	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ReginaVariablePool
  0027c	e8 00 00 00 00	 call	 ResolveLibSym
  00281	0f b6 c0	 movzx	 eax, al
  00284	85 c0		 test	 eax, eax
  00286	0f 84 24 01 00
	00		 je	 $LN10@ReginaLoad
  0028c	44 0f b6 8c 24
	80 00 00 00	 movzx	 r9d, BYTE PTR verbose$[rsp]
  00295	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR LibHandle
  0029c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160258
  002a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ReginaSetHalt
  002aa	e8 00 00 00 00	 call	 ResolveLibSym
  002af	0f b6 c0	 movzx	 eax, al
  002b2	85 c0		 test	 eax, eax
  002b4	0f 84 f6 00 00
	00		 je	 $LN10@ReginaLoad
  002ba	44 0f b6 8c 24
	80 00 00 00	 movzx	 r9d, BYTE PTR verbose$[rsp]
  002c3	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR ApiLibHandle
  002ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160259
  002d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ReginaRegisterFunction
  002d8	e8 00 00 00 00	 call	 ResolveLibSym
  002dd	0f b6 c0	 movzx	 eax, al
  002e0	85 c0		 test	 eax, eax
  002e2	0f 84 c8 00 00
	00		 je	 $LN10@ReginaLoad
  002e8	44 0f b6 8c 24
	80 00 00 00	 movzx	 r9d, BYTE PTR verbose$[rsp]
  002f1	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR ApiLibHandle
  002f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160260
  002ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ReginaRegisterSubcom
  00306	e8 00 00 00 00	 call	 ResolveLibSym
  0030b	0f b6 c0	 movzx	 eax, al
  0030e	85 c0		 test	 eax, eax
  00310	0f 84 9a 00 00
	00		 je	 $LN10@ReginaLoad
  00316	44 0f b6 8c 24
	80 00 00 00	 movzx	 r9d, BYTE PTR verbose$[rsp]
  0031f	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR ApiLibHandle
  00326	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160261
  0032d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ReginaRegisterExit
  00334	e8 00 00 00 00	 call	 ResolveLibSym
  00339	0f b6 c0	 movzx	 eax, al
  0033c	85 c0		 test	 eax, eax
  0033e	74 70		 je	 SHORT $LN10@ReginaLoad
  00340	44 0f b6 8c 24
	80 00 00 00	 movzx	 r9d, BYTE PTR verbose$[rsp]
  00349	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR ApiLibHandle
  00350	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160262
  00357	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ReginaAllocateMemory
  0035e	e8 00 00 00 00	 call	 ResolveLibSym
  00363	0f b6 c0	 movzx	 eax, al
  00366	85 c0		 test	 eax, eax
  00368	74 46		 je	 SHORT $LN10@ReginaLoad
  0036a	44 0f b6 8c 24
	80 00 00 00	 movzx	 r9d, BYTE PTR verbose$[rsp]
  00373	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR ApiLibHandle
  0037a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160263
  00381	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ReginaFreeMemory
  00388	e8 00 00 00 00	 call	 ResolveLibSym
  0038d	0f b6 c0	 movzx	 eax, al
  00390	85 c0		 test	 eax, eax
  00392	74 1c		 je	 SHORT $LN10@ReginaLoad
  00394	e8 00 00 00 00	 call	 RegisterRexxHandlersAndFunctions
  00399	0f b6 c0	 movzx	 eax, al
  0039c	85 c0		 test	 eax, eax
  0039e	74 10		 je	 SHORT $LN10@ReginaLoad
  003a0	e8 00 00 00 00	 call	 GetRexxVersionSource
  003a5	0f b6 c0	 movzx	 eax, al
  003a8	85 c0		 test	 eax, eax
  003aa	0f 85 9c 00 00
	00		 jne	 $LN9@ReginaLoad
$LN10@ReginaLoad:

; 1379 :     )
; 1380 :     {
; 1381 :         dlclose( LibHandle );

  003b0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR LibHandle
  003b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FreeLibrary

; 1382 : 
; 1383 :         if (ApiLibHandle != LibHandle)

  003bd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR LibHandle
  003c4	48 39 05 00 00
	00 00		 cmp	 QWORD PTR ApiLibHandle, rax
  003cb	74 0d		 je	 SHORT $LN11@ReginaLoad

; 1384 :             dlclose( ApiLibHandle );

  003cd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ApiLibHandle
  003d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FreeLibrary
$LN11@ReginaLoad:

; 1385 : 
; 1386 :         LibHandle    = NULL;

  003da	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR LibHandle, 0

; 1387 :         ApiLibHandle = NULL;

  003e5	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR ApiLibHandle, 0

; 1388 : 
; 1389 :         REXX_DEP( RexxStart        ) = NULL;

  003f0	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR ReginaRexxStart, 0

; 1390 :         REXX_DEP( VariablePool     ) = NULL;

  003fb	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR ReginaVariablePool, 0

; 1391 :         REXX_DEP( RegisterFunction ) = NULL;

  00406	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR ReginaRegisterFunction, 0

; 1392 :         REXX_DEP( RegisterSubcom   ) = NULL;

  00411	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR ReginaRegisterSubcom, 0

; 1393 :         REXX_DEP( RegisterExit     ) = NULL;

  0041c	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR ReginaRegisterExit, 0

; 1394 :         REXX_DEP( AllocateMemory   ) = NULL;

  00427	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR ReginaAllocateMemory, 0

; 1395 :         REXX_DEP( FreeMemory       ) = NULL;

  00432	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR ReginaFreeMemory, 0

; 1396 :         REXX_DEP( SetHalt          ) = NULL;

  0043d	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR ReginaSetHalt, 0

; 1397 : 
; 1398 :         return FALSE;

  00448	32 c0		 xor	 al, al
  0044a	eb 66		 jmp	 SHORT $LN1@ReginaLoad
$LN9@ReginaLoad:

; 1399 :     }
; 1400 : 
; 1401 :     /* Load all EXTRA libraries last... */
; 1402 : 
; 1403 :     /*---------------------------------------------------------------*/
; 1404 :     /*                                                               */
; 1405 :     /*                     PROGRAMMING NOTE                          */
; 1406 :     /*                                                               */
; 1407 :     /* It is important (at least for Windows OORexx) to also load    */
; 1408 :     /* all of the extra "Extension" libraries too, in case any of    */
; 1409 :     /* the scripts we ask rexx to run for us might require them      */
; 1410 :     /* (such as HOSTEMU.DLL which processes "EXECIO" statements).    */
; 1411 :     /*                                                               */
; 1412 :     /* This is important because rexx's automatic library loading    */
; 1413 :     /* logic might contain a race condition bug in its automatic     */
; 1414 :     /* library load//unload logic (like OORexx does) where if two    */
; 1415 :     /* threads both require the same extension DLL (hostemu.dll),    */
; 1416 :     /* the library ends up being unloaded by the first thread before */
; 1417 :     /* the second thread has had a chance to excecute, leading to a  */
; 1418 :     /* fatal Hercules crash when the second thread tries calling a   */
; 1419 :     /* rexx function within a library that has just been unloaded!   */
; 1420 :     /*                                                               */
; 1421 :     /* GitHub issue #140 "Random Hercules crash using OORexx with    */
; 1422 :     /* HAO": https://github.com/SDL-Hercules-390/hyperion/issues/140 */
; 1423 :     /*                                                               */
; 1424 :     /*---------------------------------------------------------------*/
; 1425 :     if (!REXX_DEP( LoadExtra )( verbose ))

  0044c	0f b6 8c 24 80
	00 00 00	 movzx	 ecx, BYTE PTR verbose$[rsp]
  00454	e8 00 00 00 00	 call	 ReginaLoadExtra
  00459	0f b6 c0	 movzx	 eax, al
  0045c	85 c0		 test	 eax, eax
  0045e	75 50		 jne	 SHORT $LN12@ReginaLoad

; 1426 :     {
; 1427 :         // A failure to load the ExtraLibs is fatal for
; 1428 :         // version 4.2.0 of ooRexx or earlier. For ooRexx
; 1429 :         // version 5.0.0 and later it is only a warning.
; 1430 : 
; 1431 :         if (REXX_DEP( PackageMajorVers ) < '5')

  00460	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR ReginaPackageMajorVers
  00467	83 f8 35	 cmp	 eax, 53			; 00000035H
  0046a	7d 44		 jge	 SHORT $LN13@ReginaLoad

; 1432 :         {
; 1433 :             dlclose( LibHandle );

  0046c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR LibHandle
  00473	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FreeLibrary

; 1434 :             if (ApiLibHandle != LibHandle)

  00479	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR LibHandle
  00480	48 39 05 00 00
	00 00		 cmp	 QWORD PTR ApiLibHandle, rax
  00487	74 0d		 je	 SHORT $LN14@ReginaLoad

; 1435 :                 dlclose( ApiLibHandle );

  00489	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ApiLibHandle
  00490	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FreeLibrary
$LN14@ReginaLoad:

; 1436 :             LibHandle    = NULL;

  00496	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR LibHandle, 0

; 1437 :             ApiLibHandle = NULL;

  004a1	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR ApiLibHandle, 0

; 1438 :             return FALSE;

  004ac	32 c0		 xor	 al, al
  004ae	eb 02		 jmp	 SHORT $LN1@ReginaLoad
$LN13@ReginaLoad:
$LN12@ReginaLoad:

; 1439 :         }
; 1440 :     }
; 1441 : 
; 1442 :     return TRUE;

  004b0	b0 01		 mov	 al, 1
$LN1@ReginaLoad:

; 1443 : }

  004b2	48 83 c4 78	 add	 rsp, 120		; 00000078H
  004b6	c3		 ret	 0
ReginaLoad ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
bSuccess$ = 80
i$ = 84
libname$ = 88
tv82 = 96
libhandle$ = 104
tv86 = 112
verbose$ = 144
ReginaLoadExtra PROC

; 1276 : {

$LN15:
  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	57		 push	 rdi
  00005	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 1277 :     BYTE   bSuccess  = TRUE;

  0000c	c6 44 24 50 01	 mov	 BYTE PTR bSuccess$[rsp], 1

; 1278 :     int    i;
; 1279 :     char*  libname;
; 1280 :     void*  libhandle[ NUM_EXTRALIBS ]  = {0};

  00011	48 8d 44 24 68	 lea	 rax, QWORD PTR libhandle$[rsp]
  00016	48 8b f8	 mov	 rdi, rax
  00019	33 c0		 xor	 eax, eax
  0001b	b9 08 00 00 00	 mov	 ecx, 8
  00020	f3 aa		 rep stosb

; 1281 : 
; 1282 :     for (i=0; i < (int) NUM_EXTRALIBS; ++i)

  00022	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0002a	eb 0a		 jmp	 SHORT $LN4@ReginaLoad
$LN2@ReginaLoad:
  0002c	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  00030	ff c0		 inc	 eax
  00032	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN4@ReginaLoad:
  00036	83 7c 24 54 01	 cmp	 DWORD PTR i$[rsp], 1
  0003b	0f 8d f3 00 00
	00		 jge	 $LN3@ReginaLoad

; 1283 :     {
; 1284 :         libname = REXX_DEP( ExtraLibs )[i];

  00041	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ReginaExtraLibs
  0004d	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00051	48 89 44 24 58	 mov	 QWORD PTR libname$[rsp], rax

; 1285 : 
; 1286 :         /* ooRexx version 5 and higher doesn't have the rexxutil library anymore */
; 1287 : #if REXX_PKGNUM == OOREXX_PKGNUM
; 1288 :         if (1
; 1289 :             && (REXX_DEP( PackageMajorVers ) >= '5')
; 1290 :     #if defined( _MSVC_ )
; 1291 :             && !strcmp( libname, "rexxutil.dll" )
; 1292 :     #elif defined( __APPLE__ )
; 1293 :             && !strcmp( libname, "librexxutil.dylib" )
; 1294 :     #else
; 1295 :             && !strcmp( libname, "librexxutil.so" )
; 1296 :     #endif
; 1297 :            )
; 1298 :                continue;
; 1299 : #endif
; 1300 : 
; 1301 :         if (libname && !(libhandle[i] = dlopen( libname, RTLD_NOW )))

  00056	48 83 7c 24 58
	00		 cmp	 QWORD PTR libname$[rsp], 0
  0005c	0f 84 cd 00 00
	00		 je	 $LN8@ReginaLoad
  00062	48 83 7c 24 58
	00		 cmp	 QWORD PTR libname$[rsp], 0
  00068	74 12		 je	 SHORT $LN13@ReginaLoad
  0006a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR libname$[rsp]
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryA
  00075	48 89 44 24 60	 mov	 QWORD PTR tv82[rsp], rax
  0007a	eb 0d		 jmp	 SHORT $LN14@ReginaLoad
$LN13@ReginaLoad:
  0007c	33 c9		 xor	 ecx, ecx
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleA
  00084	48 89 44 24 60	 mov	 QWORD PTR tv82[rsp], rax
$LN14@ReginaLoad:
  00089	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  0008e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv82[rsp]
  00093	48 89 4c c4 68	 mov	 QWORD PTR libhandle$[rsp+rax*8], rcx
  00098	48 83 7c 24 60
	00		 cmp	 QWORD PTR tv82[rsp], 0
  0009e	0f 85 8b 00 00
	00		 jne	 $LN8@ReginaLoad

; 1302 :         {
; 1303 :             bSuccess = FALSE;

  000a4	c6 44 24 50 00	 mov	 BYTE PTR bSuccess$[rsp], 0

; 1304 : 
; 1305 :             if (verbose)

  000a9	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR verbose$[rsp]
  000b1	85 c0		 test	 eax, eax
  000b3	74 7a		 je	 SHORT $LN9@ReginaLoad

; 1306 :             {
; 1307 :                 // "REXX(%s) dlopen '%s' failed: %s"
; 1308 :                 WRMSG( HHC17531, "W", REXX_DEP( PackageName ),

  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  000bb	8b c8		 mov	 ecx, eax
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000c3	48 89 44 24 70	 mov	 QWORD PTR tv86[rsp], rax
  000c8	b9 01 00 00 00	 mov	 ecx, 1
  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000d3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv86[rsp]
  000d8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000dd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR libname$[rsp]
  000e2	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000e7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ReginaPackageName
  000ee	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160196
  000fa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160197
  00106	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0010b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00110	41 b9 03 00 00
	00		 mov	 r9d, 3
  00116	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160198
  0011d	ba 1d 05 00 00	 mov	 edx, 1309		; 0000051dH
  00122	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160199
  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@ReginaLoad:
$LN8@ReginaLoad:

; 1309 :                     libname, dlerror());
; 1310 :             }
; 1311 :         }
; 1312 :     }

  0012f	e9 f8 fe ff ff	 jmp	 $LN2@ReginaLoad
$LN3@ReginaLoad:

; 1313 : 
; 1314 :     /* All or nothing! If ANY load fails, then they ALL fail! */
; 1315 : 
; 1316 :     if (!bSuccess)

  00134	0f b6 44 24 50	 movzx	 eax, BYTE PTR bSuccess$[rsp]
  00139	85 c0		 test	 eax, eax
  0013b	75 3a		 jne	 SHORT $LN10@ReginaLoad

; 1317 :         for (i=0; i < (int) NUM_EXTRALIBS; ++i)

  0013d	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00145	eb 0a		 jmp	 SHORT $LN7@ReginaLoad
$LN5@ReginaLoad:
  00147	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  0014b	ff c0		 inc	 eax
  0014d	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN7@ReginaLoad:
  00151	83 7c 24 54 01	 cmp	 DWORD PTR i$[rsp], 1
  00156	7d 1f		 jge	 SHORT $LN6@ReginaLoad

; 1318 :             if (libhandle[i])

  00158	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  0015d	48 83 7c c4 68
	00		 cmp	 QWORD PTR libhandle$[rsp+rax*8], 0
  00163	74 10		 je	 SHORT $LN11@ReginaLoad

; 1319 :                 dlclose( libhandle[i] );

  00165	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  0016a	48 8b 4c c4 68	 mov	 rcx, QWORD PTR libhandle$[rsp+rax*8]
  0016f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FreeLibrary
$LN11@ReginaLoad:
  00175	eb d0		 jmp	 SHORT $LN5@ReginaLoad
$LN6@ReginaLoad:
$LN10@ReginaLoad:

; 1320 : 
; 1321 :     return bSuccess;

  00177	0f b6 44 24 50	 movzx	 eax, BYTE PTR bSuccess$[rsp]

; 1322 : }

  0017c	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00183	5f		 pop	 rdi
  00184	c3		 ret	 0
ReginaLoadExtra ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
tv70 = 80
ppfn$ = 112
name$ = 120
lib$ = 128
verbose$ = 136
ResolveLibSym PROC

; 1258 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1259 :     if (!(*ppfn = dlsym( lib, name )))

  00018	48 8b 54 24 78	 mov	 rdx, QWORD PTR name$[rsp]
  0001d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR lib$[rsp]
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  0002b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ppfn$[rsp]
  00030	48 89 01	 mov	 QWORD PTR [rcx], rax
  00033	48 8b 44 24 70	 mov	 rax, QWORD PTR ppfn$[rsp]
  00038	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0003c	0f 85 8a 00 00
	00		 jne	 $LN2@ResolveLib

; 1260 :     {
; 1261 :         if (verbose)

  00042	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR verbose$[rsp]
  0004a	85 c0		 test	 eax, eax
  0004c	74 7a		 je	 SHORT $LN3@ResolveLib

; 1262 :         {
; 1263 :             // "REXX(%s) dlsym '%s' failed: %s"
; 1264 :             WRMSG( HHC17533, "E", REXX_DEP( PackageName ),

  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00054	8b c8		 mov	 ecx, eax
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0005c	48 89 44 24 50	 mov	 QWORD PTR tv70[rsp], rax
  00061	b9 01 00 00 00	 mov	 ecx, 1
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0006c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv70[rsp]
  00071	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00076	48 8b 4c 24 78	 mov	 rcx, QWORD PTR name$[rsp]
  0007b	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00080	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ReginaPackageName
  00087	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0008c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160171
  00093	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00098	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160172
  0009f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000a4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a9	41 b9 03 00 00
	00		 mov	 r9d, 3
  000af	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160173
  000b6	ba f1 04 00 00	 mov	 edx, 1265		; 000004f1H
  000bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160174
  000c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN3@ResolveLib:

; 1265 :                 name, dlerror());
; 1266 :         }
; 1267 :         return FALSE;

  000c8	32 c0		 xor	 al, al
  000ca	eb 02		 jmp	 SHORT $LN1@ResolveLib
$LN2@ResolveLib:

; 1268 :     }
; 1269 :     return TRUE;

  000cc	b0 01		 mov	 al, 1
$LN1@ResolveLib:

; 1270 : }

  000ce	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000d2	c3		 ret	 0
ResolveLibSym ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
RetRC$ = 80
rc$ = 84
source$ = 88
tv140 = 96
Result$ = 112
__$ArrayPad$ = 368
GetRexxVersionSource PROC

; 1212 : {

  00000	40 57		 push	 rdi
  00002	48 81 ec 80 01
	00 00		 sub	 rsp, 384		; 00000180H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1213 :     char         Result[ 256 ]  = {0};    // Results buffer

  0001b	48 8d 44 24 70	 lea	 rax, QWORD PTR Result$[rsp]
  00020	48 8b f8	 mov	 rdi, rax
  00023	33 c0		 xor	 eax, eax
  00025	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0002a	f3 aa		 rep stosb

; 1214 :     short        RetRC          =  0;     // Script retcode (not used)

  0002c	33 c0		 xor	 eax, eax
  0002e	66 89 44 24 50	 mov	 WORD PTR RetRC$[rsp], ax

; 1215 :     HR_REXXRC_T  rc             =  0;     // Rexx API return code

  00033	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 1216 :     char*        source         = NULL;   // Will point to Rexx SOURCE

  0003b	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR source$[rsp], 0

; 1217 : 
; 1218 :     /* Free the old values; we'll be retrieving new ones */
; 1219 :     if (REXX_DEP( PackageVersion )) free( REXX_DEP( PackageVersion ));

  00044	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ReginaPackageVersion, 0
  0004c	74 0d		 je	 SHORT $LN2@GetRexxVer
  0004e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ReginaPackageVersion
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@GetRexxVer:

; 1220 :     if (REXX_DEP( PackageSource  )) free( REXX_DEP( PackageSource  ));

  0005b	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ReginaPackageSource, 0
  00063	74 0d		 je	 SHORT $LN3@GetRexxVer
  00065	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ReginaPackageSource
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN3@GetRexxVer:

; 1221 : 
; 1222 :     /* Retrieve Rexx Interpreter version and source value */
; 1223 :     if (0
; 1224 :         || RXAPI_OK != (rc = REXX_DEP( ExecInStoreCmd )
; 1225 :            ( VER_SRC_INSTOR_SCRIPT, 0, NULL, &RetRC, Result, sizeof( Result )))
; 1226 :         || !(source = strchr( Result, '\n' ))  // (parse results too)

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 54		 jne	 SHORT $LN6@GetRexxVer
  00078	48 c7 44 24 28
	00 01 00 00	 mov	 QWORD PTR [rsp+40], 256	; 00000100H
  00081	48 8d 44 24 70	 lea	 rax, QWORD PTR Result$[rsp]
  00086	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008b	4c 8d 4c 24 50	 lea	 r9, QWORD PTR RetRC$[rsp]
  00090	45 33 c0	 xor	 r8d, r8d
  00093	33 d2		 xor	 edx, edx
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160150
  0009c	e8 00 00 00 00	 call	 ReginaExecInStoreCmd
  000a1	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax
  000a5	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  000aa	75 20		 jne	 SHORT $LN6@GetRexxVer
  000ac	ba 0a 00 00 00	 mov	 edx, 10
  000b1	48 8d 4c 24 70	 lea	 rcx, QWORD PTR Result$[rsp]
  000b6	e8 00 00 00 00	 call	 strchr
  000bb	48 89 44 24 58	 mov	 QWORD PTR source$[rsp], rax
  000c0	48 83 7c 24 58
	00		 cmp	 QWORD PTR source$[rsp], 0
  000c6	0f 85 85 00 00
	00		 jne	 $LN4@GetRexxVer
$LN6@GetRexxVer:

; 1227 :     )
; 1228 :     {
; 1229 :         // "REXX(%s) Rexx version/source retrieval failed: RC(%d)"
; 1230 :         WRMSG( HHC17501, "E", REXX_DEP( PackageName ), (S32) rc );

  000cc	b9 01 00 00 00	 mov	 ecx, 1
  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000d7	8b 4c 24 54	 mov	 ecx, DWORD PTR rc$[rsp]
  000db	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000df	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ReginaPackageName
  000e6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160151
  000f2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160152
  000fe	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00103	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00108	41 b9 03 00 00
	00		 mov	 r9d, 3
  0010e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160153
  00115	ba ce 04 00 00	 mov	 edx, 1230		; 000004ceH
  0011a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160154
  00121	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1231 : 
; 1232 :         REXX_DEP( PackageVersion ) = strdup( "unknown" );

  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160155
  0012e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00134	48 89 05 00 00
	00 00		 mov	 QWORD PTR ReginaPackageVersion, rax

; 1233 :         REXX_DEP( PackageSource  ) = strdup( "unknown" );

  0013b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160156
  00142	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00148	48 89 05 00 00
	00 00		 mov	 QWORD PTR ReginaPackageSource, rax

; 1234 :     }

  0014f	eb 53		 jmp	 SHORT $LN5@GetRexxVer
$LN4@GetRexxVer:

; 1235 :     else
; 1236 :     {
; 1237 :         *source++ = 0; // (null terminate version and point to source)

  00151	48 8b 44 24 58	 mov	 rax, QWORD PTR source$[rsp]
  00156	c6 00 00	 mov	 BYTE PTR [rax], 0
  00159	48 8b 44 24 58	 mov	 rax, QWORD PTR source$[rsp]
  0015e	48 ff c0	 inc	 rax
  00161	48 89 44 24 58	 mov	 QWORD PTR source$[rsp], rax

; 1238 :         REXX_DEP( PackageVersion ) = strdup( Result );

  00166	48 8d 4c 24 70	 lea	 rcx, QWORD PTR Result$[rsp]
  0016b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00171	48 89 05 00 00
	00 00		 mov	 QWORD PTR ReginaPackageVersion, rax

; 1239 :         REXX_DEP( PackageSource  ) = strdup( source );

  00178	48 8b 4c 24 58	 mov	 rcx, QWORD PTR source$[rsp]
  0017d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00183	48 89 05 00 00
	00 00		 mov	 QWORD PTR ReginaPackageSource, rax

; 1240 : 
; 1241 :         /* Extract the major version number too */
; 1242 : 
; 1243 :         // "REXX-ooRexx_4.2.0(MT)_32-bit"
; 1244 :         //              ^
; 1245 :         //              ^
; 1246 :         //              ^
; 1247 : 
; 1248 :         REXX_DEP( PackageMajorVers ) = REXX_DEP( PackageVersion )[12];

  0018a	b8 01 00 00 00	 mov	 eax, 1
  0018f	48 6b c0 0c	 imul	 rax, rax, 12
  00193	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ReginaPackageVersion
  0019a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0019e	88 05 00 00 00
	00		 mov	 BYTE PTR ReginaPackageMajorVers, al
$LN5@GetRexxVer:

; 1249 :     }
; 1250 : 
; 1251 :     return source ? TRUE : FALSE;

  001a4	48 83 7c 24 58
	00		 cmp	 QWORD PTR source$[rsp], 0
  001aa	74 0a		 je	 SHORT $LN8@GetRexxVer
  001ac	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv140[rsp], 1
  001b4	eb 08		 jmp	 SHORT $LN9@GetRexxVer
$LN8@GetRexxVer:
  001b6	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv140[rsp], 0
$LN9@GetRexxVer:
  001be	0f b6 44 24 60	 movzx	 eax, BYTE PTR tv140[rsp]

; 1252 : }

  001c3	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001cb	48 33 cc	 xor	 rcx, rsp
  001ce	e8 00 00 00 00	 call	 __security_check_cookie
  001d3	48 81 c4 80 01
	00 00		 add	 rsp, 384		; 00000180H
  001da	5f		 pop	 rdi
  001db	c3		 ret	 0
GetRexxVersionSource ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
rexx_rc$ = 80
pid$ = 112
tid$ = 120
ReginaHaltExec PROC

; 1132 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1133 :     HR_REXXRC_T  rexx_rc;
; 1134 : 
; 1135 :     rexx_rc = REXX_DEP( SetHalt )( (HR_PROCESS_ID_T) pid, (HR_THREAD_ID_T) tid );

  0000c	8b 54 24 78	 mov	 edx, DWORD PTR tid$[rsp]
  00010	8b 4c 24 70	 mov	 ecx, DWORD PTR pid$[rsp]
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR ReginaSetHalt
  0001a	89 44 24 50	 mov	 DWORD PTR rexx_rc$[rsp], eax

; 1136 : 
; 1137 :     if (RXARI_OK == rexx_rc)  // NOTE: "RXARI_OK", not "RXAPI_OK"!!

  0001e	83 7c 24 50 00	 cmp	 DWORD PTR rexx_rc$[rsp], 0
  00023	75 6e		 jne	 SHORT $LN2@ReginaHalt

; 1138 :     {
; 1139 :         // "REXX(%s) Signal HALT "TIDPAT" %s"
; 1140 :         WRMSG( HHC17520, "I", REXX_DEP( PackageName ), TID_CAST( tid ), "success" );

  00025	b9 01 00 00 00	 mov	 ecx, 1
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160082
  00037	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0003c	8b 4c 24 78	 mov	 ecx, DWORD PTR tid$[rsp]
  00040	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00044	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ReginaPackageName
  0004b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160083
  00057	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160084
  00063	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00068	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00073	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160085
  0007a	ba 74 04 00 00	 mov	 edx, 1140		; 00000474H
  0007f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160086
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1141 :         return 0;

  0008c	33 c0		 xor	 eax, eax
  0008e	e9 cc 00 00 00	 jmp	 $LN1@ReginaHalt
$LN2@ReginaHalt:

; 1142 :     }
; 1143 : 
; 1144 :     if (RXARI_NOT_FOUND == rexx_rc)

  00093	83 7c 24 50 01	 cmp	 DWORD PTR rexx_rc$[rsp], 1
  00098	75 61		 jne	 SHORT $LN3@ReginaHalt

; 1145 :     {
; 1146 :         // "REXX(%s) %s: The target Rexx procedure was not found"
; 1147 :         WRMSG( HHC17518, "E", REXX_DEP( PackageName ), "HaltExec" );

  0009a	b9 01 00 00 00	 mov	 ecx, 1
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160089
  000ac	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000b1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ReginaPackageName
  000b8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160090
  000c4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160091
  000d0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000d5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000da	41 b9 03 00 00
	00		 mov	 r9d, 3
  000e0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160092
  000e7	ba 7b 04 00 00	 mov	 edx, 1147		; 0000047bH
  000ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160093
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1148 :     }

  000f9	eb 5f		 jmp	 SHORT $LN4@ReginaHalt
$LN3@ReginaHalt:

; 1149 :     else // RXARI_PROCESSING_ERROR
; 1150 :     {
; 1151 :         // "REXX(%s) %s: A failure in Rexx processing has occurred"
; 1152 :         WRMSG( HHC17519, "E", REXX_DEP( PackageName ), "HaltExec" );

  000fb	b9 01 00 00 00	 mov	 ecx, 1
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00106	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160094
  0010d	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00112	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ReginaPackageName
  00119	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0011e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160095
  00125	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0012a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160096
  00131	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00136	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0013b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00141	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160097
  00148	ba 80 04 00 00	 mov	 edx, 1152		; 00000480H
  0014d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160098
  00154	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@ReginaHalt:

; 1153 :     }
; 1154 : 
; 1155 :     return -1;

  0015a	b8 ff ff ff ff	 mov	 eax, -1
$LN1@ReginaHalt:

; 1156 : }

  0015f	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00163	c3		 ret	 0
ReginaHaltExec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
argcount$ = 80
rc$ = 84
RetValue$ = 88
calltype$ = 104
tv176 = 112
ArgList$ = 120
failingfunc$ = 128
pkgname$ = 136
Instore$ = 144
ExitList$ = 176
Args$ = 208
buf$1 = 1232
__$ArrayPad$ = 1296
sourcecode$ = 1328
argc$ = 1336
argv$ = 1344
RetRC$ = 1352
Result$ = 1360
ResultLen$ = 1368
ReginaExecInStoreCmd PROC

; 1057 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 28 05
	00 00		 sub	 rsp, 1320		; 00000528H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 10
	05 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1058 :     HR_REXXRC_T   rc;
; 1059 :     long          argcount;
; 1060 :     RXSTRING      Args[ MAX_REXXSTART_ARGS ];
; 1061 :     HR_ARGV_T     ArgList;
; 1062 :     RXSTRING      Instore[2];
; 1063 :     RXSYSEXIT     ExitList[2];
; 1064 :     RXSTRING      RetValue;
; 1065 :     int           calltype;
; 1066 : 
; 1067 :     const char*   pkgname      =       REXX_DEP( PackageName );

  0002c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ReginaPackageName
  00033	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pkgname$[rsp], rax

; 1068 :     const char*   failingfunc  = QSTR( REXX_DEP( RexxStart   ));

  0003b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160056
  00042	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR failingfunc$[rsp], rax

; 1069 : 
; 1070 :     /* Build the RXSTRING function arguments array */
; 1071 :     for (argcount=0; argcount < argc && argcount < MAX_REXXSTART_ARGS; argcount++)

  0004a	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR argcount$[rsp], 0
  00052	eb 0a		 jmp	 SHORT $LN4@ReginaExec
$LN2@ReginaExec:
  00054	8b 44 24 50	 mov	 eax, DWORD PTR argcount$[rsp]
  00058	ff c0		 inc	 eax
  0005a	89 44 24 50	 mov	 DWORD PTR argcount$[rsp], eax
$LN4@ReginaExec:
  0005e	8b 84 24 38 05
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00065	39 44 24 50	 cmp	 DWORD PTR argcount$[rsp], eax
  00069	7d 57		 jge	 SHORT $LN3@ReginaExec
  0006b	83 7c 24 50 40	 cmp	 DWORD PTR argcount$[rsp], 64 ; 00000040H
  00070	7d 50		 jge	 SHORT $LN3@ReginaExec
$LN7@ReginaExec:

; 1072 :     {
; 1073 :         /* Build the RXSTRING for the next argument */
; 1074 :         HMAKE_RXSTRING( Args[ argcount ], argv[ argcount ], strlen( argv[ argcount ]));

  00072	48 63 44 24 50	 movsxd	 rax, DWORD PTR argcount$[rsp]
  00077	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR argcount$[rsp]
  0007c	48 6b c9 10	 imul	 rcx, rcx, 16
  00080	48 8b 94 24 40
	05 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00088	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  0008c	48 89 84 0c d8
	00 00 00	 mov	 QWORD PTR Args$[rsp+rcx+8], rax
  00094	48 63 44 24 50	 movsxd	 rax, DWORD PTR argcount$[rsp]
  00099	48 8b 8c 24 40
	05 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000a1	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  000a5	e8 00 00 00 00	 call	 strlen
  000aa	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR argcount$[rsp]
  000af	48 6b c9 10	 imul	 rcx, rcx, 16
  000b3	89 84 0c d0 00
	00 00		 mov	 DWORD PTR Args$[rsp+rcx], eax
  000ba	33 c0		 xor	 eax, eax
  000bc	85 c0		 test	 eax, eax
  000be	75 b2		 jne	 SHORT $LN7@ReginaExec

; 1075 :     }

  000c0	eb 92		 jmp	 SHORT $LN2@ReginaExec
$LN3@ReginaExec:

; 1076 : 
; 1077 :     Instore[0].strptr         =         sourcecode;

  000c2	b8 10 00 00 00	 mov	 eax, 16
  000c7	48 6b c0 00	 imul	 rax, rax, 0
  000cb	48 8b 8c 24 30
	05 00 00	 mov	 rcx, QWORD PTR sourcecode$[rsp]
  000d3	48 89 8c 04 98
	00 00 00	 mov	 QWORD PTR Instore$[rsp+rax+8], rcx

; 1078 :     Instore[0].strlength      = strlen( sourcecode );

  000db	48 8b 8c 24 30
	05 00 00	 mov	 rcx, QWORD PTR sourcecode$[rsp]
  000e3	e8 00 00 00 00	 call	 strlen
  000e8	b9 10 00 00 00	 mov	 ecx, 16
  000ed	48 6b c9 00	 imul	 rcx, rcx, 0
  000f1	89 84 0c 90 00
	00 00		 mov	 DWORD PTR Instore$[rsp+rcx], eax

; 1079 :     Instore[1].strptr         = NULL;

  000f8	b8 10 00 00 00	 mov	 eax, 16
  000fd	48 6b c0 01	 imul	 rax, rax, 1
  00101	48 c7 84 04 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR Instore$[rsp+rax+8], 0

; 1080 :     Instore[1].strlength      = 0;

  0010d	b8 10 00 00 00	 mov	 eax, 16
  00112	48 6b c0 01	 imul	 rax, rax, 1
  00116	c7 84 04 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR Instore$[rsp+rax], 0

; 1081 : 
; 1082 :     ExitList[0].sysexit_code  = RXSIO;

  00121	b8 10 00 00 00	 mov	 eax, 16
  00126	48 6b c0 00	 imul	 rax, rax, 0
  0012a	c7 84 04 b8 00
	00 00 05 00 00
	00		 mov	 DWORD PTR ExitList$[rsp+rax+8], 5

; 1083 :     ExitList[0].sysexit_name  = "HERCSIOE";

  00135	b8 10 00 00 00	 mov	 eax, 16
  0013a	48 6b c0 00	 imul	 rax, rax, 0
  0013e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160057
  00145	48 89 8c 04 b0
	00 00 00	 mov	 QWORD PTR ExitList$[rsp+rax], rcx

; 1084 :     ExitList[1].sysexit_code  = RXENDLST;

  0014d	b8 10 00 00 00	 mov	 eax, 16
  00152	48 6b c0 01	 imul	 rax, rax, 1
  00156	c7 84 04 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ExitList$[rsp+rax+8], 0

; 1085 : 
; 1086 :     RetValue.strptr           = NULL;   // (let Rexx allocate it)

  00161	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR RetValue$[rsp+8], 0

; 1087 :     RetValue.strlength        = 0;      // (let Rexx allocate it)

  0016a	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR RetValue$[rsp], 0

; 1088 :     ArgList                   = (HR_ARGV_T) Args;

  00172	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR Args$[rsp]
  0017a	48 89 44 24 78	 mov	 QWORD PTR ArgList$[rsp], rax

; 1089 :     calltype                  = RXFUNCTION;

  0017f	c7 44 24 68 02
	00 00 00	 mov	 DWORD PTR calltype$[rsp], 2

; 1090 : 
; 1091 :     rc = HRexxStart( argcount,          // Number of arguments

  00187	48 8d 44 24 58	 lea	 rax, QWORD PTR RetValue$[rsp]
  0018c	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00191	48 8b 84 24 48
	05 00 00	 mov	 rax, QWORD PTR RetRC$[rsp]
  00199	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0019e	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR ExitList$[rsp]
  001a6	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001ab	8b 44 24 68	 mov	 eax, DWORD PTR calltype$[rsp]
  001af	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001b3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160058
  001ba	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001bf	4c 8d 8c 24 90
	00 00 00	 lea	 r9, QWORD PTR Instore$[rsp]
  001c7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160059
  001ce	48 8b 54 24 78	 mov	 rdx, QWORD PTR ArgList$[rsp]
  001d3	8b 4c 24 50	 mov	 ecx, DWORD PTR argcount$[rsp]
  001d7	e8 00 00 00 00	 call	 HRexxStart
  001dc	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax

; 1092 :                      ArgList,           // Array of arguments
; 1093 :                      "(instore)",       // Name of Rexx file
; 1094 :                      Instore,           // In-Storage Script
; 1095 :                      "HERCULES",        // Command env. name
; 1096 :                      calltype,          // Code for how invoked
; 1097 :                      ExitList,          // EXITs on this call
; 1098 :                      RetRC,             // Converted return code
; 1099 :                      &RetValue );       // Rexx program output
; 1100 : 
; 1101 :     if (RXAPI_OK != rc)

  001e0	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  001e5	0f 84 a4 00 00
	00		 je	 $LN8@ReginaExec

; 1102 :     {
; 1103 :         char buf[ 64 ];
; 1104 :         MSGBUF( buf, "%s %s", "ExecInStoreCmd", failingfunc );

  001eb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR failingfunc$[rsp]
  001f3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160062
  001ff	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160063
  00206	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0020b	48 8d 8c 24 d0
	04 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  00213	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1105 :         // "REXX(%s) %s RC(%d)"
; 1106 :         WRMSG( HHC17502, "E", pkgname, buf, (S32) rc );

  00219	b9 01 00 00 00	 mov	 ecx, 1
  0021e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00224	8b 4c 24 54	 mov	 ecx, DWORD PTR rc$[rsp]
  00228	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0022c	48 8d 8c 24 d0
	04 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  00234	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00239	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pkgname$[rsp]
  00241	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00246	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160064
  0024d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00252	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160065
  00259	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0025e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00263	41 b9 03 00 00
	00		 mov	 r9d, 3
  00269	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160066
  00270	ba 52 04 00 00	 mov	 edx, 1106		; 00000452H
  00275	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160067
  0027c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1107 :         *Result = 0;

  00282	48 8b 84 24 50
	05 00 00	 mov	 rax, QWORD PTR Result$[rsp]
  0028a	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1108 :     }

  0028d	eb 4e		 jmp	 SHORT $LN9@ReginaExec
$LN8@ReginaExec:

; 1109 :     else if (RetValue.strptr)

  0028f	48 83 7c 24 60
	00		 cmp	 QWORD PTR RetValue$[rsp+8], 0
  00295	74 46		 je	 SHORT $LN10@ReginaExec

; 1110 :     {
; 1111 :         /* PROGRAMMING NOTE: the return value returned by Rexx
; 1112 :            is NOT null terminated so we must do that ourselves. */
; 1113 :         strlcpy( Result, RetValue.strptr, MIN( RetValue.strlength+1, ResultLen ));

  00297	8b 44 24 58	 mov	 eax, DWORD PTR RetValue$[rsp]
  0029b	ff c0		 inc	 eax
  0029d	8b c0		 mov	 eax, eax
  0029f	48 3b 84 24 58
	05 00 00	 cmp	 rax, QWORD PTR ResultLen$[rsp]
  002a7	73 0f		 jae	 SHORT $LN14@ReginaExec
  002a9	8b 44 24 58	 mov	 eax, DWORD PTR RetValue$[rsp]
  002ad	ff c0		 inc	 eax
  002af	8b c0		 mov	 eax, eax
  002b1	48 89 44 24 70	 mov	 QWORD PTR tv176[rsp], rax
  002b6	eb 0d		 jmp	 SHORT $LN15@ReginaExec
$LN14@ReginaExec:
  002b8	48 8b 84 24 58
	05 00 00	 mov	 rax, QWORD PTR ResultLen$[rsp]
  002c0	48 89 44 24 70	 mov	 QWORD PTR tv176[rsp], rax
$LN15@ReginaExec:
  002c5	4c 8b 44 24 70	 mov	 r8, QWORD PTR tv176[rsp]
  002ca	48 8b 54 24 60	 mov	 rdx, QWORD PTR RetValue$[rsp+8]
  002cf	48 8b 8c 24 50
	05 00 00	 mov	 rcx, QWORD PTR Result$[rsp]
  002d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN10@ReginaExec:
$LN9@ReginaExec:

; 1114 :     }
; 1115 : 
; 1116 :     /* Done with return value RXSTRING. Free it to prevent leak. */
; 1117 :     if (RetValue.strptr)

  002dd	48 83 7c 24 60
	00		 cmp	 QWORD PTR RetValue$[rsp+8], 0
  002e3	74 0b		 je	 SHORT $LN11@ReginaExec

; 1118 :         REXX_DEP( FreeMemory )( RetValue.strptr );

  002e5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR RetValue$[rsp+8]
  002ea	ff 15 00 00 00
	00		 call	 QWORD PTR ReginaFreeMemory
$LN11@ReginaExec:

; 1119 : 
; 1120 :     /* Also not interested in Rexx's resulting translated (compiled)
; 1121 :        image of our script so free its memory too to prevent leak. */
; 1122 :     if (Instore[1].strptr)

  002f0	b8 10 00 00 00	 mov	 eax, 16
  002f5	48 6b c0 01	 imul	 rax, rax, 1
  002f9	48 83 bc 04 98
	00 00 00 00	 cmp	 QWORD PTR Instore$[rsp+rax+8], 0
  00302	74 17		 je	 SHORT $LN12@ReginaExec

; 1123 :         REXX_DEP( FreeMemory )( Instore[1].strptr );

  00304	b8 10 00 00 00	 mov	 eax, 16
  00309	48 6b c0 01	 imul	 rax, rax, 1
  0030d	48 8b 8c 04 98
	00 00 00	 mov	 rcx, QWORD PTR Instore$[rsp+rax+8]
  00315	ff 15 00 00 00
	00		 call	 QWORD PTR ReginaFreeMemory
$LN12@ReginaExec:

; 1124 : 
; 1125 :     return rc;

  0031b	8b 44 24 54	 mov	 eax, DWORD PTR rc$[rsp]

; 1126 : }

  0031f	48 8b 8c 24 10
	05 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00327	48 33 cc	 xor	 rcx, rsp
  0032a	e8 00 00 00 00	 call	 __security_check_cookie
  0032f	48 81 c4 28 05
	00 00		 add	 rsp, 1320		; 00000528H
  00336	c3		 ret	 0
ReginaExecInStoreCmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
argcount$ = 80
RetRC$ = 84
calltype$ = 88
rc$ = 92
ArgList$ = 96
RetValue$ = 104
ExitList$ = 120
Args$ = 160
__$ArrayPad$ = 1184
scriptname$ = 1216
argc$ = 1224
argv$ = 1232
ReginaExecSub PROC

; 1006 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec b8 04
	00 00		 sub	 rsp, 1208		; 000004b8H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 a0
	04 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1007 :     HR_REXXRC_T   rc;
; 1008 :     long          argcount;
; 1009 :     RXSTRING      Args[ MAX_REXXSTART_ARGS ];
; 1010 :     HR_ARGV_T     ArgList;
; 1011 :     RXSYSEXIT     ExitList[2];
; 1012 :     RXSTRING      RetValue;
; 1013 :     int           calltype;
; 1014 :     short         RetRC;
; 1015 : 
; 1016 :     /* Build the RXSTRING subroutine arguments array */
; 1017 :     for (argcount=0; argcount < MAX_REXXSTART_ARGS && argcount < argc; argcount++)

  00027	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR argcount$[rsp], 0
  0002f	eb 0a		 jmp	 SHORT $LN4@ReginaExec
$LN2@ReginaExec:
  00031	8b 44 24 50	 mov	 eax, DWORD PTR argcount$[rsp]
  00035	ff c0		 inc	 eax
  00037	89 44 24 50	 mov	 DWORD PTR argcount$[rsp], eax
$LN4@ReginaExec:
  0003b	83 7c 24 50 40	 cmp	 DWORD PTR argcount$[rsp], 64 ; 00000040H
  00040	7d 5d		 jge	 SHORT $LN3@ReginaExec
  00042	8b 84 24 c8 04
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00049	39 44 24 50	 cmp	 DWORD PTR argcount$[rsp], eax
  0004d	7d 50		 jge	 SHORT $LN3@ReginaExec
$LN7@ReginaExec:

; 1018 :     {
; 1019 :         /* Build the RXSTRING for the next argument */
; 1020 :         HMAKE_RXSTRING( Args[ argcount ], argv[ argcount ], strlen( argv[ argcount ]));

  0004f	48 63 44 24 50	 movsxd	 rax, DWORD PTR argcount$[rsp]
  00054	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR argcount$[rsp]
  00059	48 6b c9 10	 imul	 rcx, rcx, 16
  0005d	48 8b 94 24 d0
	04 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00065	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  00069	48 89 84 0c a8
	00 00 00	 mov	 QWORD PTR Args$[rsp+rcx+8], rax
  00071	48 63 44 24 50	 movsxd	 rax, DWORD PTR argcount$[rsp]
  00076	48 8b 8c 24 d0
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0007e	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00082	e8 00 00 00 00	 call	 strlen
  00087	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR argcount$[rsp]
  0008c	48 6b c9 10	 imul	 rcx, rcx, 16
  00090	89 84 0c a0 00
	00 00		 mov	 DWORD PTR Args$[rsp+rcx], eax
  00097	33 c0		 xor	 eax, eax
  00099	85 c0		 test	 eax, eax
  0009b	75 b2		 jne	 SHORT $LN7@ReginaExec

; 1021 :     }

  0009d	eb 92		 jmp	 SHORT $LN2@ReginaExec
$LN3@ReginaExec:

; 1022 : 
; 1023 :     ExitList[0].sysexit_name  = "HERCSIOE";

  0009f	b8 10 00 00 00	 mov	 eax, 16
  000a4	48 6b c0 00	 imul	 rax, rax, 0
  000a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160018
  000af	48 89 4c 04 78	 mov	 QWORD PTR ExitList$[rsp+rax], rcx

; 1024 :     ExitList[0].sysexit_code  = RXSIO;

  000b4	b8 10 00 00 00	 mov	 eax, 16
  000b9	48 6b c0 00	 imul	 rax, rax, 0
  000bd	c7 84 04 80 00
	00 00 05 00 00
	00		 mov	 DWORD PTR ExitList$[rsp+rax+8], 5

; 1025 :     ExitList[1].sysexit_code  = RXENDLST;

  000c8	b8 10 00 00 00	 mov	 eax, 16
  000cd	48 6b c0 01	 imul	 rax, rax, 1
  000d1	c7 84 04 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ExitList$[rsp+rax+8], 0

; 1026 : 
; 1027 :     RetValue.strptr           = NULL;   // (let Rexx allocate it)

  000dc	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR RetValue$[rsp+8], 0

; 1028 :     RetValue.strlength        = 0;      // (let Rexx allocate it)

  000e5	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR RetValue$[rsp], 0

; 1029 :     ArgList                   = (HR_ARGV_T) Args;

  000ed	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR Args$[rsp]
  000f5	48 89 44 24 60	 mov	 QWORD PTR ArgList$[rsp], rax

; 1030 :     calltype                  = RXSUBROUTINE;

  000fa	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR calltype$[rsp], 1

; 1031 : 
; 1032 :     rc = HRexxStart( argcount,          // Number of arguments

  00102	48 8d 44 24 68	 lea	 rax, QWORD PTR RetValue$[rsp]
  00107	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0010c	48 8d 44 24 54	 lea	 rax, QWORD PTR RetRC$[rsp]
  00111	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00116	48 8d 44 24 78	 lea	 rax, QWORD PTR ExitList$[rsp]
  0011b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00120	8b 44 24 58	 mov	 eax, DWORD PTR calltype$[rsp]
  00124	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00128	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160019
  0012f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00134	45 33 c9	 xor	 r9d, r9d
  00137	4c 8b 84 24 c0
	04 00 00	 mov	 r8, QWORD PTR scriptname$[rsp]
  0013f	48 8b 54 24 60	 mov	 rdx, QWORD PTR ArgList$[rsp]
  00144	8b 4c 24 50	 mov	 ecx, DWORD PTR argcount$[rsp]
  00148	e8 00 00 00 00	 call	 HRexxStart
  0014d	89 44 24 5c	 mov	 DWORD PTR rc$[rsp], eax

; 1033 :                      ArgList,           // Array of arguments
; 1034 :                      scriptname,        // Name of Rexx file
; 1035 :                      NULL,              // In-Storage Script
; 1036 :                      "HERCULES",        // Command env. name
; 1037 :                      calltype,          // Code for how invoked
; 1038 :                      ExitList,          // EXITs on this call
; 1039 :                      &RetRC,            // Converted return code
; 1040 :                      &RetValue );       // Rexx program output
; 1041 : 
; 1042 :     return ExecRet( "ExecSub", scriptname, rc, &RetRC, &RetValue );

  00151	48 8d 44 24 68	 lea	 rax, QWORD PTR RetValue$[rsp]
  00156	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0015b	4c 8d 4c 24 54	 lea	 r9, QWORD PTR RetRC$[rsp]
  00160	44 8b 44 24 5c	 mov	 r8d, DWORD PTR rc$[rsp]
  00165	48 8b 94 24 c0
	04 00 00	 mov	 rdx, QWORD PTR scriptname$[rsp]
  0016d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160020
  00174	e8 00 00 00 00	 call	 ExecRet

; 1043 : }

  00179	48 8b 8c 24 a0
	04 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00181	48 33 cc	 xor	 rcx, rsp
  00184	e8 00 00 00 00	 call	 __security_check_cookie
  00189	48 81 c4 b8 04
	00 00		 add	 rsp, 1208		; 000004b8H
  00190	c3		 ret	 0
ReginaExecSub ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
RetRC$ = 80
calltype$ = 84
argcount$ = 88
rc$ = 92
tv73 = 96
ArgList$ = 104
RetValue$ = 112
Args$ = 128
ExitList$ = 144
scriptname$ = 192
argstring$ = 200
ReginaExecCmd PROC

; 961  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
$LN4@ReginaExec:

; 962  :     HR_REXXRC_T   rc;
; 963  :     long          argcount;
; 964  :     RXSTRING      Args[1];
; 965  :     HR_ARGV_T     ArgList;
; 966  :     RXSYSEXIT     ExitList[2];
; 967  :     RXSTRING      RetValue;
; 968  :     int           calltype;
; 969  :     short         RetRC;
; 970  : 
; 971  :     /* Build the one and only RXSTRING command arguments string */
; 972  :     HMAKE_RXSTRING( Args[0], argstring, argstring ? strlen( argstring ) : 0 );

  00011	b8 10 00 00 00	 mov	 eax, 16
  00016	48 6b c0 00	 imul	 rax, rax, 0
  0001a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argstring$[rsp]
  00022	48 89 8c 04 88
	00 00 00	 mov	 QWORD PTR Args$[rsp+rax+8], rcx
  0002a	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR argstring$[rsp], 0
  00033	74 14		 je	 SHORT $LN6@ReginaExec
  00035	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argstring$[rsp]
  0003d	e8 00 00 00 00	 call	 strlen
  00042	48 89 44 24 60	 mov	 QWORD PTR tv73[rsp], rax
  00047	eb 09		 jmp	 SHORT $LN7@ReginaExec
$LN6@ReginaExec:
  00049	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv73[rsp], 0
$LN7@ReginaExec:
  00052	b8 10 00 00 00	 mov	 eax, 16
  00057	48 6b c0 00	 imul	 rax, rax, 0
  0005b	8b 4c 24 60	 mov	 ecx, DWORD PTR tv73[rsp]
  0005f	89 8c 04 80 00
	00 00		 mov	 DWORD PTR Args$[rsp+rax], ecx
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 a5		 jne	 SHORT $LN4@ReginaExec

; 973  : 
; 974  :     ExitList[0].sysexit_name  = "HERCSIOE";

  0006c	b8 10 00 00 00	 mov	 eax, 16
  00071	48 6b c0 00	 imul	 rax, rax, 0
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159990
  0007c	48 89 8c 04 90
	00 00 00	 mov	 QWORD PTR ExitList$[rsp+rax], rcx

; 975  :     ExitList[0].sysexit_code  = RXSIO;

  00084	b8 10 00 00 00	 mov	 eax, 16
  00089	48 6b c0 00	 imul	 rax, rax, 0
  0008d	c7 84 04 98 00
	00 00 05 00 00
	00		 mov	 DWORD PTR ExitList$[rsp+rax+8], 5

; 976  :     ExitList[1].sysexit_code  = RXENDLST;

  00098	b8 10 00 00 00	 mov	 eax, 16
  0009d	48 6b c0 01	 imul	 rax, rax, 1
  000a1	c7 84 04 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ExitList$[rsp+rax+8], 0

; 977  : 
; 978  :     RetValue.strptr           = NULL;   // (let Rexx allocate it)

  000ac	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR RetValue$[rsp+8], 0

; 979  :     RetValue.strlength        = 0;      // (let Rexx allocate it)

  000b5	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR RetValue$[rsp], 0

; 980  :     argcount                  = 1;

  000bd	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR argcount$[rsp], 1

; 981  :     ArgList                   = (HR_ARGV_T) Args;

  000c5	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR Args$[rsp]
  000cd	48 89 44 24 68	 mov	 QWORD PTR ArgList$[rsp], rax

; 982  :     calltype                  = RXCOMMAND;

  000d2	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR calltype$[rsp], 0

; 983  : 
; 984  :     rc = HRexxStart( argcount,          // Number of arguments

  000da	48 8d 44 24 70	 lea	 rax, QWORD PTR RetValue$[rsp]
  000df	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  000e4	48 8d 44 24 50	 lea	 rax, QWORD PTR RetRC$[rsp]
  000e9	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  000ee	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR ExitList$[rsp]
  000f6	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000fb	8b 44 24 54	 mov	 eax, DWORD PTR calltype$[rsp]
  000ff	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00103	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159991
  0010a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0010f	45 33 c9	 xor	 r9d, r9d
  00112	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR scriptname$[rsp]
  0011a	48 8b 54 24 68	 mov	 rdx, QWORD PTR ArgList$[rsp]
  0011f	8b 4c 24 58	 mov	 ecx, DWORD PTR argcount$[rsp]
  00123	e8 00 00 00 00	 call	 HRexxStart
  00128	89 44 24 5c	 mov	 DWORD PTR rc$[rsp], eax

; 985  :                      ArgList,           // Array of arguments
; 986  :                      scriptname,        // Name of Rexx file
; 987  :                      NULL,              // In-Storage Script
; 988  :                      "HERCULES",        // Command env. name
; 989  :                      calltype,          // Code for how invoked
; 990  :                      ExitList,          // EXITs on this call
; 991  :                      &RetRC,            // Converted return code
; 992  :                      &RetValue );       // Rexx program output
; 993  : 
; 994  :     return ExecRet( "ExecCmd", scriptname, rc, &RetRC, &RetValue );

  0012c	48 8d 44 24 70	 lea	 rax, QWORD PTR RetValue$[rsp]
  00131	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00136	4c 8d 4c 24 50	 lea	 r9, QWORD PTR RetRC$[rsp]
  0013b	44 8b 44 24 5c	 mov	 r8d, DWORD PTR rc$[rsp]
  00140	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR scriptname$[rsp]
  00148	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159992
  0014f	e8 00 00 00 00	 call	 ExecRet

; 995  : }

  00154	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0015b	c3		 ret	 0
ReginaExecCmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
tv84 = 96
pkgname$ = 104
failingfunc$ = 112
buf$1 = 128
__$ArrayPad$ = 192
funcname$ = 224
script$ = 232
rc$ = 240
RetRC$ = 248
RetValue$ = 256
ExecRet	PROC

; 919  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 920  :     const char*  pkgname      =       REXX_DEP( PackageName );

  0002d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ReginaPackageName
  00034	48 89 44 24 68	 mov	 QWORD PTR pkgname$[rsp], rax

; 921  :     const char*  failingfunc  = QSTR( REXX_DEP( RexxStart   ));

  00039	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159951
  00040	48 89 44 24 70	 mov	 QWORD PTR failingfunc$[rsp], rax

; 922  : 
; 923  :     if (RXAPI_OK != rc)

  00045	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  0004d	0f 84 9a 00 00
	00		 je	 $LN2@ExecRet

; 924  :     {
; 925  :         char buf[ 64 ];
; 926  :         MSGBUF( buf, "%s %s", funcname, failingfunc );

  00053	48 8b 44 24 70	 mov	 rax, QWORD PTR failingfunc$[rsp]
  00058	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005d	4c 8b 8c 24 e0
	00 00 00	 mov	 r9, QWORD PTR funcname$[rsp]
  00065	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159954
  0006c	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00071	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 927  :         // "REXX(%s) %s RC(%d)"
; 928  :         WRMSG( HHC17502, "E", pkgname, buf, (S32) rc );

  0007f	b9 01 00 00 00	 mov	 ecx, 1
  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0008a	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR rc$[rsp]
  00091	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00095	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  0009d	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000a2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pkgname$[rsp]
  000a7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159955
  000b3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159956
  000bf	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000c4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c9	41 b9 03 00 00
	00		 mov	 r9d, 3
  000cf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159957
  000d6	ba a0 03 00 00	 mov	 edx, 928		; 000003a0H
  000db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159958
  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 929  :     }

  000e8	e9 1c 01 00 00	 jmp	 $LN3@ExecRet
$LN2@ExecRet:

; 930  :     else
; 931  :     {
; 932  :         if (MsgLevel)

  000ed	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR MsgLevel
  000f4	85 c0		 test	 eax, eax
  000f6	0f 84 0d 01 00
	00		 je	 $LN4@ExecRet

; 933  :         {
; 934  :             // "REXX(%s) %s %s RetRC(%hd)"
; 935  :             WRMSG( HHC17503, "I", pkgname,

  000fc	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR RetRC$[rsp]
  00104	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00107	89 44 24 60	 mov	 DWORD PTR tv84[rsp], eax
  0010b	b9 01 00 00 00	 mov	 ecx, 1
  00110	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00116	8b 4c 24 60	 mov	 ecx, DWORD PTR tv84[rsp]
  0011a	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0011e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR script$[rsp]
  00126	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0012b	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR funcname$[rsp]
  00133	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00138	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pkgname$[rsp]
  0013d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00142	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159960
  00149	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0014e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159961
  00155	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0015a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0015f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00165	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159962
  0016c	ba a8 03 00 00	 mov	 edx, 936		; 000003a8H
  00171	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159963
  00178	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 936  :                 funcname, script, *RetRC );
; 937  : 
; 938  :             if (RetValue->strptr)

  0017e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR RetValue$[rsp]
  00186	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0018b	74 7c		 je	 SHORT $LN5@ExecRet

; 939  :             {
; 940  :                 // "REXX(%s) %s %s RetValue(\"%s\")"
; 941  :                 WRMSG( HHC17504, "I", pkgname,

  0018d	b9 01 00 00 00	 mov	 ecx, 1
  00192	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00198	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR RetValue$[rsp]
  001a0	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  001a4	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001a9	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR script$[rsp]
  001b1	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001b6	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR funcname$[rsp]
  001be	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001c3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pkgname$[rsp]
  001c8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159965
  001d4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159966
  001e0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001e5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ea	41 b9 03 00 00
	00		 mov	 r9d, 3
  001f0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159967
  001f7	ba ae 03 00 00	 mov	 edx, 942		; 000003aeH
  001fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159968
  00203	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@ExecRet:
$LN4@ExecRet:
$LN3@ExecRet:

; 942  :                     funcname, script, RetValue->strptr );
; 943  :             }
; 944  :         }
; 945  :     }
; 946  : 
; 947  :     if (RetValue->strptr)

  00209	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR RetValue$[rsp]
  00211	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00216	74 12		 je	 SHORT $LN6@ExecRet

; 948  :         REXX_DEP( FreeMemory )( RetValue->strptr );

  00218	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR RetValue$[rsp]
  00220	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00224	ff 15 00 00 00
	00		 call	 QWORD PTR ReginaFreeMemory
$LN6@ExecRet:

; 949  : 
; 950  :     return (int) rc;

  0022a	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR rc$[rsp]

; 951  : }

  00231	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00239	48 33 cc	 xor	 rcx, rsp
  0023c	e8 00 00 00 00	 call	 __security_check_cookie
  00241	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00248	c3		 ret	 0
ExecRet	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
rc$ = 80
ArgCount$ = 112
ArgList$ = 120
ProgramName$ = 128
Instore$ = 136
EnvName$ = 144
CallType$ = 152
Exits$ = 160
RetRC$ = 168
Result$ = 176
HRexxStart PROC

; 883  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 884  :     /* PROGRAMMING NOTE: calling a Rexx package's RexxStart function
; 885  :        is made a separate function unto itself to make it easier to
; 886  :        debug every call made to RexxStart without having to set many
; 887  :        separate breakpoints all over the place.
; 888  :     */
; 889  : #if REXX_PKGNUM == REGINA_PKGNUM
; 890  :     /* When running a Regina script in background, handlers need to be re-registered. */
; 891  :     if (!equal_threads( thread_id(), sysblk.impltid )) RegisterRexxHandlersAndFunctions();

  00017	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  0001d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00024	8b 91 d8 00 00
	00		 mov	 edx, DWORD PTR [rcx+216]
  0002a	8b c8		 mov	 ecx, eax
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_equal_threads
  00032	85 c0		 test	 eax, eax
  00034	75 05		 jne	 SHORT $LN2@HRexxStart
  00036	e8 00 00 00 00	 call	 RegisterRexxHandlersAndFunctions
$LN2@HRexxStart:

; 892  : #endif
; 893  :     HR_REXXRC_T  rc  = REXX_DEP( RexxStart )

  0003b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR Result$[rsp]
  00043	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00048	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR RetRC$[rsp]
  00050	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00055	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR Exits$[rsp]
  0005d	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00062	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR CallType$[rsp]
  00069	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0006d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR EnvName$[rsp]
  00075	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007a	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR Instore$[rsp]
  00082	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR ProgramName$[rsp]
  0008a	48 8b 54 24 78	 mov	 rdx, QWORD PTR ArgList$[rsp]
  0008f	8b 4c 24 70	 mov	 ecx, DWORD PTR ArgCount$[rsp]
  00093	ff 15 00 00 00
	00		 call	 QWORD PTR ReginaRexxStart
  00099	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 894  :     (
; 895  :         ArgCount,                       // Number of arguments
; 896  :         ArgList,                        // Array of arguments
; 897  :         ProgramName,                    // Name of Rexx file
; 898  :         Instore,                        // In-Storage Script
; 899  :         EnvName,                        // Command env. name
; 900  :         CallType,                       // Code for how invoked
; 901  :         Exits,                          // EXITs on this call
; 902  :         RetRC,                          // Converted return code
; 903  :         Result                          // Rexx program output
; 904  :     );
; 905  :     return rc;

  0009d	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]

; 906  : }

  000a1	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000a5	c3		 ret	 0
HRexxStart ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
quiet$ = 48
err$ = 52
n$1 = 56
vname$2 = 64
resp$ = 72
line$3 = 80
vnamesize$4 = 88
stemlen$5 = 96
buf$6 = 104
__$ArrayPad$ = 120
herccmd$ = 144
stemname$ = 152
panelrc$ = 160
HerculesCommand PROC

; 605  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 44 24 78	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 606  :     HR_ERR_T  err;          // Hercules Rexx error code
; 607  :     char*     resp;         // Response from panel_command
; 608  :     bool      quiet;        // don't show response on console if true
; 609  : 
; 610  :     /* Validate arguments and trim Hercules command line */
; 611  :     if (!herccmd || !*TRIM( herccmd ) || !panelrc)

  00025	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR herccmd$[rsp], 0
  0002e	74 27		 je	 SHORT $LN6@HerculesCo
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159792
  00037	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR herccmd$[rsp]
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_trim
  00045	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00048	85 c0		 test	 eax, eax
  0004a	74 0b		 je	 SHORT $LN6@HerculesCo
  0004c	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR panelrc$[rsp], 0
  00055	75 0a		 jne	 SHORT $LN5@HerculesCo
$LN6@HerculesCo:

; 612  :         return HRERR_BADARGS;

  00057	b8 e9 03 00 00	 mov	 eax, 1001		; 000003e9H
  0005c	e9 31 02 00 00	 jmp	 $LN1@HerculesCo
$LN5@HerculesCo:

; 613  : 
; 614  :     /* if response is wanted, ask Hercules to be quiet on the console */
; 615  :     if (stemname) quiet = true;

  00061	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR stemname$[rsp], 0
  0006a	74 07		 je	 SHORT $LN7@HerculesCo
  0006c	c6 44 24 30 01	 mov	 BYTE PTR quiet$[rsp], 1
  00071	eb 05		 jmp	 SHORT $LN8@HerculesCo
$LN7@HerculesCo:

; 616  :     else          quiet = false;

  00073	c6 44 24 30 00	 mov	 BYTE PTR quiet$[rsp], 0
$LN8@HerculesCo:

; 617  : 
; 618  :     /* Issue the Hercules command and capture the response */
; 619  :     *panelrc = panel_command_capture( herccmd, &resp, quiet );

  00078	44 0f b6 44 24
	30		 movzx	 r8d, BYTE PTR quiet$[rsp]
  0007e	48 8d 54 24 48	 lea	 rdx, QWORD PTR resp$[rsp]
  00083	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR herccmd$[rsp]
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_panel_command_capture
  00091	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR panelrc$[rsp]
  00099	89 01		 mov	 DWORD PTR [rcx], eax

; 620  : 
; 621  :     /* Format response string stem values if response is wanted */
; 622  :     if (stemname)

  0009b	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR stemname$[rsp], 0
  000a4	0f 84 db 01 00
	00		 je	 $LN9@HerculesCo

; 623  :     {
; 624  :         char*   line;                 // single line of response
; 625  :         char*   vname;                // stem variable name buffer
; 626  :         size_t  vnamesize, stemlen;   // stem buffer size and strlen
; 627  : 
; 628  :         int     n;                          // (counts #of stems)
; 629  :         char    buf[ NUM_DIGITS_32 + 1 ];   // (prints #of stems)
; 630  : 
; 631  :         /* Remove any trailing dot/period from stem name */
; 632  :         if (!(stemlen = strlen( rtrim( stemname, "." ))))

  000aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159797
  000b1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR stemname$[rsp]
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim
  000bf	48 8b c8	 mov	 rcx, rax
  000c2	e8 00 00 00 00	 call	 strlen
  000c7	48 89 44 24 60	 mov	 QWORD PTR stemlen$5[rsp], rax
  000cc	48 83 7c 24 60
	00		 cmp	 QWORD PTR stemlen$5[rsp], 0
  000d2	75 15		 jne	 SHORT $LN10@HerculesCo

; 633  :         {
; 634  :             free( resp );

  000d4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR resp$[rsp]
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 635  :             return HRERR_BADARGS;

  000df	b8 e9 03 00 00	 mov	 eax, 1001		; 000003e9H
  000e4	e9 a9 01 00 00	 jmp	 $LN1@HerculesCo
$LN10@HerculesCo:

; 636  :         }
; 637  : 
; 638  :         /* Allocate buffer for constructing stem variable names.
; 639  :            +1 is for dot/period, another +1 for null terminator.
; 640  :         */
; 641  :         if (!(vname = malloc( vnamesize = stemlen + 1 + NUM_DIGITS_32 + 1 )))

  000e9	48 8b 44 24 60	 mov	 rax, QWORD PTR stemlen$5[rsp]
  000ee	48 83 c0 0c	 add	 rax, 12
  000f2	48 89 44 24 58	 mov	 QWORD PTR vnamesize$4[rsp], rax
  000f7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR vnamesize$4[rsp]
  000fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00102	48 89 44 24 40	 mov	 QWORD PTR vname$2[rsp], rax
  00107	48 83 7c 24 40
	00		 cmp	 QWORD PTR vname$2[rsp], 0
  0010d	75 15		 jne	 SHORT $LN11@HerculesCo

; 642  :         {
; 643  :             free( resp );

  0010f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR resp$[rsp]
  00114	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 644  :             return HRERR_NOMEM;     // (out of memory)

  0011a	b8 ea 03 00 00	 mov	 eax, 1002		; 000003eaH
  0011f	e9 6e 01 00 00	 jmp	 $LN1@HerculesCo
$LN11@HerculesCo:

; 645  :         }
; 646  : 
; 647  :         /* Parse response lines and assign to Rexx stem variable */
; 648  :         if (resp)

  00124	48 83 7c 24 48
	00		 cmp	 QWORD PTR resp$[rsp], 0
  0012a	0f 84 bb 00 00
	00		 je	 $LN12@HerculesCo

; 649  :         {
; 650  :             for (n=1, line = strtok( resp, "\n" ); line;

  00130	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR n$1[rsp], 1
  00138	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159801
  0013f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR resp$[rsp]
  00144	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok
  0014a	48 89 44 24 50	 mov	 QWORD PTR line$3[rsp], rax
  0014f	eb 1e		 jmp	 SHORT $LN4@HerculesCo
$LN2@HerculesCo:

; 651  :                  n++, line = strtok( NULL, "\n" ))

  00151	8b 44 24 38	 mov	 eax, DWORD PTR n$1[rsp]
  00155	ff c0		 inc	 eax
  00157	89 44 24 38	 mov	 DWORD PTR n$1[rsp], eax
  0015b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159802
  00162	33 c9		 xor	 ecx, ecx
  00164	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok
  0016a	48 89 44 24 50	 mov	 QWORD PTR line$3[rsp], rax
$LN4@HerculesCo:

; 649  :         {
; 650  :             for (n=1, line = strtok( resp, "\n" ); line;

  0016f	48 83 7c 24 50
	00		 cmp	 QWORD PTR line$3[rsp], 0
  00175	74 72		 je	 SHORT $LN3@HerculesCo

; 652  :             {
; 653  :                 snprintf( vname, vnamesize, "%s.%d", stemname, n );

  00177	8b 44 24 38	 mov	 eax, DWORD PTR n$1[rsp]
  0017b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0017f	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR stemname$[rsp]
  00187	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159803
  0018e	48 8b 54 24 58	 mov	 rdx, QWORD PTR vnamesize$4[rsp]
  00193	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vname$2[rsp]
  00198	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 654  : 
; 655  :                 if (HRERR_OK != (err = SHV2ERR( SetVar( vname, line ))))

  0019e	48 8b 54 24 50	 mov	 rdx, QWORD PTR line$3[rsp]
  001a3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vname$2[rsp]
  001a8	e8 00 00 00 00	 call	 SetVar
  001ad	8b c0		 mov	 eax, eax
  001af	8b c8		 mov	 ecx, eax
  001b1	e8 00 00 00 00	 call	 Shv2Err
  001b6	66 89 44 24 34	 mov	 WORD PTR err$[rsp], ax
  001bb	0f b7 44 24 34	 movzx	 eax, WORD PTR err$[rsp]
  001c0	85 c0		 test	 eax, eax
  001c2	74 20		 je	 SHORT $LN14@HerculesCo

; 656  :                 {
; 657  :                     free( resp );

  001c4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR resp$[rsp]
  001c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 658  :                     free( vname );

  001cf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vname$2[rsp]
  001d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 659  :                     return err;

  001da	0f b7 44 24 34	 movzx	 eax, WORD PTR err$[rsp]
  001df	e9 ae 00 00 00	 jmp	 $LN1@HerculesCo
$LN14@HerculesCo:

; 660  :                 }
; 661  :             }

  001e4	e9 68 ff ff ff	 jmp	 $LN2@HerculesCo
$LN3@HerculesCo:

; 662  :         }

  001e9	eb 08		 jmp	 SHORT $LN13@HerculesCo
$LN12@HerculesCo:

; 663  :         else
; 664  :             n = 0;  // (no response == no stems)

  001eb	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR n$1[rsp], 0
$LN13@HerculesCo:

; 665  : 
; 666  :         /* Tell Rexx how many stem values there are (stemname.0) */
; 667  :         snprintf( vname, vnamesize, "%s.%d", stemname, 0 );

  001f3	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  001fc	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR stemname$[rsp]
  00204	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159805
  0020b	48 8b 54 24 58	 mov	 rdx, QWORD PTR vnamesize$4[rsp]
  00210	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vname$2[rsp]
  00215	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 668  :         MSGBUF( buf, "%d", n ); // (number of stems)

  0021b	44 8b 4c 24 38	 mov	 r9d, DWORD PTR n$1[rsp]
  00220	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159806
  00227	ba 0b 00 00 00	 mov	 edx, 11
  0022c	48 8d 4c 24 68	 lea	 rcx, QWORD PTR buf$6[rsp]
  00231	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 669  : 
; 670  :         if (HRERR_OK != (err = SHV2ERR( SetVar( vname, buf ))))

  00237	48 8d 54 24 68	 lea	 rdx, QWORD PTR buf$6[rsp]
  0023c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vname$2[rsp]
  00241	e8 00 00 00 00	 call	 SetVar
  00246	8b c0		 mov	 eax, eax
  00248	8b c8		 mov	 ecx, eax
  0024a	e8 00 00 00 00	 call	 Shv2Err
  0024f	66 89 44 24 34	 mov	 WORD PTR err$[rsp], ax
  00254	0f b7 44 24 34	 movzx	 eax, WORD PTR err$[rsp]
  00259	85 c0		 test	 eax, eax
  0025b	74 1d		 je	 SHORT $LN15@HerculesCo

; 671  :         {
; 672  :             free( resp );

  0025d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR resp$[rsp]
  00262	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 673  :             free( vname );

  00268	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vname$2[rsp]
  0026d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 674  :             return err;

  00273	0f b7 44 24 34	 movzx	 eax, WORD PTR err$[rsp]
  00278	eb 18		 jmp	 SHORT $LN1@HerculesCo
$LN15@HerculesCo:

; 675  :         }
; 676  : 
; 677  :         /* Free stem variable name buffer */
; 678  :         free( vname );

  0027a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vname$2[rsp]
  0027f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN9@HerculesCo:

; 679  :     }
; 680  : 
; 681  :     /* Free panel_command response strings */
; 682  :     free( resp );

  00285	48 8b 4c 24 48	 mov	 rcx, QWORD PTR resp$[rsp]
  0028a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 683  : 
; 684  :     /* Return success */
; 685  :     return HRERR_OK;

  00290	33 c0		 xor	 eax, eax
$LN1@HerculesCo:

; 686  : }

  00292	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00297	48 33 cc	 xor	 rcx, rsp
  0029a	e8 00 00 00 00	 call	 __security_check_cookie
  0029f	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002a6	c3		 ret	 0
HerculesCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
rc$ = 32
err$ = 64
panelrc$ = 72
RetValue$ = 80
ExtFuncRC PROC

; 590  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 591  :     HR_EXTFUNC_RC_T  rc   = Err2ExtFunc( err );

  00012	0f b7 4c 24 40	 movzx	 ecx, WORD PTR err$[rsp]
  00017	e8 00 00 00 00	 call	 Err2ExtFunc
  0001c	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 592  :     FmtExtFuncRV(    rc,  panelrc,  RetValue );

  00020	4c 8b 44 24 50	 mov	 r8, QWORD PTR RetValue$[rsp]
  00025	8b 54 24 48	 mov	 edx, DWORD PTR panelrc$[rsp]
  00029	8b 4c 24 20	 mov	 ecx, DWORD PTR rc$[rsp]
  0002d	e8 00 00 00 00	 call	 FmtExtFuncRV

; 593  :     return           rc;

  00032	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 594  : }

  00036	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003a	c3		 ret	 0
ExtFuncRC ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
rc$ = 32
err$ = 64
panelrc$ = 72
RetValue$ = 80
Flags$ = 88
SubCommRC PROC

; 578  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 579  :     HR_SUBCOM_RC_T  rc   = Err2SubComm( err, Flags );

  00017	48 8b 54 24 58	 mov	 rdx, QWORD PTR Flags$[rsp]
  0001c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR err$[rsp]
  00021	e8 00 00 00 00	 call	 Err2SubComm
  00026	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 580  :     FmtSubCommRV(   rc,  panelrc,  RetValue );

  0002a	4c 8b 44 24 50	 mov	 r8, QWORD PTR RetValue$[rsp]
  0002f	8b 54 24 48	 mov	 edx, DWORD PTR panelrc$[rsp]
  00033	8b 4c 24 20	 mov	 ecx, DWORD PTR rc$[rsp]
  00037	e8 00 00 00 00	 call	 FmtSubCommRV

; 581  :     return          rc;

  0003c	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 582  : }

  00040	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00044	c3		 ret	 0
SubCommRC ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
rc$ = 48
panelrc$ = 56
RetValue$ = 64
FmtExtFuncRV PROC

; 552  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 553  :     if (RXFUNC_OK == rc)

  00011	83 7c 24 30 00	 cmp	 DWORD PTR rc$[rsp], 0
  00016	75 18		 jne	 SHORT $LN2@FmtExtFunc

; 554  :         rx_sprintf( RetValue, "%d", panelrc );

  00018	44 8b 44 24 38	 mov	 r8d, DWORD PTR panelrc$[rsp]
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159735
  00024	48 8b 4c 24 40	 mov	 rcx, QWORD PTR RetValue$[rsp]
  00029	e8 00 00 00 00	 call	 rx_sprintf
  0002e	eb 16		 jmp	 SHORT $LN3@FmtExtFunc
$LN2@FmtExtFunc:

; 555  :     else
; 556  : 
; 557  : #if REXX_PKGNUM == OOREXX_PKGNUM
; 558  : 
; 559  :     rx_sprintf( RetValue, "%"PRIu64, (U64) rc );   // (size_t)
; 560  : 
; 561  : #else // REXX_PKGNUM == REGINA_PKGNUM
; 562  : 
; 563  :     rx_sprintf( RetValue, "%u", rc );              // (APIRET = ULONG)

  00030	44 8b 44 24 30	 mov	 r8d, DWORD PTR rc$[rsp]
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159736
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR RetValue$[rsp]
  00041	e8 00 00 00 00	 call	 rx_sprintf
$LN3@FmtExtFunc:

; 564  : 
; 565  : #endif
; 566  : }

  00046	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004a	c3		 ret	 0
FmtExtFuncRV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
rc$ = 48
panelrc$ = 56
RetValue$ = 64
FmtSubCommRV PROC

; 530  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 531  :     if (RXSUBCOM_OK == rc)

  00011	83 7c 24 30 00	 cmp	 DWORD PTR rc$[rsp], 0
  00016	75 18		 jne	 SHORT $LN2@FmtSubComm

; 532  :         rx_sprintf( RetValue, "%d", panelrc );

  00018	44 8b 44 24 38	 mov	 r8d, DWORD PTR panelrc$[rsp]
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159723
  00024	48 8b 4c 24 40	 mov	 rcx, QWORD PTR RetValue$[rsp]
  00029	e8 00 00 00 00	 call	 rx_sprintf
  0002e	eb 16		 jmp	 SHORT $LN3@FmtSubComm
$LN2@FmtSubComm:

; 533  :     else
; 534  : 
; 535  : #if REXX_PKGNUM == OOREXX_PKGNUM
; 536  : 
; 537  :     rx_sprintf( RetValue, "%d", rc );       // (RexxReturnCode = int)
; 538  : 
; 539  : #else // REXX_PKGNUM == REGINA_PKGNUM
; 540  : 
; 541  :     rx_sprintf( RetValue, "%u", rc );       // (APIRET = ULONG)

  00030	44 8b 44 24 30	 mov	 r8d, DWORD PTR rc$[rsp]
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159724
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR RetValue$[rsp]
  00041	e8 00 00 00 00	 call	 rx_sprintf
$LN3@FmtSubComm:

; 542  : 
; 543  : #endif
; 544  : }

  00046	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004a	c3		 ret	 0
FmtSubCommRV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
rc$ = 0
tv65 = 4
err$ = 32
Err2ExtFunc PROC

; 505  : {

  00000	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00005	48 83 ec 18	 sub	 rsp, 24

; 506  :     HR_EXTFUNC_RC_T  rc;
; 507  : 
; 508  :     switch (err)

  00009	0f b7 44 24 20	 movzx	 eax, WORD PTR err$[rsp]
  0000e	89 44 24 04	 mov	 DWORD PTR tv65[rsp], eax
  00012	83 7c 24 04 00	 cmp	 DWORD PTR tv65[rsp], 0
  00017	74 24		 je	 SHORT $LN4@Err2ExtFun
  00019	83 7c 24 04 01	 cmp	 DWORD PTR tv65[rsp], 1
  0001e	74 38		 je	 SHORT $LN7@Err2ExtFun
  00020	83 7c 24 04 02	 cmp	 DWORD PTR tv65[rsp], 2
  00025	74 3a		 je	 SHORT $LN8@Err2ExtFun
  00027	81 7c 24 04 e9
	03 00 00	 cmp	 DWORD PTR tv65[rsp], 1001 ; 000003e9H
  0002f	74 15		 je	 SHORT $LN5@Err2ExtFun
  00031	81 7c 24 04 ea
	03 00 00	 cmp	 DWORD PTR tv65[rsp], 1002 ; 000003eaH
  00039	74 14		 je	 SHORT $LN6@Err2ExtFun
  0003b	eb 2d		 jmp	 SHORT $LN9@Err2ExtFun
$LN4@Err2ExtFun:

; 509  :     {
; 510  :         case HRERR_OK:      rc = RXFUNC_OK;       break;

  0003d	c7 04 24 00 00
	00 00		 mov	 DWORD PTR rc$[rsp], 0
  00044	eb 2b		 jmp	 SHORT $LN2@Err2ExtFun
$LN5@Err2ExtFun:

; 511  :         case HRERR_BADARGS: rc = RXFUNC_BADENTRY; break;

  00046	c7 04 24 28 00
	00 00		 mov	 DWORD PTR rc$[rsp], 40	; 00000028H
  0004d	eb 22		 jmp	 SHORT $LN2@Err2ExtFun
$LN6@Err2ExtFun:

; 512  :         case HRERR_NOMEM:   rc = RXFUNC_NOEMEM;   break;

  0004f	c7 04 24 ea 03
	00 00		 mov	 DWORD PTR rc$[rsp], 1002 ; 000003eaH
  00056	eb 19		 jmp	 SHORT $LN2@Err2ExtFun
$LN7@Err2ExtFun:

; 513  :         case HRERR_ERROR:   rc = RXFUNC_ERROR;    break;

  00058	c7 04 24 01 00
	00 00		 mov	 DWORD PTR rc$[rsp], 1
  0005f	eb 10		 jmp	 SHORT $LN2@Err2ExtFun
$LN8@Err2ExtFun:

; 514  :         case HRERR_FAILURE: rc = RXFUNC_FAILURE;  break;

  00061	c7 04 24 02 00
	00 00		 mov	 DWORD PTR rc$[rsp], 2
  00068	eb 07		 jmp	 SHORT $LN2@Err2ExtFun
$LN9@Err2ExtFun:

; 515  :         default:            rc = RXFUNC_FAILURE;  break;

  0006a	c7 04 24 02 00
	00 00		 mov	 DWORD PTR rc$[rsp], 2
$LN2@Err2ExtFun:

; 516  :     }
; 517  : 
; 518  :     return rc;

  00071	8b 04 24	 mov	 eax, DWORD PTR rc$[rsp]

; 519  : }

  00074	48 83 c4 18	 add	 rsp, 24
  00078	c3		 ret	 0
Err2ExtFunc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
rc$ = 0
tv65 = 4
err$ = 32
Flags$ = 40
Err2SubComm PROC

; 487  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 488  :     HR_SUBCOM_RC_T  rc;
; 489  : 
; 490  :     switch (err)

  0000e	0f b7 44 24 20	 movzx	 eax, WORD PTR err$[rsp]
  00013	89 44 24 04	 mov	 DWORD PTR tv65[rsp], eax
  00017	83 7c 24 04 00	 cmp	 DWORD PTR tv65[rsp], 0
  0001c	74 24		 je	 SHORT $LN4@Err2SubCom
  0001e	83 7c 24 04 01	 cmp	 DWORD PTR tv65[rsp], 1
  00023	74 38		 je	 SHORT $LN7@Err2SubCom
  00025	83 7c 24 04 02	 cmp	 DWORD PTR tv65[rsp], 2
  0002a	74 3a		 je	 SHORT $LN8@Err2SubCom
  0002c	81 7c 24 04 e9
	03 00 00	 cmp	 DWORD PTR tv65[rsp], 1001 ; 000003e9H
  00034	74 15		 je	 SHORT $LN5@Err2SubCom
  00036	81 7c 24 04 ea
	03 00 00	 cmp	 DWORD PTR tv65[rsp], 1002 ; 000003eaH
  0003e	74 14		 je	 SHORT $LN6@Err2SubCom
  00040	eb 2d		 jmp	 SHORT $LN9@Err2SubCom
$LN4@Err2SubCom:

; 491  :     {
; 492  :         case HRERR_OK:      rc = RXSUBCOM_OK;       break;

  00042	c7 04 24 00 00
	00 00		 mov	 DWORD PTR rc$[rsp], 0
  00049	eb 2b		 jmp	 SHORT $LN2@Err2SubCom
$LN5@Err2SubCom:

; 493  :         case HRERR_BADARGS: rc = RXSUBCOM_BADENTRY; break;

  0004b	c7 04 24 e9 03
	00 00		 mov	 DWORD PTR rc$[rsp], 1001 ; 000003e9H
  00052	eb 22		 jmp	 SHORT $LN2@Err2SubCom
$LN6@Err2SubCom:

; 494  :         case HRERR_NOMEM:   rc = RXSUBCOM_NOEMEM;   break;

  00054	c7 04 24 ea 03
	00 00		 mov	 DWORD PTR rc$[rsp], 1002 ; 000003eaH
  0005b	eb 19		 jmp	 SHORT $LN2@Err2SubCom
$LN7@Err2SubCom:

; 495  :         case HRERR_ERROR:   rc = RXSUBCOM_ERROR;    break;

  0005d	c7 04 24 01 00
	00 00		 mov	 DWORD PTR rc$[rsp], 1
  00064	eb 10		 jmp	 SHORT $LN2@Err2SubCom
$LN8@Err2SubCom:

; 496  :         case HRERR_FAILURE: rc = RXSUBCOM_FAILURE;  break;

  00066	c7 04 24 02 00
	00 00		 mov	 DWORD PTR rc$[rsp], 2
  0006d	eb 07		 jmp	 SHORT $LN2@Err2SubCom
$LN9@Err2SubCom:

; 497  :         default:            rc = RXSUBCOM_FAILURE;  break;

  0006f	c7 04 24 02 00
	00 00		 mov	 DWORD PTR rc$[rsp], 2
$LN2@Err2SubCom:

; 498  :     }
; 499  : 
; 500  :     *Flags = rc;        // (update Rexx Flags)

  00076	48 8b 44 24 28	 mov	 rax, QWORD PTR Flags$[rsp]
  0007b	0f b7 0c 24	 movzx	 ecx, WORD PTR rc$[rsp]
  0007f	66 89 08	 mov	 WORD PTR [rax], cx

; 501  :     return rc;

  00082	8b 04 24	 mov	 eax, DWORD PTR rc$[rsp]

; 502  : }

  00085	48 83 c4 18	 add	 rsp, 24
  00089	c3		 ret	 0
Err2SubComm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
tv64 = 0
shvrc$ = 32
Shv2Err	PROC

; 450  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 451  :     switch ((size_t)shvrc)          // (must be integral value)

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR shvrc$[rsp]
  0000e	48 89 04 24	 mov	 QWORD PTR tv64[rsp], rax
  00012	48 81 3c 24 80
	00 00 00	 cmp	 QWORD PTR tv64[rsp], 128 ; 00000080H
  0001a	77 31		 ja	 SHORT $LN12@Shv2Err
  0001c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:__ImageBase
  00023	48 8b 0c 24	 mov	 rcx, QWORD PTR tv64[rsp]
  00027	0f b6 8c 08 00
	00 00 00	 movzx	 ecx, BYTE PTR $LN14@Shv2Err[rax+rcx]
  0002f	8b 8c 88 00 00
	00 00		 mov	 ecx, DWORD PTR $LN15@Shv2Err[rax+rcx*4]
  00036	48 03 c8	 add	 rcx, rax
  00039	ff e1		 jmp	 rcx
$LN4@Shv2Err:
$LN5@Shv2Err:
$LN6@Shv2Err:

; 452  :     {
; 453  :         case RXSHV_OK:              // Execution was OK
; 454  :         case RXSHV_NEWV:            // Variable was created
; 455  :         case RXSHV_LVAR:            // Last var trans via SHVNEXTV
; 456  :         {
; 457  :             return HRERR_OK;

  0003b	33 c0		 xor	 eax, eax
  0003d	eb 13		 jmp	 SHORT $LN1@Shv2Err
$LN7@Shv2Err:

; 458  :         }
; 459  : 
; 460  :         case RXSHV_MEMFL:           // Out of memory failure
; 461  :         {
; 462  :             return HRERR_NOMEM;

  0003f	b8 ea 03 00 00	 mov	 eax, 1002		; 000003eaH
  00044	eb 0c		 jmp	 SHORT $LN1@Shv2Err
$LN8@Shv2Err:
$LN9@Shv2Err:
$LN10@Shv2Err:

; 463  :         }
; 464  : 
; 465  :         case RXSHV_TRUNC:           // Truncation occurred (Fetch)
; 466  :         case RXSHV_BADN:            // Invalid variable name
; 467  :         case RXSHV_BADF:            // Invalid func code (shvcode)
; 468  :         {
; 469  :             return HRERR_ERROR;

  00046	b8 01 00 00 00	 mov	 eax, 1
  0004b	eb 05		 jmp	 SHORT $LN1@Shv2Err
$LN12@Shv2Err:

; 470  :         }
; 471  : 
; 472  :         case RXSHV_NOAVL:           // Interface is not available
; 473  :         default:
; 474  :         {
; 475  :             break;                  // (catch-all)
; 476  :         }
; 477  :     }
; 478  :     return HRERR_FAILURE;           // return 'FAILURE'

  0004d	b8 02 00 00 00	 mov	 eax, 2
$LN1@Shv2Err:

; 479  : }

  00052	48 83 c4 18	 add	 rsp, 24
  00056	c3		 ret	 0
  00057	90		 npad	 1
$LN15@Shv2Err:
  00058	00 00 00 00	 DD	 $LN4@Shv2Err
  0005c	00 00 00 00	 DD	 $LN5@Shv2Err
  00060	00 00 00 00	 DD	 $LN6@Shv2Err
  00064	00 00 00 00	 DD	 $LN8@Shv2Err
  00068	00 00 00 00	 DD	 $LN9@Shv2Err
  0006c	00 00 00 00	 DD	 $LN7@Shv2Err
  00070	00 00 00 00	 DD	 $LN10@Shv2Err
  00074	00 00 00 00	 DD	 $LN12@Shv2Err
$LN14@Shv2Err:
  00078	00		 DB	 0
  00079	01		 DB	 1
  0007a	02		 DB	 2
  0007b	07		 DB	 7
  0007c	03		 DB	 3
  0007d	07		 DB	 7
  0007e	07		 DB	 7
  0007f	07		 DB	 7
  00080	04		 DB	 4
  00081	07		 DB	 7
  00082	07		 DB	 7
  00083	07		 DB	 7
  00084	07		 DB	 7
  00085	07		 DB	 7
  00086	07		 DB	 7
  00087	07		 DB	 7
  00088	05		 DB	 5
  00089	07		 DB	 7
  0008a	07		 DB	 7
  0008b	07		 DB	 7
  0008c	07		 DB	 7
  0008d	07		 DB	 7
  0008e	07		 DB	 7
  0008f	07		 DB	 7
  00090	07		 DB	 7
  00091	07		 DB	 7
  00092	07		 DB	 7
  00093	07		 DB	 7
  00094	07		 DB	 7
  00095	07		 DB	 7
  00096	07		 DB	 7
  00097	07		 DB	 7
  00098	07		 DB	 7
  00099	07		 DB	 7
  0009a	07		 DB	 7
  0009b	07		 DB	 7
  0009c	07		 DB	 7
  0009d	07		 DB	 7
  0009e	07		 DB	 7
  0009f	07		 DB	 7
  000a0	07		 DB	 7
  000a1	07		 DB	 7
  000a2	07		 DB	 7
  000a3	07		 DB	 7
  000a4	07		 DB	 7
  000a5	07		 DB	 7
  000a6	07		 DB	 7
  000a7	07		 DB	 7
  000a8	07		 DB	 7
  000a9	07		 DB	 7
  000aa	07		 DB	 7
  000ab	07		 DB	 7
  000ac	07		 DB	 7
  000ad	07		 DB	 7
  000ae	07		 DB	 7
  000af	07		 DB	 7
  000b0	07		 DB	 7
  000b1	07		 DB	 7
  000b2	07		 DB	 7
  000b3	07		 DB	 7
  000b4	07		 DB	 7
  000b5	07		 DB	 7
  000b6	07		 DB	 7
  000b7	07		 DB	 7
  000b8	07		 DB	 7
  000b9	07		 DB	 7
  000ba	07		 DB	 7
  000bb	07		 DB	 7
  000bc	07		 DB	 7
  000bd	07		 DB	 7
  000be	07		 DB	 7
  000bf	07		 DB	 7
  000c0	07		 DB	 7
  000c1	07		 DB	 7
  000c2	07		 DB	 7
  000c3	07		 DB	 7
  000c4	07		 DB	 7
  000c5	07		 DB	 7
  000c6	07		 DB	 7
  000c7	07		 DB	 7
  000c8	07		 DB	 7
  000c9	07		 DB	 7
  000ca	07		 DB	 7
  000cb	07		 DB	 7
  000cc	07		 DB	 7
  000cd	07		 DB	 7
  000ce	07		 DB	 7
  000cf	07		 DB	 7
  000d0	07		 DB	 7
  000d1	07		 DB	 7
  000d2	07		 DB	 7
  000d3	07		 DB	 7
  000d4	07		 DB	 7
  000d5	07		 DB	 7
  000d6	07		 DB	 7
  000d7	07		 DB	 7
  000d8	07		 DB	 7
  000d9	07		 DB	 7
  000da	07		 DB	 7
  000db	07		 DB	 7
  000dc	07		 DB	 7
  000dd	07		 DB	 7
  000de	07		 DB	 7
  000df	07		 DB	 7
  000e0	07		 DB	 7
  000e1	07		 DB	 7
  000e2	07		 DB	 7
  000e3	07		 DB	 7
  000e4	07		 DB	 7
  000e5	07		 DB	 7
  000e6	07		 DB	 7
  000e7	07		 DB	 7
  000e8	07		 DB	 7
  000e9	07		 DB	 7
  000ea	07		 DB	 7
  000eb	07		 DB	 7
  000ec	07		 DB	 7
  000ed	07		 DB	 7
  000ee	07		 DB	 7
  000ef	07		 DB	 7
  000f0	07		 DB	 7
  000f1	07		 DB	 7
  000f2	07		 DB	 7
  000f3	07		 DB	 7
  000f4	07		 DB	 7
  000f5	07		 DB	 7
  000f6	07		 DB	 7
  000f7	07		 DB	 7
  000f8	06		 DB	 6
Shv2Err	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
RexxRC$ = 96
RxVarBlock$ = 104
Name$ = 176
Value$ = 184
FetchVar PROC

; 319  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 320  :     SHVBLOCK     RxVarBlock;   // Shared Variable Request Block
; 321  :     HR_REXXRC_T  RexxRC;       // Rexx API return code
; 322  : 
; 323  :     RxVarBlock.shvcode  =  RXSHV_SYFET;     // FETCH

  00011	c6 84 24 98 00
	00 00 04	 mov	 BYTE PTR RxVarBlock$[rsp+48], 4

; 324  :     RxVarBlock.shvret   =  RXSHV_OK;

  00019	c6 84 24 99 00
	00 00 00	 mov	 BYTE PTR RxVarBlock$[rsp+49], 0

; 325  :     RxVarBlock.shvnext  =  NULL;

  00021	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR RxVarBlock$[rsp], 0
$LN4@FetchVar:

; 326  : 
; 327  :     /* Set 'shvvalue' to RXNULLSTRING so Rexx does allocation */
; 328  : 
; 329  :     HMAKE_RXSTRING( RxVarBlock.shvname,  Name, strlen( Name ));

  0002a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR Name$[rsp]
  00032	48 89 44 24 78	 mov	 QWORD PTR RxVarBlock$[rsp+16], rax
  00037	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR Name$[rsp]
  0003f	e8 00 00 00 00	 call	 strlen
  00044	89 44 24 70	 mov	 DWORD PTR RxVarBlock$[rsp+8], eax
  00048	33 c0		 xor	 eax, eax
  0004a	85 c0		 test	 eax, eax
  0004c	75 dc		 jne	 SHORT $LN4@FetchVar
$LN7@FetchVar:

; 330  :     HMAKE_RXSTRING( RxVarBlock.shvvalue, NULL,    0          );

  0004e	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR RxVarBlock$[rsp+32], 0
  0005a	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR RxVarBlock$[rsp+24], 0
  00065	33 c0		 xor	 eax, eax
  00067	85 c0		 test	 eax, eax
  00069	75 e3		 jne	 SHORT $LN7@FetchVar

; 331  : 
; 332  :     RxVarBlock.shvnamelen  = RxVarBlock.shvname.strlength;

  0006b	8b 44 24 70	 mov	 eax, DWORD PTR RxVarBlock$[rsp+8]
  0006f	89 84 24 90 00
	00 00		 mov	 DWORD PTR RxVarBlock$[rsp+40], eax

; 333  :     RxVarBlock.shvvaluelen = RxVarBlock.shvvalue.strlength;

  00076	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR RxVarBlock$[rsp+24]
  0007d	89 84 24 94 00
	00 00		 mov	 DWORD PTR RxVarBlock$[rsp+44], eax

; 334  : 
; 335  :     /* Retrieve the variable */
; 336  :     RexxRC = VariablePool( &RxVarBlock );

  00084	48 8d 4c 24 68	 lea	 rcx, QWORD PTR RxVarBlock$[rsp]
  00089	e8 00 00 00 00	 call	 VariablePool
  0008e	89 44 24 60	 mov	 DWORD PTR RexxRC$[rsp], eax

; 337  : 
; 338  :     /* Check for error */
; 339  :     if (RexxRC != RXSHV_OK)

  00092	83 7c 24 60 00	 cmp	 DWORD PTR RexxRC$[rsp], 0
  00097	0f 84 9e 00 00
	00		 je	 $LN8@FetchVar

; 340  :     {
; 341  :         if (MLVL( DEBUG ))

  0009d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000a4	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  000aa	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  000af	85 c0		 test	 eax, eax
  000b1	74 73		 je	 SHORT $LN9@FetchVar

; 342  :         {
; 343  :             // "REXX(%s) %s: return code 0x%8.8"PRIX32" from %s"
; 344  :             WRMSG( HHC17512, "D", REXX_DEP( PackageName ),

  000b3	b9 01 00 00 00	 mov	 ecx, 1
  000b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159610
  000c5	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000ca	8b 4c 24 60	 mov	 ecx, DWORD PTR RexxRC$[rsp]
  000ce	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  000d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159611
  000d9	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ReginaPackageName
  000e5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159612
  000f1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159613
  000fd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00102	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00107	41 b9 03 00 00
	00		 mov	 r9d, 3
  0010d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159614
  00114	ba 5a 01 00 00	 mov	 edx, 346		; 0000015aH
  00119	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159615
  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@FetchVar:

; 345  :                 "FetchVar", (U32) RexxRC,
; 346  :                 QSTR( REXX_DEP( VariablePool )));
; 347  :         }
; 348  :         *Value = NULL;

  00126	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR Value$[rsp]
  0012e	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 349  :         return RexxRC;

  00135	8b 44 24 60	 mov	 eax, DWORD PTR RexxRC$[rsp]
  00139	eb 3f		 jmp	 SHORT $LN1@FetchVar
$LN8@FetchVar:

; 350  :     }
; 351  : 
; 352  :     /* Return a copy of the variable's value to the caller.
; 353  :        Caller is responsible for eventually calling free().
; 354  :        If the variable isn't found RxVarBlock.shvvalue will
; 355  :        simply be a RXNULLSTRING (RxVarBlock.shvvalue.strptr
; 356  :        NULL and RxVarBlock.shvvalue.strlength=0).  In such
; 357  :        situations rx_strdup() function simply returns NULL.
; 358  :     */
; 359  :     *Value = rx_strdup( &RxVarBlock.shvvalue );

  0013b	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR RxVarBlock$[rsp+24]
  00143	e8 00 00 00 00	 call	 rx_strdup
  00148	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR Value$[rsp]
  00150	48 89 01	 mov	 QWORD PTR [rcx], rax

; 360  : 
; 361  :     /* Rexx string no longer needed. Free it to prevent leak. */
; 362  :     if (RXVALIDSTRING( RxVarBlock.shvvalue ))

  00153	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR RxVarBlock$[rsp+32], 0
  0015c	74 18		 je	 SHORT $LN10@FetchVar
  0015e	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR RxVarBlock$[rsp+24], 0
  00166	74 0e		 je	 SHORT $LN10@FetchVar

; 363  :         REXX_DEP( FreeMemory )( RxVarBlock.shvvalue.strptr );

  00168	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR RxVarBlock$[rsp+32]
  00170	ff 15 00 00 00
	00		 call	 QWORD PTR ReginaFreeMemory
$LN10@FetchVar:

; 364  : 
; 365  :     return RexxRC;

  00176	8b 44 24 60	 mov	 eax, DWORD PTR RexxRC$[rsp]
$LN1@FetchVar:

; 366  : }

  0017a	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00181	c3		 ret	 0
FetchVar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
RexxRC$ = 96
RxVarBlock$ = 104
Name$ = 176
DropVar	PROC

; 278  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 279  :     SHVBLOCK     RxVarBlock;    // Shared Variable Request Block
; 280  :     HR_REXXRC_T  RexxRC;        // Rexx API return code
; 281  : 
; 282  :     RxVarBlock.shvcode  =  RXSHV_SYDRO;     // DROP

  0000c	c6 84 24 98 00
	00 00 05	 mov	 BYTE PTR RxVarBlock$[rsp+48], 5

; 283  :     RxVarBlock.shvret   =  RXSHV_OK;

  00014	c6 84 24 99 00
	00 00 00	 mov	 BYTE PTR RxVarBlock$[rsp+49], 0

; 284  :     RxVarBlock.shvnext  =  NULL;

  0001c	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR RxVarBlock$[rsp], 0
$LN4@DropVar:

; 285  : 
; 286  :     HMAKE_RXSTRING( RxVarBlock.shvname, Name, strlen( Name ));

  00025	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR Name$[rsp]
  0002d	48 89 44 24 78	 mov	 QWORD PTR RxVarBlock$[rsp+16], rax
  00032	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR Name$[rsp]
  0003a	e8 00 00 00 00	 call	 strlen
  0003f	89 44 24 70	 mov	 DWORD PTR RxVarBlock$[rsp+8], eax
  00043	33 c0		 xor	 eax, eax
  00045	85 c0		 test	 eax, eax
  00047	75 dc		 jne	 SHORT $LN4@DropVar

; 287  : 
; 288  :     RxVarBlock.shvnamelen = RxVarBlock.shvname.strlength;

  00049	8b 44 24 70	 mov	 eax, DWORD PTR RxVarBlock$[rsp+8]
  0004d	89 84 24 90 00
	00 00		 mov	 DWORD PTR RxVarBlock$[rsp+40], eax

; 289  : 
; 290  :     /* Drop the variable */
; 291  :     RexxRC = VariablePool( &RxVarBlock );

  00054	48 8d 4c 24 68	 lea	 rcx, QWORD PTR RxVarBlock$[rsp]
  00059	e8 00 00 00 00	 call	 VariablePool
  0005e	89 44 24 60	 mov	 DWORD PTR RexxRC$[rsp], eax

; 292  : 
; 293  :     /* If the variable we wanted to delete didn't (doesn't) exist,
; 294  :        then it's not really an error. Our objective was achieved.
; 295  :     */
; 296  :     if (RexxRC == RXSHV_BADN)   // (if variable didn't exist before)

  00062	83 7c 24 60 08	 cmp	 DWORD PTR RexxRC$[rsp], 8
  00067	75 08		 jne	 SHORT $LN5@DropVar

; 297  :         RexxRC =  RXSHV_OK;     // (then our objective was achieved)

  00069	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR RexxRC$[rsp], 0
$LN5@DropVar:

; 298  : 
; 299  :     /* Check for error */
; 300  :     if (RexxRC != RXSHV_OK && MLVL( DEBUG ))

  00071	83 7c 24 60 00	 cmp	 DWORD PTR RexxRC$[rsp], 0
  00076	0f 84 89 00 00
	00		 je	 $LN6@DropVar
  0007c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00083	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  00089	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0008e	85 c0		 test	 eax, eax
  00090	74 73		 je	 SHORT $LN6@DropVar

; 301  :     {
; 302  :         // "REXX(%s) %s: return code 0x%8.8"PRIX32" from %s"
; 303  :         WRMSG( HHC17512, "D", REXX_DEP( PackageName ),

  00092	b9 01 00 00 00	 mov	 ecx, 1
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159584
  000a4	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000a9	8b 4c 24 60	 mov	 ecx, DWORD PTR RexxRC$[rsp]
  000ad	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  000b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159585
  000b8	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000bd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ReginaPackageName
  000c4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159586
  000d0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159587
  000dc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e6	41 b9 03 00 00
	00		 mov	 r9d, 3
  000ec	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159588
  000f3	ba 31 01 00 00	 mov	 edx, 305		; 00000131H
  000f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159589
  000ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN6@DropVar:

; 304  :             "DropVar", (U32) RexxRC,
; 305  :             QSTR( REXX_DEP( VariablePool )));
; 306  :     }
; 307  : 
; 308  :     return RexxRC;

  00105	8b 44 24 60	 mov	 eax, DWORD PTR RexxRC$[rsp]

; 309  : }

  00109	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00110	c3		 ret	 0
DropVar	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
RexxRC$ = 96
RxVarBlock$ = 104
Name$ = 176
Value$ = 184
SetVar	PROC

; 235  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 236  :     SHVBLOCK     RxVarBlock;    // Shared Variable Request Block
; 237  :     HR_REXXRC_T  RexxRC;        // Rexx API return code
; 238  : 
; 239  :     RxVarBlock.shvcode  =  RXSHV_SYSET;     // SET

  00011	c6 84 24 98 00
	00 00 03	 mov	 BYTE PTR RxVarBlock$[rsp+48], 3

; 240  :     RxVarBlock.shvret   =  RXSHV_OK;

  00019	c6 84 24 99 00
	00 00 00	 mov	 BYTE PTR RxVarBlock$[rsp+49], 0

; 241  :     RxVarBlock.shvnext  =  NULL;

  00021	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR RxVarBlock$[rsp], 0
$LN4@SetVar:

; 242  : 
; 243  :     HMAKE_RXSTRING( RxVarBlock.shvname,  Name,  strlen( Name  ));

  0002a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR Name$[rsp]
  00032	48 89 44 24 78	 mov	 QWORD PTR RxVarBlock$[rsp+16], rax
  00037	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR Name$[rsp]
  0003f	e8 00 00 00 00	 call	 strlen
  00044	89 44 24 70	 mov	 DWORD PTR RxVarBlock$[rsp+8], eax
  00048	33 c0		 xor	 eax, eax
  0004a	85 c0		 test	 eax, eax
  0004c	75 dc		 jne	 SHORT $LN4@SetVar
$LN7@SetVar:

; 244  :     HMAKE_RXSTRING( RxVarBlock.shvvalue, Value, strlen( Value ));

  0004e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR Value$[rsp]
  00056	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR RxVarBlock$[rsp+32], rax
  0005e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR Value$[rsp]
  00066	e8 00 00 00 00	 call	 strlen
  0006b	89 84 24 80 00
	00 00		 mov	 DWORD PTR RxVarBlock$[rsp+24], eax
  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 d6		 jne	 SHORT $LN7@SetVar

; 245  : 
; 246  :     RxVarBlock.shvnamelen  = RxVarBlock.shvname.strlength;

  00078	8b 44 24 70	 mov	 eax, DWORD PTR RxVarBlock$[rsp+8]
  0007c	89 84 24 90 00
	00 00		 mov	 DWORD PTR RxVarBlock$[rsp+40], eax

; 247  :     RxVarBlock.shvvaluelen = RxVarBlock.shvvalue.strlength;

  00083	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR RxVarBlock$[rsp+24]
  0008a	89 84 24 94 00
	00 00		 mov	 DWORD PTR RxVarBlock$[rsp+44], eax

; 248  : 
; 249  :     /* Create or update the variable */
; 250  :     RexxRC = VariablePool( &RxVarBlock );

  00091	48 8d 4c 24 68	 lea	 rcx, QWORD PTR RxVarBlock$[rsp]
  00096	e8 00 00 00 00	 call	 VariablePool
  0009b	89 44 24 60	 mov	 DWORD PTR RexxRC$[rsp], eax

; 251  : 
; 252  :     /* If the variable we wanted to update didn't exist before our
; 253  :        call (but was successfully created as a result of our call),
; 254  :        then it's not really an error. Our objective was achieved.
; 255  :     */
; 256  :     if (RexxRC == RXSHV_NEWV)   // (if variable was newly created)

  0009f	83 7c 24 60 01	 cmp	 DWORD PTR RexxRC$[rsp], 1
  000a4	75 08		 jne	 SHORT $LN8@SetVar

; 257  :         RexxRC =  RXSHV_OK;     // (then we condider that success)

  000a6	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR RexxRC$[rsp], 0
$LN8@SetVar:

; 258  : 
; 259  :     /* Check for error */
; 260  :     if (RexxRC != RXSHV_OK && MLVL( DEBUG ))

  000ae	83 7c 24 60 00	 cmp	 DWORD PTR RexxRC$[rsp], 0
  000b3	0f 84 89 00 00
	00		 je	 $LN9@SetVar
  000b9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000c0	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  000c6	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  000cb	85 c0		 test	 eax, eax
  000cd	74 73		 je	 SHORT $LN9@SetVar

; 261  :     {
; 262  :         // "REXX(%s) %s: return code 0x%8.8"PRIX32" from %s"
; 263  :         WRMSG( HHC17512, "D", REXX_DEP( PackageName ),

  000cf	b9 01 00 00 00	 mov	 ecx, 1
  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159565
  000e1	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000e6	8b 4c 24 60	 mov	 ecx, DWORD PTR RexxRC$[rsp]
  000ea	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159566
  000f5	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ReginaPackageName
  00101	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00106	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159567
  0010d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00112	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159568
  00119	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0011e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00123	41 b9 03 00 00
	00		 mov	 r9d, 3
  00129	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159569
  00130	ba 09 01 00 00	 mov	 edx, 265		; 00000109H
  00135	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159570
  0013c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@SetVar:

; 264  :             "SetVar", (U32) RexxRC,
; 265  :             QSTR( REXX_DEP( VariablePool )));
; 266  :     }
; 267  : 
; 268  :     return RexxRC;

  00142	8b 44 24 60	 mov	 eax, DWORD PTR RexxRC$[rsp]

; 269  : }

  00146	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0014d	c3		 ret	 0
SetVar	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
rc$ = 32
pShvBlock$ = 64
VariablePool PROC

; 216  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 217  :     /* PROGRAMMING NOTE: calling Rexx's VariablePool function is
; 218  :        made a separate function unto itself to make it easier to
; 219  :        debug every call made to VariablePool without having to set
; 220  :        many separate breakpoints all over the place.
; 221  :     */
; 222  :     HR_REXXRC_T  rc;
; 223  :     rc = REXX_DEP( VariablePool )( pShvBlock );

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pShvBlock$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR ReginaVariablePool
  00014	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 224  :     return rc;

  00018	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 225  : }

  0001c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00020	c3		 ret	 0
VariablePool ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
dup$ = 32
prx$ = 64
rx_strdup PROC

; 191  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 192  :     /* PROGRAMMING NOTE: this function exists because Rexx strings
; 193  :        are NOT necessarily NULL terminated. Thus a simple strdup()
; 194  :        should NEVER be used on a Rexx RXSTRING string.
; 195  :     */
; 196  :     char* dup;
; 197  : 
; 198  :     /* Allocate room for copy of str + null terminator */
; 199  :     if (0
; 200  :         || !prx
; 201  :         || !RXVALIDSTRING( *prx )
; 202  :         || !(dup = malloc( prx->strlength + 1 ))

  00009	33 c0		 xor	 eax, eax
  0000b	85 c0		 test	 eax, eax
  0000d	75 3e		 jne	 SHORT $LN3@rx_strdup
  0000f	48 83 7c 24 40
	00		 cmp	 QWORD PTR prx$[rsp], 0
  00015	74 36		 je	 SHORT $LN3@rx_strdup
  00017	48 8b 44 24 40	 mov	 rax, QWORD PTR prx$[rsp]
  0001c	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00021	74 2a		 je	 SHORT $LN3@rx_strdup
  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR prx$[rsp]
  00028	83 38 00	 cmp	 DWORD PTR [rax], 0
  0002b	74 20		 je	 SHORT $LN3@rx_strdup
  0002d	48 8b 44 24 40	 mov	 rax, QWORD PTR prx$[rsp]
  00032	8b 00		 mov	 eax, DWORD PTR [rax]
  00034	ff c0		 inc	 eax
  00036	8b c0		 mov	 eax, eax
  00038	8b c8		 mov	 ecx, eax
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00040	48 89 44 24 20	 mov	 QWORD PTR dup$[rsp], rax
  00045	48 83 7c 24 20
	00		 cmp	 QWORD PTR dup$[rsp], 0
  0004b	75 04		 jne	 SHORT $LN2@rx_strdup
$LN3@rx_strdup:

; 203  :     )
; 204  :         return NULL;

  0004d	33 c0		 xor	 eax, eax
  0004f	eb 27		 jmp	 SHORT $LN1@rx_strdup
$LN2@rx_strdup:

; 205  : 
; 206  :     /* Copy string to buffer and null terminate */
; 207  :     strlcpy( dup, prx->strptr, prx->strlength + 1 );

  00051	48 8b 44 24 40	 mov	 rax, QWORD PTR prx$[rsp]
  00056	8b 00		 mov	 eax, DWORD PTR [rax]
  00058	ff c0		 inc	 eax
  0005a	8b c0		 mov	 eax, eax
  0005c	44 8b c0	 mov	 r8d, eax
  0005f	48 8b 44 24 40	 mov	 rax, QWORD PTR prx$[rsp]
  00064	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00068	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dup$[rsp]
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 208  : 
; 209  :     return dup;

  00073	48 8b 44 24 20	 mov	 rax, QWORD PTR dup$[rsp]
$LN1@rx_strdup:

; 210  : }

  00078	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007c	c3		 ret	 0
rx_strdup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
len$ = 96
tv95 = 100
vargs$ = 104
tv92 = 112
prx$ = 144
fmt$ = 152
rx_sprintf PROC

; 141  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 142  :     HR_MEMSIZE_T  len;
; 143  :     va_list       vargs;
; 144  : 
; 145  :     static const HR_MEMSIZE_T maxlen = (64 * 1024);     // (64K)
; 146  : 
; 147  :     len = 0;

  0001b	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0

; 148  :     va_start( vargs, fmt );

  00023	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0002b	48 89 44 24 68	 mov	 QWORD PTR vargs$[rsp], rax

; 149  : 
; 150  :     if (RXVALIDSTRING( *prx ))

  00030	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR prx$[rsp]
  00038	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0003d	74 3c		 je	 SHORT $LN5@rx_sprintf
  0003f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR prx$[rsp]
  00047	83 38 00	 cmp	 DWORD PTR [rax], 0
  0004a	74 2f		 je	 SHORT $LN5@rx_sprintf

; 151  :         len = vsnprintf( prx->strptr, prx->strlength, fmt, vargs );

  0004c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR prx$[rsp]
  00054	8b 00		 mov	 eax, DWORD PTR [rax]
  00056	4c 8b 4c 24 68	 mov	 r9, QWORD PTR vargs$[rsp]
  0005b	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR fmt$[rsp]
  00063	8b d0		 mov	 edx, eax
  00065	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR prx$[rsp]
  0006d	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_vsnprintf
  00077	89 44 24 60	 mov	 DWORD PTR len$[rsp], eax
$LN5@rx_sprintf:

; 152  : 
; 153  :     /* PROGRAMMING NOTE: we use '>=' comparison to ensure there
; 154  :        will always be room for a terminating NULL, even though
; 155  :        RXSTRING strings are never necessarily null terminated.
; 156  :     */
; 157  :     if (!RXVALIDSTRING( *prx ) || len >= prx->strlength)

  0007b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR prx$[rsp]
  00083	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00088	74 21		 je	 SHORT $LN7@rx_sprintf
  0008a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR prx$[rsp]
  00092	83 38 00	 cmp	 DWORD PTR [rax], 0
  00095	74 14		 je	 SHORT $LN7@rx_sprintf
  00097	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR prx$[rsp]
  0009f	8b 00		 mov	 eax, DWORD PTR [rax]
  000a1	39 44 24 60	 cmp	 DWORD PTR len$[rsp], eax
  000a5	0f 82 5f 01 00
	00		 jb	 $LN6@rx_sprintf
$LN7@rx_sprintf:
$LN4@rx_sprintf:

; 158  :     {
; 159  :         do
; 160  :         {
; 161  :             if (RXVALIDSTRING( *prx ))

  000ab	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR prx$[rsp]
  000b3	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000b8	74 1f		 je	 SHORT $LN8@rx_sprintf
  000ba	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR prx$[rsp]
  000c2	83 38 00	 cmp	 DWORD PTR [rax], 0
  000c5	74 12		 je	 SHORT $LN8@rx_sprintf

; 162  :                 REXX_DEP( FreeMemory )( prx->strptr );

  000c7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR prx$[rsp]
  000cf	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000d3	ff 15 00 00 00
	00		 call	 QWORD PTR ReginaFreeMemory
$LN8@rx_sprintf:

; 163  : 
; 164  :             if (!(prx->strptr = REXX_DEP( AllocateMemory )( prx->strlength += DEF_RXSTRING_BUFSZ )))

  000d9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR prx$[rsp]
  000e1	8b 00		 mov	 eax, DWORD PTR [rax]
  000e3	05 00 01 00 00	 add	 eax, 256		; 00000100H
  000e8	89 44 24 64	 mov	 DWORD PTR tv95[rsp], eax
  000ec	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR prx$[rsp]
  000f4	8b 4c 24 64	 mov	 ecx, DWORD PTR tv95[rsp]
  000f8	89 08		 mov	 DWORD PTR [rax], ecx
  000fa	8b 4c 24 64	 mov	 ecx, DWORD PTR tv95[rsp]
  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR ReginaAllocateMemory
  00104	48 89 44 24 70	 mov	 QWORD PTR tv92[rsp], rax
  00109	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR prx$[rsp]
  00111	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv92[rsp]
  00116	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  0011a	48 83 7c 24 70
	00		 cmp	 QWORD PTR tv92[rsp], 0
  00120	75 7d		 jne	 SHORT $LN9@rx_sprintf

; 165  :             {
; 166  :                 // "REXX(%s) %s: return code 0x%8.8"PRIX32" from %s"
; 167  :                 WRMSG( HHC17512, "E", REXX_DEP( PackageName ),

  00122	b9 01 00 00 00	 mov	 ecx, 1
  00127	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0012d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159526
  00134	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00139	c7 44 24 48 10
	00 00 00	 mov	 DWORD PTR [rsp+72], 16
  00141	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159527
  00148	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0014d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ReginaPackageName
  00154	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00159	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159528
  00160	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00165	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159529
  0016c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00171	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00176	41 b9 03 00 00
	00		 mov	 r9d, 3
  0017c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159530
  00183	ba a9 00 00 00	 mov	 edx, 169		; 000000a9H
  00188	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159531
  0018f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 168  :                     "rx_sprintf", (U32) RXSHV_MEMFL,
; 169  :                     QSTR( REXX_DEP( AllocateMemory )));
; 170  :                 len = 0; // (forced since strptr is now NULL)

  00195	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0

; 171  :                 break;

  0019d	eb 55		 jmp	 SHORT $LN3@rx_sprintf
$LN9@rx_sprintf:

; 172  :             }
; 173  : 
; 174  :             len = vsnprintf( prx->strptr, prx->strlength, fmt, vargs );

  0019f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR prx$[rsp]
  001a7	8b 00		 mov	 eax, DWORD PTR [rax]
  001a9	4c 8b 4c 24 68	 mov	 r9, QWORD PTR vargs$[rsp]
  001ae	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR fmt$[rsp]
  001b6	8b d0		 mov	 edx, eax
  001b8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR prx$[rsp]
  001c0	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  001c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_vsnprintf
  001ca	89 44 24 60	 mov	 DWORD PTR len$[rsp], eax

; 175  :         }
; 176  :         while (len >= prx->strlength && prx->strlength < maxlen);

  001ce	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR prx$[rsp]
  001d6	8b 00		 mov	 eax, DWORD PTR [rax]
  001d8	39 44 24 60	 cmp	 DWORD PTR len$[rsp], eax
  001dc	72 16		 jb	 SHORT $LN10@rx_sprintf
  001de	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR prx$[rsp]
  001e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?maxlen@?1??rx_sprintf@@9@9
  001ec	39 08		 cmp	 DWORD PTR [rax], ecx
  001ee	0f 82 b7 fe ff
	ff		 jb	 $LN4@rx_sprintf
$LN10@rx_sprintf:
$LN3@rx_sprintf:

; 177  : 
; 178  :         if (len > maxlen)   // (if we gave up due to max exceeded)

  001f4	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?maxlen@?1??rx_sprintf@@9@9
  001fa	39 44 24 60	 cmp	 DWORD PTR len$[rsp], eax
  001fe	76 0a		 jbe	 SHORT $LN11@rx_sprintf

; 179  :             len = maxlen;   // (then set final len to the maximum)

  00200	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?maxlen@?1??rx_sprintf@@9@9
  00206	89 44 24 60	 mov	 DWORD PTR len$[rsp], eax
$LN11@rx_sprintf:
$LN6@rx_sprintf:

; 180  :     }
; 181  : 
; 182  :     va_end( vargs );

  0020a	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR vargs$[rsp], 0

; 183  :     prx->strlength = len;

  00213	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR prx$[rsp]
  0021b	8b 4c 24 60	 mov	 ecx, DWORD PTR len$[rsp]
  0021f	89 08		 mov	 DWORD PTR [rax], ecx

; 184  :     return len;

  00221	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]

; 185  : }

  00225	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0022c	c3		 ret	 0
rx_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
rc$ = 96
RegisterRexxHandlersAndFunctions PROC

; 1162 : {

  00000	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1163 :     static  HR_USERINFO_T  user_info  = NULL;   // No extra info needed
; 1164 :             HR_REXXRC_T    rc;                  // Rexx API return code
; 1165 : 
; 1166 :     /* Register our Hercules Exit handler */
; 1167 :     rc = REXX_DEP( RegisterExit )

  00004	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR ?user_info@?1??RegisterRexxHandlersAndFunctions@@9@9
  0000b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ExitHandler
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160110
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR ReginaRegisterExit
  0001f	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 1168 :          ( "HERCSIOE", (HR_PFN_T) ExitHandler, user_info );
; 1169 : 
; 1170 :     if (rc != RXAPI_OK)

  00023	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  00028	74 7a		 je	 SHORT $LN2@RegisterRe

; 1171 :     {
; 1172 :         // "REXX(%s) %s: return code 0x%8.8"PRIX32" from %s"
; 1173 :         WRMSG( HHC17512, "E", REXX_DEP( PackageName ),

  0002a	b9 01 00 00 00	 mov	 ecx, 1
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160112
  0003c	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00041	8b 4c 24 60	 mov	 ecx, DWORD PTR rc$[rsp]
  00045	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160113
  00050	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00055	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ReginaPackageName
  0005c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160114
  00068	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160115
  00074	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00079	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00084	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160116
  0008b	ba 97 04 00 00	 mov	 edx, 1175		; 00000497H
  00090	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160117
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1174 :             "RegisterHandlers", (U32) rc,
; 1175 :             QSTR( REXX_DEP( RegisterExit )));
; 1176 :         return FALSE;

  0009d	32 c0		 xor	 al, al
  0009f	e9 38 01 00 00	 jmp	 $LN1@RegisterRe
$LN2@RegisterRe:

; 1177 :     }
; 1178 : 
; 1179 :     /* Register our Hercules SubCommand handler */
; 1180 :     rc = REXX_DEP( RegisterSubcom )

  000a4	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR ?user_info@?1??RegisterRexxHandlersAndFunctions@@9@9
  000ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:SubComHandler
  000b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160118
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR ReginaRegisterSubcom
  000bf	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 1181 :          ( "HERCULES", (HR_PFN_T) SubComHandler, user_info );
; 1182 : 
; 1183 :     if (rc != RXAPI_OK)

  000c3	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  000c8	74 7a		 je	 SHORT $LN3@RegisterRe

; 1184 :     {
; 1185 :         // "REXX(%s) %s: return code 0x%8.8"PRIX32" from %s"
; 1186 :         WRMSG( HHC17512, "E", REXX_DEP( PackageName ),

  000ca	b9 01 00 00 00	 mov	 ecx, 1
  000cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160120
  000dc	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000e1	8b 4c 24 60	 mov	 ecx, DWORD PTR rc$[rsp]
  000e5	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160121
  000f0	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000f5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ReginaPackageName
  000fc	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00101	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160122
  00108	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0010d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160123
  00114	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00119	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00124	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160124
  0012b	ba a4 04 00 00	 mov	 edx, 1188		; 000004a4H
  00130	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160125
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1187 :             "RegisterHandlers", (U32) rc,
; 1188 :             QSTR( REXX_DEP( RegisterSubcom )));
; 1189 :         return FALSE;

  0013d	32 c0		 xor	 al, al
  0013f	e9 98 00 00 00	 jmp	 $LN1@RegisterRe
$LN3@RegisterRe:

; 1190 :     }
; 1191 : 
; 1192 :     /* Register our Hercules 'AwsCmd' external function */
; 1193 :     rc = REXX_DEP( RegisterFunction )

  00144	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:AWSCmd
  0014b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160126
  00152	ff 15 00 00 00
	00		 call	 QWORD PTR ReginaRegisterFunction
  00158	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 1194 :          ( "AWSCMD", (HR_PFN_T) AWSCmd );
; 1195 : 
; 1196 :     if (rc != RXAPI_OK)

  0015c	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  00161	74 77		 je	 SHORT $LN4@RegisterRe

; 1197 :     {
; 1198 :         // "REXX(%s) %s: return code 0x%8.8"PRIX32" from %s"
; 1199 :         WRMSG( HHC17512, "E", REXX_DEP( PackageName ),

  00163	b9 01 00 00 00	 mov	 ecx, 1
  00168	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0016e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160128
  00175	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR rc$[rsp]
  0017e	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00182	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160129
  00189	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0018e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ReginaPackageName
  00195	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0019a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160130
  001a1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160131
  001ad	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001b2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b7	41 b9 03 00 00
	00		 mov	 r9d, 3
  001bd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160132
  001c4	ba b1 04 00 00	 mov	 edx, 1201		; 000004b1H
  001c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160133
  001d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1200 :             "RegisterFunctions", (U32) rc,
; 1201 :             QSTR( REXX_DEP( RegisterFunction )));
; 1202 :         return FALSE;

  001d6	32 c0		 xor	 al, al
  001d8	eb 02		 jmp	 SHORT $LN1@RegisterRe
$LN4@RegisterRe:

; 1203 :     }
; 1204 : 
; 1205 :     return TRUE;

  001da	b0 01		 mov	 al, 1
$LN1@RegisterRe:

; 1206 : }

  001dc	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001e0	c3		 ret	 0
RegisterRexxHandlersAndFunctions ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
RetUsr$ = 32
err$ = 36
panelrc$ = 40
rc$ = 44
tv174 = 48
herccmd$ = 56
stemname$ = 64
erropt$1 = 72
Name$ = 96
argc$ = 104
argv$ = 112
Queuename$ = 120
RetValue$ = 128
AWSCmd	PROC

; 778  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 779  :     HR_EXTFUNC_RC_T  rc         = RXFUNC_OK;

  00017	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 780  :     HR_ERR_T         err        = HRERR_OK;

  0001f	33 c0		 xor	 eax, eax
  00021	66 89 44 24 24	 mov	 WORD PTR err$[rsp], ax

; 781  :     char*            stemname   = NULL;

  00026	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR stemname$[rsp], 0

; 782  :     char*            herccmd    = NULL;

  0002f	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR herccmd$[rsp], 0

; 783  :     int              panelrc    = 0;

  00038	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR panelrc$[rsp], 0

; 784  :     BYTE             RetUsr     = TRUE;

  00040	c6 44 24 20 01	 mov	 BYTE PTR RetUsr$[rsp], 1
$LN4@AWSCmd:

; 785  : 
; 786  :     // argv[0] = (required) Hercules command to be issued
; 787  :     // argv[1] = (optional) Response stem variable name (empty = not
; 788  :     //                      interested in response, i.e. not wanted)
; 789  :     // argv[2] = (optional) Error Handling option (default = user)
; 790  : 
; 791  :     UNREFERENCED( Name );

  00045	33 c0		 xor	 eax, eax
  00047	85 c0		 test	 eax, eax
  00049	75 fa		 jne	 SHORT $LN4@AWSCmd
$LN7@AWSCmd:

; 792  :     UNREFERENCED( Queuename );

  0004b	33 c0		 xor	 eax, eax
  0004d	85 c0		 test	 eax, eax
  0004f	75 fa		 jne	 SHORT $LN7@AWSCmd

; 793  : 
; 794  :     /* Need at least 1 argument: the Hercules command to be issued. */
; 795  :     if (0
; 796  :         || argc < 1
; 797  :         || argc > 3
; 798  :         || !RXVALIDSTRING( argv[0] )

  00051	33 c0		 xor	 eax, eax
  00053	85 c0		 test	 eax, eax
  00055	75 38		 jne	 SHORT $LN15@AWSCmd
  00057	83 7c 24 68 01	 cmp	 DWORD PTR argc$[rsp], 1
  0005c	7c 31		 jl	 SHORT $LN15@AWSCmd
  0005e	83 7c 24 68 03	 cmp	 DWORD PTR argc$[rsp], 3
  00063	7f 2a		 jg	 SHORT $LN15@AWSCmd
  00065	b8 10 00 00 00	 mov	 eax, 16
  0006a	48 6b c0 00	 imul	 rax, rax, 0
  0006e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR argv$[rsp]
  00073	48 83 7c 01 08
	00		 cmp	 QWORD PTR [rcx+rax+8], 0
  00079	74 14		 je	 SHORT $LN16@AWSCmd
  0007b	b8 10 00 00 00	 mov	 eax, 16
  00080	48 6b c0 00	 imul	 rax, rax, 0
  00084	48 8b 4c 24 70	 mov	 rcx, QWORD PTR argv$[rsp]
  00089	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  0008d	75 0f		 jne	 SHORT $LN14@AWSCmd
$LN16@AWSCmd:
$LN15@AWSCmd:

; 799  :     )
; 800  :     {
; 801  :         err = HRERR_BADARGS;

  0008f	b8 e9 03 00 00	 mov	 eax, 1001		; 000003e9H
  00094	66 89 44 24 24	 mov	 WORD PTR err$[rsp], ax

; 802  :         goto quick_exit;

  00099	e9 b7 01 00 00	 jmp	 $quick_exit$31
$LN14@AWSCmd:

; 803  :     }
; 804  : 
; 805  :     /* Make a modifiable copy of the Hercules command to be executed */
; 806  :     if (!(herccmd = rx_strdup( (PCRXSTRING) &argv[0] )))

  0009e	b8 10 00 00 00	 mov	 eax, 16
  000a3	48 6b c0 00	 imul	 rax, rax, 0
  000a7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR argv$[rsp]
  000ac	48 03 c8	 add	 rcx, rax
  000af	48 8b c1	 mov	 rax, rcx
  000b2	48 8b c8	 mov	 rcx, rax
  000b5	e8 00 00 00 00	 call	 rx_strdup
  000ba	48 89 44 24 38	 mov	 QWORD PTR herccmd$[rsp], rax
  000bf	48 83 7c 24 38
	00		 cmp	 QWORD PTR herccmd$[rsp], 0
  000c5	75 0f		 jne	 SHORT $LN17@AWSCmd

; 807  :     {
; 808  :         err = HRERR_NOMEM;

  000c7	b8 ea 03 00 00	 mov	 eax, 1002		; 000003eaH
  000cc	66 89 44 24 24	 mov	 WORD PTR err$[rsp], ax

; 809  :         goto quick_exit;

  000d1	e9 7f 01 00 00	 jmp	 $quick_exit$31
$LN17@AWSCmd:

; 810  :     }
; 811  : 
; 812  :     if (argc >= 2)

  000d6	83 7c 24 68 02	 cmp	 DWORD PTR argc$[rsp], 2
  000db	0f 8c 5b 01 00
	00		 jl	 $LN18@AWSCmd

; 813  :     {
; 814  :         /* Save the stem name to be used to return their results in */
; 815  :         if (RXVALIDSTRING( argv[1] ))

  000e1	b8 10 00 00 00	 mov	 eax, 16
  000e6	48 6b c0 01	 imul	 rax, rax, 1
  000ea	48 8b 4c 24 70	 mov	 rcx, QWORD PTR argv$[rsp]
  000ef	48 83 7c 01 08
	00		 cmp	 QWORD PTR [rcx+rax+8], 0
  000f5	74 4c		 je	 SHORT $LN19@AWSCmd
  000f7	b8 10 00 00 00	 mov	 eax, 16
  000fc	48 6b c0 01	 imul	 rax, rax, 1
  00100	48 8b 4c 24 70	 mov	 rcx, QWORD PTR argv$[rsp]
  00105	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  00109	74 38		 je	 SHORT $LN19@AWSCmd

; 816  :         {
; 817  :             if (!(stemname = rx_strdup( (PCRXSTRING) &argv[1] )))

  0010b	b8 10 00 00 00	 mov	 eax, 16
  00110	48 6b c0 01	 imul	 rax, rax, 1
  00114	48 8b 4c 24 70	 mov	 rcx, QWORD PTR argv$[rsp]
  00119	48 03 c8	 add	 rcx, rax
  0011c	48 8b c1	 mov	 rax, rcx
  0011f	48 8b c8	 mov	 rcx, rax
  00122	e8 00 00 00 00	 call	 rx_strdup
  00127	48 89 44 24 40	 mov	 QWORD PTR stemname$[rsp], rax
  0012c	48 83 7c 24 40
	00		 cmp	 QWORD PTR stemname$[rsp], 0
  00132	75 0f		 jne	 SHORT $LN20@AWSCmd

; 818  :             {
; 819  :                 err = HRERR_NOMEM;

  00134	b8 ea 03 00 00	 mov	 eax, 1002		; 000003eaH
  00139	66 89 44 24 24	 mov	 WORD PTR err$[rsp], ax

; 820  :                 goto quick_exit;

  0013e	e9 12 01 00 00	 jmp	 $quick_exit$31
$LN20@AWSCmd:
$LN19@AWSCmd:

; 821  :             }
; 822  :         }
; 823  : 
; 824  :         /* Check if they specified an error handling option */
; 825  :         if (argc >= 3)

  00143	83 7c 24 68 03	 cmp	 DWORD PTR argc$[rsp], 3
  00148	0f 8c ee 00 00
	00		 jl	 $LN21@AWSCmd
$LN10@AWSCmd:

; 826  :         {
; 827  :             ASSERT( argc == 3 );

  0014e	83 7c 24 68 03	 cmp	 DWORD PTR argc$[rsp], 3
  00153	74 5c		 je	 SHORT $LN22@AWSCmd
$LN13@AWSCmd:
  00155	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159900
  0015c	41 b8 3b 03 00
	00		 mov	 r8d, 827		; 0000033bH
  00162	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159901
  00169	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159902
  00170	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00176	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0017c	85 c0		 test	 eax, eax
  0017e	74 20		 je	 SHORT $LN23@AWSCmd
  00180	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159904
  00187	41 b8 3b 03 00
	00		 mov	 r8d, 827		; 0000033bH
  0018d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159905
  00194	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159906
  0019b	e8 00 00 00 00	 call	 DebuggerTrace
$LN23@AWSCmd:
  001a0	33 c0		 xor	 eax, eax
  001a2	85 c0		 test	 eax, eax
  001a4	75 af		 jne	 SHORT $LN13@AWSCmd
  001a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001ac	85 c0		 test	 eax, eax
  001ae	74 01		 je	 SHORT $LN24@AWSCmd
  001b0	cc		 int	 3
$LN24@AWSCmd:
$LN22@AWSCmd:
  001b1	33 c0		 xor	 eax, eax
  001b3	85 c0		 test	 eax, eax
  001b5	75 97		 jne	 SHORT $LN10@AWSCmd

; 828  : 
; 829  :             if (RXVALIDSTRING( argv[2] ))

  001b7	b8 10 00 00 00	 mov	 eax, 16
  001bc	48 6b c0 02	 imul	 rax, rax, 2
  001c0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR argv$[rsp]
  001c5	48 83 7c 01 08
	00		 cmp	 QWORD PTR [rcx+rax+8], 0
  001cb	74 6f		 je	 SHORT $LN25@AWSCmd
  001cd	b8 10 00 00 00	 mov	 eax, 16
  001d2	48 6b c0 02	 imul	 rax, rax, 2
  001d6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR argv$[rsp]
  001db	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  001df	74 5b		 je	 SHORT $LN25@AWSCmd

; 830  :             {
; 831  :                 /* PROGRAMMING NOTE: Rexx strings are NOT necessarily
; 832  :                    null terminated. Thus we cannot directly compare a
; 833  :                    Rexx string using e.g. strcasecmp(). We must make
; 834  :                    a careful copy of the string instead and use that.
; 835  :                 */
; 836  :                 char* erropt;
; 837  : 
; 838  :                 if (!(erropt = rx_strdup( (PCRXSTRING) &argv[2] )))

  001e1	b8 10 00 00 00	 mov	 eax, 16
  001e6	48 6b c0 02	 imul	 rax, rax, 2
  001ea	48 8b 4c 24 70	 mov	 rcx, QWORD PTR argv$[rsp]
  001ef	48 03 c8	 add	 rcx, rax
  001f2	48 8b c1	 mov	 rax, rcx
  001f5	48 8b c8	 mov	 rcx, rax
  001f8	e8 00 00 00 00	 call	 rx_strdup
  001fd	48 89 44 24 48	 mov	 QWORD PTR erropt$1[rsp], rax
  00202	48 83 7c 24 48
	00		 cmp	 QWORD PTR erropt$1[rsp], 0
  00208	75 0c		 jne	 SHORT $LN26@AWSCmd

; 839  :                 {
; 840  :                     err = HRERR_NOMEM;

  0020a	b8 ea 03 00 00	 mov	 eax, 1002		; 000003eaH
  0020f	66 89 44 24 24	 mov	 WORD PTR err$[rsp], ax

; 841  :                     goto quick_exit;

  00214	eb 3f		 jmp	 SHORT $quick_exit$31
$LN26@AWSCmd:

; 842  :                 }
; 843  : 
; 844  :                 if (strcasecmp( erropt, "system" ) == 0)

  00216	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159911
  0021d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR erropt$1[rsp]
  00222	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00228	85 c0		 test	 eax, eax
  0022a	75 05		 jne	 SHORT $LN27@AWSCmd

; 845  :                     RetUsr = FALSE;

  0022c	c6 44 24 20 00	 mov	 BYTE PTR RetUsr$[rsp], 0
$LN27@AWSCmd:

; 846  : 
; 847  :                 free( erropt );

  00231	48 8b 4c 24 48	 mov	 rcx, QWORD PTR erropt$1[rsp]
  00236	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN25@AWSCmd:
$LN21@AWSCmd:
$LN18@AWSCmd:

; 848  :             }
; 849  :         }
; 850  :     }
; 851  : 
; 852  :     /* Issue the Hercules command and save the results */
; 853  :     err = HerculesCommand( herccmd, stemname, &panelrc );

  0023c	4c 8d 44 24 28	 lea	 r8, QWORD PTR panelrc$[rsp]
  00241	48 8b 54 24 40	 mov	 rdx, QWORD PTR stemname$[rsp]
  00246	48 8b 4c 24 38	 mov	 rcx, QWORD PTR herccmd$[rsp]
  0024b	e8 00 00 00 00	 call	 HerculesCommand
  00250	66 89 44 24 24	 mov	 WORD PTR err$[rsp], ax
$quick_exit$31:

; 854  : 
; 855  : quick_exit:
; 856  : 
; 857  :     /* Free acquired storage */
; 858  :     free( herccmd );

  00255	48 8b 4c 24 38	 mov	 rcx, QWORD PTR herccmd$[rsp]
  0025a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 859  :     free( stemname );

  00260	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stemname$[rsp]
  00265	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 860  : 
; 861  :     /* Return from External Function */
; 862  :     rc = ExtFuncRC( err, panelrc, RetValue );

  0026b	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR RetValue$[rsp]
  00273	8b 54 24 28	 mov	 edx, DWORD PTR panelrc$[rsp]
  00277	0f b7 4c 24 24	 movzx	 ecx, WORD PTR err$[rsp]
  0027c	e8 00 00 00 00	 call	 ExtFuncRC
  00281	89 44 24 2c	 mov	 DWORD PTR rc$[rsp], eax

; 863  : 
; 864  :     // Return to Rexx
; 865  :     return RetUsr ? RXFUNC_OK : rc;

  00285	0f b6 44 24 20	 movzx	 eax, BYTE PTR RetUsr$[rsp]
  0028a	85 c0		 test	 eax, eax
  0028c	74 0a		 je	 SHORT $LN29@AWSCmd
  0028e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
  00296	eb 08		 jmp	 SHORT $LN30@AWSCmd
$LN29@AWSCmd:
  00298	8b 44 24 2c	 mov	 eax, DWORD PTR rc$[rsp]
  0029c	89 44 24 30	 mov	 DWORD PTR tv174[rsp], eax
$LN30@AWSCmd:
  002a0	8b 44 24 30	 mov	 eax, DWORD PTR tv174[rsp]

; 866  : }

  002a4	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002a8	c3		 ret	 0
AWSCmd	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
RetUsr$ = 32
err$ = 36
panelrc$ = 40
rc$ = 44
tv154 = 48
stemname$ = 56
herccmd$ = 64
erropt$1 = 72
Command$ = 96
Flags$ = 104
RetValue$ = 112
SubComHandler PROC

; 697  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 698  :     HR_SUBCOM_RC_T   rc         = RXSUBCOM_OK;

  00013	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 699  :     HR_ERR_T         err        = HRERR_OK;

  0001b	33 c0		 xor	 eax, eax
  0001d	66 89 44 24 24	 mov	 WORD PTR err$[rsp], ax

; 700  :     char*            stemname   = NULL;

  00022	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR stemname$[rsp], 0

; 701  :     char*            herccmd    = NULL;

  0002b	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR herccmd$[rsp], 0

; 702  :     int              panelrc    = 0;

  00034	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR panelrc$[rsp], 0

; 703  :     BYTE             RetUsr     = TRUE;

  0003c	c6 44 24 20 01	 mov	 BYTE PTR RetUsr$[rsp], 1

; 704  : 
; 705  :     /* Verify a Hercules command was passed to us */
; 706  :     if (!RXVALIDSTRING( *Command ))

  00041	48 8b 44 24 60	 mov	 rax, QWORD PTR Command$[rsp]
  00046	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0004b	74 0a		 je	 SHORT $LN3@SubComHand
  0004d	48 8b 44 24 60	 mov	 rax, QWORD PTR Command$[rsp]
  00052	83 38 00	 cmp	 DWORD PTR [rax], 0
  00055	75 0f		 jne	 SHORT $LN2@SubComHand
$LN3@SubComHand:

; 707  :     {
; 708  :         err = HRERR_BADARGS;

  00057	b8 e9 03 00 00	 mov	 eax, 1001		; 000003e9H
  0005c	66 89 44 24 24	 mov	 WORD PTR err$[rsp], ax

; 709  :         goto quick_exit;

  00061	e9 1d 01 00 00	 jmp	 $quick_exit$16
$LN2@SubComHand:

; 710  :     }
; 711  : 
; 712  :     /* Make a modifiable copy of the Hercules command to be executed */
; 713  :     if (!(herccmd = rx_strdup( Command )))

  00066	48 8b 4c 24 60	 mov	 rcx, QWORD PTR Command$[rsp]
  0006b	e8 00 00 00 00	 call	 rx_strdup
  00070	48 89 44 24 40	 mov	 QWORD PTR herccmd$[rsp], rax
  00075	48 83 7c 24 40
	00		 cmp	 QWORD PTR herccmd$[rsp], 0
  0007b	75 0f		 jne	 SHORT $LN4@SubComHand

; 714  :     {
; 715  :         err = HRERR_NOMEM;

  0007d	b8 ea 03 00 00	 mov	 eax, 1002		; 000003eaH
  00082	66 89 44 24 24	 mov	 WORD PTR err$[rsp], ax

; 716  :         goto quick_exit;

  00087	e9 f7 00 00 00	 jmp	 $quick_exit$16
$LN4@SubComHand:

; 717  :     }
; 718  : 
; 719  :     /* Examine the value of our errorhandler variable to see if
; 720  :        the user wants to handle any errors themselves or whether
; 721  :        they prefer that the system handle errors automatically.
; 722  :     */
; 723  :     {
; 724  :         char* erropt;
; 725  :         if (HRERR_OK != (err = SHV2ERR( FetchVar( HR_ERRHNDLR_VNAME, &erropt ))))

  0008c	48 8d 54 24 48	 lea	 rdx, QWORD PTR erropt$1[rsp]
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159840
  00098	e8 00 00 00 00	 call	 FetchVar
  0009d	8b c0		 mov	 eax, eax
  0009f	8b c8		 mov	 ecx, eax
  000a1	e8 00 00 00 00	 call	 Shv2Err
  000a6	66 89 44 24 24	 mov	 WORD PTR err$[rsp], ax
  000ab	0f b7 44 24 24	 movzx	 eax, WORD PTR err$[rsp]
  000b0	85 c0		 test	 eax, eax
  000b2	74 05		 je	 SHORT $LN5@SubComHand

; 726  :             goto quick_exit;

  000b4	e9 ca 00 00 00	 jmp	 $quick_exit$16
$LN5@SubComHand:

; 727  :         if (erropt)

  000b9	48 83 7c 24 48
	00		 cmp	 QWORD PTR erropt$1[rsp], 0
  000bf	74 26		 je	 SHORT $LN6@SubComHand

; 728  :         {
; 729  :             if (strcasecmp( erropt, "system" ) == 0)

  000c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159843
  000c8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR erropt$1[rsp]
  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  000d3	85 c0		 test	 eax, eax
  000d5	75 05		 jne	 SHORT $LN7@SubComHand

; 730  :                 RetUsr = FALSE;

  000d7	c6 44 24 20 00	 mov	 BYTE PTR RetUsr$[rsp], 0
$LN7@SubComHand:

; 731  :             free( erropt );

  000dc	48 8b 4c 24 48	 mov	 rcx, QWORD PTR erropt$1[rsp]
  000e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN6@SubComHand:

; 732  :         }
; 733  :     }
; 734  : 
; 735  :     /* Retrieve what stem name they want to use */
; 736  :     if (HRERR_OK != (err = SHV2ERR( FetchVar( HR_RESPSTEM_VNAME, &stemname ))))

  000e7	48 8d 54 24 38	 lea	 rdx, QWORD PTR stemname$[rsp]
  000ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159845
  000f3	e8 00 00 00 00	 call	 FetchVar
  000f8	8b c0		 mov	 eax, eax
  000fa	8b c8		 mov	 ecx, eax
  000fc	e8 00 00 00 00	 call	 Shv2Err
  00101	66 89 44 24 24	 mov	 WORD PTR err$[rsp], ax
  00106	0f b7 44 24 24	 movzx	 eax, WORD PTR err$[rsp]
  0010b	85 c0		 test	 eax, eax
  0010d	74 02		 je	 SHORT $LN8@SubComHand

; 737  :         goto quick_exit;

  0010f	eb 72		 jmp	 SHORT $quick_exit$16
$LN8@SubComHand:

; 738  : 
; 739  :     if (stemname)

  00111	48 83 7c 24 38
	00		 cmp	 QWORD PTR stemname$[rsp], 0
  00117	74 27		 je	 SHORT $LN9@SubComHand

; 740  :     {
; 741  :         /* Not persistent so drop it */
; 742  :         if (HRERR_OK != (err = SHV2ERR( DropVar( HR_RESPSTEM_VNAME ))))

  00119	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159849
  00120	e8 00 00 00 00	 call	 DropVar
  00125	8b c0		 mov	 eax, eax
  00127	8b c8		 mov	 ecx, eax
  00129	e8 00 00 00 00	 call	 Shv2Err
  0012e	66 89 44 24 24	 mov	 WORD PTR err$[rsp], ax
  00133	0f b7 44 24 24	 movzx	 eax, WORD PTR err$[rsp]
  00138	85 c0		 test	 eax, eax
  0013a	74 02		 je	 SHORT $LN11@SubComHand

; 743  :             goto quick_exit;

  0013c	eb 45		 jmp	 SHORT $quick_exit$16
$LN11@SubComHand:

; 744  :     }

  0013e	eb 2a		 jmp	 SHORT $LN10@SubComHand
$LN9@SubComHand:

; 745  :     else // HR_RESPSTEM_VNAME not found. Try HR_PERSISTRESPSTEM_VNAME.
; 746  :     {
; 747  :         if (HRERR_OK != (err = SHV2ERR( FetchVar( HR_PERSISTRESPSTEM_VNAME, &stemname ))))

  00140	48 8d 54 24 38	 lea	 rdx, QWORD PTR stemname$[rsp]
  00145	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159851
  0014c	e8 00 00 00 00	 call	 FetchVar
  00151	8b c0		 mov	 eax, eax
  00153	8b c8		 mov	 ecx, eax
  00155	e8 00 00 00 00	 call	 Shv2Err
  0015a	66 89 44 24 24	 mov	 WORD PTR err$[rsp], ax
  0015f	0f b7 44 24 24	 movzx	 eax, WORD PTR err$[rsp]
  00164	85 c0		 test	 eax, eax
  00166	74 02		 je	 SHORT $LN12@SubComHand

; 748  :             goto quick_exit;

  00168	eb 19		 jmp	 SHORT $quick_exit$16
$LN12@SubComHand:
$LN10@SubComHand:

; 749  :     }
; 750  : 
; 751  :     /* Issue the Hercules command and save the results */
; 752  :     err = HerculesCommand( herccmd, stemname, &panelrc );

  0016a	4c 8d 44 24 28	 lea	 r8, QWORD PTR panelrc$[rsp]
  0016f	48 8b 54 24 38	 mov	 rdx, QWORD PTR stemname$[rsp]
  00174	48 8b 4c 24 40	 mov	 rcx, QWORD PTR herccmd$[rsp]
  00179	e8 00 00 00 00	 call	 HerculesCommand
  0017e	66 89 44 24 24	 mov	 WORD PTR err$[rsp], ax
$quick_exit$16:

; 753  : 
; 754  : quick_exit:
; 755  : 
; 756  :     /* Free acquired storage */
; 757  :     free( herccmd );

  00183	48 8b 4c 24 40	 mov	 rcx, QWORD PTR herccmd$[rsp]
  00188	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 758  :     free( stemname );

  0018e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR stemname$[rsp]
  00193	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 759  : 
; 760  :     /* Return from SubCommand */
; 761  :     rc = SubCommRC( err, panelrc, RetValue, Flags );

  00199	4c 8b 4c 24 68	 mov	 r9, QWORD PTR Flags$[rsp]
  0019e	4c 8b 44 24 70	 mov	 r8, QWORD PTR RetValue$[rsp]
  001a3	8b 54 24 28	 mov	 edx, DWORD PTR panelrc$[rsp]
  001a7	0f b7 4c 24 24	 movzx	 ecx, WORD PTR err$[rsp]
  001ac	e8 00 00 00 00	 call	 SubCommRC
  001b1	89 44 24 2c	 mov	 DWORD PTR rc$[rsp], eax

; 762  : 
; 763  :     // Return to Rexx
; 764  :     return RetUsr ? RXSUBCOM_OK : rc;

  001b5	0f b6 44 24 20	 movzx	 eax, BYTE PTR RetUsr$[rsp]
  001ba	85 c0		 test	 eax, eax
  001bc	74 0a		 je	 SHORT $LN14@SubComHand
  001be	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv154[rsp], 0
  001c6	eb 08		 jmp	 SHORT $LN15@SubComHand
$LN14@SubComHand:
  001c8	8b 44 24 2c	 mov	 eax, DWORD PTR rc$[rsp]
  001cc	89 44 24 30	 mov	 DWORD PTR tv154[rsp], eax
$LN15@SubComHand:
  001d0	8b 44 24 30	 mov	 eax, DWORD PTR tv154[rsp]

; 765  : }

  001d4	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d8	c3		 ret	 0
SubComHandler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hRexxapi.c
_TEXT	SEGMENT
tv65 = 64
rc$ = 68
pb$ = 72
ExitNumber$ = 96
SubFunction$ = 104
ParmBlock$ = 112
ExitHandler PROC

; 397  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 398  :     HR_EXITHAND_RC_T    rc;
; 399  :     HR_PARMBLK*         pb     = (HR_PARMBLK*) ParmBlock;

  00011	48 8b 44 24 70	 mov	 rax, QWORD PTR ParmBlock$[rsp]
  00016	48 89 44 24 48	 mov	 QWORD PTR pb$[rsp], rax

; 400  : 
; 401  :     // Session I/O (RXSIO) is the only thing our exit handler handles
; 402  : 
; 403  :     if (ExitNumber != RXSIO)

  0001b	83 7c 24 60 05	 cmp	 DWORD PTR ExitNumber$[rsp], 5
  00020	74 0a		 je	 SHORT $LN10@ExitHandle

; 404  :         return RXEXIT_NOT_HANDLED;

  00022	b8 01 00 00 00	 mov	 eax, 1
  00027	e9 e6 01 00 00	 jmp	 $LN1@ExitHandle
$LN10@ExitHandle:

; 405  : 
; 406  :     rc  = RXEXIT_HANDLED;   // think positively

  0002c	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 407  : 
; 408  :     switch (SubFunction)

  00034	8b 44 24 68	 mov	 eax, DWORD PTR SubFunction$[rsp]
  00038	89 44 24 40	 mov	 DWORD PTR tv65[rsp], eax
  0003c	83 7c 24 40 01	 cmp	 DWORD PTR tv65[rsp], 1
  00041	74 26		 je	 SHORT $LN11@ExitHandle
  00043	83 7c 24 40 02	 cmp	 DWORD PTR tv65[rsp], 2
  00048	0f 84 cb 00 00
	00		 je	 $LN14@ExitHandle
  0004e	83 7c 24 40 03	 cmp	 DWORD PTR tv65[rsp], 3
  00053	0f 84 6d 01 00
	00		 je	 $LN17@ExitHandle
  00059	83 7c 24 40 04	 cmp	 DWORD PTR tv65[rsp], 4
  0005e	0f 84 82 01 00
	00		 je	 $LN18@ExitHandle
  00064	e9 9d 01 00 00	 jmp	 $LN19@ExitHandle
$LN11@ExitHandle:

; 409  :     {
; 410  :         case RXSIOSAY:      // Perform SAY Clause
; 411  :         {
; 412  :             if (MsgPrefix) WRMSG( HHC17540, "I", pb->u_say.strptr );

  00069	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR MsgPrefix
  00070	85 c0		 test	 eax, eax
  00072	74 57		 je	 SHORT $LN12@ExitHandle
  00074	b9 01 00 00 00	 mov	 ecx, 1
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0007f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pb$[rsp]
  00084	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00088	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159649
  00094	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159650
  000a0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000a5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000aa	41 b9 03 00 00
	00		 mov	 r9d, 3
  000b0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159651
  000b7	ba 9c 01 00 00	 mov	 edx, 412		; 0000019cH
  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159652
  000c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  000c9	eb 49		 jmp	 SHORT $LN13@ExitHandle
$LN12@ExitHandle:

; 413  :             else           LOGMSG( "%s\n",       pb->u_say.strptr );

  000cb	b9 01 00 00 00	 mov	 ecx, 1
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000d6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pb$[rsp]
  000db	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000df	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159653
  000eb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000f0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f5	41 b9 03 00 00
	00		 mov	 r9d, 3
  000fb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159654
  00102	ba 9d 01 00 00	 mov	 edx, 413		; 0000019dH
  00107	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159655
  0010e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN13@ExitHandle:

; 414  :         }
; 415  :         break;

  00114	e9 f5 00 00 00	 jmp	 $LN2@ExitHandle
$LN14@ExitHandle:

; 416  : 
; 417  :         case RXSIOTRC:      // Write Trace Output
; 418  :         {
; 419  :             if (ErrPrefix) WRMSG( HHC17541, "D", pb->u_trc.strptr );

  00119	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ErrPrefix
  00120	85 c0		 test	 eax, eax
  00122	74 57		 je	 SHORT $LN15@ExitHandle
  00124	b9 01 00 00 00	 mov	 ecx, 1
  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0012f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pb$[rsp]
  00134	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00138	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0013d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159659
  00144	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00149	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159660
  00150	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00155	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0015a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00160	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159661
  00167	ba a3 01 00 00	 mov	 edx, 419		; 000001a3H
  0016c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159662
  00173	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  00179	eb 49		 jmp	 SHORT $LN16@ExitHandle
$LN15@ExitHandle:

; 420  :             else           LOGMSG( "%s\n",       pb->u_trc.strptr );

  0017b	b9 01 00 00 00	 mov	 ecx, 1
  00180	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00186	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pb$[rsp]
  0018b	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0018f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00194	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159663
  0019b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001a0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a5	41 b9 03 00 00
	00		 mov	 r9d, 3
  001ab	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159664
  001b2	ba a4 01 00 00	 mov	 edx, 420		; 000001a4H
  001b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159665
  001be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN16@ExitHandle:

; 421  :         }
; 422  :         break;

  001c4	eb 48		 jmp	 SHORT $LN2@ExitHandle
$LN17@ExitHandle:
$LN6@ExitHandle:

; 423  : 
; 424  :         case RXSIOTRD:      // Read Input from the Terminal
; 425  :         {
; 426  :             HMAKE_RXSTRING( pb->u_trd, NULL, 0 );

  001c6	48 8b 44 24 48	 mov	 rax, QWORD PTR pb$[rsp]
  001cb	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  001d3	48 8b 44 24 48	 mov	 rax, QWORD PTR pb$[rsp]
  001d8	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  001de	33 c0		 xor	 eax, eax
  001e0	85 c0		 test	 eax, eax
  001e2	75 e2		 jne	 SHORT $LN6@ExitHandle

; 427  :         }
; 428  :         break;

  001e4	eb 28		 jmp	 SHORT $LN2@ExitHandle
$LN18@ExitHandle:
$LN9@ExitHandle:

; 429  : 
; 430  :         case RXSIODTR:      // Read Debug Input from the Terminal
; 431  :         {
; 432  :             HMAKE_RXSTRING( pb->u_dtr, NULL, 0 );

  001e6	48 8b 44 24 48	 mov	 rax, QWORD PTR pb$[rsp]
  001eb	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  001f3	48 8b 44 24 48	 mov	 rax, QWORD PTR pb$[rsp]
  001f8	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	75 e2		 jne	 SHORT $LN9@ExitHandle

; 433  :         }
; 434  :         break;

  00204	eb 08		 jmp	 SHORT $LN2@ExitHandle
$LN19@ExitHandle:

; 435  : 
; 436  :         default:
; 437  :         {
; 438  :             rc = RXEXIT_NOT_HANDLED;

  00206	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR rc$[rsp], 1
$LN2@ExitHandle:

; 439  :         }
; 440  :         break;
; 441  :     }
; 442  : 
; 443  :     return rc;

  0020e	8b 44 24 44	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@ExitHandle:

; 444  : }

  00212	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00216	c3		 ret	 0
ExitHandler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
