; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG159227 DB	04H DUP (?)
$SG159235 DB	04H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG159228 DB	0e5H, 0d6H, 0d3H, 00H
$SG159229 DB	0c8H, 0c4H, 0d9H, 00H
$SG159230 DB	0e4H, 0c8H, 0d3H, 00H
$SG159231 DB	0c5H, 0d6H, 0c6H, 00H
$SG159232 DB	0c5H, 0d6H, 0e5H, 00H
$SG159233 DB	0e4H, 0e3H, 0d3H, 00H
$SG159236 DB	'VOL', 00H
$SG159237 DB	'HDR', 00H
$SG159238 DB	'UHL', 00H
$SG159239 DB	'EOF', 00H
$SG159240 DB	'EOV', 00H
$SG159241 DB	'UTL', 00H
$SG159247 DB	'No error', 00H
	ORG $+7
$SG159248 DB	'Block size out of range', 00H
$SG159249 DB	'Data set sequence out of range', 00H
	ORG $+1
$SG159250 DB	'Invalid expiration date', 00H
$SG159251 DB	'Missing or invalid job name', 00H
$SG159270 DB	'U', 00H
	ORG $+2
$SG159252 DB	'Missing or invalid record length', 00H
	ORG $+3
$SG159271 DB	'UA', 00H
	ORG $+1
$SG159253 DB	'Owner string invalid or too long', 00H
	ORG $+3
$SG159272 DB	'UM', 00H
	ORG $+1
$SG159254 DB	'Missing or invalid record format', 00H
	ORG $+3
$SG159273 DB	'F', 00H
	ORG $+2
$SG159255 DB	'Missing or invalid step name', 00H
	ORG $+3
$SG159256 DB	'Invalid recording technique', 00H
$SG159274 DB	'FA', 00H
	ORG $+1
$SG159257 DB	'Volume sequence out of range', 00H
	ORG $+3
$SG159258 DB	'Missing or invalid volume serial', 00H
	ORG $+3
$SG159275 DB	'FM', 00H
	ORG $+1
$SG159259 DB	'User data too long', 00H
	ORG $+1
$SG159276 DB	'FB', 00H
	ORG $+1
$SG159260 DB	'Label type invalid', 00H
	ORG $+1
$SG159277 DB	'FBA', 00H
$SG159261 DB	'Label number invalid', 00H
	ORG $+3
$SG159262 DB	'Invalid error code', 00H
	ORG $+1
$SG159278 DB	'FBM', 00H
$SG159279 DB	'FS', 00H
	ORG $+1
$SG159280 DB	'FSA', 00H
$SG159281 DB	'FSM', 00H
$SG159282 DB	'FBS', 00H
$SG159283 DB	'FBSA', 00H
	ORG $+3
$SG159284 DB	'FBSM', 00H
	ORG $+3
$SG159285 DB	'V', 00H
	ORG $+2
$SG159286 DB	'VA', 00H
	ORG $+1
$SG159287 DB	'VM', 00H
	ORG $+1
$SG159288 DB	'VB', 00H
	ORG $+1
$SG159289 DB	'VBA', 00H
$SG159290 DB	'VBM', 00H
$SG159291 DB	'VS', 00H
	ORG $+1
$SG159292 DB	'VSA', 00H
$SG159293 DB	'VSM', 00H
$SG159294 DB	'VBS', 00H
$SG159295 DB	'VBSA', 00H
	ORG $+3
$SG159296 DB	'VBSM', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
sl_ranges DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	08H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	01H
	DD	08H
sl_cset	DB	'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 !"%&''()*+,-./:;<=>'
	DB	'?_', 00H
	ORG $+6
valfm	DQ	FLAT:$SG159270
	DB	055H
	DB	020H
	DB	020H
	ORG $+5
	DQ	FLAT:$SG159271
	DB	055H
	DB	020H
	DB	041H
	ORG $+5
	DQ	FLAT:$SG159272
	DB	055H
	DB	020H
	DB	04dH
	ORG $+5
	DQ	FLAT:$SG159273
	DB	046H
	DB	020H
	DB	020H
	ORG $+5
	DQ	FLAT:$SG159274
	DB	046H
	DB	020H
	DB	041H
	ORG $+5
	DQ	FLAT:$SG159275
	DB	046H
	DB	020H
	DB	04dH
	ORG $+5
	DQ	FLAT:$SG159276
	DB	046H
	DB	042H
	DB	020H
	ORG $+5
	DQ	FLAT:$SG159277
	DB	046H
	DB	042H
	DB	041H
	ORG $+5
	DQ	FLAT:$SG159278
	DB	046H
	DB	042H
	DB	04dH
	ORG $+5
	DQ	FLAT:$SG159279
	DB	046H
	DB	053H
	DB	020H
	ORG $+5
	DQ	FLAT:$SG159280
	DB	046H
	DB	053H
	DB	041H
	ORG $+5
	DQ	FLAT:$SG159281
	DB	046H
	DB	053H
	DB	04dH
	ORG $+5
	DQ	FLAT:$SG159282
	DB	046H
	DB	052H
	DB	020H
	ORG $+5
	DQ	FLAT:$SG159283
	DB	046H
	DB	052H
	DB	041H
	ORG $+5
	DQ	FLAT:$SG159284
	DB	046H
	DB	052H
	DB	04dH
	ORG $+5
	DQ	FLAT:$SG159285
	DB	056H
	DB	020H
	DB	020H
	ORG $+5
	DQ	FLAT:$SG159286
	DB	056H
	DB	020H
	DB	041H
	ORG $+5
	DQ	FLAT:$SG159287
	DB	056H
	DB	020H
	DB	04dH
	ORG $+5
	DQ	FLAT:$SG159288
	DB	056H
	DB	042H
	DB	020H
	ORG $+5
	DQ	FLAT:$SG159289
	DB	056H
	DB	042H
	DB	041H
	ORG $+5
	DQ	FLAT:$SG159290
	DB	056H
	DB	042H
	DB	04dH
	ORG $+5
	DQ	FLAT:$SG159291
	DB	056H
	DB	053H
	DB	020H
	ORG $+5
	DQ	FLAT:$SG159292
	DB	056H
	DB	053H
	DB	041H
	ORG $+5
	DQ	FLAT:$SG159293
	DB	056H
	DB	053H
	DB	04dH
	ORG $+5
	DQ	FLAT:$SG159294
	DB	056H
	DB	052H
	DB	020H
	ORG $+5
	DQ	FLAT:$SG159295
	DB	056H
	DB	052H
	DB	041H
	ORG $+5
	DQ	FLAT:$SG159296
	DB	056H
	DB	052H
	DB	04dH
	ORG $+5
sl_etoatab DB	00H, 01H, 02H, 03H, 0a6H, 09H, 0a7H, 07fH, 0a9H, 0b0H, 0b1H
	DB	0bH, 0cH, 0dH, 0eH, 0fH, 010H, 011H, 012H, 013H, 0b2H, 0b4H, 08H
	DB	0b7H, 018H, 019H, 01aH, 0b8H, 0baH, 01dH, 0bbH, 01fH, 0bdH, 0c0H
	DB	01cH, 0c1H, 0c2H, 0aH, 017H, 01bH, 0c3H, 0c4H, 0c5H, 0c6H, 0c7H
	DB	05H, 06H, 07H, 0c8H, 0c9H, 016H, 0cbH, 0ccH, 01eH, 0cdH, 04H, 0ceH
	DB	0d0H, 0d1H, 0d2H, 014H, 015H, 0d3H, 0fcH, ' ', 0d4H, 083H, 084H
	DB	085H, 0a0H, 0d5H, 086H, 087H, 0a4H, 0d6H, '.<(+', 0d7H, '&', 082H
	DB	088H, 089H, 08aH, 0a1H, 08cH, 08bH, 08dH, 0d8H, '!$*);^-/', 0d9H
	DB	08eH, 0dbH, 0dcH, 0ddH, 08fH, 080H, 0a5H, '|,%_>?', 0deH, 090H
	DB	0dfH, 0e0H, 0e2H, 0e3H, 0e4H, 0e5H, 0e6H, '`:#@''="', 0e7H, 'a'
	DB	'bcdefghi', 0aeH, 0afH, 0e8H, 0e9H, 0eaH, 0ecH, 0f0H, 'jklmnop'
	DB	'qr', 0f1H, 0f2H, 091H, 0f3H, 092H, 0f4H, 0f5H, '~stuvwxyz', 0adH
	DB	0a8H, 0f6H, '[', 0f7H, 0f8H, 09bH, 09cH, 09dH, 09eH, 09fH, 0b5H
	DB	0b6H, 0acH, 0abH, 0b9H, 0aaH, 0b3H, 0bcH, ']', 0beH, 0bfH, '{A'
	DB	'BCDEFGHI', 0caH, 093H, 094H, 095H, 0a2H, 0cfH, '}JKLMNOPQR', 0daH
	DB	096H, 081H, 097H, 0a3H, 098H, '\', 0e1H, 'STUVWXYZ', 0fdH, 0ebH
	DB	099H, 0edH, 0eeH, 0efH, '0123456789', 0feH, 0fbH, 09aH, 0f9H, 0faH
	DB	0ffH, 00H
	ORG $+15
sl_atoetab DB	00H, 01H, 02H, 03H, '7-./', 016H, 05H, '%', 0bH, 0cH, 0dH
	DB	0eH, 0fH, 010H, 011H, 012H, 013H, '<=2&', 018H, 019H, 01aH, ''''
	DB	'"', 01dH, '5', 01fH, '@Z', 07fH, '{[lP}M]\Nk`Ka', 0f0H, 0f1H, 0f2H
	DB	0f3H, 0f4H, 0f5H, 0f6H, 0f7H, 0f8H, 0f9H, 'z^L~no|', 0c1H, 0c2H
	DB	0c3H, 0c4H, 0c5H, 0c6H, 0c7H, 0c8H, 0c9H, 0d1H, 0d2H, 0d3H, 0d4H
	DB	0d5H, 0d6H, 0d7H, 0d8H, 0d9H, 0e2H, 0e3H, 0e4H, 0e5H, 0e6H, 0e7H
	DB	0e8H, 0e9H, 0adH, 0e0H, 0bdH, '_my', 081H, 082H, 083H, 084H, 085H
	DB	086H, 087H, 088H, 089H, 091H, 092H, 093H, 094H, 095H, 096H, 097H
	DB	098H, 099H, 0a2H, 0a3H, 0a4H, 0a5H, 0a6H, 0a7H, 0a8H, 0a9H, 0c0H
	DB	'j', 0d0H, 0a1H, 07H, 'h', 0dcH, 'QBCDGHRSTWVXcgq', 09cH, 09eH
	DB	0cbH, 0ccH, 0cdH, 0dbH, 0ddH, 0dfH, 0ecH, 0fcH, 0b0H, 0b1H, 0b2H
	DB	0b3H, 0b4H, 'EU', 0ceH, 0deH, 'Ii', 04H, 06H, 0abH, 08H, 0baH, 0b8H
	DB	0b7H, 0aaH, 08aH, 08bH, 09H, 0aH, 014H, 0bbH, 015H, 0b5H, 0b6H
	DB	017H, 01bH, 0b9H, 01cH, 01eH, 0bcH, ' ', 0beH, 0bfH, '!#$()*+,'
	DB	'01', 0caH, '3468', 0cfH, '9:;>AFJOYb', 0daH, 'defprs', 0e1H, 't'
	DB	'uvwx', 080H, 08cH, 08dH, 08eH, 0ebH, 08fH, 0edH, 0eeH, 0efH, 090H
	DB	09aH, 09bH, 09dH, 09fH, 0a0H, 0acH, 0aeH, 0afH, 0fdH, 0feH, 0fbH
	DB	'?', 0eaH, 0faH, 0ffH, 00H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	sl_atoe
PUBLIC	sl_etoa
PUBLIC	sl_fmtdate
PUBLIC	sl_fmtlab
PUBLIC	sl_islabel
PUBLIC	sl_istype
PUBLIC	sl_vol
PUBLIC	sl_ds1
PUBLIC	sl_ds2
PUBLIC	sl_usr
PUBLIC	sl_error
EXTRN	__imp_isdigit:PROC
EXTRN	strcmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strspn:PROC
EXTRN	__imp_rand:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp__localtime64:PROC
EXTRN	__imp_strftime:PROC
EXTRN	__imp__time64:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+118
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$localtime DD imagerel localtime
	DD	imagerel localtime+25
	DD	imagerel $unwind$localtime
$pdata$time DD	imagerel time
	DD	imagerel time+25
	DD	imagerel $unwind$time
$pdata$sl_atoe DD imagerel $LN6
	DD	imagerel $LN6+120
	DD	imagerel $unwind$sl_atoe
$pdata$sl_etoa DD imagerel $LN6
	DD	imagerel $LN6+120
	DD	imagerel $unwind$sl_etoa
$pdata$sl_fmtdate DD imagerel $LN21
	DD	imagerel $LN21+807
	DD	imagerel $unwind$sl_fmtdate
$pdata$sl_fmtlab DD imagerel $LN14
	DD	imagerel $LN14+3119
	DD	imagerel $unwind$sl_fmtlab
$pdata$sl_islabel DD imagerel $LN13
	DD	imagerel $LN13+387
	DD	imagerel $unwind$sl_islabel
$pdata$sl_istype DD imagerel $LN9
	DD	imagerel $LN9+196
	DD	imagerel $unwind$sl_istype
$pdata$sl_vol DD imagerel $LN8
	DD	imagerel $LN8+278
	DD	imagerel $unwind$sl_vol
$pdata$sl_ds1 DD imagerel $LN31
	DD	imagerel $LN31+1538
	DD	imagerel $unwind$sl_ds1
$pdata$sl_ds2 DD imagerel $LN48
	DD	imagerel $LN48+1590
	DD	imagerel $unwind$sl_ds2
$pdata$sl_usr DD imagerel $LN9
	DD	imagerel $LN9+247
	DD	imagerel $unwind$sl_usr
pdata	ENDS
_DATA	SEGMENT
	ORG $+3
sl_elabs DQ	FLAT:$SG159227
	DQ	FLAT:$SG159228
	DQ	FLAT:$SG159229
	DQ	FLAT:$SG159230
	DQ	FLAT:$SG159231
	DQ	FLAT:$SG159232
	DQ	FLAT:$SG159233
sl_alabs DQ	FLAT:$SG159235
	DQ	FLAT:$SG159236
	DQ	FLAT:$SG159237
	DQ	FLAT:$SG159238
	DQ	FLAT:$SG159239
	DQ	FLAT:$SG159240
	DQ	FLAT:$SG159241
$SG159397 DB	'%Y%j', 00H
	ORG $+3
sl_errstr DQ	FLAT:$SG159247
	DQ	FLAT:$SG159248
	DQ	FLAT:$SG159249
	DQ	FLAT:$SG159250
	DQ	FLAT:$SG159251
	DQ	FLAT:$SG159252
	DQ	FLAT:$SG159253
	DQ	FLAT:$SG159254
	DQ	FLAT:$SG159255
	DQ	FLAT:$SG159256
	DQ	FLAT:$SG159257
	DQ	FLAT:$SG159258
	DQ	FLAT:$SG159259
	DQ	FLAT:$SG159260
	DQ	FLAT:$SG159261
	DQ	FLAT:$SG159262
$SG159399 DB	'%2u%3u', 00H
	ORG $+1
$SG159401 DB	'%2u.%3u', 00H
$SG159403 DB	'%4u%3u', 00H
	ORG $+1
$SG159405 DB	'%4u.%3u', 00H
$SG159409 DB	'%Y%j', 00H
	ORG $+3
$SG159420 DB	'Label', 00H
	ORG $+2
$SG159423 DB	'VOL', 00H
$SG159431 DB	'HDR', 00H
$SG159425 DB	'Volume Serial', 00H
	ORG $+2
$SG159426 DB	'Volume Access', 00H
	ORG $+2
$SG159427 DB	'Owner Code', 00H
	ORG $+1
$SG159432 DB	'EOF', 00H
$SG159433 DB	'EOV', 00H
$SG159462 DB	'USR', 00H
$SG159436 DB	'Dataset ID', 00H
	ORG $+5
$SG159437 DB	'Volume Serial', 00H
	ORG $+2
$SG159438 DB	'Volume Sequence', 00H
$SG159439 DB	'Dataset Sequence', 00H
	ORG $+7
$SG159440 DB	'GDG Number', 00H
	ORG $+5
$SG159441 DB	'GDG Version', 00H
	ORG $+4
$SG159442 DB	'Creation Date', 00H
	ORG $+2
$SG159443 DB	'Expiration Date', 00H
$SG159444 DB	'Dataset Security', 00H
	ORG $+7
$SG159445 DB	'Block Count Low', 00H
$SG159446 DB	'System Code', 00H
	ORG $+4
$SG159447 DB	'Block Count High', 00H
	ORG $+7
$SG159449 DB	'Record Format', 00H
	ORG $+2
$SG159450 DB	'Block Size', 00H
	ORG $+5
$SG159451 DB	'Record Length', 00H
	ORG $+2
$SG159452 DB	'Density', 00H
$SG159453 DB	'Dataset Position', 00H
	ORG $+7
$SG159454 DB	'Job/Step ID', 00H
	ORG $+4
$SG159455 DB	'Recording Technique', 00H
	ORG $+4
$SG159456 DB	'Control Character', 00H
	ORG $+6
$SG159457 DB	'Block Attribute', 00H
$SG159458 DB	'Device Serial', 00H
	ORG $+2
$SG159459 DB	'Checkpoint ID', 00H
	ORG $+2
$SG159460 DB	'Large Block Length', 00H
	ORG $+5
$SG159463 DB	'User Data', 00H
	ORG $+6
$SG159512 DB	'_IEHINITT_', 00H
	ORG $+1
$SG159518 DB	'%04u', 00H
	ORG $+3
$SG159520 DB	'%04u', 00H
	ORG $+3
$SG159523 DB	'%010u', 00H
	ORG $+6
$SG159524 DB	'IBM OS/VS 370', 00H
	ORG $+2
$SG159525 DB	'%10u', 00H
	ORG $+3
$SG159569 DB	'%10u', 00H
	ORG $+3
$SG159570 DB	'00000', 00H
	ORG $+2
$SG159571 DB	'%05u', 00H
	ORG $+3
$SG159586 DB	'%05u', 00H
	ORG $+3
$SG159593 DB	'%-8.8s/%-8.8s', 00H
	ORG $+2
$SG159605 DB	'%06u', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sl_ds2
	DD	026H
	DD	061cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sl_ds1
	DD	026H
	DD	05e8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sl_fmtlab
	DD	01dH
	DD	0c18H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sl_fmtdate
	DD	022H
	DD	030dH
voltbl	ENDS
xdata	SEGMENT
$unwind$localtime DD 010901H
	DD	04209H
$unwind$time DD	010901H
	DD	04209H
$unwind$sl_atoe DD 011301H
	DD	02213H
$unwind$sl_etoa DD 011301H
	DD	02213H
$unwind$sl_fmtdate DD 042a19H
	DD	0130118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	088H
$unwind$sl_fmtlab DD 042219H
	DD	0110113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$sl_islabel DD 031501H
	DD	070116215H
	DD	06010H
$unwind$sl_istype DD 011201H
	DD	06212H
$unwind$sl_vol DD 031501H
	DD	070116215H
	DD	06010H
$unwind$sl_ds1 DD 042e19H
	DD	019011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$sl_ds2 DD 042e19H
	DD	015011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$sl_usr DD 031901H
	DD	070156219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sllib.c
_TEXT	SEGMENT
rc$ = 8
sl_error PROC

; 1736 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 1737 :     /*
; 1738 :     || If not an error just return the "OK" string
; 1739 :     */
; 1740 :     if( rc >= 0 )

  00004	83 7c 24 08 00	 cmp	 DWORD PTR rc$[rsp], 0
  00009	7c 08		 jl	 SHORT $LN2@sl_error

; 1741 :     {
; 1742 :         rc = 0;

  0000b	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
$LN2@sl_error:

; 1743 :     }
; 1744 : 
; 1745 :     /*
; 1746 :     || Turn it into an index
; 1747 :     */
; 1748 :     rc = -rc;

  00013	8b 44 24 08	 mov	 eax, DWORD PTR rc$[rsp]
  00017	f7 d8		 neg	 eax
  00019	89 44 24 08	 mov	 DWORD PTR rc$[rsp], eax

; 1749 : 
; 1750 :     /*
; 1751 :     || Within range?
; 1752 :     */
; 1753 :     if( rc >= (int)SL_ERRSTR_MAX )

  0001d	83 7c 24 08 10	 cmp	 DWORD PTR rc$[rsp], 16
  00022	7c 08		 jl	 SHORT $LN3@sl_error

; 1754 :     {
; 1755 :         rc = SL_ERRSTR_MAX - 1;

  00024	c7 44 24 08 0f
	00 00 00	 mov	 DWORD PTR rc$[rsp], 15
$LN3@sl_error:

; 1756 :     }
; 1757 : 
; 1758 :     /*
; 1759 :     || Return string
; 1760 :     */
; 1761 :     return( sl_errstr[ rc ] );

  0002c	48 63 44 24 08	 movsxd	 rax, DWORD PTR rc$[rsp]
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sl_errstr
  00038	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]

; 1762 : }

  0003c	c3		 ret	 0
sl_error ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sllib.c
_TEXT	SEGMENT
len$ = 32
lab$ = 80
type$ = 88
num$ = 96
data$ = 104
sl_usr	PROC

; 1647 : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1648 :     size_t len;
; 1649 : 
; 1650 :     /*
; 1651 :     || Initialize
; 1652 :     */
; 1653 :     memset( lab, ' ', sizeof( SLLABEL ) );

  00019	48 8b 7c 24 50	 mov	 rdi, QWORD PTR lab$[rsp]
  0001e	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00023	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00028	f3 aa		 rep stosb

; 1654 : 
; 1655 :     /*
; 1656 :     || Label ID
; 1657 :     */
; 1658 :     if( ( type != SLT_UHL ) && ( type != SLT_UTL ) )

  0002a	83 7c 24 58 03	 cmp	 DWORD PTR type$[rsp], 3
  0002f	74 11		 je	 SHORT $LN2@sl_usr
  00031	83 7c 24 58 06	 cmp	 DWORD PTR type$[rsp], 6
  00036	74 0a		 je	 SHORT $LN2@sl_usr

; 1659 :     {
; 1660 :         return( SLE_INVALIDTYPE );

  00038	b8 f3 ff ff ff	 mov	 eax, -13
  0003d	e9 ae 00 00 00	 jmp	 $LN1@sl_usr
$LN2@sl_usr:

; 1661 :     }
; 1662 :     memcpy( lab->id, sl_elabs[ type ], 3 );

  00042	48 63 44 24 58	 movsxd	 rax, DWORD PTR type$[rsp]
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sl_elabs
  0004e	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00052	48 8b 7c 24 50	 mov	 rdi, QWORD PTR lab$[rsp]
  00057	48 8b f0	 mov	 rsi, rax
  0005a	b9 03 00 00 00	 mov	 ecx, 3
  0005f	f3 a4		 rep movsb

; 1663 : 
; 1664 :     /*
; 1665 :     || Label number
; 1666 :     */
; 1667 :     if( ( num < 1 ) || ( num > 8 ) )

  00061	83 7c 24 60 01	 cmp	 DWORD PTR num$[rsp], 1
  00066	7c 07		 jl	 SHORT $LN4@sl_usr
  00068	83 7c 24 60 08	 cmp	 DWORD PTR num$[rsp], 8
  0006d	7e 07		 jle	 SHORT $LN3@sl_usr
$LN4@sl_usr:

; 1668 :     {
; 1669 :         return( SLE_INVALIDNUM );

  0006f	b8 f2 ff ff ff	 mov	 eax, -14
  00074	eb 7a		 jmp	 SHORT $LN1@sl_usr
$LN3@sl_usr:

; 1670 :     }
; 1671 :     lab->num[ 0 ] = '0' + num;

  00076	8b 44 24 60	 mov	 eax, DWORD PTR num$[rsp]
  0007a	83 c0 30	 add	 eax, 48			; 00000030H
  0007d	b9 01 00 00 00	 mov	 ecx, 1
  00082	48 6b c9 00	 imul	 rcx, rcx, 0
  00086	48 8b 54 24 50	 mov	 rdx, QWORD PTR lab$[rsp]
  0008b	88 44 0a 03	 mov	 BYTE PTR [rdx+rcx+3], al

; 1672 : 
; 1673 :     /*
; 1674 :     || User data
; 1675 :     */
; 1676 :     if( data == NULL )

  0008f	48 83 7c 24 68
	00		 cmp	 QWORD PTR data$[rsp], 0
  00095	75 07		 jne	 SHORT $LN5@sl_usr

; 1677 :     {
; 1678 :         return( SLE_DATA );

  00097	b8 f4 ff ff ff	 mov	 eax, -12
  0009c	eb 52		 jmp	 SHORT $LN1@sl_usr
$LN5@sl_usr:

; 1679 :     }
; 1680 : 
; 1681 :     len = strlen( data );

  0009e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR data$[rsp]
  000a3	e8 00 00 00 00	 call	 strlen
  000a8	48 89 44 24 20	 mov	 QWORD PTR len$[rsp], rax

; 1682 :     if( len == 0 || len > 76 )

  000ad	48 83 7c 24 20
	00		 cmp	 QWORD PTR len$[rsp], 0
  000b3	74 08		 je	 SHORT $LN7@sl_usr
  000b5	48 83 7c 24 20
	4c		 cmp	 QWORD PTR len$[rsp], 76	; 0000004cH
  000bb	76 07		 jbe	 SHORT $LN6@sl_usr
$LN7@sl_usr:

; 1683 :     {
; 1684 :         return( SLE_DATA );

  000bd	b8 f4 ff ff ff	 mov	 eax, -12
  000c2	eb 2c		 jmp	 SHORT $LN1@sl_usr
$LN6@sl_usr:

; 1685 :     }
; 1686 :     memcpy( lab->slusr.data, data, len );

  000c4	48 8b 44 24 50	 mov	 rax, QWORD PTR lab$[rsp]
  000c9	48 83 c0 04	 add	 rax, 4
  000cd	48 8b f8	 mov	 rdi, rax
  000d0	48 8b 74 24 68	 mov	 rsi, QWORD PTR data$[rsp]
  000d5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR len$[rsp]
  000da	f3 a4		 rep movsb

; 1687 : 
; 1688 :     /*
; 1689 :     || Convert to EBCDIC
; 1690 :     */
; 1691 :     sl_atoe( NULL, lab, sizeof( SLLABEL ) );

  000dc	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  000e2	48 8b 54 24 50	 mov	 rdx, QWORD PTR lab$[rsp]
  000e7	33 c9		 xor	 ecx, ecx
  000e9	e8 00 00 00 00	 call	 sl_atoe

; 1692 : 
; 1693 :     return 0;

  000ee	33 c0		 xor	 eax, eax
$LN1@sl_usr:

; 1694 : }

  000f0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f4	5f		 pop	 rdi
  000f5	5e		 pop	 rsi
  000f6	c3		 ret	 0
sl_usr	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sllib.c
_TEXT	SEGMENT
i$ = 32
tv272 = 36
tv188 = 40
len$ = 48
wbuf$ = 64
__$ArrayPad$ = 144
lab$ = 192
type$ = 200
recfm$ = 208
lrecl$ = 216
blksize$ = 224
jobname$ = 232
stepname$ = 240
trtch$ = 248
sl_ds2	PROC

; 1359 : {

$LN48:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1360 :     int i;
; 1361 :     size_t len;
; 1362 :     char wbuf[ 80 ];
; 1363 : 
; 1364 :     /*
; 1365 :     || Initialize
; 1366 :     */
; 1367 :     memset( lab, ' ', sizeof( SLLABEL ) );

  0002e	48 8b bc 24 c0
	00 00 00	 mov	 rdi, QWORD PTR lab$[rsp]
  00036	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  0003b	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00040	f3 aa		 rep stosb

; 1368 : 
; 1369 :     /*
; 1370 :     || Label ID
; 1371 :     */
; 1372 :     if( ( type != SLT_HDR ) && ( type != SLT_EOF ) && ( type != SLT_EOV ) )

  00042	83 bc 24 c8 00
	00 00 02	 cmp	 DWORD PTR type$[rsp], 2
  0004a	74 1e		 je	 SHORT $LN9@sl_ds2
  0004c	83 bc 24 c8 00
	00 00 04	 cmp	 DWORD PTR type$[rsp], 4
  00054	74 14		 je	 SHORT $LN9@sl_ds2
  00056	83 bc 24 c8 00
	00 00 05	 cmp	 DWORD PTR type$[rsp], 5
  0005e	74 0a		 je	 SHORT $LN9@sl_ds2

; 1373 :     {
; 1374 :         return( SLE_INVALIDTYPE );

  00060	b8 f3 ff ff ff	 mov	 eax, -13
  00065	e9 b2 05 00 00	 jmp	 $LN1@sl_ds2
$LN9@sl_ds2:

; 1375 :     }
; 1376 :     memcpy( lab->id, sl_alabs[ type ], 3 );

  0006a	48 63 84 24 c8
	00 00 00	 movsxd	 rax, DWORD PTR type$[rsp]
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sl_alabs
  00079	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0007d	48 8b bc 24 c0
	00 00 00	 mov	 rdi, QWORD PTR lab$[rsp]
  00085	48 8b f0	 mov	 rsi, rax
  00088	b9 03 00 00 00	 mov	 ecx, 3
  0008d	f3 a4		 rep movsb

; 1377 : 
; 1378 :     /*
; 1379 :     || Label number
; 1380 :     */
; 1381 :     lab->num[ 0 ] = '1';

  0008f	b8 01 00 00 00	 mov	 eax, 1
  00094	48 6b c0 00	 imul	 rax, rax, 0
  00098	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  000a0	c6 44 01 03 31	 mov	 BYTE PTR [rcx+rax+3], 49 ; 00000031H

; 1382 : 
; 1383 :     /*
; 1384 :     || Record format/Block Attribute/Control
; 1385 :     */
; 1386 :     if( recfm == NULL )

  000a5	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR recfm$[rsp], 0
  000ae	75 0a		 jne	 SHORT $LN10@sl_ds2

; 1387 :     {
; 1388 :         return( SLE_RECFM );

  000b0	b8 f9 ff ff ff	 mov	 eax, -7
  000b5	e9 62 05 00 00	 jmp	 $LN1@sl_ds2
$LN10@sl_ds2:

; 1389 :     }
; 1390 : 
; 1391 :     for( i = 0 ; i < (int)VALFMCNT ; i++ )

  000ba	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000c2	eb 0a		 jmp	 SHORT $LN4@sl_ds2
$LN2@sl_ds2:
  000c4	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000c8	ff c0		 inc	 eax
  000ca	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@sl_ds2:
  000ce	83 7c 24 20 1b	 cmp	 DWORD PTR i$[rsp], 27
  000d3	7d 29		 jge	 SHORT $LN3@sl_ds2

; 1392 :     {
; 1393 :         if( strcmp( recfm, valfm[ i ].recfm ) == 0 )

  000d5	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000da	48 6b c0 10	 imul	 rax, rax, 16
  000de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:valfm
  000e5	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  000e9	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR recfm$[rsp]
  000f1	e8 00 00 00 00	 call	 strcmp
  000f6	85 c0		 test	 eax, eax
  000f8	75 02		 jne	 SHORT $LN11@sl_ds2

; 1394 :         {
; 1395 :             break;

  000fa	eb 02		 jmp	 SHORT $LN3@sl_ds2
$LN11@sl_ds2:

; 1396 :         }
; 1397 :     }

  000fc	eb c6		 jmp	 SHORT $LN2@sl_ds2
$LN3@sl_ds2:

; 1398 : 
; 1399 :     if( i == VALFMCNT )

  000fe	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00103	48 83 f8 1b	 cmp	 rax, 27
  00107	75 0a		 jne	 SHORT $LN12@sl_ds2

; 1400 :     {
; 1401 :         return( SLE_RECFM );

  00109	b8 f9 ff ff ff	 mov	 eax, -7
  0010e	e9 09 05 00 00	 jmp	 $LN1@sl_ds2
$LN12@sl_ds2:

; 1402 :     }
; 1403 : 
; 1404 :     lab->slds2.recfm[ 0 ]   = valfm[ i ].f;

  00113	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00118	48 6b c0 10	 imul	 rax, rax, 16
  0011c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:valfm
  00123	ba 01 00 00 00	 mov	 edx, 1
  00128	48 6b d2 00	 imul	 rdx, rdx, 0
  0012c	48 8b bc 24 c0
	00 00 00	 mov	 rdi, QWORD PTR lab$[rsp]
  00134	0f b6 44 01 08	 movzx	 eax, BYTE PTR [rcx+rax+8]
  00139	88 44 17 04	 mov	 BYTE PTR [rdi+rdx+4], al

; 1405 :     lab->slds2.blkattr[ 0 ] = valfm[ i ].b;

  0013d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00142	48 6b c0 10	 imul	 rax, rax, 16
  00146	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:valfm
  0014d	ba 01 00 00 00	 mov	 edx, 1
  00152	48 6b d2 00	 imul	 rdx, rdx, 0
  00156	48 8b bc 24 c0
	00 00 00	 mov	 rdi, QWORD PTR lab$[rsp]
  0015e	0f b6 44 01 09	 movzx	 eax, BYTE PTR [rcx+rax+9]
  00163	88 44 17 26	 mov	 BYTE PTR [rdi+rdx+38], al

; 1406 :     lab->slds2.ctrl[ 0 ]    = valfm[ i ].c;

  00167	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0016c	48 6b c0 10	 imul	 rax, rax, 16
  00170	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:valfm
  00177	ba 01 00 00 00	 mov	 edx, 1
  0017c	48 6b d2 00	 imul	 rdx, rdx, 0
  00180	48 8b bc 24 c0
	00 00 00	 mov	 rdi, QWORD PTR lab$[rsp]
  00188	0f b6 44 01 0a	 movzx	 eax, BYTE PTR [rcx+rax+10]
  0018d	88 44 17 24	 mov	 BYTE PTR [rdi+rdx+36], al

; 1407 : 
; 1408 :     /*
; 1409 :     || Block size
; 1410 :     */
; 1411 :     if( blksize == 0 )

  00191	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR blksize$[rsp], 0
  00199	75 0a		 jne	 SHORT $LN13@sl_ds2

; 1412 :     {
; 1413 :         return( SLE_BLKSIZE );

  0019b	b8 ff ff ff ff	 mov	 eax, -1
  001a0	e9 77 04 00 00	 jmp	 $LN1@sl_ds2
$LN13@sl_ds2:

; 1414 :     }
; 1415 : 
; 1416 :     if( blksize > 32760 )

  001a5	81 bc 24 e0 00
	00 00 f8 7f 00
	00		 cmp	 DWORD PTR blksize$[rsp], 32760 ; 00007ff8H
  001b0	7e 53		 jle	 SHORT $LN14@sl_ds2

; 1417 :     {
; 1418 :         sprintf( wbuf, "%10u", blksize );

  001b2	44 8b 84 24 e0
	00 00 00	 mov	 r8d, DWORD PTR blksize$[rsp]
  001ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159569
  001c1	48 8d 4c 24 40	 lea	 rcx, QWORD PTR wbuf$[rsp]
  001c6	e8 00 00 00 00	 call	 sprintf

; 1419 :         memcpy( lab->slds2.lblkln, wbuf, 10 );

  001cb	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR lab$[rsp]
  001d3	48 8d 4c 24 40	 lea	 rcx, QWORD PTR wbuf$[rsp]
  001d8	48 8d 78 46	 lea	 rdi, QWORD PTR [rax+70]
  001dc	48 8b f1	 mov	 rsi, rcx
  001df	b9 0a 00 00 00	 mov	 ecx, 10
  001e4	f3 a4		 rep movsb

; 1420 :         memcpy( lab->slds2.blksize, "00000", 5 );

  001e6	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR lab$[rsp]
  001ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159570
  001f5	48 8d 78 05	 lea	 rdi, QWORD PTR [rax+5]
  001f9	48 8b f1	 mov	 rsi, rcx
  001fc	b9 05 00 00 00	 mov	 ecx, 5
  00201	f3 a4		 rep movsb

; 1421 :     }

  00203	eb 34		 jmp	 SHORT $LN15@sl_ds2
$LN14@sl_ds2:

; 1422 :     else
; 1423 :     {
; 1424 :         sprintf( wbuf, "%05u", blksize );

  00205	44 8b 84 24 e0
	00 00 00	 mov	 r8d, DWORD PTR blksize$[rsp]
  0020d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159571
  00214	48 8d 4c 24 40	 lea	 rcx, QWORD PTR wbuf$[rsp]
  00219	e8 00 00 00 00	 call	 sprintf

; 1425 :         memcpy( lab->slds2.blksize, wbuf, 5 );

  0021e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR lab$[rsp]
  00226	48 8d 4c 24 40	 lea	 rcx, QWORD PTR wbuf$[rsp]
  0022b	48 8d 78 05	 lea	 rdi, QWORD PTR [rax+5]
  0022f	48 8b f1	 mov	 rsi, rcx
  00232	b9 05 00 00 00	 mov	 ecx, 5
  00237	f3 a4		 rep movsb
$LN15@sl_ds2:

; 1426 :     }
; 1427 : 
; 1428 :     /*
; 1429 :     || Logical record length
; 1430 :     */
; 1431 :     switch( lab->slds2.recfm[ 0 ] )

  00239	b8 01 00 00 00	 mov	 eax, 1
  0023e	48 6b c0 00	 imul	 rax, rax, 0
  00242	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  0024a	0f b6 44 01 04	 movzx	 eax, BYTE PTR [rcx+rax+4]
  0024f	88 44 24 28	 mov	 BYTE PTR tv188[rsp], al
  00253	80 7c 24 28 46	 cmp	 BYTE PTR tv188[rsp], 70	; 00000046H
  00258	74 17		 je	 SHORT $LN16@sl_ds2
  0025a	80 7c 24 28 55	 cmp	 BYTE PTR tv188[rsp], 85	; 00000055H
  0025f	0f 84 f2 00 00
	00		 je	 $LN28@sl_ds2
  00265	80 7c 24 28 56	 cmp	 BYTE PTR tv188[rsp], 86	; 00000056H
  0026a	74 79		 je	 SHORT $LN22@sl_ds2
  0026c	e9 fa 00 00 00	 jmp	 $LN5@sl_ds2
$LN16@sl_ds2:

; 1432 :     {
; 1433 :         case 'F':
; 1434 :             if( ( valfm[ i ].b == 'S' ) || ( valfm[ i ].b == ' ' ) )

  00271	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00276	48 6b c0 10	 imul	 rax, rax, 16
  0027a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:valfm
  00281	0f be 44 01 09	 movsx	 eax, BYTE PTR [rcx+rax+9]
  00286	83 f8 53	 cmp	 eax, 83			; 00000053H
  00289	74 1a		 je	 SHORT $LN19@sl_ds2
  0028b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00290	48 6b c0 10	 imul	 rax, rax, 16
  00294	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:valfm
  0029b	0f be 44 01 09	 movsx	 eax, BYTE PTR [rcx+rax+9]
  002a0	83 f8 20	 cmp	 eax, 32			; 00000020H
  002a3	75 1c		 jne	 SHORT $LN17@sl_ds2
$LN19@sl_ds2:

; 1435 :             {
; 1436 :                 if( lrecl != blksize )

  002a5	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR blksize$[rsp]
  002ac	39 84 24 d8 00
	00 00		 cmp	 DWORD PTR lrecl$[rsp], eax
  002b3	74 0a		 je	 SHORT $LN20@sl_ds2

; 1437 :                 {
; 1438 :                     return( SLE_LRECL );

  002b5	b8 fb ff ff ff	 mov	 eax, -5
  002ba	e9 5d 03 00 00	 jmp	 $LN1@sl_ds2
$LN20@sl_ds2:

; 1439 :                 }
; 1440 :             }

  002bf	eb 1f		 jmp	 SHORT $LN18@sl_ds2
$LN17@sl_ds2:

; 1441 :             else
; 1442 :             {
; 1443 :                 if( ( blksize % lrecl ) != 0 )

  002c1	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR blksize$[rsp]
  002c8	99		 cdq
  002c9	f7 bc 24 d8 00
	00 00		 idiv	 DWORD PTR lrecl$[rsp]
  002d0	8b c2		 mov	 eax, edx
  002d2	85 c0		 test	 eax, eax
  002d4	74 0a		 je	 SHORT $LN21@sl_ds2

; 1444 :                 {
; 1445 :                     return( SLE_LRECL );

  002d6	b8 fb ff ff ff	 mov	 eax, -5
  002db	e9 3c 03 00 00	 jmp	 $LN1@sl_ds2
$LN21@sl_ds2:
$LN18@sl_ds2:

; 1446 :                 }
; 1447 :             }
; 1448 :         break;

  002e0	e9 86 00 00 00	 jmp	 $LN5@sl_ds2
$LN22@sl_ds2:

; 1449 : 
; 1450 :         case 'V':
; 1451 :             if( valfm[ i ].b == ' ' )

  002e5	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  002ea	48 6b c0 10	 imul	 rax, rax, 16
  002ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:valfm
  002f5	0f be 44 01 09	 movsx	 eax, BYTE PTR [rcx+rax+9]
  002fa	83 f8 20	 cmp	 eax, 32			; 00000020H
  002fd	75 1f		 jne	 SHORT $LN23@sl_ds2

; 1452 :             {
; 1453 :                 if( ( lrecl + 4 ) != blksize )

  002ff	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR lrecl$[rsp]
  00306	83 c0 04	 add	 eax, 4
  00309	3b 84 24 e0 00
	00 00		 cmp	 eax, DWORD PTR blksize$[rsp]
  00310	74 0a		 je	 SHORT $LN25@sl_ds2

; 1454 :                 {
; 1455 :                     return( SLE_LRECL );

  00312	b8 fb ff ff ff	 mov	 eax, -5
  00317	e9 00 03 00 00	 jmp	 $LN1@sl_ds2
$LN25@sl_ds2:

; 1456 :                 }
; 1457 :             }

  0031c	eb 37		 jmp	 SHORT $LN24@sl_ds2
$LN23@sl_ds2:

; 1458 :             else if( valfm[ i ].b == 'B' )

  0031e	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00323	48 6b c0 10	 imul	 rax, rax, 16
  00327	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:valfm
  0032e	0f be 44 01 09	 movsx	 eax, BYTE PTR [rcx+rax+9]
  00333	83 f8 42	 cmp	 eax, 66			; 00000042H
  00336	75 1d		 jne	 SHORT $LN26@sl_ds2

; 1459 :             {
; 1460 :                 if( ( lrecl + 4 ) > blksize )

  00338	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR lrecl$[rsp]
  0033f	83 c0 04	 add	 eax, 4
  00342	3b 84 24 e0 00
	00 00		 cmp	 eax, DWORD PTR blksize$[rsp]
  00349	7e 0a		 jle	 SHORT $LN27@sl_ds2

; 1461 :                 {
; 1462 :                     return( SLE_LRECL );

  0034b	b8 fb ff ff ff	 mov	 eax, -5
  00350	e9 c7 02 00 00	 jmp	 $LN1@sl_ds2
$LN27@sl_ds2:
$LN26@sl_ds2:
$LN24@sl_ds2:

; 1463 :                 }
; 1464 :             }
; 1465 :         break;

  00355	eb 14		 jmp	 SHORT $LN5@sl_ds2
$LN28@sl_ds2:

; 1466 : 
; 1467 :         case 'U':
; 1468 :             if( lrecl != 0 )

  00357	83 bc 24 d8 00
	00 00 00	 cmp	 DWORD PTR lrecl$[rsp], 0
  0035f	74 0a		 je	 SHORT $LN29@sl_ds2

; 1469 :             {
; 1470 :                 return( SLE_LRECL );

  00361	b8 fb ff ff ff	 mov	 eax, -5
  00366	e9 b1 02 00 00	 jmp	 $LN1@sl_ds2
$LN29@sl_ds2:
$LN5@sl_ds2:

; 1471 :             }
; 1472 :         break;
; 1473 :     }
; 1474 :     sprintf( wbuf, "%05u", lrecl );

  0036b	44 8b 84 24 d8
	00 00 00	 mov	 r8d, DWORD PTR lrecl$[rsp]
  00373	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159586
  0037a	48 8d 4c 24 40	 lea	 rcx, QWORD PTR wbuf$[rsp]
  0037f	e8 00 00 00 00	 call	 sprintf

; 1475 :     memcpy( lab->slds2.lrecl, wbuf, 5 );

  00384	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR lab$[rsp]
  0038c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR wbuf$[rsp]
  00391	48 8d 78 0a	 lea	 rdi, QWORD PTR [rax+10]
  00395	48 8b f1	 mov	 rsi, rcx
  00398	b9 05 00 00 00	 mov	 ecx, 5
  0039d	f3 a4		 rep movsb

; 1476 : 
; 1477 :     /*
; 1478 :     || Jobname and stepname
; 1479 :     */
; 1480 :     if( jobname != NULL )

  0039f	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR jobname$[rsp], 0
  003a8	74 5f		 je	 SHORT $LN30@sl_ds2

; 1481 :     {
; 1482 :         if( stepname == NULL )

  003aa	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR stepname$[rsp], 0
  003b3	75 0a		 jne	 SHORT $LN32@sl_ds2

; 1483 :         {
; 1484 :             return( SLE_STEPNAME );

  003b5	b8 f8 ff ff ff	 mov	 eax, -8
  003ba	e9 5d 02 00 00	 jmp	 $LN1@sl_ds2
$LN32@sl_ds2:

; 1485 :         }
; 1486 : 
; 1487 :         len = strlen( jobname );

  003bf	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR jobname$[rsp]
  003c7	e8 00 00 00 00	 call	 strlen
  003cc	48 89 44 24 30	 mov	 QWORD PTR len$[rsp], rax

; 1488 :         if( len > 8 )

  003d1	48 83 7c 24 30
	08		 cmp	 QWORD PTR len$[rsp], 8
  003d7	76 0a		 jbe	 SHORT $LN33@sl_ds2

; 1489 :         {
; 1490 :             return( SLE_JOBNAME );

  003d9	b8 fc ff ff ff	 mov	 eax, -4
  003de	e9 39 02 00 00	 jmp	 $LN1@sl_ds2
$LN33@sl_ds2:

; 1491 :         }
; 1492 : 
; 1493 :         len = strlen( stepname );

  003e3	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR stepname$[rsp]
  003eb	e8 00 00 00 00	 call	 strlen
  003f0	48 89 44 24 30	 mov	 QWORD PTR len$[rsp], rax

; 1494 :         if( len > 8 )

  003f5	48 83 7c 24 30
	08		 cmp	 QWORD PTR len$[rsp], 8
  003fb	76 0a		 jbe	 SHORT $LN34@sl_ds2

; 1495 :         {
; 1496 :             return( SLE_STEPNAME );

  003fd	b8 f8 ff ff ff	 mov	 eax, -8
  00402	e9 15 02 00 00	 jmp	 $LN1@sl_ds2
$LN34@sl_ds2:

; 1497 :         }
; 1498 :     }

  00407	eb 15		 jmp	 SHORT $LN31@sl_ds2
$LN30@sl_ds2:

; 1499 :     else
; 1500 :     {
; 1501 :         if( stepname != NULL )

  00409	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR stepname$[rsp], 0
  00412	74 0a		 je	 SHORT $LN35@sl_ds2

; 1502 :         {
; 1503 :             return( SLE_JOBNAME );

  00414	b8 fc ff ff ff	 mov	 eax, -4
  00419	e9 fe 01 00 00	 jmp	 $LN1@sl_ds2
$LN35@sl_ds2:
$LN31@sl_ds2:

; 1504 :         }
; 1505 :     }
; 1506 :     sprintf( wbuf, "%-8.8s/%-8.8s", jobname, stepname );

  0041e	4c 8b 8c 24 f0
	00 00 00	 mov	 r9, QWORD PTR stepname$[rsp]
  00426	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR jobname$[rsp]
  0042e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159593
  00435	48 8d 4c 24 40	 lea	 rcx, QWORD PTR wbuf$[rsp]
  0043a	e8 00 00 00 00	 call	 sprintf

; 1507 :     memcpy( lab->slds2.jobid, wbuf, 17 );

  0043f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR lab$[rsp]
  00447	48 8d 4c 24 40	 lea	 rcx, QWORD PTR wbuf$[rsp]
  0044c	48 8d 78 11	 lea	 rdi, QWORD PTR [rax+17]
  00450	48 8b f1	 mov	 rsi, rcx
  00453	b9 11 00 00 00	 mov	 ecx, 17
  00458	f3 a4		 rep movsb

; 1508 : 
; 1509 :     /*
; 1510 :     || Density
; 1511 :     */
; 1512 :     lab->slds2.den[ 0 ] = '0';

  0045a	b8 01 00 00 00	 mov	 eax, 1
  0045f	48 6b c0 00	 imul	 rax, rax, 0
  00463	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  0046b	c6 44 01 0f 30	 mov	 BYTE PTR [rcx+rax+15], 48 ; 00000030H

; 1513 : 
; 1514 :     /*
; 1515 :     || Dataset position
; 1516 :     */
; 1517 :     lab->slds2.dspos[ 0 ] = '0';

  00470	b8 01 00 00 00	 mov	 eax, 1
  00475	48 6b c0 00	 imul	 rax, rax, 0
  00479	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  00481	c6 44 01 10 30	 mov	 BYTE PTR [rcx+rax+16], 48 ; 00000030H

; 1518 : 
; 1519 :     /*
; 1520 :     || Tape recording technique
; 1521 :     */
; 1522 :     if( trtch != NULL )

  00486	48 83 bc 24 f8
	00 00 00 00	 cmp	 QWORD PTR trtch$[rsp], 0
  0048f	0f 84 25 01 00
	00		 je	 $LN36@sl_ds2

; 1523 :     {
; 1524 :         len = strlen( trtch );

  00495	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR trtch$[rsp]
  0049d	e8 00 00 00 00	 call	 strlen
  004a2	48 89 44 24 30	 mov	 QWORD PTR len$[rsp], rax

; 1525 :         if( len < 1 || len > 2 )

  004a7	48 83 7c 24 30
	01		 cmp	 QWORD PTR len$[rsp], 1
  004ad	72 08		 jb	 SHORT $LN38@sl_ds2
  004af	48 83 7c 24 30
	02		 cmp	 QWORD PTR len$[rsp], 2
  004b5	76 0a		 jbe	 SHORT $LN37@sl_ds2
$LN38@sl_ds2:

; 1526 :         {
; 1527 :             return( SLE_TRTCH );

  004b7	b8 f7 ff ff ff	 mov	 eax, -9
  004bc	e9 5b 01 00 00	 jmp	 $LN1@sl_ds2
$LN37@sl_ds2:

; 1528 :         }
; 1529 : 
; 1530 :         switch( trtch[ 0 ] )

  004c1	b8 01 00 00 00	 mov	 eax, 1
  004c6	48 6b c0 00	 imul	 rax, rax, 0
  004ca	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR trtch$[rsp]
  004d2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004d6	88 44 24 24	 mov	 BYTE PTR tv272[rsp], al
  004da	80 7c 24 24 20	 cmp	 BYTE PTR tv272[rsp], 32	; 00000020H
  004df	74 21		 je	 SHORT $LN42@sl_ds2
  004e1	80 7c 24 24 43	 cmp	 BYTE PTR tv272[rsp], 67	; 00000043H
  004e6	74 1a		 je	 SHORT $LN40@sl_ds2
  004e8	80 7c 24 24 45	 cmp	 BYTE PTR tv272[rsp], 69	; 00000045H
  004ed	74 42		 je	 SHORT $LN43@sl_ds2
  004ef	80 7c 24 24 50	 cmp	 BYTE PTR tv272[rsp], 80	; 00000050H
  004f4	74 0c		 je	 SHORT $LN41@sl_ds2
  004f6	80 7c 24 24 54	 cmp	 BYTE PTR tv272[rsp], 84	; 00000054H
  004fb	74 05		 je	 SHORT $LN39@sl_ds2
  004fd	e9 b1 00 00 00	 jmp	 $LN46@sl_ds2
$LN39@sl_ds2:
$LN40@sl_ds2:
$LN41@sl_ds2:
$LN42@sl_ds2:

; 1531 :         {
; 1532 :             case 'T': case 'C': case 'P': case ' ':
; 1533 :                 lab->slds2.trtch[ 0 ] = trtch[ 0 ];

  00502	b8 01 00 00 00	 mov	 eax, 1
  00507	48 6b c0 00	 imul	 rax, rax, 0
  0050b	b9 01 00 00 00	 mov	 ecx, 1
  00510	48 6b c9 00	 imul	 rcx, rcx, 0
  00514	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR lab$[rsp]
  0051c	48 8b bc 24 f8
	00 00 00	 mov	 rdi, QWORD PTR trtch$[rsp]
  00524	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  00528	88 44 0a 22	 mov	 BYTE PTR [rdx+rcx+34], al

; 1534 :             break;

  0052c	e9 89 00 00 00	 jmp	 $LN7@sl_ds2
$LN43@sl_ds2:

; 1535 : 
; 1536 :             case 'E':
; 1537 :                 lab->slds2.trtch[ 0 ] = trtch[ 0 ];

  00531	b8 01 00 00 00	 mov	 eax, 1
  00536	48 6b c0 00	 imul	 rax, rax, 0
  0053a	b9 01 00 00 00	 mov	 ecx, 1
  0053f	48 6b c9 00	 imul	 rcx, rcx, 0
  00543	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR lab$[rsp]
  0054b	48 8b bc 24 f8
	00 00 00	 mov	 rdi, QWORD PTR trtch$[rsp]
  00553	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  00557	88 44 0a 22	 mov	 BYTE PTR [rdx+rcx+34], al

; 1538 :                 if( len == 2 )

  0055b	48 83 7c 24 30
	02		 cmp	 QWORD PTR len$[rsp], 2
  00561	75 4e		 jne	 SHORT $LN44@sl_ds2

; 1539 :                 {
; 1540 :                     if( trtch[ 1 ] != 'T' )

  00563	b8 01 00 00 00	 mov	 eax, 1
  00568	48 6b c0 01	 imul	 rax, rax, 1
  0056c	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR trtch$[rsp]
  00574	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00578	83 f8 54	 cmp	 eax, 84			; 00000054H
  0057b	74 0a		 je	 SHORT $LN45@sl_ds2

; 1541 :                     {
; 1542 :                         return( SLE_TRTCH );

  0057d	b8 f7 ff ff ff	 mov	 eax, -9
  00582	e9 95 00 00 00	 jmp	 $LN1@sl_ds2
$LN45@sl_ds2:

; 1543 :                     }
; 1544 :                     lab->slds2.trtch[ 1 ] = trtch[ 1 ];

  00587	b8 01 00 00 00	 mov	 eax, 1
  0058c	48 6b c0 01	 imul	 rax, rax, 1
  00590	b9 01 00 00 00	 mov	 ecx, 1
  00595	48 6b c9 01	 imul	 rcx, rcx, 1
  00599	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR lab$[rsp]
  005a1	48 8b bc 24 f8
	00 00 00	 mov	 rdi, QWORD PTR trtch$[rsp]
  005a9	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  005ad	88 44 0a 22	 mov	 BYTE PTR [rdx+rcx+34], al
$LN44@sl_ds2:

; 1545 :                 }
; 1546 :             break;

  005b1	eb 07		 jmp	 SHORT $LN7@sl_ds2
$LN46@sl_ds2:

; 1547 : 
; 1548 :             default:
; 1549 :                 return( SLE_TRTCH );

  005b3	b8 f7 ff ff ff	 mov	 eax, -9
  005b8	eb 62		 jmp	 SHORT $LN1@sl_ds2
$LN7@sl_ds2:
$LN36@sl_ds2:

; 1550 :         }
; 1551 :     }
; 1552 : 
; 1553 :     /*
; 1554 :     || Device serial number
; 1555 :     */
; 1556 :     sprintf( wbuf, "%06u", rand() );

  005ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  005c0	44 8b c0	 mov	 r8d, eax
  005c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159605
  005ca	48 8d 4c 24 40	 lea	 rcx, QWORD PTR wbuf$[rsp]
  005cf	e8 00 00 00 00	 call	 sprintf

; 1557 :     memcpy( lab->slds2.devser, wbuf, 6 );

  005d4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR lab$[rsp]
  005dc	48 8d 4c 24 40	 lea	 rcx, QWORD PTR wbuf$[rsp]
  005e1	48 8d 78 29	 lea	 rdi, QWORD PTR [rax+41]
  005e5	48 8b f1	 mov	 rsi, rcx
  005e8	b9 06 00 00 00	 mov	 ecx, 6
  005ed	f3 a4		 rep movsb

; 1558 : 
; 1559 :     /*
; 1560 :     || Checkpoint dataset identifier
; 1561 :     */
; 1562 :     lab->slds2.ckptid[ 0 ] = ' ';

  005ef	b8 01 00 00 00	 mov	 eax, 1
  005f4	48 6b c0 00	 imul	 rax, rax, 0
  005f8	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  00600	c6 44 01 2f 20	 mov	 BYTE PTR [rcx+rax+47], 32 ; 00000020H

; 1563 : 
; 1564 :     /*
; 1565 :     || Convert to EBCDIC
; 1566 :     */
; 1567 :     sl_atoe( NULL, lab, sizeof( SLLABEL ) );

  00605	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  0060b	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR lab$[rsp]
  00613	33 c9		 xor	 ecx, ecx
  00615	e8 00 00 00 00	 call	 sl_atoe

; 1568 : 
; 1569 :     return 0;

  0061a	33 c0		 xor	 eax, eax
$LN1@sl_ds2:

; 1570 : }

  0061c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00624	48 33 cc	 xor	 rcx, rsp
  00627	e8 00 00 00 00	 call	 __security_check_cookie
  0062c	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00633	5f		 pop	 rdi
  00634	5e		 pop	 rsi
  00635	c3		 ret	 0
sl_ds2	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sllib.c
_TEXT	SEGMENT
gdg$ = 32
len$ = 40
tv149 = 48
tv156 = 52
tv165 = 56
tv174 = 60
tv183 = 64
tv192 = 68
tv199 = 72
tv208 = 76
tv217 = 80
ndx$ = 88
wbuf$ = 96
__$ArrayPad$ = 176
lab$ = 224
type$ = 232
dsn$ = 240
volser$ = 248
volseq$ = 256
dsseq$ = 264
expdt$ = 272
blocks$ = 280
sl_ds1	PROC

; 1106 : {

$LN31:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1107 :     int gdg;
; 1108 :     size_t len;
; 1109 :     size_t ndx;
; 1110 :     char wbuf[ 80 ];
; 1111 : 
; 1112 :     /*
; 1113 :     || Initialize
; 1114 :     */
; 1115 :     memset( lab, ' ', sizeof( SLLABEL ) );

  0002e	48 8b bc 24 e0
	00 00 00	 mov	 rdi, QWORD PTR lab$[rsp]
  00036	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  0003b	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00040	f3 aa		 rep stosb

; 1116 : 
; 1117 :     /*
; 1118 :     || Label ID
; 1119 :     */
; 1120 :     if( ( type != SLT_HDR ) && ( type != SLT_EOF ) && ( type != SLT_EOV ) )

  00042	83 bc 24 e8 00
	00 00 02	 cmp	 DWORD PTR type$[rsp], 2
  0004a	74 1e		 je	 SHORT $LN2@sl_ds1
  0004c	83 bc 24 e8 00
	00 00 04	 cmp	 DWORD PTR type$[rsp], 4
  00054	74 14		 je	 SHORT $LN2@sl_ds1
  00056	83 bc 24 e8 00
	00 00 05	 cmp	 DWORD PTR type$[rsp], 5
  0005e	74 0a		 je	 SHORT $LN2@sl_ds1

; 1121 :     {
; 1122 :         return( SLE_INVALIDTYPE );

  00060	b8 f3 ff ff ff	 mov	 eax, -13
  00065	e9 7e 05 00 00	 jmp	 $LN1@sl_ds1
$LN2@sl_ds1:

; 1123 :     }
; 1124 :     memcpy( lab->id, sl_alabs[ type ], 3 );

  0006a	48 63 84 24 e8
	00 00 00	 movsxd	 rax, DWORD PTR type$[rsp]
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sl_alabs
  00079	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0007d	48 8b bc 24 e0
	00 00 00	 mov	 rdi, QWORD PTR lab$[rsp]
  00085	48 8b f0	 mov	 rsi, rax
  00088	b9 03 00 00 00	 mov	 ecx, 3
  0008d	f3 a4		 rep movsb

; 1125 : 
; 1126 :     /*
; 1127 :     || Label number
; 1128 :     */
; 1129 :     lab->num[ 0 ] = '1';

  0008f	b8 01 00 00 00	 mov	 eax, 1
  00094	48 6b c0 00	 imul	 rax, rax, 0
  00098	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  000a0	c6 44 01 03 31	 mov	 BYTE PTR [rcx+rax+3], 49 ; 00000031H

; 1130 : 
; 1131 :     /*
; 1132 :     || Special IEHINITT dataset name?
; 1133 :     */
; 1134 :     if( ( type == SLT_HDR ) && ( strcmp( dsn, SL_INITDSN ) == 0 ) )

  000a5	83 bc 24 e8 00
	00 00 02	 cmp	 DWORD PTR type$[rsp], 2
  000ad	75 4f		 jne	 SHORT $LN3@sl_ds1
  000af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159512
  000b6	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dsn$[rsp]
  000be	e8 00 00 00 00	 call	 strcmp
  000c3	85 c0		 test	 eax, eax
  000c5	75 37		 jne	 SHORT $LN3@sl_ds1

; 1135 :     {
; 1136 :         memset( &lab->slds1, '0', sizeof( lab->slds1 ) );

  000c7	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR lab$[rsp]
  000cf	48 83 c0 04	 add	 rax, 4
  000d3	48 8b f8	 mov	 rdi, rax
  000d6	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  000db	b9 4c 00 00 00	 mov	 ecx, 76			; 0000004cH
  000e0	f3 aa		 rep stosb

; 1137 :         sl_atoe( NULL, lab, sizeof( SLLABEL ) );

  000e2	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  000e8	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR lab$[rsp]
  000f0	33 c9		 xor	 ecx, ecx
  000f2	e8 00 00 00 00	 call	 sl_atoe

; 1138 :         return( 0 );

  000f7	33 c0		 xor	 eax, eax
  000f9	e9 ea 04 00 00	 jmp	 $LN1@sl_ds1
$LN3@sl_ds1:

; 1139 :     }
; 1140 : 
; 1141 :     /*
; 1142 :     || Dataset ID
; 1143 :     */
; 1144 :     ndx = 0;

  000fe	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR ndx$[rsp], 0

; 1145 :     len = strlen( dsn );

  00107	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dsn$[rsp]
  0010f	e8 00 00 00 00	 call	 strlen
  00114	48 89 44 24 28	 mov	 QWORD PTR len$[rsp], rax

; 1146 :     if( len > 17 )

  00119	48 83 7c 24 28
	11		 cmp	 QWORD PTR len$[rsp], 17
  0011f	76 17		 jbe	 SHORT $LN4@sl_ds1

; 1147 :     {
; 1148 :         ndx = len - 17;

  00121	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  00126	48 83 e8 11	 sub	 rax, 17
  0012a	48 89 44 24 58	 mov	 QWORD PTR ndx$[rsp], rax

; 1149 :         len = 17;

  0012f	48 c7 44 24 28
	11 00 00 00	 mov	 QWORD PTR len$[rsp], 17
$LN4@sl_ds1:

; 1150 :     }
; 1151 :     memcpy( lab->slds1.dsid, &dsn[ ndx ], len );

  00138	48 8b 44 24 58	 mov	 rax, QWORD PTR ndx$[rsp]
  0013d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dsn$[rsp]
  00145	48 03 c8	 add	 rcx, rax
  00148	48 8b c1	 mov	 rax, rcx
  0014b	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  00153	48 83 c1 04	 add	 rcx, 4
  00157	48 8b f9	 mov	 rdi, rcx
  0015a	48 8b f0	 mov	 rsi, rax
  0015d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR len$[rsp]
  00162	f3 a4		 rep movsb

; 1152 : 
; 1153 :     /*
; 1154 :     || GDG generation and version
; 1155 :     */
; 1156 :     if( len > 9 )

  00164	48 83 7c 24 28
	09		 cmp	 QWORD PTR len$[rsp], 9
  0016a	0f 86 ab 02 00
	00		 jbe	 $LN5@sl_ds1

; 1157 :     {
; 1158 :         gdg  = 0;

  00170	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR gdg$[rsp], 0

; 1159 :         gdg += (          dsn[ len - 9 ]   == '.' );

  00178	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  0017d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dsn$[rsp]
  00185	48 03 c8	 add	 rcx, rax
  00188	48 8b c1	 mov	 rax, rcx
  0018b	0f be 40 f7	 movsx	 eax, BYTE PTR [rax-9]
  0018f	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00192	75 0a		 jne	 SHORT $LN13@sl_ds1
  00194	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv149[rsp], 1
  0019c	eb 08		 jmp	 SHORT $LN14@sl_ds1
$LN13@sl_ds1:
  0019e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv149[rsp], 0
$LN14@sl_ds1:
  001a6	8b 44 24 30	 mov	 eax, DWORD PTR tv149[rsp]
  001aa	8b 4c 24 20	 mov	 ecx, DWORD PTR gdg$[rsp]
  001ae	03 c8		 add	 ecx, eax
  001b0	8b c1		 mov	 eax, ecx
  001b2	89 44 24 20	 mov	 DWORD PTR gdg$[rsp], eax

; 1160 :         gdg += (          dsn[ len - 8 ]   == 'G' );

  001b6	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  001bb	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dsn$[rsp]
  001c3	48 03 c8	 add	 rcx, rax
  001c6	48 8b c1	 mov	 rax, rcx
  001c9	0f be 40 f8	 movsx	 eax, BYTE PTR [rax-8]
  001cd	83 f8 47	 cmp	 eax, 71			; 00000047H
  001d0	75 0a		 jne	 SHORT $LN15@sl_ds1
  001d2	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv156[rsp], 1
  001da	eb 08		 jmp	 SHORT $LN16@sl_ds1
$LN15@sl_ds1:
  001dc	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv156[rsp], 0
$LN16@sl_ds1:
  001e4	8b 44 24 34	 mov	 eax, DWORD PTR tv156[rsp]
  001e8	8b 4c 24 20	 mov	 ecx, DWORD PTR gdg$[rsp]
  001ec	03 c8		 add	 ecx, eax
  001ee	8b c1		 mov	 eax, ecx
  001f0	89 44 24 20	 mov	 DWORD PTR gdg$[rsp], eax

; 1161 :         gdg += ( isdigit( dsn[ len - 7 ] ) !=  0  );

  001f4	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  001f9	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dsn$[rsp]
  00201	48 03 c8	 add	 rcx, rax
  00204	48 8b c1	 mov	 rax, rcx
  00207	0f be 40 f9	 movsx	 eax, BYTE PTR [rax-7]
  0020b	8b c8		 mov	 ecx, eax
  0020d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  00213	85 c0		 test	 eax, eax
  00215	74 0a		 je	 SHORT $LN17@sl_ds1
  00217	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv165[rsp], 1
  0021f	eb 08		 jmp	 SHORT $LN18@sl_ds1
$LN17@sl_ds1:
  00221	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv165[rsp], 0
$LN18@sl_ds1:
  00229	8b 44 24 38	 mov	 eax, DWORD PTR tv165[rsp]
  0022d	8b 4c 24 20	 mov	 ecx, DWORD PTR gdg$[rsp]
  00231	03 c8		 add	 ecx, eax
  00233	8b c1		 mov	 eax, ecx
  00235	89 44 24 20	 mov	 DWORD PTR gdg$[rsp], eax

; 1162 :         gdg += ( isdigit( dsn[ len - 6 ] ) !=  0  );

  00239	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  0023e	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dsn$[rsp]
  00246	48 03 c8	 add	 rcx, rax
  00249	48 8b c1	 mov	 rax, rcx
  0024c	0f be 40 fa	 movsx	 eax, BYTE PTR [rax-6]
  00250	8b c8		 mov	 ecx, eax
  00252	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  00258	85 c0		 test	 eax, eax
  0025a	74 0a		 je	 SHORT $LN19@sl_ds1
  0025c	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
  00264	eb 08		 jmp	 SHORT $LN20@sl_ds1
$LN19@sl_ds1:
  00266	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
$LN20@sl_ds1:
  0026e	8b 44 24 3c	 mov	 eax, DWORD PTR tv174[rsp]
  00272	8b 4c 24 20	 mov	 ecx, DWORD PTR gdg$[rsp]
  00276	03 c8		 add	 ecx, eax
  00278	8b c1		 mov	 eax, ecx
  0027a	89 44 24 20	 mov	 DWORD PTR gdg$[rsp], eax

; 1163 :         gdg += ( isdigit( dsn[ len - 5 ] ) !=  0  );

  0027e	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  00283	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dsn$[rsp]
  0028b	48 03 c8	 add	 rcx, rax
  0028e	48 8b c1	 mov	 rax, rcx
  00291	0f be 40 fb	 movsx	 eax, BYTE PTR [rax-5]
  00295	8b c8		 mov	 ecx, eax
  00297	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  0029d	85 c0		 test	 eax, eax
  0029f	74 0a		 je	 SHORT $LN21@sl_ds1
  002a1	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv183[rsp], 1
  002a9	eb 08		 jmp	 SHORT $LN22@sl_ds1
$LN21@sl_ds1:
  002ab	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv183[rsp], 0
$LN22@sl_ds1:
  002b3	8b 44 24 40	 mov	 eax, DWORD PTR tv183[rsp]
  002b7	8b 4c 24 20	 mov	 ecx, DWORD PTR gdg$[rsp]
  002bb	03 c8		 add	 ecx, eax
  002bd	8b c1		 mov	 eax, ecx
  002bf	89 44 24 20	 mov	 DWORD PTR gdg$[rsp], eax

; 1164 :         gdg += ( isdigit( dsn[ len - 4 ] ) !=  0  );

  002c3	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  002c8	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dsn$[rsp]
  002d0	48 03 c8	 add	 rcx, rax
  002d3	48 8b c1	 mov	 rax, rcx
  002d6	0f be 40 fc	 movsx	 eax, BYTE PTR [rax-4]
  002da	8b c8		 mov	 ecx, eax
  002dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  002e2	85 c0		 test	 eax, eax
  002e4	74 0a		 je	 SHORT $LN23@sl_ds1
  002e6	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv192[rsp], 1
  002ee	eb 08		 jmp	 SHORT $LN24@sl_ds1
$LN23@sl_ds1:
  002f0	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv192[rsp], 0
$LN24@sl_ds1:
  002f8	8b 44 24 44	 mov	 eax, DWORD PTR tv192[rsp]
  002fc	8b 4c 24 20	 mov	 ecx, DWORD PTR gdg$[rsp]
  00300	03 c8		 add	 ecx, eax
  00302	8b c1		 mov	 eax, ecx
  00304	89 44 24 20	 mov	 DWORD PTR gdg$[rsp], eax

; 1165 :         gdg += (          dsn[ len - 3 ]   == 'V' );

  00308	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  0030d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dsn$[rsp]
  00315	48 03 c8	 add	 rcx, rax
  00318	48 8b c1	 mov	 rax, rcx
  0031b	0f be 40 fd	 movsx	 eax, BYTE PTR [rax-3]
  0031f	83 f8 56	 cmp	 eax, 86			; 00000056H
  00322	75 0a		 jne	 SHORT $LN25@sl_ds1
  00324	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv199[rsp], 1
  0032c	eb 08		 jmp	 SHORT $LN26@sl_ds1
$LN25@sl_ds1:
  0032e	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv199[rsp], 0
$LN26@sl_ds1:
  00336	8b 44 24 48	 mov	 eax, DWORD PTR tv199[rsp]
  0033a	8b 4c 24 20	 mov	 ecx, DWORD PTR gdg$[rsp]
  0033e	03 c8		 add	 ecx, eax
  00340	8b c1		 mov	 eax, ecx
  00342	89 44 24 20	 mov	 DWORD PTR gdg$[rsp], eax

; 1166 :         gdg += ( isdigit( dsn[ len - 2 ] ) !=  0  );

  00346	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  0034b	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dsn$[rsp]
  00353	48 03 c8	 add	 rcx, rax
  00356	48 8b c1	 mov	 rax, rcx
  00359	0f be 40 fe	 movsx	 eax, BYTE PTR [rax-2]
  0035d	8b c8		 mov	 ecx, eax
  0035f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  00365	85 c0		 test	 eax, eax
  00367	74 0a		 je	 SHORT $LN27@sl_ds1
  00369	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv208[rsp], 1
  00371	eb 08		 jmp	 SHORT $LN28@sl_ds1
$LN27@sl_ds1:
  00373	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv208[rsp], 0
$LN28@sl_ds1:
  0037b	8b 44 24 4c	 mov	 eax, DWORD PTR tv208[rsp]
  0037f	8b 4c 24 20	 mov	 ecx, DWORD PTR gdg$[rsp]
  00383	03 c8		 add	 ecx, eax
  00385	8b c1		 mov	 eax, ecx
  00387	89 44 24 20	 mov	 DWORD PTR gdg$[rsp], eax

; 1167 :         gdg += ( isdigit( dsn[ len - 1 ] ) !=  0  );

  0038b	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  00390	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dsn$[rsp]
  00398	48 03 c8	 add	 rcx, rax
  0039b	48 8b c1	 mov	 rax, rcx
  0039e	0f be 40 ff	 movsx	 eax, BYTE PTR [rax-1]
  003a2	8b c8		 mov	 ecx, eax
  003a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  003aa	85 c0		 test	 eax, eax
  003ac	74 0a		 je	 SHORT $LN29@sl_ds1
  003ae	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv217[rsp], 1
  003b6	eb 08		 jmp	 SHORT $LN30@sl_ds1
$LN29@sl_ds1:
  003b8	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv217[rsp], 0
$LN30@sl_ds1:
  003c0	8b 44 24 50	 mov	 eax, DWORD PTR tv217[rsp]
  003c4	8b 4c 24 20	 mov	 ecx, DWORD PTR gdg$[rsp]
  003c8	03 c8		 add	 ecx, eax
  003ca	8b c1		 mov	 eax, ecx
  003cc	89 44 24 20	 mov	 DWORD PTR gdg$[rsp], eax

; 1168 : 
; 1169 :         if( gdg == 9 )

  003d0	83 7c 24 20 09	 cmp	 DWORD PTR gdg$[rsp], 9
  003d5	75 44		 jne	 SHORT $LN6@sl_ds1

; 1170 :         {
; 1171 :             memcpy( lab->slds1.genno, &dsn[ len - 7 ], 4 );

  003d7	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  003dc	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dsn$[rsp]
  003e4	48 03 c8	 add	 rcx, rax
  003e7	48 8b c1	 mov	 rax, rcx
  003ea	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  003f2	8b 40 f9	 mov	 eax, DWORD PTR [rax-7]
  003f5	89 41 23	 mov	 DWORD PTR [rcx+35], eax

; 1172 :             memcpy( lab->slds1.verno, &dsn[ len - 2 ], 2 );

  003f8	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  003fd	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dsn$[rsp]
  00405	48 03 c8	 add	 rcx, rax
  00408	48 8b c1	 mov	 rax, rcx
  0040b	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  00413	0f b7 40 fe	 movzx	 eax, WORD PTR [rax-2]
  00417	66 89 41 27	 mov	 WORD PTR [rcx+39], ax
$LN6@sl_ds1:
$LN5@sl_ds1:

; 1173 :         }
; 1174 :     }
; 1175 : 
; 1176 :     /*
; 1177 :     || Volser
; 1178 :     */
; 1179 :     len = strlen( volser );

  0041b	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR volser$[rsp]
  00423	e8 00 00 00 00	 call	 strlen
  00428	48 89 44 24 28	 mov	 QWORD PTR len$[rsp], rax

; 1180 :     if( len > 6 )

  0042d	48 83 7c 24 28
	06		 cmp	 QWORD PTR len$[rsp], 6
  00433	76 0a		 jbe	 SHORT $LN7@sl_ds1

; 1181 :     {
; 1182 :         return( SLE_VOLSER );

  00435	b8 f5 ff ff ff	 mov	 eax, -11
  0043a	e9 a9 01 00 00	 jmp	 $LN1@sl_ds1
$LN7@sl_ds1:

; 1183 :     }
; 1184 :     memcpy( lab->slds1.volser, volser, len );

  0043f	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR lab$[rsp]
  00447	48 83 c0 15	 add	 rax, 21
  0044b	48 8b f8	 mov	 rdi, rax
  0044e	48 8b b4 24 f8
	00 00 00	 mov	 rsi, QWORD PTR volser$[rsp]
  00456	48 8b 4c 24 28	 mov	 rcx, QWORD PTR len$[rsp]
  0045b	f3 a4		 rep movsb

; 1185 : 
; 1186 :     /*
; 1187 :     || Volume sequence
; 1188 :     */
; 1189 :     if( volseq > 9999 )

  0045d	81 bc 24 00 01
	00 00 0f 27 00
	00		 cmp	 DWORD PTR volseq$[rsp], 9999 ; 0000270fH
  00468	7e 0a		 jle	 SHORT $LN8@sl_ds1

; 1190 :     {
; 1191 :         return( SLE_VOLSEQ );

  0046a	b8 f6 ff ff ff	 mov	 eax, -10
  0046f	e9 74 01 00 00	 jmp	 $LN1@sl_ds1
$LN8@sl_ds1:

; 1192 :     }
; 1193 :     sprintf( wbuf, "%04u", volseq );

  00474	44 8b 84 24 00
	01 00 00	 mov	 r8d, DWORD PTR volseq$[rsp]
  0047c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159518
  00483	48 8d 4c 24 60	 lea	 rcx, QWORD PTR wbuf$[rsp]
  00488	e8 00 00 00 00	 call	 sprintf

; 1194 :     memcpy( lab->slds1.volseq, wbuf, 4 );

  0048d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR lab$[rsp]
  00495	8b 4c 24 60	 mov	 ecx, DWORD PTR wbuf$[rsp]
  00499	89 48 1b	 mov	 DWORD PTR [rax+27], ecx

; 1195 : 
; 1196 :     /*
; 1197 :     || Dataset sequence
; 1198 :     */
; 1199 :     if( dsseq > 9999 )

  0049c	81 bc 24 08 01
	00 00 0f 27 00
	00		 cmp	 DWORD PTR dsseq$[rsp], 9999 ; 0000270fH
  004a7	7e 0a		 jle	 SHORT $LN9@sl_ds1

; 1200 :     {
; 1201 :         return( SLE_DSSEQ );

  004a9	b8 fe ff ff ff	 mov	 eax, -2
  004ae	e9 35 01 00 00	 jmp	 $LN1@sl_ds1
$LN9@sl_ds1:

; 1202 :     }
; 1203 :     sprintf( wbuf, "%04u", dsseq );

  004b3	44 8b 84 24 08
	01 00 00	 mov	 r8d, DWORD PTR dsseq$[rsp]
  004bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159520
  004c2	48 8d 4c 24 60	 lea	 rcx, QWORD PTR wbuf$[rsp]
  004c7	e8 00 00 00 00	 call	 sprintf

; 1204 :     memcpy( lab->slds1.dsseq, wbuf, 4 );

  004cc	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR lab$[rsp]
  004d4	8b 4c 24 60	 mov	 ecx, DWORD PTR wbuf$[rsp]
  004d8	89 48 1f	 mov	 DWORD PTR [rax+31], ecx

; 1205 : 
; 1206 :     /*
; 1207 :     || Creation Date
; 1208 :     */
; 1209 :     sl_fmtdate( lab->slds1.crtdt, NULL, FALSE );

  004db	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR lab$[rsp]
  004e3	48 83 c0 29	 add	 rax, 41			; 00000029H
  004e7	45 33 c0	 xor	 r8d, r8d
  004ea	33 d2		 xor	 edx, edx
  004ec	48 8b c8	 mov	 rcx, rax
  004ef	e8 00 00 00 00	 call	 sl_fmtdate

; 1210 : 
; 1211 :     /*
; 1212 :     || Expiration Date
; 1213 :     */
; 1214 :     if( sl_fmtdate( lab->slds1.expdt, expdt, FALSE ) == NULL )

  004f4	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR lab$[rsp]
  004fc	48 83 c0 2f	 add	 rax, 47			; 0000002fH
  00500	45 33 c0	 xor	 r8d, r8d
  00503	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR expdt$[rsp]
  0050b	48 8b c8	 mov	 rcx, rax
  0050e	e8 00 00 00 00	 call	 sl_fmtdate
  00513	48 85 c0	 test	 rax, rax
  00516	75 0a		 jne	 SHORT $LN10@sl_ds1

; 1215 :     {
; 1216 :         return( SLE_EXPDT );

  00518	b8 fd ff ff ff	 mov	 eax, -3
  0051d	e9 c6 00 00 00	 jmp	 $LN1@sl_ds1
$LN10@sl_ds1:

; 1217 :     }
; 1218 : 
; 1219 :     /*
; 1220 :     || Dataset security
; 1221 :     */
; 1222 :     memset( lab->slds1.dssec, '0', 1 );

  00522	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR lab$[rsp]
  0052a	48 83 c0 35	 add	 rax, 53			; 00000035H
  0052e	48 8b f8	 mov	 rdi, rax
  00531	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  00536	b9 01 00 00 00	 mov	 ecx, 1
  0053b	f3 aa		 rep stosb

; 1223 : 
; 1224 :     /*
; 1225 :     || Block count - low
; 1226 :     */
; 1227 :     if( type == SLT_HDR )

  0053d	83 bc 24 e8 00
	00 00 02	 cmp	 DWORD PTR type$[rsp], 2
  00545	75 0b		 jne	 SHORT $LN11@sl_ds1

; 1228 :     {
; 1229 :         blocks = 0;

  00547	c7 84 24 18 01
	00 00 00 00 00
	00		 mov	 DWORD PTR blocks$[rsp], 0
$LN11@sl_ds1:

; 1230 :     }
; 1231 :     sprintf( wbuf, "%010u", blocks );

  00552	44 8b 84 24 18
	01 00 00	 mov	 r8d, DWORD PTR blocks$[rsp]
  0055a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159523
  00561	48 8d 4c 24 60	 lea	 rcx, QWORD PTR wbuf$[rsp]
  00566	e8 00 00 00 00	 call	 sprintf

; 1232 :     memcpy( lab->slds1.blklo, &wbuf[ 4 ], 6 );

  0056b	b8 01 00 00 00	 mov	 eax, 1
  00570	48 6b c0 04	 imul	 rax, rax, 4
  00574	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  0057c	48 8d 79 36	 lea	 rdi, QWORD PTR [rcx+54]
  00580	48 8d 74 04 60	 lea	 rsi, QWORD PTR wbuf$[rsp+rax]
  00585	b9 06 00 00 00	 mov	 ecx, 6
  0058a	f3 a4		 rep movsb

; 1233 : 
; 1234 :     /*
; 1235 :     || System code
; 1236 :     */
; 1237 :     memcpy( lab->slds1.syscd, "IBM OS/VS 370", 13 );

  0058c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR lab$[rsp]
  00594	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159524
  0059b	48 8d 78 3c	 lea	 rdi, QWORD PTR [rax+60]
  0059f	48 8b f1	 mov	 rsi, rcx
  005a2	b9 0d 00 00 00	 mov	 ecx, 13
  005a7	f3 a4		 rep movsb

; 1238 : 
; 1239 :     /*
; 1240 :     || Block count - high
; 1241 :     */
; 1242 :     sprintf( wbuf, "%10u", blocks );

  005a9	44 8b 84 24 18
	01 00 00	 mov	 r8d, DWORD PTR blocks$[rsp]
  005b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159525
  005b8	48 8d 4c 24 60	 lea	 rcx, QWORD PTR wbuf$[rsp]
  005bd	e8 00 00 00 00	 call	 sprintf

; 1243 :     memcpy( lab->slds1.blkhi, wbuf, 4 );

  005c2	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR lab$[rsp]
  005ca	8b 4c 24 60	 mov	 ecx, DWORD PTR wbuf$[rsp]
  005ce	89 48 4c	 mov	 DWORD PTR [rax+76], ecx

; 1244 : 
; 1245 :     /*
; 1246 :     || Convert to EBCDIC
; 1247 :     */
; 1248 :     sl_atoe( NULL, lab, sizeof( SLLABEL ) );

  005d1	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  005d7	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR lab$[rsp]
  005df	33 c9		 xor	 ecx, ecx
  005e1	e8 00 00 00 00	 call	 sl_atoe

; 1249 : 
; 1250 :     return 0;

  005e6	33 c0		 xor	 eax, eax
$LN1@sl_ds1:

; 1251 : }

  005e8	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005f0	48 33 cc	 xor	 rcx, rsp
  005f3	e8 00 00 00 00	 call	 __security_check_cookie
  005f8	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  005ff	5f		 pop	 rdi
  00600	5e		 pop	 rsi
  00601	c3		 ret	 0
sl_ds1	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sllib.c
_TEXT	SEGMENT
len$ = 32
lab$ = 80
volser$ = 88
owner$ = 96
sl_vol	PROC

; 954  : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 955  :     size_t len;
; 956  : 
; 957  :     /*
; 958  :     || Initialize
; 959  :     */
; 960  :     memset( lab, ' ', sizeof( SLLABEL ) );

  00015	48 8b 7c 24 50	 mov	 rdi, QWORD PTR lab$[rsp]
  0001a	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  0001f	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00024	f3 aa		 rep stosb

; 961  : 
; 962  :     /*
; 963  :     || Label ID
; 964  :     */
; 965  :     memcpy( lab->id, sl_alabs[ SLT_VOL ], 3 );

  00026	b8 08 00 00 00	 mov	 eax, 8
  0002b	48 6b c0 01	 imul	 rax, rax, 1
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sl_alabs
  00036	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0003a	48 8b 7c 24 50	 mov	 rdi, QWORD PTR lab$[rsp]
  0003f	48 8b f0	 mov	 rsi, rax
  00042	b9 03 00 00 00	 mov	 ecx, 3
  00047	f3 a4		 rep movsb

; 966  : 
; 967  :     /*
; 968  :     || Label number
; 969  :     */
; 970  :     lab->num[ 0 ] = '1';

  00049	b8 01 00 00 00	 mov	 eax, 1
  0004e	48 6b c0 00	 imul	 rax, rax, 0
  00052	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lab$[rsp]
  00057	c6 44 01 03 31	 mov	 BYTE PTR [rcx+rax+3], 49 ; 00000031H

; 971  : 
; 972  :     /*
; 973  :     || Volser
; 974  :     */
; 975  :     if( volser == NULL )

  0005c	48 83 7c 24 58
	00		 cmp	 QWORD PTR volser$[rsp], 0
  00062	75 0a		 jne	 SHORT $LN2@sl_vol

; 976  :     {
; 977  :         return( SLE_VOLSER );

  00064	b8 f5 ff ff ff	 mov	 eax, -11
  00069	e9 a1 00 00 00	 jmp	 $LN1@sl_vol
$LN2@sl_vol:

; 978  :     }
; 979  : 
; 980  :     len = strlen( volser );

  0006e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR volser$[rsp]
  00073	e8 00 00 00 00	 call	 strlen
  00078	48 89 44 24 20	 mov	 QWORD PTR len$[rsp], rax

; 981  :     if( ( len > 6 ) || ( strspn( volser, sl_cset ) != len ) )

  0007d	48 83 7c 24 20
	06		 cmp	 QWORD PTR len$[rsp], 6
  00083	77 19		 ja	 SHORT $LN4@sl_vol
  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:sl_cset
  0008c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR volser$[rsp]
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strspn
  00097	48 3b 44 24 20	 cmp	 rax, QWORD PTR len$[rsp]
  0009c	74 07		 je	 SHORT $LN3@sl_vol
$LN4@sl_vol:

; 982  :     {
; 983  :         return( SLE_VOLSER );

  0009e	b8 f5 ff ff ff	 mov	 eax, -11
  000a3	eb 6a		 jmp	 SHORT $LN1@sl_vol
$LN3@sl_vol:

; 984  :     }
; 985  : 
; 986  :     memcpy( lab->slvol.volser, volser, len );

  000a5	48 8b 44 24 50	 mov	 rax, QWORD PTR lab$[rsp]
  000aa	48 83 c0 04	 add	 rax, 4
  000ae	48 8b f8	 mov	 rdi, rax
  000b1	48 8b 74 24 58	 mov	 rsi, QWORD PTR volser$[rsp]
  000b6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR len$[rsp]
  000bb	f3 a4		 rep movsb

; 987  : 
; 988  :     /*
; 989  :     || Owner
; 990  :     */
; 991  :     if( owner != NULL )

  000bd	48 83 7c 24 60
	00		 cmp	 QWORD PTR owner$[rsp], 0
  000c3	74 36		 je	 SHORT $LN5@sl_vol

; 992  :     {
; 993  :         len = strlen( owner );

  000c5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR owner$[rsp]
  000ca	e8 00 00 00 00	 call	 strlen
  000cf	48 89 44 24 20	 mov	 QWORD PTR len$[rsp], rax

; 994  :         if( len > 10 )

  000d4	48 83 7c 24 20
	0a		 cmp	 QWORD PTR len$[rsp], 10
  000da	76 07		 jbe	 SHORT $LN6@sl_vol

; 995  :         {
; 996  :             return( SLE_OWNER );

  000dc	b8 fa ff ff ff	 mov	 eax, -6
  000e1	eb 2c		 jmp	 SHORT $LN1@sl_vol
$LN6@sl_vol:

; 997  :         }
; 998  :         memcpy( lab->slvol.owner, owner, len );

  000e3	48 8b 44 24 50	 mov	 rax, QWORD PTR lab$[rsp]
  000e8	48 83 c0 29	 add	 rax, 41			; 00000029H
  000ec	48 8b f8	 mov	 rdi, rax
  000ef	48 8b 74 24 60	 mov	 rsi, QWORD PTR owner$[rsp]
  000f4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR len$[rsp]
  000f9	f3 a4		 rep movsb
$LN5@sl_vol:

; 999  :     }
; 1000 : 
; 1001 :     /*
; 1002 :     || Convert to EBCDIC
; 1003 :     */
; 1004 :     sl_atoe( NULL, lab, sizeof( SLLABEL ) );

  000fb	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  00101	48 8b 54 24 50	 mov	 rdx, QWORD PTR lab$[rsp]
  00106	33 c9		 xor	 ecx, ecx
  00108	e8 00 00 00 00	 call	 sl_atoe

; 1005 : 
; 1006 :     return 0;

  0010d	33 c0		 xor	 eax, eax
$LN1@sl_vol:

; 1007 : }

  0010f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00113	5f		 pop	 rdi
  00114	5e		 pop	 rsi
  00115	c3		 ret	 0
sl_vol	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sllib.c
_TEXT	SEGMENT
ptr$ = 32
buf$ = 64
type$ = 72
num$ = 80
sl_istype PROC

; 541  : {

$LN9:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 542  :     unsigned char *ptr;
; 543  : 
; 544  :     ptr = buf;

  00012	48 8b 44 24 40	 mov	 rax, QWORD PTR buf$[rsp]
  00017	48 89 44 24 20	 mov	 QWORD PTR ptr$[rsp], rax

; 545  : 
; 546  :     /*
; 547  :     || Check EBCDIC table
; 548  :     */
; 549  :     if( memcmp( buf, sl_elabs[ type ], 3 ) == 0 )

  0001c	48 63 44 24 48	 movsxd	 rax, DWORD PTR type$[rsp]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sl_elabs
  00028	41 b8 03 00 00
	00		 mov	 r8d, 3
  0002e	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buf$[rsp]
  00037	e8 00 00 00 00	 call	 memcmp
  0003c	85 c0		 test	 eax, eax
  0003e	75 2e		 jne	 SHORT $LN2@sl_istype

; 550  :     {
; 551  :         if( ( num == 0 ) || ( ptr[ 3 ] == ( ( (unsigned char) '\xF0' ) + num ) ) )

  00040	83 7c 24 50 00	 cmp	 DWORD PTR num$[rsp], 0
  00045	74 20		 je	 SHORT $LN4@sl_istype
  00047	b8 01 00 00 00	 mov	 eax, 1
  0004c	48 6b c0 03	 imul	 rax, rax, 3
  00050	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ptr$[rsp]
  00055	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00059	8b 4c 24 50	 mov	 ecx, DWORD PTR num$[rsp]
  0005d	81 c1 f0 00 00
	00		 add	 ecx, 240		; 000000f0H
  00063	3b c1		 cmp	 eax, ecx
  00065	75 07		 jne	 SHORT $LN3@sl_istype
$LN4@sl_istype:

; 552  :         {
; 553  :             return( TRUE );

  00067	b8 01 00 00 00	 mov	 eax, 1
  0006c	eb 51		 jmp	 SHORT $LN1@sl_istype
$LN3@sl_istype:
$LN2@sl_istype:

; 554  :         }
; 555  :     }
; 556  : 
; 557  :     /*
; 558  :     || Check ASCII table
; 559  :     */
; 560  :     if( memcmp( buf, sl_alabs[ type ], 3 ) == 0 )

  0006e	48 63 44 24 48	 movsxd	 rax, DWORD PTR type$[rsp]
  00073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sl_alabs
  0007a	41 b8 03 00 00
	00		 mov	 r8d, 3
  00080	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00084	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buf$[rsp]
  00089	e8 00 00 00 00	 call	 memcmp
  0008e	85 c0		 test	 eax, eax
  00090	75 2b		 jne	 SHORT $LN5@sl_istype

; 561  :     {
; 562  :         if( ( num == 0 ) || ( ptr[ 3 ] == ( ( (unsigned char) '\x30') + num ) ) )

  00092	83 7c 24 50 00	 cmp	 DWORD PTR num$[rsp], 0
  00097	74 1d		 je	 SHORT $LN7@sl_istype
  00099	b8 01 00 00 00	 mov	 eax, 1
  0009e	48 6b c0 03	 imul	 rax, rax, 3
  000a2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ptr$[rsp]
  000a7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ab	8b 4c 24 50	 mov	 ecx, DWORD PTR num$[rsp]
  000af	83 c1 30	 add	 ecx, 48			; 00000030H
  000b2	3b c1		 cmp	 eax, ecx
  000b4	75 07		 jne	 SHORT $LN6@sl_istype
$LN7@sl_istype:

; 563  :         {
; 564  :             return( TRUE );

  000b6	b8 01 00 00 00	 mov	 eax, 1
  000bb	eb 02		 jmp	 SHORT $LN1@sl_istype
$LN6@sl_istype:
$LN5@sl_istype:

; 565  :         }
; 566  :     }
; 567  : 
; 568  :     return( FALSE );

  000bd	33 c0		 xor	 eax, eax
$LN1@sl_istype:

; 569  : }

  000bf	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c3	c3		 ret	 0
sl_istype ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sllib.c
_TEXT	SEGMENT
i$ = 32
num$ = 36
ptr$ = 40
lab$ = 80
buf$ = 88
len$ = 96
sl_islabel PROC

; 434  : {

$LN13:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 435  :     int i;
; 436  :     int num;
; 437  :     unsigned char *ptr;
; 438  : 
; 439  :     if( len != sizeof( SLLABEL ) )

  00015	48 63 44 24 60	 movsxd	 rax, DWORD PTR len$[rsp]
  0001a	48 83 f8 50	 cmp	 rax, 80			; 00000050H
  0001e	74 07		 je	 SHORT $LN5@sl_islabel

; 440  :     {
; 441  :         return FALSE;

  00020	33 c0		 xor	 eax, eax
  00022	e9 55 01 00 00	 jmp	 $LN1@sl_islabel
$LN5@sl_islabel:

; 442  :     }
; 443  : 
; 444  :     for( i = 1 ; i < (int)SL_ELABS_MAX ; i++ )

  00027	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  0002f	eb 0a		 jmp	 SHORT $LN4@sl_islabel
$LN2@sl_islabel:
  00031	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00035	ff c0		 inc	 eax
  00037	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@sl_islabel:
  0003b	83 7c 24 20 07	 cmp	 DWORD PTR i$[rsp], 7
  00040	0f 8d 34 01 00
	00		 jge	 $LN3@sl_islabel

; 445  :     {
; 446  :         if( memcmp( sl_elabs[ i ], buf, 3 ) == 0 )

  00046	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sl_elabs
  00052	41 b8 03 00 00
	00		 mov	 r8d, 3
  00058	48 8b 54 24 58	 mov	 rdx, QWORD PTR buf$[rsp]
  0005d	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00061	e8 00 00 00 00	 call	 memcmp
  00066	85 c0		 test	 eax, eax
  00068	75 76		 jne	 SHORT $LN6@sl_islabel

; 447  :         {
; 448  :             ptr = buf;

  0006a	48 8b 44 24 58	 mov	 rax, QWORD PTR buf$[rsp]
  0006f	48 89 44 24 28	 mov	 QWORD PTR ptr$[rsp], rax

; 449  :             num = ptr[ 3 ] - (unsigned char) '\xF0';

  00074	b8 01 00 00 00	 mov	 eax, 1
  00079	48 6b c0 03	 imul	 rax, rax, 3
  0007d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ptr$[rsp]
  00082	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00086	2d f0 00 00 00	 sub	 eax, 240		; 000000f0H
  0008b	89 44 24 24	 mov	 DWORD PTR num$[rsp], eax

; 450  :             if( ( num >= sl_ranges[ i ].min ) && ( num <= sl_ranges[ i ].max ) )

  0008f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sl_ranges
  0009b	8b 04 c1	 mov	 eax, DWORD PTR [rcx+rax*8]
  0009e	39 44 24 24	 cmp	 DWORD PTR num$[rsp], eax
  000a2	7c 3c		 jl	 SHORT $LN7@sl_islabel
  000a4	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sl_ranges
  000b0	8b 44 c1 04	 mov	 eax, DWORD PTR [rcx+rax*8+4]
  000b4	39 44 24 24	 cmp	 DWORD PTR num$[rsp], eax
  000b8	7f 26		 jg	 SHORT $LN7@sl_islabel

; 451  :             {
; 452  :                 if( lab != NULL )

  000ba	48 83 7c 24 50
	00		 cmp	 QWORD PTR lab$[rsp], 0
  000c0	74 14		 je	 SHORT $LN8@sl_islabel

; 453  :                 {
; 454  :                     sl_etoa( lab, buf, len );

  000c2	44 8b 44 24 60	 mov	 r8d, DWORD PTR len$[rsp]
  000c7	48 8b 54 24 58	 mov	 rdx, QWORD PTR buf$[rsp]
  000cc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lab$[rsp]
  000d1	e8 00 00 00 00	 call	 sl_etoa
$LN8@sl_islabel:

; 455  :                 }
; 456  :                 return( TRUE );

  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	e9 9c 00 00 00	 jmp	 $LN1@sl_islabel
$LN7@sl_islabel:
$LN6@sl_islabel:

; 457  :             }
; 458  :         }
; 459  : 
; 460  :         if( memcmp( sl_alabs[ i ], buf, 3 ) == 0 )

  000e0	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sl_alabs
  000ec	41 b8 03 00 00
	00		 mov	 r8d, 3
  000f2	48 8b 54 24 58	 mov	 rdx, QWORD PTR buf$[rsp]
  000f7	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  000fb	e8 00 00 00 00	 call	 memcmp
  00100	85 c0		 test	 eax, eax
  00102	75 71		 jne	 SHORT $LN9@sl_islabel

; 461  :         {
; 462  :             ptr = buf;

  00104	48 8b 44 24 58	 mov	 rax, QWORD PTR buf$[rsp]
  00109	48 89 44 24 28	 mov	 QWORD PTR ptr$[rsp], rax

; 463  :             num = ptr[ 3 ] - (unsigned char) '\x30';

  0010e	b8 01 00 00 00	 mov	 eax, 1
  00113	48 6b c0 03	 imul	 rax, rax, 3
  00117	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ptr$[rsp]
  0011c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00120	83 e8 30	 sub	 eax, 48			; 00000030H
  00123	89 44 24 24	 mov	 DWORD PTR num$[rsp], eax

; 464  :             if( ( num >= sl_ranges[ i ].min ) && ( num <= sl_ranges[ i ].max ) )

  00127	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0012c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sl_ranges
  00133	8b 04 c1	 mov	 eax, DWORD PTR [rcx+rax*8]
  00136	39 44 24 24	 cmp	 DWORD PTR num$[rsp], eax
  0013a	7c 39		 jl	 SHORT $LN10@sl_islabel
  0013c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00141	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sl_ranges
  00148	8b 44 c1 04	 mov	 eax, DWORD PTR [rcx+rax*8+4]
  0014c	39 44 24 24	 cmp	 DWORD PTR num$[rsp], eax
  00150	7f 23		 jg	 SHORT $LN10@sl_islabel

; 465  :             {
; 466  :                 if( lab != NULL )

  00152	48 83 7c 24 50
	00		 cmp	 QWORD PTR lab$[rsp], 0
  00158	74 14		 je	 SHORT $LN11@sl_islabel

; 467  :                 {
; 468  :                     memcpy( lab, buf, len );

  0015a	48 63 44 24 60	 movsxd	 rax, DWORD PTR len$[rsp]
  0015f	48 8b 7c 24 50	 mov	 rdi, QWORD PTR lab$[rsp]
  00164	48 8b 74 24 58	 mov	 rsi, QWORD PTR buf$[rsp]
  00169	48 8b c8	 mov	 rcx, rax
  0016c	f3 a4		 rep movsb
$LN11@sl_islabel:

; 469  :                 }
; 470  : 
; 471  :                 return( TRUE );

  0016e	b8 01 00 00 00	 mov	 eax, 1
  00173	eb 07		 jmp	 SHORT $LN1@sl_islabel
$LN10@sl_islabel:
$LN9@sl_islabel:

; 472  :             }
; 473  :         }
; 474  :     }

  00175	e9 b7 fe ff ff	 jmp	 $LN2@sl_islabel
$LN3@sl_islabel:

; 475  : 
; 476  :     return( FALSE );

  0017a	33 c0		 xor	 eax, eax
$LN1@sl_islabel:

; 477  : }

  0017c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00180	5f		 pop	 rdi
  00181	5e		 pop	 rsi
  00182	c3		 ret	 0
sl_islabel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sllib.c
_TEXT	SEGMENT
templab$ = 32
__$ArrayPad$ = 112
fmt$ = 160
lab$ = 168
sl_fmtlab PROC

; 800  : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 801  :     SLLABEL templab;
; 802  : 
; 803  :     /*
; 804  :     || Initialize
; 805  :     */
; 806  :     memset( fmt, 0, sizeof( SLFMT ) );

  00022	48 8b bc 24 a0
	00 00 00	 mov	 rdi, QWORD PTR fmt$[rsp]
  0002a	33 c0		 xor	 eax, eax
  0002c	b9 40 01 00 00	 mov	 ecx, 320		; 00000140H
  00031	f3 aa		 rep stosb

; 807  : 
; 808  :     /*
; 809  :     || If label appears to be EBCDIC, convert to ASCII before processing
; 810  :     */
; 811  :     if( sl_islabel( &templab, lab, sizeof( SLLABEL ) ) == FALSE )

  00033	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  00039	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR lab$[rsp]
  00041	48 8d 4c 24 20	 lea	 rcx, QWORD PTR templab$[rsp]
  00046	e8 00 00 00 00	 call	 sl_islabel
  0004b	85 c0		 test	 eax, eax
  0004d	75 05		 jne	 SHORT $LN2@sl_fmtlab

; 812  :     {
; 813  :         return;

  0004f	e9 c4 0b 00 00	 jmp	 $LN1@sl_fmtlab
$LN2@sl_fmtlab:

; 814  :     }
; 815  :     lab = &templab;

  00054	48 8d 44 24 20	 lea	 rax, QWORD PTR templab$[rsp]
  00059	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR lab$[rsp], rax

; 816  : 
; 817  :     /*
; 818  :     || Store label type (combine ID and NUM)
; 819  :     */
; 820  :     fmt->key[ 0 ] = "Label";

  00061	b8 08 00 00 00	 mov	 eax, 8
  00066	48 6b c0 00	 imul	 rax, rax, 0
  0006a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  00072	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159420
  00079	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 821  :     fmt->val[ 0 ] = fmt->type;

  0007d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00085	48 05 e0 00 00
	00		 add	 rax, 224		; 000000e0H
  0008b	b9 08 00 00 00	 mov	 ecx, 8
  00090	48 6b c9 00	 imul	 rcx, rcx, 0
  00094	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  0009c	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax

; 822  :     memcpy( fmt->type, lab->id, 4 );

  000a1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  000a9	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  000b1	8b 09		 mov	 ecx, DWORD PTR [rcx]
  000b3	89 88 e0 00 00
	00		 mov	 DWORD PTR [rax+224], ecx

; 823  : 
; 824  :     /*
; 825  :     || Build remaining fields based on label type
; 826  :     */
; 827  :     if( memcmp( lab->id, "VOL", 3 ) == 0 )

  000b9	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR lab$[rsp]
  000c1	41 b8 03 00 00
	00		 mov	 r8d, 3
  000c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159423
  000ce	48 8b c8	 mov	 rcx, rax
  000d1	e8 00 00 00 00	 call	 memcmp
  000d6	85 c0		 test	 eax, eax
  000d8	0f 85 42 01 00
	00		 jne	 $LN3@sl_fmtlab

; 828  :     {
; 829  :         if( lab->num[ 0 ] == '1' )

  000de	b8 01 00 00 00	 mov	 eax, 1
  000e3	48 6b c0 00	 imul	 rax, rax, 0
  000e7	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  000ef	0f be 44 01 03	 movsx	 eax, BYTE PTR [rcx+rax+3]
  000f4	83 f8 31	 cmp	 eax, 49			; 00000031H
  000f7	0f 85 1e 01 00
	00		 jne	 $LN5@sl_fmtlab

; 830  :         {
; 831  :             lab2fmt(  1, slvol.volser,      6,  "Volume Serial"         );

  000fd	b8 08 00 00 00	 mov	 eax, 8
  00102	48 6b c0 01	 imul	 rax, rax, 1
  00106	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  0010e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159425
  00115	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  00119	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00121	48 05 e5 00 00
	00		 add	 rax, 229		; 000000e5H
  00127	b9 08 00 00 00	 mov	 ecx, 8
  0012c	48 6b c9 01	 imul	 rcx, rcx, 1
  00130	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  00138	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  0013d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00145	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  0014d	48 8d b8 e5 00
	00 00		 lea	 rdi, QWORD PTR [rax+229]
  00154	48 8d 71 04	 lea	 rsi, QWORD PTR [rcx+4]
  00158	b9 06 00 00 00	 mov	 ecx, 6
  0015d	f3 a4		 rep movsb

; 832  :             lab2fmt(  2, slvol.access,      1,  "Volume Access"         );

  0015f	b8 08 00 00 00	 mov	 eax, 8
  00164	48 6b c0 02	 imul	 rax, rax, 2
  00168	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  00170	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159426
  00177	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  0017b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00183	48 05 ec 00 00
	00		 add	 rax, 236		; 000000ecH
  00189	b9 08 00 00 00	 mov	 ecx, 8
  0018e	48 6b c9 02	 imul	 rcx, rcx, 2
  00192	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  0019a	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  0019f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  001a7	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  001af	0f b6 49 0a	 movzx	 ecx, BYTE PTR [rcx+10]
  001b3	88 88 ec 00 00
	00		 mov	 BYTE PTR [rax+236], cl

; 833  :             lab2fmt(  3, slvol.owner,       10, "Owner Code"            );

  001b9	b8 08 00 00 00	 mov	 eax, 8
  001be	48 6b c0 03	 imul	 rax, rax, 3
  001c2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  001ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159427
  001d1	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  001d5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  001dd	48 05 ee 00 00
	00		 add	 rax, 238		; 000000eeH
  001e3	b9 08 00 00 00	 mov	 ecx, 8
  001e8	48 6b c9 03	 imul	 rcx, rcx, 3
  001ec	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  001f4	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  001f9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00201	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  00209	48 8d b8 ee 00
	00 00		 lea	 rdi, QWORD PTR [rax+238]
  00210	48 8d 71 29	 lea	 rsi, QWORD PTR [rcx+41]
  00214	b9 0a 00 00 00	 mov	 ecx, 10
  00219	f3 a4		 rep movsb
$LN5@sl_fmtlab:

; 834  :         }
; 835  :     }

  0021b	e9 f8 09 00 00	 jmp	 $LN4@sl_fmtlab
$LN3@sl_fmtlab:

; 836  :     else if( ( memcmp( lab->id, "HDR", 3 ) == 0 ) ||
; 837  :              ( memcmp( lab->id, "EOF", 3 ) == 0 ) ||

  00220	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR lab$[rsp]
  00228	41 b8 03 00 00
	00		 mov	 r8d, 3
  0022e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159431
  00235	48 8b c8	 mov	 rcx, rax
  00238	e8 00 00 00 00	 call	 memcmp
  0023d	85 c0		 test	 eax, eax
  0023f	74 46		 je	 SHORT $LN8@sl_fmtlab
  00241	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR lab$[rsp]
  00249	41 b8 03 00 00
	00		 mov	 r8d, 3
  0024f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159432
  00256	48 8b c8	 mov	 rcx, rax
  00259	e8 00 00 00 00	 call	 memcmp
  0025e	85 c0		 test	 eax, eax
  00260	74 25		 je	 SHORT $LN8@sl_fmtlab
  00262	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR lab$[rsp]
  0026a	41 b8 03 00 00
	00		 mov	 r8d, 3
  00270	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159433
  00277	48 8b c8	 mov	 rcx, rax
  0027a	e8 00 00 00 00	 call	 memcmp
  0027f	85 c0		 test	 eax, eax
  00281	0f 85 0e 09 00
	00		 jne	 $LN6@sl_fmtlab
$LN8@sl_fmtlab:

; 838  :              ( memcmp( lab->id, "EOV", 3 ) == 0 ) )
; 839  :     {
; 840  :         if( lab->num[ 0 ] == '1' )

  00287	b8 01 00 00 00	 mov	 eax, 1
  0028c	48 6b c0 00	 imul	 rax, rax, 0
  00290	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  00298	0f be 44 01 03	 movsx	 eax, BYTE PTR [rcx+rax+3]
  0029d	83 f8 31	 cmp	 eax, 49			; 00000031H
  002a0	0f 85 6a 04 00
	00		 jne	 $LN9@sl_fmtlab

; 841  :         {
; 842  :             lab2fmt( 1,  slds1.dsid,        17, "Dataset ID"            );

  002a6	b8 08 00 00 00	 mov	 eax, 8
  002ab	48 6b c0 01	 imul	 rax, rax, 1
  002af	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  002b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159436
  002be	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  002c2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  002ca	48 05 e5 00 00
	00		 add	 rax, 229		; 000000e5H
  002d0	b9 08 00 00 00	 mov	 ecx, 8
  002d5	48 6b c9 01	 imul	 rcx, rcx, 1
  002d9	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  002e1	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  002e6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  002ee	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  002f6	48 8d b8 e5 00
	00 00		 lea	 rdi, QWORD PTR [rax+229]
  002fd	48 8d 71 04	 lea	 rsi, QWORD PTR [rcx+4]
  00301	b9 11 00 00 00	 mov	 ecx, 17
  00306	f3 a4		 rep movsb

; 843  :             lab2fmt( 2,  slds1.volser,      6,  "Volume Serial"         );

  00308	b8 08 00 00 00	 mov	 eax, 8
  0030d	48 6b c0 02	 imul	 rax, rax, 2
  00311	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  00319	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159437
  00320	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  00324	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  0032c	48 05 f7 00 00
	00		 add	 rax, 247		; 000000f7H
  00332	b9 08 00 00 00	 mov	 ecx, 8
  00337	48 6b c9 02	 imul	 rcx, rcx, 2
  0033b	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  00343	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  00348	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00350	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  00358	48 8d b8 f7 00
	00 00		 lea	 rdi, QWORD PTR [rax+247]
  0035f	48 8d 71 15	 lea	 rsi, QWORD PTR [rcx+21]
  00363	b9 06 00 00 00	 mov	 ecx, 6
  00368	f3 a4		 rep movsb

; 844  :             lab2fmt( 3,  slds1.volseq,      4,  "Volume Sequence"       );

  0036a	b8 08 00 00 00	 mov	 eax, 8
  0036f	48 6b c0 03	 imul	 rax, rax, 3
  00373	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  0037b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159438
  00382	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  00386	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  0038e	48 05 fe 00 00
	00		 add	 rax, 254		; 000000feH
  00394	b9 08 00 00 00	 mov	 ecx, 8
  00399	48 6b c9 03	 imul	 rcx, rcx, 3
  0039d	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  003a5	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  003aa	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  003b2	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  003ba	8b 49 1b	 mov	 ecx, DWORD PTR [rcx+27]
  003bd	89 88 fe 00 00
	00		 mov	 DWORD PTR [rax+254], ecx

; 845  :             lab2fmt( 4,  slds1.dsseq,       4,  "Dataset Sequence"      );

  003c3	b8 08 00 00 00	 mov	 eax, 8
  003c8	48 6b c0 04	 imul	 rax, rax, 4
  003cc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  003d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159439
  003db	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  003df	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  003e7	48 05 03 01 00
	00		 add	 rax, 259		; 00000103H
  003ed	b9 08 00 00 00	 mov	 ecx, 8
  003f2	48 6b c9 04	 imul	 rcx, rcx, 4
  003f6	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  003fe	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  00403	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  0040b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  00413	8b 49 1f	 mov	 ecx, DWORD PTR [rcx+31]
  00416	89 88 03 01 00
	00		 mov	 DWORD PTR [rax+259], ecx

; 846  :             lab2fmt( 5,  slds1.genno,       4,  "GDG Number"            );

  0041c	b8 08 00 00 00	 mov	 eax, 8
  00421	48 6b c0 05	 imul	 rax, rax, 5
  00425	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  0042d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159440
  00434	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  00438	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00440	48 05 08 01 00
	00		 add	 rax, 264		; 00000108H
  00446	b9 08 00 00 00	 mov	 ecx, 8
  0044b	48 6b c9 05	 imul	 rcx, rcx, 5
  0044f	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  00457	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  0045c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00464	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  0046c	8b 49 23	 mov	 ecx, DWORD PTR [rcx+35]
  0046f	89 88 08 01 00
	00		 mov	 DWORD PTR [rax+264], ecx

; 847  :             lab2fmt( 6,  slds1.verno,       2,  "GDG Version"           );

  00475	b8 08 00 00 00	 mov	 eax, 8
  0047a	48 6b c0 06	 imul	 rax, rax, 6
  0047e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  00486	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159441
  0048d	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  00491	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00499	48 05 0d 01 00
	00		 add	 rax, 269		; 0000010dH
  0049f	b9 08 00 00 00	 mov	 ecx, 8
  004a4	48 6b c9 06	 imul	 rcx, rcx, 6
  004a8	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  004b0	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  004b5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  004bd	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  004c5	0f b7 49 27	 movzx	 ecx, WORD PTR [rcx+39]
  004c9	66 89 88 0d 01
	00 00		 mov	 WORD PTR [rax+269], cx

; 848  :             lab2fmt( 7,  slds1.crtdt,       6,  "Creation Date"         );

  004d0	b8 08 00 00 00	 mov	 eax, 8
  004d5	48 6b c0 07	 imul	 rax, rax, 7
  004d9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  004e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159442
  004e8	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  004ec	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  004f4	48 05 10 01 00
	00		 add	 rax, 272		; 00000110H
  004fa	b9 08 00 00 00	 mov	 ecx, 8
  004ff	48 6b c9 07	 imul	 rcx, rcx, 7
  00503	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  0050b	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  00510	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00518	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  00520	48 8d b8 10 01
	00 00		 lea	 rdi, QWORD PTR [rax+272]
  00527	48 8d 71 29	 lea	 rsi, QWORD PTR [rcx+41]
  0052b	b9 06 00 00 00	 mov	 ecx, 6
  00530	f3 a4		 rep movsb

; 849  :             lab2fmt( 8,  slds1.expdt,       6,  "Expiration Date"       );

  00532	b8 08 00 00 00	 mov	 eax, 8
  00537	48 6b c0 08	 imul	 rax, rax, 8
  0053b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  00543	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159443
  0054a	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  0054e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00556	48 05 17 01 00
	00		 add	 rax, 279		; 00000117H
  0055c	b9 08 00 00 00	 mov	 ecx, 8
  00561	48 6b c9 08	 imul	 rcx, rcx, 8
  00565	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  0056d	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  00572	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  0057a	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  00582	48 8d b8 17 01
	00 00		 lea	 rdi, QWORD PTR [rax+279]
  00589	48 8d 71 2f	 lea	 rsi, QWORD PTR [rcx+47]
  0058d	b9 06 00 00 00	 mov	 ecx, 6
  00592	f3 a4		 rep movsb

; 850  :             lab2fmt( 9,  slds1.dssec,       1,  "Dataset Security"      );

  00594	b8 08 00 00 00	 mov	 eax, 8
  00599	48 6b c0 09	 imul	 rax, rax, 9
  0059d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  005a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159444
  005ac	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  005b0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  005b8	48 05 1e 01 00
	00		 add	 rax, 286		; 0000011eH
  005be	b9 08 00 00 00	 mov	 ecx, 8
  005c3	48 6b c9 09	 imul	 rcx, rcx, 9
  005c7	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  005cf	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  005d4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  005dc	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  005e4	0f b6 49 35	 movzx	 ecx, BYTE PTR [rcx+53]
  005e8	88 88 1e 01 00
	00		 mov	 BYTE PTR [rax+286], cl

; 851  :             lab2fmt( 10, slds1.blklo,       6,  "Block Count Low"       );

  005ee	b8 08 00 00 00	 mov	 eax, 8
  005f3	48 6b c0 0a	 imul	 rax, rax, 10
  005f7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  005ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159445
  00606	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  0060a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00612	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  00618	b9 08 00 00 00	 mov	 ecx, 8
  0061d	48 6b c9 0a	 imul	 rcx, rcx, 10
  00621	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  00629	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  0062e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00636	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  0063e	48 8d b8 20 01
	00 00		 lea	 rdi, QWORD PTR [rax+288]
  00645	48 8d 71 36	 lea	 rsi, QWORD PTR [rcx+54]
  00649	b9 06 00 00 00	 mov	 ecx, 6
  0064e	f3 a4		 rep movsb

; 852  :             lab2fmt( 11, slds1.syscd,       13, "System Code"           );

  00650	b8 08 00 00 00	 mov	 eax, 8
  00655	48 6b c0 0b	 imul	 rax, rax, 11
  00659	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  00661	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159446
  00668	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  0066c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00674	48 05 27 01 00
	00		 add	 rax, 295		; 00000127H
  0067a	b9 08 00 00 00	 mov	 ecx, 8
  0067f	48 6b c9 0b	 imul	 rcx, rcx, 11
  00683	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  0068b	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  00690	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00698	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  006a0	48 8d b8 27 01
	00 00		 lea	 rdi, QWORD PTR [rax+295]
  006a7	48 8d 71 3c	 lea	 rsi, QWORD PTR [rcx+60]
  006ab	b9 0d 00 00 00	 mov	 ecx, 13
  006b0	f3 a4		 rep movsb

; 853  :             lab2fmt( 12, slds1.blkhi,       4,  "Block Count High"      );

  006b2	b8 08 00 00 00	 mov	 eax, 8
  006b7	48 6b c0 0c	 imul	 rax, rax, 12
  006bb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  006c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159447
  006ca	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  006ce	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  006d6	48 05 35 01 00
	00		 add	 rax, 309		; 00000135H
  006dc	b9 08 00 00 00	 mov	 ecx, 8
  006e1	48 6b c9 0c	 imul	 rcx, rcx, 12
  006e5	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  006ed	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  006f2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  006fa	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  00702	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00705	89 88 35 01 00
	00		 mov	 DWORD PTR [rax+309], ecx

; 854  :         }

  0070b	e9 80 04 00 00	 jmp	 $LN10@sl_fmtlab
$LN9@sl_fmtlab:

; 855  :         else if( lab->num[ 0 ] == '2' )

  00710	b8 01 00 00 00	 mov	 eax, 1
  00715	48 6b c0 00	 imul	 rax, rax, 0
  00719	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  00721	0f be 44 01 03	 movsx	 eax, BYTE PTR [rcx+rax+3]
  00726	83 f8 32	 cmp	 eax, 50			; 00000032H
  00729	0f 85 61 04 00
	00		 jne	 $LN11@sl_fmtlab

; 856  :         {
; 857  :             lab2fmt( 1,  slds2.recfm,       1,  "Record Format"         );

  0072f	b8 08 00 00 00	 mov	 eax, 8
  00734	48 6b c0 01	 imul	 rax, rax, 1
  00738	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  00740	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159449
  00747	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  0074b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00753	48 05 e5 00 00
	00		 add	 rax, 229		; 000000e5H
  00759	b9 08 00 00 00	 mov	 ecx, 8
  0075e	48 6b c9 01	 imul	 rcx, rcx, 1
  00762	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  0076a	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  0076f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00777	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  0077f	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  00783	88 88 e5 00 00
	00		 mov	 BYTE PTR [rax+229], cl

; 858  :             lab2fmt( 2,  slds2.blksize,     5,  "Block Size"            );

  00789	b8 08 00 00 00	 mov	 eax, 8
  0078e	48 6b c0 02	 imul	 rax, rax, 2
  00792	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  0079a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159450
  007a1	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  007a5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  007ad	48 05 e7 00 00
	00		 add	 rax, 231		; 000000e7H
  007b3	b9 08 00 00 00	 mov	 ecx, 8
  007b8	48 6b c9 02	 imul	 rcx, rcx, 2
  007bc	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  007c4	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  007c9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  007d1	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  007d9	48 8d b8 e7 00
	00 00		 lea	 rdi, QWORD PTR [rax+231]
  007e0	48 8d 71 05	 lea	 rsi, QWORD PTR [rcx+5]
  007e4	b9 05 00 00 00	 mov	 ecx, 5
  007e9	f3 a4		 rep movsb

; 859  :             lab2fmt( 3,  slds2.lrecl,       5,  "Record Length"         );

  007eb	b8 08 00 00 00	 mov	 eax, 8
  007f0	48 6b c0 03	 imul	 rax, rax, 3
  007f4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  007fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159451
  00803	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  00807	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  0080f	48 05 ed 00 00
	00		 add	 rax, 237		; 000000edH
  00815	b9 08 00 00 00	 mov	 ecx, 8
  0081a	48 6b c9 03	 imul	 rcx, rcx, 3
  0081e	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  00826	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  0082b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00833	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  0083b	48 8d b8 ed 00
	00 00		 lea	 rdi, QWORD PTR [rax+237]
  00842	48 8d 71 0a	 lea	 rsi, QWORD PTR [rcx+10]
  00846	b9 05 00 00 00	 mov	 ecx, 5
  0084b	f3 a4		 rep movsb

; 860  :             lab2fmt( 4,  slds2.den,         1,  "Density"               );

  0084d	b8 08 00 00 00	 mov	 eax, 8
  00852	48 6b c0 04	 imul	 rax, rax, 4
  00856	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  0085e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159452
  00865	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  00869	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00871	48 05 f3 00 00
	00		 add	 rax, 243		; 000000f3H
  00877	b9 08 00 00 00	 mov	 ecx, 8
  0087c	48 6b c9 04	 imul	 rcx, rcx, 4
  00880	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  00888	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  0088d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00895	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  0089d	0f b6 49 0f	 movzx	 ecx, BYTE PTR [rcx+15]
  008a1	88 88 f3 00 00
	00		 mov	 BYTE PTR [rax+243], cl

; 861  :             lab2fmt( 5,  slds2.dspos,       1,  "Dataset Position"      );

  008a7	b8 08 00 00 00	 mov	 eax, 8
  008ac	48 6b c0 05	 imul	 rax, rax, 5
  008b0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  008b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159453
  008bf	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  008c3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  008cb	48 05 f5 00 00
	00		 add	 rax, 245		; 000000f5H
  008d1	b9 08 00 00 00	 mov	 ecx, 8
  008d6	48 6b c9 05	 imul	 rcx, rcx, 5
  008da	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  008e2	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  008e7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  008ef	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  008f7	0f b6 49 10	 movzx	 ecx, BYTE PTR [rcx+16]
  008fb	88 88 f5 00 00
	00		 mov	 BYTE PTR [rax+245], cl

; 862  :             lab2fmt( 6,  slds2.jobid,       17, "Job/Step ID"           );

  00901	b8 08 00 00 00	 mov	 eax, 8
  00906	48 6b c0 06	 imul	 rax, rax, 6
  0090a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  00912	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159454
  00919	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  0091d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00925	48 05 f7 00 00
	00		 add	 rax, 247		; 000000f7H
  0092b	b9 08 00 00 00	 mov	 ecx, 8
  00930	48 6b c9 06	 imul	 rcx, rcx, 6
  00934	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  0093c	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  00941	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00949	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  00951	48 8d b8 f7 00
	00 00		 lea	 rdi, QWORD PTR [rax+247]
  00958	48 8d 71 11	 lea	 rsi, QWORD PTR [rcx+17]
  0095c	b9 11 00 00 00	 mov	 ecx, 17
  00961	f3 a4		 rep movsb

; 863  :             lab2fmt( 7,  slds2.trtch,       2,  "Recording Technique"   );

  00963	b8 08 00 00 00	 mov	 eax, 8
  00968	48 6b c0 07	 imul	 rax, rax, 7
  0096c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  00974	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159455
  0097b	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  0097f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00987	48 05 09 01 00
	00		 add	 rax, 265		; 00000109H
  0098d	b9 08 00 00 00	 mov	 ecx, 8
  00992	48 6b c9 07	 imul	 rcx, rcx, 7
  00996	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  0099e	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  009a3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  009ab	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  009b3	0f b7 49 22	 movzx	 ecx, WORD PTR [rcx+34]
  009b7	66 89 88 09 01
	00 00		 mov	 WORD PTR [rax+265], cx

; 864  :             lab2fmt( 8,  slds2.ctrl,        1,  "Control Character"     );

  009be	b8 08 00 00 00	 mov	 eax, 8
  009c3	48 6b c0 08	 imul	 rax, rax, 8
  009c7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  009cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159456
  009d6	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  009da	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  009e2	48 05 0c 01 00
	00		 add	 rax, 268		; 0000010cH
  009e8	b9 08 00 00 00	 mov	 ecx, 8
  009ed	48 6b c9 08	 imul	 rcx, rcx, 8
  009f1	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  009f9	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  009fe	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00a06	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  00a0e	0f b6 49 24	 movzx	 ecx, BYTE PTR [rcx+36]
  00a12	88 88 0c 01 00
	00		 mov	 BYTE PTR [rax+268], cl

; 865  :             lab2fmt( 9,  slds2.blkattr,     1,  "Block Attribute"       );

  00a18	b8 08 00 00 00	 mov	 eax, 8
  00a1d	48 6b c0 09	 imul	 rax, rax, 9
  00a21	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  00a29	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159457
  00a30	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  00a34	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00a3c	48 05 0e 01 00
	00		 add	 rax, 270		; 0000010eH
  00a42	b9 08 00 00 00	 mov	 ecx, 8
  00a47	48 6b c9 09	 imul	 rcx, rcx, 9
  00a4b	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  00a53	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  00a58	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00a60	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  00a68	0f b6 49 26	 movzx	 ecx, BYTE PTR [rcx+38]
  00a6c	88 88 0e 01 00
	00		 mov	 BYTE PTR [rax+270], cl

; 866  :             lab2fmt( 10, slds2.devser,      6,  "Device Serial"         );

  00a72	b8 08 00 00 00	 mov	 eax, 8
  00a77	48 6b c0 0a	 imul	 rax, rax, 10
  00a7b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  00a83	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159458
  00a8a	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  00a8e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00a96	48 05 10 01 00
	00		 add	 rax, 272		; 00000110H
  00a9c	b9 08 00 00 00	 mov	 ecx, 8
  00aa1	48 6b c9 0a	 imul	 rcx, rcx, 10
  00aa5	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  00aad	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  00ab2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00aba	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  00ac2	48 8d b8 10 01
	00 00		 lea	 rdi, QWORD PTR [rax+272]
  00ac9	48 8d 71 29	 lea	 rsi, QWORD PTR [rcx+41]
  00acd	b9 06 00 00 00	 mov	 ecx, 6
  00ad2	f3 a4		 rep movsb

; 867  :             lab2fmt( 11, slds2.ckptid,      1,  "Checkpoint ID"         );

  00ad4	b8 08 00 00 00	 mov	 eax, 8
  00ad9	48 6b c0 0b	 imul	 rax, rax, 11
  00add	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  00ae5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159459
  00aec	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  00af0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00af8	48 05 17 01 00
	00		 add	 rax, 279		; 00000117H
  00afe	b9 08 00 00 00	 mov	 ecx, 8
  00b03	48 6b c9 0b	 imul	 rcx, rcx, 11
  00b07	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  00b0f	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  00b14	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00b1c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  00b24	0f b6 49 2f	 movzx	 ecx, BYTE PTR [rcx+47]
  00b28	88 88 17 01 00
	00		 mov	 BYTE PTR [rax+279], cl

; 868  :             lab2fmt( 12, slds2.lblkln,      10, "Large Block Length"    );

  00b2e	b8 08 00 00 00	 mov	 eax, 8
  00b33	48 6b c0 0c	 imul	 rax, rax, 12
  00b37	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  00b3f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159460
  00b46	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  00b4a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00b52	48 05 19 01 00
	00		 add	 rax, 281		; 00000119H
  00b58	b9 08 00 00 00	 mov	 ecx, 8
  00b5d	48 6b c9 0c	 imul	 rcx, rcx, 12
  00b61	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  00b69	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  00b6e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00b76	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  00b7e	48 8d b8 19 01
	00 00		 lea	 rdi, QWORD PTR [rax+281]
  00b85	48 8d 71 46	 lea	 rsi, QWORD PTR [rcx+70]
  00b89	b9 0a 00 00 00	 mov	 ecx, 10
  00b8e	f3 a4		 rep movsb
$LN11@sl_fmtlab:
$LN10@sl_fmtlab:

; 869  :         }
; 870  :     }

  00b90	e9 83 00 00 00	 jmp	 $LN7@sl_fmtlab
$LN6@sl_fmtlab:

; 871  :     else if( memcmp( lab->id, "USR", 3 ) == 0 )

  00b95	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR lab$[rsp]
  00b9d	41 b8 03 00 00
	00		 mov	 r8d, 3
  00ba3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159462
  00baa	48 8b c8	 mov	 rcx, rax
  00bad	e8 00 00 00 00	 call	 memcmp
  00bb2	85 c0		 test	 eax, eax
  00bb4	75 62		 jne	 SHORT $LN12@sl_fmtlab

; 872  :     {
; 873  :         lab2fmt(  1, slusr.data,            76, "User Data"             );

  00bb6	b8 08 00 00 00	 mov	 eax, 8
  00bbb	48 6b c0 01	 imul	 rax, rax, 1
  00bbf	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  00bc7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159463
  00bce	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  00bd2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00bda	48 05 e5 00 00
	00		 add	 rax, 229		; 000000e5H
  00be0	b9 08 00 00 00	 mov	 ecx, 8
  00be5	48 6b c9 01	 imul	 rcx, rcx, 1
  00be9	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fmt$[rsp]
  00bf1	48 89 44 0a 70	 mov	 QWORD PTR [rdx+rcx+112], rax
  00bf6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00bfe	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lab$[rsp]
  00c06	48 8d b8 e5 00
	00 00		 lea	 rdi, QWORD PTR [rax+229]
  00c0d	48 8d 71 04	 lea	 rsi, QWORD PTR [rcx+4]
  00c11	b9 4c 00 00 00	 mov	 ecx, 76			; 0000004cH
  00c16	f3 a4		 rep movsb
$LN12@sl_fmtlab:
$LN7@sl_fmtlab:
$LN4@sl_fmtlab:
$LN1@sl_fmtlab:

; 874  :     }
; 875  : 
; 876  :     return;
; 877  : }

  00c18	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00c1d	48 33 cc	 xor	 rcx, rsp
  00c20	e8 00 00 00 00	 call	 __security_check_cookie
  00c25	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00c2c	5f		 pop	 rdi
  00c2d	5e		 pop	 rsi
  00c2e	c3		 ret	 0
sl_fmtlab ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sllib.c
_TEXT	SEGMENT
tv158 = 32
ptr$ = 40
ret$ = 48
curtime$ = 56
tm$ = 64
wbuf$ = 104
sbuf$ = 120
__$ArrayPad$ = 136
dest$ = 176
src$ = 184
fromto$ = 192
sl_fmtdate PROC

; 628  : {

$LN21:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 629  :     char wbuf[ 9 ];
; 630  :     char sbuf[ 9 ];
; 631  :     char *ptr;
; 632  :     time_t curtime;
; 633  :     struct tm tm;
; 634  :     int ret;
; 635  : 
; 636  :     /*
; 637  :     || If source represents an SL date, then convert it to julian
; 638  :     */
; 639  :     if( fromto )

  0002a	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR fromto$[rsp], 0
  00032	0f 84 80 01 00
	00		 je	 $LN4@sl_fmtdate

; 640  :     {
; 641  :         if( src == NULL )

  00038	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR src$[rsp], 0
  00041	75 07		 jne	 SHORT $LN6@sl_fmtdate

; 642  :         {
; 643  :             return( NULL );

  00043	33 c0		 xor	 eax, eax
  00045	e9 c3 02 00 00	 jmp	 $LN1@sl_fmtdate
$LN6@sl_fmtdate:

; 644  :         }
; 645  : 
; 646  :         if( src[ 5 ] == '0' )

  0004a	b8 01 00 00 00	 mov	 eax, 1
  0004f	48 6b c0 05	 imul	 rax, rax, 5
  00053	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR src$[rsp]
  0005b	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0005f	83 f8 30	 cmp	 eax, 48			; 00000030H
  00062	75 59		 jne	 SHORT $LN7@sl_fmtdate

; 647  :         {
; 648  :             dest[ 0 ] = src[ 1 ];

  00064	b8 01 00 00 00	 mov	 eax, 1
  00069	48 6b c0 01	 imul	 rax, rax, 1
  0006d	b9 01 00 00 00	 mov	 ecx, 1
  00072	48 6b c9 00	 imul	 rcx, rcx, 0
  00076	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dest$[rsp]
  0007e	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR src$[rsp]
  00086	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0008b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 649  :             dest[ 1 ] = src[ 2 ];

  0008e	b8 01 00 00 00	 mov	 eax, 1
  00093	48 6b c0 02	 imul	 rax, rax, 2
  00097	b9 01 00 00 00	 mov	 ecx, 1
  0009c	48 6b c9 01	 imul	 rcx, rcx, 1
  000a0	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dest$[rsp]
  000a8	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR src$[rsp]
  000b0	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  000b5	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 650  :         }

  000b8	e9 85 00 00 00	 jmp	 $LN8@sl_fmtdate
$LN7@sl_fmtdate:

; 651  :         else if( src[ 0 ] == ' ' )

  000bd	b8 01 00 00 00	 mov	 eax, 1
  000c2	48 6b c0 00	 imul	 rax, rax, 0
  000c6	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR src$[rsp]
  000ce	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000d2	83 f8 20	 cmp	 eax, 32			; 00000020H
  000d5	75 2c		 jne	 SHORT $LN9@sl_fmtdate

; 652  :         {
; 653  :             dest[ 0 ] = '1';

  000d7	b8 01 00 00 00	 mov	 eax, 1
  000dc	48 6b c0 00	 imul	 rax, rax, 0
  000e0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dest$[rsp]
  000e8	c6 04 01 31	 mov	 BYTE PTR [rcx+rax], 49	; 00000031H

; 654  :             dest[ 1 ] = '9';

  000ec	b8 01 00 00 00	 mov	 eax, 1
  000f1	48 6b c0 01	 imul	 rax, rax, 1
  000f5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dest$[rsp]
  000fd	c6 04 01 39	 mov	 BYTE PTR [rcx+rax], 57	; 00000039H

; 655  :         }

  00101	eb 3f		 jmp	 SHORT $LN10@sl_fmtdate
$LN9@sl_fmtdate:

; 656  :         else
; 657  :         {
; 658  :             dest[ 0 ] = '2';

  00103	b8 01 00 00 00	 mov	 eax, 1
  00108	48 6b c0 00	 imul	 rax, rax, 0
  0010c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dest$[rsp]
  00114	c6 04 01 32	 mov	 BYTE PTR [rcx+rax], 50	; 00000032H

; 659  :             dest[ 1 ] = src[ 0 ];

  00118	b8 01 00 00 00	 mov	 eax, 1
  0011d	48 6b c0 00	 imul	 rax, rax, 0
  00121	b9 01 00 00 00	 mov	 ecx, 1
  00126	48 6b c9 01	 imul	 rcx, rcx, 1
  0012a	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dest$[rsp]
  00132	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR src$[rsp]
  0013a	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0013f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN10@sl_fmtdate:
$LN8@sl_fmtdate:

; 660  :         }
; 661  : 
; 662  :         memcpy( &dest[ 2 ], &src[ 1 ] , 2 );

  00142	b8 01 00 00 00	 mov	 eax, 1
  00147	48 6b c0 01	 imul	 rax, rax, 1
  0014b	b9 01 00 00 00	 mov	 ecx, 1
  00150	48 6b c9 02	 imul	 rcx, rcx, 2
  00154	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dest$[rsp]
  0015c	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR src$[rsp]
  00164	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00169	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax

; 663  :         dest[ 4 ] = '.';

  0016d	b8 01 00 00 00	 mov	 eax, 1
  00172	48 6b c0 04	 imul	 rax, rax, 4
  00176	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dest$[rsp]
  0017e	c6 04 01 2e	 mov	 BYTE PTR [rcx+rax], 46	; 0000002eH

; 664  :         memcpy( &dest[ 5 ], &src[ 3 ] , 3 );

  00182	b8 01 00 00 00	 mov	 eax, 1
  00187	48 6b c0 03	 imul	 rax, rax, 3
  0018b	b9 01 00 00 00	 mov	 ecx, 1
  00190	48 6b c9 05	 imul	 rcx, rcx, 5
  00194	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dest$[rsp]
  0019c	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR src$[rsp]
  001a4	48 8d 3c 0a	 lea	 rdi, QWORD PTR [rdx+rcx]
  001a8	49 8d 34 00	 lea	 rsi, QWORD PTR [r8+rax]
  001ac	b9 03 00 00 00	 mov	 ecx, 3
  001b1	f3 a4		 rep movsb

; 665  :     }

  001b3	e9 4d 01 00 00	 jmp	 $LN5@sl_fmtdate
$LN4@sl_fmtdate:

; 666  :     else
; 667  :     {
; 668  :         /*
; 669  :         || Supply current date if source is null
; 670  :         */
; 671  :         if( src == NULL )

  001b8	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR src$[rsp], 0
  001c1	75 3b		 jne	 SHORT $LN11@sl_fmtdate

; 672  :         {
; 673  :             time( &curtime );

  001c3	48 8d 4c 24 38	 lea	 rcx, QWORD PTR curtime$[rsp]
  001c8	e8 00 00 00 00	 call	 time

; 674  :             strftime( sbuf, sizeof( sbuf ), "%Y%j", localtime( &curtime ) );

  001cd	48 8d 4c 24 38	 lea	 rcx, QWORD PTR curtime$[rsp]
  001d2	e8 00 00 00 00	 call	 localtime
  001d7	4c 8b c8	 mov	 r9, rax
  001da	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159397
  001e1	ba 09 00 00 00	 mov	 edx, 9
  001e6	48 8d 4c 24 78	 lea	 rcx, QWORD PTR sbuf$[rsp]
  001eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strftime

; 675  :             src = sbuf;

  001f1	48 8d 44 24 78	 lea	 rax, QWORD PTR sbuf$[rsp]
  001f6	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR src$[rsp], rax
$LN11@sl_fmtdate:

; 676  :         }
; 677  : 
; 678  :         /*
; 679  :         || Base initial guess at format on length of src date
; 680  :         */
; 681  :         switch( strlen( src ) )

  001fe	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR src$[rsp]
  00206	e8 00 00 00 00	 call	 strlen
  0020b	48 89 44 24 20	 mov	 QWORD PTR tv158[rsp], rax
  00210	48 83 7c 24 20
	05		 cmp	 QWORD PTR tv158[rsp], 5
  00216	74 1a		 je	 SHORT $LN12@sl_fmtdate
  00218	48 83 7c 24 20
	06		 cmp	 QWORD PTR tv158[rsp], 6
  0021e	74 20		 je	 SHORT $LN13@sl_fmtdate
  00220	48 83 7c 24 20
	07		 cmp	 QWORD PTR tv158[rsp], 7
  00226	74 26		 je	 SHORT $LN14@sl_fmtdate
  00228	48 83 7c 24 20
	08		 cmp	 QWORD PTR tv158[rsp], 8
  0022e	74 2c		 je	 SHORT $LN15@sl_fmtdate
  00230	eb 38		 jmp	 SHORT $LN16@sl_fmtdate
$LN12@sl_fmtdate:

; 682  :         {
; 683  :             case 5:
; 684  :                 ptr = "%2u%3u";

  00232	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159399
  00239	48 89 44 24 28	 mov	 QWORD PTR ptr$[rsp], rax

; 685  :             break;

  0023e	eb 31		 jmp	 SHORT $LN2@sl_fmtdate
$LN13@sl_fmtdate:

; 686  : 
; 687  :             case 6:
; 688  :                 ptr = "%2u.%3u";

  00240	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159401
  00247	48 89 44 24 28	 mov	 QWORD PTR ptr$[rsp], rax

; 689  :             break;

  0024c	eb 23		 jmp	 SHORT $LN2@sl_fmtdate
$LN14@sl_fmtdate:

; 690  : 
; 691  :             case 7:
; 692  :                 ptr = "%4u%3u";

  0024e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159403
  00255	48 89 44 24 28	 mov	 QWORD PTR ptr$[rsp], rax

; 693  :             break;

  0025a	eb 15		 jmp	 SHORT $LN2@sl_fmtdate
$LN15@sl_fmtdate:

; 694  : 
; 695  :             case 8:
; 696  :                 ptr = "%4u.%3u";

  0025c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159405
  00263	48 89 44 24 28	 mov	 QWORD PTR ptr$[rsp], rax

; 697  :             break;

  00268	eb 07		 jmp	 SHORT $LN2@sl_fmtdate
$LN16@sl_fmtdate:

; 698  : 
; 699  :             default:
; 700  :                 return( NULL );

  0026a	33 c0		 xor	 eax, eax
  0026c	e9 9c 00 00 00	 jmp	 $LN1@sl_fmtdate
$LN2@sl_fmtdate:

; 701  :         }
; 702  : 
; 703  :         /*
; 704  :         || Convert src to "tm" format
; 705  :         */
; 706  :         ret = sscanf( src, ptr, &tm.tm_year, &tm.tm_yday );

  00271	4c 8d 4c 24 5c	 lea	 r9, QWORD PTR tm$[rsp+28]
  00276	4c 8d 44 24 54	 lea	 r8, QWORD PTR tm$[rsp+20]
  0027b	48 8b 54 24 28	 mov	 rdx, QWORD PTR ptr$[rsp]
  00280	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR src$[rsp]
  00288	e8 00 00 00 00	 call	 sscanf
  0028d	89 44 24 30	 mov	 DWORD PTR ret$[rsp], eax

; 707  :         if( ret != 2 || tm.tm_yday < 1 || tm.tm_yday > 366 )

  00291	83 7c 24 30 02	 cmp	 DWORD PTR ret$[rsp], 2
  00296	75 11		 jne	 SHORT $LN18@sl_fmtdate
  00298	83 7c 24 5c 01	 cmp	 DWORD PTR tm$[rsp+28], 1
  0029d	7c 0a		 jl	 SHORT $LN18@sl_fmtdate
  0029f	81 7c 24 5c 6e
	01 00 00	 cmp	 DWORD PTR tm$[rsp+28], 366 ; 0000016eH
  002a7	7e 04		 jle	 SHORT $LN17@sl_fmtdate
$LN18@sl_fmtdate:

; 708  :         {
; 709  :             return( NULL );

  002a9	33 c0		 xor	 eax, eax
  002ab	eb 60		 jmp	 SHORT $LN1@sl_fmtdate
$LN17@sl_fmtdate:

; 710  :         }
; 711  :         tm.tm_yday--;

  002ad	8b 44 24 5c	 mov	 eax, DWORD PTR tm$[rsp+28]
  002b1	ff c8		 dec	 eax
  002b3	89 44 24 5c	 mov	 DWORD PTR tm$[rsp+28], eax

; 712  : 
; 713  :         /*
; 714  :         || Now, convert to SL tape format
; 715  :         */
; 716  :         strftime( wbuf, sizeof( wbuf ), "%Y%j", &tm );

  002b7	4c 8d 4c 24 40	 lea	 r9, QWORD PTR tm$[rsp]
  002bc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159409
  002c3	ba 09 00 00 00	 mov	 edx, 9
  002c8	48 8d 4c 24 68	 lea	 rcx, QWORD PTR wbuf$[rsp]
  002cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strftime

; 717  :         if( tm.tm_year < 100 )

  002d3	83 7c 24 54 64	 cmp	 DWORD PTR tm$[rsp+20], 100 ; 00000064H
  002d8	7d 0e		 jge	 SHORT $LN19@sl_fmtdate

; 718  :         {
; 719  :             /*
; 720  :             || 1900s are indicated by a blank.
; 721  :             */
; 722  :             wbuf[ 1 ] = ' ';

  002da	b8 01 00 00 00	 mov	 eax, 1
  002df	48 6b c0 01	 imul	 rax, rax, 1
  002e3	c6 44 04 68 20	 mov	 BYTE PTR wbuf$[rsp+rax], 32 ; 00000020H
$LN19@sl_fmtdate:

; 723  :         }
; 724  : 
; 725  :         /*
; 726  :         || Finally, copy SL date to destination
; 727  :         */
; 728  :         memcpy( dest, &wbuf[ 1 ], 6 );

  002e8	b8 01 00 00 00	 mov	 eax, 1
  002ed	48 6b c0 01	 imul	 rax, rax, 1
  002f1	48 8b bc 24 b0
	00 00 00	 mov	 rdi, QWORD PTR dest$[rsp]
  002f9	48 8d 74 04 68	 lea	 rsi, QWORD PTR wbuf$[rsp+rax]
  002fe	b9 06 00 00 00	 mov	 ecx, 6
  00303	f3 a4		 rep movsb
$LN5@sl_fmtdate:

; 729  :     }
; 730  : 
; 731  :     /*
; 732  :     || Return dest pointer
; 733  :     */
; 734  :     return( dest );

  00305	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
$LN1@sl_fmtdate:

; 735  : }

  0030d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00315	48 33 cc	 xor	 rcx, rsp
  00318	e8 00 00 00 00	 call	 __security_check_cookie
  0031d	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00324	5f		 pop	 rdi
  00325	5e		 pop	 rsi
  00326	c3		 ret	 0
sl_fmtdate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sllib.c
_TEXT	SEGMENT
dptr$ = 0
sptr$ = 8
dbuf$ = 32
sbuf$ = 40
slen$ = 48
sl_etoa	PROC

; 356  : {

$LN6:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 357  :     BYTE *sptr;
; 358  :     BYTE *dptr;
; 359  : 
; 360  :     sptr = sbuf;

  00013	48 8b 44 24 28	 mov	 rax, QWORD PTR sbuf$[rsp]
  00018	48 89 44 24 08	 mov	 QWORD PTR sptr$[rsp], rax

; 361  :     dptr = dbuf;

  0001d	48 8b 44 24 20	 mov	 rax, QWORD PTR dbuf$[rsp]
  00022	48 89 04 24	 mov	 QWORD PTR dptr$[rsp], rax

; 362  : 
; 363  :     if( dptr == NULL )

  00026	48 83 3c 24 00	 cmp	 QWORD PTR dptr$[rsp], 0
  0002b	75 09		 jne	 SHORT $LN4@sl_etoa

; 364  :     {
; 365  :         dptr = sptr;

  0002d	48 8b 44 24 08	 mov	 rax, QWORD PTR sptr$[rsp]
  00032	48 89 04 24	 mov	 QWORD PTR dptr$[rsp], rax
$LN4@sl_etoa:
$LN2@sl_etoa:

; 366  :     }
; 367  : 
; 368  :     while ( slen > 0 )

  00036	83 7c 24 30 00	 cmp	 DWORD PTR slen$[rsp], 0
  0003b	7e 32		 jle	 SHORT $LN3@sl_etoa

; 369  :     {
; 370  :         slen--;

  0003d	8b 44 24 30	 mov	 eax, DWORD PTR slen$[rsp]
  00041	ff c8		 dec	 eax
  00043	89 44 24 30	 mov	 DWORD PTR slen$[rsp], eax

; 371  :         dptr[ slen ] = sl_etoatab[ sptr[ slen ] ];

  00047	48 63 44 24 30	 movsxd	 rax, DWORD PTR slen$[rsp]
  0004c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR sptr$[rsp]
  00051	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sl_etoatab
  0005c	48 63 54 24 30	 movsxd	 rdx, DWORD PTR slen$[rsp]
  00061	4c 8b 04 24	 mov	 r8, QWORD PTR dptr$[rsp]
  00065	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00069	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al

; 372  :     }

  0006d	eb c7		 jmp	 SHORT $LN2@sl_etoa
$LN3@sl_etoa:

; 373  : 
; 374  :     return( (char *)dptr );

  0006f	48 8b 04 24	 mov	 rax, QWORD PTR dptr$[rsp]

; 375  : }

  00073	48 83 c4 18	 add	 rsp, 24
  00077	c3		 ret	 0
sl_etoa	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sllib.c
_TEXT	SEGMENT
dptr$ = 0
sptr$ = 8
dbuf$ = 32
sbuf$ = 40
slen$ = 48
sl_atoe	PROC

; 264  : {

$LN6:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 265  :     unsigned char *sptr;
; 266  :     unsigned char *dptr;
; 267  : 
; 268  :     sptr = sbuf;

  00013	48 8b 44 24 28	 mov	 rax, QWORD PTR sbuf$[rsp]
  00018	48 89 44 24 08	 mov	 QWORD PTR sptr$[rsp], rax

; 269  :     dptr = dbuf;

  0001d	48 8b 44 24 20	 mov	 rax, QWORD PTR dbuf$[rsp]
  00022	48 89 04 24	 mov	 QWORD PTR dptr$[rsp], rax

; 270  : 
; 271  :     if( dptr == NULL )

  00026	48 83 3c 24 00	 cmp	 QWORD PTR dptr$[rsp], 0
  0002b	75 09		 jne	 SHORT $LN4@sl_atoe

; 272  :     {
; 273  :         dptr = sptr;

  0002d	48 8b 44 24 08	 mov	 rax, QWORD PTR sptr$[rsp]
  00032	48 89 04 24	 mov	 QWORD PTR dptr$[rsp], rax
$LN4@sl_atoe:
$LN2@sl_atoe:

; 274  :     }
; 275  : 
; 276  :     while( slen > 0 )

  00036	83 7c 24 30 00	 cmp	 DWORD PTR slen$[rsp], 0
  0003b	7e 32		 jle	 SHORT $LN3@sl_atoe

; 277  :     {
; 278  :         slen--;

  0003d	8b 44 24 30	 mov	 eax, DWORD PTR slen$[rsp]
  00041	ff c8		 dec	 eax
  00043	89 44 24 30	 mov	 DWORD PTR slen$[rsp], eax

; 279  :         dptr[ slen ] = sl_atoetab[ sptr[ slen ] ];

  00047	48 63 44 24 30	 movsxd	 rax, DWORD PTR slen$[rsp]
  0004c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR sptr$[rsp]
  00051	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sl_atoetab
  0005c	48 63 54 24 30	 movsxd	 rdx, DWORD PTR slen$[rsp]
  00061	4c 8b 04 24	 mov	 r8, QWORD PTR dptr$[rsp]
  00065	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00069	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al

; 280  :     }

  0006d	eb c7		 jmp	 SHORT $LN2@sl_atoe
$LN3@sl_atoe:

; 281  : 
; 282  :     return( (char *)dptr );

  0006f	48 8b 04 24	 mov	 rax, QWORD PTR dptr$[rsp]

; 283  : }

  00073	48 83 c4 18	 add	 rsp, 24
  00077	c3		 ret	 0
sl_atoe	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
time	PROC

; 521  :         {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 522  :             return _time64(_Time);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Time$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__time64

; 523  :         }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
localtime PROC

; 498  :         {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 499  :             return _localtime64(_Time);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Time$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__localtime64

; 500  :         }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
localtime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sprintf	PROC						; COMDAT

; 1771 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsprintf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1779 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1780 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1458 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00027	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  0002c	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00038	e8 00 00 00 00	 call	 _vsnprintf_l

; 1460 :     }

  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1391 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 83 c8 01	 or	 rax, 1
  00024	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00029	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00033	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00038	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  0003d	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00042	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00047	48 8b c8	 mov	 rcx, rax
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  00050	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00054	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00059	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  0005b	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00063	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00065	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  00069	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  0006d	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1397 :     }

  00071	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00075	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
