; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
VOL1_KEYA DB	056H
	DB	04fH
	DB	04cH
	DB	031H
VOL1_KEY DB	0e5H
	DB	0d6H
	DB	0d3H
	DB	0f1H
IPL1_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f1H
IPL2_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f2H
iplpsw	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
iplccw1	DB	06H
	DB	00H
	DB	03aH
	DB	098H
	DB	060H
	DB	00H
	DB	00H
	DB	060H
iplccw2	DB	08H
	DB	00H
	DB	03aH
	DB	098H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
noiplpsw DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0fH
noiplccw1 DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
noiplccw2 DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
ipl2data DB	07H
	DB	00H
	DB	03aH
	DB	0b8H
	DB	040H
	DB	00H
	DB	00H
	DB	06H
	DB	031H
	DB	00H
	DB	03aH
	DB	0beH
	DB	040H
	DB	00H
	DB	00H
	DB	05H
	DB	08H
	DB	00H
	DB	03aH
	DB	0a0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	06H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	00H
	DB	07fH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	04H
	ORG $+5
?endofdir@?1??process_dirblk@@9@9 DB 0ffH		; `process_dirblk'::`2'::endofdir
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	do_cat
PUBLIC	get_volser
PUBLIC	do_cat_cards
PUBLIC	do_cat_pdsmember
PUBLIC	process_member
PUBLIC	process_dirblk
PUBLIC	main
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp__errno:PROC
EXTRN	strchr:PROC
EXTRN	strcmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strncpy:PROC
EXTRN	__imp__chsize_s:PROC
EXTRN	__imp_isatty:PROC
EXTRN	__imp_setmode:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_putchar:PROC
EXTRN	__imp_puts:PROC
EXTRN	__imp_rewind:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp_fileno:PROC
EXTRN	__imp_fmt_memsize:PROC
EXTRN	__imp_initialize_utility:PROC
EXTRN	__imp_string_to_upper:PROC
EXTRN	__imp_string_to_lower:PROC
EXTRN	__imp_make_asciiz:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_w32_fwrite:PROC
EXTRN	__imp_w32_fprintf:PROC
EXTRN	__imp_guest_to_host:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_read_block:PROC
EXTRN	__imp_convert_tt:PROC
EXTRN	__imp_open_ckd_image:PROC
EXTRN	__imp_close_ckd_image:PROC
EXTRN	__imp_build_extent_array:PROC
EXTRN	__imp_set_verbose_util:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_extgui:DWORD
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
found	DD	01H DUP (?)
volser	DB	07H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$printf
pdata	ENDS
pdata	SEGMENT
$pdata$do_cat DD imagerel $LN39
	DD	imagerel $LN39+1629
	DD	imagerel $unwind$do_cat
$pdata$get_volser DD imagerel $LN5
	DD	imagerel $LN5+227
	DD	imagerel $unwind$get_volser
$pdata$do_cat_cards DD imagerel $LN9
	DD	imagerel $LN9+350
	DD	imagerel $unwind$do_cat_cards
$pdata$do_cat_pdsmember DD imagerel $LN16
	DD	imagerel $LN16+484
	DD	imagerel $unwind$do_cat_pdsmember
$pdata$process_member DD imagerel $LN22
	DD	imagerel $LN22+1167
	DD	imagerel $unwind$process_member
$pdata$process_dirblk DD imagerel $LN18
	DD	imagerel $LN18+957
	DD	imagerel $unwind$process_dirblk
$pdata$main DD	imagerel $LN15
	DD	imagerel $LN15+663
	DD	imagerel $unwind$main
pdata	ENDS
_DATA	SEGMENT
$SG159647 DB	'DASD cat program', 00H
	ORG $+7
$SG159648 DB	'dasdcat', 00H
$SG159650 DB	'I', 00H
	ORG $+2
$SG159652 DB	'main', 00H
	ORG $+7
$SG159651 DB	'HHC02405%s Usage:', 0aH, 'HHC02405I', 0aH, 'HHC02405I   '
	DB	'    %s [-i dasd_image [sf=shadowfile] spec...]...', 0aH, 'HHC'
	DB	'02405I', 0aH, 'HHC02405I Where:', 0aH, 'HHC02405I', 0aH, 'HHC'
	DB	'02405I       -i             indicates next arg is input file', 0aH
	DB	'HHC02405I       dasd_image     input dasd image file', 0aH, 'H'
	DB	'HC02405I       shadowfile     optional dasd image shadow file'
	DB	0aH, 'HHC02405I       spec           pdsname/memname[:flags]', 0aH
	DB	'HHC02405I', 0aH, 'HHC02405I       pdsname        the name of '
	DB	'the partitioned dataset', 0aH, 'HHC02405I       memname      '
	DB	'  either a specific member name or one', 0aH, 'HHC02405I     '
	DB	'                 of the following special characters:', 0aH, 'H'
	DB	'HC02405I', 0aH, 'HHC02405I                         ''?''    j'
	DB	'ust list all of the names', 0aH, 'HHC02405I                  '
	DB	'              of pdsname''s members', 0aH, 'HHC02405I', 0aH, 'H'
	DB	'HC02405I                         ''*''    selects all pdsname'
	DB	' members', 0aH, 'HHC02405I', 0aH, 'HHC02405I       flags     '
	DB	'     indicates how to format selected members:', 0aH, 'HHC024'
	DB	'05I', 0aH, 'HHC02405I                         ''c''    as 72 '
	DB	'or 80 column card images', 0aH, 'HHC02405I                   '
	DB	'      ''s''    indicates ''c'' shoud be 80 cols', 0aH, 'HHC02'
	DB	'405I                         ''a''    as plain unformatted AS'
	DB	'CII', 0aH, 'HHC02405I                         ''?''    member'
	DB	' CCCCHHR/size info only', 0aH, 'HHC02405I', 0aH, 'HHC02405I M'
	DB	'ore than one flag may be specified. The ''s'' option is ignor'
	DB	'ed', 0aH, 'HHC02405I unless the ''c'' option is also specifie'
	DB	'd. Both imply ''a'' ASCII.', 0aH, 'HHC02405I', 0aH, 'HHC02405'
	DB	'I If no flags are given the member is written in binary exact'
	DB	'ly', 0aH, 'HHC02405I as-is. Use caution when no formatting fl'
	DB	'ags are given since', 0aH, 'HHC02405I many terminal programs '
	DB	'do not react too well when pure binary', 0aH, 'HHC02405I data'
	DB	' is written to the screen. When selecting a single member', 0aH
	DB	'HHC02405I without any formatting options it is highly recomme'
	DB	'nded that', 0aH, 'HHC02405I you redirect output to another fi'
	DB	'le (e.g. dasdcat ... > file).', 0aH, 'HHC02405I', 0aH, 'HHC02'
	DB	'405I Return code is 0 if successful or 1 if any errors.', 0aH
	DB	00H
	ORG $+2
$SG159653 DB	'dasdcat.c', 00H
	ORG $+2
$SG159656 DB	'-i', 00H
	ORG $+1
$SG159659 DB	'sf=', 00H
$SG159662 DB	'E', 00H
	ORG $+2
$SG159663 DB	'HHC02403%s Failed opening %s', 0aH, 00H
	ORG $+2
$SG159664 DB	'main', 00H
	ORG $+3
$SG159665 DB	'dasdcat.c', 00H
	ORG $+2
$SG159681 DB	'E', 00H
	ORG $+2
$SG159682 DB	'HHC02404%s Can''t make 80 column card images from block '
	DB	'length %d', 0aH, 00H
	ORG $+2
$SG159738 DB	'I', 00H
	ORG $+2
$SG159683 DB	'do_cat_cards', 00H
	ORG $+3
$SG159684 DB	'dasdcat.c', 00H
	ORG $+6
$SG159740 DB	'process_member', 00H
	ORG $+1
$SG159772 DB	'HHC02400%s Directory block byte count is invalid', 0aH, 00H
	ORG $+6
$SG159739 DB	'HHC02407%s %s/%s/%-8s %8s bytes from %4.4X%2.2X%2.2X to '
	DB	'%4.4X%2.2X%2.2X', 0aH, 00H
	ORG $+3
$SG159771 DB	'E', 00H
	ORG $+2
$SG159741 DB	'dasdcat.c', 00H
	ORG $+2
$SG159786 DB	'E', 00H
	ORG $+2
$SG159773 DB	'process_dirblk', 00H
	ORG $+1
$SG159774 DB	'dasdcat.c', 00H
	ORG $+2
$SG159868 DB	'E', 00H
	ORG $+2
$SG159782 DB	'> Member %s', 0aH, 00H
	ORG $+3
$SG159785 DB	'ftruncate', 00H
	ORG $+2
$SG159870 DB	'do_cat', 00H
	ORG $+1
$SG159882 DB	'*', 00H
	ORG $+2
$SG159787 DB	'HHC02408%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG159788 DB	'process_dirblk', 00H
	ORG $+1
$SG159789 DB	'dasdcat.c', 00H
	ORG $+2
$SG159884 DB	'?', 00H
	ORG $+2
$SG159819 DB	'CTRK=%d', 0aH, 00H
	ORG $+3
$SG159886 DB	'E', 00H
	ORG $+2
$SG159869 DB	'HHC02402%s Unknown ''member:flags'' formatting option %s'
	DB	0aH, 00H
$SG159871 DB	'dasdcat.c', 00H
	ORG $+2
$SG159888 DB	'do_cat', 00H
	ORG $+1
$SG159890 DB	'E', 00H
	ORG $+2
$SG159877 DB	'ETRK=%d', 0aH, 00H
	ORG $+7
$SG159887 DB	'HHC02406%s Member ''%s'' not found in dataset ''%s'' on '
	DB	'volume ''%s''', 0aH, 00H
	ORG $+3
$SG159892 DB	'do_cat', 00H
	ORG $+1
$SG159903 DB	'E', 00H
	ORG $+2
$SG159889 DB	'dasdcat.c', 00H
	ORG $+6
$SG159891 DB	'HHC02401%s Non-PDS-members not yet supported', 0aH, 00H
	ORG $+2
$SG159893 DB	'dasdcat.c', 00H
	ORG $+2
$SG159902 DB	'VOL1', 00H
	ORG $+7
$SG159904 DB	'HHC02471%s %s record not found', 0aH, 00H
$SG159905 DB	'get_volser', 00H
	ORG $+5
$SG159906 DB	'dasdcat.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:process_dirblk
	DD	026H
	DD	03a3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:process_member
	DD	024H
	DD	0477H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:do_cat_pdsmember
	DD	027H
	DD	01caH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:do_cat_cards
	DD	01fH
	DD	0146H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:do_cat
	DD	01bH
	DD	0645H
voltbl	ENDS
xdata	SEGMENT
$unwind$do_cat DD 022319H
	DD	0410111H
	DD	imagerel __GSHandlerCheck
	DD	01f0H
$unwind$get_volser DD 010901H
	DD	0a209H
$unwind$do_cat_cards DD 022719H
	DD	0190115H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$do_cat_pdsmember DD 042f19H
	DD	02f011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0160H
$unwind$process_member DD 022c19H
	DD	02f011aH
	DD	imagerel __GSHandlerCheck
	DD	0160H
$unwind$process_dirblk DD 042e19H
	DD	015011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$main DD	010d01H
	DD	0e20dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdcat.c
_TEXT	SEGMENT
rc$ = 64
cif$ = 72
sfn$ = 80
pgm$ = 88
fn$ = 96
argc$ = 128
argv$ = 136
main	PROC

; 53   : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 54   :  char           *pgm;                    /* less any extension (.ext) */
; 55   :  int             rc = 0;

  0000d	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 56   :  CIFBLK         *cif = 0;

  00015	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR cif$[rsp], 0

; 57   :  char           *fn;
; 58   :  char           *sfn;
; 59   : 
; 60   :     INITIALIZE_UTILITY( UTILITY_NAME, UTILITY_DESC, &pgm );

  0001e	48 8d 44 24 58	 lea	 rax, QWORD PTR pgm$[rsp]
  00023	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00028	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159647
  0002f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159648
  00036	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0003e	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_initialize_utility
  0004b	89 84 24 80 00
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 61   : 
; 62   :     if (argc < 2)

  00052	83 bc 24 80 00
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  0005a	7d 5b		 jge	 SHORT $LN4@main

; 63   :     {
; 64   :         // "Usage: dasdcat..."
; 65   :         WRMSG( HHC02405, "I", pgm );

  0005c	b9 01 00 00 00	 mov	 ecx, 1
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00067	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pgm$[rsp]
  0006c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159650
  00078	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159651
  00084	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00089	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00094	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159652
  0009b	ba 41 00 00 00	 mov	 edx, 65			; 00000041H
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159653
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 66   :         return 1;

  000ad	b8 01 00 00 00	 mov	 eax, 1
  000b2	e9 db 01 00 00	 jmp	 $LN1@main
$LN4@main:

; 67   :     }
; 68   : 
; 69   :  /*
; 70   :  * If your version of Hercules doesn't have support in its
; 71   :  * dasdutil.c for turning off verbose messages, then remove
; 72   :  * the following line but you'll have to live with chatty
; 73   :  * progress output on stdout.
; 74   :  */
; 75   :  set_verbose_util(0);

  000b7	33 c9		 xor	 ecx, ecx
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_verbose_util
$LN2@main:

; 76   : 
; 77   :  while (*++argv)

  000bf	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  000c7	48 83 c0 08	 add	 rax, 8
  000cb	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR argv$[rsp], rax
  000d3	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  000db	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000df	0f 84 96 01 00
	00		 je	 $LN3@main

; 78   :  {
; 79   :      if (!strcmp(*argv, "-i"))

  000e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159656
  000ec	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  000f4	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000f7	e8 00 00 00 00	 call	 strcmp
  000fc	85 c0		 test	 eax, eax
  000fe	0f 85 40 01 00
	00		 jne	 $LN5@main

; 80   :      {
; 81   :          fn = *++argv;

  00104	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0010c	48 83 c0 08	 add	 rax, 8
  00110	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR argv$[rsp], rax
  00118	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00120	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00123	48 89 44 24 60	 mov	 QWORD PTR fn$[rsp], rax

; 82   :          if (*(argv+1) && strlen (*(argv+1)) > 3 && !memcmp(*(argv+1), "sf=", 3))

  00128	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00130	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00135	74 5f		 je	 SHORT $LN7@main
  00137	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0013f	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00143	e8 00 00 00 00	 call	 strlen
  00148	48 83 f8 03	 cmp	 rax, 3
  0014c	76 48		 jbe	 SHORT $LN7@main
  0014e	41 b8 03 00 00
	00		 mov	 r8d, 3
  00154	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159659
  0015b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00163	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00167	e8 00 00 00 00	 call	 memcmp
  0016c	85 c0		 test	 eax, eax
  0016e	75 26		 jne	 SHORT $LN7@main

; 83   :              sfn = *++argv;

  00170	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00178	48 83 c0 08	 add	 rax, 8
  0017c	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR argv$[rsp], rax
  00184	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0018c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0018f	48 89 44 24 50	 mov	 QWORD PTR sfn$[rsp], rax
  00194	eb 09		 jmp	 SHORT $LN8@main
$LN7@main:

; 84   :          else sfn = NULL;

  00196	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR sfn$[rsp], 0
$LN8@main:

; 85   :          if (cif)

  0019f	48 83 7c 24 48
	00		 cmp	 QWORD PTR cif$[rsp], 0
  001a5	74 14		 je	 SHORT $LN9@main

; 86   :          {
; 87   :              close_ckd_image(cif);

  001a7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cif$[rsp]
  001ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_ckd_image

; 88   :              cif = 0;

  001b2	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR cif$[rsp], 0
$LN9@main:

; 89   :          }
; 90   :          cif = open_ckd_image(fn, sfn, O_RDONLY | O_BINARY, IMAGE_OPEN_NORMAL);

  001bb	45 33 c9	 xor	 r9d, r9d
  001be	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  001c4	48 8b 54 24 50	 mov	 rdx, QWORD PTR sfn$[rsp]
  001c9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fn$[rsp]
  001ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open_ckd_image
  001d4	48 89 44 24 48	 mov	 QWORD PTR cif$[rsp], rax

; 91   :          if (!cif)

  001d9	48 83 7c 24 48
	00		 cmp	 QWORD PTR cif$[rsp], 0
  001df	75 61		 jne	 SHORT $LN10@main

; 92   :          {
; 93   :              // "Failed opening %s"
; 94   :              FWRMSG( stderr, HHC02403, "E", *argv );

  001e1	b9 02 00 00 00	 mov	 ecx, 2
  001e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001ec	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001f4	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001f7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159662
  00203	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00208	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159663
  0020f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00214	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00219	41 b9 03 00 00
	00		 mov	 r9d, 3
  0021f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159664
  00226	ba 5e 00 00 00	 mov	 edx, 94			; 0000005eH
  0022b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159665
  00232	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 95   :              rc = 1;

  00238	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR rc$[rsp], 1

; 96   :              break;

  00240	eb 39		 jmp	 SHORT $LN3@main
$LN10@main:

; 97   :          }
; 98   :      }

  00242	eb 32		 jmp	 SHORT $LN6@main
$LN5@main:

; 99   :      else if (cif)

  00244	48 83 7c 24 48
	00		 cmp	 QWORD PTR cif$[rsp], 0
  0024a	74 2a		 je	 SHORT $LN11@main

; 100  :      {
; 101  :          if ((rc = do_cat( cif, *argv )) != 0)

  0024c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00254	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00257	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cif$[rsp]
  0025c	e8 00 00 00 00	 call	 do_cat
  00261	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax
  00265	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  0026a	74 0a		 je	 SHORT $LN12@main

; 102  :          {
; 103  :              rc = 1;

  0026c	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR rc$[rsp], 1

; 104  :              break;

  00274	eb 05		 jmp	 SHORT $LN3@main
$LN12@main:
$LN11@main:
$LN6@main:

; 105  :          }
; 106  :      }
; 107  :  }

  00276	e9 44 fe ff ff	 jmp	 $LN2@main
$LN3@main:

; 108  : 
; 109  :  if (cif)

  0027b	48 83 7c 24 48
	00		 cmp	 QWORD PTR cif$[rsp], 0
  00281	74 0b		 je	 SHORT $LN13@main

; 110  :  close_ckd_image(cif);

  00283	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cif$[rsp]
  00288	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_ckd_image
$LN13@main:

; 111  : 
; 112  :  return rc;

  0028e	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@main:

; 113  : }

  00292	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00296	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdcat.c
_TEXT	SEGMENT
dirrem$ = 80
size$1 = 84
dirent$2 = 88
rc$ = 96
k$3 = 100
tv176 = 104
memname$ = 112
memname_lc$4 = 128
__$ArrayPad$ = 144
cif$ = 192
noext$ = 200
extent$ = 208
dirblk$ = 216
dsname$ = 224
pdsmember$ = 232
optflags$ = 240
process_dirblk PROC

; 235  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 236  :  int rc;
; 237  :  int dirrem;
; 238  :  char memname[9];
; 239  :  static const BYTE endofdir[8] = {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};
; 240  : 
; 241  :     /* Load number of bytes in directory block */
; 242  :     dirrem = (dirblk[0] << 8) | dirblk[1];

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 00	 imul	 rax, rax, 0
  00037	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR dirblk$[rsp]
  0003f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00043	c1 e0 08	 shl	 eax, 8
  00046	b9 01 00 00 00	 mov	 ecx, 1
  0004b	48 6b c9 01	 imul	 rcx, rcx, 1
  0004f	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR dirblk$[rsp]
  00057	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0005b	0b c1		 or	 eax, ecx
  0005d	89 44 24 50	 mov	 DWORD PTR dirrem$[rsp], eax

; 243  :     if (dirrem < 2 || dirrem > 256)

  00061	83 7c 24 50 02	 cmp	 DWORD PTR dirrem$[rsp], 2
  00066	7c 0a		 jl	 SHORT $LN5@process_di
  00068	81 7c 24 50 00
	01 00 00	 cmp	 DWORD PTR dirrem$[rsp], 256 ; 00000100H
  00070	7e 51		 jle	 SHORT $LN4@process_di
$LN5@process_di:

; 244  :     {
; 245  :         // "Directory block byte count is invalid"
; 246  :         FWRMSG( stderr, HHC02400, "E" );

  00072	b9 02 00 00 00	 mov	 ecx, 2
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159771
  00084	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159772
  00090	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00095	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009a	41 b9 03 00 00
	00		 mov	 r9d, 3
  000a0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159773
  000a7	ba f6 00 00 00	 mov	 edx, 246		; 000000f6H
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159774
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 247  :         return -1;

  000b9	b8 ff ff ff ff	 mov	 eax, -1
  000be	e9 e0 02 00 00	 jmp	 $LN1@process_di
$LN4@process_di:

; 248  :     }
; 249  : 
; 250  :     /* Point to first directory entry */
; 251  :     dirblk += 2;

  000c3	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dirblk$[rsp]
  000cb	48 83 c0 02	 add	 rax, 2
  000cf	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR dirblk$[rsp], rax

; 252  :     dirrem -= 2;

  000d7	8b 44 24 50	 mov	 eax, DWORD PTR dirrem$[rsp]
  000db	83 e8 02	 sub	 eax, 2
  000de	89 44 24 50	 mov	 DWORD PTR dirrem$[rsp], eax
$LN2@process_di:

; 253  : 
; 254  :     while (dirrem > 0)

  000e2	83 7c 24 50 00	 cmp	 DWORD PTR dirrem$[rsp], 0
  000e7	0f 8e b4 02 00
	00		 jle	 $LN3@process_di

; 255  :     {
; 256  :      PDSDIR *dirent = (PDSDIR*)dirblk;

  000ed	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dirblk$[rsp]
  000f5	48 89 44 24 58	 mov	 QWORD PTR dirent$2[rsp], rax

; 257  :      int k, size;
; 258  : 
; 259  :         /* Check for end of directory */
; 260  :         if (memcmp( endofdir, dirent->pds2name, 8 ) == 0)

  000fa	48 8b 44 24 58	 mov	 rax, QWORD PTR dirent$2[rsp]
  000ff	41 b8 08 00 00
	00		 mov	 r8d, 8
  00105	48 8b d0	 mov	 rdx, rax
  00108	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?endofdir@?1??process_dirblk@@9@9
  0010f	e8 00 00 00 00	 call	 memcmp
  00114	85 c0		 test	 eax, eax
  00116	75 0a		 jne	 SHORT $LN6@process_di

; 261  :             return +1; /* (logical EOF) */

  00118	b8 01 00 00 00	 mov	 eax, 1
  0011d	e9 81 02 00 00	 jmp	 $LN1@process_di
$LN6@process_di:

; 262  : 
; 263  :         /* Extract this member's name */
; 264  :         make_asciiz(memname, sizeof(memname), dirent->pds2name, 8);

  00122	48 8b 44 24 58	 mov	 rax, QWORD PTR dirent$2[rsp]
  00127	41 b9 08 00 00
	00		 mov	 r9d, 8
  0012d	4c 8b c0	 mov	 r8, rax
  00130	ba 09 00 00 00	 mov	 edx, 9
  00135	48 8d 4c 24 70	 lea	 rcx, QWORD PTR memname$[rsp]
  0013a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_make_asciiz

; 265  : 
; 266  :         if (optflags & OPT_PDS_LISTONLY)

  00140	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR optflags$[rsp]
  00147	83 e0 08	 and	 eax, 8
  0014a	85 c0		 test	 eax, eax
  0014c	74 3b		 je	 SHORT $LN7@process_di

; 267  :         {
; 268  :          char memname_lc[9];
; 269  :             /* List just the member names in this PDS */
; 270  :             memcpy(memname_lc, memname, sizeof(memname));

  0014e	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR memname_lc$4[rsp]
  00156	48 8d 4c 24 70	 lea	 rcx, QWORD PTR memname$[rsp]
  0015b	48 8b f8	 mov	 rdi, rax
  0015e	48 8b f1	 mov	 rsi, rcx
  00161	b9 09 00 00 00	 mov	 ecx, 9
  00166	f3 a4		 rep movsb

; 271  :             string_to_lower(memname_lc);

  00168	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR memname_lc$4[rsp]
  00170	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_string_to_lower

; 272  :             puts(memname_lc);

  00176	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR memname_lc$4[rsp]
  0017e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_puts

; 273  :         }

  00184	e9 cc 01 00 00	 jmp	 $LN8@process_di
$LN7@process_di:

; 274  :         else
; 275  :         {
; 276  :             /* Are we interested in this specific member? */
; 277  :             if (0
; 278  :                 || (optflags & OPT_PDS_WILDCARD)
; 279  :                 || strcmp( pdsmember, memname ) == 0

  00189	33 c0		 xor	 eax, eax
  0018b	85 c0		 test	 eax, eax
  0018d	75 28		 jne	 SHORT $LN10@process_di
  0018f	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR optflags$[rsp]
  00196	83 e0 04	 and	 eax, 4
  00199	85 c0		 test	 eax, eax
  0019b	75 1a		 jne	 SHORT $LN10@process_di
  0019d	48 8d 54 24 70	 lea	 rdx, QWORD PTR memname$[rsp]
  001a2	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR pdsmember$[rsp]
  001aa	e8 00 00 00 00	 call	 strcmp
  001af	85 c0		 test	 eax, eax
  001b1	0f 85 9e 01 00
	00		 jne	 $LN9@process_di
$LN10@process_di:

; 280  :             )
; 281  :             {
; 282  :                 if (optflags & OPT_PDS_WILDCARD && !(optflags & OPT_MEMINFO_ONLY))

  001b7	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR optflags$[rsp]
  001be	83 e0 04	 and	 eax, 4
  001c1	85 c0		 test	 eax, eax
  001c3	74 24		 je	 SHORT $LN11@process_di
  001c5	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR optflags$[rsp]
  001cc	83 e0 20	 and	 eax, 32			; 00000020H
  001cf	85 c0		 test	 eax, eax
  001d1	75 16		 jne	 SHORT $LN11@process_di

; 283  :                     printf("> Member %s\n", memname);

  001d3	48 8d 54 24 70	 lea	 rdx, QWORD PTR memname$[rsp]
  001d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159782
  001df	e8 00 00 00 00	 call	 printf
  001e4	e9 f1 00 00 00	 jmp	 $LN12@process_di
$LN11@process_di:

; 284  :                 else if (1
; 285  :                     && !(optflags & OPT_MEMINFO_ONLY)
; 286  :                     && !isatty( fileno( stdout ))

  001e9	33 c0		 xor	 eax, eax
  001eb	83 f8 01	 cmp	 eax, 1
  001ee	0f 84 e6 00 00
	00		 je	 $LN13@process_di
  001f4	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR optflags$[rsp]
  001fb	83 e0 20	 and	 eax, 32			; 00000020H
  001fe	85 c0		 test	 eax, eax
  00200	0f 85 d4 00 00
	00		 jne	 $LN13@process_di
  00206	b9 01 00 00 00	 mov	 ecx, 1
  0020b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00211	48 8b c8	 mov	 rcx, rax
  00214	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  0021a	8b c8		 mov	 ecx, eax
  0021c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isatty
  00222	85 c0		 test	 eax, eax
  00224	0f 85 b0 00 00
	00		 jne	 $LN13@process_di

; 287  :                 )
; 288  :                 {
; 289  :                     /* Delete any existing o/p file contents */
; 290  :                     rewind( stdout );

  0022a	b9 01 00 00 00	 mov	 ecx, 1
  0022f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00235	48 8b c8	 mov	 rcx, rax
  00238	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rewind

; 291  :                     if (ftruncate( fileno( stdout ), 0 ) < 0)

  0023e	b9 01 00 00 00	 mov	 ecx, 1
  00243	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00249	48 8b c8	 mov	 rcx, rax
  0024c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  00252	33 d2		 xor	 edx, edx
  00254	8b c8		 mov	 ecx, eax
  00256	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__chsize_s
  0025c	85 c0		 test	 eax, eax
  0025e	7d 7a		 jge	 SHORT $LN14@process_di

; 292  :                     {
; 293  :                         // "Error in function %s: %s"
; 294  :                         FWRMSG( stderr, HHC02408, "E", "ftruncate", strerror( errno ));

  00260	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00266	8b 08		 mov	 ecx, DWORD PTR [rax]
  00268	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0026e	48 89 44 24 68	 mov	 QWORD PTR tv176[rsp], rax
  00273	b9 02 00 00 00	 mov	 ecx, 2
  00278	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0027e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv176[rsp]
  00283	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00288	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159785
  0028f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00294	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159786
  0029b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159787
  002a7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002ac	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002b1	41 b9 03 00 00
	00		 mov	 r9d, 3
  002b7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159788
  002be	ba 26 01 00 00	 mov	 edx, 294		; 00000126H
  002c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159789
  002ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 295  :                         return -1;

  002d0	b8 ff ff ff ff	 mov	 eax, -1
  002d5	e9 c9 00 00 00	 jmp	 $LN1@process_di
$LN14@process_di:
$LN13@process_di:
$LN12@process_di:

; 296  :                     }
; 297  :                 }
; 298  : 
; 299  :                 rc = process_member(cif, noext, extent, dirent->pds2ttrp, optflags, dsname, memname);

  002da	48 8b 44 24 58	 mov	 rax, QWORD PTR dirent$2[rsp]
  002df	48 83 c0 08	 add	 rax, 8
  002e3	48 8d 4c 24 70	 lea	 rcx, QWORD PTR memname$[rsp]
  002e8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002ed	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dsname$[rsp]
  002f5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002fa	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR optflags$[rsp]
  00301	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00305	4c 8b c8	 mov	 r9, rax
  00308	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR extent$[rsp]
  00310	8b 94 24 c8 00
	00 00		 mov	 edx, DWORD PTR noext$[rsp]
  00317	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  0031f	e8 00 00 00 00	 call	 process_member
  00324	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 300  :                 if (rc < 0)

  00328	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  0032d	7d 07		 jge	 SHORT $LN15@process_di

; 301  :                     return -1;

  0032f	b8 ff ff ff ff	 mov	 eax, -1
  00334	eb 6d		 jmp	 SHORT $LN1@process_di
$LN15@process_di:

; 302  : 
; 303  :                 /* If not ALL members then we're done */
; 304  :                 if (!(optflags & OPT_PDS_WILDCARD))

  00336	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR optflags$[rsp]
  0033d	83 e0 04	 and	 eax, 4
  00340	85 c0		 test	 eax, eax
  00342	75 11		 jne	 SHORT $LN16@process_di

; 305  :                 {
; 306  :                     found = 1;

  00344	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR found, 1

; 307  :                     return +1; /* (logical EOF) */

  0034e	b8 01 00 00 00	 mov	 eax, 1
  00353	eb 4e		 jmp	 SHORT $LN1@process_di
$LN16@process_di:
$LN9@process_di:
$LN8@process_di:

; 308  :                 }
; 309  :             }
; 310  :         }
; 311  : 
; 312  :         /* Load the user data halfword count */
; 313  :         k = dirent->pds2indc & PDS2INDC_LUSR;

  00355	48 8b 44 24 58	 mov	 rax, QWORD PTR dirent$2[rsp]
  0035a	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  0035e	83 e0 1f	 and	 eax, 31
  00361	89 44 24 64	 mov	 DWORD PTR k$3[rsp], eax

; 314  : 
; 315  :         /* Point to next directory entry */
; 316  :         size = 12 + k*2;

  00365	8b 44 24 64	 mov	 eax, DWORD PTR k$3[rsp]
  00369	8d 44 00 0c	 lea	 eax, DWORD PTR [rax+rax+12]
  0036d	89 44 24 54	 mov	 DWORD PTR size$1[rsp], eax

; 317  :         dirblk += size;

  00371	48 63 44 24 54	 movsxd	 rax, DWORD PTR size$1[rsp]
  00376	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR dirblk$[rsp]
  0037e	48 03 c8	 add	 rcx, rax
  00381	48 8b c1	 mov	 rax, rcx
  00384	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR dirblk$[rsp], rax

; 318  :         dirrem -= size;

  0038c	8b 44 24 54	 mov	 eax, DWORD PTR size$1[rsp]
  00390	8b 4c 24 50	 mov	 ecx, DWORD PTR dirrem$[rsp]
  00394	2b c8		 sub	 ecx, eax
  00396	8b c1		 mov	 eax, ecx
  00398	89 44 24 50	 mov	 DWORD PTR dirrem$[rsp], eax

; 319  :     }

  0039c	e9 41 fd ff ff	 jmp	 $LN2@process_di
$LN3@process_di:

; 320  :     return 0;

  003a1	33 c0		 xor	 eax, eax
$LN1@process_di:

; 321  : }

  003a3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003ab	48 33 cc	 xor	 rcx, rsp
  003ae	e8 00 00 00 00	 call	 __security_check_cookie
  003b3	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  003ba	5f		 pop	 rdi
  003bb	5e		 pop	 rsi
  003bc	c3		 ret	 0
process_dirblk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdcat.c
_TEXT	SEGMENT
rec$ = 144
head$ = 145
len$ = 148
beg_rec$ = 152
beg_head$ = 153
rc$ = 156
trk$ = 160
cyl$ = 164
beg_cyl$ = 168
tv149 = 172
tv170 = 176
tv175 = 180
tv178 = 184
tv180 = 188
p$1 = 192
buf$ = 200
tot_len$ = 208
memsize$2 = 224
__$ArrayPad$ = 352
cif$ = 384
noext$ = 392
extent$ = 400
ttr$ = 408
optflags$ = 416
dsname$ = 424
memname$ = 432
process_member PROC

; 146  : {

$LN22:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 147  :  int   rc;
; 148  :  u_int trk;
; 149  :  U16   len;
; 150  :  U32   cyl;
; 151  :  U8    head;
; 152  :  U8    rec;
; 153  :  BYTE *buf;
; 154  : 
; 155  :  U32   beg_cyl  = 0;

  0002c	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR beg_cyl$[rsp], 0

; 156  :  U8    beg_head = 0;

  00037	c6 84 24 99 00
	00 00 00	 mov	 BYTE PTR beg_head$[rsp], 0

; 157  :  U8    beg_rec  = 0;

  0003f	c6 84 24 98 00
	00 00 00	 mov	 BYTE PTR beg_rec$[rsp], 0

; 158  :  U64   tot_len  = 0;

  00047	48 c7 84 24 d0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tot_len$[rsp], 0

; 159  : 
; 160  :     trk = (ttr[0] << 8) | ttr[1];

  00053	b8 01 00 00 00	 mov	 eax, 1
  00058	48 6b c0 00	 imul	 rax, rax, 0
  0005c	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR ttr$[rsp]
  00064	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00068	c1 e0 08	 shl	 eax, 8
  0006b	b9 01 00 00 00	 mov	 ecx, 1
  00070	48 6b c9 01	 imul	 rcx, rcx, 1
  00074	48 8b 94 24 98
	01 00 00	 mov	 rdx, QWORD PTR ttr$[rsp]
  0007c	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00080	0b c1		 or	 eax, ecx
  00082	89 84 24 a0 00
	00 00		 mov	 DWORD PTR trk$[rsp], eax

; 161  :     rec = ttr[2];

  00089	b8 01 00 00 00	 mov	 eax, 1
  0008e	48 6b c0 02	 imul	 rax, rax, 2
  00092	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR ttr$[rsp]
  0009a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0009e	88 84 24 90 00
	00 00		 mov	 BYTE PTR rec$[rsp], al
$LN21@process_me:
$LN2@process_me:

; 162  : 
; 163  :     while (1)

  000a5	33 c0		 xor	 eax, eax
  000a7	83 f8 01	 cmp	 eax, 1
  000aa	0f 84 9a 02 00
	00		 je	 $LN3@process_me

; 164  :     {
; 165  :         rc = convert_tt(trk, noext, extent, cif->heads, &cyl, &head);

  000b0	48 8d 84 24 91
	00 00 00	 lea	 rax, QWORD PTR head$[rsp]
  000b8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000bd	48 8d 84 24 a4
	00 00 00	 lea	 rax, QWORD PTR cyl$[rsp]
  000c5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ca	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  000d2	44 0f b6 48 24	 movzx	 r9d, BYTE PTR [rax+36]
  000d7	4c 8b 84 24 90
	01 00 00	 mov	 r8, QWORD PTR extent$[rsp]
  000df	8b 94 24 88 01
	00 00		 mov	 edx, DWORD PTR noext$[rsp]
  000e6	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_tt
  000f3	89 84 24 9c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 166  :         if (rc < 0)

  000fa	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00102	7d 0a		 jge	 SHORT $LN7@process_me

; 167  :             return -1;

  00104	b8 ff ff ff ff	 mov	 eax, -1
  00109	e9 69 03 00 00	 jmp	 $LN1@process_me
$LN7@process_me:

; 168  : 
; 169  :         rc = read_block(cif, cyl, head, rec, 0, 0, &buf, &len);

  0010e	48 8d 84 24 94
	00 00 00	 lea	 rax, QWORD PTR len$[rsp]
  00116	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0011b	48 8d 84 24 c8
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  00123	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00128	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00131	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0013a	44 0f b6 8c 24
	90 00 00 00	 movzx	 r9d, BYTE PTR rec$[rsp]
  00143	44 0f b6 84 24
	91 00 00 00	 movzx	 r8d, BYTE PTR head$[rsp]
  0014c	8b 94 24 a4 00
	00 00		 mov	 edx, DWORD PTR cyl$[rsp]
  00153	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  0015b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_block
  00161	89 84 24 9c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 170  :         if (rc < 0)

  00168	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00170	7d 0a		 jge	 SHORT $LN8@process_me

; 171  :             return -1;

  00172	b8 ff ff ff ff	 mov	 eax, -1
  00177	e9 fb 02 00 00	 jmp	 $LN1@process_me
$LN8@process_me:

; 172  : 
; 173  :         if (rc > 0)  /* end of track */

  0017c	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00184	7e 1d		 jle	 SHORT $LN9@process_me

; 174  :         {
; 175  :             trk++;

  00186	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  0018d	ff c0		 inc	 eax
  0018f	89 84 24 a0 00
	00 00		 mov	 DWORD PTR trk$[rsp], eax

; 176  :             rec = 1;

  00196	c6 84 24 90 00
	00 00 01	 mov	 BYTE PTR rec$[rsp], 1

; 177  :             continue;

  0019e	e9 02 ff ff ff	 jmp	 $LN2@process_me
$LN9@process_me:

; 178  :         }
; 179  : 
; 180  :         if (len == 0) /* end of member */

  001a3	0f b7 84 24 94
	00 00 00	 movzx	 eax, WORD PTR len$[rsp]
  001ab	85 c0		 test	 eax, eax
  001ad	75 05		 jne	 SHORT $LN10@process_me

; 181  :             break;

  001af	e9 96 01 00 00	 jmp	 $LN3@process_me
$LN10@process_me:

; 182  : 
; 183  :         if (optflags & OPT_MEMINFO_ONLY)

  001b4	8b 84 24 a0 01
	00 00		 mov	 eax, DWORD PTR optflags$[rsp]
  001bb	83 e0 20	 and	 eax, 32			; 00000020H
  001be	85 c0		 test	 eax, eax
  001c0	74 59		 je	 SHORT $LN11@process_me

; 184  :         {
; 185  :             if (!beg_cyl)

  001c2	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR beg_cyl$[rsp], 0
  001ca	75 2c		 jne	 SHORT $LN13@process_me

; 186  :             {
; 187  :                 beg_cyl  = cyl;

  001cc	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR cyl$[rsp]
  001d3	89 84 24 a8 00
	00 00		 mov	 DWORD PTR beg_cyl$[rsp], eax

; 188  :                 beg_head = head;

  001da	0f b6 84 24 91
	00 00 00	 movzx	 eax, BYTE PTR head$[rsp]
  001e2	88 84 24 99 00
	00 00		 mov	 BYTE PTR beg_head$[rsp], al

; 189  :                 beg_rec  = rec;

  001e9	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR rec$[rsp]
  001f1	88 84 24 98 00
	00 00		 mov	 BYTE PTR beg_rec$[rsp], al
$LN13@process_me:

; 190  :             }
; 191  :             tot_len += len;

  001f8	0f b7 84 24 94
	00 00 00	 movzx	 eax, WORD PTR len$[rsp]
  00200	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tot_len$[rsp]
  00208	48 03 c8	 add	 rcx, rax
  0020b	48 8b c1	 mov	 rax, rcx
  0020e	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tot_len$[rsp], rax

; 192  :         }

  00216	e9 19 01 00 00	 jmp	 $LN12@process_me
$LN11@process_me:

; 193  :         else if (optflags & OPT_CARDS)

  0021b	8b 84 24 a0 01
	00 00		 mov	 eax, DWORD PTR optflags$[rsp]
  00222	83 e0 02	 and	 eax, 2
  00225	85 c0		 test	 eax, eax
  00227	74 3f		 je	 SHORT $LN14@process_me

; 194  :         {
; 195  :             /* Formatted 72 or 80 column ASCII card images */
; 196  :             if ((rc = do_cat_cards(buf, len, optflags)) != 0)

  00229	0f b7 84 24 94
	00 00 00	 movzx	 eax, WORD PTR len$[rsp]
  00231	44 8b 84 24 a0
	01 00 00	 mov	 r8d, DWORD PTR optflags$[rsp]
  00239	8b d0		 mov	 edx, eax
  0023b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00243	e8 00 00 00 00	 call	 do_cat_cards
  00248	89 84 24 9c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  0024f	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00257	74 0a		 je	 SHORT $LN16@process_me

; 197  :                 return -1; // (len not multiple of 80 bytes)

  00259	b8 ff ff ff ff	 mov	 eax, -1
  0025e	e9 14 02 00 00	 jmp	 $LN1@process_me
$LN16@process_me:

; 198  :         }

  00263	e9 cc 00 00 00	 jmp	 $LN15@process_me
$LN14@process_me:

; 199  :         else if (optflags & OPT_ASCIIFY)

  00268	8b 84 24 a0 01
	00 00		 mov	 eax, DWORD PTR optflags$[rsp]
  0026f	83 e0 01	 and	 eax, 1
  00272	85 c0		 test	 eax, eax
  00274	74 71		 je	 SHORT $LN17@process_me

; 200  :         {
; 201  :             /* Unformatted ASCII text */
; 202  :             BYTE *p;
; 203  :             for (p = buf; len--; p++)

  00276	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0027e	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR p$1[rsp], rax
  00286	eb 13		 jmp	 SHORT $LN6@process_me
$LN4@process_me:
  00288	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR p$1[rsp]
  00290	48 ff c0	 inc	 rax
  00293	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR p$1[rsp], rax
$LN6@process_me:
  0029b	0f b7 84 24 94
	00 00 00	 movzx	 eax, WORD PTR len$[rsp]
  002a3	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv149[rsp], eax
  002aa	0f b7 84 24 94
	00 00 00	 movzx	 eax, WORD PTR len$[rsp]
  002b2	66 ff c8	 dec	 ax
  002b5	66 89 84 24 94
	00 00 00	 mov	 WORD PTR len$[rsp], ax
  002bd	83 bc 24 ac 00
	00 00 00	 cmp	 DWORD PTR tv149[rsp], 0
  002c5	74 1e		 je	 SHORT $LN5@process_me

; 204  :                 putchar(guest_to_host(*p));

  002c7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR p$1[rsp]
  002cf	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  002d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  002d8	0f b6 c0	 movzx	 eax, al
  002db	8b c8		 mov	 ecx, eax
  002dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_putchar
  002e3	eb a3		 jmp	 SHORT $LN4@process_me
$LN5@process_me:

; 205  :         }

  002e5	eb 4d		 jmp	 SHORT $LN18@process_me
$LN17@process_me:

; 206  :         else
; 207  :         {
; 208  :             /* Output member in binary exactly as-is */
; 209  : #if O_BINARY != 0
; 210  :             setmode(fileno(stdout),O_BINARY);

  002e7	b9 01 00 00 00	 mov	 ecx, 1
  002ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002f2	48 8b c8	 mov	 rcx, rax
  002f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  002fb	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  00300	8b c8		 mov	 ecx, eax
  00302	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setmode

; 211  : #endif
; 212  :             fwrite(buf, len, 1, stdout);

  00308	b9 01 00 00 00	 mov	 ecx, 1
  0030d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00313	0f b7 8c 24 94
	00 00 00	 movzx	 ecx, WORD PTR len$[rsp]
  0031b	4c 8b c8	 mov	 r9, rax
  0031e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00324	8b d1		 mov	 edx, ecx
  00326	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0032e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite
$LN18@process_me:
$LN15@process_me:
$LN12@process_me:

; 213  :         }
; 214  : 
; 215  :         rec++;

  00334	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR rec$[rsp]
  0033c	fe c0		 inc	 al
  0033e	88 84 24 90 00
	00 00		 mov	 BYTE PTR rec$[rsp], al

; 216  :     }

  00345	e9 5b fd ff ff	 jmp	 $LN21@process_me
$LN3@process_me:

; 217  : 
; 218  :     if (optflags & OPT_MEMINFO_ONLY)

  0034a	8b 84 24 a0 01
	00 00		 mov	 eax, DWORD PTR optflags$[rsp]
  00351	83 e0 20	 and	 eax, 32			; 00000020H
  00354	85 c0		 test	 eax, eax
  00356	0f 84 19 01 00
	00		 je	 $LN19@process_me

; 219  :     {
; 220  :         char memsize[128];
; 221  :         fmt_memsize( tot_len, memsize, sizeof( memsize ));

  0035c	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  00362	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR memsize$2[rsp]
  0036a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tot_len$[rsp]
  00372	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fmt_memsize

; 222  : 
; 223  :         // "%s/%s/%-8s %8s bytes from %4.4"PRIX32"%2.2"PRIX32"%2.2"PRIX32" to %4.4"PRIX32"%2.2"PRIX32"%2.2"PRIX32
; 224  :         FWRMSG( stdout, HHC02407, "I",

  00378	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR rec$[rsp]
  00380	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv170[rsp], eax
  00387	0f b6 8c 24 91
	00 00 00	 movzx	 ecx, BYTE PTR head$[rsp]
  0038f	89 8c 24 b4 00
	00 00		 mov	 DWORD PTR tv175[rsp], ecx
  00396	0f b6 94 24 98
	00 00 00	 movzx	 edx, BYTE PTR beg_rec$[rsp]
  0039e	89 94 24 b8 00
	00 00		 mov	 DWORD PTR tv178[rsp], edx
  003a5	44 0f b6 84 24
	99 00 00 00	 movzx	 r8d, BYTE PTR beg_head$[rsp]
  003ae	44 89 84 24 bc
	00 00 00	 mov	 DWORD PTR tv180[rsp], r8d
  003b6	b9 01 00 00 00	 mov	 ecx, 1
  003bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003c1	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv170[rsp]
  003c8	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  003cf	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv175[rsp]
  003d6	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  003da	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR cyl$[rsp]
  003e1	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  003e5	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv178[rsp]
  003ec	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  003f0	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv180[rsp]
  003f7	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  003fb	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR beg_cyl$[rsp]
  00402	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00406	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR memsize$2[rsp]
  0040e	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00413	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR memname$[rsp]
  0041b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00420	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR dsname$[rsp]
  00428	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0042d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:volser
  00434	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00439	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159738
  00440	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00445	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159739
  0044c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00451	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00456	41 b9 03 00 00
	00		 mov	 r9d, 3
  0045c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159740
  00463	ba e3 00 00 00	 mov	 edx, 227		; 000000e3H
  00468	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159741
  0046f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN19@process_me:

; 225  :             volser, dsname, memname, memsize,
; 226  :             (U32) beg_cyl, (U32) beg_head, (U32) beg_rec,
; 227  :             (U32)     cyl, (U32)     head, (U32)     rec );
; 228  :     }
; 229  : 
; 230  :     return 0;

  00475	33 c0		 xor	 eax, eax
$LN1@process_me:

; 231  : }

  00477	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0047f	48 33 cc	 xor	 rcx, rsp
  00482	e8 00 00 00 00	 call	 __security_check_cookie
  00487	48 81 c4 78 01
	00 00		 add	 rsp, 376		; 00000178H
  0048e	c3		 ret	 0
process_member ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdcat.c
_TEXT	SEGMENT
rec$ = 64
head$1 = 65
rc$ = 68
trk$ = 72
len$2 = 76
cyl$3 = 80
blkptr$4 = 88
dirblk$5 = 96
__$ArrayPad$ = 352
cif$ = 400
extent$ = 408
noext$ = 416
dsname$ = 424
pdsmember$ = 432
optflags$ = 440
do_cat_pdsmember PROC

; 325  : {

$LN16:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 326  :  int   rc;
; 327  :  u_int trk;
; 328  :  U8    rec;
; 329  : 
; 330  :     /* Point to the start of the directory */
; 331  :     trk = 0;

  0002f	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR trk$[rsp], 0

; 332  :     rec = 1;

  00037	c6 44 24 40 01	 mov	 BYTE PTR rec$[rsp], 1
$LN15@do_cat_pds:
$LN2@do_cat_pds:

; 333  : 
; 334  :     /* Read the directory */
; 335  :     while (1)

  0003c	33 c0		 xor	 eax, eax
$LN6@do_cat_pds:

; 336  :     {
; 337  :      BYTE *blkptr;
; 338  :      BYTE dirblk[256];
; 339  :      U32 cyl;
; 340  :      U8  head;
; 341  :      U16 len;
; 342  :         EXTGUIMSG( "CTRK=%d\n", trk );

  0003e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  00045	83 38 00	 cmp	 DWORD PTR [rax], 0
  00048	74 20		 je	 SHORT $LN7@do_cat_pds
  0004a	b9 02 00 00 00	 mov	 ecx, 2
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00055	44 8b 44 24 48	 mov	 r8d, DWORD PTR trk$[rsp]
  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159819
  00061	48 8b c8	 mov	 rcx, rax
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN7@do_cat_pds:
  0006a	33 c0		 xor	 eax, eax
  0006c	85 c0		 test	 eax, eax
  0006e	75 ce		 jne	 SHORT $LN6@do_cat_pds

; 343  :         rc = convert_tt(trk, noext, extent, cif->heads, &cyl, &head);

  00070	48 8d 44 24 41	 lea	 rax, QWORD PTR head$1[rsp]
  00075	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0007a	48 8d 44 24 50	 lea	 rax, QWORD PTR cyl$3[rsp]
  0007f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00084	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  0008c	44 0f b6 48 24	 movzx	 r9d, BYTE PTR [rax+36]
  00091	4c 8b 84 24 98
	01 00 00	 mov	 r8, QWORD PTR extent$[rsp]
  00099	8b 94 24 a0 01
	00 00		 mov	 edx, DWORD PTR noext$[rsp]
  000a0	8b 4c 24 48	 mov	 ecx, DWORD PTR trk$[rsp]
  000a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_tt
  000aa	89 44 24 44	 mov	 DWORD PTR rc$[rsp], eax

; 344  :         if (rc < 0)

  000ae	83 7c 24 44 00	 cmp	 DWORD PTR rc$[rsp], 0
  000b3	7d 0a		 jge	 SHORT $LN8@do_cat_pds

; 345  :             return -1;

  000b5	b8 ff ff ff ff	 mov	 eax, -1
  000ba	e9 0b 01 00 00	 jmp	 $LN1@do_cat_pds
$LN8@do_cat_pds:

; 346  : 
; 347  :         rc = read_block(cif, cyl, head, rec, 0, 0, &blkptr, &len);

  000bf	48 8d 44 24 4c	 lea	 rax, QWORD PTR len$2[rsp]
  000c4	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  000c9	48 8d 44 24 58	 lea	 rax, QWORD PTR blkptr$4[rsp]
  000ce	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000d3	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  000dc	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000e5	44 0f b6 4c 24
	40		 movzx	 r9d, BYTE PTR rec$[rsp]
  000eb	44 0f b6 44 24
	41		 movzx	 r8d, BYTE PTR head$1[rsp]
  000f1	8b 54 24 50	 mov	 edx, DWORD PTR cyl$3[rsp]
  000f5	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  000fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_block
  00103	89 44 24 44	 mov	 DWORD PTR rc$[rsp], eax

; 348  :         if (rc < 0)

  00107	83 7c 24 44 00	 cmp	 DWORD PTR rc$[rsp], 0
  0010c	7d 0a		 jge	 SHORT $LN9@do_cat_pds

; 349  :             return -1;

  0010e	b8 ff ff ff ff	 mov	 eax, -1
  00113	e9 b2 00 00 00	 jmp	 $LN1@do_cat_pds
$LN9@do_cat_pds:

; 350  : 
; 351  :         if (rc > 0)     /* end of track */

  00118	83 7c 24 44 00	 cmp	 DWORD PTR rc$[rsp], 0
  0011d	7e 14		 jle	 SHORT $LN10@do_cat_pds

; 352  :         {
; 353  :             trk++;

  0011f	8b 44 24 48	 mov	 eax, DWORD PTR trk$[rsp]
  00123	ff c0		 inc	 eax
  00125	89 44 24 48	 mov	 DWORD PTR trk$[rsp], eax

; 354  :             rec = 1;

  00129	c6 44 24 40 01	 mov	 BYTE PTR rec$[rsp], 1

; 355  :             continue;

  0012e	e9 09 ff ff ff	 jmp	 $LN2@do_cat_pds
$LN10@do_cat_pds:

; 356  :         }
; 357  : 
; 358  :         if (len == 0)   /* physical end of file */

  00133	0f b7 44 24 4c	 movzx	 eax, WORD PTR len$2[rsp]
  00138	85 c0		 test	 eax, eax
  0013a	75 07		 jne	 SHORT $LN11@do_cat_pds

; 359  :             return 0;

  0013c	33 c0		 xor	 eax, eax
  0013e	e9 87 00 00 00	 jmp	 $LN1@do_cat_pds
$LN11@do_cat_pds:

; 360  : 
; 361  :         memcpy(dirblk, blkptr, sizeof(dirblk));

  00143	48 8d 44 24 60	 lea	 rax, QWORD PTR dirblk$5[rsp]
  00148	48 8b f8	 mov	 rdi, rax
  0014b	48 8b 74 24 58	 mov	 rsi, QWORD PTR blkptr$4[rsp]
  00150	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00155	f3 a4		 rep movsb

; 362  : 
; 363  :         rc = process_dirblk(cif, noext, extent, dirblk, dsname, pdsmember, optflags);

  00157	8b 84 24 b8 01
	00 00		 mov	 eax, DWORD PTR optflags$[rsp]
  0015e	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00162	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR pdsmember$[rsp]
  0016a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0016f	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR dsname$[rsp]
  00177	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0017c	4c 8d 4c 24 60	 lea	 r9, QWORD PTR dirblk$5[rsp]
  00181	4c 8b 84 24 98
	01 00 00	 mov	 r8, QWORD PTR extent$[rsp]
  00189	8b 94 24 a0 01
	00 00		 mov	 edx, DWORD PTR noext$[rsp]
  00190	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00198	e8 00 00 00 00	 call	 process_dirblk
  0019d	89 44 24 44	 mov	 DWORD PTR rc$[rsp], eax

; 364  :         if (rc < 0)

  001a1	83 7c 24 44 00	 cmp	 DWORD PTR rc$[rsp], 0
  001a6	7d 07		 jge	 SHORT $LN12@do_cat_pds

; 365  :             return -1;

  001a8	b8 ff ff ff ff	 mov	 eax, -1
  001ad	eb 1b		 jmp	 SHORT $LN1@do_cat_pds
$LN12@do_cat_pds:

; 366  : 
; 367  :         if (rc > 0)     /* logical end of file */

  001af	83 7c 24 44 00	 cmp	 DWORD PTR rc$[rsp], 0
  001b4	7e 04		 jle	 SHORT $LN13@do_cat_pds

; 368  :             return 0;

  001b6	33 c0		 xor	 eax, eax
  001b8	eb 10		 jmp	 SHORT $LN1@do_cat_pds
$LN13@do_cat_pds:

; 369  : 
; 370  :         rec++;

  001ba	0f b6 44 24 40	 movzx	 eax, BYTE PTR rec$[rsp]
  001bf	fe c0		 inc	 al
  001c1	88 44 24 40	 mov	 BYTE PTR rec$[rsp], al

; 371  :     }

  001c5	e9 72 fe ff ff	 jmp	 $LN15@do_cat_pds
$LN1@do_cat_pds:
$LN14@do_cat_pds:

; 372  :     UNREACHABLE_CODE( return -1 );
; 373  : }

  001ca	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001d2	48 33 cc	 xor	 rcx, rsp
  001d5	e8 00 00 00 00	 call	 __security_check_cookie
  001da	48 81 c4 78 01
	00 00		 add	 rsp, 376		; 00000178H
  001e1	5f		 pop	 rdi
  001e2	5e		 pop	 rsi
  001e3	c3		 ret	 0
do_cat_pdsmember ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdcat.c
_TEXT	SEGMENT
tv79 = 64
srclen$1 = 68
card$2 = 80
__$ArrayPad$ = 176
buf$ = 208
len$ = 216
optflags$ = 224
do_cat_cards PROC

; 116  : {

$LN9:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 117  :     if (len % 80 != 0)

  00027	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  0002e	99		 cdq
  0002f	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00034	f7 f9		 idiv	 ecx
  00036	8b c2		 mov	 eax, edx
  00038	85 c0		 test	 eax, eax
  0003a	74 5c		 je	 SHORT $LN4@do_cat_car

; 118  :     {
; 119  :         // "Can't make 80 column card images from block length %d"
; 120  :         FWRMSG( stderr, HHC02404, "E", len );

  0003c	b9 02 00 00 00	 mov	 ecx, 2
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00047	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  0004e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159681
  00059	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159682
  00065	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0006a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00075	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159683
  0007c	ba 78 00 00 00	 mov	 edx, 120		; 00000078H
  00081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159684
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 121  :         return -1;

  0008e	b8 ff ff ff ff	 mov	 eax, -1
  00093	e9 ae 00 00 00	 jmp	 $LN1@do_cat_car
$LN4@do_cat_car:
$LN2@do_cat_car:

; 122  :     }
; 123  : 
; 124  :     while (len)

  00098	83 bc 24 d8 00
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  000a0	0f 84 9e 00 00
	00		 je	 $LN3@do_cat_car

; 125  :     {
; 126  :      char card[81];
; 127  :      int srclen = (optflags & OPT_SEQNO) ? 80 : 72;

  000a6	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR optflags$[rsp]
  000ad	83 e0 10	 and	 eax, 16
  000b0	85 c0		 test	 eax, eax
  000b2	74 0a		 je	 SHORT $LN7@do_cat_car
  000b4	c7 44 24 40 50
	00 00 00	 mov	 DWORD PTR tv79[rsp], 80	; 00000050H
  000bc	eb 08		 jmp	 SHORT $LN8@do_cat_car
$LN7@do_cat_car:
  000be	c7 44 24 40 48
	00 00 00	 mov	 DWORD PTR tv79[rsp], 72	; 00000048H
$LN8@do_cat_car:
  000c6	8b 44 24 40	 mov	 eax, DWORD PTR tv79[rsp]
  000ca	89 44 24 44	 mov	 DWORD PTR srclen$1[rsp], eax

; 128  :         make_asciiz(card, sizeof(card), buf, srclen);

  000ce	44 8b 4c 24 44	 mov	 r9d, DWORD PTR srclen$1[rsp]
  000d3	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  000db	ba 51 00 00 00	 mov	 edx, 81			; 00000051H
  000e0	48 8d 4c 24 50	 lea	 rcx, QWORD PTR card$2[rsp]
  000e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_make_asciiz

; 129  : 
; 130  :         if (optflags & OPT_PDS_WILDCARD)

  000eb	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR optflags$[rsp]
  000f2	83 e0 04	 and	 eax, 4
  000f5	85 c0		 test	 eax, eax
  000f7	74 16		 je	 SHORT $LN5@do_cat_car

; 131  :         {
; 132  :             putchar('|');

  000f9	b9 7c 00 00 00	 mov	 ecx, 124		; 0000007cH
  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_putchar

; 133  :             putchar(' ');

  00104	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00109	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_putchar
$LN5@do_cat_car:

; 134  :         }
; 135  : 
; 136  :         puts(card);

  0010f	48 8d 4c 24 50	 lea	 rcx, QWORD PTR card$2[rsp]
  00114	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_puts

; 137  :         len -= 80;

  0011a	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00121	83 e8 50	 sub	 eax, 80			; 00000050H
  00124	89 84 24 d8 00
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 138  :         buf += 80;

  0012b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00133	48 83 c0 50	 add	 rax, 80			; 00000050H
  00137	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 139  :     }

  0013f	e9 54 ff ff ff	 jmp	 $LN2@do_cat_car
$LN3@do_cat_car:

; 140  :     return 0;

  00144	33 c0		 xor	 eax, eax
$LN1@do_cat_car:

; 141  : }

  00146	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0014e	48 33 cc	 xor	 rcx, rsp
  00151	e8 00 00 00 00	 call	 __security_check_cookie
  00156	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0015d	c3		 ret	 0
do_cat_cards ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdcat.c
_TEXT	SEGMENT
rlen$ = 64
rc$ = 68
vol1data$ = 72
cif$ = 96
get_volser PROC

; 483  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 484  :     unsigned char *vol1data;
; 485  :     int rc;
; 486  :     U16 rlen;
; 487  : 
; 488  :     rc = read_block( cif, 0, 0, 3, 0, 0, &vol1data, &rlen );

  00009	48 8d 44 24 40	 lea	 rax, QWORD PTR rlen$[rsp]
  0000e	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00013	48 8d 44 24 48	 lea	 rax, QWORD PTR vol1data$[rsp]
  00018	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0001d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00026	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002f	41 b1 03	 mov	 r9b, 3
  00032	45 33 c0	 xor	 r8d, r8d
  00035	33 d2		 xor	 edx, edx
  00037	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cif$[rsp]
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_block
  00042	89 44 24 44	 mov	 DWORD PTR rc$[rsp], eax

; 489  : 
; 490  :     if (rc < 0)

  00046	83 7c 24 44 00	 cmp	 DWORD PTR rc$[rsp], 0
  0004b	7d 0a		 jge	 SHORT $LN2@get_volser

; 491  :         return -1;

  0004d	b8 ff ff ff ff	 mov	 eax, -1
  00052	e9 87 00 00 00	 jmp	 $LN1@get_volser
$LN2@get_volser:

; 492  : 
; 493  :     if (rc > 0)

  00057	83 7c 24 44 00	 cmp	 DWORD PTR rc$[rsp], 0
  0005c	7e 5a		 jle	 SHORT $LN3@get_volser

; 494  :     {
; 495  :         // "%s record not found"
; 496  :         FWRMSG( stderr, HHC02471, "E", "VOL1" );

  0005e	b9 02 00 00 00	 mov	 ecx, 2
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159902
  00070	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159903
  0007c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159904
  00088	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0008d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00092	41 b9 03 00 00
	00		 mov	 r9d, 3
  00098	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159905
  0009f	ba f0 01 00 00	 mov	 edx, 496		; 000001f0H
  000a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159906
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 497  :         return -1;

  000b1	b8 ff ff ff ff	 mov	 eax, -1
  000b6	eb 26		 jmp	 SHORT $LN1@get_volser
$LN3@get_volser:

; 498  :     }
; 499  : 
; 500  :     make_asciiz( volser, sizeof(volser), vol1data+4, 6 );

  000b8	48 8b 44 24 48	 mov	 rax, QWORD PTR vol1data$[rsp]
  000bd	48 83 c0 04	 add	 rax, 4
  000c1	41 b9 06 00 00
	00		 mov	 r9d, 6
  000c7	4c 8b c0	 mov	 r8, rax
  000ca	ba 07 00 00 00	 mov	 edx, 7
  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:volser
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_make_asciiz

; 501  :     return 0;

  000dc	33 c0		 xor	 eax, eax
$LN1@get_volser:

; 502  : }

  000de	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000e2	c3		 ret	 0
get_volser ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdcat.c
_TEXT	SEGMENT
optflags$ = 80
rc$ = 84
i$1 = 88
p$ = 96
buf$2 = 104
trks$3 = 108
pdsmember$ = 112
noext$ = 120
ecyl$4 = 124
etrk$5 = 128
bcyl$6 = 132
btrk$7 = 136
tv237 = 140
$T8 = 144
$T9 = 152
$T10 = 160
extent$ = 176
dsname$ = 336
buff$ = 384
__$ArrayPad$ = 496
cif$ = 528
file$ = 536
do_cat	PROC

; 376  : {

$LN39:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 08 02
	00 00		 sub	 rsp, 520		; 00000208H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 f0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 377  :  int rc = 0;

  00023	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 378  :  DSXTENT extent[16];
; 379  :  int noext;
; 380  :  char buff[100]; /* must fit max length DSNAME/MEMBER..OPTS */
; 381  :  char dsname[45];
; 382  :  unsigned long optflags = 0;

  0002b	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR optflags$[rsp], 0

; 383  :  char *p;
; 384  :  char *pdsmember = 0;

  00033	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR pdsmember$[rsp], 0

; 385  : 
; 386  :     if ((rc = get_volser( cif )) != 0)

  0003c	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00044	e8 00 00 00 00	 call	 get_volser
  00049	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax
  0004d	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  00052	74 09		 je	 SHORT $LN11@do_cat

; 387  :         return rc;

  00054	8b 44 24 54	 mov	 eax, DWORD PTR rc$[rsp]
  00058	e9 e8 05 00 00	 jmp	 $LN1@do_cat
$LN11@do_cat:

; 388  : 
; 389  :     strncpy(buff, file, sizeof(buff));

  0005d	41 b8 64 00 00
	00		 mov	 r8d, 100		; 00000064H
  00063	48 8b 94 24 18
	02 00 00	 mov	 rdx, QWORD PTR file$[rsp]
  0006b	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR buff$[rsp]
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 390  :     buff[sizeof(buff)-1] = 0;

  00079	b8 01 00 00 00	 mov	 eax, 1
  0007e	48 6b c0 63	 imul	 rax, rax, 99		; 00000063H
  00082	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR $T8[rsp], rax
  0008a	48 83 bc 24 90
	00 00 00 64	 cmp	 QWORD PTR $T8[rsp], 100	; 00000064H
  00093	73 02		 jae	 SHORT $LN33@do_cat
  00095	eb 05		 jmp	 SHORT $LN34@do_cat
$LN33@do_cat:
  00097	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN34@do_cat:
  0009c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR $T8[rsp]
  000a4	c6 84 04 80 01
	00 00 00	 mov	 BYTE PTR buff$[rsp+rax], 0

; 391  : 
; 392  :     p = strchr(buff, ':');

  000ac	ba 3a 00 00 00	 mov	 edx, 58			; 0000003aH
  000b1	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR buff$[rsp]
  000b9	e8 00 00 00 00	 call	 strchr
  000be	48 89 44 24 60	 mov	 QWORD PTR p$[rsp], rax

; 393  :     if (p)

  000c3	48 83 7c 24 60
	00		 cmp	 QWORD PTR p$[rsp], 0
  000c9	0f 84 46 01 00
	00		 je	 $LN12@do_cat

; 394  :     {
; 395  :         *p++ = 0;

  000cf	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  000d4	c6 00 00	 mov	 BYTE PTR [rax], 0
  000d7	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  000dc	48 ff c0	 inc	 rax
  000df	48 89 44 24 60	 mov	 QWORD PTR p$[rsp], rax

; 396  :         for (; *p; p++)

  000e4	eb 0d		 jmp	 SHORT $LN4@do_cat
$LN2@do_cat:
  000e6	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  000eb	48 ff c0	 inc	 rax
  000ee	48 89 44 24 60	 mov	 QWORD PTR p$[rsp], rax
$LN4@do_cat:
  000f3	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  000f8	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000fb	85 c0		 test	 eax, eax
  000fd	0f 84 12 01 00
	00		 je	 $LN3@do_cat

; 397  :         {
; 398  :             if (*p == 'a')

  00103	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  00108	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0010b	83 f8 61	 cmp	 eax, 97			; 00000061H
  0010e	75 10		 jne	 SHORT $LN13@do_cat

; 399  :                 optflags |= OPT_ASCIIFY;

  00110	8b 44 24 50	 mov	 eax, DWORD PTR optflags$[rsp]
  00114	83 c8 01	 or	 eax, 1
  00117	89 44 24 50	 mov	 DWORD PTR optflags$[rsp], eax
  0011b	e9 f0 00 00 00	 jmp	 $LN14@do_cat
$LN13@do_cat:

; 400  :             else if (*p == 'c')

  00120	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  00125	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00128	83 f8 63	 cmp	 eax, 99			; 00000063H
  0012b	75 10		 jne	 SHORT $LN15@do_cat

; 401  :                 optflags |= OPT_CARDS;

  0012d	8b 44 24 50	 mov	 eax, DWORD PTR optflags$[rsp]
  00131	83 c8 02	 or	 eax, 2
  00134	89 44 24 50	 mov	 DWORD PTR optflags$[rsp], eax
  00138	e9 d3 00 00 00	 jmp	 $LN16@do_cat
$LN15@do_cat:

; 402  :             else if (*p == 's')

  0013d	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  00142	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00145	83 f8 73	 cmp	 eax, 115		; 00000073H
  00148	75 10		 jne	 SHORT $LN17@do_cat

; 403  :                 optflags |= OPT_SEQNO;

  0014a	8b 44 24 50	 mov	 eax, DWORD PTR optflags$[rsp]
  0014e	83 c8 10	 or	 eax, 16
  00151	89 44 24 50	 mov	 DWORD PTR optflags$[rsp], eax
  00155	e9 b6 00 00 00	 jmp	 $LN18@do_cat
$LN17@do_cat:

; 404  :             else if (*p == '?')

  0015a	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  0015f	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00162	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  00165	75 10		 jne	 SHORT $LN19@do_cat

; 405  :                 optflags |= OPT_MEMINFO_ONLY;

  00167	8b 44 24 50	 mov	 eax, DWORD PTR optflags$[rsp]
  0016b	83 c8 20	 or	 eax, 32			; 00000020H
  0016e	89 44 24 50	 mov	 DWORD PTR optflags$[rsp], eax
  00172	e9 99 00 00 00	 jmp	 $LN20@do_cat
$LN19@do_cat:

; 406  :             else
; 407  :             {
; 408  :                 char buf[2];
; 409  :                 buf[0] = *p;

  00177	b8 01 00 00 00	 mov	 eax, 1
  0017c	48 6b c0 00	 imul	 rax, rax, 0
  00180	48 8b 4c 24 60	 mov	 rcx, QWORD PTR p$[rsp]
  00185	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00188	88 4c 04 68	 mov	 BYTE PTR buf$2[rsp+rax], cl

; 410  :                 buf[1] = 0;

  0018c	48 c7 84 24 98
	00 00 00 01 00
	00 00		 mov	 QWORD PTR $T9[rsp], 1
  00198	48 83 bc 24 98
	00 00 00 02	 cmp	 QWORD PTR $T9[rsp], 2
  001a1	73 02		 jae	 SHORT $LN35@do_cat
  001a3	eb 05		 jmp	 SHORT $LN36@do_cat
$LN35@do_cat:
  001a5	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN36@do_cat:
  001aa	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR $T9[rsp]
  001b2	c6 44 04 68 00	 mov	 BYTE PTR buf$2[rsp+rax], 0

; 411  :                 // "Unknown 'member:flags' formatting option %s"
; 412  :                 FWRMSG( stderr, HHC02402, "E", buf );

  001b7	b9 02 00 00 00	 mov	 ecx, 2
  001bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001c2	48 8d 4c 24 68	 lea	 rcx, QWORD PTR buf$2[rsp]
  001c7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159868
  001d3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159869
  001df	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001e4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e9	41 b9 03 00 00
	00		 mov	 r9d, 3
  001ef	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159870
  001f6	ba 9c 01 00 00	 mov	 edx, 412		; 0000019cH
  001fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159871
  00202	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 413  :                 rc = -1;

  00208	c7 44 24 54 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN20@do_cat:
$LN18@do_cat:
$LN16@do_cat:
$LN14@do_cat:

; 414  :             }
; 415  :         }

  00210	e9 d1 fe ff ff	 jmp	 $LN2@do_cat
$LN3@do_cat:
$LN12@do_cat:

; 416  :     }
; 417  : 
; 418  :     if (rc != 0)

  00215	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  0021a	74 09		 je	 SHORT $LN21@do_cat

; 419  :         return rc;

  0021c	8b 44 24 54	 mov	 eax, DWORD PTR rc$[rsp]
  00220	e9 20 04 00 00	 jmp	 $LN1@do_cat
$LN21@do_cat:

; 420  : 
; 421  :     p = strchr(buff, '/');

  00225	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  0022a	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR buff$[rsp]
  00232	e8 00 00 00 00	 call	 strchr
  00237	48 89 44 24 60	 mov	 QWORD PTR p$[rsp], rax

; 422  :     if (p)

  0023c	48 83 7c 24 60
	00		 cmp	 QWORD PTR p$[rsp], 0
  00242	74 20		 je	 SHORT $LN22@do_cat

; 423  :     {
; 424  :         *p = 0;

  00244	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  00249	c6 00 00	 mov	 BYTE PTR [rax], 0

; 425  :         pdsmember = p + 1;

  0024c	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  00251	48 ff c0	 inc	 rax
  00254	48 89 44 24 70	 mov	 QWORD PTR pdsmember$[rsp], rax

; 426  :         string_to_upper(pdsmember);

  00259	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pdsmember$[rsp]
  0025e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_string_to_upper
$LN22@do_cat:

; 427  :     }
; 428  : 
; 429  :     strncpy(dsname, buff, sizeof(dsname));

  00264	41 b8 2d 00 00
	00		 mov	 r8d, 45			; 0000002dH
  0026a	48 8d 94 24 80
	01 00 00	 lea	 rdx, QWORD PTR buff$[rsp]
  00272	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR dsname$[rsp]
  0027a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 430  :     dsname[sizeof(dsname)-1] = 0;

  00280	b8 01 00 00 00	 mov	 eax, 1
  00285	48 6b c0 2c	 imul	 rax, rax, 44		; 0000002cH
  00289	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR $T10[rsp], rax
  00291	48 83 bc 24 a0
	00 00 00 2d	 cmp	 QWORD PTR $T10[rsp], 45	; 0000002dH
  0029a	73 02		 jae	 SHORT $LN37@do_cat
  0029c	eb 05		 jmp	 SHORT $LN38@do_cat
$LN37@do_cat:
  0029e	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN38@do_cat:
  002a3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR $T10[rsp]
  002ab	c6 84 04 50 01
	00 00 00	 mov	 BYTE PTR dsname$[rsp+rax], 0

; 431  :     string_to_upper(dsname);

  002b3	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR dsname$[rsp]
  002bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_string_to_upper

; 432  : 
; 433  :     rc = build_extent_array(cif, dsname, extent, &noext);

  002c1	4c 8d 4c 24 78	 lea	 r9, QWORD PTR noext$[rsp]
  002c6	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR extent$[rsp]
  002ce	48 8d 94 24 50
	01 00 00	 lea	 rdx, QWORD PTR dsname$[rsp]
  002d6	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  002de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_build_extent_array
  002e4	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax

; 434  :     if (rc < 0)

  002e8	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  002ed	7d 0a		 jge	 SHORT $LN23@do_cat

; 435  :         return -1;

  002ef	b8 ff ff ff ff	 mov	 eax, -1
  002f4	e9 4c 03 00 00	 jmp	 $LN1@do_cat
$LN23@do_cat:

; 436  : 
; 437  :     /* Calculate ending relative track */
; 438  :     if (extgui)

  002f9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  00300	83 38 00	 cmp	 DWORD PTR [rax], 0
  00303	0f 84 db 01 00
	00		 je	 $LN24@do_cat

; 439  :     {
; 440  :         int bcyl;  /* Extent begin cylinder     */
; 441  :         int btrk;  /* Extent begin head         */
; 442  :         int ecyl;  /* Extent end cylinder       */
; 443  :         int etrk;  /* Extent end head           */
; 444  :         int trks;  /* total tracks in dataset   */
; 445  :         int i;     /* loop control              */
; 446  : 
; 447  :         for (i = 0, trks = 0; i < noext; i++)

  00309	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00311	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR trks$3[rsp], 0
  00319	eb 0a		 jmp	 SHORT $LN7@do_cat
$LN5@do_cat:
  0031b	8b 44 24 58	 mov	 eax, DWORD PTR i$1[rsp]
  0031f	ff c0		 inc	 eax
  00321	89 44 24 58	 mov	 DWORD PTR i$1[rsp], eax
$LN7@do_cat:
  00325	8b 44 24 78	 mov	 eax, DWORD PTR noext$[rsp]
  00329	39 44 24 58	 cmp	 DWORD PTR i$1[rsp], eax
  0032d	0f 8d 6d 01 00
	00		 jge	 $LN6@do_cat

; 448  :         {
; 449  :             bcyl = (extent[i].xtbcyl[0] << 8) | extent[i].xtbcyl[1];

  00333	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$1[rsp]
  00338	48 6b c0 0a	 imul	 rax, rax, 10
  0033c	48 8d 84 04 b0
	00 00 00	 lea	 rax, QWORD PTR extent$[rsp+rax]
  00344	b9 01 00 00 00	 mov	 ecx, 1
  00349	48 6b c9 00	 imul	 rcx, rcx, 0
  0034d	0f b6 44 08 02	 movzx	 eax, BYTE PTR [rax+rcx+2]
  00352	c1 e0 08	 shl	 eax, 8
  00355	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR i$1[rsp]
  0035a	48 6b c9 0a	 imul	 rcx, rcx, 10
  0035e	48 8d 8c 0c b0
	00 00 00	 lea	 rcx, QWORD PTR extent$[rsp+rcx]
  00366	ba 01 00 00 00	 mov	 edx, 1
  0036b	48 6b d2 01	 imul	 rdx, rdx, 1
  0036f	0f b6 4c 11 02	 movzx	 ecx, BYTE PTR [rcx+rdx+2]
  00374	0b c1		 or	 eax, ecx
  00376	89 84 24 84 00
	00 00		 mov	 DWORD PTR bcyl$6[rsp], eax

; 450  :             btrk = (extent[i].xtbtrk[0] << 8) | extent[i].xtbtrk[1];

  0037d	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$1[rsp]
  00382	48 6b c0 0a	 imul	 rax, rax, 10
  00386	48 8d 84 04 b0
	00 00 00	 lea	 rax, QWORD PTR extent$[rsp+rax]
  0038e	b9 01 00 00 00	 mov	 ecx, 1
  00393	48 6b c9 00	 imul	 rcx, rcx, 0
  00397	0f b6 44 08 04	 movzx	 eax, BYTE PTR [rax+rcx+4]
  0039c	c1 e0 08	 shl	 eax, 8
  0039f	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR i$1[rsp]
  003a4	48 6b c9 0a	 imul	 rcx, rcx, 10
  003a8	48 8d 8c 0c b0
	00 00 00	 lea	 rcx, QWORD PTR extent$[rsp+rcx]
  003b0	ba 01 00 00 00	 mov	 edx, 1
  003b5	48 6b d2 01	 imul	 rdx, rdx, 1
  003b9	0f b6 4c 11 04	 movzx	 ecx, BYTE PTR [rcx+rdx+4]
  003be	0b c1		 or	 eax, ecx
  003c0	89 84 24 88 00
	00 00		 mov	 DWORD PTR btrk$7[rsp], eax

; 451  :             ecyl = (extent[i].xtecyl[0] << 8) | extent[i].xtecyl[1];

  003c7	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$1[rsp]
  003cc	48 6b c0 0a	 imul	 rax, rax, 10
  003d0	48 8d 84 04 b0
	00 00 00	 lea	 rax, QWORD PTR extent$[rsp+rax]
  003d8	b9 01 00 00 00	 mov	 ecx, 1
  003dd	48 6b c9 00	 imul	 rcx, rcx, 0
  003e1	0f b6 44 08 06	 movzx	 eax, BYTE PTR [rax+rcx+6]
  003e6	c1 e0 08	 shl	 eax, 8
  003e9	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR i$1[rsp]
  003ee	48 6b c9 0a	 imul	 rcx, rcx, 10
  003f2	48 8d 8c 0c b0
	00 00 00	 lea	 rcx, QWORD PTR extent$[rsp+rcx]
  003fa	ba 01 00 00 00	 mov	 edx, 1
  003ff	48 6b d2 01	 imul	 rdx, rdx, 1
  00403	0f b6 4c 11 06	 movzx	 ecx, BYTE PTR [rcx+rdx+6]
  00408	0b c1		 or	 eax, ecx
  0040a	89 44 24 7c	 mov	 DWORD PTR ecyl$4[rsp], eax

; 452  :             etrk = (extent[i].xtetrk[0] << 8) | extent[i].xtetrk[1];

  0040e	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$1[rsp]
  00413	48 6b c0 0a	 imul	 rax, rax, 10
  00417	48 8d 84 04 b0
	00 00 00	 lea	 rax, QWORD PTR extent$[rsp+rax]
  0041f	b9 01 00 00 00	 mov	 ecx, 1
  00424	48 6b c9 00	 imul	 rcx, rcx, 0
  00428	0f b6 44 08 08	 movzx	 eax, BYTE PTR [rax+rcx+8]
  0042d	c1 e0 08	 shl	 eax, 8
  00430	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00435	48 6b c9 0a	 imul	 rcx, rcx, 10
  00439	48 8d 8c 0c b0
	00 00 00	 lea	 rcx, QWORD PTR extent$[rsp+rcx]
  00441	ba 01 00 00 00	 mov	 edx, 1
  00446	48 6b d2 01	 imul	 rdx, rdx, 1
  0044a	0f b6 4c 11 08	 movzx	 ecx, BYTE PTR [rcx+rdx+8]
  0044f	0b c1		 or	 eax, ecx
  00451	89 84 24 80 00
	00 00		 mov	 DWORD PTR etrk$5[rsp], eax

; 453  :             trks += (((ecyl*cif->heads)+etrk)-((bcyl*cif->heads)+btrk))+1;

  00458	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00460	8b 4c 24 7c	 mov	 ecx, DWORD PTR ecyl$4[rsp]
  00464	0f af 48 24	 imul	 ecx, DWORD PTR [rax+36]
  00468	8b c1		 mov	 eax, ecx
  0046a	03 84 24 80 00
	00 00		 add	 eax, DWORD PTR etrk$5[rsp]
  00471	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00479	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR bcyl$6[rsp]
  00480	0f af 51 24	 imul	 edx, DWORD PTR [rcx+36]
  00484	8b ca		 mov	 ecx, edx
  00486	03 8c 24 88 00
	00 00		 add	 ecx, DWORD PTR btrk$7[rsp]
  0048d	2b c1		 sub	 eax, ecx
  0048f	8b 4c 24 6c	 mov	 ecx, DWORD PTR trks$3[rsp]
  00493	8d 44 01 01	 lea	 eax, DWORD PTR [rcx+rax+1]
  00497	89 44 24 6c	 mov	 DWORD PTR trks$3[rsp], eax

; 454  :         }

  0049b	e9 7b fe ff ff	 jmp	 $LN5@do_cat
$LN6@do_cat:
$LN10@do_cat:

; 455  :         EXTGUIMSG( "ETRK=%d\n", trks-1 );

  004a0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  004a7	83 38 00	 cmp	 DWORD PTR [rax], 0
  004aa	74 32		 je	 SHORT $LN25@do_cat
  004ac	8b 44 24 6c	 mov	 eax, DWORD PTR trks$3[rsp]
  004b0	ff c8		 dec	 eax
  004b2	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv237[rsp], eax
  004b9	b9 02 00 00 00	 mov	 ecx, 2
  004be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004c4	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv237[rsp]
  004cb	44 8b c1	 mov	 r8d, ecx
  004ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159877
  004d5	48 8b c8	 mov	 rcx, rax
  004d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN25@do_cat:
  004de	33 c0		 xor	 eax, eax
  004e0	85 c0		 test	 eax, eax
  004e2	75 bc		 jne	 SHORT $LN10@do_cat
$LN24@do_cat:

; 456  :     }
; 457  : 
; 458  :     if (pdsmember)

  004e4	48 83 7c 24 70
	00		 cmp	 QWORD PTR pdsmember$[rsp], 0
  004ea	0f 84 02 01 00
	00		 je	 $LN26@do_cat

; 459  :     {
; 460  :         if      (!strcmp(pdsmember, "*")) optflags |= OPT_PDS_WILDCARD;

  004f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159882
  004f7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pdsmember$[rsp]
  004fc	e8 00 00 00 00	 call	 strcmp
  00501	85 c0		 test	 eax, eax
  00503	75 0d		 jne	 SHORT $LN28@do_cat
  00505	8b 44 24 50	 mov	 eax, DWORD PTR optflags$[rsp]
  00509	83 c8 04	 or	 eax, 4
  0050c	89 44 24 50	 mov	 DWORD PTR optflags$[rsp], eax
  00510	eb 20		 jmp	 SHORT $LN29@do_cat
$LN28@do_cat:

; 461  :         else if (!strcmp(pdsmember, "?")) optflags |= OPT_PDS_LISTONLY;

  00512	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159884
  00519	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pdsmember$[rsp]
  0051e	e8 00 00 00 00	 call	 strcmp
  00523	85 c0		 test	 eax, eax
  00525	75 0b		 jne	 SHORT $LN30@do_cat
  00527	8b 44 24 50	 mov	 eax, DWORD PTR optflags$[rsp]
  0052b	83 c8 08	 or	 eax, 8
  0052e	89 44 24 50	 mov	 DWORD PTR optflags$[rsp], eax
$LN30@do_cat:
$LN29@do_cat:

; 462  : 
; 463  :         rc = do_cat_pdsmember(cif, extent, noext, dsname, pdsmember, optflags);

  00532	8b 44 24 50	 mov	 eax, DWORD PTR optflags$[rsp]
  00536	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0053a	48 8b 44 24 70	 mov	 rax, QWORD PTR pdsmember$[rsp]
  0053f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00544	4c 8d 8c 24 50
	01 00 00	 lea	 r9, QWORD PTR dsname$[rsp]
  0054c	44 8b 44 24 78	 mov	 r8d, DWORD PTR noext$[rsp]
  00551	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR extent$[rsp]
  00559	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00561	e8 00 00 00 00	 call	 do_cat_pdsmember
  00566	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax

; 464  : 
; 465  :         if (!(optflags & (OPT_PDS_LISTONLY | OPT_PDS_WILDCARD)) && !found)

  0056a	8b 44 24 50	 mov	 eax, DWORD PTR optflags$[rsp]
  0056e	83 e0 0c	 and	 eax, 12
  00571	85 c0		 test	 eax, eax
  00573	75 7b		 jne	 SHORT $LN31@do_cat
  00575	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR found, 0
  0057c	75 72		 jne	 SHORT $LN31@do_cat

; 466  :         {
; 467  :             // "Member '%s' not found in dataset '%s' on volume '%s'"
; 468  :             FWRMSG( stderr, HHC02406, "E", pdsmember, dsname, volser );

  0057e	b9 02 00 00 00	 mov	 ecx, 2
  00583	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00589	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:volser
  00590	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00595	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR dsname$[rsp]
  0059d	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  005a2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pdsmember$[rsp]
  005a7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  005ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159886
  005b3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159887
  005bf	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005c4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005c9	41 b9 03 00 00
	00		 mov	 r9d, 3
  005cf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159888
  005d6	ba d4 01 00 00	 mov	 edx, 468		; 000001d4H
  005db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159889
  005e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 469  :             rc = 1;

  005e8	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR rc$[rsp], 1
$LN31@do_cat:

; 470  :         }
; 471  :     }

  005f0	eb 4f		 jmp	 SHORT $LN27@do_cat
$LN26@do_cat:

; 472  :     else
; 473  :     {
; 474  :         // "Non-PDS-members not yet supported"
; 475  :         FWRMSG( stderr, HHC02401, "E" );

  005f2	b9 02 00 00 00	 mov	 ecx, 2
  005f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159890
  00604	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00609	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159891
  00610	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00615	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0061a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00620	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159892
  00627	ba db 01 00 00	 mov	 edx, 475		; 000001dbH
  0062c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159893
  00633	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 476  :         rc = 1;

  00639	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR rc$[rsp], 1
$LN27@do_cat:

; 477  :     }
; 478  : 
; 479  :     return rc;

  00641	8b 44 24 54	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@do_cat:
$LN32@do_cat:

; 480  : }

  00645	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0064d	48 33 cc	 xor	 rcx, rsp
  00650	e8 00 00 00 00	 call	 __security_check_cookie
  00655	48 81 c4 08 02
	00 00		 add	 rsp, 520		; 00000208H
  0065c	c3		 ret	 0
do_cat	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 956  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 48	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00022	b9 01 00 00 00	 mov	 ecx, 1
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0002d	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00032	45 33 c0	 xor	 r8d, r8d
  00035	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Format$[rsp]
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 _vfprintf_l
  00042	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 961  :         __crt_va_end(_ArgList);

  00046	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 962  :         return _Result;

  0004f	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 963  :     }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 646  :     }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
