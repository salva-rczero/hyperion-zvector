; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	fwritemsg
PUBLIC	logmsg
PUBLIC	panel_command_capture
EXTRN	__imp__errno:PROC
EXTRN	strchr:PROC
EXTRN	strlen:PROC
EXTRN	__imp__strnicmp:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_realloc:PROC
EXTRN	__imp_send:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fflush:PROC
EXTRN	fthread_self:PROC
EXTRN	hthread_initialize_lock:PROC
EXTRN	hthread_obtain_lock:PROC
EXTRN	hthread_release_lock:PROC
EXTRN	hthread_equal_threads:PROC
EXTRN	strlcat:PROC
EXTRN	trimloc:PROC
EXTRN	usleep:PROC
EXTRN	w32_vsnprintf:PROC
EXTRN	w32_snprintf:PROC
EXTRN	w32_fprintf:PROC
EXTRN	log_wakeup:PROC
EXTRN	logger_timestamped_logfile_write:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	logger_syslogfd:QWORD
EXTRN	__imp_sysblk:BYTE
EXTRN	__imp_extgui:DWORD
EXTRN	__imp_panel_command:QWORD
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
captctl_tab DB	0440H DUP (?)
captctl_lock DQ	01H DUP (?)
wrmsg_quiet DB	01H DUP (?)
	ALIGN	4

?didthis@?1??InitCAPTCTL@@9@9 DB 01H DUP (?)		; `InitCAPTCTL'::`2'::didthis
_BSS	ENDS
pdata	SEGMENT
$pdata$fwritemsg DD imagerel $LN3
	DD	imagerel $LN3+102
	DD	imagerel $unwind$fwritemsg
$pdata$logmsg DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$logmsg
$pdata$panel_command_capture DD imagerel $LN3
	DD	imagerel $LN3+121
	DD	imagerel $unwind$panel_command_capture
$pdata$InitCAPTCTL DD imagerel InitCAPTCTL
	DD	imagerel InitCAPTCTL+77
	DD	imagerel $unwind$InitCAPTCTL
$pdata$FindCAPTCTL DD imagerel FindCAPTCTL
	DD	imagerel FindCAPTCTL+97
	DD	imagerel $unwind$FindCAPTCTL
$pdata$NewCAPTCTL DD imagerel NewCAPTCTL
	DD	imagerel NewCAPTCTL+72
	DD	imagerel $unwind$NewCAPTCTL
$pdata$start_capturing DD imagerel start_capturing
	DD	imagerel start_capturing+84
	DD	imagerel $unwind$start_capturing
$pdata$stop_capturing DD imagerel stop_capturing
	DD	imagerel stop_capturing+78
	DD	imagerel $unwind$stop_capturing
$pdata$capture_message DD imagerel capture_message
	DD	imagerel capture_message+213
	DD	imagerel $unwind$capture_message
$pdata$do_write_pipe DD imagerel do_write_pipe
	DD	imagerel do_write_pipe+242
	DD	imagerel $unwind$do_write_pipe
$pdata$_flog_write_pipe DD imagerel _flog_write_pipe
	DD	imagerel _flog_write_pipe+237
	DD	imagerel $unwind$_flog_write_pipe
$pdata$flog_write DD imagerel flog_write
	DD	imagerel flog_write+167
	DD	imagerel $unwind$flog_write
$pdata$vfwritemsg DD imagerel vfwritemsg
	DD	imagerel vfwritemsg+1491
	DD	imagerel $unwind$vfwritemsg
$pdata$vflogmsg DD imagerel vflogmsg
	DD	imagerel vflogmsg+416
	DD	imagerel $unwind$vflogmsg
pdata	ENDS
_DATA	SEGMENT
$SG159067 DB	'logmsg.c:118', 00H
	ORG $+3
$SG159068 DB	'&captctl_lock', 00H
	ORG $+2
$SG159096 DB	'logmsg.c:159', 00H
	ORG $+3
$SG159097 DB	'logmsg.c:163', 00H
	ORG $+3
$SG159104 DB	'logmsg.c:174', 00H
	ORG $+3
$SG159105 DB	'logmsg.c:178', 00H
	ORG $+3
$SG159156 DB	'%s', 00H
	ORG $+1
$SG159235 DB	'HHC', 00H
$SG159169 DB	'logmsg.c:350', 00H
	ORG $+3
$SG159170 DB	'logmsg.c:354', 00H
	ORG $+3
$SG159230 DB	'%s(%d)', 00H
	ORG $+1
$SG159231 DB	'%-17.17s ', 00H
	ORG $+2
$SG159233 DB	'%s%s', 00H
	ORG $+3
$SG159237 DB	'I', 00H
	ORG $+2
$SG159238 DB	'HHC00007%s Previous message from function ''%s'' at %s(%'
	DB	'd)', 0aH, 00H
	ORG $+6
$SG159239 DB	'vfwritemsg', 00H
	ORG $+5
$SG159240 DB	'logmsg.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:vfwritemsg
	DD	026H
	DD	05b9H
voltbl	ENDS
xdata	SEGMENT
$unwind$fwritemsg DD 011701H
	DD	0a217H
$unwind$logmsg DD 011801H
	DD	06218H
$unwind$panel_command_capture DD 021401H
	DD	070107214H
$unwind$InitCAPTCTL DD 020601H
	DD	070023206H
$unwind$FindCAPTCTL DD 010801H
	DD	06208H
$unwind$NewCAPTCTL DD 010d01H
	DD	0620dH
$unwind$start_capturing DD 010901H
	DD	06209H
$unwind$stop_capturing DD 020a01H
	DD	07006320aH
$unwind$capture_message DD 010e01H
	DD	0620eH
$unwind$do_write_pipe DD 011201H
	DD	08212H
$unwind$_flog_write_pipe DD 010e01H
	DD	0620eH
$unwind$flog_write DD 011201H
	DD	06212H
$unwind$vfwritemsg DD 042e19H
	DD	023011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0108H
$unwind$vflogmsg DD 011701H
	DD	08217H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\logmsg.c
_TEXT	SEGMENT
siz$ = 32
rc$ = 36
bfr$ = 40
original_vl$1 = 48
p$2 = 56
panel$ = 80
f$ = 88
fmt$ = 96
vl$ = 104
vflogmsg PROC

; 482  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 483  :     char    *bfr =   NULL;

  00017	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR bfr$[rsp], 0

; 484  :     int      rc;
; 485  :     int      siz =   1024;

  00020	c7 44 24 20 00
	04 00 00	 mov	 DWORD PTR siz$[rsp], 1024 ; 00000400H

; 486  : 
; 487  : #ifdef NEED_LOGMSG_FFLUSH
; 488  :     fflush(f);

  00028	48 8b 4c 24 58	 mov	 rcx, QWORD PTR f$[rsp]
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush
$LN4@vflogmsg:

; 489  : #endif
; 490  : 
; 491  :     BFR_VSNPRINTF();  // Note: uses 'vl', 'bfr', 'siz', 'fmt' and 'rc'.

  00033	48 8b 44 24 68	 mov	 rax, QWORD PTR vl$[rsp]
  00038	48 89 44 24 30	 mov	 QWORD PTR original_vl$1[rsp], rax
  0003d	48 63 44 24 20	 movsxd	 rax, DWORD PTR siz$[rsp]
  00042	48 8b d0	 mov	 rdx, rax
  00045	b9 01 00 00 00	 mov	 ecx, 1
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00050	48 89 44 24 28	 mov	 QWORD PTR bfr$[rsp], rax
  00055	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN5@vflogmsg:
  0005d	48 83 7c 24 28
	00		 cmp	 QWORD PTR bfr$[rsp], 0
  00063	0f 84 82 00 00
	00		 je	 $LN6@vflogmsg
  00069	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  0006e	7d 7b		 jge	 SHORT $LN6@vflogmsg
  00070	48 63 44 24 20	 movsxd	 rax, DWORD PTR siz$[rsp]
  00075	4c 8b 4c 24 68	 mov	 r9, QWORD PTR vl$[rsp]
  0007a	4c 8b 44 24 60	 mov	 r8, QWORD PTR fmt$[rsp]
  0007f	48 8b d0	 mov	 rdx, rax
  00082	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bfr$[rsp]
  00087	e8 00 00 00 00	 call	 w32_vsnprintf
  0008c	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax
  00090	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  00095	7c 0c		 jl	 SHORT $LN7@vflogmsg
  00097	8b 44 24 20	 mov	 eax, DWORD PTR siz$[rsp]
  0009b	39 44 24 24	 cmp	 DWORD PTR rc$[rsp], eax
  0009f	7d 02		 jge	 SHORT $LN7@vflogmsg
  000a1	eb 48		 jmp	 SHORT $LN6@vflogmsg
$LN7@vflogmsg:
  000a3	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
  000ab	8b 44 24 20	 mov	 eax, DWORD PTR siz$[rsp]
  000af	05 00 01 00 00	 add	 eax, 256		; 00000100H
  000b4	89 44 24 20	 mov	 DWORD PTR siz$[rsp], eax
  000b8	81 7c 24 20 00
	00 01 00	 cmp	 DWORD PTR siz$[rsp], 65536 ; 00010000H
  000c0	7e 02		 jle	 SHORT $LN8@vflogmsg
  000c2	eb 27		 jmp	 SHORT $LN6@vflogmsg
$LN8@vflogmsg:
  000c4	48 63 44 24 20	 movsxd	 rax, DWORD PTR siz$[rsp]
  000c9	48 8b d0	 mov	 rdx, rax
  000cc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bfr$[rsp]
  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  000d7	48 89 44 24 28	 mov	 QWORD PTR bfr$[rsp], rax
  000dc	48 8b 44 24 30	 mov	 rax, QWORD PTR original_vl$1[rsp]
  000e1	48 89 44 24 68	 mov	 QWORD PTR vl$[rsp], rax
  000e6	e9 72 ff ff ff	 jmp	 $LN5@vflogmsg
$LN6@vflogmsg:
  000eb	48 83 7c 24 28
	00		 cmp	 QWORD PTR bfr$[rsp], 0
  000f1	74 3b		 je	 SHORT $LN9@vflogmsg
  000f3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bfr$[rsp]
  000f8	e8 00 00 00 00	 call	 strlen
  000fd	48 85 c0	 test	 rax, rax
  00100	75 2c		 jne	 SHORT $LN9@vflogmsg
  00102	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fmt$[rsp]
  00107	e8 00 00 00 00	 call	 strlen
  0010c	48 85 c0	 test	 rax, rax
  0010f	74 1d		 je	 SHORT $LN9@vflogmsg
  00111	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bfr$[rsp]
  00116	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  0011c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fmt$[rsp]
  00121	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00127	48 89 44 24 28	 mov	 QWORD PTR bfr$[rsp], rax
  0012c	eb 2d		 jmp	 SHORT $LN10@vflogmsg
$LN9@vflogmsg:
  0012e	48 83 7c 24 28
	00		 cmp	 QWORD PTR bfr$[rsp], 0
  00134	74 25		 je	 SHORT $LN11@vflogmsg
  00136	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bfr$[rsp]
  0013b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00141	48 89 44 24 38	 mov	 QWORD PTR p$2[rsp], rax
  00146	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bfr$[rsp]
  0014b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00151	48 8b 44 24 38	 mov	 rax, QWORD PTR p$2[rsp]
  00156	48 89 44 24 28	 mov	 QWORD PTR bfr$[rsp], rax
$LN11@vflogmsg:
$LN10@vflogmsg:
  0015b	33 c0		 xor	 eax, eax
  0015d	85 c0		 test	 eax, eax
  0015f	0f 85 ce fe ff
	ff		 jne	 $LN4@vflogmsg

; 492  :     if (!bfr)         // If BFR_VSNPRINTF runs out of memory,

  00165	48 83 7c 24 28
	00		 cmp	 QWORD PTR bfr$[rsp], 0
  0016b	75 02		 jne	 SHORT $LN12@vflogmsg

; 493  :         return;       // then there's nothing more we can do.

  0016d	eb 2c		 jmp	 SHORT $LN1@vflogmsg
$LN12@vflogmsg:

; 494  : 
; 495  :     flog_write( panel, f, bfr );

  0016f	0f b6 44 24 50	 movzx	 eax, BYTE PTR panel$[rsp]
  00174	4c 8b 44 24 28	 mov	 r8, QWORD PTR bfr$[rsp]
  00179	48 8b 54 24 58	 mov	 rdx, QWORD PTR f$[rsp]
  0017e	8b c8		 mov	 ecx, eax
  00180	e8 00 00 00 00	 call	 flog_write

; 496  : 
; 497  : #ifdef NEED_LOGMSG_FFLUSH
; 498  :     fflush(f);

  00185	48 8b 4c 24 58	 mov	 rcx, QWORD PTR f$[rsp]
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 499  : #endif
; 500  : 
; 501  :     free( bfr );

  00190	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bfr$[rsp]
  00195	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN1@vflogmsg:

; 502  : }

  0019b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0019f	c3		 ret	 0
vflogmsg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\logmsg.c
_TEXT	SEGMENT
bfr$ = 80
siz$ = 88
rc$ = 92
nl$1 = 96
bufsiz$ = 104
leftsize$2 = 112
pfxsiz$3 = 120
newbfr$4 = 128
msgbuf$ = 136
newsiz$5 = 144
msglen$ = 152
original_vl$6 = 160
p$7 = 168
left$8 = 176
right$9 = 184
rightsiz$10 = 192
prefix$ = 200
wrk$11 = 232
__$ArrayPad$ = 264
panel$ = 304
f$ = 312
filename$ = 320
line$ = 328
func$ = 336
fmt$ = 344
vl$ = 352
vfwritemsg PROC

; 381  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 382  :     char     prefix[ 32 ]  =  {0};

  0002e	48 8d 84 24 c8
	00 00 00	 lea	 rax, QWORD PTR prefix$[rsp]
  00036	48 8b f8	 mov	 rdi, rax
  00039	33 c0		 xor	 eax, eax
  0003b	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00040	f3 aa		 rep stosb

; 383  :     char*    bfr           =  NULL;

  00042	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR bfr$[rsp], 0

; 384  :     int      rc            =  1;

  0004b	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR rc$[rsp], 1

; 385  :     int      siz           =  1024;

  00053	c7 44 24 58 00
	04 00 00	 mov	 DWORD PTR siz$[rsp], 1024 ; 00000400H

; 386  :     char*    msgbuf;
; 387  :     size_t   msglen, bufsiz;
; 388  : 
; 389  :   #ifdef NEED_LOGMSG_FFLUSH
; 390  :     fflush( f );

  0005b	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR f$[rsp]
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush
$LN4@vfwritemsg:

; 391  :   #endif
; 392  : 
; 393  :     // Format just the message part, without the filename and line number
; 394  : 
; 395  :     BFR_VSNPRINTF();  // Note: uses 'vl', 'bfr', 'siz', 'fmt' and 'rc'.

  00069	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR vl$[rsp]
  00071	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR original_vl$6[rsp], rax
  00079	48 63 44 24 58	 movsxd	 rax, DWORD PTR siz$[rsp]
  0007e	48 8b d0	 mov	 rdx, rax
  00081	b9 01 00 00 00	 mov	 ecx, 1
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0008c	48 89 44 24 50	 mov	 QWORD PTR bfr$[rsp], rax
  00091	c7 44 24 5c ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN5@vfwritemsg:
  00099	48 83 7c 24 50
	00		 cmp	 QWORD PTR bfr$[rsp], 0
  0009f	0f 84 92 00 00
	00		 je	 $LN6@vfwritemsg
  000a5	83 7c 24 5c 00	 cmp	 DWORD PTR rc$[rsp], 0
  000aa	0f 8d 87 00 00
	00		 jge	 $LN6@vfwritemsg
  000b0	48 63 44 24 58	 movsxd	 rax, DWORD PTR siz$[rsp]
  000b5	4c 8b 8c 24 60
	01 00 00	 mov	 r9, QWORD PTR vl$[rsp]
  000bd	4c 8b 84 24 58
	01 00 00	 mov	 r8, QWORD PTR fmt$[rsp]
  000c5	48 8b d0	 mov	 rdx, rax
  000c8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bfr$[rsp]
  000cd	e8 00 00 00 00	 call	 w32_vsnprintf
  000d2	89 44 24 5c	 mov	 DWORD PTR rc$[rsp], eax
  000d6	83 7c 24 5c 00	 cmp	 DWORD PTR rc$[rsp], 0
  000db	7c 0c		 jl	 SHORT $LN10@vfwritemsg
  000dd	8b 44 24 58	 mov	 eax, DWORD PTR siz$[rsp]
  000e1	39 44 24 5c	 cmp	 DWORD PTR rc$[rsp], eax
  000e5	7d 02		 jge	 SHORT $LN10@vfwritemsg
  000e7	eb 4e		 jmp	 SHORT $LN6@vfwritemsg
$LN10@vfwritemsg:
  000e9	c7 44 24 5c ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
  000f1	8b 44 24 58	 mov	 eax, DWORD PTR siz$[rsp]
  000f5	05 00 01 00 00	 add	 eax, 256		; 00000100H
  000fa	89 44 24 58	 mov	 DWORD PTR siz$[rsp], eax
  000fe	81 7c 24 58 00
	00 01 00	 cmp	 DWORD PTR siz$[rsp], 65536 ; 00010000H
  00106	7e 02		 jle	 SHORT $LN11@vfwritemsg
  00108	eb 2d		 jmp	 SHORT $LN6@vfwritemsg
$LN11@vfwritemsg:
  0010a	48 63 44 24 58	 movsxd	 rax, DWORD PTR siz$[rsp]
  0010f	48 8b d0	 mov	 rdx, rax
  00112	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bfr$[rsp]
  00117	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  0011d	48 89 44 24 50	 mov	 QWORD PTR bfr$[rsp], rax
  00122	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR original_vl$6[rsp]
  0012a	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR vl$[rsp], rax
  00132	e9 62 ff ff ff	 jmp	 $LN5@vfwritemsg
$LN6@vfwritemsg:
  00137	48 83 7c 24 50
	00		 cmp	 QWORD PTR bfr$[rsp], 0
  0013d	74 41		 je	 SHORT $LN12@vfwritemsg
  0013f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bfr$[rsp]
  00144	e8 00 00 00 00	 call	 strlen
  00149	48 85 c0	 test	 rax, rax
  0014c	75 32		 jne	 SHORT $LN12@vfwritemsg
  0014e	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  00156	e8 00 00 00 00	 call	 strlen
  0015b	48 85 c0	 test	 rax, rax
  0015e	74 20		 je	 SHORT $LN12@vfwritemsg
  00160	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bfr$[rsp]
  00165	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  0016b	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR fmt$[rsp]
  00173	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00179	48 89 44 24 50	 mov	 QWORD PTR bfr$[rsp], rax
  0017e	eb 33		 jmp	 SHORT $LN13@vfwritemsg
$LN12@vfwritemsg:
  00180	48 83 7c 24 50
	00		 cmp	 QWORD PTR bfr$[rsp], 0
  00186	74 2b		 je	 SHORT $LN14@vfwritemsg
  00188	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bfr$[rsp]
  0018d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00193	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR p$7[rsp], rax
  0019b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bfr$[rsp]
  001a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  001a6	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR p$7[rsp]
  001ae	48 89 44 24 50	 mov	 QWORD PTR bfr$[rsp], rax
$LN14@vfwritemsg:
$LN13@vfwritemsg:
  001b3	33 c0		 xor	 eax, eax
  001b5	85 c0		 test	 eax, eax
  001b7	0f 85 ac fe ff
	ff		 jne	 $LN4@vfwritemsg

; 396  :     if (!bfr)         // If BFR_VSNPRINTF runs out of memory,

  001bd	48 83 7c 24 50
	00		 cmp	 QWORD PTR bfr$[rsp], 0
  001c3	75 05		 jne	 SHORT $LN15@vfwritemsg

; 397  :         return;       // then there's nothing more we can do.

  001c5	e9 ef 03 00 00	 jmp	 $LN1@vfwritemsg
$LN15@vfwritemsg:

; 398  : 
; 399  :     bufsiz = msglen = strlen( bfr ) + 2;

  001ca	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bfr$[rsp]
  001cf	e8 00 00 00 00	 call	 strlen
  001d4	48 83 c0 02	 add	 rax, 2
  001d8	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR msglen$[rsp], rax
  001e0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR msglen$[rsp]
  001e8	48 89 44 24 68	 mov	 QWORD PTR bufsiz$[rsp], rax

; 400  : 
; 401  :     // Prefix message with filename and line number, if requested
; 402  : 
; 403  :     if (MLVL( DEBUG ))

  001ed	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001f4	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  001fa	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  001ff	85 c0		 test	 eax, eax
  00201	0f 84 f1 01 00
	00		 je	 $LN16@vfwritemsg

; 404  :     {
; 405  :         char wrk[ 32 ];
; 406  :         char *nl, *newbfr, *left, *right;
; 407  :         size_t newsiz, pfxsiz, leftsize, rightsiz;
; 408  : 
; 409  :         MSGBUF( wrk, "%s(%d)", TRIMLOC( filename ), line );

  00207	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR filename$[rsp]
  0020f	e8 00 00 00 00	 call	 trimloc
  00214	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR line$[rsp]
  0021b	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0021f	4c 8b c8	 mov	 r9, rax
  00222	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159230
  00229	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0022e	48 8d 8c 24 e8
	00 00 00	 lea	 rcx, QWORD PTR wrk$11[rsp]
  00236	e8 00 00 00 00	 call	 w32_snprintf

; 410  :         MSGBUF( prefix, MLVL_DEBUG_PFXFMT, wrk );

  0023b	4c 8d 8c 24 e8
	00 00 00	 lea	 r9, QWORD PTR wrk$11[rsp]
  00243	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159231
  0024a	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0024f	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR prefix$[rsp]
  00257	e8 00 00 00 00	 call	 w32_snprintf

; 411  : 
; 412  :         pfxsiz = strlen( prefix );

  0025c	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR prefix$[rsp]
  00264	e8 00 00 00 00	 call	 strlen
  00269	48 89 44 24 78	 mov	 QWORD PTR pfxsiz$3[rsp], rax

; 413  : 
; 414  :         // Special handling for multi-line messages: insert the
; 415  :         // debug prefix (prefix) before each line except the first
; 416  :         // (which is is handled automatically further below)
; 417  : 
; 418  :         for (nl = strchr( bfr, '\n' ); nl && nl[1]; nl = strchr( nl, '\n' ))

  0026e	ba 0a 00 00 00	 mov	 edx, 10
  00273	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bfr$[rsp]
  00278	e8 00 00 00 00	 call	 strchr
  0027d	48 89 44 24 60	 mov	 QWORD PTR nl$1[rsp], rax
  00282	eb 14		 jmp	 SHORT $LN9@vfwritemsg
$LN7@vfwritemsg:
  00284	ba 0a 00 00 00	 mov	 edx, 10
  00289	48 8b 4c 24 60	 mov	 rcx, QWORD PTR nl$1[rsp]
  0028e	e8 00 00 00 00	 call	 strchr
  00293	48 89 44 24 60	 mov	 QWORD PTR nl$1[rsp], rax
$LN9@vfwritemsg:
  00298	48 83 7c 24 60
	00		 cmp	 QWORD PTR nl$1[rsp], 0
  0029e	0f 84 3f 01 00
	00		 je	 $LN8@vfwritemsg
  002a4	b8 01 00 00 00	 mov	 eax, 1
  002a9	48 6b c0 01	 imul	 rax, rax, 1
  002ad	48 8b 4c 24 60	 mov	 rcx, QWORD PTR nl$1[rsp]
  002b2	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  002b6	85 c0		 test	 eax, eax
  002b8	0f 84 25 01 00
	00		 je	 $LN8@vfwritemsg

; 419  :         {
; 420  :             left = bfr;

  002be	48 8b 44 24 50	 mov	 rax, QWORD PTR bfr$[rsp]
  002c3	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR left$8[rsp], rax

; 421  :             right = nl+1;

  002cb	48 8b 44 24 60	 mov	 rax, QWORD PTR nl$1[rsp]
  002d0	48 ff c0	 inc	 rax
  002d3	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR right$9[rsp], rax

; 422  : 
; 423  :             leftsize = ((nl+1) - bfr);

  002db	48 8b 44 24 60	 mov	 rax, QWORD PTR nl$1[rsp]
  002e0	48 ff c0	 inc	 rax
  002e3	48 2b 44 24 50	 sub	 rax, QWORD PTR bfr$[rsp]
  002e8	48 89 44 24 70	 mov	 QWORD PTR leftsize$2[rsp], rax

; 424  :             rightsiz = bufsiz - leftsize;

  002ed	48 8b 44 24 70	 mov	 rax, QWORD PTR leftsize$2[rsp]
  002f2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bufsiz$[rsp]
  002f7	48 2b c8	 sub	 rcx, rax
  002fa	48 8b c1	 mov	 rax, rcx
  002fd	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR rightsiz$10[rsp], rax

; 425  : 
; 426  :             newsiz = bufsiz + pfxsiz;

  00305	48 8b 44 24 78	 mov	 rax, QWORD PTR pfxsiz$3[rsp]
  0030a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bufsiz$[rsp]
  0030f	48 03 c8	 add	 rcx, rax
  00312	48 8b c1	 mov	 rax, rcx
  00315	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR newsiz$5[rsp], rax

; 427  :             newbfr = malloc( newsiz );

  0031d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR newsiz$5[rsp]
  00325	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0032b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR newbfr$4[rsp], rax

; 428  : 
; 429  :             memcpy( newbfr, left, leftsize );

  00333	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR newbfr$4[rsp]
  0033b	48 8b b4 24 b0
	00 00 00	 mov	 rsi, QWORD PTR left$8[rsp]
  00343	48 8b 4c 24 70	 mov	 rcx, QWORD PTR leftsize$2[rsp]
  00348	f3 a4		 rep movsb

; 430  :             memcpy( newbfr + leftsize, prefix, pfxsiz );

  0034a	48 8b 44 24 70	 mov	 rax, QWORD PTR leftsize$2[rsp]
  0034f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR newbfr$4[rsp]
  00357	48 03 c8	 add	 rcx, rax
  0035a	48 8b c1	 mov	 rax, rcx
  0035d	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR prefix$[rsp]
  00365	48 8b f8	 mov	 rdi, rax
  00368	48 8b f1	 mov	 rsi, rcx
  0036b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pfxsiz$3[rsp]
  00370	f3 a4		 rep movsb

; 431  :             memcpy( newbfr + leftsize + pfxsiz, right, rightsiz );

  00372	48 8b 44 24 70	 mov	 rax, QWORD PTR leftsize$2[rsp]
  00377	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR newbfr$4[rsp]
  0037f	48 03 c8	 add	 rcx, rax
  00382	48 8b c1	 mov	 rax, rcx
  00385	48 03 44 24 78	 add	 rax, QWORD PTR pfxsiz$3[rsp]
  0038a	48 8b f8	 mov	 rdi, rax
  0038d	48 8b b4 24 b8
	00 00 00	 mov	 rsi, QWORD PTR right$9[rsp]
  00395	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR rightsiz$10[rsp]
  0039d	f3 a4		 rep movsb

; 432  : 
; 433  :             free( bfr );

  0039f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bfr$[rsp]
  003a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 434  :             bfr = newbfr;

  003aa	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR newbfr$4[rsp]
  003b2	48 89 44 24 50	 mov	 QWORD PTR bfr$[rsp], rax

; 435  :             bufsiz = newsiz;

  003b7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR newsiz$5[rsp]
  003bf	48 89 44 24 68	 mov	 QWORD PTR bufsiz$[rsp], rax

; 436  :             nl = bfr + leftsize + pfxsiz;

  003c4	48 8b 44 24 70	 mov	 rax, QWORD PTR leftsize$2[rsp]
  003c9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bfr$[rsp]
  003ce	48 03 c8	 add	 rcx, rax
  003d1	48 8b c1	 mov	 rax, rcx
  003d4	48 03 44 24 78	 add	 rax, QWORD PTR pfxsiz$3[rsp]
  003d9	48 89 44 24 60	 mov	 QWORD PTR nl$1[rsp], rax

; 437  :         }

  003de	e9 a1 fe ff ff	 jmp	 $LN7@vfwritemsg
$LN8@vfwritemsg:

; 438  : 
; 439  :         bufsiz += pfxsiz;

  003e3	48 8b 44 24 78	 mov	 rax, QWORD PTR pfxsiz$3[rsp]
  003e8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bufsiz$[rsp]
  003ed	48 03 c8	 add	 rcx, rax
  003f0	48 8b c1	 mov	 rax, rcx
  003f3	48 89 44 24 68	 mov	 QWORD PTR bufsiz$[rsp], rax
$LN16@vfwritemsg:

; 440  :     }
; 441  : 
; 442  :     msgbuf = calloc( 1, bufsiz );

  003f8	48 8b 54 24 68	 mov	 rdx, QWORD PTR bufsiz$[rsp]
  003fd	b9 01 00 00 00	 mov	 ecx, 1
  00402	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00408	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR msgbuf$[rsp], rax

; 443  : 
; 444  :     if (msgbuf)

  00410	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR msgbuf$[rsp], 0
  00419	74 58		 je	 SHORT $LN17@vfwritemsg

; 445  :     {
; 446  :         snprintf( msgbuf, bufsiz, "%s%s", prefix, bfr );

  0041b	48 8b 44 24 50	 mov	 rax, QWORD PTR bfr$[rsp]
  00420	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00425	4c 8d 8c 24 c8
	00 00 00	 lea	 r9, QWORD PTR prefix$[rsp]
  0042d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159233
  00434	48 8b 54 24 68	 mov	 rdx, QWORD PTR bufsiz$[rsp]
  00439	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR msgbuf$[rsp]
  00441	e8 00 00 00 00	 call	 w32_snprintf

; 447  :         flog_write( panel, f, msgbuf );

  00446	0f b6 84 24 30
	01 00 00	 movzx	 eax, BYTE PTR panel$[rsp]
  0044e	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR msgbuf$[rsp]
  00456	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR f$[rsp]
  0045e	8b c8		 mov	 ecx, eax
  00460	e8 00 00 00 00	 call	 flog_write

; 448  :         free( msgbuf );

  00465	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR msgbuf$[rsp]
  0046d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN17@vfwritemsg:

; 449  :     }
; 450  : 
; 451  :     // Show them where the error message came from, if requested
; 452  : 
; 453  :     if (1
; 454  :         &&  MLVL( EMSGLOC )
; 455  :         && !MLVL( DEBUG )
; 456  :         && msglen > 10
; 457  :         && strncasecmp( bfr, "HHC", 3 ) == 0
; 458  :         && (0

  00473	33 c0		 xor	 eax, eax
  00475	83 f8 01	 cmp	 eax, 1
  00478	0f 84 1b 01 00
	00		 je	 $LN18@vfwritemsg
  0047e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00485	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  0048b	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00490	85 c0		 test	 eax, eax
  00492	0f 84 01 01 00
	00		 je	 $LN18@vfwritemsg
  00498	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0049f	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  004a5	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  004aa	85 c0		 test	 eax, eax
  004ac	0f 85 e7 00 00
	00		 jne	 $LN18@vfwritemsg
  004b2	48 83 bc 24 98
	00 00 00 0a	 cmp	 QWORD PTR msglen$[rsp], 10
  004bb	0f 86 d8 00 00
	00		 jbe	 $LN18@vfwritemsg
  004c1	41 b8 03 00 00
	00		 mov	 r8d, 3
  004c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159235
  004ce	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bfr$[rsp]
  004d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  004d9	85 c0		 test	 eax, eax
  004db	0f 85 b8 00 00
	00		 jne	 $LN18@vfwritemsg
  004e1	33 c0		 xor	 eax, eax
  004e3	85 c0		 test	 eax, eax
  004e5	75 45		 jne	 SHORT $LN19@vfwritemsg
  004e7	b8 01 00 00 00	 mov	 eax, 1
  004ec	48 6b c0 08	 imul	 rax, rax, 8
  004f0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bfr$[rsp]
  004f5	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  004f9	83 f8 53	 cmp	 eax, 83			; 00000053H
  004fc	74 2e		 je	 SHORT $LN19@vfwritemsg
  004fe	b8 01 00 00 00	 mov	 eax, 1
  00503	48 6b c0 08	 imul	 rax, rax, 8
  00507	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bfr$[rsp]
  0050c	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00510	83 f8 45	 cmp	 eax, 69			; 00000045H
  00513	74 17		 je	 SHORT $LN19@vfwritemsg
  00515	b8 01 00 00 00	 mov	 eax, 1
  0051a	48 6b c0 08	 imul	 rax, rax, 8
  0051e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bfr$[rsp]
  00523	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00527	83 f8 57	 cmp	 eax, 87			; 00000057H
  0052a	75 6d		 jne	 SHORT $LN18@vfwritemsg
$LN19@vfwritemsg:

; 459  :             || 'S' == bfr[8]
; 460  :             || 'E' == bfr[8]
; 461  :             || 'W' == bfr[8]
; 462  :            )
; 463  :     )
; 464  :     {
; 465  :         // "Previous message from function '%s' at %s(%d)"
; 466  :         FWRMSG( f, HHC00007, "I", func, TRIMLOC( filename ), line );

  0052c	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR filename$[rsp]
  00534	e8 00 00 00 00	 call	 trimloc
  00539	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR line$[rsp]
  00540	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00544	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00549	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR func$[rsp]
  00551	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00556	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159237
  0055d	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00562	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159238
  00569	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0056e	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR f$[rsp]
  00576	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0057b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00581	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159239
  00588	ba d2 01 00 00	 mov	 edx, 466		; 000001d2H
  0058d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159240
  00594	e8 00 00 00 00	 call	 fwritemsg
$LN18@vfwritemsg:

; 467  :     }
; 468  : 
; 469  :     free( bfr );

  00599	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bfr$[rsp]
  0059e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 470  : 
; 471  :   #ifdef NEED_LOGMSG_FFLUSH
; 472  :     fflush( f );

  005a4	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR f$[rsp]
  005ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 473  :   #endif
; 474  : 
; 475  :     log_wakeup( NULL );

  005b2	33 c9		 xor	 ecx, ecx
  005b4	e8 00 00 00 00	 call	 log_wakeup
$LN1@vfwritemsg:

; 476  : }

  005b9	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005c1	48 33 cc	 xor	 rcx, rsp
  005c4	e8 00 00 00 00	 call	 __security_check_cookie
  005c9	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  005d0	5f		 pop	 rdi
  005d1	5e		 pop	 rsi
  005d2	c3		 ret	 0
vfwritemsg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\logmsg.c
_TEXT	SEGMENT
pCAPTCTL$ = 32
panel$ = 64
f$ = 72
msg$ = 80
flog_write PROC

; 341  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 342  :     CAPTCTL* pCAPTCTL = NULL;       // (MUST be initialized to NULL)

  00012	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR pCAPTCTL$[rsp], 0

; 343  : 
; 344  :     /* Retrieve capture control entry if capturing is allowed/active */
; 345  :     if (panel & WRMSG_CAPTURE)

  0001b	8b 44 24 40	 mov	 eax, DWORD PTR panel$[rsp]
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 3c		 je	 SHORT $LN2@flog_write

; 346  :     {
; 347  :         InitCAPTCTL();  // (in case it hasn't been done yet)

  00026	e8 00 00 00 00	 call	 InitCAPTCTL

; 348  : 
; 349  :         /* Locate the capturing control entry for this thread */
; 350  :         lock_capture();

  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159169
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:captctl_lock
  00039	e8 00 00 00 00	 call	 hthread_obtain_lock

; 351  :         {
; 352  :             pCAPTCTL = FindCAPTCTL( thread_id() );

  0003e	e8 00 00 00 00	 call	 fthread_self
  00043	8b c8		 mov	 ecx, eax
  00045	e8 00 00 00 00	 call	 FindCAPTCTL
  0004a	48 89 44 24 20	 mov	 QWORD PTR pCAPTCTL$[rsp], rax

; 353  :         }
; 354  :         unlock_capture();

  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159170
  00056	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:captctl_lock
  0005d	e8 00 00 00 00	 call	 hthread_release_lock
$LN2@flog_write:

; 355  :     }
; 356  : 
; 357  :     /* If write to panel wanted, send message through logmsg pipe */
; 358  :     if ((panel & WRMSG_PANEL) && !wrmsg_quiet)

  00062	8b 44 24 40	 mov	 eax, DWORD PTR panel$[rsp]
  00066	83 e0 02	 and	 eax, 2
  00069	85 c0		 test	 eax, eax
  0006b	74 1a		 je	 SHORT $LN3@flog_write
  0006d	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR wrmsg_quiet
  00074	85 c0		 test	 eax, eax
  00076	75 0f		 jne	 SHORT $LN3@flog_write

; 359  :         _flog_write_pipe( f, msg );

  00078	48 8b 54 24 50	 mov	 rdx, QWORD PTR msg$[rsp]
  0007d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR f$[rsp]
  00082	e8 00 00 00 00	 call	 _flog_write_pipe
$LN3@flog_write:

; 360  : 
; 361  :     /* Capture this message if capturing is active for this thread */
; 362  :     if (pCAPTCTL)

  00087	48 83 7c 24 20
	00		 cmp	 QWORD PTR pCAPTCTL$[rsp], 0
  0008d	74 13		 je	 SHORT $LN4@flog_write

; 363  :         capture_message( msg, pCAPTCTL->captmsgs );

  0008f	48 8b 44 24 20	 mov	 rax, QWORD PTR pCAPTCTL$[rsp]
  00094	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00098	48 8b 4c 24 50	 mov	 rcx, QWORD PTR msg$[rsp]
  0009d	e8 00 00 00 00	 call	 capture_message
$LN4@flog_write:

; 364  : }

  000a2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a6	c3		 ret	 0
flog_write ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\logmsg.c
_TEXT	SEGMENT
rc$ = 32
len$ = 36
f$ = 64
msg$ = 72
_flog_write_pipe PROC

; 269  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 270  :     /* Send message through logger facility pipe to panel.c,
; 271  :        or display it directly to the terminal via fprintf
; 272  :        if this is a utility message or we're shutting down
; 273  :        or we're otherwise unable to send it through the pipe.
; 274  :     */
; 275  :     int rc = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 276  :     int len = (int) strlen( msg );

  00016	48 8b 4c 24 48	 mov	 rcx, QWORD PTR msg$[rsp]
  0001b	e8 00 00 00 00	 call	 strlen
  00020	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 277  :     if (0
; 278  :         || sysblk.shutdown
; 279  :         || stdout != f
; 280  :         || !logger_syslogfd[ LOG_WRITE ]
; 281  :         || (rc = do_write_pipe( logger_syslogfd[ LOG_WRITE ], msg, len )) < 0

  00024	33 c0		 xor	 eax, eax
  00026	85 c0		 test	 eax, eax
  00028	75 6c		 jne	 SHORT $LN3@flog_write
  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00031	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00037	c1 e8 0b	 shr	 eax, 11
  0003a	83 e0 01	 and	 eax, 1
  0003d	85 c0		 test	 eax, eax
  0003f	75 55		 jne	 SHORT $LN3@flog_write
  00041	b9 01 00 00 00	 mov	 ecx, 1
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0004c	48 3b 44 24 40	 cmp	 rax, QWORD PTR f$[rsp]
  00051	75 43		 jne	 SHORT $LN3@flog_write
  00053	b8 04 00 00 00	 mov	 eax, 4
  00058	48 6b c0 01	 imul	 rax, rax, 1
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_syslogfd
  00063	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  00067	74 2d		 je	 SHORT $LN3@flog_write
  00069	b8 04 00 00 00	 mov	 eax, 4
  0006e	48 6b c0 01	 imul	 rax, rax, 1
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_syslogfd
  00079	44 8b 44 24 24	 mov	 r8d, DWORD PTR len$[rsp]
  0007e	48 8b 54 24 48	 mov	 rdx, QWORD PTR msg$[rsp]
  00083	8b 0c 01	 mov	 ecx, DWORD PTR [rcx+rax]
  00086	e8 00 00 00 00	 call	 do_write_pipe
  0008b	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
  0008f	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00094	7d 52		 jge	 SHORT $LN2@flog_write
$LN3@flog_write:

; 282  :     )
; 283  :     {
; 284  :         // Something went wrong or we're shutting down.
; 285  :         // Write the message to the screen instead...
; 286  : 
; 287  :         fprintf( f, "%s", msg );   /* (write msg to screen) */

  00096	4c 8b 44 24 48	 mov	 r8, QWORD PTR msg$[rsp]
  0009b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159156
  000a2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR f$[rsp]
  000a7	e8 00 00 00 00	 call	 w32_fprintf

; 288  : 
; 289  :         // PROGRAMMING NOTE: the external GUI receives messages
; 290  :         // not only via its logfile stream but also via its stderr
; 291  :         // stream too, so if there's an external gui, we skip the
; 292  :         // logfile write in order to prevent duplicate messages.
; 293  :         //
; 294  :         // If no external GUI exists however, then we need to
; 295  :         // write the message to the logfile WITH a timstamp.
; 296  : 
; 297  :         if (1
; 298  :             && sysblk.shutdown      // (shutting down?)
; 299  :             && !extgui              // (no external gui?)

  000ac	33 c0		 xor	 eax, eax
  000ae	83 f8 01	 cmp	 eax, 1
  000b1	74 35		 je	 SHORT $LN4@flog_write
  000b3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ba	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  000c0	c1 e8 0b	 shr	 eax, 11
  000c3	83 e0 01	 and	 eax, 1
  000c6	85 c0		 test	 eax, eax
  000c8	74 1e		 je	 SHORT $LN4@flog_write
  000ca	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  000d1	83 38 00	 cmp	 DWORD PTR [rax], 0
  000d4	75 12		 jne	 SHORT $LN4@flog_write

; 300  :         )
; 301  :         {
; 302  :             // (then we need to timestamp the logmsg...)
; 303  :             // (note: call does nothing if no logfile exists!)
; 304  : 
; 305  :             logger_timestamped_logfile_write( msg, len );

  000d6	48 63 44 24 24	 movsxd	 rax, DWORD PTR len$[rsp]
  000db	48 8b d0	 mov	 rdx, rax
  000de	48 8b 4c 24 48	 mov	 rcx, QWORD PTR msg$[rsp]
  000e3	e8 00 00 00 00	 call	 logger_timestamped_logfile_write
$LN4@flog_write:
$LN2@flog_write:

; 306  :         }
; 307  :     }
; 308  : }

  000e8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ec	c3		 ret	 0
_flog_write_pipe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\logmsg.c
_TEXT	SEGMENT
rc$ = 32
retry$ = 36
written$ = 40
tv85 = 44
tv73 = 48
fd$ = 80
msg$ = 88
len$ = 96
do_write_pipe PROC

; 237  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 238  :     // Note: logger write fd is non-blocking
; 239  :     int retry = 5;

  00012	c7 44 24 24 05
	00 00 00	 mov	 DWORD PTR retry$[rsp], 5

; 240  :     int written = 0;

  0001a	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR written$[rsp], 0
$LN10@do_write_p:
$LN2@do_write_p:

; 241  :     int rc;
; 242  :     while ((rc = write_pipe( fd, msg, len )) != len && retry--)

  00022	48 63 44 24 50	 movsxd	 rax, DWORD PTR fd$[rsp]
  00027	45 33 c9	 xor	 r9d, r9d
  0002a	44 8b 44 24 60	 mov	 r8d, DWORD PTR len$[rsp]
  0002f	48 8b 54 24 58	 mov	 rdx, QWORD PTR msg$[rsp]
  00034	48 8b c8	 mov	 rcx, rax
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_send
  0003d	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
  00041	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  00045	39 44 24 20	 cmp	 DWORD PTR rc$[rsp], eax
  00049	74 7d		 je	 SHORT $LN3@do_write_p
  0004b	8b 44 24 24	 mov	 eax, DWORD PTR retry$[rsp]
  0004f	89 44 24 30	 mov	 DWORD PTR tv73[rsp], eax
  00053	8b 44 24 24	 mov	 eax, DWORD PTR retry$[rsp]
  00057	ff c8		 dec	 eax
  00059	89 44 24 24	 mov	 DWORD PTR retry$[rsp], eax
  0005d	83 7c 24 30 00	 cmp	 DWORD PTR tv73[rsp], 0
  00062	74 64		 je	 SHORT $LN3@do_write_p

; 243  :     {
; 244  :         if (rc == -1)

  00064	83 7c 24 20 ff	 cmp	 DWORD PTR rc$[rsp], -1
  00069	75 19		 jne	 SHORT $LN4@do_write_p

; 245  :         {
; 246  :             if (errno == EAGAIN)

  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00071	83 38 0b	 cmp	 DWORD PTR [rax], 11
  00074	75 0c		 jne	 SHORT $LN5@do_write_p

; 247  :             {
; 248  :                 // logger is backlogged; wait a bit before retrying
; 249  :                 usleep(10000);

  00076	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  0007b	e8 00 00 00 00	 call	 usleep

; 250  :                 continue;

  00080	eb a0		 jmp	 SHORT $LN2@do_write_p
$LN5@do_write_p:

; 251  :             }
; 252  :             break;

  00082	eb 44		 jmp	 SHORT $LN3@do_write_p
$LN4@do_write_p:

; 253  :         }
; 254  :         if (rc < len)

  00084	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  00088	39 44 24 20	 cmp	 DWORD PTR rc$[rsp], eax
  0008c	7d 35		 jge	 SHORT $LN6@do_write_p

; 255  :         {
; 256  :             // Short write (may occur if write >= PIPE_BUF)
; 257  :             len -= rc;

  0008e	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  00092	8b 4c 24 60	 mov	 ecx, DWORD PTR len$[rsp]
  00096	2b c8		 sub	 ecx, eax
  00098	8b c1		 mov	 eax, ecx
  0009a	89 44 24 60	 mov	 DWORD PTR len$[rsp], eax

; 258  :             msg += rc;

  0009e	48 63 44 24 20	 movsxd	 rax, DWORD PTR rc$[rsp]
  000a3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR msg$[rsp]
  000a8	48 03 c8	 add	 rcx, rax
  000ab	48 8b c1	 mov	 rax, rcx
  000ae	48 89 44 24 58	 mov	 QWORD PTR msg$[rsp], rax

; 259  :             written += rc;

  000b3	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  000b7	8b 4c 24 28	 mov	 ecx, DWORD PTR written$[rsp]
  000bb	03 c8		 add	 ecx, eax
  000bd	8b c1		 mov	 eax, ecx
  000bf	89 44 24 28	 mov	 DWORD PTR written$[rsp], eax
$LN6@do_write_p:

; 260  :         }
; 261  :     }

  000c3	e9 5a ff ff ff	 jmp	 $LN10@do_write_p
$LN3@do_write_p:

; 262  :     return rc == -1 ? -1 : written + len;

  000c8	83 7c 24 20 ff	 cmp	 DWORD PTR rc$[rsp], -1
  000cd	75 0a		 jne	 SHORT $LN8@do_write_p
  000cf	c7 44 24 2c ff
	ff ff ff	 mov	 DWORD PTR tv85[rsp], -1
  000d7	eb 10		 jmp	 SHORT $LN9@do_write_p
$LN8@do_write_p:
  000d9	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  000dd	8b 4c 24 28	 mov	 ecx, DWORD PTR written$[rsp]
  000e1	03 c8		 add	 ecx, eax
  000e3	8b c1		 mov	 eax, ecx
  000e5	89 44 24 2c	 mov	 DWORD PTR tv85[rsp], eax
$LN9@do_write_p:
  000e9	8b 44 24 2c	 mov	 eax, DWORD PTR tv85[rsp]

; 263  : }

  000ed	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f1	c3		 ret	 0
do_write_pipe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\logmsg.c
_TEXT	SEGMENT
tv89 = 32
msg$ = 64
pCAPTMSGS$ = 72
capture_message PROC

; 182  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 183  :     if (!msg || !*msg || !pCAPTMSGS)

  0000e	48 83 7c 24 40
	00		 cmp	 QWORD PTR msg$[rsp], 0
  00014	74 14		 je	 SHORT $LN3@capture_me
  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR msg$[rsp]
  0001b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0001e	85 c0		 test	 eax, eax
  00020	74 08		 je	 SHORT $LN3@capture_me
  00022	48 83 7c 24 48
	00		 cmp	 QWORD PTR pCAPTMSGS$[rsp], 0
  00028	75 05		 jne	 SHORT $LN2@capture_me
$LN3@capture_me:

; 184  :         return;

  0002a	e9 a1 00 00 00	 jmp	 $LN1@capture_me
$LN2@capture_me:

; 185  : 
; 186  :     /* Initialize the captured messages buffer if needed */
; 187  :     if (!pCAPTMSGS->msgs || !pCAPTMSGS->szmsgs)

  0002f	48 8b 44 24 48	 mov	 rax, QWORD PTR pCAPTMSGS$[rsp]
  00034	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00038	74 0c		 je	 SHORT $LN5@capture_me
  0003a	48 8b 44 24 48	 mov	 rax, QWORD PTR pCAPTMSGS$[rsp]
  0003f	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00044	75 2b		 jne	 SHORT $LN4@capture_me
$LN5@capture_me:

; 188  :     {
; 189  :         pCAPTMSGS->msgs = malloc( pCAPTMSGS->szmsgs = 1 );

  00046	48 8b 44 24 48	 mov	 rax, QWORD PTR pCAPTMSGS$[rsp]
  0004b	48 c7 40 08 01
	00 00 00	 mov	 QWORD PTR [rax+8], 1
  00053	b9 01 00 00 00	 mov	 ecx, 1
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0005e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pCAPTMSGS$[rsp]
  00063	48 89 01	 mov	 QWORD PTR [rcx], rax

; 190  :         *pCAPTMSGS->msgs = 0; // (null terminate)

  00066	48 8b 44 24 48	 mov	 rax, QWORD PTR pCAPTMSGS$[rsp]
  0006b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006e	c6 00 00	 mov	 BYTE PTR [rax], 0
$LN4@capture_me:

; 191  :     }
; 192  : 
; 193  :     /* Reallocate capture buffer to accommodate the new message */
; 194  :     pCAPTMSGS->msgs = realloc( pCAPTMSGS->msgs, pCAPTMSGS->szmsgs += strlen( msg ));

  00071	48 8b 4c 24 40	 mov	 rcx, QWORD PTR msg$[rsp]
  00076	e8 00 00 00 00	 call	 strlen
  0007b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pCAPTMSGS$[rsp]
  00080	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00084	48 03 c8	 add	 rcx, rax
  00087	48 89 4c 24 20	 mov	 QWORD PTR tv89[rsp], rcx
  0008c	48 8b 44 24 48	 mov	 rax, QWORD PTR pCAPTMSGS$[rsp]
  00091	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv89[rsp]
  00096	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  0009a	48 8b 54 24 20	 mov	 rdx, QWORD PTR tv89[rsp]
  0009f	48 8b 44 24 48	 mov	 rax, QWORD PTR pCAPTMSGS$[rsp]
  000a4	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  000ad	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pCAPTMSGS$[rsp]
  000b2	48 89 01	 mov	 QWORD PTR [rcx], rax

; 195  : 
; 196  :     /* Add this new message to our buffer of captured messages */
; 197  :     strlcat( pCAPTMSGS->msgs, msg, pCAPTMSGS->szmsgs );

  000b5	48 8b 44 24 48	 mov	 rax, QWORD PTR pCAPTMSGS$[rsp]
  000ba	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  000be	48 8b 54 24 40	 mov	 rdx, QWORD PTR msg$[rsp]
  000c3	48 8b 44 24 48	 mov	 rax, QWORD PTR pCAPTMSGS$[rsp]
  000c8	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000cb	e8 00 00 00 00	 call	 strlcat
$LN1@capture_me:

; 198  : }

  000d0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d4	c3		 ret	 0
capture_message ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\logmsg.c
_TEXT	SEGMENT
pCAPTCTL$ = 48
stop_capturing PROC

; 169  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 170  :     if (!pCAPTCTL)      // (if start capturing failed)

  0000a	48 83 7c 24 30
	00		 cmp	 QWORD PTR pCAPTCTL$[rsp], 0
  00010	75 02		 jne	 SHORT $LN2@stop_captu

; 171  :         return;         // (then no capturing to stop)

  00012	eb 34		 jmp	 SHORT $LN1@stop_captu
$LN2@stop_captu:

; 172  : 
; 173  :     /* Zero this capturing control table entry so it can be reused */
; 174  :     lock_capture();

  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159104
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:captctl_lock
  00022	e8 00 00 00 00	 call	 hthread_obtain_lock

; 175  :     {
; 176  :         memset( pCAPTCTL, 0, sizeof( CAPTCTL ));

  00027	48 8b 7c 24 30	 mov	 rdi, QWORD PTR pCAPTCTL$[rsp]
  0002c	33 c0		 xor	 eax, eax
  0002e	b9 10 00 00 00	 mov	 ecx, 16
  00033	f3 aa		 rep stosb

; 177  :     }
; 178  :     unlock_capture();

  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159105
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:captctl_lock
  00043	e8 00 00 00 00	 call	 hthread_release_lock
$LN1@stop_captu:

; 179  : }

  00048	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004c	5f		 pop	 rdi
  0004d	c3		 ret	 0
stop_capturing ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\logmsg.c
_TEXT	SEGMENT
pCAPTCTL$ = 32
pCAPTMSGS$ = 64
start_capturing PROC

; 154  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 155  :     CAPTCTL* pCAPTCTL;
; 156  : 
; 157  :     InitCAPTCTL();  // (in case it hasn't been done yet)

  00009	e8 00 00 00 00	 call	 InitCAPTCTL

; 158  : 
; 159  :     lock_capture();

  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159096
  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:captctl_lock
  0001c	e8 00 00 00 00	 call	 hthread_obtain_lock

; 160  :     {
; 161  :         pCAPTCTL = NewCAPTCTL( thread_id(), pCAPTMSGS );

  00021	e8 00 00 00 00	 call	 fthread_self
  00026	48 8b 54 24 40	 mov	 rdx, QWORD PTR pCAPTMSGS$[rsp]
  0002b	8b c8		 mov	 ecx, eax
  0002d	e8 00 00 00 00	 call	 NewCAPTCTL
  00032	48 89 44 24 20	 mov	 QWORD PTR pCAPTCTL$[rsp], rax

; 162  :     }
; 163  :     unlock_capture();

  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159097
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:captctl_lock
  00045	e8 00 00 00 00	 call	 hthread_release_lock

; 164  : 
; 165  :     return pCAPTCTL;

  0004a	48 8b 44 24 20	 mov	 rax, QWORD PTR pCAPTCTL$[rsp]

; 166  : }

  0004f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00053	c3		 ret	 0
start_capturing ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\logmsg.c
_TEXT	SEGMENT
pCAPTCTL$ = 32
tid$ = 64
pCAPTMSGS$ = 72
NewCAPTCTL PROC

; 137  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 138  :     CAPTCTL* pCAPTCTL;
; 139  : 
; 140  :     /* Find an available CAPTCTL entry */
; 141  :     if (!(pCAPTCTL = FindCAPTCTL( (TID) 0 )))

  0000d	33 c9		 xor	 ecx, ecx
  0000f	e8 00 00 00 00	 call	 FindCAPTCTL
  00014	48 89 44 24 20	 mov	 QWORD PTR pCAPTCTL$[rsp], rax
  00019	48 83 7c 24 20
	00		 cmp	 QWORD PTR pCAPTCTL$[rsp], 0
  0001f	75 04		 jne	 SHORT $LN2@NewCAPTCTL

; 142  :         return NULL;

  00021	33 c0		 xor	 eax, eax
  00023	eb 1e		 jmp	 SHORT $LN1@NewCAPTCTL
$LN2@NewCAPTCTL:

; 143  : 
; 144  :     /* Fill in the new entry */
; 145  :     pCAPTCTL->tid      = tid;

  00025	48 8b 44 24 20	 mov	 rax, QWORD PTR pCAPTCTL$[rsp]
  0002a	8b 4c 24 40	 mov	 ecx, DWORD PTR tid$[rsp]
  0002e	89 08		 mov	 DWORD PTR [rax], ecx

; 146  :     pCAPTCTL->captmsgs = pCAPTMSGS;

  00030	48 8b 44 24 20	 mov	 rax, QWORD PTR pCAPTCTL$[rsp]
  00035	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pCAPTMSGS$[rsp]
  0003a	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 147  : 
; 148  :     return pCAPTCTL;

  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR pCAPTCTL$[rsp]
$LN1@NewCAPTCTL:

; 149  : }

  00043	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00047	c3		 ret	 0
NewCAPTCTL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\logmsg.c
_TEXT	SEGMENT
i$ = 32
pCAPTCTL$ = 40
tid$ = 64
FindCAPTCTL PROC

; 123  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 124  :     CAPTCTL*  pCAPTCTL;
; 125  :     int       i;
; 126  : 
; 127  :     /* Search our capture control table for the desired entry */
; 128  :     for (i=0, pCAPTCTL = captctl_tab; i < (int) _countof( captctl_tab ); i++, pCAPTCTL++)

  00008	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00010	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:captctl_tab
  00017	48 89 44 24 28	 mov	 QWORD PTR pCAPTCTL$[rsp], rax
  0001c	eb 18		 jmp	 SHORT $LN4@FindCAPTCT
$LN2@FindCAPTCT:
  0001e	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00022	ff c0		 inc	 eax
  00024	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00028	48 8b 44 24 28	 mov	 rax, QWORD PTR pCAPTCTL$[rsp]
  0002d	48 83 c0 10	 add	 rax, 16
  00031	48 89 44 24 28	 mov	 QWORD PTR pCAPTCTL$[rsp], rax
$LN4@FindCAPTCT:
  00036	83 7c 24 20 44	 cmp	 DWORD PTR i$[rsp], 68	; 00000044H
  0003b	7d 1d		 jge	 SHORT $LN3@FindCAPTCT

; 129  :     {
; 130  :         if (equal_threads( pCAPTCTL->tid, tid ))

  0003d	8b 54 24 40	 mov	 edx, DWORD PTR tid$[rsp]
  00041	48 8b 44 24 28	 mov	 rax, QWORD PTR pCAPTCTL$[rsp]
  00046	8b 08		 mov	 ecx, DWORD PTR [rax]
  00048	e8 00 00 00 00	 call	 hthread_equal_threads
  0004d	85 c0		 test	 eax, eax
  0004f	74 07		 je	 SHORT $LN5@FindCAPTCT

; 131  :             return pCAPTCTL;

  00051	48 8b 44 24 28	 mov	 rax, QWORD PTR pCAPTCTL$[rsp]
  00056	eb 04		 jmp	 SHORT $LN1@FindCAPTCT
$LN5@FindCAPTCT:

; 132  :     }

  00058	eb c4		 jmp	 SHORT $LN2@FindCAPTCT
$LN3@FindCAPTCT:

; 133  :     return NULL;

  0005a	33 c0		 xor	 eax, eax
$LN1@FindCAPTCT:

; 134  : }

  0005c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00060	c3		 ret	 0
FindCAPTCTL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\logmsg.c
_TEXT	SEGMENT
InitCAPTCTL PROC

; 114  : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 115  :     static BYTE didthis = FALSE;
; 116  :     if (didthis) return;

  00006	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?didthis@?1??InitCAPTCTL@@9@9
  0000d	85 c0		 test	 eax, eax
  0000f	74 02		 je	 SHORT $LN2@InitCAPTCT
  00011	eb 34		 jmp	 SHORT $LN1@InitCAPTCT
$LN2@InitCAPTCT:

; 117  :     didthis = TRUE;

  00013	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?didthis@?1??InitCAPTCTL@@9@9, 1

; 118  :     initialize_lock( &captctl_lock );

  0001a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159067
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159068
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:captctl_lock
  0002f	e8 00 00 00 00	 call	 hthread_initialize_lock

; 119  :     memset( captctl_tab, 0, sizeof( captctl_tab ));

  00034	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:captctl_tab
  0003b	48 8b f8	 mov	 rdi, rax
  0003e	33 c0		 xor	 eax, eax
  00040	b9 40 04 00 00	 mov	 ecx, 1088		; 00000440H
  00045	f3 aa		 rep stosb
$LN1@InitCAPTCT:

; 120  : }

  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5f		 pop	 rdi
  0004c	c3		 ret	 0
InitCAPTCTL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\logmsg.c
_TEXT	SEGMENT
rc$ = 32
pCAPTCTL$ = 40
captmsgs$ = 48
cmd$ = 80
resp$ = 88
quiet$ = 96
panel_command_capture PROC

; 204  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 205  :     int rc;
; 206  :     CAPTCTL*  pCAPTCTL;             // ptr to capturing control entry
; 207  :     CAPTMSGS  captmsgs  = {0};      // captured messages structure

  00014	48 8d 44 24 30	 lea	 rax, QWORD PTR captmsgs$[rsp]
  00019	48 8b f8	 mov	 rdi, rax
  0001c	33 c0		 xor	 eax, eax
  0001e	b9 10 00 00 00	 mov	 ecx, 16
  00023	f3 aa		 rep stosb

; 208  : 
; 209  :     /* Start capturing */
; 210  :     wrmsg_quiet = quiet;            // caller can suppress panel output

  00025	0f b6 44 24 60	 movzx	 eax, BYTE PTR quiet$[rsp]
  0002a	88 05 00 00 00
	00		 mov	 BYTE PTR wrmsg_quiet, al

; 211  :                                     // by setting quiet to true
; 212  :     pCAPTCTL = start_capturing( &captmsgs );

  00030	48 8d 4c 24 30	 lea	 rcx, QWORD PTR captmsgs$[rsp]
  00035	e8 00 00 00 00	 call	 start_capturing
  0003a	48 89 44 24 28	 mov	 QWORD PTR pCAPTCTL$[rsp], rax

; 213  : 
; 214  :     /* Execute the Hercules panel command and save the return code */
; 215  :     rc = (int) (uintptr_t) panel_command( cmd );

  0003f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cmd$[rsp]
  00044	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_panel_command
  0004b	ff 10		 call	 QWORD PTR [rax]
  0004d	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 216  : 
; 217  :     /* Pass any captured log messages back to the caller */
; 218  :     *resp = captmsgs.msgs;

  00051	48 8b 44 24 58	 mov	 rax, QWORD PTR resp$[rsp]
  00056	48 8b 4c 24 30	 mov	 rcx, QWORD PTR captmsgs$[rsp]
  0005b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 219  : 
; 220  :     /* Stop capturing */
; 221  :     stop_capturing( pCAPTCTL );

  0005e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCAPTCTL$[rsp]
  00063	e8 00 00 00 00	 call	 stop_capturing

; 222  :     wrmsg_quiet = false;            // reinstate panel output

  00068	c6 05 00 00 00
	00 00		 mov	 BYTE PTR wrmsg_quiet, 0

; 223  : 
; 224  :     /* Return to caller */
; 225  :     return rc;

  0006f	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 226  : }

  00073	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00077	5f		 pop	 rdi
  00078	c3		 ret	 0
panel_command_capture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\logmsg.c
_TEXT	SEGMENT
vl$ = 32
fmt$ = 64
logmsg	PROC

; 523  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 524  :     va_list   vl;
; 525  :     va_start( vl, fmt );

  00018	48 8d 44 24 48	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0001d	48 89 44 24 20	 mov	 QWORD PTR vl$[rsp], rax

; 526  :     vflogmsg( WRMSG_NORMAL, stdout, fmt, vl );

  00022	b9 01 00 00 00	 mov	 ecx, 1
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0002d	4c 8b 4c 24 20	 mov	 r9, QWORD PTR vl$[rsp]
  00032	4c 8b 44 24 40	 mov	 r8, QWORD PTR fmt$[rsp]
  00037	48 8b d0	 mov	 rdx, rax
  0003a	b1 03		 mov	 cl, 3
  0003c	e8 00 00 00 00	 call	 vflogmsg

; 527  : }

  00041	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00045	c3		 ret	 0
logmsg	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\logmsg.c
_TEXT	SEGMENT
vl$ = 64
filename$ = 96
line$ = 104
func$ = 112
panel$ = 120
f$ = 128
fmt$ = 136
fwritemsg PROC

; 516  : {

$LN3:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 517  :     va_list   vl;
; 518  :     va_start( vl, fmt );

  00017	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0001f	48 89 44 24 40	 mov	 QWORD PTR vl$[rsp], rax

; 519  :     vfwritemsg( panel, f, filename, line, func, fmt, vl );

  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR vl$[rsp]
  00029	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0002e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  00036	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0003b	48 8b 44 24 70	 mov	 rax, QWORD PTR func$[rsp]
  00040	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00045	44 8b 4c 24 68	 mov	 r9d, DWORD PTR line$[rsp]
  0004a	4c 8b 44 24 60	 mov	 r8, QWORD PTR filename$[rsp]
  0004f	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR f$[rsp]
  00057	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR panel$[rsp]
  0005c	e8 00 00 00 00	 call	 vfwritemsg

; 520  : }

  00061	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00065	c3		 ret	 0
fwritemsg ENDP
_TEXT	ENDS
END
