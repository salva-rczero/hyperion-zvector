; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	local_verbose
PUBLIC	copy_verbose
PUBLIC	absvalid
PUBLIC	expert
PUBLIC	tran_ascii
PUBLIC	debug
_BSS	SEGMENT
local_verbose DD 01H DUP (?)
copy_verbose DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	din:QWORD
COMM	sfn:QWORD
_DATA	ENDS
_BSS	SEGMENT
absvalid DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	argdsn:QWORD
_DATA	ENDS
_BSS	SEGMENT
expert	DD	01H DUP (?)
tran_ascii DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
debug	DD	01H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
VOL1_KEYA DB	056H
	DB	04fH
	DB	04cH
	DB	031H
VOL1_KEY DB	0e5H
	DB	0d6H
	DB	0d3H
	DB	0f1H
IPL1_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f1H
IPL2_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f2H
iplpsw	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
iplccw1	DB	06H
	DB	00H
	DB	03aH
	DB	098H
	DB	060H
	DB	00H
	DB	00H
	DB	060H
iplccw2	DB	08H
	DB	00H
	DB	03aH
	DB	098H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
noiplpsw DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0fH
noiplccw1 DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
noiplccw2 DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
ipl2data DB	07H
	DB	00H
	DB	03aH
	DB	0b8H
	DB	040H
	DB	00H
	DB	00H
	DB	06H
	DB	031H
	DB	00H
	DB	03aH
	DB	0beH
	DB	040H
	DB	00H
	DB	00H
	DB	05H
	DB	08H
	DB	00H
	DB	03aH
	DB	0a0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	06H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	00H
	DB	07fH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	04H
CONST	ENDS
PUBLIC	showhelp
PUBLIC	parsecmd
PUBLIC	sayext
PUBLIC	showf1
PUBLIC	fbcopy
PUBLIC	makext
PUBLIC	getlabel
PUBLIC	getF1dscb
PUBLIC	getF3dscb
PUBLIC	getF4dscb
PUBLIC	dadsm_setup
PUBLIC	main
EXTRN	__imp__errno:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_exit:PROC
EXTRN	__imp_atoi:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_ferror:PROC
EXTRN	__imp_fopen:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_strlcat:PROC
EXTRN	__imp_initialize_utility:PROC
EXTRN	__imp_string_to_upper:PROC
EXTRN	__imp_convert_to_ebcdic:PROC
EXTRN	__imp_make_asciiz:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_w32_fwrite:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_fclose:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_data_dump:PROC
EXTRN	__imp_read_block:PROC
EXTRN	__imp_search_key_equal:PROC
EXTRN	__imp_convert_tt:PROC
EXTRN	__imp_open_ckd_image:PROC
EXTRN	__imp_close_ckd_image:PROC
EXTRN	__imp_set_verbose_util:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
$SG159715 DB	01H DUP (?)
	ALIGN	4

$SG159767 DB	01H DUP (?)
	ALIGN	4

$SG159927 DB	01H DUP (?)
	ALIGN	4

$SG159928 DB	01H DUP (?)
	ALIGN	4

$SG160564 DB	01H DUP (?)
	ALIGN	4

$SG160569 DB	01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$showhelp DD imagerel $LN9
	DD	imagerel $LN9+414
	DD	imagerel $unwind$showhelp
$pdata$parsecmd DD imagerel $LN46
	DD	imagerel $LN46+3692
	DD	imagerel $unwind$parsecmd
$pdata$sayext DD imagerel $LN6
	DD	imagerel $LN6+763
	DD	imagerel $unwind$sayext
$pdata$showf1 DD imagerel $LN26
	DD	imagerel $LN26+3159
	DD	imagerel $unwind$showf1
$pdata$fbcopy DD imagerel $LN46
	DD	imagerel $LN46+4393
	DD	imagerel $unwind$fbcopy
$pdata$makext DD imagerel $LN4
	DD	imagerel $LN4+717
	DD	imagerel $unwind$makext
$pdata$getlabel DD imagerel $LN7
	DD	imagerel $LN7+514
	DD	imagerel $unwind$getlabel
$pdata$getF1dscb DD imagerel $LN13
	DD	imagerel $LN13+1447
	DD	imagerel $unwind$getF1dscb
$pdata$getF3dscb DD imagerel $LN9
	DD	imagerel $LN9+1001
	DD	imagerel $unwind$getF3dscb
$pdata$getF4dscb DD imagerel $LN12
	DD	imagerel $LN12+1611
	DD	imagerel $unwind$getF4dscb
$pdata$dadsm_setup DD imagerel $LN15
	DD	imagerel $LN15+1167
	DD	imagerel $unwind$dadsm_setup
$pdata$main DD	imagerel $LN24
	DD	imagerel $LN24+1851
	DD	imagerel $unwind$main
pdata	ENDS
_DATA	SEGMENT
$SG159716 DB	'I', 00H
	ORG $+10
$SG159705 DB	'[-debug] [-expert] [-ascii] image [sf=shadow] [attr] fil'
	DB	'espec', 0aH, 'HHC02660I   -debug    optional - Enables debug '
	DB	'mode, additional debug help appears', 0aH, 00H
	ORG $+2
$SG159743 DB	'-debug', 00H
	ORG $+1
$SG159745 DB	'D', 00H
	ORG $+2
$SG159706 DB	'[-expert] [-ascii] image [sf=shadow] filespec', 0aH, 00H
	ORG $+1
$SG159707 DB	'HHC02660I   -expert   optional - Additional help describ'
	DB	'es expert operands', 0aH, 'HHC02660I   -ascii    optional - t'
	DB	'ranslate output file to ascii, trim trailing blanks', 0aH, 'H'
	DB	'HC02660I   image     required - [path/]filename of dasd image'
	DB	' file (dasd volume)', 0aH, 'HHC02660I   shadow    optional - '
	DB	'[path/]filename of shadow file (note sf=)', 0aH, 00H
	ORG $+1
$SG159710 DB	'HHC02660I   ALL EXPERT FACILITIES ARE EXPERIMENTAL', 0aH
	DB	'HHC02660I   attr      optional - dataset attributes (only use'
	DB	'ful with -abs)', 0aH, 'HHC02660I             attr syntax: [-r'
	DB	'ecfm fb] [-lrecl aa]', 0aH, 'HHC02660I             -recfm des'
	DB	'ignates RECFM, reserved for future support', 0aH, 'HHC02660I '
	DB	'            fb - fixed, blocked (only RECFM currently support'
	DB	'ed)', 0aH, 'HHC02660I             -lrecl designates dataset L'
	DB	'RECL', 0aH, 'HHC02660I             aa - decimal logical recor'
	DB	'd length (default 80)', 0aH, 'HHC02660I                  Bloc'
	DB	'ksize need not be specified; dasdseq handles whatever', 0aH, 'H'
	DB	'HC02660I                  block size comes off the volume.', 0aH
	DB	'HHC02660I   filespec  required (optional sub-operands in the '
	DB	'following order):', 0aH, 'HHC02660I                  [-heads '
	DB	'xx]', 0aH, 'HHC02660I                  [-abs cc hh tt] [...] '
	DB	'[-abs cc hh tt ]', 0aH, 'HHC02660I                  filename', 0aH
	DB	'HHC02660I             When -abs is -not- specified,', 0aH, 'H'
	DB	'HC02660I                  Filename specifies the MVS DSORG=PS'
	DB	' dataset on the volume.', 0aH, 'HHC02660I                  Th'
	DB	'e dasd image volume containing the dataset must have a valid '
	DB	'VTOC', 0aH, 'HHC02660I                  structure, and a F1 D'
	DB	'SCB describing the dataset.', 0aH, 'HHC02660I                '
	DB	'  Specifying -debug will (eventually) display extent informat'
	DB	'ion.', 0aH, 'HHC02660I             When -abs is specified, ea'
	DB	'ch -abs group specifies one dataset extent.', 0aH, 'HHC02660I'
	DB	'                  For multi-extent datasets, -abs groups may '
	DB	'be repeated as needed,', 0aH, 'HHC02660I                  in '
	DB	'the order in which the dataset''s extents occur.', 0aH, 'HHC0'
	DB	'2660I                  A maximum of %d extents are supported.'
	DB	0aH, 'HHC02660I                  No VTOC structure is implied,'
	DB	' a F1 DSCB will not be sought.', 0aH, 'HHC02660I             '
	DB	'     Dasdseq will frequently report ''track not found in exte'
	DB	'nt table''', 0aH, 'HHC02660I                  (along with a m'
	DB	'essage from fbcopy about rc -1 from convert_tt)', 0aH, 'HHC02'
	DB	'660I                  due to potentially missing EOF markers '
	DB	'in the extent, and the', 0aH, 'HHC02660I                  fac'
	DB	't that the F1 DSCB DS1LSTAR field is not valid.', 0aH, 'HHC02'
	DB	'660I                  Check your output file before you panic'
	DB	'.', 0aH, 'HHC02660I                  Fbcopy ignores EOF, in c'
	DB	'ase you are attempting to recovery PDS', 0aH, 'HHC02660I     '
	DB	'             member(s) from a damaged dasd volume, preferring'
	DB	' to wait until', 0aH, 'HHC02660I                  all tracks '
	DB	'in the extent have been processed.', 0aH, 'HHC02660I         '
	DB	'         Tracks containing PDS members may have more than one'
	DB	' EOF per track.', 0aH, 'HHC02660I                  Expect a l'
	DB	'ot of associated manual effort with -abs.', 0aH, 'HHC02660I  '
	DB	'           -heads defines # tracks per cylinder on device;', 0aH
	DB	'HHC02660I             xx - decimal number of heads per cylind'
	DB	'er on device', 0aH, 'HHC02660I                  default xx = '
	DB	'15 (valid for 3380s, 3390s)', 0aH, 'HHC02660I             -ab'
	DB	's indicates the beginning of each extent''s location in terms'
	DB	' of', 0aH, 'HHC02660I                  absolute dasd image lo'
	DB	'cation.', 0aH, 'HHC02660I             cc - decimal cylinder n'
	DB	'umber (relative zero)', 0aH, 'HHC02660I             hh - deci'
	DB	'mal head number (relative zero)', 0aH, 'HHC02660I            '
	DB	' tt - decimal number of tracks in extent', 0aH, 'HHC02660I   '
	DB	'          filename will be the filename of the output file in'
	DB	' the current directory;', 0aH, 'HHC02660I                  ou'
	DB	'tput filename in the same case as the command line filename.', 0aH
	DB	00H
	ORG $+1
$SG159744 DB	'Debug', 00H
	ORG $+2
$SG159711 DB	'HHC02660I   filespec  required - MVS dataset name of DSO'
	DB	'RG=PS dataset, output filename', 0aH, 00H
$SG159750 DB	'-expert', 00H
$SG159714 DB	'HHC02660I Debugging options (at end of dasdseq command)', 0aH
	DB	'HHC02660I   [verbose [x [y [z]]]]', 0aH, 'HHC02660I   verbose'
	DB	'   debug output level (default = 0 when not specified)', 0aH, 'H'
	DB	'HC02660I       x  main program (default = 1 when verbose spec'
	DB	'ified)', 0aH, 'HHC02660I       y  copyfile + showf1', 0aH, 'H'
	DB	'HC02660I       z  dasdutil', 0aH, 'HHC02660I       Higher num'
	DB	'bers produces more output', 00H
	ORG $+2
$SG159717 DB	'HHC02660%s Usage: %s %s%s%s%s', 0aH, 00H
	ORG $+1
$SG159718 DB	'showhelp', 00H
	ORG $+3
$SG159752 DB	'EXPERT', 00H
	ORG $+1
$SG159753 DB	'I', 00H
	ORG $+2
$SG159719 DB	'dasdseq.c', 00H
	ORG $+2
$SG159758 DB	'-ascii', 00H
	ORG $+1
$SG159761 DB	'I', 00H
	ORG $+2
$SG159746 DB	'HHC02672%s %s mode enabled', 0aH, 00H
$SG159769 DB	'D', 00H
	ORG $+2
$SG159747 DB	'parsecmd', 00H
	ORG $+3
$SG159768 DB	'Image', 00H
	ORG $+2
$SG159775 DB	'sf=', 00H
$SG159748 DB	'dasdseq.c', 00H
	ORG $+2
$SG159777 DB	'(s)', 00H
$SG159754 DB	'HHC02672%s %s mode enabled', 0aH, 00H
$SG159779 DB	'D', 00H
	ORG $+2
$SG159755 DB	'parsecmd', 00H
	ORG $+3
$SG159778 DB	'SHADOW', 00H
	ORG $+1
$SG159787 DB	'fb', 00H
	ORG $+1
$SG159756 DB	'dasdseq.c', 00H
	ORG $+2
$SG159784 DB	'-recfm', 00H
	ORG $+1
$SG159789 DB	'FB', 00H
	ORG $+1
$SG159760 DB	'ASCII translation', 00H
	ORG $+2
$SG159791 DB	'D', 00H
	ORG $+2
$SG159762 DB	'HHC02672%s %s mode enabled', 0aH, 00H
$SG159796 DB	'I', 00H
	ORG $+2
$SG159763 DB	'parsecmd', 00H
	ORG $+3
$SG159790 DB	'RECFM', 00H
	ORG $+2
$SG159801 DB	'-lrecl', 00H
	ORG $+1
$SG159805 DB	'D', 00H
	ORG $+2
$SG159764 DB	'dasdseq.c', 00H
	ORG $+2
$SG159810 DB	'-heads', 00H
	ORG $+1
$SG159814 DB	'D', 00H
	ORG $+2
$SG159770 DB	'HHC02673%s %s file%s ''%s''', 0aH, 00H
	ORG $+1
$SG159825 DB	'D', 00H
	ORG $+2
$SG159771 DB	'parsecmd', 00H
	ORG $+3
$SG159804 DB	'LRECL', 00H
	ORG $+2
$SG159830 DB	'S', 00H
	ORG $+2
$SG159772 DB	'dasdseq.c', 00H
	ORG $+2
$SG159836 DB	'D', 00H
	ORG $+2
$SG159780 DB	'HHC02673%s %s file%s ''%s''', 0aH, 00H
	ORG $+1
$SG159842 DB	'D', 00H
	ORG $+2
$SG159781 DB	'parsecmd', 00H
	ORG $+3
$SG159813 DB	'HEADS', 00H
	ORG $+2
$SG159849 DB	'-ascii', 00H
	ORG $+1
$SG159852 DB	'D', 00H
	ORG $+2
$SG159782 DB	'dasdseq.c', 00H
	ORG $+2
$SG159862 DB	'D', 00H
	ORG $+2
$SG159792 DB	'HHC02674%s %s=%s', 0aH, 00H
	ORG $+2
$SG159881 DB	'I', 00H
	ORG $+2
$SG159793 DB	'parsecmd', 00H
	ORG $+3
$SG159848 DB	'ascii', 00H
	ORG $+2
$SG159883 DB	'sayext', 00H
	ORG $+1
$SG159885 DB	'I', 00H
	ORG $+2
$SG159794 DB	'dasdseq.c', 00H
	ORG $+2
$SG159887 DB	'sayext', 00H
	ORG $+1
$SG159889 DB	'I', 00H
	ORG $+2
$SG159795 DB	'-recfm %s', 00H
	ORG $+2
$SG159891 DB	'sayext', 00H
	ORG $+1
$SG159931 DB	'I', 00H
	ORG $+2
$SG159797 DB	'HHC02465%s Invalid argument: %s', 0aH, 00H
	ORG $+3
$SG159926 DB	'(n/a)', 00H
	ORG $+2
$SG159933 DB	'showf1', 00H
	ORG $+1
$SG159936 DB	'.', 00H
	ORG $+2
$SG159798 DB	'parsecmd', 00H
	ORG $+3
$SG159935 DB	'%4.4d', 00H
	ORG $+2
$SG159941 DB	'.', 00H
	ORG $+2
$SG159799 DB	'dasdseq.c', 00H
	ORG $+2
$SG159942 DB	'.%3.3d', 00H
	ORG $+1
$SG159944 DB	'IS', 00H
	ORG $+1
$SG159806 DB	'HHC02675%s %s=%d', 0aH, 00H
	ORG $+2
$SG159946 DB	'PS', 00H
	ORG $+1
$SG159807 DB	'parsecmd', 00H
	ORG $+3
$SG159937 DB	'%3.3d', 00H
	ORG $+2
$SG159948 DB	'DA', 00H
	ORG $+1
$SG159808 DB	'dasdseq.c', 00H
	ORG $+2
$SG159950 DB	'PO', 00H
	ORG $+1
$SG159815 DB	'HHC02675%s %s=%d', 0aH, 00H
	ORG $+2
$SG159952 DB	'VS', 00H
	ORG $+1
$SG159816 DB	'parsecmd', 00H
	ORG $+3
$SG159940 DB	'%4.4d', 00H
	ORG $+2
$SG159954 DB	'??', 00H
	ORG $+1
$SG159817 DB	'dasdseq.c', 00H
	ORG $+2
$SG159819 DB	'-abs', 00H
	ORG $+3
$SG159820 DB	'-abs', 00H
	ORG $+3
$SG159956 DB	'U', 00H
	ORG $+2
$SG159826 DB	'HHC02676%s Absolute CC %d HH %d [%04X%04X] Track %d/%X', 0aH
	DB	00H
$SG159827 DB	'parsecmd', 00H
	ORG $+3
$SG159958 DB	'F', 00H
	ORG $+2
$SG159828 DB	'dasdseq.c', 00H
	ORG $+6
$SG159837 DB	'HHC02677%s %s', 0aH, 00H
	ORG $+1
$SG159851 DB	'ASCII translation', 00H
	ORG $+6
$SG159831 DB	'HHC02494%s Requested number of extents %d exceeds maximu'
	DB	'm %d; utility ends', 0aH, 00H
$SG159960 DB	'V', 00H
	ORG $+2
$SG159832 DB	'parsecmd', 00H
	ORG $+3
$SG159962 DB	'U', 00H
	ORG $+2
$SG159833 DB	'dasdseq.c', 00H
	ORG $+2
$SG159964 DB	'B', 00H
	ORG $+2
$SG159835 DB	'Completed Format 1 DSCB:', 00H
	ORG $+3
$SG159966 DB	'S', 00H
	ORG $+2
$SG159838 DB	'parsecmd', 00H
	ORG $+3
$SG159968 DB	'A', 00H
	ORG $+2
$SG159839 DB	'dasdseq.c', 00H
	ORG $+2
$SG159970 DB	'M', 00H
	ORG $+2
$SG159843 DB	'HHC02678%s Dataset ''%s''', 0aH, 00H
	ORG $+3
$SG159972 DB	'T', 00H
	ORG $+2
$SG159844 DB	'parsecmd', 00H
	ORG $+3
$SG159973 DB	'I', 00H
	ORG $+2
$SG159845 DB	'dasdseq.c', 00H
	ORG $+2
$SG159975 DB	'showf1', 00H
	ORG $+1
$SG159977 DB	'I', 00H
	ORG $+2
$SG159853 DB	'HHC02672%s %s mode enabled', 0aH, 00H
$SG159981 DB	'I', 00H
	ORG $+2
$SG159854 DB	'parsecmd', 00H
	ORG $+3
$SG159979 DB	'showf1', 00H
	ORG $+1
$SG159985 DB	'I', 00H
	ORG $+2
$SG159855 DB	'dasdseq.c', 00H
	ORG $+2
$SG159983 DB	'showf1', 00H
	ORG $+1
$SG159990 DB	'I', 00H
	ORG $+2
$SG159857 DB	'verbose', 00H
$SG159863 DB	'HHC02679%s Utility verbose %d', 0aH, 00H
	ORG $+1
$SG159864 DB	'parsecmd', 00H
	ORG $+3
$SG159987 DB	'showf1', 00H
	ORG $+1
$SG159996 DB	'I', 00H
	ORG $+2
$SG159865 DB	'dasdseq.c', 00H
	ORG $+2
$SG159992 DB	'showf1', 00H
	ORG $+1
$SG160001 DB	'I', 00H
	ORG $+2
$SG159882 DB	'HHC02481%s      EXTENT --begin-- ---end---', 0aH, 00H
$SG160006 DB	'I', 00H
	ORG $+2
$SG159884 DB	'dasdseq.c', 00H
	ORG $+2
$SG159998 DB	'showf1', 00H
	ORG $+1
$SG160010 DB	'I', 00H
	ORG $+2
$SG159886 DB	'HHC02482%s TYPE NUMBER CCCC HHHH CCCC HHHH', 0aH, 00H
$SG160064 DB	'D', 00H
	ORG $+2
$SG159888 DB	'dasdseq.c', 00H
	ORG $+2
$SG160003 DB	'showf1', 00H
	ORG $+1
$SG160072 DB	'D', 00H
	ORG $+2
$SG159890 DB	'HHC02483%s   %02X   %02X   %04X %04X %04X %04X', 0aH, 00H
$SG159892 DB	'dasdseq.c', 00H
	ORG $+2
$SG160008 DB	'showf1', 00H
	ORG $+1
$SG160077 DB	'D', 00H
	ORG $+2
$SG159930 DB	'Format 1 DSCB:', 00H
	ORG $+1
$SG159932 DB	'HHC02681%s %s', 0aH, 00H
	ORG $+1
$SG159934 DB	'dasdseq.c', 00H
	ORG $+2
$SG160012 DB	'showf1', 00H
	ORG $+1
$SG160082 DB	'D', 00H
	ORG $+2
$SG159974 DB	'HHC02485%s Dataset %s on volume %s sequence %d', 0aH, 00H
$SG159976 DB	'dasdseq.c', 00H
	ORG $+2
$SG160066 DB	'fbcopy', 00H
	ORG $+1
$SG160087 DB	'D', 00H
	ORG $+2
$SG159978 DB	'HHC02486%s Creation Date: %s; Expiration Date: %s', 0aH, 00H
	ORG $+1
$SG160092 DB	'I', 00H
	ORG $+2
$SG159980 DB	'dasdseq.c', 00H
	ORG $+2
$SG160074 DB	'fbcopy', 00H
	ORG $+1
$SG160099 DB	'E', 00H
	ORG $+2
$SG159982 DB	'HHC02487%s Dsorg=%s recfm=%s lrecl=%d blksize=%d', 0aH, 00H
	ORG $+2
$SG160079 DB	'fbcopy', 00H
	ORG $+1
$SG160106 DB	'I', 00H
	ORG $+2
$SG159984 DB	'dasdseq.c', 00H
	ORG $+2
$SG160084 DB	'fbcopy', 00H
	ORG $+1
$SG160110 DB	'I', 00H
	ORG $+2
$SG159986 DB	'HHC02488%s System code %s', 0aH, 00H
	ORG $+1
$SG160117 DB	'E', 00H
	ORG $+2
$SG159988 DB	'dasdseq.c', 00H
	ORG $+2
$SG160089 DB	'fbcopy', 00H
	ORG $+1
$SG160124 DB	'I', 00H
	ORG $+2
$SG159991 DB	'HHC02680%s Dataset has %d extent(s):', 0aH, 00H
	ORG $+2
$SG159993 DB	'dasdseq.c', 00H
	ORG $+2
$SG160094 DB	'fbcopy', 00H
	ORG $+1
$SG160129 DB	'I', 00H
	ORG $+2
$SG159995 DB	'Extent Information:', 00H
$SG160137 DB	'E', 00H
	ORG $+2
$SG159997 DB	'HHC02681%s %s', 0aH, 00H
	ORG $+1
$SG159999 DB	'dasdseq.c', 00H
	ORG $+2
$SG160101 DB	'fbcopy', 00H
	ORG $+1
$SG160144 DB	'I', 00H
	ORG $+2
$SG160000 DB	'     EXTENT --begin-- ---end---', 00H
$SG160002 DB	'HHC02681%s %s', 0aH, 00H
	ORG $+1
$SG160004 DB	'dasdseq.c', 00H
	ORG $+2
$SG160108 DB	'fbcopy', 00H
	ORG $+1
$SG160150 DB	'EOF', 00H
$SG160005 DB	'TYPE NUMBER CCCC HHHH CCCC HHHH', 00H
$SG160007 DB	'HHC02681%s %s', 0aH, 00H
	ORG $+1
$SG160009 DB	'dasdseq.c', 00H
	ORG $+2
$SG160112 DB	'fbcopy', 00H
	ORG $+1
$SG160151 DB	'I', 00H
	ORG $+2
$SG160011 DB	'HHC02682%s   %02X   %02X   %04X %04X %04X %04X', 0aH, 00H
$SG160013 DB	'dasdseq.c', 00H
	ORG $+2
$SG160119 DB	'fbcopy', 00H
	ORG $+1
$SG160159 DB	'I', 00H
	ORG $+2
$SG160063 DB	'absvalid', 00H
	ORG $+3
$SG160081 DB	'lrecl', 00H
	ORG $+2
$SG160126 DB	'fbcopy', 00H
	ORG $+1
$SG160164 DB	'I', 00H
	ORG $+2
$SG160065 DB	'HHC02677%s %s', 0aH, 00H
	ORG $+1
$SG160067 DB	'dasdseq.c', 00H
	ORG $+2
$SG160071 DB	'zdsn', 00H
	ORG $+3
$SG160131 DB	'fbcopy', 00H
	ORG $+1
$SG160170 DB	'I', 00H
	ORG $+2
$SG160073 DB	'HHC02674%s %s=%s', 0aH, 00H
	ORG $+2
$SG160139 DB	'fbcopy', 00H
	ORG $+1
$SG160175 DB	'I', 00H
	ORG $+2
$SG160075 DB	'dasdseq.c', 00H
	ORG $+2
$SG160143 DB	'End of', 00H
	ORG $+1
$SG160180 DB	'I', 00H
	ORG $+2
$SG160076 DB	'num_extents', 00H
$SG160187 DB	'I', 00H
	ORG $+2
$SG160078 DB	'HHC02675%s %s=%d', 0aH, 00H
	ORG $+2
$SG160146 DB	'fbcopy', 00H
	ORG $+1
$SG160191 DB	'I', 00H
	ORG $+2
$SG160080 DB	'dasdseq.c', 00H
	ORG $+2
$SG160153 DB	'fbcopy', 00H
	ORG $+1
$SG160198 DB	'I', 00H
	ORG $+2
$SG160083 DB	'HHC02675%s %s=%d', 0aH, 00H
	ORG $+2
$SG160161 DB	'fbcopy', 00H
	ORG $+1
$SG160204 DB	'E', 00H
	ORG $+2
$SG160085 DB	'dasdseq.c', 00H
	ORG $+2
$SG160166 DB	'fbcopy', 00H
	ORG $+1
$SG160228 DB	'S', 00H
	ORG $+2
$SG160086 DB	'Format 1 DSCB:', 00H
	ORG $+1
$SG160088 DB	'HHC02677%s %s', 0aH, 00H
	ORG $+1
$SG160090 DB	'dasdseq.c', 00H
	ORG $+6
$SG160100 DB	'HHC02489%s %s: unable to allocate ASCII buffer', 0aH, 00H
$SG160105 DB	'DS1LSTAR indicates EOF', 00H
	ORG $+1
$SG160093 DB	'HHC02683%s DS1LSTAR[%02X%02X%02X] lstartrack(%d) lstarre'
	DB	'c(%d) lstarvalid(%d)', 0aH, 00H
	ORG $+2
$SG160095 DB	'dasdseq.c', 00H
	ORG $+2
$SG160172 DB	'fbcopy', 00H
	ORG $+1
$SG160249 DB	'I', 00H
	ORG $+2
$SG160098 DB	'fbcopy()', 00H
	ORG $+3
$SG160177 DB	'fbcopy', 00H
	ORG $+1
$SG160254 DB	'E', 00H
	ORG $+2
$SG160102 DB	'dasdseq.c', 00H
	ORG $+2
$SG160182 DB	'fbcopy', 00H
	ORG $+1
$SG160259 DB	'E', 00H
	ORG $+2
$SG160107 DB	'HHC02681%s %s', 0aH, 00H
	ORG $+1
$SG160109 DB	'dasdseq.c', 00H
	ORG $+2
$SG160189 DB	'fbcopy', 00H
	ORG $+1
$SG160265 DB	'I', 00H
	ORG $+2
$SG160111 DB	'HHC02684%s DS1LSTAR[%02X%02X%02X] track(%02X) record(%02'
	DB	'X)', 0aH, 00H
$SG160299 DB	'I', 00H
	ORG $+2
$SG160113 DB	'dasdseq.c', 00H
	ORG $+2
$SG160193 DB	'fbcopy', 00H
	ORG $+1
$SG160304 DB	'I', 00H
	ORG $+2
$SG160116 DB	'fbcopy()', 00H
	ORG $+3
$SG160200 DB	'fbcopy', 00H
	ORG $+1
$SG160309 DB	'E', 00H
	ORG $+2
$SG160118 DB	'HHC02490%s %s: convert_tt() track %5.5d/x''%04X'', rc %d'
	DB	0aH, 00H
$SG160120 DB	'dasdseq.c', 00H
	ORG $+2
$SG160206 DB	'fbcopy', 00H
	ORG $+1
$SG160315 DB	'E', 00H
	ORG $+2
$SG160125 DB	'HHC02685%s Convert TT %5.5d/x''%04X'' CCHH[%04X%04X]', 0aH
	DB	00H
$SG160321 DB	'I', 00H
	ORG $+2
$SG160127 DB	'dasdseq.c', 00H
	ORG $+6
$SG160134 DB	', error reading ''%s''', 00H
	ORG $+3
$SG160130 DB	'HHC02686%s Reading track %5.5d/x''%04X'' record %d/x''%X'
	DB	''' CCHHR[%04X%04X%02X]', 0aH, 00H
$SG160327 DB	'E', 00H
	ORG $+2
$SG160132 DB	'dasdseq.c', 00H
	ORG $+2
$SG160230 DB	'makext', 00H
	ORG $+1
$SG160332 DB	'I', 00H
	ORG $+2
$SG160135 DB	'read_block()', 00H
	ORG $+3
$SG160136 DB	'fbcopy()', 00H
	ORG $+3
$SG160367 DB	'I', 00H
	ORG $+2
$SG160138 DB	'HHC02477%s In %s: function %s rc %d%s', 0aH, 00H
	ORG $+1
$SG160140 DB	'dasdseq.c', 00H
	ORG $+2
$SG160373 DB	'I', 00H
	ORG $+2
$SG160145 DB	'HHC02687%s %s track %5.5d/x''%04X'' rec %d', 0aH, 00H
	ORG $+2
$SG160378 DB	'I', 00H
	ORG $+2
$SG160147 DB	'dasdseq.c', 00H
	ORG $+2
$SG160383 DB	'E', 00H
	ORG $+2
$SG160152 DB	'HHC02687%s %s track %5.5d/x''%04X'' rec %d', 0aH, 00H
	ORG $+2
$SG160389 DB	'I', 00H
	ORG $+2
$SG160154 DB	'dasdseq.c', 00H
	ORG $+2
$SG160397 DB	'E', 00H
	ORG $+2
$SG160158 DB	'Ignoring -abs EOF', 00H
	ORG $+2
$SG160404 DB	'E', 00H
	ORG $+2
$SG160160 DB	'HHC02681%s %s', 0aH, 00H
	ORG $+1
$SG160162 DB	'dasdseq.c', 00H
	ORG $+2
$SG160410 DB	'I', 00H
	ORG $+2
$SG160165 DB	'HHC02688%s read %d bytes', 0aH, 00H
	ORG $+2
$SG160415 DB	'1', 00H
	ORG $+2
$SG160167 DB	'dasdseq.c', 00H
	ORG $+2
$SG160416 DB	'1', 00H
	ORG $+2
$SG160169 DB	'BEGIN OF BUFFER DUMP >', 00H
	ORG $+1
$SG160171 DB	'HHC02681%s %s', 0aH, 00H
	ORG $+1
$SG160173 DB	'dasdseq.c', 00H
	ORG $+2
$SG160418 DB	'E', 00H
	ORG $+2
$SG160174 DB	'< END OF BUFFER DUMP', 00H
	ORG $+3
$SG160176 DB	'HHC02681%s %s', 0aH, 00H
	ORG $+1
$SG160178 DB	'dasdseq.c', 00H
	ORG $+2
$SG160447 DB	'I', 00H
	ORG $+2
$SG160181 DB	'HHC02689%s offset %d length %d rec %d', 0aH, 00H
	ORG $+1
$SG160183 DB	'dasdseq.c', 00H
	ORG $+2
$SG160455 DB	'E', 00H
	ORG $+2
$SG160188 DB	'HHC02690%s buffer offset %d rec %d:', 0aH, 00H
	ORG $+3
$SG160190 DB	'dasdseq.c', 00H
	ORG $+2
$SG160462 DB	'E', 00H
	ORG $+2
$SG160192 DB	'HHC02691%s ascii> ''%s''', 0aH, 00H
$SG160194 DB	'dasdseq.c', 00H
	ORG $+2
$SG160468 DB	'I', 00H
	ORG $+2
$SG160197 DB	'EBCDIC buffer:', 00H
	ORG $+1
$SG160199 DB	'HHC02681%s %s', 0aH, 00H
	ORG $+1
$SG160201 DB	'dasdseq.c', 00H
	ORG $+2
$SG160473 DB	'3', 00H
	ORG $+2
$SG160203 DB	'fwrite()', 00H
	ORG $+3
$SG160474 DB	'3', 00H
	ORG $+2
$SG160205 DB	'HHC02468%s File %s; %s error: %s', 0aH, 00H
	ORG $+2
$SG160476 DB	'E', 00H
	ORG $+2
$SG160207 DB	'dasdseq.c', 00H
	ORG $+2
$SG160506 DB	'E', 00H
	ORG $+2
$SG160227 DB	'makext()', 00H
	ORG $+7
$SG160231 DB	'dasdseq.c', 00H
	ORG $+6
$SG160250 DB	'HHC02661%s Reading volume label...', 0aH, 00H
	ORG $+4
$SG160229 DB	'HHC02491%s %s: extent number parameter invalid %d; utili'
	DB	'ty ends', 0aH, 00H
	ORG $+3
$SG160512 DB	'I', 00H
	ORG $+2
$SG160251 DB	'getlabel', 00H
	ORG $+3
$SG160520 DB	'E', 00H
	ORG $+2
$SG160252 DB	'dasdseq.c', 00H
	ORG $+2
$SG160526 DB	'E', 00H
	ORG $+2
$SG160255 DB	'HHC02663%s Error reading volume label, rc %d', 0aH, 00H
	ORG $+2
$SG160256 DB	'getlabel', 00H
	ORG $+3
$SG160554 DB	'D', 00H
	ORG $+2
$SG160257 DB	'dasdseq.c', 00H
	ORG $+6
$SG160264 DB	'Volume label:', 00H
	ORG $+2
$SG160266 DB	'HHC02681%s %s', 0aH, 00H
	ORG $+1
$SG160305 DB	'HHC02666%s Reading VTOC F4 DSCB...', 0aH, 00H
	ORG $+4
$SG160260 DB	'HHC02664%s Error: volume label is %d bytes long, not 80 '
	DB	'bytes long', 0aH, 00H
$SG160565 DB	'I', 00H
	ORG $+2
$SG160261 DB	'getlabel', 00H
	ORG $+3
$SG160570 DB	'I', 00H
	ORG $+2
$SG160262 DB	'dasdseq.c', 00H
	ORG $+2
$SG160579 DB	'S', 00H
	ORG $+2
$SG160267 DB	'getlabel', 00H
	ORG $+3
$SG160583 DB	'PS', 00H
	ORG $+1
$SG160268 DB	'dasdseq.c', 00H
	ORG $+2
$SG160584 DB	'S', 00H
	ORG $+2
$SG160300 DB	'HHC02665%s VTOC F4 at cyl %d head %d rec %d', 0aH, 00H
	ORG $+3
$SG160301 DB	'getF4dscb', 00H
	ORG $+2
$SG160589 DB	'wb', 00H
	ORG $+1
$SG160302 DB	'dasdseq.c', 00H
	ORG $+2
$SG160590 DB	'w', 00H
	ORG $+2
$SG160306 DB	'getF4dscb', 00H
	ORG $+2
$SG160593 DB	'E', 00H
	ORG $+2
$SG160307 DB	'dasdseq.c', 00H
	ORG $+2
$SG160598 DB	'I', 00H
	ORG $+2
$SG160310 DB	'HHC02667%s Error reading F4 DSCB, rc %d', 0aH, 00H
	ORG $+3
$SG160604 DB	'E', 00H
	ORG $+2
$SG160311 DB	'getF4dscb', 00H
	ORG $+2
$SG160608 DB	'I', 00H
	ORG $+2
$SG160312 DB	'dasdseq.c', 00H
	ORG $+2
$SG160613 DB	'I', 00H
	ORG $+2
$SG160316 DB	'HHC02668%s Erroneous key length %d or data length %d', 0aH
	DB	00H
	ORG $+2
$SG160317 DB	'getF4dscb', 00H
	ORG $+2
$SG160619 DB	'I', 00H
	ORG $+2
$SG160318 DB	'dasdseq.c', 00H
	ORG $+2
$SG160625 DB	'I', 00H
	ORG $+2
$SG160320 DB	'F4 DSCB:', 00H
	ORG $+7
$SG160322 DB	'HHC02681%s %s', 0aH, 00H
	ORG $+1
$SG160323 DB	'getF4dscb', 00H
	ORG $+6
$SG160324 DB	'dasdseq.c', 00H
	ORG $+6
$SG160328 DB	'HHC02670%s VTOC format id byte invalid (DS4IDFMT) %2.2X,'
	DB	0aH, 'HHC02670E VTOC key invalid, or multi-extent VTOC', 0aH, 00H
	ORG $+5
$SG160329 DB	'getF4dscb', 00H
	ORG $+6
$SG160330 DB	'dasdseq.c', 00H
	ORG $+6
$SG160333 DB	'HHC02671%s VTOC start CCHH=%2.2X%2.2X %2.2X%2.2X end CCH'
	DB	'H=%2.2X%2.2X %2.2X%2.2X', 0aH, 00H
	ORG $+7
$SG160334 DB	'getF4dscb', 00H
	ORG $+6
$SG160335 DB	'dasdseq.c', 00H
	ORG $+6
$SG160368 DB	'HHC02692%s searching VTOC for ''%s''', 0aH, 00H
	ORG $+4
$SG160369 DB	'getF1dscb', 00H
	ORG $+6
$SG160370 DB	'dasdseq.c', 00H
	ORG $+6
$SG160374 DB	'HHC02693%s search_key_equal rc %d', 0aH, 00H
	ORG $+5
$SG160375 DB	'getF1dscb', 00H
	ORG $+6
$SG160376 DB	'dasdseq.c', 00H
	ORG $+2
$SG160377 DB	'KEY:', 00H
	ORG $+7
$SG160379 DB	'HHC02681%s %s', 0aH, 00H
	ORG $+1
$SG160380 DB	'getF1dscb', 00H
	ORG $+6
$SG160381 DB	'dasdseq.c', 00H
	ORG $+6
$SG160384 DB	'HHC02476%s Dataset %s not found', 0aH, 00H
	ORG $+7
$SG160385 DB	'getF1dscb', 00H
	ORG $+6
$SG160386 DB	'dasdseq.c', 00H
	ORG $+6
$SG160388 DB	'reading Format 1 DSCB', 00H
	ORG $+2
$SG160390 DB	'HHC02681%s %s', 0aH, 00H
	ORG $+1
$SG160391 DB	'getF1dscb', 00H
	ORG $+6
$SG160392 DB	'dasdseq.c', 00H
	ORG $+6
$SG160394 DB	', attempting to read Format 1 DSCB', 00H
	ORG $+5
$SG160395 DB	'read_block()', 00H
	ORG $+3
$SG160396 DB	'getF1dscb()', 00H
	ORG $+4
$SG160398 DB	'HHC02477%s In %s: function %s rc %d%s', 0aH, 00H
	ORG $+1
$SG160399 DB	'getF1dscb', 00H
	ORG $+6
$SG160400 DB	'dasdseq.c', 00H
	ORG $+6
$SG160403 DB	' received for Format 1 DSCB', 00H
	ORG $+4
$SG160405 DB	'HHC02478%s Length invalid for KEY %d or DATA %d%s', 0aH, 00H
	ORG $+5
$SG160406 DB	'getF1dscb', 00H
	ORG $+6
$SG160407 DB	'dasdseq.c', 00H
	ORG $+6
$SG160409 DB	'Format 1 DSCB:', 00H
	ORG $+1
$SG160411 DB	'HHC02681%s %s', 0aH, 00H
	ORG $+1
$SG160412 DB	'getF1dscb', 00H
	ORG $+6
$SG160413 DB	'dasdseq.c', 00H
	ORG $+6
$SG160417 DB	'getF1dscb()', 00H
$SG160556 DB	'main', 00H
	ORG $+7
$SG160419 DB	'HHC02479%s In %s: x''F%s'' expected for DS%sIDFMT, recei'
	DB	'ved x''%02X''', 0aH, 00H
	ORG $+5
$SG160420 DB	'getF1dscb', 00H
	ORG $+6
$SG160421 DB	'dasdseq.c', 00H
	ORG $+6
$SG160448 DB	'HHC02662%s reading Format 3 DSCB - CCHHR %04X%04X%02X', 0aH
	DB	00H
	ORG $+1
$SG160449 DB	'getF3dscb', 00H
	ORG $+6
$SG160450 DB	'dasdseq.c', 00H
	ORG $+6
$SG160452 DB	', attempting to read Format 3 DSCB', 00H
	ORG $+5
$SG160453 DB	'read_block()', 00H
	ORG $+3
$SG160454 DB	'getF3dscb()', 00H
	ORG $+4
$SG160456 DB	'HHC02477%s In %s: function %s rc %d%s', 0aH, 00H
	ORG $+1
$SG160457 DB	'getF3dscb', 00H
	ORG $+6
$SG160458 DB	'dasdseq.c', 00H
	ORG $+6
$SG160461 DB	' received for Format 3 DSCB', 00H
	ORG $+4
$SG160463 DB	'HHC02478%s Length invalid for KEY %d or DATA %d%s', 0aH, 00H
	ORG $+5
$SG160464 DB	'getF3dscb', 00H
	ORG $+6
$SG160465 DB	'dasdseq.c', 00H
	ORG $+6
$SG160467 DB	'Format 3 DSCB:', 00H
	ORG $+1
$SG160469 DB	'HHC02681%s %s', 0aH, 00H
	ORG $+1
$SG160470 DB	'getF3dscb', 00H
	ORG $+6
$SG160471 DB	'dasdseq.c', 00H
	ORG $+6
$SG160475 DB	'getF3dscb()', 00H
$SG160567 DB	'main', 00H
	ORG $+7
$SG160477 DB	'HHC02479%s In %s: x''F%s'' expected for DS%sIDFMT, recei'
	DB	'ved x''%02X''', 0aH, 00H
	ORG $+5
$SG160478 DB	'getF3dscb', 00H
	ORG $+6
$SG160479 DB	'dasdseq.c', 00H
	ORG $+6
$SG160505 DB	'dadsm_setup()', 00H
	ORG $+2
$SG160550 DB	'Sequential DSN unload', 00H
	ORG $+2
$SG160507 DB	'HHC02480%s In %s: extent slots exhausted; maximum suppor'
	DB	'ted is %d', 0aH, 00H
	ORG $+5
$SG160508 DB	'dadsm_setup', 00H
	ORG $+4
$SG160509 DB	'dasdseq.c', 00H
	ORG $+6
$SG160513 DB	'HHC02669%s %d extent(s) found; all are in Format 1 DSCB', 0aH
	DB	00H
	ORG $+7
$SG160514 DB	'dadsm_setup', 00H
	ORG $+4
$SG160515 DB	'dasdseq.c', 00H
	ORG $+6
$SG160519 DB	'dadsm_setup()', 00H
	ORG $+2
$SG160551 DB	'dasdseq', 00H
$SG160521 DB	'HHC02480%s In %s: extent slots exhausted; maximum suppor'
	DB	'ted is %d', 0aH, 00H
	ORG $+5
$SG160522 DB	'dadsm_setup', 00H
	ORG $+4
$SG160523 DB	'dasdseq.c', 00H
	ORG $+6
$SG160525 DB	'dadsm_setup()', 00H
	ORG $+2
$SG160555 DB	'HHC02677%s %s', 0aH, 00H
	ORG $+1
$SG160572 DB	'main', 00H
	ORG $+3
$SG160527 DB	'HHC02480%s In %s: extent slots exhausted; maximum suppor'
	DB	'ted is %d', 0aH, 00H
	ORG $+5
$SG160528 DB	'dadsm_setup', 00H
	ORG $+4
$SG160529 DB	'dasdseq.c', 00H
	ORG $+6
$SG160553 DB	'DEBUG enabled', 00H
	ORG $+2
$SG160557 DB	'dasdseq.c', 00H
	ORG $+6
$SG160566 DB	'HHC02484%s %s', 0aH, 00H
	ORG $+1
$SG160568 DB	'dasdseq.c', 00H
	ORG $+6
$SG160571 DB	'HHC02484%s %s', 0aH, 00H
	ORG $+1
$SG160573 DB	'dasdseq.c', 00H
	ORG $+2
$SG160578 DB	'F[B]', 00H
	ORG $+7
$SG160580 DB	'HHC02472%s Dataset is not RECFM %s; utility ends', 0aH, 00H
	ORG $+2
$SG160581 DB	'main', 00H
	ORG $+7
$SG160582 DB	'dasdseq.c', 00H
	ORG $+6
$SG160585 DB	'HHC02473%s Dataset is not DSORG %s; utility ends', 0aH, 00H
	ORG $+2
$SG160586 DB	'main', 00H
	ORG $+7
$SG160587 DB	'dasdseq.c', 00H
	ORG $+6
$SG160592 DB	'fopen()', 00H
$SG160594 DB	'HHC02468%s File %s; %s error: %s', 0aH, 00H
	ORG $+2
$SG160595 DB	'main', 00H
	ORG $+7
$SG160596 DB	'dasdseq.c', 00H
	ORG $+6
$SG160599 DB	'HHC02694%s writing %s', 0aH, 00H
	ORG $+1
$SG160600 DB	'main', 00H
	ORG $+3
$SG160601 DB	'dasdseq.c', 00H
	ORG $+6
$SG160605 DB	'HHC02474%s Error processing %s', 0aH, 00H
$SG160606 DB	'main', 00H
	ORG $+3
$SG160607 DB	'dasdseq.c', 00H
	ORG $+6
$SG160609 DB	'HHC02475%s Records written to %s: %d', 0aH, 00H
	ORG $+2
$SG160610 DB	'main', 00H
	ORG $+3
$SG160611 DB	'dasdseq.c', 00H
	ORG $+6
$SG160614 DB	'HHC02695%s Closed output file %s', 0aH, 00H
	ORG $+2
$SG160615 DB	'main', 00H
	ORG $+7
$SG160616 DB	'dasdseq.c', 00H
	ORG $+6
$SG160618 DB	'CIFBLK:', 00H
$SG160620 DB	'HHC02681%s %s', 0aH, 00H
	ORG $+1
$SG160621 DB	'main', 00H
	ORG $+3
$SG160622 DB	'dasdseq.c', 00H
	ORG $+6
$SG160624 DB	'Closed image file', 00H
	ORG $+6
$SG160626 DB	'HHC02681%s %s', 0aH, 00H
	ORG $+1
$SG160627 DB	'main', 00H
	ORG $+3
$SG160628 DB	'dasdseq.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:main
	DD	01bH
	DD	0722H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:getF4dscb
	DD	027H
	DD	0631H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:getF1dscb
	DD	027H
	DD	058dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:fbcopy
	DD	027H
	DD	0110fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:showf1
	DD	022H
	DD	0c3dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:parsecmd
	DD	024H
	DD	0e54H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:showhelp
	DD	01cH
	DD	0186H
voltbl	ENDS
xdata	SEGMENT
$unwind$showhelp DD 022419H
	DD	02ef0112H
	DD	imagerel __GSHandlerCheck
	DD	01760H
$unwind$parsecmd DD 022c19H
	DD	02d011aH
	DD	imagerel __GSHandlerCheck
	DD	0150H
$unwind$sayext DD 021001H
	DD	0150110H
$unwind$showf1 DD 042a19H
	DD	0290118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0138H
$unwind$fbcopy DD 042f19H
	DD	0d7011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	06a0H
$unwind$makext DD 011601H
	DD	0c216H
$unwind$getlabel DD 031501H
	DD	07011c215H
	DD	06010H
$unwind$getF1dscb DD 042f19H
	DD	021011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0f0H
$unwind$getF3dscb DD 041d01H
	DD	015011dH
	DD	060157016H
$unwind$getF4dscb DD 042f19H
	DD	023011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$dadsm_setup DD 031a01H
	DD	07016e21aH
	DD	06015H
$unwind$main DD	032319H
	DD	01120111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0880H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdseq.c
_TEXT	SEGMENT
rc$ = 80
cif$ = 88
bail$ = 96
dsn_recs_written$ = 100
fout$ = 104
dsorg$ = 112
tv208 = 120
pgm$ = 128
tv212 = 136
dadsm$ = 144
pathname$ = 1904
__$ArrayPad$ = 2176
argc$ = 2208
argv$ = 2216
main	PROC

; 1421 : {

$LN24:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	57		 push	 rdi
  0000a	48 81 ec 90 08
	00 00		 sub	 rsp, 2192		; 00000890H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 80
	08 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1422 :     char           *pgm;                    /* less any extension (.ext) */
; 1423 :     DADSM           dadsm;                  // DADSM workarea
; 1424 :     FILE           *fout = NULL;            // output file

  00023	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR fout$[rsp], 0

; 1425 :     CIFBLK         *cif;
; 1426 :     int             dsn_recs_written = 0;

  0002c	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR dsn_recs_written$[rsp], 0

; 1427 :     int             bail;
; 1428 :     int             dsorg;
; 1429 :     int             rc;
; 1430 :     char            pathname[MAX_PATH];
; 1431 : 
; 1432 :     INITIALIZE_UTILITY( UTILITY_NAME, UTILITY_DESC, &pgm );

  00034	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR pgm$[rsp]
  0003c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00041	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160550
  00048	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160551
  0004f	48 8b 94 24 a8
	08 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00057	8b 8c 24 a0 08
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_initialize_utility
  00064	89 84 24 a0 08
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 1433 : 
; 1434 :     if (debug) WRMSG( HHC02677, "D", "DEBUG enabled" );

  0006b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  00072	74 53		 je	 SHORT $LN2@main
  00074	b9 01 00 00 00	 mov	 ecx, 1
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0007f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160553
  00086	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0008b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160554
  00092	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00097	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160555
  0009e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000a3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a8	41 b9 03 00 00
	00		 mov	 r9d, 3
  000ae	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160556
  000b5	ba 9a 05 00 00	 mov	 edx, 1434		; 0000059aH
  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160557
  000c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN2@main:

; 1435 : 
; 1436 :     //  Parse command line
; 1437 : 
; 1438 :     memset(&dadsm, 0, sizeof(dadsm));           // init DADSM workarea

  000c7	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR dadsm$[rsp]
  000cf	48 8b f8	 mov	 rdi, rax
  000d2	33 c0		 xor	 eax, eax
  000d4	b9 d4 06 00 00	 mov	 ecx, 1748		; 000006d4H
  000d9	f3 aa		 rep stosb

; 1439 :     rc = parsecmd(argc, argv, &dadsm, pgm);

  000db	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR pgm$[rsp]
  000e3	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR dadsm$[rsp]
  000eb	48 8b 94 24 a8
	08 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  000f3	8b 8c 24 a0 08
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  000fa	e8 00 00 00 00	 call	 parsecmd
  000ff	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 1440 :     if (rc) exit(rc);

  00103	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00108	74 0a		 je	 SHORT $LN3@main
  0010a	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  0010e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN3@main:

; 1441 : 
; 1442 :     //  Open CKD image
; 1443 : 
; 1444 :     cif = open_ckd_image(din, sfn, O_RDONLY | O_BINARY, IMAGE_OPEN_NORMAL);

  00114	45 33 c9	 xor	 r9d, r9d
  00117	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  0011d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR sfn
  00124	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR din
  0012b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open_ckd_image
  00131	48 89 44 24 58	 mov	 QWORD PTR cif$[rsp], rax

; 1445 :     if (!cif || cif == NULL )

  00136	48 83 7c 24 58
	00		 cmp	 QWORD PTR cif$[rsp], 0
  0013c	74 08		 je	 SHORT $LN5@main
  0013e	48 83 7c 24 58
	00		 cmp	 QWORD PTR cif$[rsp], 0
  00144	75 0a		 jne	 SHORT $LN4@main
$LN5@main:

; 1446 :         return -1;

  00146	b8 ff ff ff ff	 mov	 eax, -1
  0014b	e9 d2 05 00 00	 jmp	 $LN1@main
$LN4@main:

; 1447 : 
; 1448 :     //  Unless -abs specified (in which case trust the expert user):
; 1449 :     //  Retrieve extent information for the dataset
; 1450 :     //  Display dataset attributes
; 1451 :     //  Verify dataset has acceptable attributes
; 1452 : 
; 1453 :     if (!absvalid)

  00150	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR absvalid, 0
  00157	0f 85 4e 02 00
	00		 jne	 $LN6@main

; 1454 :     {
; 1455 :         rc = dadsm_setup(cif, &argdsn, &dadsm, local_verbose);

  0015d	44 8b 0d 00 00
	00 00		 mov	 r9d, DWORD PTR local_verbose
  00164	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR dadsm$[rsp]
  0016c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:argdsn
  00173	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cif$[rsp]
  00178	e8 00 00 00 00	 call	 dadsm_setup
  0017d	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 1456 :         if (rc)

  00181	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00186	74 15		 je	 SHORT $LN7@main

; 1457 :         {
; 1458 :             close_ckd_image(cif);

  00188	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cif$[rsp]
  0018d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_ckd_image

; 1459 :             exit(rc);

  00193	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  00197	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN7@main:

; 1460 :         }
; 1461 :         if (local_verbose)

  0019d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR local_verbose, 0
  001a4	0f 84 c2 00 00
	00		 je	 $LN8@main

; 1462 :         {
; 1463 :             FWRMSG( stderr, HHC02484, "I", "" );

  001aa	b9 02 00 00 00	 mov	 ecx, 2
  001af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160564
  001bc	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160565
  001c8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160566
  001d4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001d9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001de	41 b9 03 00 00
	00		 mov	 r9d, 3
  001e4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160567
  001eb	ba b7 05 00 00	 mov	 edx, 1463		; 000005b7H
  001f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160568
  001f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1464 :             showf1(&dadsm.f1buf, dadsm.f1ext, copy_verbose);

  001fd	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR copy_verbose
  00204	48 8d 94 24 94
	02 00 00	 lea	 rdx, QWORD PTR dadsm$[rsp+516]
  0020c	48 8d 8c 24 02
	02 00 00	 lea	 rcx, QWORD PTR dadsm$[rsp+370]
  00214	e8 00 00 00 00	 call	 showf1

; 1465 :             FWRMSG( stderr, HHC02484, "I", "" );

  00219	b9 02 00 00 00	 mov	 ecx, 2
  0021e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00224	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160569
  0022b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00230	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160570
  00237	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0023c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160571
  00243	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00248	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0024d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00253	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160572
  0025a	ba b9 05 00 00	 mov	 edx, 1465		; 000005b9H
  0025f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160573
  00266	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN8@main:

; 1466 :         }
; 1467 :         bail = 1;

  0026c	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR bail$[rsp], 1

; 1468 :         dsorg = (dadsm.f1buf.ds1dsorg[0] << 8) | (dadsm.f1buf.ds1dsorg[1]);

  00274	b8 01 00 00 00	 mov	 eax, 1
  00279	48 6b c0 00	 imul	 rax, rax, 0
  0027d	0f b6 84 04 54
	02 00 00	 movzx	 eax, BYTE PTR dadsm$[rsp+rax+452]
  00285	c1 e0 08	 shl	 eax, 8
  00288	b9 01 00 00 00	 mov	 ecx, 1
  0028d	48 6b c9 01	 imul	 rcx, rcx, 1
  00291	0f b6 8c 0c 54
	02 00 00	 movzx	 ecx, BYTE PTR dadsm$[rsp+rcx+452]
  00299	0b c1		 or	 eax, ecx
  0029b	89 44 24 70	 mov	 DWORD PTR dsorg$[rsp], eax

; 1469 :         if (dsorg & (DSORG_PS * 256))

  0029f	8b 44 24 70	 mov	 eax, DWORD PTR dsorg$[rsp]
  002a3	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  002a8	85 c0		 test	 eax, eax
  002aa	0f 84 8b 00 00
	00		 je	 $LN9@main

; 1470 :         {
; 1471 :             if ((dadsm.f1buf.ds1recfm & RECFM_FORMAT) == RECFM_FORMAT_F)

  002b0	0f b6 84 24 56
	02 00 00	 movzx	 eax, BYTE PTR dadsm$[rsp+454]
  002b8	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  002bd	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  002c2	75 08		 jne	 SHORT $LN11@main

; 1472 :                 bail = 0;

  002c4	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR bail$[rsp], 0
$LN11@main:

; 1473 :             if ((dadsm.f1buf.ds1recfm & RECFM_FORMAT) == RECFM_FORMAT_V)

  002cc	0f b6 84 24 56
	02 00 00	 movzx	 eax, BYTE PTR dadsm$[rsp+454]
  002d4	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  002d9	83 f8 40	 cmp	 eax, 64			; 00000040H
  002dc	75 5b		 jne	 SHORT $LN12@main

; 1474 :             {
; 1475 :                 bail = 1;               // not yet

  002de	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR bail$[rsp], 1

; 1476 :                 // "Dataset is not RECFM %s; utility ends"
; 1477 :                 FWRMSG( stderr, HHC02472, "S", "F[B]" );

  002e6	b9 02 00 00 00	 mov	 ecx, 2
  002eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160578
  002f8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160579
  00304	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00309	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160580
  00310	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00315	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0031a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00320	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160581
  00327	ba c5 05 00 00	 mov	 edx, 1477		; 000005c5H
  0032c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160582
  00333	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN12@main:

; 1478 :             }
; 1479 :         }

  00339	eb 53		 jmp	 SHORT $LN10@main
$LN9@main:

; 1480 :         else
; 1481 :         {
; 1482 :             // "Dataset is not DSORG %s; utility ends"
; 1483 :             FWRMSG( stderr, HHC02473, "S", "PS" );

  0033b	b9 02 00 00 00	 mov	 ecx, 2
  00340	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00346	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160583
  0034d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00352	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160584
  00359	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0035e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160585
  00365	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0036a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0036f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00375	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160586
  0037c	ba cb 05 00 00	 mov	 edx, 1483		; 000005cbH
  00381	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160587
  00388	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN10@main:

; 1484 :         }
; 1485 :         if (bail)

  0038e	83 7c 24 60 00	 cmp	 DWORD PTR bail$[rsp], 0
  00393	74 16		 je	 SHORT $LN13@main

; 1486 :         {
; 1487 :             close_ckd_image(cif);

  00395	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cif$[rsp]
  0039a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_ckd_image

; 1488 :             exit(21);

  003a0	b9 15 00 00 00	 mov	 ecx, 21
  003a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN13@main:
$LN6@main:

; 1489 :         }
; 1490 :     }
; 1491 : 
; 1492 :     //  Open output dataset (EBCDIC requires binary open)
; 1493 : 
; 1494 :     hostpath(pathname, argdsn, sizeof(pathname));

  003ab	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  003b1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR argdsn
  003b8	48 8d 8c 24 70
	07 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  003c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 1495 : 
; 1496 :     fout = fopen(pathname, (tran_ascii) ? "wb" : "w");

  003c6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR tran_ascii, 0
  003cd	74 0e		 je	 SHORT $LN22@main
  003cf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160589
  003d6	48 89 44 24 78	 mov	 QWORD PTR tv208[rsp], rax
  003db	eb 0c		 jmp	 SHORT $LN23@main
$LN22@main:
  003dd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160590
  003e4	48 89 44 24 78	 mov	 QWORD PTR tv208[rsp], rax
$LN23@main:
  003e9	48 8b 54 24 78	 mov	 rdx, QWORD PTR tv208[rsp]
  003ee	48 8d 8c 24 70
	07 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  003f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  003fc	48 89 44 24 68	 mov	 QWORD PTR fout$[rsp], rax

; 1497 :     if (fout == NULL)

  00401	48 83 7c 24 68
	00		 cmp	 QWORD PTR fout$[rsp], 0
  00407	0f 85 98 00 00
	00		 jne	 $LN14@main

; 1498 :     {
; 1499 :         // "File %s; %s error: %s"
; 1500 :         FWRMSG( stderr, HHC02468, "E", argdsn, "fopen()", strerror( errno ));

  0040d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00413	8b 08		 mov	 ecx, DWORD PTR [rax]
  00415	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0041b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv212[rsp], rax
  00423	b9 02 00 00 00	 mov	 ecx, 2
  00428	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0042e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv212[rsp]
  00436	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0043b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160592
  00442	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00447	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR argdsn
  0044e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00453	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160593
  0045a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0045f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160594
  00466	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0046b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00470	41 b9 03 00 00
	00		 mov	 r9d, 3
  00476	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160595
  0047d	ba dc 05 00 00	 mov	 edx, 1500		; 000005dcH
  00482	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160596
  00489	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1501 :         close_ckd_image(cif);

  0048f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cif$[rsp]
  00494	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_ckd_image

; 1502 :         exit(22);

  0049a	b9 16 00 00 00	 mov	 ecx, 22
  0049f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN14@main:

; 1503 :     }
; 1504 :     if (local_verbose)

  004a5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR local_verbose, 0
  004ac	74 53		 je	 SHORT $LN15@main

; 1505 :     {
; 1506 :         // "writing %s"
; 1507 :         WRMSG( HHC02694, "I", argdsn );

  004ae	b9 01 00 00 00	 mov	 ecx, 1
  004b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004b9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR argdsn
  004c0	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160598
  004cc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160599
  004d8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004dd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004e2	41 b9 03 00 00
	00		 mov	 r9d, 3
  004e8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160600
  004ef	ba e3 05 00 00	 mov	 edx, 1507		; 000005e3H
  004f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160601
  004fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN15@main:

; 1508 :     }
; 1509 : 
; 1510 :     //  Write dasd data to output dataset
; 1511 : 
; 1512 :     dsn_recs_written = fbcopy(fout, cif, &dadsm, tran_ascii, copy_verbose);

  00501	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR copy_verbose
  00507	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0050b	44 8b 0d 00 00
	00 00		 mov	 r9d, DWORD PTR tran_ascii
  00512	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR dadsm$[rsp]
  0051a	48 8b 54 24 58	 mov	 rdx, QWORD PTR cif$[rsp]
  0051f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR fout$[rsp]
  00524	e8 00 00 00 00	 call	 fbcopy
  00529	89 44 24 64	 mov	 DWORD PTR dsn_recs_written$[rsp], eax

; 1513 :     if (dsn_recs_written == -1)

  0052d	83 7c 24 64 ff	 cmp	 DWORD PTR dsn_recs_written$[rsp], -1
  00532	75 55		 jne	 SHORT $LN16@main

; 1514 :     {
; 1515 :         // "Error processing %s"
; 1516 :         FWRMSG( stderr, HHC02474, "E", argdsn );

  00534	b9 02 00 00 00	 mov	 ecx, 2
  00539	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0053f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR argdsn
  00546	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0054b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160604
  00552	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00557	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160605
  0055e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00563	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00568	41 b9 03 00 00
	00		 mov	 r9d, 3
  0056e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160606
  00575	ba ec 05 00 00	 mov	 edx, 1516		; 000005ecH
  0057a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160607
  00581	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1517 :     }

  00587	eb 5b		 jmp	 SHORT $LN17@main
$LN16@main:

; 1518 :     else
; 1519 :     {
; 1520 :         // "Records written to %s: %d"
; 1521 :         WRMSG( HHC02475, "I", argdsn, dsn_recs_written );

  00589	b9 01 00 00 00	 mov	 ecx, 1
  0058e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00594	8b 4c 24 64	 mov	 ecx, DWORD PTR dsn_recs_written$[rsp]
  00598	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0059c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR argdsn
  005a3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  005a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160608
  005af	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160609
  005bb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005c0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005c5	41 b9 03 00 00
	00		 mov	 r9d, 3
  005cb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160610
  005d2	ba f1 05 00 00	 mov	 edx, 1521		; 000005f1H
  005d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160611
  005de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN17@main:

; 1522 :     }
; 1523 : 
; 1524 :     //  Close output dataset, dasd image and return to caller
; 1525 : 
; 1526 :     fclose(fout);

  005e4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR fout$[rsp]
  005e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose

; 1527 :     if (local_verbose > 2)

  005ef	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR local_verbose, 2
  005f6	7e 53		 jle	 SHORT $LN18@main

; 1528 :     {
; 1529 :         // "Closed output file %s"
; 1530 :         WRMSG( HHC02695, "I", argdsn );

  005f8	b9 01 00 00 00	 mov	 ecx, 1
  005fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00603	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR argdsn
  0060a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0060f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160613
  00616	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0061b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160614
  00622	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00627	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0062c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00632	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160615
  00639	ba fa 05 00 00	 mov	 edx, 1530		; 000005faH
  0063e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160616
  00645	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN18@main:

; 1531 :     }
; 1532 : 
; 1533 :     if (local_verbose > 3)

  0064b	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR local_verbose, 3
  00652	7e 63		 jle	 SHORT $LN19@main

; 1534 :     {
; 1535 :         // "%s"
; 1536 :         WRMSG( HHC02681, "I", "CIFBLK:" );

  00654	b9 01 00 00 00	 mov	 ecx, 1
  00659	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0065f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160618
  00666	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0066b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160619
  00672	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00677	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160620
  0067e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00683	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00688	41 b9 03 00 00
	00		 mov	 r9d, 3
  0068e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160621
  00695	ba 00 06 00 00	 mov	 edx, 1536		; 00000600H
  0069a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160622
  006a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1537 :         data_dump((void *) cif, sizeof(CIFBLK));

  006a7	ba d0 1b 00 00	 mov	 edx, 7120		; 00001bd0H
  006ac	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cif$[rsp]
  006b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump
$LN19@main:

; 1538 :     }
; 1539 : 
; 1540 :     close_ckd_image(cif);

  006b7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cif$[rsp]
  006bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_ckd_image

; 1541 : 
; 1542 :     if (local_verbose > 2 )

  006c2	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR local_verbose, 2
  006c9	7e 53		 jle	 SHORT $LN20@main

; 1543 :     {
; 1544 :         // "%s"
; 1545 :         WRMSG( HHC02681, "I", "Closed image file" );

  006cb	b9 01 00 00 00	 mov	 ecx, 1
  006d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160624
  006dd	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  006e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160625
  006e9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160626
  006f5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006fa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006ff	41 b9 03 00 00
	00		 mov	 r9d, 3
  00705	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160627
  0070c	ba 09 06 00 00	 mov	 edx, 1545		; 00000609H
  00711	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160628
  00718	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN20@main:

; 1546 :     }
; 1547 : 
; 1548 :     return rc;

  0071e	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@main:
$LN21@main:

; 1549 : }

  00722	48 8b 8c 24 80
	08 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0072a	48 33 cc	 xor	 rcx, rsp
  0072d	e8 00 00 00 00	 call	 __security_check_cookie
  00732	48 81 c4 90 08
	00 00		 add	 rsp, 2192		; 00000890H
  00739	5f		 pop	 rdi
  0073a	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdseq.c
_TEXT	SEGMENT
rc$ = 80
numx$ = 84
f1x$ = 88
pcchhr$ = 96
cif$ = 144
pdsn$ = 152
dadsm$ = 160
verbose$ = 168
dadsm_setup PROC

; 1342 : {

$LN15:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1343 :     DSXTENT         *f1x;
; 1344 :     BYTE            *pcchhr;
; 1345 :     int             numx = MAX_EXTENTS;     // # extent slots available

  0001a	c7 44 24 54 7b
	00 00 00	 mov	 DWORD PTR numx$[rsp], 123 ; 0000007bH

; 1346 :     int             rc;
; 1347 : 
; 1348 :     //  Read dasd volume label record
; 1349 : 
; 1350 :     rc = getlabel(cif, &dadsm->volrec, verbose);

  00022	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dadsm$[rsp]
  0002a	44 8b 84 24 a8
	00 00 00	 mov	 r8d, DWORD PTR verbose$[rsp]
  00032	48 8b d0	 mov	 rdx, rax
  00035	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  0003d	e8 00 00 00 00	 call	 getlabel
  00042	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 1351 :     if (rc) return rc;

  00046	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  0004b	74 09		 je	 SHORT $LN4@dadsm_setu
  0004d	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
  00051	e9 32 04 00 00	 jmp	 $LN1@dadsm_setu
$LN4@dadsm_setu:

; 1352 : 
; 1353 :     //  Read F4 DSCB, save VTOC extent info
; 1354 : 
; 1355 :     rc = getF4dscb(cif, &dadsm->f4buf, &dadsm->volrec, &dadsm->f4ext, verbose);

  00056	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dadsm$[rsp]
  0005e	48 05 dc 00 00
	00		 add	 rax, 220		; 000000dcH
  00064	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dadsm$[rsp]
  0006c	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dadsm$[rsp]
  00074	48 83 c2 50	 add	 rdx, 80			; 00000050H
  00078	44 8b 84 24 a8
	00 00 00	 mov	 r8d, DWORD PTR verbose$[rsp]
  00080	44 89 44 24 20	 mov	 DWORD PTR [rsp+32], r8d
  00085	4c 8b c8	 mov	 r9, rax
  00088	4c 8b c1	 mov	 r8, rcx
  0008b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00093	e8 00 00 00 00	 call	 getF4dscb
  00098	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 1356 :     if (rc) return rc;

  0009c	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  000a1	74 09		 je	 SHORT $LN5@dadsm_setu
  000a3	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
  000a7	e9 dc 03 00 00	 jmp	 $LN1@dadsm_setu
$LN5@dadsm_setu:

; 1357 : 
; 1358 :     //  Read F1 DSCB, save first three extents from F1 DSCB
; 1359 : 
; 1360 :     rc = getF1dscb(cif, pdsn, &dadsm->f1buf, (void *)&dadsm->f4ext, verbose);

  000ac	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dadsm$[rsp]
  000b4	48 05 dc 00 00
	00		 add	 rax, 220		; 000000dcH
  000ba	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dadsm$[rsp]
  000c2	48 81 c1 72 01
	00 00		 add	 rcx, 370		; 00000172H
  000c9	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR verbose$[rsp]
  000d0	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  000d4	4c 8b c8	 mov	 r9, rax
  000d7	4c 8b c1	 mov	 r8, rcx
  000da	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR pdsn$[rsp]
  000e2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  000ea	e8 00 00 00 00	 call	 getF1dscb
  000ef	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 1361 :     if (rc) return rc;

  000f3	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  000f8	74 09		 je	 SHORT $LN6@dadsm_setu
  000fa	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
  000fe	e9 85 03 00 00	 jmp	 $LN1@dadsm_setu
$LN6@dadsm_setu:

; 1362 : 
; 1363 :     f1x = &dadsm->f1ext[0];                     // @ extent # 0

  00103	b8 0a 00 00 00	 mov	 eax, 10
  00108	48 6b c0 00	 imul	 rax, rax, 0
  0010c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dadsm$[rsp]
  00114	48 8d 84 01 04
	02 00 00	 lea	 rax, QWORD PTR [rcx+rax+516]
  0011c	48 89 44 24 58	 mov	 QWORD PTR f1x$[rsp], rax

; 1364 :     numx -= 3;                                  // will use 3 slots (if available)

  00121	8b 44 24 54	 mov	 eax, DWORD PTR numx$[rsp]
  00125	83 e8 03	 sub	 eax, 3
  00128	89 44 24 54	 mov	 DWORD PTR numx$[rsp], eax

; 1365 :     if (numx < 0)

  0012c	83 7c 24 54 00	 cmp	 DWORD PTR numx$[rsp], 0
  00131	7d 65		 jge	 SHORT $LN7@dadsm_setu

; 1366 :     {
; 1367 :         // "In %s: extent slots exhausted; maximum supported is %d"
; 1368 :         FWRMSG( stderr, HHC02480, "E", "dadsm_setup()", MAX_EXTENTS );

  00133	b9 02 00 00 00	 mov	 ecx, 2
  00138	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0013e	c7 44 24 40 7b
	00 00 00	 mov	 DWORD PTR [rsp+64], 123	; 0000007bH
  00146	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160505
  0014d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00152	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160506
  00159	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0015e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160507
  00165	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0016a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0016f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00175	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160508
  0017c	ba 58 05 00 00	 mov	 edx, 1368		; 00000558H
  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160509
  00188	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1369 :         return 1;

  0018e	b8 01 00 00 00	 mov	 eax, 1
  00193	e9 f0 02 00 00	 jmp	 $LN1@dadsm_setu
$LN7@dadsm_setu:

; 1370 :     }
; 1371 :     memcpy(f1x, &dadsm->f1buf.ds1ext1, sizeof(DSXTENT) * 3);

  00198	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dadsm$[rsp]
  001a0	48 8b 7c 24 58	 mov	 rdi, QWORD PTR f1x$[rsp]
  001a5	48 8d b0 db 01
	00 00		 lea	 rsi, QWORD PTR [rax+475]
  001ac	b9 1e 00 00 00	 mov	 ecx, 30
  001b1	f3 a4		 rep movsb

; 1372 :     f1x += 3;                                   // @ extent # 3

  001b3	48 8b 44 24 58	 mov	 rax, QWORD PTR f1x$[rsp]
  001b8	48 83 c0 1e	 add	 rax, 30
  001bc	48 89 44 24 58	 mov	 QWORD PTR f1x$[rsp], rax

; 1373 :     dadsm->f1numx = dadsm->f1buf.ds1noepv;      // # extents alloc'd to dataset

  001c1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dadsm$[rsp]
  001c9	0f b6 80 ad 01
	00 00		 movzx	 eax, BYTE PTR [rax+429]
  001d0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dadsm$[rsp]
  001d8	89 81 00 02 00
	00		 mov	 DWORD PTR [rcx+512], eax

; 1374 :     if (dadsm->f1numx < 4)

  001de	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dadsm$[rsp]
  001e6	83 b8 00 02 00
	00 04		 cmp	 DWORD PTR [rax+512], 4
  001ed	7d 6a		 jge	 SHORT $LN8@dadsm_setu

; 1375 :     {
; 1376 :         if (verbose > 1)

  001ef	83 bc 24 a8 00
	00 00 01	 cmp	 DWORD PTR verbose$[rsp], 1
  001f7	7e 59		 jle	 SHORT $LN9@dadsm_setu

; 1377 :         {
; 1378 :             // "%d extent(s) found; all are in Format 1 DSCB"
; 1379 :             WRMSG( HHC02669, "I", dadsm->f1numx );

  001f9	b9 01 00 00 00	 mov	 ecx, 1
  001fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00204	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dadsm$[rsp]
  0020c	8b 89 00 02 00
	00		 mov	 ecx, DWORD PTR [rcx+512]
  00212	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00216	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160512
  0021d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00222	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160513
  00229	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0022e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00233	41 b9 03 00 00
	00		 mov	 r9d, 3
  00239	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160514
  00240	ba 63 05 00 00	 mov	 edx, 1379		; 00000563H
  00245	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160515
  0024c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@dadsm_setu:

; 1380 :         }
; 1381 :         return 0;

  00252	33 c0		 xor	 eax, eax
  00254	e9 2f 02 00 00	 jmp	 $LN1@dadsm_setu
$LN8@dadsm_setu:

; 1382 :     }
; 1383 : 
; 1384 :     //  When more than 3 extents, get additional extent info from F3 DSCB(s).
; 1385 :     //  Chase the F3 chain starting with the CCHHR in the F1, accumulating
; 1386 :     //  extent information for the dataset as we progress.
; 1387 : 
; 1388 :     pcchhr = (BYTE *)&dadsm->f1buf.ds1ptrds;            // @ F1 ptr to F3

  00259	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dadsm$[rsp]
  00261	48 05 f9 01 00
	00		 add	 rax, 505		; 000001f9H
  00267	48 89 44 24 60	 mov	 QWORD PTR pcchhr$[rsp], rax
$LN2@dadsm_setu:

; 1389 :     while (pcchhr[0] || pcchhr[1] || pcchhr[2] || pcchhr[3] || pcchhr[4])

  0026c	b8 01 00 00 00	 mov	 eax, 1
  00271	48 6b c0 00	 imul	 rax, rax, 0
  00275	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pcchhr$[rsp]
  0027a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0027e	85 c0		 test	 eax, eax
  00280	75 5c		 jne	 SHORT $LN10@dadsm_setu
  00282	b8 01 00 00 00	 mov	 eax, 1
  00287	48 6b c0 01	 imul	 rax, rax, 1
  0028b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pcchhr$[rsp]
  00290	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00294	85 c0		 test	 eax, eax
  00296	75 46		 jne	 SHORT $LN10@dadsm_setu
  00298	b8 01 00 00 00	 mov	 eax, 1
  0029d	48 6b c0 02	 imul	 rax, rax, 2
  002a1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pcchhr$[rsp]
  002a6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002aa	85 c0		 test	 eax, eax
  002ac	75 30		 jne	 SHORT $LN10@dadsm_setu
  002ae	b8 01 00 00 00	 mov	 eax, 1
  002b3	48 6b c0 03	 imul	 rax, rax, 3
  002b7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pcchhr$[rsp]
  002bc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002c0	85 c0		 test	 eax, eax
  002c2	75 1a		 jne	 SHORT $LN10@dadsm_setu
  002c4	b8 01 00 00 00	 mov	 eax, 1
  002c9	48 6b c0 04	 imul	 rax, rax, 4
  002cd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pcchhr$[rsp]
  002d2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002d6	85 c0		 test	 eax, eax
  002d8	0f 84 a8 01 00
	00		 je	 $LN3@dadsm_setu
$LN10@dadsm_setu:

; 1390 :     {
; 1391 :         rc = getF3dscb(cif, pcchhr, &dadsm->f3buf, verbose);

  002de	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dadsm$[rsp]
  002e6	48 05 e6 00 00
	00		 add	 rax, 230		; 000000e6H
  002ec	44 8b 8c 24 a8
	00 00 00	 mov	 r9d, DWORD PTR verbose$[rsp]
  002f4	4c 8b c0	 mov	 r8, rax
  002f7	48 8b 54 24 60	 mov	 rdx, QWORD PTR pcchhr$[rsp]
  002fc	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00304	e8 00 00 00 00	 call	 getF3dscb
  00309	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 1392 :         if (rc) return rc;

  0030d	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00312	74 09		 je	 SHORT $LN11@dadsm_setu
  00314	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
  00318	e9 6b 01 00 00	 jmp	 $LN1@dadsm_setu
$LN11@dadsm_setu:

; 1393 :         numx -= 4;                              // use extent slots

  0031d	8b 44 24 54	 mov	 eax, DWORD PTR numx$[rsp]
  00321	83 e8 04	 sub	 eax, 4
  00324	89 44 24 54	 mov	 DWORD PTR numx$[rsp], eax

; 1394 :         if (numx < 0)

  00328	83 7c 24 54 00	 cmp	 DWORD PTR numx$[rsp], 0
  0032d	7d 65		 jge	 SHORT $LN12@dadsm_setu

; 1395 :         {
; 1396 :             // "In %s: extent slots exhausted; maximum supported is %d"
; 1397 :             FWRMSG( stderr, HHC02480, "E", "dadsm_setup()", MAX_EXTENTS );

  0032f	b9 02 00 00 00	 mov	 ecx, 2
  00334	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0033a	c7 44 24 40 7b
	00 00 00	 mov	 DWORD PTR [rsp+64], 123	; 0000007bH
  00342	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160519
  00349	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0034e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160520
  00355	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0035a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160521
  00361	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00366	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0036b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00371	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160522
  00378	ba 75 05 00 00	 mov	 edx, 1397		; 00000575H
  0037d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160523
  00384	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1398 :             return 2;

  0038a	b8 02 00 00 00	 mov	 eax, 2
  0038f	e9 f4 00 00 00	 jmp	 $LN1@dadsm_setu
$LN12@dadsm_setu:

; 1399 :         }
; 1400 :         memcpy(f1x, &dadsm->f3buf.ds3extnt[0], sizeof(DSXTENT) * 4);

  00394	b8 0a 00 00 00	 mov	 eax, 10
  00399	48 6b c0 00	 imul	 rax, rax, 0
  0039d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dadsm$[rsp]
  003a5	48 8b 7c 24 58	 mov	 rdi, QWORD PTR f1x$[rsp]
  003aa	48 8d b4 01 ea
	00 00 00	 lea	 rsi, QWORD PTR [rcx+rax+234]
  003b2	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  003b7	f3 a4		 rep movsb

; 1401 :         f1x += 4;

  003b9	48 8b 44 24 58	 mov	 rax, QWORD PTR f1x$[rsp]
  003be	48 83 c0 28	 add	 rax, 40			; 00000028H
  003c2	48 89 44 24 58	 mov	 QWORD PTR f1x$[rsp], rax

; 1402 :         numx -= 9;                              // use extent slots

  003c7	8b 44 24 54	 mov	 eax, DWORD PTR numx$[rsp]
  003cb	83 e8 09	 sub	 eax, 9
  003ce	89 44 24 54	 mov	 DWORD PTR numx$[rsp], eax

; 1403 :         if (numx < 0)

  003d2	83 7c 24 54 00	 cmp	 DWORD PTR numx$[rsp], 0
  003d7	7d 62		 jge	 SHORT $LN13@dadsm_setu

; 1404 :         {
; 1405 :             // "In %s: extent slots exhausted; maximum supported is %d"
; 1406 :             FWRMSG( stderr, HHC02480, "E", "dadsm_setup()", MAX_EXTENTS );

  003d9	b9 02 00 00 00	 mov	 ecx, 2
  003de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003e4	c7 44 24 40 7b
	00 00 00	 mov	 DWORD PTR [rsp+64], 123	; 0000007bH
  003ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160525
  003f3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160526
  003ff	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00404	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160527
  0040b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00410	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00415	41 b9 03 00 00
	00		 mov	 r9d, 3
  0041b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160528
  00422	ba 7e 05 00 00	 mov	 edx, 1406		; 0000057eH
  00427	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160529
  0042e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1407 :             return 3;

  00434	b8 03 00 00 00	 mov	 eax, 3
  00439	eb 4d		 jmp	 SHORT $LN1@dadsm_setu
$LN13@dadsm_setu:

; 1408 :         }
; 1409 :         memcpy(f1x, &dadsm->f3buf.ds3adext[0], sizeof(DSXTENT) * 9);

  0043b	b8 0a 00 00 00	 mov	 eax, 10
  00440	48 6b c0 00	 imul	 rax, rax, 0
  00444	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dadsm$[rsp]
  0044c	48 8b 7c 24 58	 mov	 rdi, QWORD PTR f1x$[rsp]
  00451	48 8d b4 01 13
	01 00 00	 lea	 rsi, QWORD PTR [rcx+rax+275]
  00459	b9 5a 00 00 00	 mov	 ecx, 90			; 0000005aH
  0045e	f3 a4		 rep movsb

; 1410 :         f1x += 9;

  00460	48 8b 44 24 58	 mov	 rax, QWORD PTR f1x$[rsp]
  00465	48 83 c0 5a	 add	 rax, 90			; 0000005aH
  00469	48 89 44 24 58	 mov	 QWORD PTR f1x$[rsp], rax

; 1411 :         pcchhr = (BYTE *)&dadsm->f3buf.ds3ptrds;        // @ next F3 CCHHR

  0046e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dadsm$[rsp]
  00476	48 05 6d 01 00
	00		 add	 rax, 365		; 0000016dH
  0047c	48 89 44 24 60	 mov	 QWORD PTR pcchhr$[rsp], rax

; 1412 :     }

  00481	e9 e6 fd ff ff	 jmp	 $LN2@dadsm_setu
$LN3@dadsm_setu:

; 1413 :     return 0;

  00486	33 c0		 xor	 eax, eax
$LN1@dadsm_setu:

; 1414 : }

  00488	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0048c	5f		 pop	 rdi
  0048d	5e		 pop	 rsi
  0048e	c3		 ret	 0
dadsm_setup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdseq.c
_TEXT	SEGMENT
f4kl$ = 128
rec$ = 129
head$ = 130
f4dl$ = 132
cyl$ = 136
rc$ = 140
tv89 = 144
tv91 = 148
tv169 = 152
tv171 = 156
tv236 = 160
tv251 = 164
tv256 = 168
tv261 = 172
tv276 = 176
tv281 = 180
tv286 = 184
f4key$ = 192
f4data$ = 200
vtockey$ = 208
__$ArrayPad$ = 256
cif$ = 304
f4dscb$ = 312
volrec$ = 320
vtocx$ = 328
verbose$ = 336
getF4dscb PROC

; 993  : {

$LN12:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 994  :     char    vtockey[sizeof(f4dscb->ds4keyid)];
; 995  :     void    *f4key, *f4data;
; 996  :     U8      f4kl;
; 997  :     U16     f4dl;
; 998  :     int     rc;
; 999  :     U32     cyl;
; 1000 :     U8      head, rec;
; 1001 : 
; 1002 :     //  Extract VTOC's CCHHR from volume label
; 1003 : 
; 1004 :     cyl = (volrec->volvtoc[0] << 8) | volrec->volvtoc[1];

  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	48 6b c0 00	 imul	 rax, rax, 0
  00038	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR volrec$[rsp]
  00040	0f b6 44 01 0b	 movzx	 eax, BYTE PTR [rcx+rax+11]
  00045	c1 e0 08	 shl	 eax, 8
  00048	b9 01 00 00 00	 mov	 ecx, 1
  0004d	48 6b c9 01	 imul	 rcx, rcx, 1
  00051	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR volrec$[rsp]
  00059	0f b6 4c 0a 0b	 movzx	 ecx, BYTE PTR [rdx+rcx+11]
  0005e	0b c1		 or	 eax, ecx
  00060	89 84 24 88 00
	00 00		 mov	 DWORD PTR cyl$[rsp], eax

; 1005 :     head = (volrec->volvtoc[2] << 8) | volrec->volvtoc[3];

  00067	b8 01 00 00 00	 mov	 eax, 1
  0006c	48 6b c0 02	 imul	 rax, rax, 2
  00070	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR volrec$[rsp]
  00078	0f b6 44 01 0b	 movzx	 eax, BYTE PTR [rcx+rax+11]
  0007d	c1 e0 08	 shl	 eax, 8
  00080	b9 01 00 00 00	 mov	 ecx, 1
  00085	48 6b c9 03	 imul	 rcx, rcx, 3
  00089	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR volrec$[rsp]
  00091	0f b6 4c 0a 0b	 movzx	 ecx, BYTE PTR [rdx+rcx+11]
  00096	0b c1		 or	 eax, ecx
  00098	88 84 24 82 00
	00 00		 mov	 BYTE PTR head$[rsp], al

; 1006 :     rec = volrec->volvtoc[4];

  0009f	b8 01 00 00 00	 mov	 eax, 1
  000a4	48 6b c0 04	 imul	 rax, rax, 4
  000a8	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR volrec$[rsp]
  000b0	0f b6 44 01 0b	 movzx	 eax, BYTE PTR [rcx+rax+11]
  000b5	88 84 24 81 00
	00 00		 mov	 BYTE PTR rec$[rsp], al

; 1007 : 
; 1008 :     if (verbose > 1)

  000bc	83 bc 24 50 01
	00 00 01	 cmp	 DWORD PTR verbose$[rsp], 1
  000c4	0f 8e 86 00 00
	00		 jle	 $LN2@getF4dscb

; 1009 :     {
; 1010 :         // "VTOC F4 at cyl %d head %d rec %d"
; 1011 :         WRMSG( HHC02665, "I", cyl, head, rec);

  000ca	0f b6 84 24 81
	00 00 00	 movzx	 eax, BYTE PTR rec$[rsp]
  000d2	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv89[rsp], eax
  000d9	0f b6 8c 24 82
	00 00 00	 movzx	 ecx, BYTE PTR head$[rsp]
  000e1	89 8c 24 94 00
	00 00		 mov	 DWORD PTR tv91[rsp], ecx
  000e8	b9 01 00 00 00	 mov	 ecx, 1
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000f3	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv89[rsp]
  000fa	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  000fe	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv91[rsp]
  00105	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00109	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR cyl$[rsp]
  00110	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00114	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160299
  0011b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00120	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160300
  00127	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0012c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00131	41 b9 03 00 00
	00		 mov	 r9d, 3
  00137	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160301
  0013e	ba f3 03 00 00	 mov	 edx, 1011		; 000003f3H
  00143	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160302
  0014a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN2@getF4dscb:

; 1012 :     }
; 1013 : 
; 1014 :     //  Read VTOC's Format 4 DSCB (VTOC self-descriptor)
; 1015 : 
; 1016 :     if (verbose)

  00150	83 bc 24 50 01
	00 00 00	 cmp	 DWORD PTR verbose$[rsp], 0
  00158	74 47		 je	 SHORT $LN3@getF4dscb

; 1017 :     {
; 1018 :         // "Reading VTOC F4 DSCB..."
; 1019 :         WRMSG( HHC02666, "I" );

  0015a	b9 01 00 00 00	 mov	 ecx, 1
  0015f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00165	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160304
  0016c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00171	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160305
  00178	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0017d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00182	41 b9 03 00 00
	00		 mov	 r9d, 3
  00188	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160306
  0018f	ba fb 03 00 00	 mov	 edx, 1019		; 000003fbH
  00194	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160307
  0019b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN3@getF4dscb:

; 1020 :     }
; 1021 : 
; 1022 :     rc = read_block( cif, cyl, head, rec, (void*) &f4key, &f4kl, (void*) &f4data, &f4dl );

  001a1	48 8d 84 24 84
	00 00 00	 lea	 rax, QWORD PTR f4dl$[rsp]
  001a9	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  001ae	48 8d 84 24 c8
	00 00 00	 lea	 rax, QWORD PTR f4data$[rsp]
  001b6	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001bb	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR f4kl$[rsp]
  001c3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001c8	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR f4key$[rsp]
  001d0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001d5	44 0f b6 8c 24
	81 00 00 00	 movzx	 r9d, BYTE PTR rec$[rsp]
  001de	44 0f b6 84 24
	82 00 00 00	 movzx	 r8d, BYTE PTR head$[rsp]
  001e7	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR cyl$[rsp]
  001ee	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  001f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_block
  001fc	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 1023 :     if (rc)

  00203	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  0020b	74 5c		 je	 SHORT $LN4@getF4dscb

; 1024 :     {
; 1025 :         // "Error reading F4 DSCB, rc %d"
; 1026 :         FWRMSG( stderr, HHC02667, "E", rc );

  0020d	b9 02 00 00 00	 mov	 ecx, 2
  00212	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00218	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR rc$[rsp]
  0021f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00223	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160309
  0022a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0022f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160310
  00236	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0023b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00240	41 b9 03 00 00
	00		 mov	 r9d, 3
  00246	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160311
  0024d	ba 02 04 00 00	 mov	 edx, 1026		; 00000402H
  00252	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160312
  00259	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1027 :         return 1;

  0025f	b8 01 00 00 00	 mov	 eax, 1
  00264	e9 c8 03 00 00	 jmp	 $LN1@getF4dscb
$LN4@getF4dscb:

; 1028 :     }
; 1029 : 
; 1030 :     //  Verify correct key and data length
; 1031 : 
; 1032 :     if ((f4kl != sizeof(f4dscb->ds4keyid)) ||

  00269	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR f4kl$[rsp]
  00271	48 83 f8 2c	 cmp	 rax, 44			; 0000002cH
  00275	75 12		 jne	 SHORT $LN6@getF4dscb
  00277	0f b7 84 24 84
	00 00 00	 movzx	 eax, WORD PTR f4dl$[rsp]
  0027f	48 83 f8 60	 cmp	 rax, 96			; 00000060H
  00283	0f 84 85 00 00
	00		 je	 $LN5@getF4dscb
$LN6@getF4dscb:

; 1033 :         (f4dl != (sizeof(FORMAT4_DSCB) - sizeof(f4dscb->ds4keyid))))
; 1034 :     {
; 1035 :         // "Erroneous key length %d or data length %d"
; 1036 :         FWRMSG( stderr, HHC02668, "E", f4kl, f4dl );

  00289	0f b7 84 24 84
	00 00 00	 movzx	 eax, WORD PTR f4dl$[rsp]
  00291	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv169[rsp], eax
  00298	0f b6 8c 24 80
	00 00 00	 movzx	 ecx, BYTE PTR f4kl$[rsp]
  002a0	89 8c 24 9c 00
	00 00		 mov	 DWORD PTR tv171[rsp], ecx
  002a7	b9 02 00 00 00	 mov	 ecx, 2
  002ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002b2	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv169[rsp]
  002b9	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002bd	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv171[rsp]
  002c4	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160315
  002cf	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160316
  002db	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002e0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002e5	41 b9 03 00 00
	00		 mov	 r9d, 3
  002eb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160317
  002f2	ba 0c 04 00 00	 mov	 edx, 1036		; 0000040cH
  002f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160318
  002fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1037 :         return 2;

  00304	b8 02 00 00 00	 mov	 eax, 2
  00309	e9 23 03 00 00	 jmp	 $LN1@getF4dscb
$LN5@getF4dscb:

; 1038 :     }
; 1039 : 
; 1040 :     //  Return data to caller
; 1041 : 
; 1042 :     memcpy((void *) &f4dscb->ds4keyid, f4key, f4kl);    // copy F4 key into buffer

  0030e	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR f4kl$[rsp]
  00316	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR f4dscb$[rsp]
  0031e	48 8b bc 24 38
	01 00 00	 mov	 rdi, QWORD PTR f4dscb$[rsp]
  00326	48 8b b4 24 c0
	00 00 00	 mov	 rsi, QWORD PTR f4key$[rsp]
  0032e	8b c8		 mov	 ecx, eax
  00330	f3 a4		 rep movsb

; 1043 :     memcpy((void *) &f4dscb->ds4fmtid, f4data, f4dl);   // copy F4 data into buffer

  00332	0f b7 84 24 84
	00 00 00	 movzx	 eax, WORD PTR f4dl$[rsp]
  0033a	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR f4dscb$[rsp]
  00342	48 83 c1 2c	 add	 rcx, 44			; 0000002cH
  00346	48 8b f9	 mov	 rdi, rcx
  00349	48 8b b4 24 c8
	00 00 00	 mov	 rsi, QWORD PTR f4data$[rsp]
  00351	8b c8		 mov	 ecx, eax
  00353	f3 a4		 rep movsb

; 1044 :     memcpy((void *) vtocx, (void *)&f4dscb->ds4vtoce,

  00355	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR f4dscb$[rsp]
  0035d	48 8b bc 24 48
	01 00 00	 mov	 rdi, QWORD PTR vtocx$[rsp]
  00365	48 8d 70 69	 lea	 rsi, QWORD PTR [rax+105]
  00369	b9 0a 00 00 00	 mov	 ecx, 10
  0036e	f3 a4		 rep movsb

; 1045 :         sizeof(f4dscb->ds4vtoce));                      // copy VTOC extent entry
; 1046 :     if (verbose > 1)

  00370	83 bc 24 50 01
	00 00 01	 cmp	 DWORD PTR verbose$[rsp], 1
  00378	7e 66		 jle	 SHORT $LN7@getF4dscb

; 1047 :     {
; 1048 :         // "%s"
; 1049 :         WRMSG( HHC02681, "I", "F4 DSCB:" );

  0037a	b9 01 00 00 00	 mov	 ecx, 1
  0037f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00385	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160320
  0038c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00391	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160321
  00398	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0039d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160322
  003a4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003a9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003ae	41 b9 03 00 00
	00		 mov	 r9d, 3
  003b4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160323
  003bb	ba 19 04 00 00	 mov	 edx, 1049		; 00000419H
  003c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160324
  003c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1050 :         data_dump((void *) f4dscb, sizeof(FORMAT4_DSCB));

  003cd	ba 8c 00 00 00	 mov	 edx, 140		; 0000008cH
  003d2	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR f4dscb$[rsp]
  003da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump
$LN7@getF4dscb:

; 1051 :     }
; 1052 : 
; 1053 :     //  Verify DS4FMTID byte = x'F4', DS4KEYID key = x'04', and DS4NOEXT = x'01'
; 1054 :     //  Do this after copying data to caller's buffer so we can use struct fields
; 1055 :     //  rather than having to calculate offset to verified data; little harm done
; 1056 :     //  if it doesn't verify since we're toast if they're bad.
; 1057 : 
; 1058 :     memset(vtockey, 0x04, sizeof(vtockey));

  003e0	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR vtockey$[rsp]
  003e8	48 8b f8	 mov	 rdi, rax
  003eb	b8 04 00 00 00	 mov	 eax, 4
  003f0	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  003f5	f3 aa		 rep stosb

; 1059 :     if ((f4dscb->ds4fmtid != 0xf4) ||
; 1060 :         (f4dscb->ds4noext != 0x01) ||

  003f7	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR f4dscb$[rsp]
  003ff	0f b6 40 2c	 movzx	 eax, BYTE PTR [rax+44]
  00403	3d f4 00 00 00	 cmp	 eax, 244		; 000000f4H
  00408	75 33		 jne	 SHORT $LN9@getF4dscb
  0040a	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR f4dscb$[rsp]
  00412	0f b6 40 3b	 movzx	 eax, BYTE PTR [rax+59]
  00416	83 f8 01	 cmp	 eax, 1
  00419	75 22		 jne	 SHORT $LN9@getF4dscb
  0041b	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR f4dscb$[rsp]
  00423	41 b8 2c 00 00
	00		 mov	 r8d, 44			; 0000002cH
  00429	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR vtockey$[rsp]
  00431	48 8b c8	 mov	 rcx, rax
  00434	e8 00 00 00 00	 call	 memcmp
  00439	85 c0		 test	 eax, eax
  0043b	74 6f		 je	 SHORT $LN8@getF4dscb
$LN9@getF4dscb:

; 1061 :         (memcmp(&f4dscb->ds4keyid, vtockey, sizeof(vtockey))))
; 1062 :     {
; 1063 :         // "VTOC format id byte invalid (DS4IDFMT) %2.2X,\n"
; 1064 :         // "VTOC key invalid, or multi-extent VTOC"
; 1065 :         FWRMSG( stderr, HHC02670, "E", f4dscb->ds4fmtid );

  0043d	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR f4dscb$[rsp]
  00445	0f b6 40 2c	 movzx	 eax, BYTE PTR [rax+44]
  00449	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv236[rsp], eax
  00450	b9 02 00 00 00	 mov	 ecx, 2
  00455	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0045b	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv236[rsp]
  00462	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00466	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160327
  0046d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00472	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160328
  00479	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0047e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00483	41 b9 03 00 00
	00		 mov	 r9d, 3
  00489	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160329
  00490	ba 29 04 00 00	 mov	 edx, 1065		; 00000429H
  00495	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160330
  0049c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1066 :         return 3;

  004a2	b8 03 00 00 00	 mov	 eax, 3
  004a7	e9 85 01 00 00	 jmp	 $LN1@getF4dscb
$LN8@getF4dscb:

; 1067 :     }
; 1068 : 
; 1069 :     //  Display VTOC extent info (always one extent, never more)
; 1070 : 
; 1071 :     if (verbose > 1)

  004ac	83 bc 24 50 01
	00 00 01	 cmp	 DWORD PTR verbose$[rsp], 1
  004b4	0f 8e 75 01 00
	00		 jle	 $LN10@getF4dscb

; 1072 :     {
; 1073 :         // "VTOC start CCHH=%2.2X%2.2X %2.2X%2.2X end CCHH=%2.2X%2.2X %2.2X%2.2X"
; 1074 :         WRMSG( HHC02671, "I",

  004ba	b8 01 00 00 00	 mov	 eax, 1
  004bf	48 6b c0 01	 imul	 rax, rax, 1
  004c3	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR vtocx$[rsp]
  004cb	0f b6 44 01 08	 movzx	 eax, BYTE PTR [rcx+rax+8]
  004d0	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv251[rsp], eax
  004d7	b9 01 00 00 00	 mov	 ecx, 1
  004dc	48 6b c9 00	 imul	 rcx, rcx, 0
  004e0	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR vtocx$[rsp]
  004e8	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  004ed	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR tv256[rsp], ecx
  004f4	ba 01 00 00 00	 mov	 edx, 1
  004f9	48 6b d2 01	 imul	 rdx, rdx, 1
  004fd	48 8b bc 24 48
	01 00 00	 mov	 rdi, QWORD PTR vtocx$[rsp]
  00505	0f b6 54 17 06	 movzx	 edx, BYTE PTR [rdi+rdx+6]
  0050a	89 94 24 ac 00
	00 00		 mov	 DWORD PTR tv261[rsp], edx
  00511	bf 01 00 00 00	 mov	 edi, 1
  00516	48 6b ff 00	 imul	 rdi, rdi, 0
  0051a	48 8b b4 24 48
	01 00 00	 mov	 rsi, QWORD PTR vtocx$[rsp]
  00522	0f b6 7c 3e 06	 movzx	 edi, BYTE PTR [rsi+rdi+6]
  00527	be 01 00 00 00	 mov	 esi, 1
  0052c	48 6b f6 01	 imul	 rsi, rsi, 1
  00530	4c 8b 84 24 48
	01 00 00	 mov	 r8, QWORD PTR vtocx$[rsp]
  00538	41 0f b6 74 30
	04		 movzx	 esi, BYTE PTR [r8+rsi+4]
  0053e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00544	4d 6b c0 00	 imul	 r8, r8, 0
  00548	4c 8b 8c 24 48
	01 00 00	 mov	 r9, QWORD PTR vtocx$[rsp]
  00550	47 0f b6 44 01
	04		 movzx	 r8d, BYTE PTR [r9+r8+4]
  00556	44 89 84 24 b0
	00 00 00	 mov	 DWORD PTR tv276[rsp], r8d
  0055e	41 b9 01 00 00
	00		 mov	 r9d, 1
  00564	4d 6b c9 01	 imul	 r9, r9, 1
  00568	4c 8b 94 24 48
	01 00 00	 mov	 r10, QWORD PTR vtocx$[rsp]
  00570	47 0f b6 4c 0a
	02		 movzx	 r9d, BYTE PTR [r10+r9+2]
  00576	44 89 8c 24 b4
	00 00 00	 mov	 DWORD PTR tv281[rsp], r9d
  0057e	41 ba 01 00 00
	00		 mov	 r10d, 1
  00584	4d 6b d2 00	 imul	 r10, r10, 0
  00588	4c 8b 9c 24 48
	01 00 00	 mov	 r11, QWORD PTR vtocx$[rsp]
  00590	47 0f b6 54 13
	02		 movzx	 r10d, BYTE PTR [r11+r10+2]
  00596	44 89 94 24 b8
	00 00 00	 mov	 DWORD PTR tv286[rsp], r10d
  0059e	b9 01 00 00 00	 mov	 ecx, 1
  005a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005a9	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv251[rsp]
  005b0	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  005b4	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv256[rsp]
  005bb	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  005bf	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv261[rsp]
  005c6	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  005ca	89 7c 24 58	 mov	 DWORD PTR [rsp+88], edi
  005ce	89 74 24 50	 mov	 DWORD PTR [rsp+80], esi
  005d2	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv276[rsp]
  005d9	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  005dd	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv281[rsp]
  005e4	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005e8	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv286[rsp]
  005ef	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160332
  005fa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160333
  00606	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0060b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00610	41 b9 03 00 00
	00		 mov	 r9d, 3
  00616	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160334
  0061d	ba 36 04 00 00	 mov	 edx, 1078		; 00000436H
  00622	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160335
  00629	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN10@getF4dscb:

; 1075 :             vtocx->xtbcyl[0], vtocx->xtbcyl[1],
; 1076 :             vtocx->xtbtrk[0], vtocx->xtbtrk[1],
; 1077 :             vtocx->xtecyl[0], vtocx->xtecyl[1],
; 1078 :             vtocx->xtetrk[0], vtocx->xtetrk[1]);
; 1079 :     }
; 1080 :     return 0;

  0062f	33 c0		 xor	 eax, eax
$LN1@getF4dscb:

; 1081 : }

  00631	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00639	48 33 cc	 xor	 rcx, rsp
  0063c	e8 00 00 00 00	 call	 __security_check_cookie
  00641	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00648	5f		 pop	 rdi
  00649	5e		 pop	 rsi
  0064a	c3		 ret	 0
getF4dscb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdseq.c
_TEXT	SEGMENT
f3kl$ = 96
rec$ = 97
head$ = 98
f3dl$ = 100
cyl$ = 104
rc$ = 108
tv84 = 112
tv86 = 116
tv158 = 120
tv160 = 124
tv203 = 128
f3key$ = 136
f3data$ = 144
cif$ = 192
f3cchhr$ = 200
f3dscb$ = 208
verbose$ = 216
getF3dscb PROC

; 1253 : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 1254 :     int     rc;
; 1255 :     U32     cyl;
; 1256 :     U8      head, rec;
; 1257 :     void    *f3key, *f3data;
; 1258 :     U8      f3kl;
; 1259 :     U16     f3dl;
; 1260 : 
; 1261 :     cyl = (f3cchhr[0] << 8) | f3cchhr[1];

  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	48 6b c0 00	 imul	 rax, rax, 0
  00026	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR f3cchhr$[rsp]
  0002e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00032	c1 e0 08	 shl	 eax, 8
  00035	b9 01 00 00 00	 mov	 ecx, 1
  0003a	48 6b c9 01	 imul	 rcx, rcx, 1
  0003e	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR f3cchhr$[rsp]
  00046	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0004a	0b c1		 or	 eax, ecx
  0004c	89 44 24 68	 mov	 DWORD PTR cyl$[rsp], eax

; 1262 :     head = (f3cchhr[2] << 8) | f3cchhr[3];

  00050	b8 01 00 00 00	 mov	 eax, 1
  00055	48 6b c0 02	 imul	 rax, rax, 2
  00059	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR f3cchhr$[rsp]
  00061	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00065	c1 e0 08	 shl	 eax, 8
  00068	b9 01 00 00 00	 mov	 ecx, 1
  0006d	48 6b c9 03	 imul	 rcx, rcx, 3
  00071	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR f3cchhr$[rsp]
  00079	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0007d	0b c1		 or	 eax, ecx
  0007f	88 44 24 62	 mov	 BYTE PTR head$[rsp], al

; 1263 :     rec = f3cchhr[4];

  00083	b8 01 00 00 00	 mov	 eax, 1
  00088	48 6b c0 04	 imul	 rax, rax, 4
  0008c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR f3cchhr$[rsp]
  00094	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00098	88 44 24 61	 mov	 BYTE PTR rec$[rsp], al

; 1264 : 
; 1265 :     if (verbose)

  0009c	83 bc 24 d8 00
	00 00 00	 cmp	 DWORD PTR verbose$[rsp], 0
  000a4	74 71		 je	 SHORT $LN2@getF3dscb

; 1266 :     {
; 1267 :         // "reading Format 3 DSCB - CCHHR %04X%04X%02X"
; 1268 :         WRMSG( HHC02662, "I", cyl, head, rec );

  000a6	0f b6 44 24 61	 movzx	 eax, BYTE PTR rec$[rsp]
  000ab	89 44 24 70	 mov	 DWORD PTR tv84[rsp], eax
  000af	0f b6 4c 24 62	 movzx	 ecx, BYTE PTR head$[rsp]
  000b4	89 4c 24 74	 mov	 DWORD PTR tv86[rsp], ecx
  000b8	b9 01 00 00 00	 mov	 ecx, 1
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000c3	8b 4c 24 70	 mov	 ecx, DWORD PTR tv84[rsp]
  000c7	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  000cb	8b 4c 24 74	 mov	 ecx, DWORD PTR tv86[rsp]
  000cf	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000d3	8b 4c 24 68	 mov	 ecx, DWORD PTR cyl$[rsp]
  000d7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160447
  000e2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160448
  000ee	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000f3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f8	41 b9 03 00 00
	00		 mov	 r9d, 3
  000fe	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160449
  00105	ba f4 04 00 00	 mov	 edx, 1268		; 000004f4H
  0010a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160450
  00111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN2@getF3dscb:

; 1269 :     }
; 1270 : 
; 1271 :     rc = read_block (cif, cyl, head, rec,

  00117	48 8d 44 24 64	 lea	 rax, QWORD PTR f3dl$[rsp]
  0011c	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00121	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR f3data$[rsp]
  00129	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0012e	48 8d 44 24 60	 lea	 rax, QWORD PTR f3kl$[rsp]
  00133	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00138	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR f3key$[rsp]
  00140	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00145	44 0f b6 4c 24
	61		 movzx	 r9d, BYTE PTR rec$[rsp]
  0014b	44 0f b6 44 24
	62		 movzx	 r8d, BYTE PTR head$[rsp]
  00151	8b 54 24 68	 mov	 edx, DWORD PTR cyl$[rsp]
  00155	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  0015d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_block
  00163	89 44 24 6c	 mov	 DWORD PTR rc$[rsp], eax

; 1272 :                 (void *)&f3key, &f3kl,
; 1273 :                 (void *)&f3data, &f3dl);
; 1274 :     if (rc)

  00167	83 7c 24 6c 00	 cmp	 DWORD PTR rc$[rsp], 0
  0016c	74 7d		 je	 SHORT $LN3@getF3dscb

; 1275 :     {
; 1276 :         // "In %s: function %s rc %d%s"
; 1277 :         FWRMSG( stderr, HHC02477, "E", "getF3dscb()", "read_block()", rc,

  0016e	b9 02 00 00 00	 mov	 ecx, 2
  00173	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00179	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160452
  00180	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00185	8b 4c 24 6c	 mov	 ecx, DWORD PTR rc$[rsp]
  00189	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0018d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160453
  00194	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00199	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160454
  001a0	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160455
  001ac	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160456
  001b8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c2	41 b9 03 00 00
	00		 mov	 r9d, 3
  001c8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160457
  001cf	ba fe 04 00 00	 mov	 edx, 1278		; 000004feH
  001d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160458
  001db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1278 :                             ", attempting to read Format 3 DSCB");
; 1279 :         return 1;

  001e1	b8 01 00 00 00	 mov	 eax, 1
  001e6	e9 f4 01 00 00	 jmp	 $LN1@getF3dscb
$LN3@getF3dscb:

; 1280 :     }
; 1281 :     if ((f3kl != 44) || (f3dl != 96))

  001eb	0f b6 44 24 60	 movzx	 eax, BYTE PTR f3kl$[rsp]
  001f0	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  001f3	75 0a		 jne	 SHORT $LN5@getF3dscb
  001f5	0f b7 44 24 64	 movzx	 eax, WORD PTR f3dl$[rsp]
  001fa	83 f8 60	 cmp	 eax, 96			; 00000060H
  001fd	74 7f		 je	 SHORT $LN4@getF3dscb
$LN5@getF3dscb:

; 1282 :     {
; 1283 :         // "Length invalid for KEY %d or DATA %d%s"
; 1284 :         FWRMSG( stderr, HHC02478, "E", f3kl, f3dl, " received for Format 3 DSCB");

  001ff	0f b7 44 24 64	 movzx	 eax, WORD PTR f3dl$[rsp]
  00204	89 44 24 78	 mov	 DWORD PTR tv158[rsp], eax
  00208	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR f3kl$[rsp]
  0020d	89 4c 24 7c	 mov	 DWORD PTR tv160[rsp], ecx
  00211	b9 02 00 00 00	 mov	 ecx, 2
  00216	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0021c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160461
  00223	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00228	8b 4c 24 78	 mov	 ecx, DWORD PTR tv158[rsp]
  0022c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00230	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv160[rsp]
  00234	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00238	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160462
  0023f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00244	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160463
  0024b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00250	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00255	41 b9 03 00 00
	00		 mov	 r9d, 3
  0025b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160464
  00262	ba 04 05 00 00	 mov	 edx, 1284		; 00000504H
  00267	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160465
  0026e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1285 :         return 2;

  00274	b8 02 00 00 00	 mov	 eax, 2
  00279	e9 61 01 00 00	 jmp	 $LN1@getF3dscb
$LN4@getF3dscb:

; 1286 :     }
; 1287 :     memcpy((void *) &f3dscb->ds3keyid,

  0027e	0f b6 44 24 60	 movzx	 eax, BYTE PTR f3kl$[rsp]
  00283	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR f3dscb$[rsp]
  0028b	48 8b bc 24 d0
	00 00 00	 mov	 rdi, QWORD PTR f3dscb$[rsp]
  00293	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR f3key$[rsp]
  0029b	8b c8		 mov	 ecx, eax
  0029d	f3 a4		 rep movsb

; 1288 :                 f3key, f3kl);           // copy F3 key to buffer
; 1289 :     memcpy((void *) ((BYTE*)f3dscb + f3kl),

  0029f	0f b7 44 24 64	 movzx	 eax, WORD PTR f3dl$[rsp]
  002a4	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR f3kl$[rsp]
  002a9	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR f3dscb$[rsp]
  002b1	48 03 d1	 add	 rdx, rcx
  002b4	48 8b ca	 mov	 rcx, rdx
  002b7	48 8b f9	 mov	 rdi, rcx
  002ba	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR f3data$[rsp]
  002c2	8b c8		 mov	 ecx, eax
  002c4	f3 a4		 rep movsb

; 1290 :                 f3data, f3dl);          // copy F3 data to buffer
; 1291 : 
; 1292 :     if (verbose > 1)

  002c6	83 bc 24 d8 00
	00 00 01	 cmp	 DWORD PTR verbose$[rsp], 1
  002ce	7e 66		 jle	 SHORT $LN6@getF3dscb

; 1293 :     {
; 1294 :         // "%s"
; 1295 :         WRMSG( HHC02681, "I", "Format 3 DSCB:" );

  002d0	b9 01 00 00 00	 mov	 ecx, 1
  002d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160467
  002e2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160468
  002ee	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160469
  002fa	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002ff	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00304	41 b9 03 00 00
	00		 mov	 r9d, 3
  0030a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160470
  00311	ba 0f 05 00 00	 mov	 edx, 1295		; 0000050fH
  00316	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160471
  0031d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1296 :         data_dump((void *) f3dscb, sizeof(FORMAT3_DSCB));

  00323	ba 8c 00 00 00	 mov	 edx, 140		; 0000008cH
  00328	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR f3dscb$[rsp]
  00330	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump
$LN6@getF3dscb:

; 1297 :     }
; 1298 : 
; 1299 :     //  Verify DS3FMTID byte = x'F3'
; 1300 :     //  Do this after copying data to caller's buffer so we can use struct fields
; 1301 :     //  rather than having to calculate offset to verified data; little harm done
; 1302 :     //  if it doesn't verify since we're toast if it's bad.
; 1303 : 
; 1304 :     if (f3dscb->ds3fmtid != 0xf3)

  00336	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR f3dscb$[rsp]
  0033e	0f b6 40 2c	 movzx	 eax, BYTE PTR [rax+44]
  00342	3d f3 00 00 00	 cmp	 eax, 243		; 000000f3H
  00347	0f 84 90 00 00
	00		 je	 $LN7@getF3dscb

; 1305 :     {
; 1306 :         // "In %s: x'F%s' expected for DS%sIDFMT, received x'%02X'"
; 1307 :         FWRMSG( stderr, HHC02479, "E", "getF3dscb()", "3", "3", f3dscb->ds3fmtid);

  0034d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR f3dscb$[rsp]
  00355	0f b6 40 2c	 movzx	 eax, BYTE PTR [rax+44]
  00359	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv203[rsp], eax
  00360	b9 02 00 00 00	 mov	 ecx, 2
  00365	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0036b	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv203[rsp]
  00372	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00376	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160473
  0037d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00382	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160474
  00389	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0038e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160475
  00395	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0039a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160476
  003a1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160477
  003ad	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003b2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003b7	41 b9 03 00 00
	00		 mov	 r9d, 3
  003bd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160478
  003c4	ba 1b 05 00 00	 mov	 edx, 1307		; 0000051bH
  003c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160479
  003d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1308 :         return 2;

  003d6	b8 02 00 00 00	 mov	 eax, 2
  003db	eb 02		 jmp	 SHORT $LN1@getF3dscb
$LN7@getF3dscb:

; 1309 :     }
; 1310 :     return 0;

  003dd	33 c0		 xor	 eax, eax
$LN1@getF3dscb:

; 1311 : }

  003df	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  003e6	5f		 pop	 rdi
  003e7	5e		 pop	 rsi
  003e8	c3		 ret	 0
getF3dscb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdseq.c
_TEXT	SEGMENT
f1kl$ = 96
rec$ = 97
head$ = 98
f1dl$ = 100
rc$ = 104
vtocextents$ = 108
cyl$ = 112
tv215 = 116
tv217 = 120
tv245 = 124
f1key$ = 128
f1data$ = 136
zdsn$ = 144
edsn$ = 192
__$ArrayPad$ = 240
cif$ = 288
pdsn$ = 296
f1dscb$ = 304
vtocext$ = 312
verbose$ = 320
getF1dscb PROC

; 1114 : {

$LN13:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1115 :     char    zdsn[sizeof(f1dscb->ds1dsnam) + 1];     // zASCII dsn
; 1116 :     BYTE    edsn[sizeof(f1dscb->ds1dsnam)];         // EBCDIC dsn
; 1117 :     void    *f1key, *f1data;
; 1118 :     U8      f1kl;
; 1119 :     U16     f1dl;
; 1120 :     U32     cyl;
; 1121 :     U8      head;
; 1122 :     U8      rec;
; 1123 :     int     rc;
; 1124 :     int     vtocextents = 1;        // VTOC has only one extent

  0002f	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR vtocextents$[rsp], 1

; 1125 : 
; 1126 :     //  Locate dataset's F1 DSCB
; 1127 : 
; 1128 :     memset(zdsn, 0, sizeof(zdsn));

  00037	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR zdsn$[rsp]
  0003f	48 8b f8	 mov	 rdi, rax
  00042	33 c0		 xor	 eax, eax
  00044	b9 2d 00 00 00	 mov	 ecx, 45			; 0000002dH
  00049	f3 aa		 rep stosb

; 1129 :     STRLCPY( zdsn, *pdsn );

  0004b	41 b8 2d 00 00
	00		 mov	 r8d, 45			; 0000002dH
  00051	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR pdsn$[rsp]
  00059	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0005c	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR zdsn$[rsp]
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1130 :     string_to_upper( zdsn );

  0006a	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR zdsn$[rsp]
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_string_to_upper

; 1131 :     convert_to_ebcdic( edsn, sizeof( edsn ), zdsn );

  00078	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR zdsn$[rsp]
  00080	ba 2c 00 00 00	 mov	 edx, 44			; 0000002cH
  00085	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR edsn$[rsp]
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_to_ebcdic

; 1132 :     if (verbose)

  00093	83 bc 24 40 01
	00 00 00	 cmp	 DWORD PTR verbose$[rsp], 0
  0009b	74 54		 je	 SHORT $LN2@getF1dscb

; 1133 :     {
; 1134 :         // "searching VTOC for '%s'"
; 1135 :         WRMSG( HHC02692, "I", zdsn );

  0009d	b9 01 00 00 00	 mov	 ecx, 1
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000a8	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR zdsn$[rsp]
  000b0	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160367
  000bc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160368
  000c8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000cd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d2	41 b9 03 00 00
	00		 mov	 r9d, 3
  000d8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160369
  000df	ba 6f 04 00 00	 mov	 edx, 1135		; 0000046fH
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160370
  000eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN2@getF1dscb:

; 1136 :     }
; 1137 :     rc = search_key_equal(cif, edsn, sizeof(edsn),

  000f1	48 8d 44 24 61	 lea	 rax, QWORD PTR rec$[rsp]
  000f6	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  000fb	48 8d 44 24 62	 lea	 rax, QWORD PTR head$[rsp]
  00100	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00105	48 8d 44 24 70	 lea	 rax, QWORD PTR cyl$[rsp]
  0010a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0010f	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR vtocext$[rsp]
  00117	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011c	44 8b 4c 24 6c	 mov	 r9d, DWORD PTR vtocextents$[rsp]
  00121	41 b0 2c	 mov	 r8b, 44			; 0000002cH
  00124	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR edsn$[rsp]
  0012c	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00134	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_search_key_equal
  0013a	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax

; 1138 :                         vtocextents, (DSXTENT *)vtocext,
; 1139 :                         &cyl, &head, &rec);
; 1140 :     if (rc)

  0013e	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  00143	0f 84 28 01 00
	00		 je	 $LN3@getF1dscb

; 1141 :     {
; 1142 :         if (verbose)

  00149	83 bc 24 40 01
	00 00 00	 cmp	 DWORD PTR verbose$[rsp], 0
  00151	0f 84 b5 00 00
	00		 je	 $LN4@getF1dscb

; 1143 :         {
; 1144 :             // "search_key_equal rc %d"
; 1145 :             WRMSG( HHC02693, "I", rc );

  00157	b9 01 00 00 00	 mov	 ecx, 1
  0015c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00162	8b 4c 24 68	 mov	 ecx, DWORD PTR rc$[rsp]
  00166	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0016a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160373
  00171	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00176	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160374
  0017d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00182	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00187	41 b9 03 00 00
	00		 mov	 r9d, 3
  0018d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160375
  00194	ba 79 04 00 00	 mov	 edx, 1145		; 00000479H
  00199	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160376
  001a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1146 :             // "%s"
; 1147 :             WRMSG( HHC02681, "I", "KEY:" );

  001a6	b9 01 00 00 00	 mov	 ecx, 1
  001ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160377
  001b8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160378
  001c4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160379
  001d0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001d5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001da	41 b9 03 00 00
	00		 mov	 r9d, 3
  001e0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160380
  001e7	ba 7b 04 00 00	 mov	 edx, 1147		; 0000047bH
  001ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160381
  001f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1148 :             data_dump(edsn, sizeof(edsn));

  001f9	ba 2c 00 00 00	 mov	 edx, 44			; 0000002cH
  001fe	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR edsn$[rsp]
  00206	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump
$LN4@getF1dscb:

; 1149 :         }
; 1150 :         if (rc == 1)

  0020c	83 7c 24 68 01	 cmp	 DWORD PTR rc$[rsp], 1
  00211	75 54		 jne	 SHORT $LN5@getF1dscb

; 1151 :         {
; 1152 :             // "Dataset %s not found"
; 1153 :             FWRMSG( stderr, HHC02476, "E", zdsn);

  00213	b9 02 00 00 00	 mov	 ecx, 2
  00218	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0021e	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR zdsn$[rsp]
  00226	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0022b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160383
  00232	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00237	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160384
  0023e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00243	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00248	41 b9 03 00 00
	00		 mov	 r9d, 3
  0024e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160385
  00255	ba 81 04 00 00	 mov	 edx, 1153		; 00000481H
  0025a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160386
  00261	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@getF1dscb:

; 1154 :         }
; 1155 :         return 1;

  00267	b8 01 00 00 00	 mov	 eax, 1
  0026c	e9 1c 03 00 00	 jmp	 $LN1@getF1dscb
$LN3@getF1dscb:

; 1156 :     }
; 1157 : 
; 1158 :     //  Read F1 DSCB describing dataset
; 1159 : 
; 1160 :     if (verbose)

  00271	83 bc 24 40 01
	00 00 00	 cmp	 DWORD PTR verbose$[rsp], 0
  00279	74 53		 je	 SHORT $LN6@getF1dscb

; 1161 :     {
; 1162 :         // "%s"
; 1163 :         WRMSG( HHC02681, "I", "reading Format 1 DSCB" );

  0027b	b9 01 00 00 00	 mov	 ecx, 1
  00280	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00286	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160388
  0028d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00292	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160389
  00299	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0029e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160390
  002a5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002aa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002af	41 b9 03 00 00
	00		 mov	 r9d, 3
  002b5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160391
  002bc	ba 8b 04 00 00	 mov	 edx, 1163		; 0000048bH
  002c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160392
  002c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN6@getF1dscb:

; 1164 :     }
; 1165 :     rc = read_block(cif, cyl, head, rec,

  002ce	48 8d 44 24 64	 lea	 rax, QWORD PTR f1dl$[rsp]
  002d3	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  002d8	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR f1data$[rsp]
  002e0	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  002e5	48 8d 44 24 60	 lea	 rax, QWORD PTR f1kl$[rsp]
  002ea	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002ef	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR f1key$[rsp]
  002f7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002fc	44 0f b6 4c 24
	61		 movzx	 r9d, BYTE PTR rec$[rsp]
  00302	44 0f b6 44 24
	62		 movzx	 r8d, BYTE PTR head$[rsp]
  00308	8b 54 24 70	 mov	 edx, DWORD PTR cyl$[rsp]
  0030c	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00314	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_block
  0031a	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax

; 1166 :                 (void *)&f1key, &f1kl,
; 1167 :                 (void *) &f1data, &f1dl);
; 1168 :     if (rc)

  0031e	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  00323	74 7d		 je	 SHORT $LN7@getF1dscb

; 1169 :     {
; 1170 :         // "In %s: function %s rc %d%s"
; 1171 :         FWRMSG( stderr, HHC02477, "E", "getF1dscb()", "read_block()", rc,

  00325	b9 02 00 00 00	 mov	 ecx, 2
  0032a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00330	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160394
  00337	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0033c	8b 4c 24 68	 mov	 ecx, DWORD PTR rc$[rsp]
  00340	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00344	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160395
  0034b	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00350	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160396
  00357	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0035c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160397
  00363	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00368	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160398
  0036f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00374	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00379	41 b9 03 00 00
	00		 mov	 r9d, 3
  0037f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160399
  00386	ba 94 04 00 00	 mov	 edx, 1172		; 00000494H
  0038b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160400
  00392	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1172 :                             ", attempting to read Format 1 DSCB");
; 1173 :         return 2;

  00398	b8 02 00 00 00	 mov	 eax, 2
  0039d	e9 eb 01 00 00	 jmp	 $LN1@getF1dscb
$LN7@getF1dscb:

; 1174 :     }
; 1175 : 
; 1176 :     //  Return data to caller
; 1177 : 
; 1178 :     if ((f1kl == sizeof(f1dscb->ds1dsnam)) &&

  003a2	0f b6 44 24 60	 movzx	 eax, BYTE PTR f1kl$[rsp]
  003a7	48 83 f8 2c	 cmp	 rax, 44			; 0000002cH
  003ab	75 4e		 jne	 SHORT $LN8@getF1dscb
  003ad	0f b7 44 24 64	 movzx	 eax, WORD PTR f1dl$[rsp]
  003b2	48 83 f8 60	 cmp	 rax, 96			; 00000060H
  003b6	75 43		 jne	 SHORT $LN8@getF1dscb

; 1179 :         (f1dl == (sizeof(FORMAT1_DSCB) - sizeof(f1dscb->ds1dsnam))))
; 1180 :     {
; 1181 :         memcpy((void *) &f1dscb->ds1dsnam,

  003b8	0f b6 44 24 60	 movzx	 eax, BYTE PTR f1kl$[rsp]
  003bd	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  003c5	48 8b bc 24 30
	01 00 00	 mov	 rdi, QWORD PTR f1dscb$[rsp]
  003cd	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR f1key$[rsp]
  003d5	8b c8		 mov	 ecx, eax
  003d7	f3 a4		 rep movsb

; 1182 :                 f1key, f1kl);           // copy F1 key to buffer
; 1183 :         memcpy((void *) &f1dscb->ds1fmtid,

  003d9	0f b7 44 24 64	 movzx	 eax, WORD PTR f1dl$[rsp]
  003de	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  003e6	48 83 c1 2c	 add	 rcx, 44			; 0000002cH
  003ea	48 8b f9	 mov	 rdi, rcx
  003ed	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR f1data$[rsp]
  003f5	8b c8		 mov	 ecx, eax
  003f7	f3 a4		 rep movsb

; 1184 :                 f1data, f1dl);          // copy F1 data to buffer
; 1185 :     }

  003f9	eb 7f		 jmp	 SHORT $LN9@getF1dscb
$LN8@getF1dscb:

; 1186 :     else
; 1187 :     {
; 1188 :         // "Length invalid for KEY %d or DATA %d%s"
; 1189 :         FWRMSG( stderr, HHC02478, "E", f1kl, f1dl, " received for Format 1 DSCB");

  003fb	0f b7 44 24 64	 movzx	 eax, WORD PTR f1dl$[rsp]
  00400	89 44 24 74	 mov	 DWORD PTR tv215[rsp], eax
  00404	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR f1kl$[rsp]
  00409	89 4c 24 78	 mov	 DWORD PTR tv217[rsp], ecx
  0040d	b9 02 00 00 00	 mov	 ecx, 2
  00412	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00418	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160403
  0041f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00424	8b 4c 24 74	 mov	 ecx, DWORD PTR tv215[rsp]
  00428	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0042c	8b 4c 24 78	 mov	 ecx, DWORD PTR tv217[rsp]
  00430	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00434	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160404
  0043b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00440	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160405
  00447	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0044c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00451	41 b9 03 00 00
	00		 mov	 r9d, 3
  00457	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160406
  0045e	ba a5 04 00 00	 mov	 edx, 1189		; 000004a5H
  00463	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160407
  0046a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1190 :         return 3;

  00470	b8 03 00 00 00	 mov	 eax, 3
  00475	e9 13 01 00 00	 jmp	 $LN1@getF1dscb
$LN9@getF1dscb:

; 1191 :     }
; 1192 : 
; 1193 :     if (verbose > 1)

  0047a	83 bc 24 40 01
	00 00 01	 cmp	 DWORD PTR verbose$[rsp], 1
  00482	7e 66		 jle	 SHORT $LN10@getF1dscb

; 1194 :     {
; 1195 :         // "%s"
; 1196 :         WRMSG( HHC02681, "I", "Format 1 DSCB:" );

  00484	b9 01 00 00 00	 mov	 ecx, 1
  00489	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0048f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160409
  00496	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0049b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160410
  004a2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160411
  004ae	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004b3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004b8	41 b9 03 00 00
	00		 mov	 r9d, 3
  004be	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160412
  004c5	ba ac 04 00 00	 mov	 edx, 1196		; 000004acH
  004ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160413
  004d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1197 :         data_dump((void *) f1dscb, sizeof(FORMAT1_DSCB));

  004d7	ba 8c 00 00 00	 mov	 edx, 140		; 0000008cH
  004dc	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  004e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump
$LN10@getF1dscb:

; 1198 :     }
; 1199 : 
; 1200 :     //  Verify DS1FMTID byte = x'F1'
; 1201 :     //  Do this after copying data to caller's buffer so we can use struct fields
; 1202 :     //  rather than having to calculate offset to verified data; little harm done
; 1203 :     //  if it doesn't verify since we're toast if it's bad.
; 1204 : 
; 1205 :     if (f1dscb->ds1fmtid != 0xf1)

  004ea	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR f1dscb$[rsp]
  004f2	0f b6 40 2c	 movzx	 eax, BYTE PTR [rax+44]
  004f6	3d f1 00 00 00	 cmp	 eax, 241		; 000000f1H
  004fb	0f 84 8a 00 00
	00		 je	 $LN11@getF1dscb

; 1206 :     {
; 1207 :         // "In %s: x'F%s' expected for DS%sIDFMT, received x'%02X'"
; 1208 :         FWRMSG( stderr, HHC02479, "E", "getF1dscb()", "1", "1", f1dscb->ds1fmtid);

  00501	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR f1dscb$[rsp]
  00509	0f b6 40 2c	 movzx	 eax, BYTE PTR [rax+44]
  0050d	89 44 24 7c	 mov	 DWORD PTR tv245[rsp], eax
  00511	b9 02 00 00 00	 mov	 ecx, 2
  00516	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0051c	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv245[rsp]
  00520	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00524	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160415
  0052b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00530	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160416
  00537	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0053c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160417
  00543	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00548	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160418
  0054f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00554	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160419
  0055b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00560	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00565	41 b9 03 00 00
	00		 mov	 r9d, 3
  0056b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160420
  00572	ba b8 04 00 00	 mov	 edx, 1208		; 000004b8H
  00577	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160421
  0057e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1209 :         return 4;

  00584	b8 04 00 00 00	 mov	 eax, 4
  00589	eb 02		 jmp	 SHORT $LN1@getF1dscb
$LN11@getF1dscb:

; 1210 :     }
; 1211 :     return 0;

  0058b	33 c0		 xor	 eax, eax
$LN1@getF1dscb:

; 1212 : }

  0058d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00595	48 33 cc	 xor	 rcx, rsp
  00598	e8 00 00 00 00	 call	 __security_check_cookie
  0059d	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  005a4	5f		 pop	 rdi
  005a5	5e		 pop	 rsi
  005a6	c3		 ret	 0
getF1dscb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdseq.c
_TEXT	SEGMENT
len$ = 64
rc$ = 68
tv128 = 72
plabel$ = 80
cif$ = 128
glbuf$ = 136
verbose$ = 144
getlabel PROC

; 925  : {

$LN7:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 926  :     int     rc;
; 927  :     U16     len;
; 928  :     void    *plabel;
; 929  : 
; 930  :     if (verbose)

  00015	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR verbose$[rsp], 0
  0001d	74 47		 je	 SHORT $LN2@getlabel

; 931  :     {
; 932  :         // "Reading volume label..."
; 933  :         WRMSG( HHC02661, "I" );

  0001f	b9 01 00 00 00	 mov	 ecx, 1
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160249
  00031	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160250
  0003d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00042	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00047	41 b9 03 00 00
	00		 mov	 r9d, 3
  0004d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160251
  00054	ba a5 03 00 00	 mov	 edx, 933		; 000003a5H
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160252
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN2@getlabel:

; 934  :     }
; 935  : 
; 936  :     rc = read_block(cif, 0, 0, 3, NULL, NULL, (void *) &plabel, &len);

  00066	48 8d 44 24 40	 lea	 rax, QWORD PTR len$[rsp]
  0006b	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00070	48 8d 44 24 50	 lea	 rax, QWORD PTR plabel$[rsp]
  00075	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0007a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00083	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0008c	41 b1 03	 mov	 r9b, 3
  0008f	45 33 c0	 xor	 r8d, r8d
  00092	33 d2		 xor	 edx, edx
  00094	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_block
  000a2	89 44 24 44	 mov	 DWORD PTR rc$[rsp], eax

; 937  :     if (rc)

  000a6	83 7c 24 44 00	 cmp	 DWORD PTR rc$[rsp], 0
  000ab	74 59		 je	 SHORT $LN3@getlabel

; 938  :     {
; 939  :         // "Error reading volume label, rc %d"
; 940  :         FWRMSG( stderr, HHC02663, "E", rc );

  000ad	b9 02 00 00 00	 mov	 ecx, 2
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b8	8b 4c 24 44	 mov	 ecx, DWORD PTR rc$[rsp]
  000bc	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160254
  000c7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160255
  000d3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000d8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000dd	41 b9 03 00 00
	00		 mov	 r9d, 3
  000e3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160256
  000ea	ba ac 03 00 00	 mov	 edx, 940		; 000003acH
  000ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160257
  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 941  :         return 1;

  000fc	b8 01 00 00 00	 mov	 eax, 1
  00101	e9 f5 00 00 00	 jmp	 $LN1@getlabel
$LN3@getlabel:

; 942  :     }
; 943  :     if (len != sizeof(DASD_VOL_LABEL))

  00106	0f b7 44 24 40	 movzx	 eax, WORD PTR len$[rsp]
  0010b	48 83 f8 50	 cmp	 rax, 80			; 00000050H
  0010f	74 62		 je	 SHORT $LN4@getlabel

; 944  :     {
; 945  :         // "Error: volume label is %d bytes long, not 80 bytes long"
; 946  :         FWRMSG( stderr, HHC02664, "E", len );

  00111	0f b7 44 24 40	 movzx	 eax, WORD PTR len$[rsp]
  00116	89 44 24 48	 mov	 DWORD PTR tv128[rsp], eax
  0011a	b9 02 00 00 00	 mov	 ecx, 2
  0011f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00125	8b 4c 24 48	 mov	 ecx, DWORD PTR tv128[rsp]
  00129	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0012d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160259
  00134	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00139	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160260
  00140	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00145	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0014a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00150	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160261
  00157	ba b2 03 00 00	 mov	 edx, 946		; 000003b2H
  0015c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160262
  00163	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 947  :         return 2;

  00169	b8 02 00 00 00	 mov	 eax, 2
  0016e	e9 88 00 00 00	 jmp	 $LN1@getlabel
$LN4@getlabel:

; 948  :     }
; 949  : 
; 950  :     memcpy((void *)glbuf, plabel, sizeof(DASD_VOL_LABEL));

  00173	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR glbuf$[rsp]
  0017b	48 8b 74 24 50	 mov	 rsi, QWORD PTR plabel$[rsp]
  00180	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00185	f3 a4		 rep movsb

; 951  : 
; 952  :     if (verbose > 1)

  00187	83 bc 24 90 00
	00 00 01	 cmp	 DWORD PTR verbose$[rsp], 1
  0018f	7e 68		 jle	 SHORT $LN5@getlabel

; 953  :     {
; 954  :         // "%s"
; 955  :         WRMSG( HHC02681, "I", "Volume label:" );

  00191	b9 01 00 00 00	 mov	 ecx, 1
  00196	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0019c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160264
  001a3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160265
  001af	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160266
  001bb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001c0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c5	41 b9 03 00 00
	00		 mov	 r9d, 3
  001cb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160267
  001d2	ba bb 03 00 00	 mov	 edx, 955		; 000003bbH
  001d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160268
  001de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 956  :         data_dump(glbuf, len);

  001e4	0f b7 44 24 40	 movzx	 eax, WORD PTR len$[rsp]
  001e9	8b d0		 mov	 edx, eax
  001eb	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR glbuf$[rsp]
  001f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump
$LN5@getlabel:

; 957  :     }
; 958  :     return 0;

  001f9	33 c0		 xor	 eax, eax
$LN1@getlabel:

; 959  : }

  001fb	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001ff	5f		 pop	 rdi
  00200	5e		 pop	 rsi
  00201	c3		 ret	 0
getlabel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdseq.c
_TEXT	SEGMENT
endcyl$ = 80
endtrk$ = 84
i$ = 112
heads$ = 120
extent$ = 128
startcyl$ = 136
starttrk$ = 144
size$ = 152
makext	PROC

; 869  : {

$LN4:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 870  :     int endcyl = ((startcyl * heads) + starttrk + size - 1) / heads;

  00016	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR startcyl$[rsp]
  0001d	0f af 44 24 78	 imul	 eax, DWORD PTR heads$[rsp]
  00022	03 84 24 90 00
	00 00		 add	 eax, DWORD PTR starttrk$[rsp]
  00029	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR size$[rsp]
  00030	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00034	99		 cdq
  00035	f7 7c 24 78	 idiv	 DWORD PTR heads$[rsp]
  00039	89 44 24 50	 mov	 DWORD PTR endcyl$[rsp], eax

; 871  :     int endtrk = ((startcyl * heads) + starttrk + size - 1) % heads;

  0003d	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR startcyl$[rsp]
  00044	0f af 44 24 78	 imul	 eax, DWORD PTR heads$[rsp]
  00049	03 84 24 90 00
	00 00		 add	 eax, DWORD PTR starttrk$[rsp]
  00050	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR size$[rsp]
  00057	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  0005b	99		 cdq
  0005c	f7 7c 24 78	 idiv	 DWORD PTR heads$[rsp]
  00060	8b c2		 mov	 eax, edx
  00062	89 44 24 54	 mov	 DWORD PTR endtrk$[rsp], eax

; 872  : 
; 873  :     if (i > (MAX_EXTENTS - 1))

  00066	83 7c 24 70 7a	 cmp	 DWORD PTR i$[rsp], 122	; 0000007aH
  0006b	7e 66		 jle	 SHORT $LN2@makext

; 874  :     {
; 875  :         // "%s: extent number parameter invalid %d; utility ends"
; 876  :         FWRMSG( stderr, HHC02491, "S", "makext()", i );

  0006d	b9 02 00 00 00	 mov	 ecx, 2
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00078	8b 4c 24 70	 mov	 ecx, DWORD PTR i$[rsp]
  0007c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00080	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160227
  00087	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0008c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160228
  00093	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00098	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160229
  0009f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000a4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a9	41 b9 03 00 00
	00		 mov	 r9d, 3
  000af	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160230
  000b6	ba 6c 03 00 00	 mov	 edx, 876		; 0000036cH
  000bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160231
  000c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 877  :         exit(4);

  000c8	b9 04 00 00 00	 mov	 ecx, 4
  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN2@makext:

; 878  :     }
; 879  : 
; 880  :     extent[i].xttype = 1;       // extent type

  000d3	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  000d8	48 6b c0 0a	 imul	 rax, rax, 10
  000dc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  000e4	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 881  :     extent[i].xtseqn = i;       // extent # (relative zero)

  000e8	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  000ed	48 6b c0 0a	 imul	 rax, rax, 10
  000f1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  000f9	0f b6 54 24 70	 movzx	 edx, BYTE PTR i$[rsp]
  000fe	88 54 01 01	 mov	 BYTE PTR [rcx+rax+1], dl

; 882  : 
; 883  :     // begin cyl
; 884  : 
; 885  :     extent[i].xtbcyl[0] = startcyl >> 8;

  00102	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR startcyl$[rsp]
  00109	c1 f8 08	 sar	 eax, 8
  0010c	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$[rsp]
  00111	48 6b c9 0a	 imul	 rcx, rcx, 10
  00115	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  0011d	48 03 d1	 add	 rdx, rcx
  00120	48 8b ca	 mov	 rcx, rdx
  00123	ba 01 00 00 00	 mov	 edx, 1
  00128	48 6b d2 00	 imul	 rdx, rdx, 0
  0012c	88 44 11 02	 mov	 BYTE PTR [rcx+rdx+2], al

; 886  :     extent[i].xtbcyl[1] = startcyl - ((startcyl / 256) * 256);

  00130	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR startcyl$[rsp]
  00137	99		 cdq
  00138	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0013e	03 c2		 add	 eax, edx
  00140	c1 f8 08	 sar	 eax, 8
  00143	69 c0 00 01 00
	00		 imul	 eax, eax, 256		; 00000100H
  00149	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR startcyl$[rsp]
  00150	2b c8		 sub	 ecx, eax
  00152	8b c1		 mov	 eax, ecx
  00154	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$[rsp]
  00159	48 6b c9 0a	 imul	 rcx, rcx, 10
  0015d	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00165	48 03 d1	 add	 rdx, rcx
  00168	48 8b ca	 mov	 rcx, rdx
  0016b	ba 01 00 00 00	 mov	 edx, 1
  00170	48 6b d2 01	 imul	 rdx, rdx, 1
  00174	88 44 11 02	 mov	 BYTE PTR [rcx+rdx+2], al

; 887  :     extent[i].xtbtrk[0] = starttrk >> 8;

  00178	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR starttrk$[rsp]
  0017f	c1 f8 08	 sar	 eax, 8
  00182	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$[rsp]
  00187	48 6b c9 0a	 imul	 rcx, rcx, 10
  0018b	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00193	48 03 d1	 add	 rdx, rcx
  00196	48 8b ca	 mov	 rcx, rdx
  00199	ba 01 00 00 00	 mov	 edx, 1
  0019e	48 6b d2 00	 imul	 rdx, rdx, 0
  001a2	88 44 11 04	 mov	 BYTE PTR [rcx+rdx+4], al

; 888  :     extent[i].xtbtrk[1] = starttrk - ((starttrk / 256) * 256);

  001a6	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR starttrk$[rsp]
  001ad	99		 cdq
  001ae	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  001b4	03 c2		 add	 eax, edx
  001b6	c1 f8 08	 sar	 eax, 8
  001b9	69 c0 00 01 00
	00		 imul	 eax, eax, 256		; 00000100H
  001bf	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR starttrk$[rsp]
  001c6	2b c8		 sub	 ecx, eax
  001c8	8b c1		 mov	 eax, ecx
  001ca	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$[rsp]
  001cf	48 6b c9 0a	 imul	 rcx, rcx, 10
  001d3	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  001db	48 03 d1	 add	 rdx, rcx
  001de	48 8b ca	 mov	 rcx, rdx
  001e1	ba 01 00 00 00	 mov	 edx, 1
  001e6	48 6b d2 01	 imul	 rdx, rdx, 1
  001ea	88 44 11 04	 mov	 BYTE PTR [rcx+rdx+4], al

; 889  : 
; 890  :     // end cyl
; 891  : 
; 892  :     extent[i].xtecyl[0] = endcyl >> 8;

  001ee	8b 44 24 50	 mov	 eax, DWORD PTR endcyl$[rsp]
  001f2	c1 f8 08	 sar	 eax, 8
  001f5	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$[rsp]
  001fa	48 6b c9 0a	 imul	 rcx, rcx, 10
  001fe	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00206	48 03 d1	 add	 rdx, rcx
  00209	48 8b ca	 mov	 rcx, rdx
  0020c	ba 01 00 00 00	 mov	 edx, 1
  00211	48 6b d2 00	 imul	 rdx, rdx, 0
  00215	88 44 11 06	 mov	 BYTE PTR [rcx+rdx+6], al

; 893  :     extent[i].xtecyl[1] = endcyl - ((endcyl / 256) * 256);

  00219	8b 44 24 50	 mov	 eax, DWORD PTR endcyl$[rsp]
  0021d	99		 cdq
  0021e	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00224	03 c2		 add	 eax, edx
  00226	c1 f8 08	 sar	 eax, 8
  00229	69 c0 00 01 00
	00		 imul	 eax, eax, 256		; 00000100H
  0022f	8b 4c 24 50	 mov	 ecx, DWORD PTR endcyl$[rsp]
  00233	2b c8		 sub	 ecx, eax
  00235	8b c1		 mov	 eax, ecx
  00237	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$[rsp]
  0023c	48 6b c9 0a	 imul	 rcx, rcx, 10
  00240	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00248	48 03 d1	 add	 rdx, rcx
  0024b	48 8b ca	 mov	 rcx, rdx
  0024e	ba 01 00 00 00	 mov	 edx, 1
  00253	48 6b d2 01	 imul	 rdx, rdx, 1
  00257	88 44 11 06	 mov	 BYTE PTR [rcx+rdx+6], al

; 894  :     extent[i].xtetrk[0] = endtrk >> 8;

  0025b	8b 44 24 54	 mov	 eax, DWORD PTR endtrk$[rsp]
  0025f	c1 f8 08	 sar	 eax, 8
  00262	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$[rsp]
  00267	48 6b c9 0a	 imul	 rcx, rcx, 10
  0026b	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00273	48 03 d1	 add	 rdx, rcx
  00276	48 8b ca	 mov	 rcx, rdx
  00279	ba 01 00 00 00	 mov	 edx, 1
  0027e	48 6b d2 00	 imul	 rdx, rdx, 0
  00282	88 44 11 08	 mov	 BYTE PTR [rcx+rdx+8], al

; 895  :     extent[i].xtetrk[1] = endtrk - ((endtrk / 256) * 256);  // end track

  00286	8b 44 24 54	 mov	 eax, DWORD PTR endtrk$[rsp]
  0028a	99		 cdq
  0028b	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00291	03 c2		 add	 eax, edx
  00293	c1 f8 08	 sar	 eax, 8
  00296	69 c0 00 01 00
	00		 imul	 eax, eax, 256		; 00000100H
  0029c	8b 4c 24 54	 mov	 ecx, DWORD PTR endtrk$[rsp]
  002a0	2b c8		 sub	 ecx, eax
  002a2	8b c1		 mov	 eax, ecx
  002a4	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$[rsp]
  002a9	48 6b c9 0a	 imul	 rcx, rcx, 10
  002ad	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  002b5	48 03 d1	 add	 rdx, rcx
  002b8	48 8b ca	 mov	 rcx, rdx
  002bb	ba 01 00 00 00	 mov	 edx, 1
  002c0	48 6b d2 01	 imul	 rdx, rdx, 1
  002c4	88 44 11 08	 mov	 BYTE PTR [rcx+rdx+8], al
$LN3@makext:

; 896  :     return;
; 897  : }

  002c8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002cc	c3		 ret	 0
makext	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdseq.c
_TEXT	SEGMENT
rec$ = 112
head$ = 113
offset$ = 116
trk$ = 120
lrecl$ = 124
len$ = 128
rc_copy$ = 132
f1dscb$ = 136
recs_written$ = 144
cyl$ = 148
pascii$ = 152
lstarvalid$ = 160
lstartrack$ = 164
lstarrec$ = 168
num_extents$ = 172
rc_rb$ = 176
trkconv$ = 180
rc$ = 184
buffer$ = 192
tv309 = 200
tv315 = 204
tv320 = 208
tv361 = 212
tv376 = 216
tv378 = 220
tv381 = 224
tv425 = 228
tv443 = 232
tv502 = 236
tv546 = 240
tv572 = 244
tv574 = 248
tv221 = 252
tv226 = 256
tv231 = 260
tv561 = 264
tv659 = 272
extent$ = 288
zdsn$ = 1520
msgbuf$ = 1568
__$ArrayPad$ = 1696
fout$ = 1744
cif$ = 1752
dadsm$ = 1760
tran$ = 1768
verbose$ = 1776
fbcopy	PROC

; 615  : {

$LN46:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec b8 06
	00 00		 sub	 rsp, 1720		; 000006b8H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 a0
	06 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 616  :     FORMAT1_DSCB    *f1dscb = &dadsm->f1buf;

  0002f	48 8b 84 24 e0
	06 00 00	 mov	 rax, QWORD PTR dadsm$[rsp]
  00037	48 05 72 01 00
	00		 add	 rax, 370		; 00000172H
  0003d	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR f1dscb$[rsp], rax

; 617  :     DSXTENT         extent[MAX_EXTENTS];
; 618  :     int     rc;
; 619  :     u_int   trk = 0, trkconv = 999;

  00045	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR trk$[rsp], 0
  0004d	c7 84 24 b4 00
	00 00 e7 03 00
	00		 mov	 DWORD PTR trkconv$[rsp], 999 ; 000003e7H

; 620  :     U8      rec = 1;

  00058	c6 44 24 70 01	 mov	 BYTE PTR rec$[rsp], 1

; 621  :     U32     cyl = 0;

  0005d	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR cyl$[rsp], 0

; 622  :     U8      head = 0;

  00068	c6 44 24 71 00	 mov	 BYTE PTR head$[rsp], 0

; 623  :     int     rc_rb;
; 624  :     U16     len, offset;
; 625  :     int     rc_copy = 0;

  0006d	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR rc_copy$[rsp], 0

; 626  :     int     recs_written = 0, lrecl, num_extents;

  00078	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR recs_written$[rsp], 0

; 627  :     u_int   lstartrack = 0, lstarrec = 0, lstarvalid = 0;

  00083	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR lstartrack$[rsp], 0
  0008e	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR lstarrec$[rsp], 0
  00099	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR lstarvalid$[rsp], 0

; 628  :     BYTE    *buffer;
; 629  :     char    *pascii = NULL;

  000a4	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pascii$[rsp], 0

; 630  :     char    zdsn[sizeof(f1dscb->ds1dsnam) + 1];     // ascii dsn
; 631  :     char    msgbuf[128];                            // message work area
; 632  : 
; 633  :     // Kludge to avoid rewriting this code (for now):
; 634  :     memcpy(&extent, (void *)&(dadsm->f1ext), sizeof(extent));

  000b0	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR extent$[rsp]
  000b8	48 8b 8c 24 e0
	06 00 00	 mov	 rcx, QWORD PTR dadsm$[rsp]
  000c0	48 8b f8	 mov	 rdi, rax
  000c3	48 8d b1 04 02
	00 00		 lea	 rsi, QWORD PTR [rcx+516]
  000ca	b9 ce 04 00 00	 mov	 ecx, 1230		; 000004ceH
  000cf	f3 a4		 rep movsb

; 635  : 
; 636  :     num_extents = f1dscb->ds1noepv;

  000d1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR f1dscb$[rsp]
  000d9	0f b6 40 3b	 movzx	 eax, BYTE PTR [rax+59]
  000dd	89 84 24 ac 00
	00 00		 mov	 DWORD PTR num_extents$[rsp], eax

; 637  :     lrecl = (f1dscb->ds1lrecl[0] << 8) | (f1dscb->ds1lrecl[1]);

  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 00	 imul	 rax, rax, 0
  000ed	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  000f5	0f b6 44 01 58	 movzx	 eax, BYTE PTR [rcx+rax+88]
  000fa	c1 e0 08	 shl	 eax, 8
  000fd	b9 01 00 00 00	 mov	 ecx, 1
  00102	48 6b c9 01	 imul	 rcx, rcx, 1
  00106	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR f1dscb$[rsp]
  0010e	0f b6 4c 0a 58	 movzx	 ecx, BYTE PTR [rdx+rcx+88]
  00113	0b c1		 or	 eax, ecx
  00115	89 44 24 7c	 mov	 DWORD PTR lrecl$[rsp], eax

; 638  : 
; 639  :     if (absvalid)

  00119	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR absvalid, 0
  00120	74 7c		 je	 SHORT $LN7@fbcopy

; 640  :     {
; 641  :         STRLCPY( zdsn, argdsn );

  00122	41 b8 2d 00 00
	00		 mov	 r8d, 45			; 0000002dH
  00128	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR argdsn
  0012f	48 8d 8c 24 f0
	05 00 00	 lea	 rcx, QWORD PTR zdsn$[rsp]
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 642  :         // "%s"
; 643  :         if (debug) WRMSG( HHC02677, "D", "absvalid" );

  0013d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  00144	74 53		 je	 SHORT $LN9@fbcopy
  00146	b9 01 00 00 00	 mov	 ecx, 1
  0014b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00151	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160063
  00158	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0015d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160064
  00164	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00169	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160065
  00170	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00175	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0017a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00180	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160066
  00187	ba 83 02 00 00	 mov	 edx, 643		; 00000283H
  0018c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160067
  00193	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@fbcopy:

; 644  :     }

  00199	e9 d2 00 00 00	 jmp	 $LN8@fbcopy
$LN7@fbcopy:

; 645  :     else
; 646  :     {
; 647  :         make_asciiz(zdsn, sizeof(zdsn),

  0019e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR f1dscb$[rsp]
  001a6	41 b9 2c 00 00
	00		 mov	 r9d, 44			; 0000002cH
  001ac	4c 8b c0	 mov	 r8, rax
  001af	ba 2d 00 00 00	 mov	 edx, 45			; 0000002dH
  001b4	48 8d 8c 24 f0
	05 00 00	 lea	 rcx, QWORD PTR zdsn$[rsp]
  001bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_make_asciiz

; 648  :                 f1dscb->ds1dsnam, sizeof(f1dscb->ds1dsnam));
; 649  :         if ((f1dscb->ds1lstar[0] !=0) ||
; 650  :                 (f1dscb->ds1lstar[1] != 0) ||

  001c2	b8 01 00 00 00	 mov	 eax, 1
  001c7	48 6b c0 00	 imul	 rax, rax, 0
  001cb	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  001d3	0f b6 44 01 62	 movzx	 eax, BYTE PTR [rcx+rax+98]
  001d8	85 c0		 test	 eax, eax
  001da	75 34		 jne	 SHORT $LN11@fbcopy
  001dc	b8 01 00 00 00	 mov	 eax, 1
  001e1	48 6b c0 01	 imul	 rax, rax, 1
  001e5	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  001ed	0f b6 44 01 62	 movzx	 eax, BYTE PTR [rcx+rax+98]
  001f2	85 c0		 test	 eax, eax
  001f4	75 1a		 jne	 SHORT $LN11@fbcopy
  001f6	b8 01 00 00 00	 mov	 eax, 1
  001fb	48 6b c0 02	 imul	 rax, rax, 2
  001ff	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  00207	0f b6 44 01 62	 movzx	 eax, BYTE PTR [rcx+rax+98]
  0020c	85 c0		 test	 eax, eax
  0020e	74 60		 je	 SHORT $LN10@fbcopy
$LN11@fbcopy:

; 651  :                 (f1dscb->ds1lstar[2] != 0))
; 652  :         {
; 653  :             lstartrack = (f1dscb->ds1lstar[0] << 8) | (f1dscb->ds1lstar[1]);

  00210	b8 01 00 00 00	 mov	 eax, 1
  00215	48 6b c0 00	 imul	 rax, rax, 0
  00219	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  00221	0f b6 44 01 62	 movzx	 eax, BYTE PTR [rcx+rax+98]
  00226	c1 e0 08	 shl	 eax, 8
  00229	b9 01 00 00 00	 mov	 ecx, 1
  0022e	48 6b c9 01	 imul	 rcx, rcx, 1
  00232	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR f1dscb$[rsp]
  0023a	0f b6 4c 0a 62	 movzx	 ecx, BYTE PTR [rdx+rcx+98]
  0023f	0b c1		 or	 eax, ecx
  00241	89 84 24 a4 00
	00 00		 mov	 DWORD PTR lstartrack$[rsp], eax

; 654  :             lstarrec = f1dscb->ds1lstar[2];

  00248	b8 01 00 00 00	 mov	 eax, 1
  0024d	48 6b c0 02	 imul	 rax, rax, 2
  00251	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  00259	0f b6 44 01 62	 movzx	 eax, BYTE PTR [rcx+rax+98]
  0025e	89 84 24 a8 00
	00 00		 mov	 DWORD PTR lstarrec$[rsp], eax

; 655  :             lstarvalid = 1;     // DS1LSTAR valid

  00265	c7 84 24 a0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR lstarvalid$[rsp], 1
$LN10@fbcopy:
$LN8@fbcopy:

; 656  :         }
; 657  :     }
; 658  : 
; 659  :     if (debug)

  00270	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  00277	0f 84 93 01 00
	00		 je	 $LN12@fbcopy

; 660  :     {
; 661  :         // HHC02674 "%s=%s"
; 662  :         // HHC02675 "%s=%d"
; 663  : 
; 664  :         WRMSG( HHC02674, "D", "zdsn",        zdsn        );

  0027d	b9 01 00 00 00	 mov	 ecx, 1
  00282	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00288	48 8d 8c 24 f0
	05 00 00	 lea	 rcx, QWORD PTR zdsn$[rsp]
  00290	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00295	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160071
  0029c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160072
  002a8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160073
  002b4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002b9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002be	41 b9 03 00 00
	00		 mov	 r9d, 3
  002c4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160074
  002cb	ba 98 02 00 00	 mov	 edx, 664		; 00000298H
  002d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160075
  002d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 665  :         WRMSG( HHC02675, "D", "num_extents", num_extents );

  002dd	b9 01 00 00 00	 mov	 ecx, 1
  002e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002e8	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR num_extents$[rsp]
  002ef	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160076
  002fa	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160077
  00306	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0030b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160078
  00312	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00317	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0031c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00322	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160079
  00329	ba 99 02 00 00	 mov	 edx, 665		; 00000299H
  0032e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160080
  00335	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 666  :         WRMSG( HHC02675, "D", "lrecl",       lrecl       );

  0033b	b9 01 00 00 00	 mov	 ecx, 1
  00340	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00346	8b 4c 24 7c	 mov	 ecx, DWORD PTR lrecl$[rsp]
  0034a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0034e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160081
  00355	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0035a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160082
  00361	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00366	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160083
  0036d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00372	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00377	41 b9 03 00 00
	00		 mov	 r9d, 3
  0037d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160084
  00384	ba 9a 02 00 00	 mov	 edx, 666		; 0000029aH
  00389	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160085
  00390	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 667  : 
; 668  :         // "%s"
; 669  :         WRMSG( HHC02677, "D", "Format 1 DSCB:" );

  00396	b9 01 00 00 00	 mov	 ecx, 1
  0039b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160086
  003a8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160087
  003b4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160088
  003c0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003c5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003ca	41 b9 03 00 00
	00		 mov	 r9d, 3
  003d0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160089
  003d7	ba 9d 02 00 00	 mov	 edx, 669		; 0000029dH
  003dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160090
  003e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 670  :         data_dump(f1dscb, sizeof(FORMAT1_DSCB));

  003e9	ba 8c 00 00 00	 mov	 edx, 140		; 0000008cH
  003ee	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  003f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump

; 671  : 
; 672  :         sayext( num_extents, (void*) &extent );

  003fc	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR extent$[rsp]
  00404	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR num_extents$[rsp]
  0040b	e8 00 00 00 00	 call	 sayext
$LN12@fbcopy:

; 673  :     }
; 674  : 
; 675  :     if (verbose)    // DS1LSTAR = last block written TTR

  00410	83 bc 24 f0 06
	00 00 00	 cmp	 DWORD PTR verbose$[rsp], 0
  00418	0f 84 e0 00 00
	00		 je	 $LN13@fbcopy

; 676  :     {
; 677  :         // HHC02683 "DS1LSTAR[%02X%02X%02X] lstartrack(%d) lstarrec(%d) lstarvalid(%d)"
; 678  :         WRMSG( HHC02683, "I",f1dscb->ds1lstar[0], f1dscb->ds1lstar[1],

  0041e	b8 01 00 00 00	 mov	 eax, 1
  00423	48 6b c0 02	 imul	 rax, rax, 2
  00427	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  0042f	0f b6 44 01 62	 movzx	 eax, BYTE PTR [rcx+rax+98]
  00434	89 84 24 fc 00
	00 00		 mov	 DWORD PTR tv221[rsp], eax
  0043b	b9 01 00 00 00	 mov	 ecx, 1
  00440	48 6b c9 01	 imul	 rcx, rcx, 1
  00444	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR f1dscb$[rsp]
  0044c	0f b6 4c 0a 62	 movzx	 ecx, BYTE PTR [rdx+rcx+98]
  00451	89 8c 24 00 01
	00 00		 mov	 DWORD PTR tv226[rsp], ecx
  00458	ba 01 00 00 00	 mov	 edx, 1
  0045d	48 6b d2 00	 imul	 rdx, rdx, 0
  00461	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR f1dscb$[rsp]
  00469	0f b6 54 17 62	 movzx	 edx, BYTE PTR [rdi+rdx+98]
  0046e	89 94 24 04 01
	00 00		 mov	 DWORD PTR tv231[rsp], edx
  00475	b9 01 00 00 00	 mov	 ecx, 1
  0047a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00480	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR lstarvalid$[rsp]
  00487	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  0048b	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR lstarrec$[rsp]
  00492	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00496	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR lstartrack$[rsp]
  0049d	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  004a1	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR tv221[rsp]
  004a8	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  004ac	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv226[rsp]
  004b3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  004b7	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR tv231[rsp]
  004be	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  004c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160092
  004c9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160093
  004d5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004df	41 b9 03 00 00
	00		 mov	 r9d, 3
  004e5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160094
  004ec	ba a7 02 00 00	 mov	 edx, 679		; 000002a7H
  004f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160095
  004f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN13@fbcopy:

; 679  :             f1dscb->ds1lstar[2], lstartrack, lstarrec, lstarvalid );
; 680  :     }
; 681  : 
; 682  :     if (tran)   // need ASCII translation buffer?

  004fe	83 bc 24 e8 06
	00 00 00	 cmp	 DWORD PTR tran$[rsp], 0
  00506	0f 84 81 00 00
	00		 je	 $LN14@fbcopy

; 683  :     {
; 684  :         pascii = malloc(lrecl + 1);

  0050c	8b 44 24 7c	 mov	 eax, DWORD PTR lrecl$[rsp]
  00510	ff c0		 inc	 eax
  00512	48 98		 cdqe
  00514	48 8b c8	 mov	 rcx, rax
  00517	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0051d	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pascii$[rsp], rax

; 685  :         if (pascii == NULL)

  00525	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR pascii$[rsp], 0
  0052e	75 5d		 jne	 SHORT $LN15@fbcopy

; 686  :         {
; 687  :             // "%s: unable to allocate ASCII buffer"
; 688  :             FWRMSG( stderr, HHC02489, "E", "fbcopy()" );

  00530	b9 02 00 00 00	 mov	 ecx, 2
  00535	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0053b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160098
  00542	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00547	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160099
  0054e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00553	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160100
  0055a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0055f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00564	41 b9 03 00 00
	00		 mov	 r9d, 3
  0056a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160101
  00571	ba b0 02 00 00	 mov	 edx, 688		; 000002b0H
  00576	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160102
  0057d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 689  :             return -1;

  00583	b8 ff ff ff ff	 mov	 eax, -1
  00588	e9 82 0b 00 00	 jmp	 $LN1@fbcopy
$LN15@fbcopy:
$LN14@fbcopy:
$LN45@fbcopy:
$LN2@fbcopy:

; 690  :         }
; 691  :     }
; 692  : 
; 693  :     while (1)   // output records until something stops us

  0058d	33 c0		 xor	 eax, eax
  0058f	83 f8 01	 cmp	 eax, 1
  00592	0f 84 57 0b 00
	00		 je	 $LN3@fbcopy

; 694  :     {
; 695  :         //  Honor DS1LSTAR when valid
; 696  : 
; 697  :         if ((lstarvalid) && (trk == lstartrack) && (rec > lstarrec))

  00598	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR lstarvalid$[rsp], 0
  005a0	0f 84 67 01 00
	00		 je	 $LN16@fbcopy
  005a6	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR lstartrack$[rsp]
  005ad	39 44 24 78	 cmp	 DWORD PTR trk$[rsp], eax
  005b1	0f 85 56 01 00
	00		 jne	 $LN16@fbcopy
  005b7	0f b6 44 24 70	 movzx	 eax, BYTE PTR rec$[rsp]
  005bc	3b 84 24 a8 00
	00 00		 cmp	 eax, DWORD PTR lstarrec$[rsp]
  005c3	0f 86 44 01 00
	00		 jbe	 $LN16@fbcopy

; 698  :         {
; 699  :             if (verbose)

  005c9	83 bc 24 f0 06
	00 00 00	 cmp	 DWORD PTR verbose$[rsp], 0
  005d1	0f 84 23 01 00
	00		 je	 $LN17@fbcopy

; 700  :             {
; 701  :                 // "%s"
; 702  :                 WRMSG( HHC02681, "I", "DS1LSTAR indicates EOF" );

  005d7	b9 01 00 00 00	 mov	 ecx, 1
  005dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160105
  005e9	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  005ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160106
  005f5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160107
  00601	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00606	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0060b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00611	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160108
  00618	ba be 02 00 00	 mov	 edx, 702		; 000002beH
  0061d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160109
  00624	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 703  :                 // HHC02684 "DS1LSTAR[%02X%02X%02X] track(%02X) record(%02X)"
; 704  :                 WRMSG( HHC02684, "I", f1dscb->ds1lstar[0], f1dscb->ds1lstar[1],

  0062a	0f b6 44 24 70	 movzx	 eax, BYTE PTR rec$[rsp]
  0062f	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv309[rsp], eax
  00636	b9 01 00 00 00	 mov	 ecx, 1
  0063b	48 6b c9 02	 imul	 rcx, rcx, 2
  0063f	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR f1dscb$[rsp]
  00647	0f b6 4c 0a 62	 movzx	 ecx, BYTE PTR [rdx+rcx+98]
  0064c	89 8c 24 cc 00
	00 00		 mov	 DWORD PTR tv315[rsp], ecx
  00653	ba 01 00 00 00	 mov	 edx, 1
  00658	48 6b d2 01	 imul	 rdx, rdx, 1
  0065c	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR f1dscb$[rsp]
  00664	0f b6 54 17 62	 movzx	 edx, BYTE PTR [rdi+rdx+98]
  00669	89 94 24 d0 00
	00 00		 mov	 DWORD PTR tv320[rsp], edx
  00670	bf 01 00 00 00	 mov	 edi, 1
  00675	48 6b ff 00	 imul	 rdi, rdi, 0
  00679	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR f1dscb$[rsp]
  00681	0f b6 7c 3e 62	 movzx	 edi, BYTE PTR [rsi+rdi+98]
  00686	b9 01 00 00 00	 mov	 ecx, 1
  0068b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00691	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv309[rsp]
  00698	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0069c	8b 4c 24 78	 mov	 ecx, DWORD PTR trk$[rsp]
  006a0	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  006a4	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv315[rsp]
  006ab	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  006af	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv320[rsp]
  006b6	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006ba	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  006be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160110
  006c5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160111
  006d1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006d6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006db	41 b9 03 00 00
	00		 mov	 r9d, 3
  006e1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160112
  006e8	ba c1 02 00 00	 mov	 edx, 705		; 000002c1H
  006ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160113
  006f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN17@fbcopy:

; 705  :                     f1dscb->ds1lstar[2], trk, rec );
; 706  :             }
; 707  :             rc_copy = recs_written;

  006fa	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR recs_written$[rsp]
  00701	89 84 24 84 00
	00 00		 mov	 DWORD PTR rc_copy$[rsp], eax

; 708  :             break;

  00708	e9 e2 09 00 00	 jmp	 $LN3@fbcopy
$LN16@fbcopy:

; 709  :         }
; 710  : 
; 711  :         //  Convert TT to CCHH for upcoming read_block call
; 712  : 
; 713  :         if (trkconv != trk)     // avoid converting for each block

  0070d	8b 44 24 78	 mov	 eax, DWORD PTR trk$[rsp]
  00711	39 84 24 b4 00
	00 00		 cmp	 DWORD PTR trkconv$[rsp], eax
  00718	0f 84 77 01 00
	00		 je	 $LN18@fbcopy

; 714  :         {
; 715  :             trkconv = trk;      // current track converted

  0071e	8b 44 24 78	 mov	 eax, DWORD PTR trk$[rsp]
  00722	89 84 24 b4 00
	00 00		 mov	 DWORD PTR trkconv$[rsp], eax

; 716  :             rc = convert_tt(trk, num_extents, extent, cif->heads, &cyl, &head);

  00729	48 8d 44 24 71	 lea	 rax, QWORD PTR head$[rsp]
  0072e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00733	48 8d 84 24 94
	00 00 00	 lea	 rax, QWORD PTR cyl$[rsp]
  0073b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00740	48 8b 84 24 d8
	06 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00748	44 0f b6 48 24	 movzx	 r9d, BYTE PTR [rax+36]
  0074d	4c 8d 84 24 20
	01 00 00	 lea	 r8, QWORD PTR extent$[rsp]
  00755	8b 94 24 ac 00
	00 00		 mov	 edx, DWORD PTR num_extents$[rsp]
  0075c	8b 4c 24 78	 mov	 ecx, DWORD PTR trk$[rsp]
  00760	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_tt
  00766	89 84 24 b8 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 717  :             if (rc < 0)

  0076d	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00775	0f 8d 97 00 00
	00		 jge	 $LN19@fbcopy

; 718  :             {
; 719  :                 // "%s: convert_tt() track %5.5d/x'%04X', rc %d"
; 720  :                 FWRMSG( stderr, HHC02490, "E", "fbcopy()", trk, trk, rc );

  0077b	b9 02 00 00 00	 mov	 ecx, 2
  00780	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00786	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR rc$[rsp]
  0078d	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00791	8b 4c 24 78	 mov	 ecx, DWORD PTR trk$[rsp]
  00795	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00799	8b 4c 24 78	 mov	 ecx, DWORD PTR trk$[rsp]
  0079d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  007a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160116
  007a8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  007ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160117
  007b4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160118
  007c0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007c5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007ca	41 b9 03 00 00
	00		 mov	 r9d, 3
  007d0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160119
  007d7	ba d0 02 00 00	 mov	 edx, 720		; 000002d0H
  007dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160120
  007e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 721  :                 if (absvalid)

  007e9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR absvalid, 0
  007f0	74 10		 je	 SHORT $LN20@fbcopy

; 722  :                     rc_copy = recs_written;

  007f2	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR recs_written$[rsp]
  007f9	89 84 24 84 00
	00 00		 mov	 DWORD PTR rc_copy$[rsp], eax
  00800	eb 0b		 jmp	 SHORT $LN21@fbcopy
$LN20@fbcopy:

; 723  :                 else
; 724  :                     rc_copy = -1;

  00802	c7 84 24 84 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR rc_copy$[rsp], -1
$LN21@fbcopy:

; 725  :                 break;

  0080d	e9 dd 08 00 00	 jmp	 $LN3@fbcopy
$LN19@fbcopy:

; 726  :             }
; 727  :             if (verbose > 1)

  00812	83 bc 24 f0 06
	00 00 01	 cmp	 DWORD PTR verbose$[rsp], 1
  0081a	7e 79		 jle	 SHORT $LN22@fbcopy

; 728  :             {
; 729  :                 // "Convert TT %5.5d/x'%04X' CCHH[%04X%04X]"
; 730  :                 WRMSG( HHC02685, "I", trk, trk, cyl, head );

  0081c	0f b6 44 24 71	 movzx	 eax, BYTE PTR head$[rsp]
  00821	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv361[rsp], eax
  00828	b9 01 00 00 00	 mov	 ecx, 1
  0082d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00833	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv361[rsp]
  0083a	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0083e	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR cyl$[rsp]
  00845	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00849	8b 4c 24 78	 mov	 ecx, DWORD PTR trk$[rsp]
  0084d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00851	8b 4c 24 78	 mov	 ecx, DWORD PTR trk$[rsp]
  00855	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00859	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160124
  00860	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00865	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160125
  0086c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00871	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00876	41 b9 03 00 00
	00		 mov	 r9d, 3
  0087c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160126
  00883	ba da 02 00 00	 mov	 edx, 730		; 000002daH
  00888	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160127
  0088f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN22@fbcopy:
$LN18@fbcopy:

; 731  :             }
; 732  :         }
; 733  : 
; 734  :         //  Read block from dasd
; 735  : 
; 736  :         if (verbose > 2)

  00895	83 bc 24 f0 06
	00 00 02	 cmp	 DWORD PTR verbose$[rsp], 2
  0089d	0f 8e b0 00 00
	00		 jle	 $LN23@fbcopy

; 737  :         {
; 738  :             // "Reading track %5.5d/x'%04X' record %d/x'%X' CCHHR[%04X%04X%02X]"
; 739  :             WRMSG( HHC02686, "I", trk, trk, rec, rec, cyl, head, rec );

  008a3	0f b6 44 24 70	 movzx	 eax, BYTE PTR rec$[rsp]
  008a8	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv376[rsp], eax
  008af	0f b6 4c 24 71	 movzx	 ecx, BYTE PTR head$[rsp]
  008b4	89 8c 24 dc 00
	00 00		 mov	 DWORD PTR tv378[rsp], ecx
  008bb	0f b6 54 24 70	 movzx	 edx, BYTE PTR rec$[rsp]
  008c0	89 94 24 e0 00
	00 00		 mov	 DWORD PTR tv381[rsp], edx
  008c7	0f b6 7c 24 70	 movzx	 edi, BYTE PTR rec$[rsp]
  008cc	b9 01 00 00 00	 mov	 ecx, 1
  008d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  008d7	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv376[rsp]
  008de	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  008e2	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv378[rsp]
  008e9	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  008ed	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR cyl$[rsp]
  008f4	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  008f8	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv381[rsp]
  008ff	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00903	89 7c 24 48	 mov	 DWORD PTR [rsp+72], edi
  00907	8b 4c 24 78	 mov	 ecx, DWORD PTR trk$[rsp]
  0090b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0090f	8b 4c 24 78	 mov	 ecx, DWORD PTR trk$[rsp]
  00913	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00917	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160129
  0091e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00923	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160130
  0092a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0092f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00934	41 b9 03 00 00
	00		 mov	 r9d, 3
  0093a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160131
  00941	ba e3 02 00 00	 mov	 edx, 739		; 000002e3H
  00946	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160132
  0094d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN23@fbcopy:

; 740  :         }
; 741  :         rc_rb = read_block(cif, cyl, head, rec, NULL, NULL, &buffer, &len);

  00953	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR len$[rsp]
  0095b	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00960	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR buffer$[rsp]
  00968	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0096d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00976	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0097f	44 0f b6 4c 24
	70		 movzx	 r9d, BYTE PTR rec$[rsp]
  00985	44 0f b6 44 24
	71		 movzx	 r8d, BYTE PTR head$[rsp]
  0098b	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR cyl$[rsp]
  00992	48 8b 8c 24 d8
	06 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  0099a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_block
  009a0	89 84 24 b0 00
	00 00		 mov	 DWORD PTR rc_rb$[rsp], eax

; 742  :         if (rc_rb < 0)          // error

  009a7	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR rc_rb$[rsp], 0
  009af	0f 8d a9 00 00
	00		 jge	 $LN24@fbcopy

; 743  :         {
; 744  :             // "In %s: function %s rc %d%s"
; 745  :             MSGBUF( msgbuf, ", error reading '%s'", zdsn );

  009b5	4c 8d 8c 24 f0
	05 00 00	 lea	 r9, QWORD PTR zdsn$[rsp]
  009bd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160134
  009c4	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  009c9	48 8d 8c 24 20
	06 00 00	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  009d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 746  :             FWRMSG( stderr, HHC02477, "E", "fbcopy()",

  009d7	b9 02 00 00 00	 mov	 ecx, 2
  009dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009e2	48 8d 8c 24 20
	06 00 00	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  009ea	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  009ef	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR rc_rb$[rsp]
  009f6	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  009fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160135
  00a01	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00a06	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160136
  00a0d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00a12	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160137
  00a19	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a1e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160138
  00a25	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a2a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a2f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a35	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160139
  00a3c	ba eb 02 00 00	 mov	 edx, 747		; 000002ebH
  00a41	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160140
  00a48	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 747  :                             "read_block()", rc_rb, msgbuf );
; 748  :             rc_copy = -1;

  00a4e	c7 84 24 84 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR rc_copy$[rsp], -1

; 749  :             break;

  00a59	e9 91 06 00 00	 jmp	 $LN3@fbcopy
$LN24@fbcopy:

; 750  :         }
; 751  : 
; 752  :         //  Handle end of track return from read_block
; 753  : 
; 754  :         if (rc_rb > 0)      // end of track

  00a5e	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR rc_rb$[rsp], 0
  00a66	0f 8e 98 00 00
	00		 jle	 $LN25@fbcopy

; 755  :         {
; 756  :             if (verbose > 2)

  00a6c	83 bc 24 f0 06
	00 00 02	 cmp	 DWORD PTR verbose$[rsp], 2
  00a74	7e 7a		 jle	 SHORT $LN26@fbcopy

; 757  :             {
; 758  :                 // "%s track %5.5d/x'%04X' rec %d"
; 759  :                 WRMSG( HHC02687, "I", "End of", trk, trk, rec );

  00a76	0f b6 44 24 70	 movzx	 eax, BYTE PTR rec$[rsp]
  00a7b	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv425[rsp], eax
  00a82	b9 01 00 00 00	 mov	 ecx, 1
  00a87	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a8d	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv425[rsp]
  00a94	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00a98	8b 4c 24 78	 mov	 ecx, DWORD PTR trk$[rsp]
  00a9c	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00aa0	8b 4c 24 78	 mov	 ecx, DWORD PTR trk$[rsp]
  00aa4	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00aa8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160143
  00aaf	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00ab4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160144
  00abb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00ac0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160145
  00ac7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00acc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ad1	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ad7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160146
  00ade	ba f7 02 00 00	 mov	 edx, 759		; 000002f7H
  00ae3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160147
  00aea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN26@fbcopy:

; 760  :             }
; 761  :             trk++;          // next track

  00af0	8b 44 24 78	 mov	 eax, DWORD PTR trk$[rsp]
  00af4	ff c0		 inc	 eax
  00af6	89 44 24 78	 mov	 DWORD PTR trk$[rsp], eax

; 762  :             rec = 1;        // record 1 on new track

  00afa	c6 44 24 70 01	 mov	 BYTE PTR rec$[rsp], 1

; 763  :             continue;

  00aff	e9 89 fa ff ff	 jmp	 $LN2@fbcopy
$LN25@fbcopy:

; 764  :         }
; 765  : 
; 766  :         //  Check for dataset EOF
; 767  : 
; 768  :         if (len == 0)       // EOF

  00b04	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR len$[rsp]
  00b0c	85 c0		 test	 eax, eax
  00b0e	0f 85 ff 00 00
	00		 jne	 $LN27@fbcopy

; 769  :         {
; 770  :             if (verbose)

  00b14	83 bc 24 f0 06
	00 00 00	 cmp	 DWORD PTR verbose$[rsp], 0
  00b1c	74 7a		 je	 SHORT $LN28@fbcopy

; 771  :             {
; 772  :                 // "%s track %5.5d/x'%04X' rec %d"
; 773  :                 WRMSG( HHC02687, "I", "EOF", trk, trk, rec );

  00b1e	0f b6 44 24 70	 movzx	 eax, BYTE PTR rec$[rsp]
  00b23	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv443[rsp], eax
  00b2a	b9 01 00 00 00	 mov	 ecx, 1
  00b2f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b35	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv443[rsp]
  00b3c	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00b40	8b 4c 24 78	 mov	 ecx, DWORD PTR trk$[rsp]
  00b44	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00b48	8b 4c 24 78	 mov	 ecx, DWORD PTR trk$[rsp]
  00b4c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00b50	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160150
  00b57	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00b5c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160151
  00b63	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b68	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160152
  00b6f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b74	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b79	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b7f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160153
  00b86	ba 05 03 00 00	 mov	 edx, 773		; 00000305H
  00b8b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160154
  00b92	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN28@fbcopy:

; 774  :             }
; 775  :             if (absvalid)   // capture as much -abs data as possible

  00b98	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR absvalid, 0
  00b9f	74 5f		 je	 SHORT $LN29@fbcopy

; 776  :             {
; 777  :                 if (verbose)

  00ba1	83 bc 24 f0 06
	00 00 00	 cmp	 DWORD PTR verbose$[rsp], 0
  00ba9	74 53		 je	 SHORT $LN31@fbcopy

; 778  :                 {
; 779  :                     // "%s"
; 780  :                     WRMSG( HHC02681, "I", "Ignoring -abs EOF" );

  00bab	b9 01 00 00 00	 mov	 ecx, 1
  00bb0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00bb6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160158
  00bbd	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00bc2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160159
  00bc9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00bce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160160
  00bd5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00bda	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00bdf	41 b9 03 00 00
	00		 mov	 r9d, 3
  00be5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160161
  00bec	ba 0c 03 00 00	 mov	 edx, 780		; 0000030cH
  00bf1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160162
  00bf8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN31@fbcopy:

; 781  :                 }
; 782  :             }

  00bfe	eb 13		 jmp	 SHORT $LN30@fbcopy
$LN29@fbcopy:

; 783  :             else
; 784  :             {
; 785  :                 rc_copy = recs_written;

  00c00	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR recs_written$[rsp]
  00c07	89 84 24 84 00
	00 00		 mov	 DWORD PTR rc_copy$[rsp], eax

; 786  :                 break;

  00c0e	e9 dc 04 00 00	 jmp	 $LN3@fbcopy
$LN30@fbcopy:
$LN27@fbcopy:

; 787  :             }
; 788  :         }
; 789  :         if (verbose > 3)

  00c13	83 bc 24 f0 06
	00 00 03	 cmp	 DWORD PTR verbose$[rsp], 3
  00c1b	7e 61		 jle	 SHORT $LN32@fbcopy

; 790  :         {
; 791  :             // "read %d bytes"
; 792  :             WRMSG( HHC02688, "I", len );

  00c1d	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR len$[rsp]
  00c25	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv502[rsp], eax
  00c2c	b9 01 00 00 00	 mov	 ecx, 1
  00c31	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c37	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR tv502[rsp]
  00c3e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00c42	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160164
  00c49	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c4e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160165
  00c55	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c5a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c5f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c65	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160166
  00c6c	ba 18 03 00 00	 mov	 edx, 792		; 00000318H
  00c71	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160167
  00c78	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN32@fbcopy:

; 793  :         }
; 794  :         if (verbose > 2)

  00c7e	83 bc 24 f0 06
	00 00 02	 cmp	 DWORD PTR verbose$[rsp], 2
  00c86	0f 8e be 00 00
	00		 jle	 $LN33@fbcopy

; 795  :         {
; 796  :             // "%s"
; 797  :             WRMSG( HHC02681, "I", "BEGIN OF BUFFER DUMP >" );

  00c8c	b9 01 00 00 00	 mov	 ecx, 1
  00c91	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c97	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160169
  00c9e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00ca3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160170
  00caa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00caf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160171
  00cb6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00cbb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00cc0	41 b9 03 00 00
	00		 mov	 r9d, 3
  00cc6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160172
  00ccd	ba 1d 03 00 00	 mov	 edx, 797		; 0000031dH
  00cd2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160173
  00cd9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 798  :             data_dump( buffer, len );

  00cdf	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR len$[rsp]
  00ce7	8b d0		 mov	 edx, eax
  00ce9	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  00cf1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump

; 799  :             WRMSG( HHC02681, "I", "< END OF BUFFER DUMP" );

  00cf7	b9 01 00 00 00	 mov	 ecx, 1
  00cfc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00d02	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160174
  00d09	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00d0e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160175
  00d15	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00d1a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160176
  00d21	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00d26	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d2b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00d31	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160177
  00d38	ba 1f 03 00 00	 mov	 edx, 799		; 0000031fH
  00d3d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160178
  00d44	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN33@fbcopy:

; 800  :         }
; 801  : 
; 802  :         //  Deblock input dasd block, write records to output dataset
; 803  : 
; 804  :         for (offset=0; offset < len; offset += lrecl)

  00d4a	33 c0		 xor	 eax, eax
  00d4c	66 89 44 24 74	 mov	 WORD PTR offset$[rsp], ax
  00d51	eb 0e		 jmp	 SHORT $LN6@fbcopy
$LN4@fbcopy:
  00d53	0f b7 44 24 74	 movzx	 eax, WORD PTR offset$[rsp]
  00d58	03 44 24 7c	 add	 eax, DWORD PTR lrecl$[rsp]
  00d5c	66 89 44 24 74	 mov	 WORD PTR offset$[rsp], ax
$LN6@fbcopy:
  00d61	0f b7 44 24 74	 movzx	 eax, WORD PTR offset$[rsp]
  00d66	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR len$[rsp]
  00d6e	3b c1		 cmp	 eax, ecx
  00d70	0f 8d 5b 03 00
	00		 jge	 $LN5@fbcopy

; 805  :         {
; 806  :             if (verbose > 3)

  00d76	83 bc 24 f0 06
	00 00 03	 cmp	 DWORD PTR verbose$[rsp], 3
  00d7e	7e 71		 jle	 SHORT $LN34@fbcopy

; 807  :             {
; 808  :                 // "offset %d length %d rec %d"
; 809  :                 WRMSG( HHC02689, "I", offset, lrecl, recs_written );

  00d80	0f b7 44 24 74	 movzx	 eax, WORD PTR offset$[rsp]
  00d85	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv546[rsp], eax
  00d8c	b9 01 00 00 00	 mov	 ecx, 1
  00d91	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00d97	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR recs_written$[rsp]
  00d9e	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00da2	8b 4c 24 7c	 mov	 ecx, DWORD PTR lrecl$[rsp]
  00da6	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00daa	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv546[rsp]
  00db1	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00db5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160180
  00dbc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00dc1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160181
  00dc8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00dcd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00dd2	41 b9 03 00 00
	00		 mov	 r9d, 3
  00dd8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160182
  00ddf	ba 29 03 00 00	 mov	 edx, 809		; 00000329H
  00de4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160183
  00deb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN34@fbcopy:

; 810  :             }
; 811  : 
; 812  :             if (tran)   // ASCII output

  00df1	83 bc 24 e8 06
	00 00 00	 cmp	 DWORD PTR tran$[rsp], 0
  00df9	0f 84 6d 01 00
	00		 je	 $LN35@fbcopy

; 813  :             {
; 814  :                 memset( pascii, 0, lrecl + 1 );

  00dff	8b 44 24 7c	 mov	 eax, DWORD PTR lrecl$[rsp]
  00e03	ff c0		 inc	 eax
  00e05	48 98		 cdqe
  00e07	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv561[rsp], rax
  00e0f	48 8b bc 24 98
	00 00 00	 mov	 rdi, QWORD PTR pascii$[rsp]
  00e17	33 c0		 xor	 eax, eax
  00e19	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tv561[rsp]
  00e21	f3 aa		 rep stosb

; 815  :                 make_asciiz( pascii, lrecl + 1, buffer + offset, lrecl );

  00e23	0f b7 44 24 74	 movzx	 eax, WORD PTR offset$[rsp]
  00e28	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  00e30	48 03 c8	 add	 rcx, rax
  00e33	48 8b c1	 mov	 rax, rcx
  00e36	8b 4c 24 7c	 mov	 ecx, DWORD PTR lrecl$[rsp]
  00e3a	ff c1		 inc	 ecx
  00e3c	44 8b 4c 24 7c	 mov	 r9d, DWORD PTR lrecl$[rsp]
  00e41	4c 8b c0	 mov	 r8, rax
  00e44	8b d1		 mov	 edx, ecx
  00e46	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pascii$[rsp]
  00e4e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_make_asciiz

; 816  :                 if (verbose > 4)

  00e54	83 bc 24 f0 06
	00 00 04	 cmp	 DWORD PTR verbose$[rsp], 4
  00e5c	0f 8e 95 00 00
	00		 jle	 $LN37@fbcopy

; 817  :                 {
; 818  :                     // "buffer offset %d rec %d:"
; 819  :                     WRMSG( HHC02690, "I", offset, rec );

  00e62	0f b6 44 24 70	 movzx	 eax, BYTE PTR rec$[rsp]
  00e67	89 84 24 f4 00
	00 00		 mov	 DWORD PTR tv572[rsp], eax
  00e6e	0f b7 4c 24 74	 movzx	 ecx, WORD PTR offset$[rsp]
  00e73	89 8c 24 f8 00
	00 00		 mov	 DWORD PTR tv574[rsp], ecx
  00e7a	b9 01 00 00 00	 mov	 ecx, 1
  00e7f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e85	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR tv572[rsp]
  00e8c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00e90	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR tv574[rsp]
  00e97	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00e9b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160187
  00ea2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00ea7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160188
  00eae	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00eb3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00eb8	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ebe	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160189
  00ec5	ba 33 03 00 00	 mov	 edx, 819		; 00000333H
  00eca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160190
  00ed1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 820  :                     data_dump( buffer + offset, lrecl );

  00ed7	0f b7 44 24 74	 movzx	 eax, WORD PTR offset$[rsp]
  00edc	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  00ee4	48 03 c8	 add	 rcx, rax
  00ee7	48 8b c1	 mov	 rax, rcx
  00eea	8b 54 24 7c	 mov	 edx, DWORD PTR lrecl$[rsp]
  00eee	48 8b c8	 mov	 rcx, rax
  00ef1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump
$LN37@fbcopy:

; 821  :                 }
; 822  :                 // "ascii> '%s'"
; 823  :                 WRMSG( HHC02691, "I", pascii );

  00ef7	b9 01 00 00 00	 mov	 ecx, 1
  00efc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00f02	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pascii$[rsp]
  00f0a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00f0f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160191
  00f16	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00f1b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160192
  00f22	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00f27	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f2c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00f32	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160193
  00f39	ba 37 03 00 00	 mov	 edx, 823		; 00000337H
  00f3e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160194
  00f45	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 824  :                 if (verbose > 3)

  00f4b	83 bc 24 f0 06
	00 00 03	 cmp	 DWORD PTR verbose$[rsp], 3
  00f53	7e 12		 jle	 SHORT $LN38@fbcopy

; 825  :                     data_dump( pascii, lrecl );

  00f55	8b 54 24 7c	 mov	 edx, DWORD PTR lrecl$[rsp]
  00f59	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pascii$[rsp]
  00f61	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump
$LN38@fbcopy:

; 826  :             }

  00f67	e9 ac 00 00 00	 jmp	 $LN36@fbcopy
$LN35@fbcopy:

; 827  :             else    // EBCDIC output
; 828  :             {
; 829  :                 if (verbose > 3)

  00f6c	83 bc 24 f0 06
	00 00 03	 cmp	 DWORD PTR verbose$[rsp], 3
  00f74	7e 73		 jle	 SHORT $LN39@fbcopy

; 830  :                 {
; 831  :                     // "%s"
; 832  :                     WRMSG( HHC02681, "I", "EBCDIC buffer:" );

  00f76	b9 01 00 00 00	 mov	 ecx, 1
  00f7b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00f81	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160197
  00f88	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00f8d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160198
  00f94	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00f99	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160199
  00fa0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00fa5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00faa	41 b9 03 00 00
	00		 mov	 r9d, 3
  00fb0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160200
  00fb7	ba 40 03 00 00	 mov	 edx, 832		; 00000340H
  00fbc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160201
  00fc3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 833  :                     data_dump( buffer + offset, lrecl );

  00fc9	0f b7 44 24 74	 movzx	 eax, WORD PTR offset$[rsp]
  00fce	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  00fd6	48 03 c8	 add	 rcx, rax
  00fd9	48 8b c1	 mov	 rax, rcx
  00fdc	8b 54 24 7c	 mov	 edx, DWORD PTR lrecl$[rsp]
  00fe0	48 8b c8	 mov	 rcx, rax
  00fe3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump
$LN39@fbcopy:

; 834  :                 }
; 835  :                 fwrite(buffer + offset, lrecl, 1, fout);

  00fe9	48 63 44 24 7c	 movsxd	 rax, DWORD PTR lrecl$[rsp]
  00fee	0f b7 4c 24 74	 movzx	 ecx, WORD PTR offset$[rsp]
  00ff3	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR buffer$[rsp]
  00ffb	48 03 d1	 add	 rdx, rcx
  00ffe	48 8b ca	 mov	 rcx, rdx
  01001	4c 8b 8c 24 d0
	06 00 00	 mov	 r9, QWORD PTR fout$[rsp]
  01009	41 b8 01 00 00
	00		 mov	 r8d, 1
  0100f	48 8b d0	 mov	 rdx, rax
  01012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite
$LN36@fbcopy:

; 836  :             }
; 837  :             if (ferror(fout))

  01018	48 8b 8c 24 d0
	06 00 00	 mov	 rcx, QWORD PTR fout$[rsp]
  01020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ferror
  01026	85 c0		 test	 eax, eax
  01028	0f 84 8e 00 00
	00		 je	 $LN40@fbcopy

; 838  :             {
; 839  :                 // "File %s; %s error: %s"
; 840  :                 FWRMSG( stderr, HHC02468, "E", zdsn, "fwrite()", strerror( errno ));

  0102e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01034	8b 08		 mov	 ecx, DWORD PTR [rax]
  01036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0103c	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv659[rsp], rax
  01044	b9 02 00 00 00	 mov	 ecx, 2
  01049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0104f	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR tv659[rsp]
  01057	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0105c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160203
  01063	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01068	48 8d 8c 24 f0
	05 00 00	 lea	 rcx, QWORD PTR zdsn$[rsp]
  01070	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160204
  0107c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160205
  01088	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0108d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01092	41 b9 03 00 00
	00		 mov	 r9d, 3
  01098	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160206
  0109f	ba 48 03 00 00	 mov	 edx, 840		; 00000348H
  010a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160207
  010ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 841  :                 rc_copy = -1;

  010b1	c7 84 24 84 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR rc_copy$[rsp], -1
$LN40@fbcopy:

; 842  :             }
; 843  :             recs_written++;

  010bc	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR recs_written$[rsp]
  010c3	ff c0		 inc	 eax
  010c5	89 84 24 90 00
	00 00		 mov	 DWORD PTR recs_written$[rsp], eax

; 844  :         }

  010cc	e9 82 fc ff ff	 jmp	 $LN4@fbcopy
$LN5@fbcopy:

; 845  :         if (rc_copy != 0)

  010d1	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR rc_copy$[rsp], 0
  010d9	74 04		 je	 SHORT $LN41@fbcopy

; 846  :             break;

  010db	eb 12		 jmp	 SHORT $LN3@fbcopy
  010dd	eb 0b		 jmp	 SHORT $LN42@fbcopy
$LN41@fbcopy:

; 847  :         else
; 848  :             rec++;          // next record on track

  010df	0f b6 44 24 70	 movzx	 eax, BYTE PTR rec$[rsp]
  010e4	fe c0		 inc	 al
  010e6	88 44 24 70	 mov	 BYTE PTR rec$[rsp], al
$LN42@fbcopy:

; 849  :     }

  010ea	e9 9e f4 ff ff	 jmp	 $LN45@fbcopy
$LN3@fbcopy:

; 850  :     /* end while (1) */
; 851  : 
; 852  :     if (pascii)

  010ef	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR pascii$[rsp], 0
  010f8	74 0e		 je	 SHORT $LN43@fbcopy

; 853  :         free(pascii);       // release ASCII conversion buffer

  010fa	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pascii$[rsp]
  01102	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN43@fbcopy:

; 854  : 
; 855  :     return rc_copy;

  01108	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR rc_copy$[rsp]
$LN1@fbcopy:

; 856  : }

  0110f	48 8b 8c 24 a0
	06 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01117	48 33 cc	 xor	 rcx, rsp
  0111a	e8 00 00 00 00	 call	 __security_check_cookie
  0111f	48 81 c4 b8 06
	00 00		 add	 rsp, 1720		; 000006b8H
  01126	5f		 pop	 rdi
  01127	5e		 pop	 rsi
  01128	c3		 ret	 0
fbcopy	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdseq.c
_TEXT	SEGMENT
i$ = 112
dsorg$ = 116
x$ = 120
y$ = 124
num_extents$ = 128
volseq$ = 132
blksize$ = 136
lrecl$ = 140
etrk$1 = 144
ecyl$2 = 148
btrk$3 = 152
bcyl$4 = 156
tv561 = 160
tv567 = 164
txtrecfm$ = 168
txtdsorg$ = 176
txtexpdt$ = 184
txtcredt$ = 200
volser$ = 216
txtscr$ = 224
txtsyscd$ = 248
dsn$ = 264
__$ArrayPad$ = 312
f1dscb$ = 352
extent$ = 360
verbose$ = 368
showf1	PROC

; 457  : {

$LN26:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 458  :     int     i, dsorg, lrecl, blksize, volseq, x, y, num_extents;
; 459  :     char    volser[sizeof(f1dscb->ds1dssn) + 1];
; 460  :     char    dsn[sizeof(f1dscb->ds1dsnam) + 1];
; 461  :     char    txtcredt[9];                            // creation date
; 462  :     char    txtexpdt[9] = "(n/a)";                  // expiration date

  0002a	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR txtexpdt$[rsp]
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159926
  00039	48 8b f8	 mov	 rdi, rax
  0003c	48 8b f1	 mov	 rsi, rcx
  0003f	b9 06 00 00 00	 mov	 ecx, 6
  00044	f3 a4		 rep movsb
  00046	48 8d 84 24 be
	00 00 00	 lea	 rax, QWORD PTR txtexpdt$[rsp+6]
  0004e	48 8b f8	 mov	 rdi, rax
  00051	33 c0		 xor	 eax, eax
  00053	b9 03 00 00 00	 mov	 ecx, 3
  00058	f3 aa		 rep stosb

; 463  :     char    txtscr[20];
; 464  :     char    txtsyscd[14];
; 465  :     char    txtdsorg[5] = "";                       // dsorg text

  0005a	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR $SG159927
  00061	88 84 24 b0 00
	00 00		 mov	 BYTE PTR txtdsorg$[rsp], al
  00068	48 8d 84 24 b1
	00 00 00	 lea	 rax, QWORD PTR txtdsorg$[rsp+1]
  00070	48 8b f8	 mov	 rdi, rax
  00073	33 c0		 xor	 eax, eax
  00075	b9 04 00 00 00	 mov	 ecx, 4
  0007a	f3 aa		 rep stosb

; 466  :     char    txtrecfm[5] = "";                       // recfm text

  0007c	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR $SG159928
  00083	88 84 24 a8 00
	00 00		 mov	 BYTE PTR txtrecfm$[rsp], al
  0008a	48 8d 84 24 a9
	00 00 00	 lea	 rax, QWORD PTR txtrecfm$[rsp+1]
  00092	48 8b f8	 mov	 rdi, rax
  00095	33 c0		 xor	 eax, eax
  00097	b9 04 00 00 00	 mov	 ecx, 4
  0009c	f3 aa		 rep stosb

; 467  : 
; 468  :     if (verbose > 2)

  0009e	83 bc 24 70 01
	00 00 02	 cmp	 DWORD PTR verbose$[rsp], 2
  000a6	7e 66		 jle	 SHORT $LN5@showf1

; 469  :     {
; 470  :         // "%s"
; 471  :         WRMSG( HHC02681, "I", "Format 1 DSCB:" );

  000a8	b9 01 00 00 00	 mov	 ecx, 1
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159930
  000ba	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159931
  000c6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159932
  000d2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000d7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000dc	41 b9 03 00 00
	00		 mov	 r9d, 3
  000e2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159933
  000e9	ba d7 01 00 00	 mov	 edx, 471		; 000001d7H
  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159934
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 472  :         data_dump(f1dscb, sizeof(FORMAT1_DSCB));

  000fb	ba 8c 00 00 00	 mov	 edx, 140		; 0000008cH
  00100	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump
$LN5@showf1:

; 473  :     }
; 474  : 
; 475  :     make_asciiz(dsn, sizeof(dsn),

  0010e	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR f1dscb$[rsp]
  00116	41 b9 2c 00 00
	00		 mov	 r9d, 44			; 0000002cH
  0011c	4c 8b c0	 mov	 r8, rax
  0011f	ba 2d 00 00 00	 mov	 edx, 45			; 0000002dH
  00124	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR dsn$[rsp]
  0012c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_make_asciiz

; 476  :                 f1dscb->ds1dsnam, sizeof(f1dscb->ds1dsnam));
; 477  :     make_asciiz(volser, sizeof(volser),

  00132	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR f1dscb$[rsp]
  0013a	48 83 c0 2d	 add	 rax, 45			; 0000002dH
  0013e	41 b9 06 00 00
	00		 mov	 r9d, 6
  00144	4c 8b c0	 mov	 r8, rax
  00147	ba 07 00 00 00	 mov	 edx, 7
  0014c	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR volser$[rsp]
  00154	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_make_asciiz

; 478  :                 f1dscb->ds1dssn, sizeof(f1dscb->ds1dssn));
; 479  :     volseq = (f1dscb->ds1volsq[0] << 8) | (f1dscb->ds1volsq[1]);

  0015a	b8 01 00 00 00	 mov	 eax, 1
  0015f	48 6b c0 00	 imul	 rax, rax, 0
  00163	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  0016b	0f b6 44 01 33	 movzx	 eax, BYTE PTR [rcx+rax+51]
  00170	c1 e0 08	 shl	 eax, 8
  00173	b9 01 00 00 00	 mov	 ecx, 1
  00178	48 6b c9 01	 imul	 rcx, rcx, 1
  0017c	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR f1dscb$[rsp]
  00184	0f b6 4c 0a 33	 movzx	 ecx, BYTE PTR [rdx+rcx+51]
  00189	0b c1		 or	 eax, ecx
  0018b	89 84 24 84 00
	00 00		 mov	 DWORD PTR volseq$[rsp], eax

; 480  :     x = f1dscb->ds1credt[0] + 1900;

  00192	b8 01 00 00 00	 mov	 eax, 1
  00197	48 6b c0 00	 imul	 rax, rax, 0
  0019b	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  001a3	0f b6 44 01 35	 movzx	 eax, BYTE PTR [rcx+rax+53]
  001a8	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  001ad	89 44 24 78	 mov	 DWORD PTR x$[rsp], eax

; 481  :     y = (f1dscb->ds1credt[1] << 8) | f1dscb->ds1credt[2];

  001b1	b8 01 00 00 00	 mov	 eax, 1
  001b6	48 6b c0 01	 imul	 rax, rax, 1
  001ba	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  001c2	0f b6 44 01 35	 movzx	 eax, BYTE PTR [rcx+rax+53]
  001c7	c1 e0 08	 shl	 eax, 8
  001ca	b9 01 00 00 00	 mov	 ecx, 1
  001cf	48 6b c9 02	 imul	 rcx, rcx, 2
  001d3	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR f1dscb$[rsp]
  001db	0f b6 4c 0a 35	 movzx	 ecx, BYTE PTR [rdx+rcx+53]
  001e0	0b c1		 or	 eax, ecx
  001e2	89 44 24 7c	 mov	 DWORD PTR y$[rsp], eax

; 482  : 
; 483  :     MSGBUF( txtcredt, "%4.4d", x );

  001e6	44 8b 4c 24 78	 mov	 r9d, DWORD PTR x$[rsp]
  001eb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159935
  001f2	ba 09 00 00 00	 mov	 edx, 9
  001f7	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR txtcredt$[rsp]
  001ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 484  :     STRLCAT( txtcredt, "." );

  00205	41 b8 09 00 00
	00		 mov	 r8d, 9
  0020b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159936
  00212	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR txtcredt$[rsp]
  0021a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 485  : 
; 486  :     MSGBUF( txtscr, "%3.3d", y );

  00220	44 8b 4c 24 7c	 mov	 r9d, DWORD PTR y$[rsp]
  00225	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159937
  0022c	ba 14 00 00 00	 mov	 edx, 20
  00231	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR txtscr$[rsp]
  00239	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 487  :     STRLCAT( txtcredt, txtscr );

  0023f	41 b8 09 00 00
	00		 mov	 r8d, 9
  00245	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR txtscr$[rsp]
  0024d	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR txtcredt$[rsp]
  00255	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 488  : 
; 489  :     if (f1dscb->ds1expdt[0] || f1dscb->ds1expdt[1] || f1dscb->ds1expdt[2])

  0025b	b8 01 00 00 00	 mov	 eax, 1
  00260	48 6b c0 00	 imul	 rax, rax, 0
  00264	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  0026c	0f b6 44 01 38	 movzx	 eax, BYTE PTR [rcx+rax+56]
  00271	85 c0		 test	 eax, eax
  00273	75 38		 jne	 SHORT $LN7@showf1
  00275	b8 01 00 00 00	 mov	 eax, 1
  0027a	48 6b c0 01	 imul	 rax, rax, 1
  0027e	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  00286	0f b6 44 01 38	 movzx	 eax, BYTE PTR [rcx+rax+56]
  0028b	85 c0		 test	 eax, eax
  0028d	75 1e		 jne	 SHORT $LN7@showf1
  0028f	b8 01 00 00 00	 mov	 eax, 1
  00294	48 6b c0 02	 imul	 rax, rax, 2
  00298	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  002a0	0f b6 44 01 38	 movzx	 eax, BYTE PTR [rcx+rax+56]
  002a5	85 c0		 test	 eax, eax
  002a7	0f 84 c9 00 00
	00		 je	 $LN6@showf1
$LN7@showf1:

; 490  :     {
; 491  :         x = f1dscb->ds1expdt[0] + 1900;

  002ad	b8 01 00 00 00	 mov	 eax, 1
  002b2	48 6b c0 00	 imul	 rax, rax, 0
  002b6	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  002be	0f b6 44 01 38	 movzx	 eax, BYTE PTR [rcx+rax+56]
  002c3	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  002c8	89 44 24 78	 mov	 DWORD PTR x$[rsp], eax

; 492  :         y = (f1dscb->ds1expdt[1] << 8) | f1dscb->ds1expdt[2];

  002cc	b8 01 00 00 00	 mov	 eax, 1
  002d1	48 6b c0 01	 imul	 rax, rax, 1
  002d5	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  002dd	0f b6 44 01 38	 movzx	 eax, BYTE PTR [rcx+rax+56]
  002e2	c1 e0 08	 shl	 eax, 8
  002e5	b9 01 00 00 00	 mov	 ecx, 1
  002ea	48 6b c9 02	 imul	 rcx, rcx, 2
  002ee	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR f1dscb$[rsp]
  002f6	0f b6 4c 0a 38	 movzx	 ecx, BYTE PTR [rdx+rcx+56]
  002fb	0b c1		 or	 eax, ecx
  002fd	89 44 24 7c	 mov	 DWORD PTR y$[rsp], eax

; 493  : 
; 494  :         MSGBUF( txtexpdt, "%4.4d", x );

  00301	44 8b 4c 24 78	 mov	 r9d, DWORD PTR x$[rsp]
  00306	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159940
  0030d	ba 09 00 00 00	 mov	 edx, 9
  00312	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR txtexpdt$[rsp]
  0031a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 495  :         STRLCAT( txtexpdt, "." );

  00320	41 b8 09 00 00
	00		 mov	 r8d, 9
  00326	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159941
  0032d	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR txtexpdt$[rsp]
  00335	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 496  : 
; 497  :         MSGBUF( txtscr, ".%3.3d", y );

  0033b	44 8b 4c 24 7c	 mov	 r9d, DWORD PTR y$[rsp]
  00340	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159942
  00347	ba 14 00 00 00	 mov	 edx, 20
  0034c	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR txtscr$[rsp]
  00354	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 498  :         STRLCAT( txtexpdt, txtscr );

  0035a	41 b8 09 00 00
	00		 mov	 r8d, 9
  00360	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR txtscr$[rsp]
  00368	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR txtexpdt$[rsp]
  00370	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN6@showf1:

; 499  :     }
; 500  : 
; 501  :     num_extents = f1dscb->ds1noepv;

  00376	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR f1dscb$[rsp]
  0037e	0f b6 40 3b	 movzx	 eax, BYTE PTR [rax+59]
  00382	89 84 24 80 00
	00 00		 mov	 DWORD PTR num_extents$[rsp], eax

; 502  :     //  Field ignored: ds1nobdb (# bytes used in last PDS dir blk)
; 503  :     make_asciiz(txtsyscd, sizeof(txtsyscd),

  00389	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR f1dscb$[rsp]
  00391	48 83 c0 3e	 add	 rax, 62			; 0000003eH
  00395	41 b9 0d 00 00
	00		 mov	 r9d, 13
  0039b	4c 8b c0	 mov	 r8, rax
  0039e	ba 0e 00 00 00	 mov	 edx, 14
  003a3	48 8d 8c 24 f8
	00 00 00	 lea	 rcx, QWORD PTR txtsyscd$[rsp]
  003ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_make_asciiz

; 504  :                 f1dscb->ds1syscd, sizeof(f1dscb->ds1syscd));
; 505  : 
; 506  :     dsorg = (f1dscb->ds1dsorg[0] << 8) | (f1dscb->ds1dsorg[1]);

  003b1	b8 01 00 00 00	 mov	 eax, 1
  003b6	48 6b c0 00	 imul	 rax, rax, 0
  003ba	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  003c2	0f b6 44 01 52	 movzx	 eax, BYTE PTR [rcx+rax+82]
  003c7	c1 e0 08	 shl	 eax, 8
  003ca	b9 01 00 00 00	 mov	 ecx, 1
  003cf	48 6b c9 01	 imul	 rcx, rcx, 1
  003d3	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR f1dscb$[rsp]
  003db	0f b6 4c 0a 52	 movzx	 ecx, BYTE PTR [rdx+rcx+82]
  003e0	0b c1		 or	 eax, ecx
  003e2	89 44 24 74	 mov	 DWORD PTR dsorg$[rsp], eax

; 507  : 
; 508  :     if (dsorg & (DSORG_IS * 256))               STRLCPY( txtdsorg, "IS" );

  003e6	8b 44 24 74	 mov	 eax, DWORD PTR dsorg$[rsp]
  003ea	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  003ef	85 c0		 test	 eax, eax
  003f1	74 1b		 je	 SHORT $LN8@showf1
  003f3	41 b8 05 00 00
	00		 mov	 r8d, 5
  003f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159944
  00400	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR txtdsorg$[rsp]
  00408	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN8@showf1:

; 509  :     if (dsorg & (DSORG_PS * 256))               STRLCPY( txtdsorg, "PS" );

  0040e	8b 44 24 74	 mov	 eax, DWORD PTR dsorg$[rsp]
  00412	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  00417	85 c0		 test	 eax, eax
  00419	74 1b		 je	 SHORT $LN9@showf1
  0041b	41 b8 05 00 00
	00		 mov	 r8d, 5
  00421	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159946
  00428	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR txtdsorg$[rsp]
  00430	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN9@showf1:

; 510  :     if (dsorg & (DSORG_DA * 256))               STRLCPY( txtdsorg, "DA" );

  00436	8b 44 24 74	 mov	 eax, DWORD PTR dsorg$[rsp]
  0043a	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  0043f	85 c0		 test	 eax, eax
  00441	74 1b		 je	 SHORT $LN10@showf1
  00443	41 b8 05 00 00
	00		 mov	 r8d, 5
  00449	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159948
  00450	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR txtdsorg$[rsp]
  00458	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN10@showf1:

; 511  :     if (dsorg & (DSORG_PO * 256))               STRLCPY( txtdsorg, "PO" );

  0045e	8b 44 24 74	 mov	 eax, DWORD PTR dsorg$[rsp]
  00462	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00467	85 c0		 test	 eax, eax
  00469	74 1b		 je	 SHORT $LN11@showf1
  0046b	41 b8 05 00 00
	00		 mov	 r8d, 5
  00471	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159950
  00478	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR txtdsorg$[rsp]
  00480	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN11@showf1:

; 512  :     if (dsorg &  DSORG_AM)                      STRLCPY( txtdsorg, "VS" );

  00486	8b 44 24 74	 mov	 eax, DWORD PTR dsorg$[rsp]
  0048a	83 e0 08	 and	 eax, 8
  0048d	85 c0		 test	 eax, eax
  0048f	74 1b		 je	 SHORT $LN12@showf1
  00491	41 b8 05 00 00
	00		 mov	 r8d, 5
  00497	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159952
  0049e	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR txtdsorg$[rsp]
  004a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN12@showf1:

; 513  :     if (txtdsorg[0] == '\0')                    STRLCPY( txtdsorg, "??" );

  004ac	b8 01 00 00 00	 mov	 eax, 1
  004b1	48 6b c0 00	 imul	 rax, rax, 0
  004b5	0f be 84 04 b0
	00 00 00	 movsx	 eax, BYTE PTR txtdsorg$[rsp+rax]
  004bd	85 c0		 test	 eax, eax
  004bf	75 1b		 jne	 SHORT $LN13@showf1
  004c1	41 b8 05 00 00
	00		 mov	 r8d, 5
  004c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159954
  004ce	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR txtdsorg$[rsp]
  004d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN13@showf1:

; 514  : 
; 515  :     if (dsorg & (DSORG_U * 256))                STRLCAT( txtdsorg, "U" );

  004dc	8b 44 24 74	 mov	 eax, DWORD PTR dsorg$[rsp]
  004e0	25 00 01 00 00	 and	 eax, 256		; 00000100H
  004e5	85 c0		 test	 eax, eax
  004e7	74 1b		 je	 SHORT $LN14@showf1
  004e9	41 b8 05 00 00
	00		 mov	 r8d, 5
  004ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159956
  004f6	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR txtdsorg$[rsp]
  004fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN14@showf1:

; 516  : 
; 517  :     if (f1dscb->ds1recfm & RECFM_FORMAT_F)      STRLCPY( txtrecfm, "F" );

  00504	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR f1dscb$[rsp]
  0050c	0f b6 40 54	 movzx	 eax, BYTE PTR [rax+84]
  00510	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00515	85 c0		 test	 eax, eax
  00517	74 1b		 je	 SHORT $LN15@showf1
  00519	41 b8 05 00 00
	00		 mov	 r8d, 5
  0051f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159958
  00526	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR txtrecfm$[rsp]
  0052e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN15@showf1:

; 518  :     if (f1dscb->ds1recfm & RECFM_FORMAT_V)      STRLCPY( txtrecfm, "V" );

  00534	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR f1dscb$[rsp]
  0053c	0f b6 40 54	 movzx	 eax, BYTE PTR [rax+84]
  00540	83 e0 40	 and	 eax, 64			; 00000040H
  00543	85 c0		 test	 eax, eax
  00545	74 1b		 je	 SHORT $LN16@showf1
  00547	41 b8 05 00 00
	00		 mov	 r8d, 5
  0054d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159960
  00554	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR txtrecfm$[rsp]
  0055c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN16@showf1:

; 519  :     if ((f1dscb->ds1recfm & RECFM_FORMAT_U) == RECFM_FORMAT_U)

  00562	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR f1dscb$[rsp]
  0056a	0f b6 40 54	 movzx	 eax, BYTE PTR [rax+84]
  0056e	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  00573	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00578	75 1b		 jne	 SHORT $LN17@showf1

; 520  :                                                 STRLCPY( txtrecfm, "U" );

  0057a	41 b8 05 00 00
	00		 mov	 r8d, 5
  00580	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159962
  00587	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR txtrecfm$[rsp]
  0058f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN17@showf1:

; 521  : 
; 522  :     if (f1dscb->ds1recfm & RECFM_BLOCKED)       STRLCAT( txtrecfm, "B" );

  00595	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR f1dscb$[rsp]
  0059d	0f b6 40 54	 movzx	 eax, BYTE PTR [rax+84]
  005a1	83 e0 10	 and	 eax, 16
  005a4	85 c0		 test	 eax, eax
  005a6	74 1b		 je	 SHORT $LN18@showf1
  005a8	41 b8 05 00 00
	00		 mov	 r8d, 5
  005ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159964
  005b5	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR txtrecfm$[rsp]
  005bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN18@showf1:

; 523  :     if (f1dscb->ds1recfm & RECFM_SPANNED)       STRLCAT( txtrecfm, "S" );

  005c3	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR f1dscb$[rsp]
  005cb	0f b6 40 54	 movzx	 eax, BYTE PTR [rax+84]
  005cf	83 e0 08	 and	 eax, 8
  005d2	85 c0		 test	 eax, eax
  005d4	74 1b		 je	 SHORT $LN19@showf1
  005d6	41 b8 05 00 00
	00		 mov	 r8d, 5
  005dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159966
  005e3	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR txtrecfm$[rsp]
  005eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN19@showf1:

; 524  :     if (f1dscb->ds1recfm & RECFM_CTLCHAR_A)     STRLCAT( txtrecfm, "A" );

  005f1	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR f1dscb$[rsp]
  005f9	0f b6 40 54	 movzx	 eax, BYTE PTR [rax+84]
  005fd	83 e0 04	 and	 eax, 4
  00600	85 c0		 test	 eax, eax
  00602	74 1b		 je	 SHORT $LN20@showf1
  00604	41 b8 05 00 00
	00		 mov	 r8d, 5
  0060a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159968
  00611	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR txtrecfm$[rsp]
  00619	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN20@showf1:

; 525  :     if (f1dscb->ds1recfm & RECFM_CTLCHAR_M)     STRLCAT( txtrecfm, "M" );

  0061f	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR f1dscb$[rsp]
  00627	0f b6 40 54	 movzx	 eax, BYTE PTR [rax+84]
  0062b	83 e0 02	 and	 eax, 2
  0062e	85 c0		 test	 eax, eax
  00630	74 1b		 je	 SHORT $LN21@showf1
  00632	41 b8 05 00 00
	00		 mov	 r8d, 5
  00638	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159970
  0063f	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR txtrecfm$[rsp]
  00647	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN21@showf1:

; 526  :     if (f1dscb->ds1recfm & RECFM_TRKOFLOW)      STRLCAT( txtrecfm, "T" );

  0064d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR f1dscb$[rsp]
  00655	0f b6 40 54	 movzx	 eax, BYTE PTR [rax+84]
  00659	83 e0 20	 and	 eax, 32			; 00000020H
  0065c	85 c0		 test	 eax, eax
  0065e	74 1b		 je	 SHORT $LN22@showf1
  00660	41 b8 05 00 00
	00		 mov	 r8d, 5
  00666	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159972
  0066d	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR txtrecfm$[rsp]
  00675	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN22@showf1:

; 527  : 
; 528  :     //  Field ignored: ds1optcd (option codes, same as in DCB)
; 529  : 
; 530  :     blksize = (f1dscb->ds1blkl[0]  << 8) | f1dscb->ds1blkl[1];

  0067b	b8 01 00 00 00	 mov	 eax, 1
  00680	48 6b c0 00	 imul	 rax, rax, 0
  00684	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  0068c	0f b6 44 01 56	 movzx	 eax, BYTE PTR [rcx+rax+86]
  00691	c1 e0 08	 shl	 eax, 8
  00694	b9 01 00 00 00	 mov	 ecx, 1
  00699	48 6b c9 01	 imul	 rcx, rcx, 1
  0069d	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR f1dscb$[rsp]
  006a5	0f b6 4c 0a 56	 movzx	 ecx, BYTE PTR [rdx+rcx+86]
  006aa	0b c1		 or	 eax, ecx
  006ac	89 84 24 88 00
	00 00		 mov	 DWORD PTR blksize$[rsp], eax

; 531  :     lrecl   = (f1dscb->ds1lrecl[0] << 8) | f1dscb->ds1lrecl[1];

  006b3	b8 01 00 00 00	 mov	 eax, 1
  006b8	48 6b c0 00	 imul	 rax, rax, 0
  006bc	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  006c4	0f b6 44 01 58	 movzx	 eax, BYTE PTR [rcx+rax+88]
  006c9	c1 e0 08	 shl	 eax, 8
  006cc	b9 01 00 00 00	 mov	 ecx, 1
  006d1	48 6b c9 01	 imul	 rcx, rcx, 1
  006d5	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR f1dscb$[rsp]
  006dd	0f b6 4c 0a 58	 movzx	 ecx, BYTE PTR [rdx+rcx+88]
  006e2	0b c1		 or	 eax, ecx
  006e4	89 84 24 8c 00
	00 00		 mov	 DWORD PTR lrecl$[rsp], eax

; 532  : 
; 533  :     //  Field ignored: ds1keyl (key length)
; 534  :     //  Field ignored: ds1rkp (relative key position)
; 535  :     //  Field ignored: ds1dsind (data set indicators)
; 536  :     //  Field ignored: ds1scalo (secondary allocation)
; 537  :     //  Field ignored: ds1lstar (pointer to last written block; ttr)
; 538  :     //  Field ignored: ds1trbal (bytes remaining on last track used)
; 539  :     //  Extent information was passed to us, so we ignore what's in F1DSCB
; 540  : 
; 541  :     // "Dataset %s on volume %s sequence %d"
; 542  :     // "Creation Date: %s; Expiration Date: %s"
; 543  :     // "Dsorg=%s recfm=%s lrecl=%d blksize=%d"
; 544  :     // "System code %s"
; 545  : 
; 546  :     WRMSG( HHC02485, "I", dsn, volser, volseq );

  006eb	b9 01 00 00 00	 mov	 ecx, 1
  006f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006f6	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR volseq$[rsp]
  006fd	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00701	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR volser$[rsp]
  00709	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0070e	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR dsn$[rsp]
  00716	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0071b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159973
  00722	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00727	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159974
  0072e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00733	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00738	41 b9 03 00 00
	00		 mov	 r9d, 3
  0073e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159975
  00745	ba 22 02 00 00	 mov	 edx, 546		; 00000222H
  0074a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159976
  00751	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 547  :     WRMSG( HHC02486, "I", txtcredt, txtexpdt );

  00757	b9 01 00 00 00	 mov	 ecx, 1
  0075c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00762	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR txtexpdt$[rsp]
  0076a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0076f	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR txtcredt$[rsp]
  00777	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0077c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159977
  00783	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00788	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159978
  0078f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00794	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00799	41 b9 03 00 00
	00		 mov	 r9d, 3
  0079f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159979
  007a6	ba 23 02 00 00	 mov	 edx, 547		; 00000223H
  007ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159980
  007b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 548  :     WRMSG( HHC02487, "I", txtdsorg, txtrecfm, lrecl, blksize );

  007b8	b9 01 00 00 00	 mov	 ecx, 1
  007bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007c3	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR blksize$[rsp]
  007ca	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  007ce	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR lrecl$[rsp]
  007d5	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  007d9	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR txtrecfm$[rsp]
  007e1	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  007e6	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR txtdsorg$[rsp]
  007ee	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  007f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159981
  007fa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159982
  00806	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0080b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00810	41 b9 03 00 00
	00		 mov	 r9d, 3
  00816	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159983
  0081d	ba 24 02 00 00	 mov	 edx, 548		; 00000224H
  00822	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159984
  00829	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 549  :     WRMSG( HHC02488, "I", txtsyscd );

  0082f	b9 01 00 00 00	 mov	 ecx, 1
  00834	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0083a	48 8d 8c 24 f8
	00 00 00	 lea	 rcx, QWORD PTR txtsyscd$[rsp]
  00842	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00847	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159985
  0084e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00853	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159986
  0085a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0085f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00864	41 b9 03 00 00
	00		 mov	 r9d, 3
  0086a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159987
  00871	ba 25 02 00 00	 mov	 edx, 549		; 00000225H
  00876	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159988
  0087d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 550  : 
; 551  :     if (verbose > 1)

  00883	83 bc 24 70 01
	00 00 01	 cmp	 DWORD PTR verbose$[rsp], 1
  0088b	0f 8e ac 03 00
	00		 jle	 $LN23@showf1

; 552  :     {
; 553  :         int bcyl, btrk, ecyl, etrk;
; 554  : 
; 555  :         // "Dataset has %d extent(s)"
; 556  :         WRMSG( HHC02680, "I", num_extents );

  00891	b9 01 00 00 00	 mov	 ecx, 1
  00896	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0089c	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR num_extents$[rsp]
  008a3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  008a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159990
  008ae	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159991
  008ba	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008bf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008c4	41 b9 03 00 00
	00		 mov	 r9d, 3
  008ca	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159992
  008d1	ba 2c 02 00 00	 mov	 edx, 556		; 0000022cH
  008d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159993
  008dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 557  : 
; 558  :         if (verbose > 2)

  008e3	83 bc 24 70 01
	00 00 02	 cmp	 DWORD PTR verbose$[rsp], 2
  008eb	7e 13		 jle	 SHORT $LN24@showf1

; 559  :             data_dump((void *)extent, sizeof(DSXTENT) * MAX_EXTENTS);

  008ed	ba ce 04 00 00	 mov	 edx, 1230		; 000004ceH
  008f2	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  008fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump
$LN24@showf1:

; 560  : 
; 561  :         // "%s"
; 562  :         WRMSG( HHC02681, "I", "Extent Information:" );

  00900	b9 01 00 00 00	 mov	 ecx, 1
  00905	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0090b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159995
  00912	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00917	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159996
  0091e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00923	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159997
  0092a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0092f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00934	41 b9 03 00 00
	00		 mov	 r9d, 3
  0093a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159998
  00941	ba 32 02 00 00	 mov	 edx, 562		; 00000232H
  00946	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159999
  0094d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 563  :         WRMSG( HHC02681, "I", "     EXTENT --begin-- ---end---" );

  00953	b9 01 00 00 00	 mov	 ecx, 1
  00958	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0095e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160000
  00965	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0096a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160001
  00971	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00976	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160002
  0097d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00982	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00987	41 b9 03 00 00
	00		 mov	 r9d, 3
  0098d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160003
  00994	ba 33 02 00 00	 mov	 edx, 563		; 00000233H
  00999	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160004
  009a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 564  :         WRMSG( HHC02681, "I", "TYPE NUMBER CCCC HHHH CCCC HHHH" );

  009a6	b9 01 00 00 00	 mov	 ecx, 1
  009ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160005
  009b8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  009bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160006
  009c4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160007
  009d0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  009d5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009da	41 b9 03 00 00
	00		 mov	 r9d, 3
  009e0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160008
  009e7	ba 34 02 00 00	 mov	 edx, 564		; 00000234H
  009ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160009
  009f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 565  : 
; 566  :         for (i=0; i < num_extents; i++)

  009f9	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00a01	eb 0a		 jmp	 SHORT $LN4@showf1
$LN2@showf1:
  00a03	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  00a07	ff c0		 inc	 eax
  00a09	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
$LN4@showf1:
  00a0d	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR num_extents$[rsp]
  00a14	39 44 24 70	 cmp	 DWORD PTR i$[rsp], eax
  00a18	0f 8d 1f 02 00
	00		 jge	 $LN3@showf1

; 567  :         {
; 568  :             bcyl = (extent[i].xtbcyl[0] << 8) | extent[i].xtbcyl[1];

  00a1e	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00a23	48 6b c0 0a	 imul	 rax, rax, 10
  00a27	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  00a2f	48 03 c8	 add	 rcx, rax
  00a32	48 8b c1	 mov	 rax, rcx
  00a35	b9 01 00 00 00	 mov	 ecx, 1
  00a3a	48 6b c9 00	 imul	 rcx, rcx, 0
  00a3e	0f b6 44 08 02	 movzx	 eax, BYTE PTR [rax+rcx+2]
  00a43	c1 e0 08	 shl	 eax, 8
  00a46	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$[rsp]
  00a4b	48 6b c9 0a	 imul	 rcx, rcx, 10
  00a4f	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00a57	48 03 d1	 add	 rdx, rcx
  00a5a	48 8b ca	 mov	 rcx, rdx
  00a5d	ba 01 00 00 00	 mov	 edx, 1
  00a62	48 6b d2 01	 imul	 rdx, rdx, 1
  00a66	0f b6 4c 11 02	 movzx	 ecx, BYTE PTR [rcx+rdx+2]
  00a6b	0b c1		 or	 eax, ecx
  00a6d	89 84 24 9c 00
	00 00		 mov	 DWORD PTR bcyl$4[rsp], eax

; 569  :             btrk = (extent[i].xtbtrk[0] << 8) | extent[i].xtbtrk[1];

  00a74	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00a79	48 6b c0 0a	 imul	 rax, rax, 10
  00a7d	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  00a85	48 03 c8	 add	 rcx, rax
  00a88	48 8b c1	 mov	 rax, rcx
  00a8b	b9 01 00 00 00	 mov	 ecx, 1
  00a90	48 6b c9 00	 imul	 rcx, rcx, 0
  00a94	0f b6 44 08 04	 movzx	 eax, BYTE PTR [rax+rcx+4]
  00a99	c1 e0 08	 shl	 eax, 8
  00a9c	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$[rsp]
  00aa1	48 6b c9 0a	 imul	 rcx, rcx, 10
  00aa5	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00aad	48 03 d1	 add	 rdx, rcx
  00ab0	48 8b ca	 mov	 rcx, rdx
  00ab3	ba 01 00 00 00	 mov	 edx, 1
  00ab8	48 6b d2 01	 imul	 rdx, rdx, 1
  00abc	0f b6 4c 11 04	 movzx	 ecx, BYTE PTR [rcx+rdx+4]
  00ac1	0b c1		 or	 eax, ecx
  00ac3	89 84 24 98 00
	00 00		 mov	 DWORD PTR btrk$3[rsp], eax

; 570  :             ecyl = (extent[i].xtecyl[0] << 8) | extent[i].xtecyl[1];

  00aca	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00acf	48 6b c0 0a	 imul	 rax, rax, 10
  00ad3	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  00adb	48 03 c8	 add	 rcx, rax
  00ade	48 8b c1	 mov	 rax, rcx
  00ae1	b9 01 00 00 00	 mov	 ecx, 1
  00ae6	48 6b c9 00	 imul	 rcx, rcx, 0
  00aea	0f b6 44 08 06	 movzx	 eax, BYTE PTR [rax+rcx+6]
  00aef	c1 e0 08	 shl	 eax, 8
  00af2	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$[rsp]
  00af7	48 6b c9 0a	 imul	 rcx, rcx, 10
  00afb	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00b03	48 03 d1	 add	 rdx, rcx
  00b06	48 8b ca	 mov	 rcx, rdx
  00b09	ba 01 00 00 00	 mov	 edx, 1
  00b0e	48 6b d2 01	 imul	 rdx, rdx, 1
  00b12	0f b6 4c 11 06	 movzx	 ecx, BYTE PTR [rcx+rdx+6]
  00b17	0b c1		 or	 eax, ecx
  00b19	89 84 24 94 00
	00 00		 mov	 DWORD PTR ecyl$2[rsp], eax

; 571  :             etrk = (extent[i].xtetrk[0] << 8) | extent[i].xtetrk[1];

  00b20	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00b25	48 6b c0 0a	 imul	 rax, rax, 10
  00b29	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  00b31	48 03 c8	 add	 rcx, rax
  00b34	48 8b c1	 mov	 rax, rcx
  00b37	b9 01 00 00 00	 mov	 ecx, 1
  00b3c	48 6b c9 00	 imul	 rcx, rcx, 0
  00b40	0f b6 44 08 08	 movzx	 eax, BYTE PTR [rax+rcx+8]
  00b45	c1 e0 08	 shl	 eax, 8
  00b48	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$[rsp]
  00b4d	48 6b c9 0a	 imul	 rcx, rcx, 10
  00b51	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00b59	48 03 d1	 add	 rdx, rcx
  00b5c	48 8b ca	 mov	 rcx, rdx
  00b5f	ba 01 00 00 00	 mov	 edx, 1
  00b64	48 6b d2 01	 imul	 rdx, rdx, 1
  00b68	0f b6 4c 11 08	 movzx	 ecx, BYTE PTR [rcx+rdx+8]
  00b6d	0b c1		 or	 eax, ecx
  00b6f	89 84 24 90 00
	00 00		 mov	 DWORD PTR etrk$1[rsp], eax

; 572  : 
; 573  :             // "  %02X   %02X   %04X %04X %04X %04X"
; 574  :             WRMSG( HHC02682, "I", extent[i].xttype, extent[i].xtseqn,

  00b76	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00b7b	48 6b c0 0a	 imul	 rax, rax, 10
  00b7f	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  00b87	0f b6 44 01 01	 movzx	 eax, BYTE PTR [rcx+rax+1]
  00b8c	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv561[rsp], eax
  00b93	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$[rsp]
  00b98	48 6b c9 0a	 imul	 rcx, rcx, 10
  00b9c	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00ba4	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00ba8	89 8c 24 a4 00
	00 00		 mov	 DWORD PTR tv567[rsp], ecx
  00baf	b9 01 00 00 00	 mov	 ecx, 1
  00bb4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00bba	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR etrk$1[rsp]
  00bc1	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00bc5	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR ecyl$2[rsp]
  00bcc	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00bd0	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR btrk$3[rsp]
  00bd7	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00bdb	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR bcyl$4[rsp]
  00be2	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00be6	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv561[rsp]
  00bed	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00bf1	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv567[rsp]
  00bf8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00bfc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160010
  00c03	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c08	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160011
  00c0f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c14	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c19	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c1f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160012
  00c26	ba 3f 02 00 00	 mov	 edx, 575		; 0000023fH
  00c2b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160013
  00c32	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 575  :                 bcyl, btrk, ecyl, etrk );
; 576  :         }

  00c38	e9 c6 fd ff ff	 jmp	 $LN2@showf1
$LN3@showf1:
$LN23@showf1:

; 577  :     }
; 578  : }

  00c3d	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00c45	48 33 cc	 xor	 rcx, rsp
  00c48	e8 00 00 00 00	 call	 __security_check_cookie
  00c4d	48 81 c4 48 01
	00 00		 add	 rsp, 328		; 00000148H
  00c54	5f		 pop	 rdi
  00c55	5e		 pop	 rsi
  00c56	c3		 ret	 0
showf1	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdseq.c
_TEXT	SEGMENT
i$ = 112
etrk$1 = 116
btrk$2 = 120
tv182 = 124
ecyl$3 = 128
tv185 = 132
bcyl$4 = 136
tv192 = 140
tv198 = 144
max$ = 176
extent$ = 184
sayext	PROC

; 432  : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 433  :     int     i;
; 434  :     // "     EXTENT --begin-- ---end---"
; 435  :     WRMSG( HHC02481, "I");

  00010	b9 01 00 00 00	 mov	 ecx, 1
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159881
  00022	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159882
  0002e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00033	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00038	41 b9 03 00 00
	00		 mov	 r9d, 3
  0003e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159883
  00045	ba b3 01 00 00	 mov	 edx, 435		; 000001b3H
  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159884
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 436  :     // "TYPE NUMBER CCCC HHHH CCCC HHHH"
; 437  :     WRMSG( HHC02482, "I");

  00057	b9 01 00 00 00	 mov	 ecx, 1
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159885
  00069	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0006e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159886
  00075	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0007a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00085	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159887
  0008c	ba b5 01 00 00	 mov	 edx, 437		; 000001b5H
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159888
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 438  :     for (i=0; i < max; i++)

  0009e	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000a6	eb 0a		 jmp	 SHORT $LN4@sayext
$LN2@sayext:
  000a8	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  000ac	ff c0		 inc	 eax
  000ae	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
$LN4@sayext:
  000b2	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  000b9	39 44 24 70	 cmp	 DWORD PTR i$[rsp], eax
  000bd	0f 8d 30 02 00
	00		 jge	 $LN3@sayext

; 439  :     {
; 440  :         U32 bcyl = (extent[i].xtbcyl[0] << 8) | extent[i].xtbcyl[1];

  000c3	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  000c8	48 6b c0 0a	 imul	 rax, rax, 10
  000cc	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  000d4	48 03 c8	 add	 rcx, rax
  000d7	48 8b c1	 mov	 rax, rcx
  000da	b9 01 00 00 00	 mov	 ecx, 1
  000df	48 6b c9 00	 imul	 rcx, rcx, 0
  000e3	0f b6 44 08 02	 movzx	 eax, BYTE PTR [rax+rcx+2]
  000e8	c1 e0 08	 shl	 eax, 8
  000eb	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$[rsp]
  000f0	48 6b c9 0a	 imul	 rcx, rcx, 10
  000f4	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  000fc	48 03 d1	 add	 rdx, rcx
  000ff	48 8b ca	 mov	 rcx, rdx
  00102	ba 01 00 00 00	 mov	 edx, 1
  00107	48 6b d2 01	 imul	 rdx, rdx, 1
  0010b	0f b6 4c 11 02	 movzx	 ecx, BYTE PTR [rcx+rdx+2]
  00110	0b c1		 or	 eax, ecx
  00112	89 84 24 88 00
	00 00		 mov	 DWORD PTR bcyl$4[rsp], eax

; 441  :         U16 btrk = (extent[i].xtbtrk[0] << 8) | extent[i].xtbtrk[1];

  00119	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0011e	48 6b c0 0a	 imul	 rax, rax, 10
  00122	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  0012a	48 03 c8	 add	 rcx, rax
  0012d	48 8b c1	 mov	 rax, rcx
  00130	b9 01 00 00 00	 mov	 ecx, 1
  00135	48 6b c9 00	 imul	 rcx, rcx, 0
  00139	0f b6 44 08 04	 movzx	 eax, BYTE PTR [rax+rcx+4]
  0013e	c1 e0 08	 shl	 eax, 8
  00141	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$[rsp]
  00146	48 6b c9 0a	 imul	 rcx, rcx, 10
  0014a	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  00152	48 03 d1	 add	 rdx, rcx
  00155	48 8b ca	 mov	 rcx, rdx
  00158	ba 01 00 00 00	 mov	 edx, 1
  0015d	48 6b d2 01	 imul	 rdx, rdx, 1
  00161	0f b6 4c 11 04	 movzx	 ecx, BYTE PTR [rcx+rdx+4]
  00166	0b c1		 or	 eax, ecx
  00168	66 89 44 24 78	 mov	 WORD PTR btrk$2[rsp], ax

; 442  :         U32 ecyl = (extent[i].xtecyl[0] << 8) | extent[i].xtecyl[1];

  0016d	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00172	48 6b c0 0a	 imul	 rax, rax, 10
  00176	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  0017e	48 03 c8	 add	 rcx, rax
  00181	48 8b c1	 mov	 rax, rcx
  00184	b9 01 00 00 00	 mov	 ecx, 1
  00189	48 6b c9 00	 imul	 rcx, rcx, 0
  0018d	0f b6 44 08 06	 movzx	 eax, BYTE PTR [rax+rcx+6]
  00192	c1 e0 08	 shl	 eax, 8
  00195	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$[rsp]
  0019a	48 6b c9 0a	 imul	 rcx, rcx, 10
  0019e	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  001a6	48 03 d1	 add	 rdx, rcx
  001a9	48 8b ca	 mov	 rcx, rdx
  001ac	ba 01 00 00 00	 mov	 edx, 1
  001b1	48 6b d2 01	 imul	 rdx, rdx, 1
  001b5	0f b6 4c 11 06	 movzx	 ecx, BYTE PTR [rcx+rdx+6]
  001ba	0b c1		 or	 eax, ecx
  001bc	89 84 24 80 00
	00 00		 mov	 DWORD PTR ecyl$3[rsp], eax

; 443  :         U16 etrk = (extent[i].xtetrk[0] << 8) | extent[i].xtetrk[1];

  001c3	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  001c8	48 6b c0 0a	 imul	 rax, rax, 10
  001cc	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR extent$[rsp]
  001d4	48 03 c8	 add	 rcx, rax
  001d7	48 8b c1	 mov	 rax, rcx
  001da	b9 01 00 00 00	 mov	 ecx, 1
  001df	48 6b c9 00	 imul	 rcx, rcx, 0
  001e3	0f b6 44 08 08	 movzx	 eax, BYTE PTR [rax+rcx+8]
  001e8	c1 e0 08	 shl	 eax, 8
  001eb	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$[rsp]
  001f0	48 6b c9 0a	 imul	 rcx, rcx, 10
  001f4	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR extent$[rsp]
  001fc	48 03 d1	 add	 rdx, rcx
  001ff	48 8b ca	 mov	 rcx, rdx
  00202	ba 01 00 00 00	 mov	 edx, 1
  00207	48 6b d2 01	 imul	 rdx, rdx, 1
  0020b	0f b6 4c 11 08	 movzx	 ecx, BYTE PTR [rcx+rdx+8]
  00210	0b c1		 or	 eax, ecx
  00212	66 89 44 24 74	 mov	 WORD PTR etrk$1[rsp], ax

; 444  :         // "  %02X   %02X   %04X %04X %04X %04X"
; 445  :         WRMSG( HHC02483, "I",

  00217	0f b7 44 24 74	 movzx	 eax, WORD PTR etrk$1[rsp]
  0021c	89 44 24 7c	 mov	 DWORD PTR tv182[rsp], eax
  00220	0f b7 4c 24 78	 movzx	 ecx, WORD PTR btrk$2[rsp]
  00225	89 8c 24 84 00
	00 00		 mov	 DWORD PTR tv185[rsp], ecx
  0022c	48 63 54 24 70	 movsxd	 rdx, DWORD PTR i$[rsp]
  00231	48 6b d2 0a	 imul	 rdx, rdx, 10
  00235	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR extent$[rsp]
  0023d	41 0f b6 54 10
	01		 movzx	 edx, BYTE PTR [r8+rdx+1]
  00243	89 94 24 8c 00
	00 00		 mov	 DWORD PTR tv192[rsp], edx
  0024a	4c 63 44 24 70	 movsxd	 r8, DWORD PTR i$[rsp]
  0024f	4d 6b c0 0a	 imul	 r8, r8, 10
  00253	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR extent$[rsp]
  0025b	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  00260	44 89 84 24 90
	00 00 00	 mov	 DWORD PTR tv198[rsp], r8d
  00268	b9 01 00 00 00	 mov	 ecx, 1
  0026d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00273	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv182[rsp]
  00277	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  0027b	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ecyl$3[rsp]
  00282	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00286	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv185[rsp]
  0028d	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00291	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR bcyl$4[rsp]
  00298	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0029c	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv192[rsp]
  002a3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002a7	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv198[rsp]
  002ae	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159889
  002b9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159890
  002c5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002ca	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002cf	41 b9 03 00 00
	00		 mov	 r9d, 3
  002d5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159891
  002dc	ba be 01 00 00	 mov	 edx, 446		; 000001beH
  002e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159892
  002e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 446  :             extent[i].xttype, extent[i].xtseqn, bcyl, btrk, ecyl, etrk );
; 447  :     }

  002ee	e9 b5 fd ff ff	 jmp	 $LN2@sayext
$LN3@sayext:

; 448  : }

  002f3	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  002fa	c3		 ret	 0
sayext	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdseq.c
_TEXT	SEGMENT
extnum$ = 112
lrecl$ = 116
abstrk$ = 120
abshead$ = 124
abscyl$ = 128
heads$ = 132
util_verbose$ = 136
tv484 = 140
tv268 = 144
tv303 = 152
tv331 = 160
tv336 = 168
tv341 = 176
tv471 = 184
tv476 = 192
tv481 = 200
msgbuf$ = 208
__$ArrayPad$ = 336
argc$ = 368
argv$ = 376
dadsm$ = 384
pgm$ = 392
parsecmd PROC

; 250  : {

$LN46:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 251  :         int     util_verbose = 0;       // Hercules dasdutil.c diagnostic level

  0002c	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR util_verbose$[rsp], 0

; 252  :         int     heads = 15;             // # heads per cylinder on device

  00037	c7 84 24 84 00
	00 00 0f 00 00
	00		 mov	 DWORD PTR heads$[rsp], 15

; 253  :         int     extnum = 0;             // extent number for makext()

  00042	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR extnum$[rsp], 0

; 254  :         int     abscyl = 0;             // absolute CC (default 0)

  0004a	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR abscyl$[rsp], 0

; 255  :         int     abshead = 0;            // absolute HH (default 0)

  00055	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR abshead$[rsp], 0

; 256  :         int     abstrk = 1;             // absolute tracks (default 1)

  0005d	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR abstrk$[rsp], 1

; 257  :         int     lrecl = 80;             // default F1 DSCB lrecl

  00065	c7 44 24 74 50
	00 00 00	 mov	 DWORD PTR lrecl$[rsp], 80 ; 00000050H

; 258  :         char    msgbuf[128];            // message work area
; 259  : 
; 260  :     //  Usage: dasdseq [-debug] [-expert] [-ascii] image [sf=shadow] [attr] filespec
; 261  : 
; 262  :     argv++;                             // skip dasdseq command argv[0]

  0006d	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00075	48 83 c0 08	 add	 rax, 8
  00079	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 263  :     if ((*argv) && (strcasecmp(*argv, "-debug") == 0))

  00081	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00089	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0008d	0f 84 8d 00 00
	00		 je	 $LN4@parsecmd
  00093	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159743
  0009a	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  000a2	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  000ab	85 c0		 test	 eax, eax
  000ad	75 71		 jne	 SHORT $LN4@parsecmd

; 264  :     {
; 265  :         argv++;

  000af	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  000b7	48 83 c0 08	 add	 rax, 8
  000bb	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 266  :         debug = 1;

  000c3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR debug, 1

; 267  :         // "%s mode enabled"
; 268  :         WRMSG( HHC02672, "D", "Debug" );

  000cd	b9 01 00 00 00	 mov	 ecx, 1
  000d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159744
  000df	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159745
  000eb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159746
  000f7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000fc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00101	41 b9 03 00 00
	00		 mov	 r9d, 3
  00107	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159747
  0010e	ba 0c 01 00 00	 mov	 edx, 268		; 0000010cH
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159748
  0011a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@parsecmd:

; 269  :     }
; 270  :     if ((*argv) && (strcasecmp(*argv, "-expert") == 0))

  00120	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00128	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0012c	0f 84 96 00 00
	00		 je	 $LN5@parsecmd
  00132	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159750
  00139	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00141	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00144	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0014a	85 c0		 test	 eax, eax
  0014c	75 7a		 jne	 SHORT $LN5@parsecmd

; 271  :     {
; 272  :         argv++;

  0014e	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00156	48 83 c0 08	 add	 rax, 8
  0015a	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 273  :         expert = 1;

  00162	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR expert, 1

; 274  :         // "% mode enabled"
; 275  :         if (debug) WRMSG( HHC02672, "I", "EXPERT" );

  0016c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  00173	74 53		 je	 SHORT $LN6@parsecmd
  00175	b9 01 00 00 00	 mov	 ecx, 1
  0017a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00180	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159752
  00187	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0018c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159753
  00193	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00198	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159754
  0019f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001a4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a9	41 b9 03 00 00
	00		 mov	 r9d, 3
  001af	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159755
  001b6	ba 13 01 00 00	 mov	 edx, 275		; 00000113H
  001bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159756
  001c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN6@parsecmd:
$LN5@parsecmd:

; 276  :     }
; 277  :     if ((*argv) && (strcasecmp(*argv, "-ascii") == 0))

  001c8	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  001d0	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  001d4	0f 84 96 00 00
	00		 je	 $LN7@parsecmd
  001da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159758
  001e1	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  001e9	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  001f2	85 c0		 test	 eax, eax
  001f4	75 7a		 jne	 SHORT $LN7@parsecmd

; 278  :     {
; 279  :         argv++;

  001f6	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  001fe	48 83 c0 08	 add	 rax, 8
  00202	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 280  :         tran_ascii = 1;

  0020a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR tran_ascii, 1

; 281  :         // "%s mode enabled"
; 282  :         if (debug) WRMSG( HHC02672, "I", "ASCII translation" );

  00214	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  0021b	74 53		 je	 SHORT $LN8@parsecmd
  0021d	b9 01 00 00 00	 mov	 ecx, 1
  00222	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00228	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159760
  0022f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00234	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159761
  0023b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00240	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159762
  00247	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0024c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00251	41 b9 03 00 00
	00		 mov	 r9d, 3
  00257	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159763
  0025e	ba 1a 01 00 00	 mov	 edx, 282		; 0000011aH
  00263	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159764
  0026a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN8@parsecmd:
$LN7@parsecmd:

; 283  :     }
; 284  :     if (*argv) din = *argv++;           // dasd image filename

  00270	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00278	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0027c	74 26		 je	 SHORT $LN9@parsecmd
  0027e	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00286	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00289	48 89 05 00 00
	00 00		 mov	 QWORD PTR din, rax
  00290	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00298	48 83 c0 08	 add	 rax, 8
  0029c	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR argv$[rsp], rax
$LN9@parsecmd:

; 285  :     if (debug)

  002a4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  002ab	74 6b		 je	 SHORT $LN10@parsecmd

; 286  :     {
; 287  :         // "%s file%s '%s'"
; 288  :         WRMSG( HHC02673, "D", "Image", "", din );

  002ad	b9 01 00 00 00	 mov	 ecx, 1
  002b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002b8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR din
  002bf	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159767
  002cb	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159768
  002d7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159769
  002e3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159770
  002ef	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002f4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f9	41 b9 03 00 00
	00		 mov	 r9d, 3
  002ff	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159771
  00306	ba 20 01 00 00	 mov	 edx, 288		; 00000120H
  0030b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159772
  00312	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN10@parsecmd:

; 289  :     }
; 290  :     if (*argv && strlen(*argv) > 3 && !memcmp(*argv, "sf=", 3))

  00318	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00320	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00324	74 5f		 je	 SHORT $LN11@parsecmd
  00326	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0032e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00331	e8 00 00 00 00	 call	 strlen
  00336	48 83 f8 03	 cmp	 rax, 3
  0033a	76 49		 jbe	 SHORT $LN11@parsecmd
  0033c	41 b8 03 00 00
	00		 mov	 r8d, 3
  00342	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159775
  00349	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00351	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00354	e8 00 00 00 00	 call	 memcmp
  00359	85 c0		 test	 eax, eax
  0035b	75 28		 jne	 SHORT $LN11@parsecmd

; 291  :     {
; 292  :         sfn = *argv++;                  // shadow file parm

  0035d	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00365	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00368	48 89 05 00 00
	00 00		 mov	 QWORD PTR sfn, rax
  0036f	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00377	48 83 c0 08	 add	 rax, 8
  0037b	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 293  :     }

  00383	eb 0b		 jmp	 SHORT $LN12@parsecmd
$LN11@parsecmd:

; 294  :     else
; 295  :         sfn = NULL;

  00385	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR sfn, 0
$LN12@parsecmd:

; 296  :     if (debug)

  00390	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  00397	74 6b		 je	 SHORT $LN13@parsecmd

; 297  :     {
; 298  :         // "%s file%s '%s'"
; 299  :         WRMSG( HHC02673, "D", "SHADOW", "(s)", sfn );

  00399	b9 01 00 00 00	 mov	 ecx, 1
  0039e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003a4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR sfn
  003ab	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  003b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159777
  003b7	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  003bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159778
  003c3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159779
  003cf	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159780
  003db	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003e0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003e5	41 b9 03 00 00
	00		 mov	 r9d, 3
  003eb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159781
  003f2	ba 2b 01 00 00	 mov	 edx, 299		; 0000012bH
  003f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159782
  003fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN13@parsecmd:

; 300  :     }
; 301  :     dadsm->f1buf.ds1recfm =

  00404	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dadsm$[rsp]
  0040c	c6 80 c6 01 00
	00 90		 mov	 BYTE PTR [rax+454], 144	; 00000090H

; 302  :                 RECFM_FORMAT_F | RECFM_BLOCKED; // recfm FB for fbcopy
; 303  :     if ((*argv) && (strcasecmp(*argv, "-recfm") == 0))

  00413	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0041b	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0041f	0f 84 74 01 00
	00		 je	 $LN14@parsecmd
  00425	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159784
  0042c	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00434	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00437	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0043d	85 c0		 test	 eax, eax
  0043f	0f 85 54 01 00
	00		 jne	 $LN14@parsecmd

; 304  :     {
; 305  :         argv++;                                 // skip -recfm

  00445	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0044d	48 83 c0 08	 add	 rax, 8
  00451	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 306  :         if ((*argv) && (strcasecmp(*argv, "fb") == 0))

  00459	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00461	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00465	0f 84 a1 00 00
	00		 je	 $LN15@parsecmd
  0046b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159787
  00472	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0047a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0047d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00483	85 c0		 test	 eax, eax
  00485	0f 85 81 00 00
	00		 jne	 $LN15@parsecmd

; 307  :         {
; 308  :             argv++;                             // skip fb

  0048b	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00493	48 83 c0 08	 add	 rax, 8
  00497	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 309  :             // "%s=%s"
; 310  :             if (debug) WRMSG( HHC02674, "D", "RECFM", "FB" );

  0049f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  004a6	74 5f		 je	 SHORT $LN17@parsecmd
  004a8	b9 01 00 00 00	 mov	 ecx, 1
  004ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159789
  004ba	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  004bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159790
  004c6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159791
  004d2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159792
  004de	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004e3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004e8	41 b9 03 00 00
	00		 mov	 r9d, 3
  004ee	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159793
  004f5	ba 36 01 00 00	 mov	 edx, 310		; 00000136H
  004fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159794
  00501	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN17@parsecmd:

; 311  :         }

  00507	e9 8d 00 00 00	 jmp	 $LN16@parsecmd
$LN15@parsecmd:

; 312  :         else
; 313  :         {
; 314  :             // "Invalid argument: %s"
; 315  :             argv++;                             // skip bad recfm

  0050c	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00514	48 83 c0 08	 add	 rax, 8
  00518	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 316  :             MSGBUF( msgbuf, "-recfm %s", *argv );

  00520	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00528	4c 8b 08	 mov	 r9, QWORD PTR [rax]
  0052b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159795
  00532	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00537	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  0053f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 317  :             WRMSG( HHC02465, "I", msgbuf);

  00545	b9 01 00 00 00	 mov	 ecx, 1
  0054a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00550	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  00558	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0055d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159796
  00564	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00569	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159797
  00570	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00575	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0057a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00580	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159798
  00587	ba 3d 01 00 00	 mov	 edx, 317		; 0000013dH
  0058c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159799
  00593	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN16@parsecmd:
$LN14@parsecmd:

; 318  :         }
; 319  :     }
; 320  :     if ((*argv) && (strcasecmp(*argv, "-lrecl") == 0))

  00599	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  005a1	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  005a5	0f 84 df 00 00
	00		 je	 $LN18@parsecmd
  005ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159801
  005b2	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  005ba	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  005bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  005c3	85 c0		 test	 eax, eax
  005c5	0f 85 bf 00 00
	00		 jne	 $LN18@parsecmd

; 321  :     {
; 322  :         argv++;                                         // skip -lrecl

  005cb	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  005d3	48 83 c0 08	 add	 rax, 8
  005d7	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 323  :         if (*argv) lrecl = atoi(*argv++);               // lrecl value

  005df	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  005e7	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  005eb	74 39		 je	 SHORT $LN19@parsecmd
  005ed	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  005f5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005f8	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv268[rsp], rax
  00600	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv268[rsp]
  00608	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  0060e	89 44 24 74	 mov	 DWORD PTR lrecl$[rsp], eax
  00612	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0061a	48 83 c0 08	 add	 rax, 8
  0061e	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR argv$[rsp], rax
$LN19@parsecmd:

; 324  :         if (debug)

  00626	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  0062d	74 5b		 je	 SHORT $LN20@parsecmd

; 325  :         {
; 326  :             // "%s=%d"
; 327  :             WRMSG( HHC02675, "D", "LRECL", lrecl );

  0062f	b9 01 00 00 00	 mov	 ecx, 1
  00634	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0063a	8b 4c 24 74	 mov	 ecx, DWORD PTR lrecl$[rsp]
  0063e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00642	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159804
  00649	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0064e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159805
  00655	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0065a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159806
  00661	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00666	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0066b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00671	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159807
  00678	ba 47 01 00 00	 mov	 edx, 327		; 00000147H
  0067d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159808
  00684	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN20@parsecmd:
$LN18@parsecmd:

; 328  :         }
; 329  :     }
; 330  :     dadsm->f1buf.ds1lrecl[0] = lrecl >> 8;      // for fbcopy

  0068a	8b 44 24 74	 mov	 eax, DWORD PTR lrecl$[rsp]
  0068e	c1 f8 08	 sar	 eax, 8
  00691	b9 01 00 00 00	 mov	 ecx, 1
  00696	48 6b c9 00	 imul	 rcx, rcx, 0
  0069a	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR dadsm$[rsp]
  006a2	88 84 0a ca 01
	00 00		 mov	 BYTE PTR [rdx+rcx+458], al

; 331  :     dadsm->f1buf.ds1lrecl[1] = lrecl - ((lrecl >> 8) << 8);

  006a9	8b 44 24 74	 mov	 eax, DWORD PTR lrecl$[rsp]
  006ad	c1 f8 08	 sar	 eax, 8
  006b0	c1 e0 08	 shl	 eax, 8
  006b3	8b 4c 24 74	 mov	 ecx, DWORD PTR lrecl$[rsp]
  006b7	2b c8		 sub	 ecx, eax
  006b9	8b c1		 mov	 eax, ecx
  006bb	b9 01 00 00 00	 mov	 ecx, 1
  006c0	48 6b c9 01	 imul	 rcx, rcx, 1
  006c4	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR dadsm$[rsp]
  006cc	88 84 0a ca 01
	00 00		 mov	 BYTE PTR [rdx+rcx+458], al

; 332  :     if ((*argv) && (strcasecmp(*argv, "-heads") == 0))

  006d3	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  006db	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  006df	74 7a		 je	 SHORT $LN21@parsecmd
  006e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159810
  006e8	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  006f0	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  006f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  006f9	85 c0		 test	 eax, eax
  006fb	75 5e		 jne	 SHORT $LN21@parsecmd

; 333  :     {
; 334  :         argv++;                                 // skip -heads

  006fd	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00705	48 83 c0 08	 add	 rax, 8
  00709	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 335  :         if (*argv) heads = atoi(*argv++);       // heads value

  00711	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00719	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0071d	74 3c		 je	 SHORT $LN22@parsecmd
  0071f	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00727	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0072a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv303[rsp], rax
  00732	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv303[rsp]
  0073a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00740	89 84 24 84 00
	00 00		 mov	 DWORD PTR heads$[rsp], eax
  00747	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0074f	48 83 c0 08	 add	 rax, 8
  00753	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR argv$[rsp], rax
$LN22@parsecmd:
$LN21@parsecmd:

; 336  :     }
; 337  :     if (debug)

  0075b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  00762	74 5e		 je	 SHORT $LN23@parsecmd

; 338  :     {
; 339  :         // "%s=%d"
; 340  :         WRMSG( HHC02675, "D", "HEADS", heads );

  00764	b9 01 00 00 00	 mov	 ecx, 1
  00769	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0076f	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR heads$[rsp]
  00776	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0077a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159813
  00781	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00786	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159814
  0078d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00792	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159815
  00799	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0079e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007a3	41 b9 03 00 00
	00		 mov	 r9d, 3
  007a9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159816
  007b0	ba 54 01 00 00	 mov	 edx, 340		; 00000154H
  007b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159817
  007bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN23@parsecmd:

; 341  :     }
; 342  :     if ((*argv) && (strcasecmp(*argv, "-abs") == 0))

  007c2	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  007ca	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  007ce	0f 84 ad 02 00
	00		 je	 $LN24@parsecmd
  007d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159819
  007db	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  007e3	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  007e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  007ec	85 c0		 test	 eax, eax
  007ee	0f 85 8d 02 00
	00		 jne	 $LN24@parsecmd

; 343  :     {
; 344  :         absvalid = 1;                               // CCHH valid

  007f4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR absvalid, 1
$LN2@parsecmd:

; 345  :         while ((*argv) && (strcasecmp(*argv, "-abs") == 0))

  007fe	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00806	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0080a	0f 84 71 02 00
	00		 je	 $LN3@parsecmd
  00810	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159820
  00817	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0081f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00822	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00828	85 c0		 test	 eax, eax
  0082a	0f 85 51 02 00
	00		 jne	 $LN3@parsecmd

; 346  :         {
; 347  :             argv++;                                 // skip -abs

  00830	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00838	48 83 c0 08	 add	 rax, 8
  0083c	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 348  :             abscyl = 0; abshead = 0; abstrk = 1;    // defaults

  00844	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR abscyl$[rsp], 0
  0084f	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR abshead$[rsp], 0
  00857	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR abstrk$[rsp], 1

; 349  :             if (*argv) abscyl = atoi(*argv++);      // abs cc

  0085f	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00867	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0086b	74 3c		 je	 SHORT $LN25@parsecmd
  0086d	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00875	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00878	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv331[rsp], rax
  00880	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv331[rsp]
  00888	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  0088e	89 84 24 80 00
	00 00		 mov	 DWORD PTR abscyl$[rsp], eax
  00895	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0089d	48 83 c0 08	 add	 rax, 8
  008a1	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR argv$[rsp], rax
$LN25@parsecmd:

; 350  :             if (*argv) abshead = atoi(*argv++);     // abs hh

  008a9	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  008b1	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  008b5	74 39		 je	 SHORT $LN26@parsecmd
  008b7	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  008bf	48 8b 00	 mov	 rax, QWORD PTR [rax]
  008c2	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv336[rsp], rax
  008ca	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv336[rsp]
  008d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  008d8	89 44 24 7c	 mov	 DWORD PTR abshead$[rsp], eax
  008dc	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  008e4	48 83 c0 08	 add	 rax, 8
  008e8	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR argv$[rsp], rax
$LN26@parsecmd:

; 351  :             if (*argv) abstrk = atoi(*argv++);      // abs tracks

  008f0	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  008f8	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  008fc	74 39		 je	 SHORT $LN27@parsecmd
  008fe	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00906	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00909	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv341[rsp], rax
  00911	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv341[rsp]
  00919	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  0091f	89 44 24 78	 mov	 DWORD PTR abstrk$[rsp], eax
  00923	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0092b	48 83 c0 08	 add	 rax, 8
  0092f	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR argv$[rsp], rax
$LN27@parsecmd:

; 352  : 
; 353  :             // Build extent entry for -abs group
; 354  :             makext(extnum, heads,

  00937	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dadsm$[rsp]
  0093f	48 05 04 02 00
	00		 add	 rax, 516		; 00000204H
  00945	8b 4c 24 78	 mov	 ecx, DWORD PTR abstrk$[rsp]
  00949	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  0094d	8b 4c 24 7c	 mov	 ecx, DWORD PTR abshead$[rsp]
  00951	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00955	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR abscyl$[rsp]
  0095d	4c 8b c0	 mov	 r8, rax
  00960	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR heads$[rsp]
  00967	8b 4c 24 70	 mov	 ecx, DWORD PTR extnum$[rsp]
  0096b	e8 00 00 00 00	 call	 makext

; 355  :                     (DSXTENT *) &dadsm->f1ext, abscyl, abshead, abstrk);
; 356  :             extnum++;

  00970	8b 44 24 70	 mov	 eax, DWORD PTR extnum$[rsp]
  00974	ff c0		 inc	 eax
  00976	89 44 24 70	 mov	 DWORD PTR extnum$[rsp], eax

; 357  :             dadsm->f1buf.ds1noepv = extnum;         // for fbcopy

  0097a	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dadsm$[rsp]
  00982	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR extnum$[rsp]
  00987	88 88 ad 01 00
	00		 mov	 BYTE PTR [rax+429], cl

; 358  :             if (debug)

  0098d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  00994	74 7d		 je	 SHORT $LN28@parsecmd

; 359  :             {
; 360  :                 // "Absolute CC %d HH %d [%04X%04X] Track %d/%X"
; 361  :                 WRMSG( HHC02676, "D", abscyl, abshead, abscyl, abshead, abstrk, abstrk);

  00996	b9 01 00 00 00	 mov	 ecx, 1
  0099b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009a1	8b 4c 24 78	 mov	 ecx, DWORD PTR abstrk$[rsp]
  009a5	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  009a9	8b 4c 24 78	 mov	 ecx, DWORD PTR abstrk$[rsp]
  009ad	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  009b1	8b 4c 24 7c	 mov	 ecx, DWORD PTR abshead$[rsp]
  009b5	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  009b9	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR abscyl$[rsp]
  009c0	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  009c4	8b 4c 24 7c	 mov	 ecx, DWORD PTR abshead$[rsp]
  009c8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  009cc	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR abscyl$[rsp]
  009d3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  009d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159825
  009de	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159826
  009ea	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  009ef	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009f4	41 b9 03 00 00
	00		 mov	 r9d, 3
  009fa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159827
  00a01	ba 69 01 00 00	 mov	 edx, 361		; 00000169H
  00a06	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159828
  00a0d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN28@parsecmd:

; 362  :             }
; 363  :             if (extnum > MAX_EXTENTS)

  00a13	83 7c 24 70 7b	 cmp	 DWORD PTR extnum$[rsp], 123 ; 0000007bH
  00a18	7e 62		 jle	 SHORT $LN29@parsecmd

; 364  :             {
; 365  :                 // "Requested number of extents %d exceeds maximum %d; utility ends"
; 366  :                 FWRMSG( stderr, HHC02494, "S", extnum, MAX_EXTENTS);

  00a1a	b9 02 00 00 00	 mov	 ecx, 2
  00a1f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a25	c7 44 24 40 7b
	00 00 00	 mov	 DWORD PTR [rsp+64], 123	; 0000007bH
  00a2d	8b 4c 24 70	 mov	 ecx, DWORD PTR extnum$[rsp]
  00a31	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00a35	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159830
  00a3c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a41	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159831
  00a48	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a4d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a52	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a58	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159832
  00a5f	ba 6e 01 00 00	 mov	 edx, 366		; 0000016eH
  00a64	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159833
  00a6b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 367  :                 exit(3);

  00a71	b9 03 00 00 00	 mov	 ecx, 3
  00a76	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN29@parsecmd:

; 368  :             }
; 369  :         }

  00a7c	e9 7d fd ff ff	 jmp	 $LN2@parsecmd
$LN3@parsecmd:
$LN24@parsecmd:

; 370  :         // if (debug) sayext(MAX_EXTENTS, dadsm->f1ext);// show extent table
; 371  :     }
; 372  :     if (debug)

  00a81	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  00a88	74 6f		 je	 SHORT $LN30@parsecmd

; 373  :     {
; 374  :         // "%s"
; 375  :         WRMSG( HHC02677, "D", "Completed Format 1 DSCB:" );

  00a8a	b9 01 00 00 00	 mov	 ecx, 1
  00a8f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a95	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159835
  00a9c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00aa1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159836
  00aa8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00aad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159837
  00ab4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ab9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00abe	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ac4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159838
  00acb	ba 77 01 00 00	 mov	 edx, 375		; 00000177H
  00ad0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159839
  00ad7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 376  :         data_dump(&dadsm->f1buf, sizeof(FORMAT1_DSCB));

  00add	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dadsm$[rsp]
  00ae5	48 05 72 01 00
	00		 add	 rax, 370		; 00000172H
  00aeb	ba 8c 00 00 00	 mov	 edx, 140		; 0000008cH
  00af0	48 8b c8	 mov	 rcx, rax
  00af3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump
$LN30@parsecmd:

; 377  :     }
; 378  :     if (*argv) argdsn = *argv++;        // [MVS dataset name/]output filename

  00af9	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00b01	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00b05	74 26		 je	 SHORT $LN31@parsecmd
  00b07	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00b0f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00b12	48 89 05 00 00
	00 00		 mov	 QWORD PTR argdsn, rax
  00b19	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00b21	48 83 c0 08	 add	 rax, 8
  00b25	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR argv$[rsp], rax
$LN31@parsecmd:

; 379  :     if (debug)

  00b2d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  00b34	74 53		 je	 SHORT $LN32@parsecmd

; 380  :     {
; 381  :         // "Dataset '%s'"
; 382  :         WRMSG( HHC02678, "D", argdsn );

  00b36	b9 01 00 00 00	 mov	 ecx, 1
  00b3b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b41	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR argdsn
  00b48	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00b4d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159842
  00b54	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b59	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159843
  00b60	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b65	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b6a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b70	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159844
  00b77	ba 7e 01 00 00	 mov	 edx, 382		; 0000017eH
  00b7c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159845
  00b83	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN32@parsecmd:

; 383  :     }
; 384  :     if ((*argv) && (            // support deprecated 'ascii' operand

  00b89	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00b91	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00b95	0f 84 b2 00 00
	00		 je	 $LN33@parsecmd
  00b9b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159848
  00ba2	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00baa	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00bad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00bb3	85 c0		 test	 eax, eax
  00bb5	74 1c		 je	 SHORT $LN34@parsecmd
  00bb7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159849
  00bbe	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00bc6	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00bc9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00bcf	85 c0		 test	 eax, eax
  00bd1	75 7a		 jne	 SHORT $LN33@parsecmd
$LN34@parsecmd:

; 385  :                 (strcasecmp(*argv, "ascii") == 0) ||
; 386  :                 (strcasecmp(*argv, "-ascii") == 0)
; 387  :                 )
; 388  :         )
; 389  :     {
; 390  :         argv++;

  00bd3	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00bdb	48 83 c0 08	 add	 rax, 8
  00bdf	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 391  :         tran_ascii = 1;

  00be7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR tran_ascii, 1

; 392  :         // "%s mode enabled"
; 393  :         if (debug) WRMSG( HHC02672, "D", "ASCII translation" );

  00bf1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  00bf8	74 53		 je	 SHORT $LN35@parsecmd
  00bfa	b9 01 00 00 00	 mov	 ecx, 1
  00bff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c05	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159851
  00c0c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00c11	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159852
  00c18	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c1d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159853
  00c24	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c29	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c2e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c34	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159854
  00c3b	ba 89 01 00 00	 mov	 edx, 393		; 00000189H
  00c40	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159855
  00c47	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN35@parsecmd:
$LN33@parsecmd:

; 394  :     }
; 395  :     set_verbose_util(0);                // default util verbosity

  00c4d	33 c9		 xor	 ecx, ecx
  00c4f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_verbose_util

; 396  :     if ((*argv) && (strcasecmp(*argv, "verbose") == 0))

  00c55	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00c5d	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00c61	0f 84 a9 01 00
	00		 je	 $LN36@parsecmd
  00c67	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159857
  00c6e	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00c76	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00c79	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00c7f	85 c0		 test	 eax, eax
  00c81	0f 85 89 01 00
	00		 jne	 $LN36@parsecmd

; 397  :     {
; 398  :         local_verbose = 1;

  00c87	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR local_verbose, 1

; 399  :         argv++;

  00c91	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00c99	48 83 c0 08	 add	 rax, 8
  00c9d	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 400  :         if (*argv) local_verbose = atoi(*argv++);

  00ca5	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00cad	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00cb1	74 3b		 je	 SHORT $LN37@parsecmd
  00cb3	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00cbb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00cbe	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv471[rsp], rax
  00cc6	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv471[rsp]
  00cce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00cd4	89 05 00 00 00
	00		 mov	 DWORD PTR local_verbose, eax
  00cda	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00ce2	48 83 c0 08	 add	 rax, 8
  00ce6	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR argv$[rsp], rax
$LN37@parsecmd:

; 401  :         if (*argv) copy_verbose = atoi(*argv++);

  00cee	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00cf6	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00cfa	74 3b		 je	 SHORT $LN38@parsecmd
  00cfc	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00d04	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00d07	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv476[rsp], rax
  00d0f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv476[rsp]
  00d17	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00d1d	89 05 00 00 00
	00		 mov	 DWORD PTR copy_verbose, eax
  00d23	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00d2b	48 83 c0 08	 add	 rax, 8
  00d2f	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR argv$[rsp], rax
$LN38@parsecmd:

; 402  :         if (*argv)

  00d37	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00d3f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00d43	0f 84 c7 00 00
	00		 je	 $LN39@parsecmd

; 403  :         {
; 404  :             util_verbose = atoi(*argv++);

  00d49	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00d51	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00d54	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv481[rsp], rax
  00d5c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv481[rsp]
  00d64	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00d6a	89 84 24 88 00
	00 00		 mov	 DWORD PTR util_verbose$[rsp], eax
  00d71	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00d79	48 83 c0 08	 add	 rax, 8
  00d7d	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 405  :             set_verbose_util(util_verbose);

  00d85	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR util_verbose$[rsp], 0
  00d8d	75 0d		 jne	 SHORT $LN44@parsecmd
  00d8f	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv484[rsp], 0
  00d9a	eb 0b		 jmp	 SHORT $LN45@parsecmd
$LN44@parsecmd:
  00d9c	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv484[rsp], 1
$LN45@parsecmd:
  00da7	0f b6 8c 24 8c
	00 00 00	 movzx	 ecx, BYTE PTR tv484[rsp]
  00daf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_verbose_util

; 406  :             if (debug)

  00db5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  00dbc	74 52		 je	 SHORT $LN40@parsecmd

; 407  :             {
; 408  :                 // "Utility verbose %d"
; 409  :                 WRMSG( HHC02679, "D", util_verbose );

  00dbe	b9 01 00 00 00	 mov	 ecx, 1
  00dc3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00dc9	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR util_verbose$[rsp]
  00dd0	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00dd4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159862
  00ddb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00de0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159863
  00de7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00dec	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00df1	41 b9 03 00 00
	00		 mov	 r9d, 3
  00df7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159864
  00dfe	ba 99 01 00 00	 mov	 edx, 409		; 00000199H
  00e03	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159865
  00e0a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN40@parsecmd:
$LN39@parsecmd:
$LN36@parsecmd:

; 410  :             }
; 411  :         }
; 412  :     }
; 413  : 
; 414  :     //  If the user specified expert mode without -abs, give help & exit
; 415  :     //  Additionally, if the user has "extra" parms, show help & exit
; 416  :     //  No "extraneous parms" message is issued, since some of the code
; 417  :     //  above forces *argv to be true when it wants help displayed
; 418  : 
; 419  :     if ((argc < 3) || (*argv) || ((expert) && (!absvalid)))

  00e10	83 bc 24 70 01
	00 00 03	 cmp	 DWORD PTR argc$[rsp], 3
  00e18	7c 20		 jl	 SHORT $LN42@parsecmd
  00e1a	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00e22	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00e26	75 12		 jne	 SHORT $LN42@parsecmd
  00e28	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR expert, 0
  00e2f	74 21		 je	 SHORT $LN41@parsecmd
  00e31	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR absvalid, 0
  00e38	75 18		 jne	 SHORT $LN41@parsecmd
$LN42@parsecmd:

; 420  :     {
; 421  :         showhelp(pgm);                     // show syntax before bailing

  00e3a	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00e42	e8 00 00 00 00	 call	 showhelp

; 422  :         exit(2);

  00e47	b9 02 00 00 00	 mov	 ecx, 2
  00e4c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN41@parsecmd:

; 423  :     }
; 424  :     return 0;

  00e52	33 c0		 xor	 eax, eax
$LN43@parsecmd:

; 425  : }

  00e54	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00e5c	48 33 cc	 xor	 rcx, rsp
  00e5f	e8 00 00 00 00	 call	 __security_check_cookie
  00e64	48 81 c4 68 01
	00 00		 add	 rsp, 360		; 00000168H
  00e6b	c3		 ret	 0
parsecmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdseq.c
_TEXT	SEGMENT
part1$ = 96
part2$ = 352
part4$ = 864
part3$ = 1888
__$ArrayPad$ = 5984
pgm$ = 6016
showhelp PROC

; 143  : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	b8 78 17 00 00	 mov	 eax, 6008		; 00001778H
  0000a	e8 00 00 00 00	 call	 __chkstk
  0000f	48 2b e0	 sub	 rsp, rax
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 60
	17 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 144  :     char part1[256];
; 145  :     char part2[512];
; 146  :     char part3[4096];
; 147  :     char part4[1024];
; 148  : 
; 149  :     if (expert)

  00024	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR expert, 0
  0002b	74 1a		 je	 SHORT $LN2@showhelp

; 150  :     {
; 151  :         strlcpy( part1,

  0002d	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159705
  0003a	48 8d 4c 24 60	 lea	 rcx, QWORD PTR part1$[rsp]
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 152  :             "[-debug] [-expert] [-ascii] image [sf=shadow] [attr] filespec\n"
; 153  :             "HHC02660I   -debug    optional - Enables debug mode, additional debug help appears\n"
; 154  :             , sizeof( part1 ));
; 155  :     }

  00045	eb 18		 jmp	 SHORT $LN3@showhelp
$LN2@showhelp:

; 156  :     else
; 157  :     {
; 158  :         strlcpy( part1,

  00047	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159706
  00054	48 8d 4c 24 60	 lea	 rcx, QWORD PTR part1$[rsp]
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN3@showhelp:

; 159  :             "[-expert] [-ascii] image [sf=shadow] filespec\n"
; 160  :             , sizeof( part1 ));
; 161  :     }
; 162  : 
; 163  :     strlcpy( part2,

  0005f	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159707
  0006c	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR part2$[rsp]
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 164  :         "HHC02660I   -expert   optional - Additional help describes expert operands\n"
; 165  :         "HHC02660I   -ascii    optional - translate output file to ascii, trim trailing blanks\n"
; 166  :         "HHC02660I   image     required - [path/]filename of dasd image file (dasd volume)\n"
; 167  :         "HHC02660I   shadow    optional - [path/]filename of shadow file (note sf=)\n"
; 168  :         , sizeof( part2 ));
; 169  : 
; 170  :     if (expert)

  0007a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR expert, 0
  00081	74 22		 je	 SHORT $LN4@showhelp

; 171  :     {
; 172  :         MSGBUF( part3,

  00083	41 b9 7b 00 00
	00		 mov	 r9d, 123		; 0000007bH
  00089	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159710
  00090	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  00095	48 8d 8c 24 60
	07 00 00	 lea	 rcx, QWORD PTR part3$[rsp]
  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 173  :             "HHC02660I   ALL EXPERT FACILITIES ARE EXPERIMENTAL\n"
; 174  :             "HHC02660I   attr      optional - dataset attributes (only useful with -abs)\n"
; 175  :             "HHC02660I             attr syntax: [-recfm fb] [-lrecl aa]\n"
; 176  :             "HHC02660I             -recfm designates RECFM, reserved for future support\n"
; 177  :             "HHC02660I             fb - fixed, blocked (only RECFM currently supported)\n"
; 178  :             "HHC02660I             -lrecl designates dataset LRECL\n"
; 179  :             "HHC02660I             aa - decimal logical record length (default 80)\n"
; 180  :             "HHC02660I                  Blocksize need not be specified; dasdseq handles whatever\n"
; 181  :             "HHC02660I                  block size comes off the volume.\n"
; 182  :             "HHC02660I   filespec  required (optional sub-operands in the following order):\n"
; 183  :             "HHC02660I                  [-heads xx]\n"
; 184  :             "HHC02660I                  [-abs cc hh tt] [...] [-abs cc hh tt ]\n"
; 185  :             "HHC02660I                  filename\n"
; 186  :             "HHC02660I             When -abs is -not- specified,\n"
; 187  :             "HHC02660I                  Filename specifies the MVS DSORG=PS dataset on the volume.\n"
; 188  :             "HHC02660I                  The dasd image volume containing the dataset must have a valid VTOC\n"
; 189  :             "HHC02660I                  structure, and a F1 DSCB describing the dataset.\n"
; 190  :             "HHC02660I                  Specifying -debug will (eventually) display extent information.\n"
; 191  :             "HHC02660I             When -abs is specified, each -abs group specifies one dataset extent.\n"
; 192  :             "HHC02660I                  For multi-extent datasets, -abs groups may be repeated as needed,\n"
; 193  :             "HHC02660I                  in the order in which the dataset's extents occur.\n"
; 194  :             "HHC02660I                  A maximum of %d extents are supported.\n"
; 195  :             "HHC02660I                  No VTOC structure is implied, a F1 DSCB will not be sought.\n"
; 196  :             "HHC02660I                  Dasdseq will frequently report 'track not found in extent table'\n"
; 197  :             "HHC02660I                  (along with a message from fbcopy about rc -1 from convert_tt)\n"
; 198  :             "HHC02660I                  due to potentially missing EOF markers in the extent, and the\n"
; 199  :             "HHC02660I                  fact that the F1 DSCB DS1LSTAR field is not valid.\n"
; 200  :             "HHC02660I                  Check your output file before you panic.\n"
; 201  :             "HHC02660I                  Fbcopy ignores EOF, in case you are attempting to recovery PDS\n"
; 202  :             "HHC02660I                  member(s) from a damaged dasd volume, preferring to wait until\n"
; 203  :             "HHC02660I                  all tracks in the extent have been processed.\n"
; 204  :             "HHC02660I                  Tracks containing PDS members may have more than one EOF per track.\n"
; 205  :             "HHC02660I                  Expect a lot of associated manual effort with -abs.\n"
; 206  :             "HHC02660I             -heads defines # tracks per cylinder on device;\n"
; 207  :             "HHC02660I             xx - decimal number of heads per cylinder on device\n"
; 208  :             "HHC02660I                  default xx = 15 (valid for 3380s, 3390s)\n"
; 209  :             "HHC02660I             -abs indicates the beginning of each extent's location in terms of\n"
; 210  :             "HHC02660I                  absolute dasd image location.\n"
; 211  :             "HHC02660I             cc - decimal cylinder number (relative zero)\n"
; 212  :             "HHC02660I             hh - decimal head number (relative zero)\n"
; 213  :             "HHC02660I             tt - decimal number of tracks in extent\n"
; 214  :             "HHC02660I             filename will be the filename of the output file in the current directory;\n"
; 215  :             "HHC02660I                  output filename in the same case as the command line filename.\n"
; 216  :             , MAX_EXTENTS );
; 217  :     }

  000a3	eb 1b		 jmp	 SHORT $LN5@showhelp
$LN4@showhelp:

; 218  :     else
; 219  :     {
; 220  :         strlcpy( part3,

  000a5	41 b8 00 10 00
	00		 mov	 r8d, 4096		; 00001000H
  000ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159711
  000b2	48 8d 8c 24 60
	07 00 00	 lea	 rcx, QWORD PTR part3$[rsp]
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN5@showhelp:

; 221  :             "HHC02660I   filespec  required - MVS dataset name of DSORG=PS dataset, output filename\n"
; 222  :             , sizeof( part3 ));
; 223  :     }
; 224  : 
; 225  :     if (debug)

  000c0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  000c7	74 1d		 je	 SHORT $LN6@showhelp

; 226  :     {
; 227  :         strlcpy( part4,

  000c9	41 b8 00 04 00
	00		 mov	 r8d, 1024		; 00000400H
  000cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159714
  000d6	48 8d 8c 24 60
	03 00 00	 lea	 rcx, QWORD PTR part4$[rsp]
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 228  :             "HHC02660I Debugging options (at end of dasdseq command)\n"
; 229  :             "HHC02660I   [verbose [x [y [z]]]]\n"
; 230  :             "HHC02660I   verbose   debug output level (default = 0 when not specified)\n"
; 231  :             "HHC02660I       x  main program (default = 1 when verbose specified)\n"
; 232  :             "HHC02660I       y  copyfile + showf1\n"
; 233  :             "HHC02660I       z  dasdutil\n"
; 234  :             "HHC02660I       Higher numbers produces more output"
; 235  :             , sizeof( part4 ));
; 236  :     }

  000e4	eb 1b		 jmp	 SHORT $LN7@showhelp
$LN6@showhelp:

; 237  :     else
; 238  :         STRLCPY( part4, "" );

  000e6	41 b8 00 04 00
	00		 mov	 r8d, 1024		; 00000400H
  000ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159715
  000f3	48 8d 8c 24 60
	03 00 00	 lea	 rcx, QWORD PTR part4$[rsp]
  000fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN7@showhelp:

; 239  : 
; 240  :     // HHC02660 "Usage: %s %s%s%s%s"
; 241  :     WRMSG( HHC02660, "I", pgm, part1, part2, part3, part4 );

  00101	b9 01 00 00 00	 mov	 ecx, 1
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0010c	48 8d 8c 24 60
	03 00 00	 lea	 rcx, QWORD PTR part4$[rsp]
  00114	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00119	48 8d 8c 24 60
	07 00 00	 lea	 rcx, QWORD PTR part3$[rsp]
  00121	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00126	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR part2$[rsp]
  0012e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00133	48 8d 4c 24 60	 lea	 rcx, QWORD PTR part1$[rsp]
  00138	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0013d	48 8b 8c 24 80
	17 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00145	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0014a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159716
  00151	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00156	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159717
  0015d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00162	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00167	41 b9 03 00 00
	00		 mov	 r9d, 3
  0016d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159718
  00174	ba f1 00 00 00	 mov	 edx, 241		; 000000f1H
  00179	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159719
  00180	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 242  : 
; 243  : }

  00186	48 8b 8c 24 60
	17 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0018e	48 33 cc	 xor	 rcx, rsp
  00191	e8 00 00 00 00	 call	 __security_check_cookie
  00196	48 81 c4 78 17
	00 00		 add	 rsp, 6008		; 00001778H
  0019d	c3		 ret	 0
showhelp ENDP
_TEXT	ENDS
END
