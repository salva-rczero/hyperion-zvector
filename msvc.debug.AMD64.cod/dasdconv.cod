; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	twelvehex00
PUBLIC	ebcdicvol1
PUBLIC	gz_magic_id
PUBLIC	ckd_ident
_BSS	SEGMENT
twelvehex00 DB	0cH DUP (?)
_BSS	ENDS
_DATA	SEGMENT
ebcdicvol1 DB	0e5H
	DB	0d6H
	DB	0d3H
	DB	0f1H
gz_magic_id DB	01fH
	DB	08bH
	ORG $+2
ckd_ident DB	043H
	DB	04bH
	DB	044H
	DB	05fH
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
VOL1_KEYA DB	056H
	DB	04fH
	DB	04cH
	DB	031H
VOL1_KEY DB	0e5H
	DB	0d6H
	DB	0d3H
	DB	0f1H
IPL1_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f1H
IPL2_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f2H
iplpsw	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
iplccw1	DB	06H
	DB	00H
	DB	03aH
	DB	098H
	DB	060H
	DB	00H
	DB	00H
	DB	060H
iplccw2	DB	08H
	DB	00H
	DB	03aH
	DB	098H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
noiplpsw DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0fH
noiplccw1 DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
noiplccw2 DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
ipl2data DB	07H
	DB	00H
	DB	03aH
	DB	0b8H
	DB	040H
	DB	00H
	DB	00H
	DB	06H
	DB	031H
	DB	00H
	DB	03aH
	DB	0beH
	DB	040H
	DB	00H
	DB	00H
	DB	05H
	DB	08H
	DB	00H
	DB	03aH
	DB	0a0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	06H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	00H
	DB	07fH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	04H
CONST	ENDS
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	store_fw_noswap
PUBLIC	main
EXTRN	__imp__errno:PROC
EXTRN	strchr:PROC
EXTRN	strrchr:PROC
EXTRN	strcmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_exit:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp_read:PROC
EXTRN	__imp_write:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_strlcat:PROC
EXTRN	__imp_initialize_utility:PROC
EXTRN	__imp_make_asciiz:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_usleep:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_fprintf:PROC
EXTRN	__imp_w32_hopen:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_dh_devid_str:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_extgui:DWORD
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
$SG168852 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$delayed_exit DD imagerel delayed_exit
	DD	imagerel delayed_exit+34
	DD	imagerel $unwind$delayed_exit
$pdata$argexit DD imagerel argexit
	DD	imagerel argexit+222
	DD	imagerel $unwind$argexit
$pdata$read_input_data DD imagerel read_input_data
	DD	imagerel read_input_data+399
	DD	imagerel $unwind$read_input_data
$pdata$find_input_record DD imagerel find_input_record
	DD	imagerel find_input_record+613
	DD	imagerel $unwind$find_input_record
$pdata$open_input_image DD imagerel open_input_image
	DD	imagerel open_input_image+2332
	DD	imagerel $unwind$open_input_image
$pdata$convert_ckd_file DD imagerel convert_ckd_file
	DD	imagerel convert_ckd_file+2782
	DD	imagerel $unwind$convert_ckd_file
$pdata$convert_ckd DD imagerel convert_ckd
	DD	imagerel convert_ckd+1594
	DD	imagerel $unwind$convert_ckd
$pdata$main DD	imagerel $LN31
	DD	imagerel $LN31+1495
	DD	imagerel $unwind$main
pdata	ENDS
_DATA	SEGMENT
$SG168803 DB	'-', 00H
	ORG $+2
$SG168800 DB	'DASD CKD image conversion', 00H
	ORG $+2
$SG168807 DB	'-r', 00H
	ORG $+1
$SG168801 DB	'dasdconv', 00H
	ORG $+3
$SG168810 DB	'-q', 00H
	ORG $+1
$SG168813 DB	'-lfs', 00H
	ORG $+3
$SG168828 DB	'E', 00H
	ORG $+2
$SG168832 DB	'I', 00H
	ORG $+2
$SG168829 DB	'HHC02416%s Unknown device type %04X', 0aH, 00H
	ORG $+3
$SG168830 DB	'main', 00H
	ORG $+3
$SG168831 DB	'dasdconv.c', 00H
	ORG $+1
$SG168848 DB	'I', 00H
	ORG $+2
$SG168833 DB	'HHC02423%s DASD operation completed', 0aH, 00H
	ORG $+3
$SG168834 DB	'main', 00H
	ORG $+3
$SG168835 DB	'dasdconv.c', 00H
	ORG $+1
$SG168853 DB	'I', 00H
	ORG $+2
$SG168847 DB	0aH, 'HHC02410I   -lfs   build one large output file', 00H
$SG168849 DB	'HHC02410%s Usage: %s [options] infile outfile', 0aH, 'HH'
	DB	'C02410I   infile:  name of input HDR-30 CKD image file (''-'''
	DB	' means stdin)', 0aH, 'HHC02410I   outfile: name of AWSCKD ima'
	DB	'ge file to be created', 0aH, 'HHC02410I options:', 0aH, 'HHC0'
	DB	'2410I   -r     replace existing output file', 0aH, 'HHC02410I'
	DB	'   -q     suppress progress messages%s', 0aH, 00H
	ORG $+2
$SG168880 DB	'read()', 00H
	ORG $+1
$SG168881 DB	'E', 00H
	ORG $+2
$SG168850 DB	'argexit', 00H
$SG168851 DB	'dasdconv.c', 00H
	ORG $+5
$SG168854 DB	'HHC02410%s Usage: %s [options] infile outfile', 0aH, 'HH'
	DB	'C02410I   infile:  name of input HDR-30 CKD image file (''-'''
	DB	' means stdin)', 0aH, 'HHC02410I   outfile: name of AWSCKD ima'
	DB	'ge file to be created', 0aH, 'HHC02410I options:', 0aH, 'HHC0'
	DB	'2410I   -r     replace existing output file', 0aH, 'HHC02410I'
	DB	'   -q     suppress progress messages%s', 0aH, 00H
	ORG $+2
$SG168887 DB	'read()', 00H
	ORG $+1
$SG168888 DB	'E', 00H
	ORG $+2
$SG168855 DB	'argexit', 00H
$SG168856 DB	'dasdconv.c', 00H
	ORG $+1
$SG168995 DB	'-', 00H
	ORG $+2
$SG168882 DB	'HHC02412%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168883 DB	'read_input_data', 00H
$SG168884 DB	'dasdconv.c', 00H
	ORG $+1
$SG168998 DB	'E', 00H
	ORG $+2
$SG168886 DB	'unexpected end of file', 00H
	ORG $+1
$SG168889 DB	'HHC02412%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168890 DB	'read_input_data', 00H
$SG168891 DB	'dasdconv.c', 00H
	ORG $+1
$SG168997 DB	'open()', 00H
	ORG $+1
$SG169003 DB	'E', 00H
	ORG $+2
$SG168999 DB	'HHC02412%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169000 DB	'open_input_image', 00H
	ORG $+3
$SG169008 DB	'I', 00H
	ORG $+2
$SG169001 DB	'dasdconv.c', 00H
	ORG $+5
$SG169004 DB	'HHC02413%s Dasdconv is compiled without compress support'
	DB	' and input is compressed', 0aH, 00H
	ORG $+2
$SG169029 DB	'E', 00H
	ORG $+2
$SG169005 DB	'open_input_image', 00H
	ORG $+3
$SG169042 DB	'E', 00H
	ORG $+2
$SG169006 DB	'dasdconv.c', 00H
	ORG $+1
$SG169048 DB	'E', 00H
	ORG $+2
$SG169009 DB	'HHC02414%s Input file is already in CKD format, use dasd'
	DB	'copy', 0aH, 00H
	ORG $+2
$SG169010 DB	'open_input_image', 00H
	ORG $+3
$SG169052 DB	'(NONE)', 00H
	ORG $+1
$SG169155 DB	'E', 00H
	ORG $+2
$SG169011 DB	'dasdconv.c', 00H
	ORG $+5
$SG169030 DB	'HHC02415%s Unknown device type %04X at offset 00000000 i'
	DB	'n input file', 0aH, 00H
	ORG $+2
$SG169031 DB	'open_input_image', 00H
	ORG $+3
$SG169154 DB	'open()', 00H
	ORG $+1
$SG169162 DB	'E', 00H
	ORG $+2
$SG169032 DB	'dasdconv.c', 00H
	ORG $+1
$SG169175 DB	'E', 00H
	ORG $+2
$SG169043 DB	'HHC02416%s Unknown device type %04X', 0aH, 00H
	ORG $+3
$SG169044 DB	'open_input_image', 00H
	ORG $+3
$SG169179 DB	'E', 00H
	ORG $+2
$SG169045 DB	'dasdconv.c', 00H
	ORG $+1
$SG169185 DB	'E', 00H
	ORG $+2
$SG169047 DB	'malloc(%u)', 00H
	ORG $+1
$SG169195 DB	'E', 00H
	ORG $+2
$SG169049 DB	'HHC02412%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169050 DB	'open_input_image', 00H
	ORG $+3
$SG169201 DB	'E', 00H
	ORG $+2
$SG169051 DB	'dasdconv.c', 00H
	ORG $+1
$SG169205 DB	'I', 00H
	ORG $+2
$SG169156 DB	'HHC02412%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169157 DB	'convert_ckd_file', 00H
	ORG $+3
$SG169275 DB	'E', 00H
	ORG $+2
$SG169158 DB	'dasdconv.c', 00H
	ORG $+1
$SG169281 DB	'E', 00H
	ORG $+2
$SG169160 DB	'incomplete', 00H
	ORG $+1
$SG169285 DB	'I', 00H
	ORG $+2
$SG169161 DB	'write()', 00H
$SG169163 DB	'HHC02412%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169164 DB	'convert_ckd_file', 00H
	ORG $+3
$SG169295 DB	'_1', 00H
	ORG $+1
$SG169165 DB	'dasdconv.c', 00H
	ORG $+1
$SG169296 DB	'_1', 00H
	ORG $+1
$SG169168 DB	'CYL=%u', 0aH, 00H
$SG169170 DB	'Writing cylinder %u', 0dH, 00H
	ORG $+3
$SG169176 DB	'HHC02417%s Invalid track header at offset 0x%16.16llX', 0aH
	DB	00H
	ORG $+1
$SG169177 DB	'convert_ckd_file', 00H
	ORG $+7
$SG169178 DB	'dasdconv.c', 00H
	ORG $+5
$SG169180 DB	'HHC02418%s Expected CCHH %04X%04X, found CCHH %04X%04X', 0aH
	DB	00H
$SG169181 DB	'convert_ckd_file', 00H
	ORG $+7
$SG169182 DB	'dasdconv.c', 00H
	ORG $+5
$SG169186 DB	'HHC02419%s Invalid record header (rc %d) at offset %04X '
	DB	'in trk at CCHH %04X%04X at offset 0x%16.16llX in file %s', 0aH
	DB	00H
	ORG $+6
$SG169187 DB	'convert_ckd_file', 00H
	ORG $+7
$SG169188 DB	'dasdconv.c', 00H
	ORG $+5
$SG169193 DB	'incomplete', 00H
	ORG $+5
$SG169194 DB	'write()', 00H
$SG169196 DB	'HHC02412%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169197 DB	'convert_ckd_file', 00H
	ORG $+7
$SG169198 DB	'dasdconv.c', 00H
	ORG $+5
$SG169200 DB	'close()', 00H
$SG169202 DB	'HHC02412%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169203 DB	'convert_ckd_file', 00H
	ORG $+7
$SG169204 DB	'dasdconv.c', 00H
	ORG $+5
$SG169206 DB	'HHC02420%s %u cylinders succesfully written to file %s', 0aH
	DB	00H
$SG169207 DB	'convert_ckd_file', 00H
	ORG $+7
$SG169208 DB	'dasdconv.c', 00H
	ORG $+5
$SG169276 DB	'HHC02421%s Cylinder count %u is outside range %u-%u', 0aH
	DB	00H
	ORG $+3
$SG169277 DB	'convert_ckd', 00H
	ORG $+4
$SG169278 DB	'dasdconv.c', 00H
	ORG $+5
$SG169280 DB	'malloc(%u)', 00H
	ORG $+5
$SG169282 DB	'HHC02412%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169283 DB	'convert_ckd', 00H
	ORG $+4
$SG169284 DB	'dasdconv.c', 00H
	ORG $+5
$SG169286 DB	'HHC02422%s Converting %04X volume %s: %u cyls, %u trks/c'
	DB	'yl, %u bytes/trk', 0aH, 00H
	ORG $+6
$SG169287 DB	'convert_ckd', 00H
	ORG $+4
$SG169288 DB	'dasdconv.c', 00H
	ORG $+5
$SG169290 DB	'CYLS=%u', 0aH, 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:main
	DD	01aH
	DD	05bfH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:convert_ckd
	DD	023H
	DD	0622H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:convert_ckd_file
	DD	026H
	DD	0ac4H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:open_input_image
	DD	027H
	DD	08adH
voltbl	ENDS
xdata	SEGMENT
$unwind$delayed_exit DD 010801H
	DD	04208H
$unwind$argexit DD 010d01H
	DD	0a20dH
$unwind$read_input_data DD 011701H
	DD	0c217H
$unwind$find_input_record DD 011801H
	DD	08218H
$unwind$open_input_image DD 042f19H
	DD	049011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0230H
$unwind$convert_ckd_file DD 042e19H
	DD	08b011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0440H
$unwind$convert_ckd DD 022b19H
	DD	0450119H
	DD	imagerel __GSHandlerCheck
	DD	0210H
$unwind$main DD	022219H
	DD	05b0110H
	DD	imagerel __GSHandlerCheck
	DD	02c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdconv.c
_TEXT	SEGMENT
tv189 = 112
maxdlen$ = 116
heads$ = 120
devtype$ = 124
quiet$ = 128
repl$ = 132
lfs$ = 136
ifd$ = 140
pgm$ = 144
tv190 = 152
volcyls$ = 156
itrklen$ = 160
itrkbuf$ = 168
volser$ = 176
ifname$ = 192
ofname$ = 448
__$ArrayPad$ = 704
argc$ = 736
argv$ = 744
main	PROC

; 106  : {

$LN31:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 81 ec d8 02
	00 00		 sub	 rsp, 728		; 000002d8H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 c0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 107  : char           *pgm;                    /* less any extension (.ext) */
; 108  : IFD             ifd;                    /* Input file descriptor     */
; 109  : int             repl = 0;               /* 1=replace existing file   */

  00022	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR repl$[rsp], 0

; 110  : int             quiet = 0;              /* 1=suppress progress msgs  */

  0002d	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR quiet$[rsp], 0

; 111  : BYTE           *itrkbuf;                /* -> Input track buffer     */
; 112  : U32             itrklen;                /* Input track length        */
; 113  : U32             volcyls;                /* Total cylinders on volume */
; 114  : U32             heads = 0;              /* Number of tracks/cylinder */

  00038	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR heads$[rsp], 0

; 115  : U32             maxdlen = 0;            /* Maximum R1 data length    */

  00040	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR maxdlen$[rsp], 0

; 116  : U16             devtype;                /* Device type               */
; 117  : char            ifname[256];            /* Input file name           */
; 118  : char            ofname[256];            /* Output file name          */
; 119  : BYTE            volser[7];              /* Volume serial (ASCIIZ)    */
; 120  : int             lfs = 0;                /* 1 = Build large file      */

  00048	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR lfs$[rsp], 0

; 121  : 
; 122  :     INITIALIZE_UTILITY( UTILITY_NAME, UTILITY_DESC, &pgm );

  00053	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR pgm$[rsp]
  0005b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00060	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168800
  00067	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168801
  0006e	48 8b 94 24 e8
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00076	8b 8c 24 e0 02
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_initialize_utility
  00083	89 84 24 e0 02
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 123  : 
; 124  :     /* Process the options in the argument list */
; 125  :     for (; argc > 1; argc--, argv++)

  0008a	eb 24		 jmp	 SHORT $LN4@main
$LN2@main:
  0008c	8b 84 24 e0 02
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00093	ff c8		 dec	 eax
  00095	89 84 24 e0 02
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  0009c	48 8b 84 24 e8
	02 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  000a4	48 83 c0 08	 add	 rax, 8
  000a8	48 89 84 24 e8
	02 00 00	 mov	 QWORD PTR argv$[rsp], rax
$LN4@main:
  000b0	83 bc 24 e0 02
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  000b8	0f 8e 0a 01 00
	00		 jle	 $LN3@main

; 126  :     {
; 127  :         if (strcmp(argv[1], "-") == 0) break;

  000be	b8 08 00 00 00	 mov	 eax, 8
  000c3	48 6b c0 01	 imul	 rax, rax, 1
  000c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168803
  000ce	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000d6	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  000da	e8 00 00 00 00	 call	 strcmp
  000df	85 c0		 test	 eax, eax
  000e1	75 05		 jne	 SHORT $LN7@main
  000e3	e9 e0 00 00 00	 jmp	 $LN3@main
$LN7@main:

; 128  :         if (argv[1][0] != '-') break;

  000e8	b8 08 00 00 00	 mov	 eax, 8
  000ed	48 6b c0 01	 imul	 rax, rax, 1
  000f1	b9 01 00 00 00	 mov	 ecx, 1
  000f6	48 6b c9 00	 imul	 rcx, rcx, 0
  000fa	48 8b 94 24 e8
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00102	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00106	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  0010a	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0010d	74 05		 je	 SHORT $LN8@main
  0010f	e9 b4 00 00 00	 jmp	 $LN3@main
$LN8@main:

; 129  :         if (strcmp(argv[1], "-r") == 0)

  00114	b8 08 00 00 00	 mov	 eax, 8
  00119	48 6b c0 01	 imul	 rax, rax, 1
  0011d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168807
  00124	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0012c	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00130	e8 00 00 00 00	 call	 strcmp
  00135	85 c0		 test	 eax, eax
  00137	75 0d		 jne	 SHORT $LN9@main

; 130  :             repl = 1;

  00139	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR repl$[rsp], 1
  00144	eb 7d		 jmp	 SHORT $LN10@main
$LN9@main:

; 131  :         else if (strcmp(argv[1], "-q") == 0)

  00146	b8 08 00 00 00	 mov	 eax, 8
  0014b	48 6b c0 01	 imul	 rax, rax, 1
  0014f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168810
  00156	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0015e	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00162	e8 00 00 00 00	 call	 strcmp
  00167	85 c0		 test	 eax, eax
  00169	75 0d		 jne	 SHORT $LN11@main

; 132  :             quiet = 1;

  0016b	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR quiet$[rsp], 1
  00176	eb 4b		 jmp	 SHORT $LN12@main
$LN11@main:

; 133  :         else
; 134  :         if (sizeof(off_t) > 4 && strcmp(argv[1], "-lfs") == 0)

  00178	33 c0		 xor	 eax, eax
  0017a	83 f8 01	 cmp	 eax, 1
  0017d	74 32		 je	 SHORT $LN13@main
  0017f	b8 08 00 00 00	 mov	 eax, 8
  00184	48 6b c0 01	 imul	 rax, rax, 1
  00188	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168813
  0018f	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00197	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0019b	e8 00 00 00 00	 call	 strcmp
  001a0	85 c0		 test	 eax, eax
  001a2	75 0d		 jne	 SHORT $LN13@main

; 135  :             lfs = 1;

  001a4	c7 84 24 88 00
	00 00 01 00 00
	00		 mov	 DWORD PTR lfs$[rsp], 1
  001af	eb 12		 jmp	 SHORT $LN14@main
$LN13@main:

; 136  :         else
; 137  :             argexit(5, pgm);

  001b1	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pgm$[rsp]
  001b9	b9 05 00 00 00	 mov	 ecx, 5
  001be	e8 00 00 00 00	 call	 argexit
$LN14@main:
$LN12@main:
$LN10@main:

; 138  :     }

  001c3	e9 c4 fe ff ff	 jmp	 $LN2@main
$LN3@main:

; 139  :     if (argc != 3)

  001c8	83 bc 24 e0 02
	00 00 03	 cmp	 DWORD PTR argc$[rsp], 3
  001d0	74 12		 je	 SHORT $LN15@main

; 140  :         argexit(5, pgm);

  001d2	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pgm$[rsp]
  001da	b9 05 00 00 00	 mov	 ecx, 5
  001df	e8 00 00 00 00	 call	 argexit
$LN15@main:

; 141  : 
; 142  :     /* The first argument is the input file name */
; 143  :     if (argv[1] == NULL || strlen(argv[1]) == 0
; 144  :         || strlen(argv[1]) > sizeof(ifname)-1)

  001e4	b8 08 00 00 00	 mov	 eax, 8
  001e9	48 6b c0 01	 imul	 rax, rax, 1
  001ed	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001f5	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  001fa	74 41		 je	 SHORT $LN17@main
  001fc	b8 08 00 00 00	 mov	 eax, 8
  00201	48 6b c0 01	 imul	 rax, rax, 1
  00205	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0020d	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00211	e8 00 00 00 00	 call	 strlen
  00216	48 85 c0	 test	 rax, rax
  00219	74 22		 je	 SHORT $LN17@main
  0021b	b8 08 00 00 00	 mov	 eax, 8
  00220	48 6b c0 01	 imul	 rax, rax, 1
  00224	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0022c	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00230	e8 00 00 00 00	 call	 strlen
  00235	48 3d ff 00 00
	00		 cmp	 rax, 255		; 000000ffH
  0023b	76 12		 jbe	 SHORT $LN16@main
$LN17@main:

; 145  :         argexit(1, pgm);

  0023d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pgm$[rsp]
  00245	b9 01 00 00 00	 mov	 ecx, 1
  0024a	e8 00 00 00 00	 call	 argexit
$LN16@main:

; 146  :     STRLCPY( ifname, argv[1] );

  0024f	b8 08 00 00 00	 mov	 eax, 8
  00254	48 6b c0 01	 imul	 rax, rax, 1
  00258	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0025e	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00266	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  0026a	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR ifname$[rsp]
  00272	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 147  : 
; 148  :     /* The second argument is the output file name */
; 149  :     if (argv[2] == NULL || strlen(argv[2]) == 0
; 150  :         || strlen(argv[2]) > sizeof(ofname)-1)

  00278	b8 08 00 00 00	 mov	 eax, 8
  0027d	48 6b c0 02	 imul	 rax, rax, 2
  00281	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00289	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  0028e	74 41		 je	 SHORT $LN19@main
  00290	b8 08 00 00 00	 mov	 eax, 8
  00295	48 6b c0 02	 imul	 rax, rax, 2
  00299	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002a1	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  002a5	e8 00 00 00 00	 call	 strlen
  002aa	48 85 c0	 test	 rax, rax
  002ad	74 22		 je	 SHORT $LN19@main
  002af	b8 08 00 00 00	 mov	 eax, 8
  002b4	48 6b c0 02	 imul	 rax, rax, 2
  002b8	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002c0	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  002c4	e8 00 00 00 00	 call	 strlen
  002c9	48 3d ff 00 00
	00		 cmp	 rax, 255		; 000000ffH
  002cf	76 12		 jbe	 SHORT $LN18@main
$LN19@main:

; 151  :         argexit(2, pgm);

  002d1	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pgm$[rsp]
  002d9	b9 02 00 00 00	 mov	 ecx, 2
  002de	e8 00 00 00 00	 call	 argexit
$LN18@main:

; 152  :     STRLCPY( ofname, argv[2] );

  002e3	b8 08 00 00 00	 mov	 eax, 8
  002e8	48 6b c0 02	 imul	 rax, rax, 2
  002ec	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  002f2	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002fa	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  002fe	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR ofname$[rsp]
  00306	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 153  : 
; 154  :     /* Read the first track of the input file, and determine
; 155  :        the device type and size from the track header */
; 156  :     ifd = open_input_image (ifname, &devtype, &volcyls,

  0030c	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR volser$[rsp]
  00314	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00319	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR itrkbuf$[rsp]
  00321	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00326	4c 8d 8c 24 a0
	00 00 00	 lea	 r9, QWORD PTR itrklen$[rsp]
  0032e	4c 8d 84 24 9c
	00 00 00	 lea	 r8, QWORD PTR volcyls$[rsp]
  00336	48 8d 54 24 7c	 lea	 rdx, QWORD PTR devtype$[rsp]
  0033b	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR ifname$[rsp]
  00343	e8 00 00 00 00	 call	 open_input_image
  00348	89 84 24 8c 00
	00 00		 mov	 DWORD PTR ifd$[rsp], eax

; 157  :                 &itrklen, &itrkbuf, volser);
; 158  : 
; 159  :     /* Use the device type to determine track characteristics */
; 160  :     switch (devtype) {

  0034f	0f b7 44 24 7c	 movzx	 eax, WORD PTR devtype$[rsp]
  00354	89 44 24 70	 mov	 DWORD PTR tv189[rsp], eax
  00358	81 7c 24 70 75
	33 00 00	 cmp	 DWORD PTR tv189[rsp], 13173 ; 00003375H
  00360	7f 3b		 jg	 SHORT $LN30@main
  00362	81 7c 24 70 75
	33 00 00	 cmp	 DWORD PTR tv189[rsp], 13173 ; 00003375H
  0036a	0f 84 b0 00 00
	00		 je	 $LN24@main
  00370	81 7c 24 70 14
	23 00 00	 cmp	 DWORD PTR tv189[rsp], 8980 ; 00002314H
  00378	74 52		 je	 SHORT $LN20@main
  0037a	81 7c 24 70 30
	33 00 00	 cmp	 DWORD PTR tv189[rsp], 13104 ; 00003330H
  00382	74 5d		 je	 SHORT $LN21@main
  00384	81 7c 24 70 40
	33 00 00	 cmp	 DWORD PTR tv189[rsp], 13120 ; 00003340H
  0038c	74 68		 je	 SHORT $LN22@main
  0038e	81 7c 24 70 50
	33 00 00	 cmp	 DWORD PTR tv189[rsp], 13136 ; 00003350H
  00396	74 73		 je	 SHORT $LN23@main
  00398	e9 d1 00 00 00	 jmp	 $LN28@main
$LN30@main:
  0039d	81 7c 24 70 80
	33 00 00	 cmp	 DWORD PTR tv189[rsp], 13184 ; 00003380H
  003a5	0f 84 8a 00 00
	00		 je	 $LN25@main
  003ab	81 7c 24 70 90
	33 00 00	 cmp	 DWORD PTR tv189[rsp], 13200 ; 00003390H
  003b3	0f 84 91 00 00
	00		 je	 $LN26@main
  003b9	81 7c 24 70 45
	93 00 00	 cmp	 DWORD PTR tv189[rsp], 37701 ; 00009345H
  003c1	0f 84 95 00 00
	00		 je	 $LN27@main
  003c7	e9 a2 00 00 00	 jmp	 $LN28@main
$LN20@main:

; 161  :     case 0x2314: heads = 20; maxdlen =  7294; break;

  003cc	c7 44 24 78 14
	00 00 00	 mov	 DWORD PTR heads$[rsp], 20
  003d4	c7 44 24 74 7e
	1c 00 00	 mov	 DWORD PTR maxdlen$[rsp], 7294 ; 00001c7eH
  003dc	e9 f5 00 00 00	 jmp	 $LN5@main
$LN21@main:

; 162  :     case 0x3330: heads = 19; maxdlen = 13030; break;

  003e1	c7 44 24 78 13
	00 00 00	 mov	 DWORD PTR heads$[rsp], 19
  003e9	c7 44 24 74 e6
	32 00 00	 mov	 DWORD PTR maxdlen$[rsp], 13030 ; 000032e6H
  003f1	e9 e0 00 00 00	 jmp	 $LN5@main
$LN22@main:

; 163  :     case 0x3340: heads = 12; maxdlen =  8368; break;

  003f6	c7 44 24 78 0c
	00 00 00	 mov	 DWORD PTR heads$[rsp], 12
  003fe	c7 44 24 74 b0
	20 00 00	 mov	 DWORD PTR maxdlen$[rsp], 8368 ; 000020b0H
  00406	e9 cb 00 00 00	 jmp	 $LN5@main
$LN23@main:

; 164  :     case 0x3350: heads = 30; maxdlen = 19069; break;

  0040b	c7 44 24 78 1e
	00 00 00	 mov	 DWORD PTR heads$[rsp], 30
  00413	c7 44 24 74 7d
	4a 00 00	 mov	 DWORD PTR maxdlen$[rsp], 19069 ; 00004a7dH
  0041b	e9 b6 00 00 00	 jmp	 $LN5@main
$LN24@main:

; 165  :     case 0x3375: heads = 12; maxdlen = 35616; break;

  00420	c7 44 24 78 0c
	00 00 00	 mov	 DWORD PTR heads$[rsp], 12
  00428	c7 44 24 74 20
	8b 00 00	 mov	 DWORD PTR maxdlen$[rsp], 35616 ; 00008b20H
  00430	e9 a1 00 00 00	 jmp	 $LN5@main
$LN25@main:

; 166  :     case 0x3380: heads = 15; maxdlen = 47476; break;

  00435	c7 44 24 78 0f
	00 00 00	 mov	 DWORD PTR heads$[rsp], 15
  0043d	c7 44 24 74 74
	b9 00 00	 mov	 DWORD PTR maxdlen$[rsp], 47476 ; 0000b974H
  00445	e9 8c 00 00 00	 jmp	 $LN5@main
$LN26@main:

; 167  :     case 0x3390: heads = 15; maxdlen = 56664; break;

  0044a	c7 44 24 78 0f
	00 00 00	 mov	 DWORD PTR heads$[rsp], 15
  00452	c7 44 24 74 58
	dd 00 00	 mov	 DWORD PTR maxdlen$[rsp], 56664 ; 0000dd58H
  0045a	eb 7a		 jmp	 SHORT $LN5@main
$LN27@main:

; 168  :     case 0x9345: heads = 15; maxdlen = 46456; break;

  0045c	c7 44 24 78 0f
	00 00 00	 mov	 DWORD PTR heads$[rsp], 15
  00464	c7 44 24 74 78
	b5 00 00	 mov	 DWORD PTR maxdlen$[rsp], 46456 ; 0000b578H
  0046c	eb 68		 jmp	 SHORT $LN5@main
$LN28@main:

; 169  :     default:
; 170  :         // "Unknown device type %04X"
; 171  :         FWRMSG( stderr, HHC02416, "E", devtype );

  0046e	0f b7 44 24 7c	 movzx	 eax, WORD PTR devtype$[rsp]
  00473	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv190[rsp], eax
  0047a	b9 02 00 00 00	 mov	 ecx, 2
  0047f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00485	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv190[rsp]
  0048c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00490	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168828
  00497	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0049c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168829
  004a3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004a8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004ad	41 b9 03 00 00
	00		 mov	 r9d, 3
  004b3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168830
  004ba	ba ab 00 00 00	 mov	 edx, 171		; 000000abH
  004bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168831
  004c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 172  :         EXIT(3);

  004cc	b9 03 00 00 00	 mov	 ecx, 3
  004d1	e8 00 00 00 00	 call	 delayed_exit
$LN5@main:

; 173  :     } /* end switch(devtype) */
; 174  : 
; 175  :     /* Create the device */
; 176  :     convert_ckd (lfs, ifd, ifname, itrklen, itrkbuf, repl, quiet,

  004d6	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR volser$[rsp]
  004de	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  004e3	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR volcyls$[rsp]
  004ea	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  004ee	8b 44 24 74	 mov	 eax, DWORD PTR maxdlen$[rsp]
  004f2	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  004f6	8b 44 24 78	 mov	 eax, DWORD PTR heads$[rsp]
  004fa	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  004fe	0f b7 44 24 7c	 movzx	 eax, WORD PTR devtype$[rsp]
  00503	66 89 44 24 40	 mov	 WORD PTR [rsp+64], ax
  00508	48 8d 84 24 c0
	01 00 00	 lea	 rax, QWORD PTR ofname$[rsp]
  00510	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00515	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR quiet$[rsp]
  0051c	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00520	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR repl$[rsp]
  00527	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0052b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR itrkbuf$[rsp]
  00533	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00538	44 8b 8c 24 a0
	00 00 00	 mov	 r9d, DWORD PTR itrklen$[rsp]
  00540	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR ifname$[rsp]
  00548	8b 94 24 8c 00
	00 00		 mov	 edx, DWORD PTR ifd$[rsp]
  0054f	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR lfs$[rsp]
  00556	e8 00 00 00 00	 call	 convert_ckd

; 177  :                 ofname, devtype, heads, maxdlen, volcyls, volser);
; 178  : 
; 179  :     /* Release the input buffer and close the input file */
; 180  :     free (itrkbuf);

  0055b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR itrkbuf$[rsp]
  00563	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 181  :     IFCLOS (ifd);

  00569	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR ifd$[rsp]
  00570	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 182  : 
; 183  :     /* Display completion message */
; 184  :     // "DASD operation completed"
; 185  :     WRMSG( HHC02423, "I" );

  00576	b9 01 00 00 00	 mov	 ecx, 1
  0057b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00581	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168832
  00588	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0058d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168833
  00594	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00599	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0059e	41 b9 03 00 00
	00		 mov	 r9d, 3
  005a4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168834
  005ab	ba b9 00 00 00	 mov	 edx, 185		; 000000b9H
  005b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168835
  005b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 186  : 
; 187  :     return 0;

  005bd	33 c0		 xor	 eax, eax

; 188  : 
; 189  : } /* end function main */

  005bf	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005c7	48 33 cc	 xor	 rcx, rsp
  005ca	e8 00 00 00 00	 call	 __security_check_cookie
  005cf	48 81 c4 d8 02
	00 00		 add	 rsp, 728		; 000002d8H
  005d6	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdconv.c
_TEXT	SEGMENT
trksize$ = 128
maxcyls$ = 132
maxcpif$ = 136
cyl$ = 140
i$ = 144
fileseq$ = 148
s$ = 152
tv75 = 160
mincyls$ = 164
endcyl$ = 168
suffix$ = 176
rec0len$ = 184
cylsize$ = 188
tv158 = 192
obuf$ = 200
tv135 = 208
buf$1 = 216
sfname$ = 256
__$ArrayPad$ = 528
lfs$ = 560
ifd$ = 568
ifname$ = 576
itrklen$ = 584
itrkbuf$ = 592
repl$ = 600
quiet$ = 608
ofname$ = 616
devtype$ = 624
heads$ = 632
maxdlen$ = 640
volcyls$ = 648
volser$ = 656
convert_ckd PROC

; 789  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 81 ec 28 02
	00 00		 sub	 rsp, 552		; 00000228H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 10
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 790  : int             i;                      /* Array subscript           */
; 791  : char            *s;                     /* String pointer            */
; 792  : int             fileseq;                /* File sequence number      */
; 793  : char            sfname[260];            /* Suffixed name of this file*/
; 794  : char            *suffix;                /* -> Suffix character       */
; 795  : U32             endcyl;                 /* Last cylinder of this file*/
; 796  : U32             cyl;                    /* Cylinder number           */
; 797  : U32             cylsize;                /* Cylinder size in bytes    */
; 798  : BYTE           *obuf;                   /* -> Output track buffer    */
; 799  : U32             mincyls;                /* Minimum cylinder count    */
; 800  : U32             maxcyls;                /* Maximum cylinder count    */
; 801  : U32             maxcpif;                /* Maximum number of cylinders
; 802  :                                            in each CKD image file    */
; 803  : int             rec0len = 8;            /* Length of R0 data         */

  0002b	c7 84 24 b8 00
	00 00 08 00 00
	00		 mov	 DWORD PTR rec0len$[rsp], 8

; 804  : U32             trksize;                /* AWSCKD image track length */
; 805  : 
; 806  :     /* Compute the AWSCKD image track length */
; 807  :     trksize = CKD_TRKHDR_SIZE

  00036	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR rec0len$[rsp]
  0003e	8b 8c 24 80 02
	00 00		 mov	 ecx, DWORD PTR maxdlen$[rsp]
  00045	48 8d 44 08 1d	 lea	 rax, QWORD PTR [rax+rcx+29]
  0004a	89 84 24 80 00
	00 00		 mov	 DWORD PTR trksize$[rsp], eax

; 808  :             + CKD_RECHDR_SIZE + rec0len
; 809  :             + CKD_RECHDR_SIZE + maxdlen
; 810  :             + CKD_ENDTRK_SIZE;
; 811  :     trksize = ROUND_UP(trksize,512);

  00051	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR trksize$[rsp], 0
  00059	74 24		 je	 SHORT $LN23@convert_ck
  0005b	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR trksize$[rsp]
  00062	05 ff 01 00 00	 add	 eax, 511		; 000001ffH
  00067	33 d2		 xor	 edx, edx
  00069	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0006e	f7 f1		 div	 ecx
  00070	69 c0 00 02 00
	00		 imul	 eax, eax, 512		; 00000200H
  00076	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv75[rsp], eax
  0007d	eb 0b		 jmp	 SHORT $LN24@convert_ck
$LN23@convert_ck:
  0007f	c7 84 24 a0 00
	00 00 00 02 00
	00		 mov	 DWORD PTR tv75[rsp], 512 ; 00000200H
$LN24@convert_ck:
  0008a	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv75[rsp]
  00091	89 84 24 80 00
	00 00		 mov	 DWORD PTR trksize$[rsp], eax

; 812  : 
; 813  :     /* Compute minimum and maximum number of cylinders */
; 814  :     cylsize = trksize * heads;

  00098	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR trksize$[rsp]
  0009f	0f af 84 24 78
	02 00 00	 imul	 eax, DWORD PTR heads$[rsp]
  000a7	89 84 24 bc 00
	00 00		 mov	 DWORD PTR cylsize$[rsp], eax

; 815  :     mincyls = 1;

  000ae	c7 84 24 a4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR mincyls$[rsp], 1

; 816  : 
; 817  :     if (!lfs)

  000b9	83 bc 24 30 02
	00 00 00	 cmp	 DWORD PTR lfs$[rsp], 0
  000c1	75 26		 jne	 SHORT $LN8@convert_ck

; 818  :     {
; 819  :         maxcpif = 0x80000000 / cylsize;

  000c3	33 d2		 xor	 edx, edx
  000c5	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  000ca	f7 b4 24 bc 00
	00 00		 div	 DWORD PTR cylsize$[rsp]
  000d1	89 84 24 88 00
	00 00		 mov	 DWORD PTR maxcpif$[rsp], eax

; 820  :         maxcyls = maxcpif * CKD_MAXFILES;

  000d8	6b 84 24 88 00
	00 00 1b	 imul	 eax, DWORD PTR maxcpif$[rsp], 27
  000e0	89 84 24 84 00
	00 00		 mov	 DWORD PTR maxcyls$[rsp], eax

; 821  :     }

  000e7	eb 1c		 jmp	 SHORT $LN9@convert_ck
$LN8@convert_ck:

; 822  :     else
; 823  :         maxcpif = maxcyls = volcyls;

  000e9	8b 84 24 88 02
	00 00		 mov	 eax, DWORD PTR volcyls$[rsp]
  000f0	89 84 24 84 00
	00 00		 mov	 DWORD PTR maxcyls$[rsp], eax
  000f7	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR maxcyls$[rsp]
  000fe	89 84 24 88 00
	00 00		 mov	 DWORD PTR maxcpif$[rsp], eax
$LN9@convert_ck:

; 824  : 
; 825  :     if (maxcyls > 65536) maxcyls = 65536;

  00105	81 bc 24 84 00
	00 00 00 00 01
	00		 cmp	 DWORD PTR maxcyls$[rsp], 65536 ; 00010000H
  00110	76 0b		 jbe	 SHORT $LN10@convert_ck
  00112	c7 84 24 84 00
	00 00 00 00 01
	00		 mov	 DWORD PTR maxcyls$[rsp], 65536 ; 00010000H
$LN10@convert_ck:

; 826  : 
; 827  :     /* Check for valid number of cylinders */
; 828  :     if (volcyls < mincyls || volcyls > maxcyls)

  0011d	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR mincyls$[rsp]
  00124	39 84 24 88 02
	00 00		 cmp	 DWORD PTR volcyls$[rsp], eax
  0012b	72 10		 jb	 SHORT $LN12@convert_ck
  0012d	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR maxcyls$[rsp]
  00134	39 84 24 88 02
	00 00		 cmp	 DWORD PTR volcyls$[rsp], eax
  0013b	76 72		 jbe	 SHORT $LN11@convert_ck
$LN12@convert_ck:

; 829  :     {
; 830  :         // "Cylinder count %u is outside range %u-%u"
; 831  :         FWRMSG( stderr, HHC02421, "E",

  0013d	b9 02 00 00 00	 mov	 ecx, 2
  00142	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00148	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR maxcyls$[rsp]
  0014f	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00153	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR mincyls$[rsp]
  0015a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0015e	8b 8c 24 88 02
	00 00		 mov	 ecx, DWORD PTR volcyls$[rsp]
  00165	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00169	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169275
  00170	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00175	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169276
  0017c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00181	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00186	41 b9 03 00 00
	00		 mov	 r9d, 3
  0018c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169277
  00193	ba 40 03 00 00	 mov	 edx, 832		; 00000340H
  00198	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169278
  0019f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 832  :                 volcyls, mincyls, maxcyls );
; 833  :         EXIT(4);

  001a5	b9 04 00 00 00	 mov	 ecx, 4
  001aa	e8 00 00 00 00	 call	 delayed_exit
$LN11@convert_ck:

; 834  :     }
; 835  : 
; 836  :     /* Obtain track data buffer */
; 837  :     obuf = malloc(trksize);

  001af	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR trksize$[rsp]
  001b6	8b c8		 mov	 ecx, eax
  001b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  001be	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR obuf$[rsp], rax

; 838  :     if (obuf == NULL)

  001c6	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR obuf$[rsp], 0
  001cf	0f 85 a3 00 00
	00		 jne	 $LN13@convert_ck

; 839  :     {
; 840  :         char buf[40];
; 841  :         MSGBUF( buf, "malloc(%u)", trksize);

  001d5	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR trksize$[rsp]
  001dd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169280
  001e4	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  001e9	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  001f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 842  :         // "Error in function %s: %s"
; 843  :         FWRMSG( stderr, HHC02412, "E", buf, strerror( errno ));

  001f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001fd	8b 08		 mov	 ecx, DWORD PTR [rax]
  001ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00205	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv135[rsp], rax
  0020d	b9 02 00 00 00	 mov	 ecx, 2
  00212	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00218	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv135[rsp]
  00220	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00225	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  0022d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00232	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169281
  00239	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0023e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169282
  00245	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0024a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0024f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00255	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169283
  0025c	ba 4b 03 00 00	 mov	 edx, 843		; 0000034bH
  00261	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169284
  00268	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 844  :         EXIT(6);

  0026e	b9 06 00 00 00	 mov	 ecx, 6
  00273	e8 00 00 00 00	 call	 delayed_exit
$LN13@convert_ck:

; 845  :     }
; 846  : 
; 847  :     /* Display progress message */
; 848  :     // "Converting %04X volume %s: %u cyls, %u trks/cyl, %u bytes/trk"
; 849  :     WRMSG( HHC02422, "I", devtype, volser, volcyls, heads, trksize );

  00278	0f b7 84 24 70
	02 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  00280	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv158[rsp], eax
  00287	b9 01 00 00 00	 mov	 ecx, 1
  0028c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00292	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR trksize$[rsp]
  00299	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0029d	8b 8c 24 78 02
	00 00		 mov	 ecx, DWORD PTR heads$[rsp]
  002a4	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  002a8	8b 8c 24 88 02
	00 00		 mov	 ecx, DWORD PTR volcyls$[rsp]
  002af	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  002b3	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR volser$[rsp]
  002bb	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002c0	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv158[rsp]
  002c7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169285
  002d2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169286
  002de	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002e3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002e8	41 b9 03 00 00
	00		 mov	 r9d, 3
  002ee	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169287
  002f5	ba 51 03 00 00	 mov	 edx, 849		; 00000351H
  002fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169288
  00301	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@convert_ck:

; 850  : 
; 851  :     EXTGUIMSG( "CYLS=%u\n", volcyls );

  00307	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  0030e	83 38 00	 cmp	 DWORD PTR [rax], 0
  00311	74 23		 je	 SHORT $LN14@convert_ck
  00313	b9 02 00 00 00	 mov	 ecx, 2
  00318	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0031e	44 8b 84 24 88
	02 00 00	 mov	 r8d, DWORD PTR volcyls$[rsp]
  00326	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169290
  0032d	48 8b c8	 mov	 rcx, rax
  00330	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN14@convert_ck:
  00336	33 c0		 xor	 eax, eax
  00338	85 c0		 test	 eax, eax
  0033a	75 cb		 jne	 SHORT $LN4@convert_ck

; 852  : 
; 853  :     /* Copy the unsuffixed AWSCKD image file name */
; 854  :     STRLCPY( sfname, ofname );

  0033c	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00342	48 8b 94 24 68
	02 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  0034a	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR sfname$[rsp]
  00352	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 855  :     suffix = NULL;

  00358	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR suffix$[rsp], 0

; 856  : 
; 857  :     /* Create the suffixed file name if volume will exceed 2GB */
; 858  :     if (volcyls > maxcpif)

  00364	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR maxcpif$[rsp]
  0036b	39 84 24 88 02
	00 00		 cmp	 DWORD PTR volcyls$[rsp], eax
  00372	0f 86 2d 01 00
	00		 jbe	 $LN15@convert_ck

; 859  :     {
; 860  :         /* Look for last slash marking end of directory name */
; 861  :         s = strrchr (ofname, '/');

  00378	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  0037d	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR ofname$[rsp]
  00385	e8 00 00 00 00	 call	 strrchr
  0038a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 862  :         if (s == NULL) s = ofname;

  00392	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR s$[rsp], 0
  0039b	75 10		 jne	 SHORT $LN16@convert_ck
  0039d	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR ofname$[rsp]
  003a5	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR s$[rsp], rax
$LN16@convert_ck:

; 863  : 
; 864  :         /* Insert suffix before first dot in file name, or
; 865  :            append suffix to file name if there is no dot */
; 866  :         s = strchr (s, '.');

  003ad	ba 2e 00 00 00	 mov	 edx, 46			; 0000002eH
  003b2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003ba	e8 00 00 00 00	 call	 strchr
  003bf	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 867  :         if (s != NULL)

  003c7	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR s$[rsp], 0
  003d0	0f 84 97 00 00
	00		 je	 $LN17@convert_ck

; 868  :         {
; 869  :             i = (int) (s - ofname);

  003d6	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR ofname$[rsp]
  003de	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003e6	48 2b c8	 sub	 rcx, rax
  003e9	48 8b c1	 mov	 rax, rcx
  003ec	89 84 24 90 00
	00 00		 mov	 DWORD PTR i$[rsp], eax

; 870  :             strlcpy( sfname + i, "_1", sizeof( sfname ) - i );

  003f3	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  003fb	b9 04 01 00 00	 mov	 ecx, 260		; 00000104H
  00400	48 2b c8	 sub	 rcx, rax
  00403	48 8b c1	 mov	 rax, rcx
  00406	48 63 8c 24 90
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  0040e	48 8d 8c 0c 00
	01 00 00	 lea	 rcx, QWORD PTR sfname$[rsp+rcx]
  00416	4c 8b c0	 mov	 r8, rax
  00419	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169295
  00420	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 871  :             STRLCAT( sfname, ofname + i );

  00426	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0042e	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR ofname$[rsp]
  00436	48 03 c8	 add	 rcx, rax
  00439	48 8b c1	 mov	 rax, rcx
  0043c	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00442	48 8b d0	 mov	 rdx, rax
  00445	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR sfname$[rsp]
  0044d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 872  :             suffix = sfname + i + 1;

  00453	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0045b	48 8d 84 04 01
	01 00 00	 lea	 rax, QWORD PTR sfname$[rsp+rax+1]
  00463	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR suffix$[rsp], rax

; 873  :         }

  0046b	eb 38		 jmp	 SHORT $LN18@convert_ck
$LN17@convert_ck:

; 874  :         else
; 875  :         {
; 876  :             STRLCAT( sfname, "_1" );

  0046d	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00473	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169296
  0047a	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR sfname$[rsp]
  00482	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 877  :             suffix = sfname + strlen(sfname) - 1;

  00488	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR sfname$[rsp]
  00490	e8 00 00 00 00	 call	 strlen
  00495	48 8d 84 04 ff
	00 00 00	 lea	 rax, QWORD PTR sfname$[rsp+rax-1]
  0049d	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR suffix$[rsp], rax
$LN18@convert_ck:
$LN15@convert_ck:

; 878  :         }
; 879  :     }
; 880  : 
; 881  :     /* Create the AWSCKD image files */
; 882  :     for (cyl = 0, fileseq = 1; cyl < volcyls;

  004a5	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR cyl$[rsp], 0
  004b0	c7 84 24 94 00
	00 00 01 00 00
	00		 mov	 DWORD PTR fileseq$[rsp], 1
  004bb	eb 29		 jmp	 SHORT $LN7@convert_ck
$LN5@convert_ck:

; 883  :             cyl += maxcpif, fileseq++)

  004bd	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR maxcpif$[rsp]
  004c4	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR cyl$[rsp]
  004cb	03 c8		 add	 ecx, eax
  004cd	8b c1		 mov	 eax, ecx
  004cf	89 84 24 8c 00
	00 00		 mov	 DWORD PTR cyl$[rsp], eax
  004d6	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR fileseq$[rsp]
  004dd	ff c0		 inc	 eax
  004df	89 84 24 94 00
	00 00		 mov	 DWORD PTR fileseq$[rsp], eax
$LN7@convert_ck:

; 878  :         }
; 879  :     }
; 880  : 
; 881  :     /* Create the AWSCKD image files */
; 882  :     for (cyl = 0, fileseq = 1; cyl < volcyls;

  004e6	8b 84 24 88 02
	00 00		 mov	 eax, DWORD PTR volcyls$[rsp]
  004ed	39 84 24 8c 00
	00 00		 cmp	 DWORD PTR cyl$[rsp], eax
  004f4	0f 83 1a 01 00
	00		 jae	 $LN6@convert_ck

; 884  :     {
; 885  :         /* Insert the file sequence number in the file name */
; 886  :         if (suffix) *suffix = '0' + fileseq;

  004fa	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR suffix$[rsp], 0
  00503	74 14		 je	 SHORT $LN19@convert_ck
  00505	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR fileseq$[rsp]
  0050c	83 c0 30	 add	 eax, 48			; 00000030H
  0050f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR suffix$[rsp]
  00517	88 01		 mov	 BYTE PTR [rcx], al
$LN19@convert_ck:

; 887  : 
; 888  :         /* Calculate the ending cylinder for this file */
; 889  :         if (cyl + maxcpif < volcyls)

  00519	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR maxcpif$[rsp]
  00520	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR cyl$[rsp]
  00527	03 c8		 add	 ecx, eax
  00529	8b c1		 mov	 eax, ecx
  0052b	3b 84 24 88 02
	00 00		 cmp	 eax, DWORD PTR volcyls$[rsp]
  00532	73 1b		 jae	 SHORT $LN20@convert_ck

; 890  :             endcyl = cyl + maxcpif - 1;

  00534	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR cyl$[rsp]
  0053b	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR maxcpif$[rsp]
  00542	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00546	89 84 24 a8 00
	00 00		 mov	 DWORD PTR endcyl$[rsp], eax
  0054d	eb 10		 jmp	 SHORT $LN21@convert_ck
$LN20@convert_ck:

; 891  :         else
; 892  :             endcyl = volcyls - 1;

  0054f	8b 84 24 88 02
	00 00		 mov	 eax, DWORD PTR volcyls$[rsp]
  00556	ff c8		 dec	 eax
  00558	89 84 24 a8 00
	00 00		 mov	 DWORD PTR endcyl$[rsp], eax
$LN21@convert_ck:

; 893  : 
; 894  :         /* Create an AWSCKD image file */
; 895  :         convert_ckd_file (ifd, ifname, itrklen, itrkbuf, repl, quiet,

  0055f	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR volser$[rsp]
  00567	48 89 44 24 78	 mov	 QWORD PTR [rsp+120], rax
  0056c	8b 84 24 88 02
	00 00		 mov	 eax, DWORD PTR volcyls$[rsp]
  00573	89 44 24 70	 mov	 DWORD PTR [rsp+112], eax
  00577	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR endcyl$[rsp]
  0057e	89 44 24 68	 mov	 DWORD PTR [rsp+104], eax
  00582	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR cyl$[rsp]
  00589	89 44 24 60	 mov	 DWORD PTR [rsp+96], eax
  0058d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR obuf$[rsp]
  00595	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  0059a	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR trksize$[rsp]
  005a1	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  005a5	8b 84 24 78 02
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  005ac	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  005b0	0f b7 84 24 70
	02 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  005b8	66 89 44 24 40	 mov	 WORD PTR [rsp+64], ax
  005bd	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR fileseq$[rsp]
  005c4	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  005c8	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR sfname$[rsp]
  005d0	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  005d5	8b 84 24 60 02
	00 00		 mov	 eax, DWORD PTR quiet$[rsp]
  005dc	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  005e0	8b 84 24 58 02
	00 00		 mov	 eax, DWORD PTR repl$[rsp]
  005e7	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  005eb	4c 8b 8c 24 50
	02 00 00	 mov	 r9, QWORD PTR itrkbuf$[rsp]
  005f3	44 8b 84 24 48
	02 00 00	 mov	 r8d, DWORD PTR itrklen$[rsp]
  005fb	48 8b 94 24 40
	02 00 00	 mov	 rdx, QWORD PTR ifname$[rsp]
  00603	8b 8c 24 38 02
	00 00		 mov	 ecx, DWORD PTR ifd$[rsp]
  0060a	e8 00 00 00 00	 call	 convert_ckd_file

; 896  :                         sfname, fileseq, devtype, heads, trksize,
; 897  :                         obuf, cyl, endcyl, volcyls, volser);
; 898  :     }

  0060f	e9 a9 fe ff ff	 jmp	 $LN5@convert_ck
$LN6@convert_ck:

; 899  : 
; 900  :     /* Release the output track buffer */
; 901  :     free (obuf);

  00614	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR obuf$[rsp]
  0061c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 902  : 
; 903  : } /* end function convert_ckd */

  00622	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0062a	48 33 cc	 xor	 rcx, rsp
  0062d	e8 00 00 00 00	 call	 __security_check_cookie
  00632	48 81 c4 28 02
	00 00		 add	 rsp, 552		; 00000228H
  00639	c3		 ret	 0
convert_ckd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdconv.c
_TEXT	SEGMENT
klen$ = 112
cyl$ = 116
rc$ = 120
dlen$ = 124
head$ = 128
rec$ = 132
opos$ = 136
ihc$ = 144
ihh$ = 148
ofd$ = 152
offset$ = 156
tv76 = 160
fileseq$ = 164
highcyl$ = 168
rechdr$ = 176
ilen$ = 184
tv462 = 188
trkhdr$ = 192
tv175 = 200
ith$ = 208
iptr$ = 216
tv398 = 224
tv81 = 232
tv263 = 240
tv290 = 248
tv324 = 256
tv328 = 264
kptr$ = 272
dptr$ = 280
tv414 = 288
devhdr$ = 304
pathname$ = 816
__$ArrayPad$ = 1088
ifd$ = 1136
ifname$ = 1144
itrklen$ = 1152
itrkbuf$ = 1160
repl$ = 1168
quiet$ = 1176
ofname$ = 1184
fseqn$ = 1192
devtype$ = 1200
heads$ = 1208
trksize$ = 1216
obuf$ = 1224
start$ = 1232
end$ = 1240
volcyls$ = 1248
volser$ = 1256
convert_ckd_file PROC

; 568  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec 58 04
	00 00		 sub	 rsp, 1112		; 00000458H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 40
	04 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@convert_ck:

; 569  : int             rc;                     /* Return code               */
; 570  : int             ofd;                    /* Output file descriptor    */
; 571  : CKD_DEVHDR      devhdr;                 /* Output device header      */
; 572  : CKD_TRKHDR     *trkhdr;                 /* -> Output track header    */
; 573  : CKD_RECHDR     *rechdr;                 /* -> Output record header   */
; 574  : U32             cyl;                    /* Cylinder number           */
; 575  : U32             head;                   /* Head number               */
; 576  : int             fileseq;                /* CKD header sequence number*/
; 577  : int             highcyl;                /* CKD header high cyl number*/
; 578  : BYTE           *opos;                   /* -> Byte in output buffer  */
; 579  : BYTE            klen;                   /* Key length                */
; 580  : U16             dlen;                   /* Data length               */
; 581  : BYTE            rec;                    /* Record number             */
; 582  : BYTE           *iptr;                   /* -> Byte in input buffer   */
; 583  : BYTE           *kptr;                   /* -> Key in input buffer    */
; 584  : BYTE           *dptr;                   /* -> Data in input buffer   */
; 585  : int             ilen;                   /* Bytes left in input buffer*/
; 586  : H30CKD_TRKHDR  *ith;                    /* -> Input track header     */
; 587  : U32             ihc, ihh;               /* Input trk header cyl,head */
; 588  : U32             offset;                 /* Current input file offset */
; 589  : char            pathname[MAX_PATH];     /* file path in host format  */
; 590  : 
; 591  :     UNREFERENCED(volser);

  0002e	33 c0		 xor	 eax, eax
  00030	85 c0		 test	 eax, eax
  00032	75 fa		 jne	 SHORT $LN4@convert_ck

; 592  : 
; 593  :     /* Set file sequence number to zero if this is the only file */
; 594  :     if (fseqn == 1 && end + 1 == volcyls)

  00034	83 bc 24 a8 04
	00 00 01	 cmp	 DWORD PTR fseqn$[rsp], 1
  0003c	75 1f		 jne	 SHORT $LN16@convert_ck
  0003e	8b 84 24 d8 04
	00 00		 mov	 eax, DWORD PTR end$[rsp]
  00045	ff c0		 inc	 eax
  00047	3b 84 24 e0 04
	00 00		 cmp	 eax, DWORD PTR volcyls$[rsp]
  0004e	75 0d		 jne	 SHORT $LN16@convert_ck

; 595  :         fileseq = 0;

  00050	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR fileseq$[rsp], 0
  0005b	eb 0e		 jmp	 SHORT $LN17@convert_ck
$LN16@convert_ck:

; 596  :     else
; 597  :         fileseq = fseqn;

  0005d	8b 84 24 a8 04
	00 00		 mov	 eax, DWORD PTR fseqn$[rsp]
  00064	89 84 24 a4 00
	00 00		 mov	 DWORD PTR fileseq$[rsp], eax
$LN17@convert_ck:

; 598  : 
; 599  :     /* Set high cylinder number to zero if this is the last file */
; 600  :     if (end + 1 == volcyls)

  0006b	8b 84 24 d8 04
	00 00		 mov	 eax, DWORD PTR end$[rsp]
  00072	ff c0		 inc	 eax
  00074	3b 84 24 e0 04
	00 00		 cmp	 eax, DWORD PTR volcyls$[rsp]
  0007b	75 0d		 jne	 SHORT $LN18@convert_ck

; 601  :         highcyl = 0;

  0007d	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR highcyl$[rsp], 0
  00088	eb 0e		 jmp	 SHORT $LN19@convert_ck
$LN18@convert_ck:

; 602  :     else
; 603  :         highcyl = end;

  0008a	8b 84 24 d8 04
	00 00		 mov	 eax, DWORD PTR end$[rsp]
  00091	89 84 24 a8 00
	00 00		 mov	 DWORD PTR highcyl$[rsp], eax
$LN19@convert_ck:

; 604  : 
; 605  :     /* Create the AWSCKD image file */
; 606  :     hostpath(pathname, (char *)ofname, sizeof(pathname));

  00098	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0009e	48 8b 94 24 a0
	04 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  000a6	48 8d 8c 24 30
	03 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 607  :     ofd = HOPEN (pathname,

  000b4	83 bc 24 90 04
	00 00 00	 cmp	 DWORD PTR repl$[rsp], 0
  000bc	74 0d		 je	 SHORT $LN37@convert_ck
  000be	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv76[rsp], 0
  000c9	eb 0b		 jmp	 SHORT $LN38@convert_ck
$LN37@convert_ck:
  000cb	c7 84 24 a0 00
	00 00 00 04 00
	00		 mov	 DWORD PTR tv76[rsp], 1024 ; 00000400H
$LN38@convert_ck:
  000d6	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv76[rsp]
  000dd	0d 01 81 00 00	 or	 eax, 33025		; 00008101H
  000e2	41 b8 80 01 00
	00		 mov	 r8d, 384		; 00000180H
  000e8	8b d0		 mov	 edx, eax
  000ea	48 8d 8c 24 30
	03 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  000f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  000f8	89 84 24 98 00
	00 00		 mov	 DWORD PTR ofd$[rsp], eax

; 608  :                 O_WRONLY | O_CREAT | O_BINARY | (repl ? 0 : O_EXCL),
; 609  :                 S_IRUSR | S_IWUSR | S_IRGRP);
; 610  : 
; 611  :     if (ofd < 0)

  000ff	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR ofd$[rsp], 0
  00107	0f 8d 80 00 00
	00		 jge	 $LN20@convert_ck

; 612  :     {
; 613  :         // "Error in function %s: %s"
; 614  :         FWRMSG( stderr, HHC02412, "E", "open()", strerror( errno ));

  0010d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00113	8b 08		 mov	 ecx, DWORD PTR [rax]
  00115	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0011b	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv81[rsp], rax
  00123	b9 02 00 00 00	 mov	 ecx, 2
  00128	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0012e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv81[rsp]
  00136	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0013b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169154
  00142	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00147	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169155
  0014e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00153	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169156
  0015a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0015f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00164	41 b9 03 00 00
	00		 mov	 r9d, 3
  0016a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169157
  00171	ba 66 02 00 00	 mov	 edx, 614		; 00000266H
  00176	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169158
  0017d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 615  :         EXIT(8);

  00183	b9 08 00 00 00	 mov	 ecx, 8
  00188	e8 00 00 00 00	 call	 delayed_exit
$LN20@convert_ck:

; 616  :     }
; 617  : 
; 618  :     /* Create the device header */
; 619  :     memset( &devhdr, 0, CKD_DEVHDR_SIZE );

  0018d	48 8d 84 24 30
	01 00 00	 lea	 rax, QWORD PTR devhdr$[rsp]
  00195	48 8b f8	 mov	 rdi, rax
  00198	33 c0		 xor	 eax, eax
  0019a	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0019f	f3 aa		 rep stosb

; 620  :     memcpy( devhdr.dh_devid, dh_devid_str( CKD_P370_TYP ), 8 );

  001a1	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  001a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dh_devid_str
  001ac	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001af	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR devhdr$[rsp], rax

; 621  : 
; 622  :     STORE_LE_FW( devhdr.dh_heads,    heads   );

  001b7	8b 8c 24 b8 04
	00 00		 mov	 ecx, DWORD PTR heads$[rsp]
  001be	e8 00 00 00 00	 call	 _byteswap_ulong
  001c3	8b c8		 mov	 ecx, eax
  001c5	e8 00 00 00 00	 call	 _byteswap_ulong
  001ca	8b d0		 mov	 edx, eax
  001cc	48 8d 8c 24 38
	01 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+8]
  001d4	e8 00 00 00 00	 call	 store_fw_noswap

; 623  :     STORE_LE_FW( devhdr.dh_trksize,  trksize );

  001d9	8b 8c 24 c0 04
	00 00		 mov	 ecx, DWORD PTR trksize$[rsp]
  001e0	e8 00 00 00 00	 call	 _byteswap_ulong
  001e5	8b c8		 mov	 ecx, eax
  001e7	e8 00 00 00 00	 call	 _byteswap_ulong
  001ec	8b d0		 mov	 edx, eax
  001ee	48 8d 8c 24 3c
	01 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+12]
  001f6	e8 00 00 00 00	 call	 store_fw_noswap

; 624  :                  devhdr.dh_devtyp   = devtype & 0xFF;

  001fb	0f b7 84 24 b0
	04 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  00203	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00208	88 84 24 40 01
	00 00		 mov	 BYTE PTR devhdr$[rsp+16], al

; 625  :                  devhdr.dh_fileseq = fileseq & 0xFF;

  0020f	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR fileseq$[rsp]
  00216	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0021b	88 84 24 41 01
	00 00		 mov	 BYTE PTR devhdr$[rsp+17], al

; 626  :     STORE_LE_HW( devhdr.dh_highcyl,  (U16) highcyl );

  00222	0f b7 8c 24 a8
	00 00 00	 movzx	 ecx, WORD PTR highcyl$[rsp]
  0022a	e8 00 00 00 00	 call	 _byteswap_ushort
  0022f	0f b7 c8	 movzx	 ecx, ax
  00232	e8 00 00 00 00	 call	 _byteswap_ushort
  00237	0f b7 d0	 movzx	 edx, ax
  0023a	48 8d 8c 24 42
	01 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+18]
  00242	e8 00 00 00 00	 call	 store_hw_noswap

; 627  : 
; 628  :     /* Write the device header */
; 629  :     rc = write (ofd, &devhdr, CKD_DEVHDR_SIZE);

  00247	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  0024d	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR devhdr$[rsp]
  00255	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR ofd$[rsp]
  0025c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  00262	89 44 24 78	 mov	 DWORD PTR rc$[rsp], eax

; 630  :     if (rc < CKD_DEVHDR_SIZE)

  00266	48 63 44 24 78	 movsxd	 rax, DWORD PTR rc$[rsp]
  0026b	48 3d 00 02 00
	00		 cmp	 rax, 512		; 00000200H
  00271	0f 8d 9c 00 00
	00		 jge	 $LN21@convert_ck

; 631  :     {
; 632  :         // "Error in function %s: %s"
; 633  :         FWRMSG( stderr, HHC02412, "E", "write()", errno ? strerror(errno) : "incomplete" );

  00277	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0027d	83 38 00	 cmp	 DWORD PTR [rax], 0
  00280	74 18		 je	 SHORT $LN39@convert_ck
  00282	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00288	8b 08		 mov	 ecx, DWORD PTR [rax]
  0028a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00290	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv175[rsp], rax
  00298	eb 0f		 jmp	 SHORT $LN40@convert_ck
$LN39@convert_ck:
  0029a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169160
  002a1	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv175[rsp], rax
$LN40@convert_ck:
  002a9	b9 02 00 00 00	 mov	 ecx, 2
  002ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002b4	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv175[rsp]
  002bc	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169161
  002c8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169162
  002d4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169163
  002e0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002e5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002ea	41 b9 03 00 00
	00		 mov	 r9d, 3
  002f0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169164
  002f7	ba 79 02 00 00	 mov	 edx, 633		; 00000279H
  002fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169165
  00303	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 634  :         EXIT(1);

  00309	b9 01 00 00 00	 mov	 ecx, 1
  0030e	e8 00 00 00 00	 call	 delayed_exit
$LN21@convert_ck:

; 635  :     }
; 636  : 
; 637  :     /* Write each cylinder */
; 638  :     for (cyl = start; cyl <= end; cyl++)

  00313	8b 84 24 d0 04
	00 00		 mov	 eax, DWORD PTR start$[rsp]
  0031a	89 44 24 74	 mov	 DWORD PTR cyl$[rsp], eax
  0031e	eb 0a		 jmp	 SHORT $LN7@convert_ck
$LN5@convert_ck:
  00320	8b 44 24 74	 mov	 eax, DWORD PTR cyl$[rsp]
  00324	ff c0		 inc	 eax
  00326	89 44 24 74	 mov	 DWORD PTR cyl$[rsp], eax
$LN7@convert_ck:
  0032a	8b 84 24 d8 04
	00 00		 mov	 eax, DWORD PTR end$[rsp]
  00331	39 44 24 74	 cmp	 DWORD PTR cyl$[rsp], eax
  00335	0f 87 78 06 00
	00		 ja	 $LN6@convert_ck

; 639  :     {
; 640  :         /* Display progress message every 10 cylinders */
; 641  :         if ((cyl % 10) == 0)

  0033b	33 d2		 xor	 edx, edx
  0033d	8b 44 24 74	 mov	 eax, DWORD PTR cyl$[rsp]
  00341	b9 0a 00 00 00	 mov	 ecx, 10
  00346	f7 f1		 div	 ecx
  00348	8b c2		 mov	 eax, edx
  0034a	85 c0		 test	 eax, eax
  0034c	75 5c		 jne	 SHORT $LN22@convert_ck
$LN10@convert_ck:

; 642  :         {
; 643  :             EXTGUIMSG( "CYL=%u\n", cyl );

  0034e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  00355	83 38 00	 cmp	 DWORD PTR [rax], 0
  00358	74 20		 je	 SHORT $LN23@convert_ck
  0035a	b9 02 00 00 00	 mov	 ecx, 2
  0035f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00365	44 8b 44 24 74	 mov	 r8d, DWORD PTR cyl$[rsp]
  0036a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169168
  00371	48 8b c8	 mov	 rcx, rax
  00374	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN23@convert_ck:
  0037a	33 c0		 xor	 eax, eax
  0037c	85 c0		 test	 eax, eax
  0037e	75 ce		 jne	 SHORT $LN10@convert_ck

; 644  :             if (!quiet)

  00380	83 bc 24 98 04
	00 00 00	 cmp	 DWORD PTR quiet$[rsp], 0
  00388	75 20		 jne	 SHORT $LN24@convert_ck

; 645  :                 fprintf (stderr, "Writing cylinder %u\r", cyl);

  0038a	b9 02 00 00 00	 mov	 ecx, 2
  0038f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00395	44 8b 44 24 74	 mov	 r8d, DWORD PTR cyl$[rsp]
  0039a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169170
  003a1	48 8b c8	 mov	 rcx, rax
  003a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN24@convert_ck:
$LN22@convert_ck:

; 646  :         }
; 647  : 
; 648  :         for (head = 0; head < heads; head++)

  003aa	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR head$[rsp], 0
  003b5	eb 10		 jmp	 SHORT $LN13@convert_ck
$LN11@convert_ck:
  003b7	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR head$[rsp]
  003be	ff c0		 inc	 eax
  003c0	89 84 24 80 00
	00 00		 mov	 DWORD PTR head$[rsp], eax
$LN13@convert_ck:
  003c7	8b 84 24 b8 04
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  003ce	39 84 24 80 00
	00 00		 cmp	 DWORD PTR head$[rsp], eax
  003d5	0f 83 d3 05 00
	00		 jae	 $LN12@convert_ck

; 649  :         {
; 650  :             /* Calculate the current offset in the file */
; 651  :             offset = ((cyl*heads)+head)*itrklen;

  003db	8b 44 24 74	 mov	 eax, DWORD PTR cyl$[rsp]
  003df	0f af 84 24 b8
	04 00 00	 imul	 eax, DWORD PTR heads$[rsp]
  003e7	03 84 24 80 00
	00 00		 add	 eax, DWORD PTR head$[rsp]
  003ee	0f af 84 24 80
	04 00 00	 imul	 eax, DWORD PTR itrklen$[rsp]
  003f6	89 84 24 9c 00
	00 00		 mov	 DWORD PTR offset$[rsp], eax

; 652  : 
; 653  :             /* Read the input track image (except cyl 0 head 0
; 654  :                already read by the open_input_image procedure) */
; 655  :             if (cyl > 0 || head > 0)

  003fd	83 7c 24 74 00	 cmp	 DWORD PTR cyl$[rsp], 0
  00402	77 0a		 ja	 SHORT $LN26@convert_ck
  00404	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR head$[rsp], 0
  0040c	76 2f		 jbe	 SHORT $LN25@convert_ck
$LN26@convert_ck:

; 656  :             {
; 657  :                 read_input_data (ifd, ifname,

  0040e	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR offset$[rsp]
  00415	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00419	44 8b 8c 24 80
	04 00 00	 mov	 r9d, DWORD PTR itrklen$[rsp]
  00421	4c 8b 84 24 88
	04 00 00	 mov	 r8, QWORD PTR itrkbuf$[rsp]
  00429	48 8b 94 24 78
	04 00 00	 mov	 rdx, QWORD PTR ifname$[rsp]
  00431	8b 8c 24 70 04
	00 00		 mov	 ecx, DWORD PTR ifd$[rsp]
  00438	e8 00 00 00 00	 call	 read_input_data
$LN25@convert_ck:

; 658  :                                  itrkbuf, itrklen,
; 659  :                                  offset);
; 660  :             } /* end if(cyl>0||head>0) */
; 661  : 
; 662  :             /* Validate the track header */
; 663  :             ith = (H30CKD_TRKHDR*)itrkbuf;

  0043d	48 8b 84 24 88
	04 00 00	 mov	 rax, QWORD PTR itrkbuf$[rsp]
  00445	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR ith$[rsp], rax

; 664  :             FETCH_HW (ihc, ith->cyl);

  0044d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR ith$[rsp]
  00455	48 83 c0 10	 add	 rax, 16
  00459	48 8b c8	 mov	 rcx, rax
  0045c	e8 00 00 00 00	 call	 fetch_hw_noswap
  00461	0f b7 c8	 movzx	 ecx, ax
  00464	e8 00 00 00 00	 call	 _byteswap_ushort
  00469	0f b7 c0	 movzx	 eax, ax
  0046c	89 84 24 90 00
	00 00		 mov	 DWORD PTR ihc$[rsp], eax

; 665  :             FETCH_HW (ihh, ith->head);

  00473	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR ith$[rsp]
  0047b	48 83 c0 12	 add	 rax, 18
  0047f	48 8b c8	 mov	 rcx, rax
  00482	e8 00 00 00 00	 call	 fetch_hw_noswap
  00487	0f b7 c8	 movzx	 ecx, ax
  0048a	e8 00 00 00 00	 call	 _byteswap_ushort
  0048f	0f b7 c0	 movzx	 eax, ax
  00492	89 84 24 94 00
	00 00		 mov	 DWORD PTR ihh$[rsp], eax

; 666  :             if (ihc != cyl || ihh != head)

  00499	8b 44 24 74	 mov	 eax, DWORD PTR cyl$[rsp]
  0049d	39 84 24 90 00
	00 00		 cmp	 DWORD PTR ihc$[rsp], eax
  004a4	75 14		 jne	 SHORT $LN28@convert_ck
  004a6	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR head$[rsp]
  004ad	39 84 24 94 00
	00 00		 cmp	 DWORD PTR ihh$[rsp], eax
  004b4	0f 84 dd 00 00
	00		 je	 $LN27@convert_ck
$LN28@convert_ck:

; 667  :             {
; 668  :                 // "Invalid track header at offset 0x%16.16"PRIX64
; 669  :                 FWRMSG( stderr, HHC02417, "E", (U64)offset );

  004ba	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR offset$[rsp]
  004c1	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv263[rsp], rax
  004c9	b9 02 00 00 00	 mov	 ecx, 2
  004ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004d4	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv263[rsp]
  004dc	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169175
  004e8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169176
  004f4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004f9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004fe	41 b9 03 00 00
	00		 mov	 r9d, 3
  00504	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169177
  0050b	ba 9d 02 00 00	 mov	 edx, 669		; 0000029dH
  00510	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169178
  00517	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 670  :                 // "Expected CCHH %04X%04X, found CCHH %04X%04X"
; 671  :                 FWRMSG( stderr, HHC02418, "E", cyl, head, ihc, ihh );

  0051d	b9 02 00 00 00	 mov	 ecx, 2
  00522	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00528	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR ihh$[rsp]
  0052f	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00533	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR ihc$[rsp]
  0053a	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0053e	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR head$[rsp]
  00545	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00549	8b 4c 24 74	 mov	 ecx, DWORD PTR cyl$[rsp]
  0054d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00551	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169179
  00558	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0055d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169180
  00564	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00569	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0056e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00574	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169181
  0057b	ba 9f 02 00 00	 mov	 edx, 671		; 0000029fH
  00580	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169182
  00587	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 672  :                 EXIT(8);

  0058d	b9 08 00 00 00	 mov	 ecx, 8
  00592	e8 00 00 00 00	 call	 delayed_exit
$LN27@convert_ck:

; 673  :             }
; 674  : 
; 675  :             /* Clear the output track image to zeroes */
; 676  :             memset (obuf, 0, trksize);

  00597	8b 84 24 c0 04
	00 00		 mov	 eax, DWORD PTR trksize$[rsp]
  0059e	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv290[rsp], rax
  005a6	48 8b bc 24 c8
	04 00 00	 mov	 rdi, QWORD PTR obuf$[rsp]
  005ae	33 c0		 xor	 eax, eax
  005b0	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv290[rsp]
  005b8	f3 aa		 rep stosb

; 677  : 
; 678  :             /* Build the output track header */
; 679  :             trkhdr = (CKD_TRKHDR*)obuf;

  005ba	48 8b 84 24 c8
	04 00 00	 mov	 rax, QWORD PTR obuf$[rsp]
  005c2	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR trkhdr$[rsp], rax

; 680  :             trkhdr->bin = 0;

  005ca	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR trkhdr$[rsp]
  005d2	c6 00 00	 mov	 BYTE PTR [rax], 0

; 681  :             STORE_HW (trkhdr->cyl, cyl);

  005d5	0f b7 4c 24 74	 movzx	 ecx, WORD PTR cyl$[rsp]
  005da	e8 00 00 00 00	 call	 _byteswap_ushort
  005df	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR trkhdr$[rsp]
  005e7	48 ff c1	 inc	 rcx
  005ea	0f b7 d0	 movzx	 edx, ax
  005ed	e8 00 00 00 00	 call	 store_hw_noswap

; 682  :             STORE_HW (trkhdr->head, head);

  005f2	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  005fa	e8 00 00 00 00	 call	 _byteswap_ushort
  005ff	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR trkhdr$[rsp]
  00607	48 83 c1 03	 add	 rcx, 3
  0060b	0f b7 d0	 movzx	 edx, ax
  0060e	e8 00 00 00 00	 call	 store_hw_noswap

; 683  :             opos = obuf + CKD_TRKHDR_SIZE;

  00613	48 8b 84 24 c8
	04 00 00	 mov	 rax, QWORD PTR obuf$[rsp]
  0061b	48 83 c0 05	 add	 rax, 5
  0061f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR opos$[rsp], rax

; 684  : 
; 685  :             /* Copy each record from the input buffer */
; 686  :             iptr = itrkbuf + H30CKD_TRKHDR_SIZE;

  00627	48 8b 84 24 88
	04 00 00	 mov	 rax, QWORD PTR itrkbuf$[rsp]
  0062f	48 83 c0 30	 add	 rax, 48			; 00000030H
  00633	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR iptr$[rsp], rax

; 687  :             ilen = itrklen - H30CKD_TRKHDR_SIZE;

  0063b	48 63 84 24 80
	04 00 00	 movsxd	 rax, DWORD PTR itrklen$[rsp]
  00643	48 83 e8 30	 sub	 rax, 48			; 00000030H
  00647	89 84 24 b8 00
	00 00		 mov	 DWORD PTR ilen$[rsp], eax
$LN14@convert_ck:

; 688  :             while (1)

  0064e	33 c0		 xor	 eax, eax
  00650	83 f8 01	 cmp	 eax, 1
  00653	0f 84 69 02 00
	00		 je	 $LN15@convert_ck

; 689  :             {
; 690  :                 /* Locate the next input record */
; 691  :                 rc = find_input_record (itrkbuf, &iptr, &ilen,

  00659	48 8d 84 24 84
	00 00 00	 lea	 rax, QWORD PTR rec$[rsp]
  00661	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00666	48 8d 84 24 94
	00 00 00	 lea	 rax, QWORD PTR ihh$[rsp]
  0066e	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00673	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR ihc$[rsp]
  0067b	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00680	48 8d 84 24 18
	01 00 00	 lea	 rax, QWORD PTR dptr$[rsp]
  00688	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0068d	48 8d 44 24 7c	 lea	 rax, QWORD PTR dlen$[rsp]
  00692	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00697	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR kptr$[rsp]
  0069f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006a4	4c 8d 4c 24 70	 lea	 r9, QWORD PTR klen$[rsp]
  006a9	4c 8d 84 24 b8
	00 00 00	 lea	 r8, QWORD PTR ilen$[rsp]
  006b1	48 8d 94 24 d8
	00 00 00	 lea	 rdx, QWORD PTR iptr$[rsp]
  006b9	48 8b 8c 24 88
	04 00 00	 mov	 rcx, QWORD PTR itrkbuf$[rsp]
  006c1	e8 00 00 00 00	 call	 find_input_record
  006c6	89 44 24 78	 mov	 DWORD PTR rc$[rsp], eax

; 692  :                         &klen, &kptr, &dlen, &dptr,
; 693  :                         &ihc, &ihh, &rec);
; 694  : 
; 695  :                 /* Exit at end of track */
; 696  :                 if (rc == 1) break;

  006ca	83 7c 24 78 01	 cmp	 DWORD PTR rc$[rsp], 1
  006cf	75 05		 jne	 SHORT $LN29@convert_ck
  006d1	e9 ec 01 00 00	 jmp	 $LN15@convert_ck
$LN29@convert_ck:

; 697  : 
; 698  :                 /* Error if invalid record header detected */
; 699  :                 if (rc > 1)

  006d6	83 7c 24 78 01	 cmp	 DWORD PTR rc$[rsp], 1
  006db	0f 8e bf 00 00
	00		 jle	 $LN30@convert_ck

; 700  :                 {
; 701  :                     // "Invalid record header (rc %d) at offset %04X in trk at CCHH %04X%04X at offset 0x%16.16"PRIX64" in file %s"
; 702  :                     FWRMSG( stderr, HHC02419, "E",

  006e1	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR offset$[rsp]
  006e8	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv324[rsp], rax
  006f0	48 8b 8c 24 88
	04 00 00	 mov	 rcx, QWORD PTR itrkbuf$[rsp]
  006f8	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR iptr$[rsp]
  00700	48 2b d1	 sub	 rdx, rcx
  00703	48 8b ca	 mov	 rcx, rdx
  00706	48 89 8c 24 08
	01 00 00	 mov	 QWORD PTR tv328[rsp], rcx
  0070e	b9 02 00 00 00	 mov	 ecx, 2
  00713	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00719	48 8b 8c 24 78
	04 00 00	 mov	 rcx, QWORD PTR ifname$[rsp]
  00721	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00726	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv324[rsp]
  0072e	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00733	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR head$[rsp]
  0073a	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0073e	8b 4c 24 74	 mov	 ecx, DWORD PTR cyl$[rsp]
  00742	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00746	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tv328[rsp]
  0074e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00752	8b 4c 24 78	 mov	 ecx, DWORD PTR rc$[rsp]
  00756	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0075a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169185
  00761	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00766	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169186
  0076d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00772	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00777	41 b9 03 00 00
	00		 mov	 r9d, 3
  0077d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169187
  00784	ba c0 02 00 00	 mov	 edx, 704		; 000002c0H
  00789	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169188
  00790	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 703  :                             rc, (unsigned int)(iptr-itrkbuf), cyl, head,
; 704  :                             (U64)offset, ifname );
; 705  :                     EXIT(9);

  00796	b9 09 00 00 00	 mov	 ecx, 9
  0079b	e8 00 00 00 00	 call	 delayed_exit
$LN30@convert_ck:

; 706  :                 }
; 707  : 
; 708  :                 /* Build AWSCKD record header in output buffer */
; 709  :                 rechdr = (CKD_RECHDR*)opos;

  007a0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR opos$[rsp]
  007a8	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR rechdr$[rsp], rax

; 710  :                 opos += CKD_RECHDR_SIZE;

  007b0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR opos$[rsp]
  007b8	48 83 c0 08	 add	 rax, 8
  007bc	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR opos$[rsp], rax

; 711  :                 STORE_HW (rechdr->cyl, ihc);

  007c4	0f b7 8c 24 90
	00 00 00	 movzx	 ecx, WORD PTR ihc$[rsp]
  007cc	e8 00 00 00 00	 call	 _byteswap_ushort
  007d1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR rechdr$[rsp]
  007d9	0f b7 d0	 movzx	 edx, ax
  007dc	e8 00 00 00 00	 call	 store_hw_noswap

; 712  :                 STORE_HW (rechdr->head, ihh);

  007e1	0f b7 8c 24 94
	00 00 00	 movzx	 ecx, WORD PTR ihh$[rsp]
  007e9	e8 00 00 00 00	 call	 _byteswap_ushort
  007ee	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR rechdr$[rsp]
  007f6	48 83 c1 02	 add	 rcx, 2
  007fa	0f b7 d0	 movzx	 edx, ax
  007fd	e8 00 00 00 00	 call	 store_hw_noswap

; 713  :                 rechdr->rec = rec;

  00802	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR rechdr$[rsp]
  0080a	0f b6 8c 24 84
	00 00 00	 movzx	 ecx, BYTE PTR rec$[rsp]
  00812	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 714  :                 rechdr->klen = klen;

  00815	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR rechdr$[rsp]
  0081d	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR klen$[rsp]
  00822	88 48 05	 mov	 BYTE PTR [rax+5], cl

; 715  :                 STORE_HW (rechdr->dlen, dlen);

  00825	0f b7 4c 24 7c	 movzx	 ecx, WORD PTR dlen$[rsp]
  0082a	e8 00 00 00 00	 call	 _byteswap_ushort
  0082f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00837	48 83 c1 06	 add	 rcx, 6
  0083b	0f b7 d0	 movzx	 edx, ax
  0083e	e8 00 00 00 00	 call	 store_hw_noswap

; 716  : 
; 717  :                 /* Copy key and data to output buffer */
; 718  :                 if (klen != 0)

  00843	0f b6 44 24 70	 movzx	 eax, BYTE PTR klen$[rsp]
  00848	85 c0		 test	 eax, eax
  0084a	74 34		 je	 SHORT $LN31@convert_ck

; 719  :                 {
; 720  :                     memcpy (opos, kptr, klen);

  0084c	0f b6 44 24 70	 movzx	 eax, BYTE PTR klen$[rsp]
  00851	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR opos$[rsp]
  00859	48 8b b4 24 10
	01 00 00	 mov	 rsi, QWORD PTR kptr$[rsp]
  00861	8b c8		 mov	 ecx, eax
  00863	f3 a4		 rep movsb

; 721  :                     opos += klen;

  00865	0f b6 44 24 70	 movzx	 eax, BYTE PTR klen$[rsp]
  0086a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR opos$[rsp]
  00872	48 03 c8	 add	 rcx, rax
  00875	48 8b c1	 mov	 rax, rcx
  00878	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR opos$[rsp], rax
$LN31@convert_ck:

; 722  :                 }
; 723  :                 if (dlen != 0)

  00880	0f b7 44 24 7c	 movzx	 eax, WORD PTR dlen$[rsp]
  00885	85 c0		 test	 eax, eax
  00887	74 34		 je	 SHORT $LN32@convert_ck

; 724  :                 {
; 725  :                     memcpy (opos, dptr, dlen);

  00889	0f b7 44 24 7c	 movzx	 eax, WORD PTR dlen$[rsp]
  0088e	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR opos$[rsp]
  00896	48 8b b4 24 18
	01 00 00	 mov	 rsi, QWORD PTR dptr$[rsp]
  0089e	8b c8		 mov	 ecx, eax
  008a0	f3 a4		 rep movsb

; 726  :                     opos += dlen;

  008a2	0f b7 44 24 7c	 movzx	 eax, WORD PTR dlen$[rsp]
  008a7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR opos$[rsp]
  008af	48 03 c8	 add	 rcx, rax
  008b2	48 8b c1	 mov	 rax, rcx
  008b5	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR opos$[rsp], rax
$LN32@convert_ck:

; 727  :                 }
; 728  : 
; 729  :             } /* end while */

  008bd	e9 8c fd ff ff	 jmp	 $LN14@convert_ck
$LN15@convert_ck:

; 730  : 
; 731  :             /* Build the end of track marker */
; 732  :             memcpy( opos, &CKD_ENDTRK, CKD_ENDTRK_SIZE );

  008c2	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR opos$[rsp]
  008ca	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR CKD_ENDTRK
  008d1	48 89 08	 mov	 QWORD PTR [rax], rcx

; 733  : 
; 734  :             /* Write the track to the file */
; 735  :             rc = write (ofd, obuf, trksize);

  008d4	44 8b 84 24 c0
	04 00 00	 mov	 r8d, DWORD PTR trksize$[rsp]
  008dc	48 8b 94 24 c8
	04 00 00	 mov	 rdx, QWORD PTR obuf$[rsp]
  008e4	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR ofd$[rsp]
  008eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  008f1	89 44 24 78	 mov	 DWORD PTR rc$[rsp], eax

; 736  :             if (rc < 0 || (U32)rc < trksize)

  008f5	83 7c 24 78 00	 cmp	 DWORD PTR rc$[rsp], 0
  008fa	7c 11		 jl	 SHORT $LN34@convert_ck
  008fc	8b 84 24 c0 04
	00 00		 mov	 eax, DWORD PTR trksize$[rsp]
  00903	39 44 24 78	 cmp	 DWORD PTR rc$[rsp], eax
  00907	0f 83 9c 00 00
	00		 jae	 $LN33@convert_ck
$LN34@convert_ck:

; 737  :             {
; 738  :                 // "Error in function %s: %s"
; 739  :                 FWRMSG( stderr, HHC02412, "E", "write()",

  0090d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00913	83 38 00	 cmp	 DWORD PTR [rax], 0
  00916	74 18		 je	 SHORT $LN41@convert_ck
  00918	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0091e	8b 08		 mov	 ecx, DWORD PTR [rax]
  00920	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00926	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv398[rsp], rax
  0092e	eb 0f		 jmp	 SHORT $LN42@convert_ck
$LN41@convert_ck:
  00930	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169193
  00937	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv398[rsp], rax
$LN42@convert_ck:
  0093f	b9 02 00 00 00	 mov	 ecx, 2
  00944	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0094a	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv398[rsp]
  00952	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00957	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169194
  0095e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00963	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169195
  0096a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0096f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169196
  00976	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0097b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00980	41 b9 03 00 00
	00		 mov	 r9d, 3
  00986	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169197
  0098d	ba e4 02 00 00	 mov	 edx, 740		; 000002e4H
  00992	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169198
  00999	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 740  :                         errno ? strerror(errno) : "incomplete" );
; 741  :                 EXIT(1);

  0099f	b9 01 00 00 00	 mov	 ecx, 1
  009a4	e8 00 00 00 00	 call	 delayed_exit
$LN33@convert_ck:

; 742  :             }
; 743  : 
; 744  :         } /* end for(head) */

  009a9	e9 09 fa ff ff	 jmp	 $LN11@convert_ck
$LN12@convert_ck:

; 745  : 
; 746  :     } /* end for(cyl) */

  009ae	e9 6d f9 ff ff	 jmp	 $LN5@convert_ck
$LN6@convert_ck:

; 747  : 
; 748  :     /* Close the AWSCKD image file */
; 749  :     rc = close (ofd);

  009b3	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR ofd$[rsp]
  009ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close
  009c0	89 44 24 78	 mov	 DWORD PTR rc$[rsp], eax

; 750  :     if (rc < 0)

  009c4	83 7c 24 78 00	 cmp	 DWORD PTR rc$[rsp], 0
  009c9	0f 8d 80 00 00
	00		 jge	 $LN35@convert_ck

; 751  :     {
; 752  :         // "Error in function %s: %s"
; 753  :         FWRMSG( stderr, HHC02412, "E", "close()", strerror( errno ));

  009cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  009d5	8b 08		 mov	 ecx, DWORD PTR [rax]
  009d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  009dd	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv414[rsp], rax
  009e5	b9 02 00 00 00	 mov	 ecx, 2
  009ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009f0	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv414[rsp]
  009f8	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  009fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169200
  00a04	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00a09	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169201
  00a10	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a15	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169202
  00a1c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a21	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a26	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a2c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169203
  00a33	ba f1 02 00 00	 mov	 edx, 753		; 000002f1H
  00a38	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169204
  00a3f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 754  :         EXIT(10);

  00a45	b9 0a 00 00 00	 mov	 ecx, 10
  00a4a	e8 00 00 00 00	 call	 delayed_exit
$LN35@convert_ck:

; 755  :     }
; 756  : 
; 757  :     /* Display completion message */
; 758  :     // "%u cylinders succesfully written to file %s"
; 759  :     WRMSG( HHC02420, "I", cyl - start, ofname );

  00a4f	8b 84 24 d0 04
	00 00		 mov	 eax, DWORD PTR start$[rsp]
  00a56	8b 4c 24 74	 mov	 ecx, DWORD PTR cyl$[rsp]
  00a5a	2b c8		 sub	 ecx, eax
  00a5c	8b c1		 mov	 eax, ecx
  00a5e	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv462[rsp], eax
  00a65	b9 01 00 00 00	 mov	 ecx, 1
  00a6a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a70	48 8b 8c 24 a0
	04 00 00	 mov	 rcx, QWORD PTR ofname$[rsp]
  00a78	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00a7d	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv462[rsp]
  00a84	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00a88	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169205
  00a8f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a94	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169206
  00a9b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00aa0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00aa5	41 b9 03 00 00
	00		 mov	 r9d, 3
  00aab	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169207
  00ab2	ba f7 02 00 00	 mov	 edx, 759		; 000002f7H
  00ab7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169208
  00abe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 760  : 
; 761  : } /* end function convert_ckd_file */

  00ac4	48 8b 8c 24 40
	04 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00acc	48 33 cc	 xor	 rcx, rsp
  00acf	e8 00 00 00 00	 call	 __security_check_cookie
  00ad4	48 81 c4 58 04
	00 00		 add	 rsp, 1112		; 00000458H
  00adb	5f		 pop	 rdi
  00adc	5e		 pop	 rsi
  00add	c3		 ret	 0
convert_ckd_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdconv.c
_TEXT	SEGMENT
dt$ = 80
alts$ = 84
cyls$ = 88
itrklen$ = 92
tv182 = 96
rec$ = 100
klen$ = 101
code$ = 104
ifd$ = 108
tv166 = 112
dlen$ = 116
itrkbuf$ = 120
tv167 = 128
tv183 = 132
len$ = 136
rc$ = 140
cyl$ = 144
head$ = 148
dptr$ = 152
tv75 = 160
tv211 = 168
pbuf$ = 176
kptr$ = 184
h30trkhdr$ = 192
buf$1 = 240
pathname$ = 288
__$ArrayPad$ = 560
ifname$ = 608
devt$ = 616
vcyls$ = 624
itrkl$ = 632
itrkb$ = 640
volser$ = 648
open_input_image PROC

; 370  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 48 02
	00 00		 sub	 rsp, 584		; 00000248H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 30
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 371  : int             rc;                     /* Return code               */
; 372  : H30CKD_TRKHDR   h30trkhdr;              /* Input track header        */
; 373  : IFD             ifd;                    /* Input file descriptor     */
; 374  : int             len;                    /* Length of input           */
; 375  : U16             code;                   /* Device type code          */
; 376  : U16             dt = 0;                 /* Device type               */

  0002f	33 c0		 xor	 eax, eax
  00031	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax

; 377  : U32             cyls;                   /* Device size (pri+alt cyls)*/
; 378  : U32             alts;                   /* Number of alternate cyls  */
; 379  : BYTE           *itrkbuf;                /* -> Input track buffer     */
; 380  : U32             itrklen = 0;            /* Input track length        */

  00036	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR itrklen$[rsp], 0

; 381  : BYTE           *pbuf;                   /* Current byte in input buf */
; 382  : BYTE            klen;                   /* Key length                */
; 383  : U16             dlen;                   /* Data length               */
; 384  : BYTE           *kptr;                   /* -> Key in input buffer    */
; 385  : BYTE           *dptr;                   /* -> Data in input buffer   */
; 386  : U32             cyl;                    /* Cylinder number           */
; 387  : U32             head;                   /* Head number               */
; 388  : BYTE            rec;                    /* Record number             */
; 389  : char            pathname[MAX_PATH];     /* file path in host format  */
; 390  : 
; 391  :     hostpath(pathname, (char *)ifname, sizeof(pathname));

  0003e	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00044	48 8b 94 24 60
	02 00 00	 mov	 rdx, QWORD PTR ifname$[rsp]
  0004c	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 392  : 
; 393  :     /* Open the HDR-30 CKD image file */
; 394  :   #if defined( HAVE_ZLIB )
; 395  :     if (strcmp(ifname, "-") == 0)
; 396  :         ifd = gzdopen (STDIN_FILENO, "rb");
; 397  :     else
; 398  :         ifd = gzopen (pathname, "rb");
; 399  : 
; 400  :     if (ifd == NULL)
; 401  :     {
; 402  :         // "Error in function %s: %s"
; 403  :         FWRMSG( stderr, HHC02412, "E", "gzopen()", strerror( errno ));
; 404  :         EXIT(3);
; 405  :     }
; 406  :   #else /*!defined( HAVE_ZLIB )*/
; 407  :     if (strcmp(ifname, "-") == 0)

  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168995
  00061	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR ifname$[rsp]
  00069	e8 00 00 00 00	 call	 strcmp
  0006e	85 c0		 test	 eax, eax
  00070	75 0d		 jne	 SHORT $LN8@open_input

; 408  :         ifd = STDIN_FILENO;

  00072	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR ifd$[rsp], 0
  0007a	e9 a2 00 00 00	 jmp	 $LN9@open_input
$LN8@open_input:

; 409  :     else
; 410  :     {
; 411  :         ifd = HOPEN (pathname, O_RDONLY | O_BINARY);

  0007f	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  00084	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00092	89 44 24 6c	 mov	 DWORD PTR ifd$[rsp], eax

; 412  : 
; 413  :         if (ifd < 0)

  00096	83 7c 24 6c 00	 cmp	 DWORD PTR ifd$[rsp], 0
  0009b	0f 8d 80 00 00
	00		 jge	 $LN10@open_input

; 414  :         {
; 415  :             // "Error in function %s: %s"
; 416  :             FWRMSG( stderr, HHC02412, "E", "open()", strerror( errno ));

  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000a7	8b 08		 mov	 ecx, DWORD PTR [rax]
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000af	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv75[rsp], rax
  000b7	b9 02 00 00 00	 mov	 ecx, 2
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000c2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv75[rsp]
  000ca	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168997
  000d6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168998
  000e2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168999
  000ee	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000f3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f8	41 b9 03 00 00
	00		 mov	 r9d, 3
  000fe	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169000
  00105	ba a0 01 00 00	 mov	 edx, 416		; 000001a0H
  0010a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169001
  00111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 417  :             EXIT(3);

  00117	b9 03 00 00 00	 mov	 ecx, 3
  0011c	e8 00 00 00 00	 call	 delayed_exit
$LN10@open_input:
$LN9@open_input:

; 418  :         }
; 419  :     }
; 420  :   #endif /*!defined( HAVE_ZLIB )*/
; 421  : 
; 422  :     /* Read the first track header */
; 423  :     read_input_data (ifd, ifname, (BYTE*)&h30trkhdr,

  00121	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00129	41 b9 30 00 00
	00		 mov	 r9d, 48			; 00000030H
  0012f	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR h30trkhdr$[rsp]
  00137	48 8b 94 24 60
	02 00 00	 mov	 rdx, QWORD PTR ifname$[rsp]
  0013f	8b 4c 24 6c	 mov	 ecx, DWORD PTR ifd$[rsp]
  00143	e8 00 00 00 00	 call	 read_input_data

; 424  :                     H30CKD_TRKHDR_SIZE, 0);
; 425  : 
; 426  :   #if !defined( HAVE_ZLIB )
; 427  :     /* Reject input if compressed and we lack gzip support */
; 428  :     if (memcmp(h30trkhdr.devcode, gz_magic_id, sizeof(gz_magic_id)) == 0)

  00148	41 b8 02 00 00
	00		 mov	 r8d, 2
  0014e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:gz_magic_id
  00155	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR h30trkhdr$[rsp]
  0015d	e8 00 00 00 00	 call	 memcmp
  00162	85 c0		 test	 eax, eax
  00164	75 51		 jne	 SHORT $LN11@open_input

; 429  :     {
; 430  :         // "Dasdconv is compiled without compress support and input is compressed"
; 431  :         FWRMSG( stderr, HHC02413, "E" );

  00166	b9 02 00 00 00	 mov	 ecx, 2
  0016b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00171	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169003
  00178	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0017d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169004
  00184	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00189	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0018e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00194	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169005
  0019b	ba af 01 00 00	 mov	 edx, 431		; 000001afH
  001a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169006
  001a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 432  :         EXIT(3);

  001ad	b9 03 00 00 00	 mov	 ecx, 3
  001b2	e8 00 00 00 00	 call	 delayed_exit
$LN11@open_input:

; 433  :     }
; 434  :   #endif /*!defined( HAVE_ZLIB )*/
; 435  : 
; 436  :     /* Reject input if it is already in CKD or CCKD format */
; 437  :     if (memcmp((BYTE*)&h30trkhdr, ckd_ident, sizeof(ckd_ident)) == 0)

  001b7	41 b8 04 00 00
	00		 mov	 r8d, 4
  001bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ckd_ident
  001c4	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR h30trkhdr$[rsp]
  001cc	e8 00 00 00 00	 call	 memcmp
  001d1	85 c0		 test	 eax, eax
  001d3	75 51		 jne	 SHORT $LN12@open_input

; 438  :     {
; 439  :         // "Input file is already in CKD format, use dasdcopy"
; 440  :         WRMSG( HHC02414, "I" );

  001d5	b9 01 00 00 00	 mov	 ecx, 1
  001da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169008
  001e7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169009
  001f3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001f8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001fd	41 b9 03 00 00
	00		 mov	 r9d, 3
  00203	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169010
  0020a	ba b8 01 00 00	 mov	 edx, 440		; 000001b8H
  0020f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169011
  00216	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 441  :         EXIT(3);

  0021c	b9 03 00 00 00	 mov	 ecx, 3
  00221	e8 00 00 00 00	 call	 delayed_exit
$LN12@open_input:

; 442  :     }
; 443  : 
; 444  :     /* Extract the device type code from the track header */
; 445  :     FETCH_HW (code, h30trkhdr.devcode);

  00226	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR h30trkhdr$[rsp]
  0022e	e8 00 00 00 00	 call	 fetch_hw_noswap
  00233	0f b7 c8	 movzx	 ecx, ax
  00236	e8 00 00 00 00	 call	 _byteswap_ushort
  0023b	66 89 44 24 68	 mov	 WORD PTR code$[rsp], ax

; 446  : 
; 447  :     /* Determine the input device type and size from the device code */
; 448  :     switch (code) {

  00240	0f b7 44 24 68	 movzx	 eax, WORD PTR code$[rsp]
  00245	89 44 24 70	 mov	 DWORD PTR tv166[rsp], eax
  00249	8b 44 24 70	 mov	 eax, DWORD PTR tv166[rsp]
  0024d	ff c8		 dec	 eax
  0024f	89 44 24 70	 mov	 DWORD PTR tv166[rsp], eax
  00253	83 7c 24 70 14	 cmp	 DWORD PTR tv166[rsp], 20
  00258	0f 87 05 02 00
	00		 ja	 $LN29@open_input
  0025e	48 63 44 24 70	 movsxd	 rax, DWORD PTR tv166[rsp]
  00263	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0026a	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN45@open_input[rcx+rax*4]
  00271	48 03 c1	 add	 rax, rcx
  00274	ff e0		 jmp	 rax
$LN13@open_input:

; 449  :     case 0x01: dt=0x3330; cyls=411; alts=7; break;      /* 3330      */

  00276	b8 30 33 00 00	 mov	 eax, 13104		; 00003330H
  0027b	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  00280	c7 44 24 58 9b
	01 00 00	 mov	 DWORD PTR cyls$[rsp], 411 ; 0000019bH
  00288	c7 44 24 54 07
	00 00 00	 mov	 DWORD PTR alts$[rsp], 7
  00290	e9 36 02 00 00	 jmp	 $LN2@open_input
$LN14@open_input:

; 450  :     case 0x02: dt=0x3330; cyls=815; alts=7; break;      /* 3330-11   */

  00295	b8 30 33 00 00	 mov	 eax, 13104		; 00003330H
  0029a	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  0029f	c7 44 24 58 2f
	03 00 00	 mov	 DWORD PTR cyls$[rsp], 815 ; 0000032fH
  002a7	c7 44 24 54 07
	00 00 00	 mov	 DWORD PTR alts$[rsp], 7
  002af	e9 17 02 00 00	 jmp	 $LN2@open_input
$LN15@open_input:

; 451  :     case 0x03: dt=0x3340; cyls=351; alts=1; break;      /* 3340-35   */

  002b4	b8 40 33 00 00	 mov	 eax, 13120		; 00003340H
  002b9	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  002be	c7 44 24 58 5f
	01 00 00	 mov	 DWORD PTR cyls$[rsp], 351 ; 0000015fH
  002c6	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR alts$[rsp], 1
  002ce	e9 f8 01 00 00	 jmp	 $LN2@open_input
$LN16@open_input:

; 452  :     case 0x04: dt=0x3340; cyls=701; alts=1; break;      /* 3340-70   */

  002d3	b8 40 33 00 00	 mov	 eax, 13120		; 00003340H
  002d8	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  002dd	c7 44 24 58 bd
	02 00 00	 mov	 DWORD PTR cyls$[rsp], 701 ; 000002bdH
  002e5	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR alts$[rsp], 1
  002ed	e9 d9 01 00 00	 jmp	 $LN2@open_input
$LN17@open_input:

; 453  :     case 0x05: dt=0x3350; cyls=562; alts=7; break;      /* 3350      */

  002f2	b8 50 33 00 00	 mov	 eax, 13136		; 00003350H
  002f7	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  002fc	c7 44 24 58 32
	02 00 00	 mov	 DWORD PTR cyls$[rsp], 562 ; 00000232H
  00304	c7 44 24 54 07
	00 00 00	 mov	 DWORD PTR alts$[rsp], 7
  0030c	e9 ba 01 00 00	 jmp	 $LN2@open_input
$LN18@open_input:

; 454  :     case 0x06: dt=0x3375; cyls=962; alts=3; break;      /* 3375      */

  00311	b8 75 33 00 00	 mov	 eax, 13173		; 00003375H
  00316	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  0031b	c7 44 24 58 c2
	03 00 00	 mov	 DWORD PTR cyls$[rsp], 962 ; 000003c2H
  00323	c7 44 24 54 03
	00 00 00	 mov	 DWORD PTR alts$[rsp], 3
  0032b	e9 9b 01 00 00	 jmp	 $LN2@open_input
$LN19@open_input:

; 455  :     case 0x08: dt=0x3380; cyls=888; alts=3; break;      /* 3380-A,D,J*/

  00330	b8 80 33 00 00	 mov	 eax, 13184		; 00003380H
  00335	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  0033a	c7 44 24 58 78
	03 00 00	 mov	 DWORD PTR cyls$[rsp], 888 ; 00000378H
  00342	c7 44 24 54 03
	00 00 00	 mov	 DWORD PTR alts$[rsp], 3
  0034a	e9 7c 01 00 00	 jmp	 $LN2@open_input
$LN20@open_input:

; 456  :     case 0x09: dt=0x3380; cyls=1774; alts=4; break;     /* 3380-E    */

  0034f	b8 80 33 00 00	 mov	 eax, 13184		; 00003380H
  00354	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  00359	c7 44 24 58 ee
	06 00 00	 mov	 DWORD PTR cyls$[rsp], 1774 ; 000006eeH
  00361	c7 44 24 54 04
	00 00 00	 mov	 DWORD PTR alts$[rsp], 4
  00369	e9 5d 01 00 00	 jmp	 $LN2@open_input
$LN21@open_input:

; 457  :     case 0x0A: dt=0x3380; cyls=2660; alts=5; break;     /* 3380-K    */

  0036e	b8 80 33 00 00	 mov	 eax, 13184		; 00003380H
  00373	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  00378	c7 44 24 58 64
	0a 00 00	 mov	 DWORD PTR cyls$[rsp], 2660 ; 00000a64H
  00380	c7 44 24 54 05
	00 00 00	 mov	 DWORD PTR alts$[rsp], 5
  00388	e9 3e 01 00 00	 jmp	 $LN2@open_input
$LN22@open_input:

; 458  :     case 0x0B: dt=0x3390; cyls=1117; alts=4; break;     /* 3390-1    */

  0038d	b8 90 33 00 00	 mov	 eax, 13200		; 00003390H
  00392	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  00397	c7 44 24 58 5d
	04 00 00	 mov	 DWORD PTR cyls$[rsp], 1117 ; 0000045dH
  0039f	c7 44 24 54 04
	00 00 00	 mov	 DWORD PTR alts$[rsp], 4
  003a7	e9 1f 01 00 00	 jmp	 $LN2@open_input
$LN23@open_input:

; 459  :     case 0x0C: dt=0x3390; cyls=2230; alts=4; break;     /* 3390-2    */

  003ac	b8 90 33 00 00	 mov	 eax, 13200		; 00003390H
  003b1	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  003b6	c7 44 24 58 b6
	08 00 00	 mov	 DWORD PTR cyls$[rsp], 2230 ; 000008b6H
  003be	c7 44 24 54 04
	00 00 00	 mov	 DWORD PTR alts$[rsp], 4
  003c6	e9 00 01 00 00	 jmp	 $LN2@open_input
$LN24@open_input:

; 460  :     case 0x0D: dt=0x3390; cyls=3343; alts=4; break;     /* 3390-3    */

  003cb	b8 90 33 00 00	 mov	 eax, 13200		; 00003390H
  003d0	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  003d5	c7 44 24 58 0f
	0d 00 00	 mov	 DWORD PTR cyls$[rsp], 3343 ; 00000d0fH
  003dd	c7 44 24 54 04
	00 00 00	 mov	 DWORD PTR alts$[rsp], 4
  003e5	e9 e1 00 00 00	 jmp	 $LN2@open_input
$LN25@open_input:

; 461  :     case 0x12: dt=0x2314; cyls=203; alts=3; break;      /* 2314      */

  003ea	b8 14 23 00 00	 mov	 eax, 8980		; 00002314H
  003ef	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  003f4	c7 44 24 58 cb
	00 00 00	 mov	 DWORD PTR cyls$[rsp], 203 ; 000000cbH
  003fc	c7 44 24 54 03
	00 00 00	 mov	 DWORD PTR alts$[rsp], 3
  00404	e9 c2 00 00 00	 jmp	 $LN2@open_input
$LN26@open_input:

; 462  :     case 0x13: dt=0x3390; cyls=10038; alts=21; break;   /* 3390-9    */

  00409	b8 90 33 00 00	 mov	 eax, 13200		; 00003390H
  0040e	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  00413	c7 44 24 58 36
	27 00 00	 mov	 DWORD PTR cyls$[rsp], 10038 ; 00002736H
  0041b	c7 44 24 54 15
	00 00 00	 mov	 DWORD PTR alts$[rsp], 21
  00423	e9 a3 00 00 00	 jmp	 $LN2@open_input
$LN27@open_input:

; 463  :     case 0x14: dt=0x9345; cyls=1454; alts=14; break;    /* 9345-1    */

  00428	b8 45 93 00 00	 mov	 eax, 37701		; 00009345H
  0042d	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  00432	c7 44 24 58 ae
	05 00 00	 mov	 DWORD PTR cyls$[rsp], 1454 ; 000005aeH
  0043a	c7 44 24 54 0e
	00 00 00	 mov	 DWORD PTR alts$[rsp], 14
  00442	e9 84 00 00 00	 jmp	 $LN2@open_input
$LN28@open_input:

; 464  :     case 0x15: dt=0x9345; cyls=2170; alts=14; break;    /* 9345-2    */

  00447	b8 45 93 00 00	 mov	 eax, 37701		; 00009345H
  0044c	66 89 44 24 50	 mov	 WORD PTR dt$[rsp], ax
  00451	c7 44 24 58 7a
	08 00 00	 mov	 DWORD PTR cyls$[rsp], 2170 ; 0000087aH
  00459	c7 44 24 54 0e
	00 00 00	 mov	 DWORD PTR alts$[rsp], 14
  00461	eb 68		 jmp	 SHORT $LN2@open_input
$LN29@open_input:

; 465  :     default:
; 466  :         // "Unknown device type %04X at offset 00000000 in input file"
; 467  :         FWRMSG( stderr, HHC02415, "E", code );

  00463	0f b7 44 24 68	 movzx	 eax, WORD PTR code$[rsp]
  00468	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv167[rsp], eax
  0046f	b9 02 00 00 00	 mov	 ecx, 2
  00474	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0047a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv167[rsp]
  00481	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00485	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169029
  0048c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00491	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169030
  00498	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0049d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004a2	41 b9 03 00 00
	00		 mov	 r9d, 3
  004a8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169031
  004af	ba d3 01 00 00	 mov	 edx, 467		; 000001d3H
  004b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169032
  004bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 468  :         EXIT(3);

  004c1	b9 03 00 00 00	 mov	 ecx, 3
  004c6	e8 00 00 00 00	 call	 delayed_exit
$LN2@open_input:

; 469  :     } /* end switch(code) */
; 470  : 
; 471  :     /* Use the device type to determine the input image track size */
; 472  :     switch (dt) {

  004cb	0f b7 44 24 50	 movzx	 eax, WORD PTR dt$[rsp]
  004d0	89 44 24 60	 mov	 DWORD PTR tv182[rsp], eax
  004d4	81 7c 24 60 75
	33 00 00	 cmp	 DWORD PTR tv182[rsp], 13173 ; 00003375H
  004dc	7f 34		 jg	 SHORT $LN44@open_input
  004de	81 7c 24 60 75
	33 00 00	 cmp	 DWORD PTR tv182[rsp], 13173 ; 00003375H
  004e6	74 7e		 je	 SHORT $LN34@open_input
  004e8	81 7c 24 60 14
	23 00 00	 cmp	 DWORD PTR tv182[rsp], 8980 ; 00002314H
  004f0	74 40		 je	 SHORT $LN30@open_input
  004f2	81 7c 24 60 30
	33 00 00	 cmp	 DWORD PTR tv182[rsp], 13104 ; 00003330H
  004fa	74 43		 je	 SHORT $LN31@open_input
  004fc	81 7c 24 60 40
	33 00 00	 cmp	 DWORD PTR tv182[rsp], 13120 ; 00003340H
  00504	74 46		 je	 SHORT $LN32@open_input
  00506	81 7c 24 60 50
	33 00 00	 cmp	 DWORD PTR tv182[rsp], 13136 ; 00003350H
  0050e	74 49		 je	 SHORT $LN33@open_input
  00510	eb 7f		 jmp	 SHORT $LN38@open_input
$LN44@open_input:
  00512	81 7c 24 60 80
	33 00 00	 cmp	 DWORD PTR tv182[rsp], 13184 ; 00003380H
  0051a	74 57		 je	 SHORT $LN35@open_input
  0051c	81 7c 24 60 90
	33 00 00	 cmp	 DWORD PTR tv182[rsp], 13200 ; 00003390H
  00524	74 57		 je	 SHORT $LN36@open_input
  00526	81 7c 24 60 45
	93 00 00	 cmp	 DWORD PTR tv182[rsp], 37701 ; 00009345H
  0052e	74 57		 je	 SHORT $LN37@open_input
  00530	eb 5f		 jmp	 SHORT $LN38@open_input
$LN30@open_input:

; 473  :     case 0x2314: itrklen = 0x2000; break;

  00532	c7 44 24 5c 00
	20 00 00	 mov	 DWORD PTR itrklen$[rsp], 8192 ; 00002000H
  0053a	e9 ba 00 00 00	 jmp	 $LN4@open_input
$LN31@open_input:

; 474  :     case 0x3330: itrklen = 0x3400; break;

  0053f	c7 44 24 5c 00
	34 00 00	 mov	 DWORD PTR itrklen$[rsp], 13312 ; 00003400H
  00547	e9 ad 00 00 00	 jmp	 $LN4@open_input
$LN32@open_input:

; 475  :     case 0x3340: itrklen = 0x2400; break;

  0054c	c7 44 24 5c 00
	24 00 00	 mov	 DWORD PTR itrklen$[rsp], 9216 ; 00002400H
  00554	e9 a0 00 00 00	 jmp	 $LN4@open_input
$LN33@open_input:

; 476  :     case 0x3350: itrklen = 0x4C00; break;

  00559	c7 44 24 5c 00
	4c 00 00	 mov	 DWORD PTR itrklen$[rsp], 19456 ; 00004c00H
  00561	e9 93 00 00 00	 jmp	 $LN4@open_input
$LN34@open_input:

; 477  :     case 0x3375: itrklen = 0x9000; break;

  00566	c7 44 24 5c 00
	90 00 00	 mov	 DWORD PTR itrklen$[rsp], 36864 ; 00009000H
  0056e	e9 86 00 00 00	 jmp	 $LN4@open_input
$LN35@open_input:

; 478  :     case 0x3380: itrklen = 0xBC00; break;

  00573	c7 44 24 5c 00
	bc 00 00	 mov	 DWORD PTR itrklen$[rsp], 48128 ; 0000bc00H
  0057b	eb 7c		 jmp	 SHORT $LN4@open_input
$LN36@open_input:

; 479  :     case 0x3390: itrklen = 0xE400; break;

  0057d	c7 44 24 5c 00
	e4 00 00	 mov	 DWORD PTR itrklen$[rsp], 58368 ; 0000e400H
  00585	eb 72		 jmp	 SHORT $LN4@open_input
$LN37@open_input:

; 480  :     case 0x9345: itrklen = 0xBC00; break;

  00587	c7 44 24 5c 00
	bc 00 00	 mov	 DWORD PTR itrklen$[rsp], 48128 ; 0000bc00H
  0058f	eb 68		 jmp	 SHORT $LN4@open_input
$LN38@open_input:

; 481  :     default:
; 482  :         // "Unknown device type %04X"
; 483  :         FWRMSG( stderr, HHC02416, "E", dt );

  00591	0f b7 44 24 50	 movzx	 eax, WORD PTR dt$[rsp]
  00596	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv183[rsp], eax
  0059d	b9 02 00 00 00	 mov	 ecx, 2
  005a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005a8	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv183[rsp]
  005af	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169042
  005ba	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169043
  005c6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005cb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005d0	41 b9 03 00 00
	00		 mov	 r9d, 3
  005d6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169044
  005dd	ba e3 01 00 00	 mov	 edx, 483		; 000001e3H
  005e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169045
  005e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 484  :         EXIT(3);

  005ef	b9 03 00 00 00	 mov	 ecx, 3
  005f4	e8 00 00 00 00	 call	 delayed_exit
$LN4@open_input:

; 485  :     } /* end switch(dt) */
; 486  : 
; 487  :     /* Obtain the input track buffer */
; 488  :     itrkbuf = malloc (itrklen);

  005f9	8b 44 24 5c	 mov	 eax, DWORD PTR itrklen$[rsp]
  005fd	8b c8		 mov	 ecx, eax
  005ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00605	48 89 44 24 78	 mov	 QWORD PTR itrkbuf$[rsp], rax

; 489  :     if (itrkbuf == NULL)

  0060a	48 83 7c 24 78
	00		 cmp	 QWORD PTR itrkbuf$[rsp], 0
  00610	0f 85 a0 00 00
	00		 jne	 $LN39@open_input

; 490  :     {
; 491  :         char buf[40];
; 492  :         MSGBUF( buf, "malloc(%u)", itrklen);

  00616	44 8b 4c 24 5c	 mov	 r9d, DWORD PTR itrklen$[rsp]
  0061b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169047
  00622	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00627	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  0062f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 493  :         // "Error in function %s: %s"
; 494  :         FWRMSG( stderr, HHC02412, "E", buf, strerror( errno ));

  00635	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0063b	8b 08		 mov	 ecx, DWORD PTR [rax]
  0063d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00643	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv211[rsp], rax
  0064b	b9 02 00 00 00	 mov	 ecx, 2
  00650	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00656	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv211[rsp]
  0065e	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00663	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  0066b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00670	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169048
  00677	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0067c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169049
  00683	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00688	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0068d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00693	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169050
  0069a	ba ee 01 00 00	 mov	 edx, 494		; 000001eeH
  0069f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169051
  006a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 495  :         EXIT(3);

  006ac	b9 03 00 00 00	 mov	 ecx, 3
  006b1	e8 00 00 00 00	 call	 delayed_exit
$LN39@open_input:

; 496  :     }
; 497  : 
; 498  :     /* Copy the first track header to the input track buffer */
; 499  :     memcpy (itrkbuf, &h30trkhdr, H30CKD_TRKHDR_SIZE);

  006b6	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR h30trkhdr$[rsp]
  006be	48 8b 7c 24 78	 mov	 rdi, QWORD PTR itrkbuf$[rsp]
  006c3	48 8b f0	 mov	 rsi, rax
  006c6	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  006cb	f3 a4		 rep movsb

; 500  : 
; 501  :     /* Read the remainder of the first track into the buffer */
; 502  :     read_input_data (ifd, ifname,

  006cd	8b 44 24 5c	 mov	 eax, DWORD PTR itrklen$[rsp]
  006d1	48 83 e8 30	 sub	 rax, 48			; 00000030H
  006d5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR itrkbuf$[rsp]
  006da	48 83 c1 30	 add	 rcx, 48			; 00000030H
  006de	c7 44 24 20 30
	00 00 00	 mov	 DWORD PTR [rsp+32], 48	; 00000030H
  006e6	44 8b c8	 mov	 r9d, eax
  006e9	4c 8b c1	 mov	 r8, rcx
  006ec	48 8b 94 24 60
	02 00 00	 mov	 rdx, QWORD PTR ifname$[rsp]
  006f4	8b 4c 24 6c	 mov	 ecx, DWORD PTR ifd$[rsp]
  006f8	e8 00 00 00 00	 call	 read_input_data

; 503  :                      itrkbuf + H30CKD_TRKHDR_SIZE,
; 504  :                      itrklen - H30CKD_TRKHDR_SIZE,
; 505  :                      H30CKD_TRKHDR_SIZE);
; 506  : 
; 507  :     /* Initialize the volume serial number */
; 508  :     strlcpy( (char*) volser, "(NONE)", VOLSER_LEN+1 );

  006fd	41 b8 07 00 00
	00		 mov	 r8d, 7
  00703	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169052
  0070a	48 8b 8c 24 88
	02 00 00	 mov	 rcx, QWORD PTR volser$[rsp]
  00712	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 509  : 
; 510  :     /* Search for volume label in record 3 of first track */
; 511  :     pbuf = itrkbuf + H30CKD_TRKHDR_SIZE;

  00718	48 8b 44 24 78	 mov	 rax, QWORD PTR itrkbuf$[rsp]
  0071d	48 83 c0 30	 add	 rax, 48			; 00000030H
  00721	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR pbuf$[rsp], rax

; 512  :     len  = itrklen - H30CKD_TRKHDR_SIZE;

  00729	8b 44 24 5c	 mov	 eax, DWORD PTR itrklen$[rsp]
  0072d	48 83 e8 30	 sub	 rax, 48			; 00000030H
  00731	89 84 24 88 00
	00 00		 mov	 DWORD PTR len$[rsp], eax
$LN6@open_input:

; 513  :     while (1)

  00738	33 c0		 xor	 eax, eax
  0073a	83 f8 01	 cmp	 eax, 1
  0073d	0f 84 22 01 00
	00		 je	 $LN7@open_input

; 514  :     {
; 515  :         /* Find next input record */
; 516  :         rc = find_input_record (itrkbuf, &pbuf, &len,

  00743	48 8d 44 24 64	 lea	 rax, QWORD PTR rec$[rsp]
  00748	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0074d	48 8d 84 24 94
	00 00 00	 lea	 rax, QWORD PTR head$[rsp]
  00755	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0075a	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR cyl$[rsp]
  00762	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00767	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR dptr$[rsp]
  0076f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00774	48 8d 44 24 74	 lea	 rax, QWORD PTR dlen$[rsp]
  00779	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0077e	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR kptr$[rsp]
  00786	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0078b	4c 8d 4c 24 65	 lea	 r9, QWORD PTR klen$[rsp]
  00790	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR len$[rsp]
  00798	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR pbuf$[rsp]
  007a0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR itrkbuf$[rsp]
  007a5	e8 00 00 00 00	 call	 find_input_record
  007aa	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 517  :                 &klen, &kptr, &dlen, &dptr,
; 518  :                 &cyl, &head, &rec);
; 519  : 
; 520  :         /* Give up if error or end of track */
; 521  :         if (rc != 0) break;

  007b1	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  007b9	74 05		 je	 SHORT $LN40@open_input
  007bb	e9 a5 00 00 00	 jmp	 $LN7@open_input
$LN40@open_input:

; 522  : 
; 523  :         /* Process when record 3 is found */
; 524  :         if (cyl == 0 && head == 0 && rec == 3)

  007c0	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR cyl$[rsp], 0
  007c8	0f 85 92 00 00
	00		 jne	 $LN41@open_input
  007ce	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR head$[rsp], 0
  007d6	0f 85 84 00 00
	00		 jne	 $LN41@open_input
  007dc	0f b6 44 24 64	 movzx	 eax, BYTE PTR rec$[rsp]
  007e1	83 f8 03	 cmp	 eax, 3
  007e4	75 7a		 jne	 SHORT $LN41@open_input

; 525  :         {
; 526  :             /* Extract volser if it is a volume label */
; 527  :             if (klen ==  4 && memcmp( kptr, VOL1_KEY, VOL1_KEYLEN ) == 0
; 528  :             &&  dlen == 80 && memcmp( dptr, VOL1_KEY, VOL1_KEYLEN ) == 0)

  007e6	0f b6 44 24 65	 movzx	 eax, BYTE PTR klen$[rsp]
  007eb	83 f8 04	 cmp	 eax, 4
  007ee	75 6e		 jne	 SHORT $LN42@open_input
  007f0	41 b8 04 00 00
	00		 mov	 r8d, 4
  007f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:VOL1_KEY
  007fd	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR kptr$[rsp]
  00805	e8 00 00 00 00	 call	 memcmp
  0080a	85 c0		 test	 eax, eax
  0080c	75 50		 jne	 SHORT $LN42@open_input
  0080e	0f b7 44 24 74	 movzx	 eax, WORD PTR dlen$[rsp]
  00813	83 f8 50	 cmp	 eax, 80			; 00000050H
  00816	75 46		 jne	 SHORT $LN42@open_input
  00818	41 b8 04 00 00
	00		 mov	 r8d, 4
  0081e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:VOL1_KEY
  00825	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dptr$[rsp]
  0082d	e8 00 00 00 00	 call	 memcmp
  00832	85 c0		 test	 eax, eax
  00834	75 28		 jne	 SHORT $LN42@open_input

; 529  :                 make_asciiz( (char*) volser, VOLSER_LEN+1, dptr + VOL1_KEYLEN, VOLSER_LEN );

  00836	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dptr$[rsp]
  0083e	48 83 c0 04	 add	 rax, 4
  00842	41 b9 06 00 00
	00		 mov	 r9d, 6
  00848	4c 8b c0	 mov	 r8, rax
  0084b	ba 07 00 00 00	 mov	 edx, 7
  00850	48 8b 8c 24 88
	02 00 00	 mov	 rcx, QWORD PTR volser$[rsp]
  00858	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_make_asciiz
$LN42@open_input:

; 530  :             break;

  0085e	eb 05		 jmp	 SHORT $LN7@open_input
$LN41@open_input:

; 531  :         }
; 532  :     } /* end while */

  00860	e9 d3 fe ff ff	 jmp	 $LN6@open_input
$LN7@open_input:

; 533  : 
; 534  :     /* Set output variables and return the input file descriptor */
; 535  :     *devt  = dt;

  00865	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR devt$[rsp]
  0086d	0f b7 4c 24 50	 movzx	 ecx, WORD PTR dt$[rsp]
  00872	66 89 08	 mov	 WORD PTR [rax], cx

; 536  :     *vcyls = cyls - alts;

  00875	8b 44 24 54	 mov	 eax, DWORD PTR alts$[rsp]
  00879	8b 4c 24 58	 mov	 ecx, DWORD PTR cyls$[rsp]
  0087d	2b c8		 sub	 ecx, eax
  0087f	8b c1		 mov	 eax, ecx
  00881	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR vcyls$[rsp]
  00889	89 01		 mov	 DWORD PTR [rcx], eax

; 537  :     *itrkl = itrklen;

  0088b	48 8b 84 24 78
	02 00 00	 mov	 rax, QWORD PTR itrkl$[rsp]
  00893	8b 4c 24 5c	 mov	 ecx, DWORD PTR itrklen$[rsp]
  00897	89 08		 mov	 DWORD PTR [rax], ecx

; 538  :     *itrkb = itrkbuf;

  00899	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR itrkb$[rsp]
  008a1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR itrkbuf$[rsp]
  008a6	48 89 08	 mov	 QWORD PTR [rax], rcx

; 539  :     return ifd;

  008a9	8b 44 24 6c	 mov	 eax, DWORD PTR ifd$[rsp]

; 540  : 
; 541  : } /* end function open_input_image */

  008ad	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  008b5	48 33 cc	 xor	 rcx, rsp
  008b8	e8 00 00 00 00	 call	 __security_check_cookie
  008bd	48 81 c4 48 02
	00 00		 add	 rsp, 584		; 00000248H
  008c4	5f		 pop	 rdi
  008c5	5e		 pop	 rsi
  008c6	c3		 ret	 0
  008c7	90		 npad	 1
$LN45@open_input:
  008c8	00 00 00 00	 DD	 $LN13@open_input
  008cc	00 00 00 00	 DD	 $LN14@open_input
  008d0	00 00 00 00	 DD	 $LN15@open_input
  008d4	00 00 00 00	 DD	 $LN16@open_input
  008d8	00 00 00 00	 DD	 $LN17@open_input
  008dc	00 00 00 00	 DD	 $LN18@open_input
  008e0	00 00 00 00	 DD	 $LN29@open_input
  008e4	00 00 00 00	 DD	 $LN19@open_input
  008e8	00 00 00 00	 DD	 $LN20@open_input
  008ec	00 00 00 00	 DD	 $LN21@open_input
  008f0	00 00 00 00	 DD	 $LN22@open_input
  008f4	00 00 00 00	 DD	 $LN23@open_input
  008f8	00 00 00 00	 DD	 $LN24@open_input
  008fc	00 00 00 00	 DD	 $LN29@open_input
  00900	00 00 00 00	 DD	 $LN29@open_input
  00904	00 00 00 00	 DD	 $LN29@open_input
  00908	00 00 00 00	 DD	 $LN29@open_input
  0090c	00 00 00 00	 DD	 $LN25@open_input
  00910	00 00 00 00	 DD	 $LN26@open_input
  00914	00 00 00 00	 DD	 $LN27@open_input
  00918	00 00 00 00	 DD	 $LN28@open_input
open_input_image ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdconv.c
_TEXT	SEGMENT
klen$ = 32
dlen$ = 36
n$ = 40
hrec$ = 48
buf$ = 80
ppbuf$ = 88
plen$ = 96
pkl$ = 104
pkp$ = 112
pdl$ = 120
pdp$ = 128
pcc$ = 136
phh$ = 144
prn$ = 152
find_input_record PROC

; 289  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@find_input:

; 290  : H30CKD_RECHDR  *hrec;                   /* Input record header       */
; 291  : U16             dlen;                   /* Data length               */
; 292  : BYTE            klen;                   /* Key length                */
; 293  : int             n;                      /* Integer work area         */
; 294  : 
; 295  :     UNREFERENCED(buf);

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	75 fa		 jne	 SHORT $LN4@find_input

; 296  : 
; 297  :     /* End of track if not enough bytes remain in buffer */
; 298  :     if (*plen < H30CKD_RECHDR_SIZE) return 1;

  0001e	48 8b 44 24 60	 mov	 rax, QWORD PTR plen$[rsp]
  00023	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00026	48 83 f8 0c	 cmp	 rax, 12
  0002a	7d 0a		 jge	 SHORT $LN5@find_input
  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	e9 2a 02 00 00	 jmp	 $LN1@find_input
$LN5@find_input:

; 299  : 
; 300  :     /* Point to record header */
; 301  :     hrec = (H30CKD_RECHDR*)(*ppbuf);

  00036	48 8b 44 24 58	 mov	 rax, QWORD PTR ppbuf$[rsp]
  0003b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003e	48 89 44 24 30	 mov	 QWORD PTR hrec$[rsp], rax

; 302  : 
; 303  :     /* End of track if record header is all zero */
; 304  :     if (memcmp(*ppbuf, twelvehex00, 12) == 0) return 1;

  00043	41 b8 0c 00 00
	00		 mov	 r8d, 12
  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:twelvehex00
  00050	48 8b 44 24 58	 mov	 rax, QWORD PTR ppbuf$[rsp]
  00055	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00058	e8 00 00 00 00	 call	 memcmp
  0005d	85 c0		 test	 eax, eax
  0005f	75 0a		 jne	 SHORT $LN6@find_input
  00061	b8 01 00 00 00	 mov	 eax, 1
  00066	e9 f5 01 00 00	 jmp	 $LN1@find_input
$LN6@find_input:

; 305  : 
; 306  :     /* Extract the key length and data length */
; 307  :     klen = hrec->klen;

  0006b	48 8b 44 24 30	 mov	 rax, QWORD PTR hrec$[rsp]
  00070	0f b6 40 09	 movzx	 eax, BYTE PTR [rax+9]
  00074	88 44 24 20	 mov	 BYTE PTR klen$[rsp], al

; 308  :     FETCH_HW (dlen, hrec->dlen);

  00078	48 8b 44 24 30	 mov	 rax, QWORD PTR hrec$[rsp]
  0007d	48 83 c0 0a	 add	 rax, 10
  00081	48 8b c8	 mov	 rcx, rax
  00084	e8 00 00 00 00	 call	 fetch_hw_noswap
  00089	0f b7 c8	 movzx	 ecx, ax
  0008c	e8 00 00 00 00	 call	 _byteswap_ushort
  00091	66 89 44 24 24	 mov	 WORD PTR dlen$[rsp], ax

; 309  : 
; 310  :     /* Check that the reserved bytes are all zero */
; 311  :     if (memcmp(hrec->resv00, twelvehex00, sizeof(hrec->resv00)) != 0)

  00096	48 8b 44 24 30	 mov	 rax, QWORD PTR hrec$[rsp]
  0009b	41 b8 04 00 00
	00		 mov	 r8d, 4
  000a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:twelvehex00
  000a8	48 8b c8	 mov	 rcx, rax
  000ab	e8 00 00 00 00	 call	 memcmp
  000b0	85 c0		 test	 eax, eax
  000b2	74 0a		 je	 SHORT $LN7@find_input

; 312  :         return 2;

  000b4	b8 02 00 00 00	 mov	 eax, 2
  000b9	e9 a2 01 00 00	 jmp	 $LN1@find_input
$LN7@find_input:

; 313  : 
; 314  :     /* Check that the key and data do not overflow the buffer */
; 315  :     if (*plen < H30CKD_RECHDR_SIZE + klen + dlen)

  000be	48 8b 44 24 60	 mov	 rax, QWORD PTR plen$[rsp]
  000c3	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  000c6	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR klen$[rsp]
  000cb	0f b7 54 24 24	 movzx	 edx, WORD PTR dlen$[rsp]
  000d0	48 8d 4c 11 0c	 lea	 rcx, QWORD PTR [rcx+rdx+12]
  000d5	48 3b c1	 cmp	 rax, rcx
  000d8	7d 0a		 jge	 SHORT $LN8@find_input

; 316  :         return 3;

  000da	b8 03 00 00 00	 mov	 eax, 3
  000df	e9 7c 01 00 00	 jmp	 $LN1@find_input
$LN8@find_input:

; 317  : 
; 318  :     /* Return the cylinder, head, and record number */
; 319  :     FETCH_HW (*pcc, hrec->cyl);

  000e4	48 8b 44 24 30	 mov	 rax, QWORD PTR hrec$[rsp]
  000e9	48 83 c0 04	 add	 rax, 4
  000ed	48 8b c8	 mov	 rcx, rax
  000f0	e8 00 00 00 00	 call	 fetch_hw_noswap
  000f5	0f b7 c8	 movzx	 ecx, ax
  000f8	e8 00 00 00 00	 call	 _byteswap_ushort
  000fd	0f b7 c0	 movzx	 eax, ax
  00100	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pcc$[rsp]
  00108	89 01		 mov	 DWORD PTR [rcx], eax

; 320  :     FETCH_HW (*phh, hrec->head);

  0010a	48 8b 44 24 30	 mov	 rax, QWORD PTR hrec$[rsp]
  0010f	48 83 c0 06	 add	 rax, 6
  00113	48 8b c8	 mov	 rcx, rax
  00116	e8 00 00 00 00	 call	 fetch_hw_noswap
  0011b	0f b7 c8	 movzx	 ecx, ax
  0011e	e8 00 00 00 00	 call	 _byteswap_ushort
  00123	0f b7 c0	 movzx	 eax, ax
  00126	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR phh$[rsp]
  0012e	89 01		 mov	 DWORD PTR [rcx], eax

; 321  :     *prn = hrec->rec;

  00130	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR prn$[rsp]
  00138	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hrec$[rsp]
  0013d	0f b6 49 08	 movzx	 ecx, BYTE PTR [rcx+8]
  00141	88 08		 mov	 BYTE PTR [rax], cl

; 322  : 
; 323  :     /* Point past the record header to the key */
; 324  :     *plen -= H30CKD_RECHDR_SIZE;

  00143	48 8b 44 24 60	 mov	 rax, QWORD PTR plen$[rsp]
  00148	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  0014b	48 83 e8 0c	 sub	 rax, 12
  0014f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR plen$[rsp]
  00154	89 01		 mov	 DWORD PTR [rcx], eax

; 325  :     *ppbuf += H30CKD_RECHDR_SIZE;

  00156	48 8b 44 24 58	 mov	 rax, QWORD PTR ppbuf$[rsp]
  0015b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0015e	48 83 c0 0c	 add	 rax, 12
  00162	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ppbuf$[rsp]
  00167	48 89 01	 mov	 QWORD PTR [rcx], rax

; 326  : 
; 327  :     /* Return the key length and key pointer */
; 328  :     *pkl = klen;

  0016a	48 8b 44 24 68	 mov	 rax, QWORD PTR pkl$[rsp]
  0016f	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR klen$[rsp]
  00174	88 08		 mov	 BYTE PTR [rax], cl

; 329  :     *pkp = *ppbuf;

  00176	48 8b 44 24 70	 mov	 rax, QWORD PTR pkp$[rsp]
  0017b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ppbuf$[rsp]
  00180	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00183	48 89 08	 mov	 QWORD PTR [rax], rcx

; 330  : 
; 331  :     /* Point past the key to the data */
; 332  :     *plen -= klen;

  00186	0f b6 44 24 20	 movzx	 eax, BYTE PTR klen$[rsp]
  0018b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR plen$[rsp]
  00190	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00192	2b c8		 sub	 ecx, eax
  00194	8b c1		 mov	 eax, ecx
  00196	48 8b 4c 24 60	 mov	 rcx, QWORD PTR plen$[rsp]
  0019b	89 01		 mov	 DWORD PTR [rcx], eax

; 333  :     *ppbuf += klen;

  0019d	0f b6 44 24 20	 movzx	 eax, BYTE PTR klen$[rsp]
  001a2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ppbuf$[rsp]
  001a7	48 03 01	 add	 rax, QWORD PTR [rcx]
  001aa	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ppbuf$[rsp]
  001af	48 89 01	 mov	 QWORD PTR [rcx], rax

; 334  : 
; 335  :     /* Return the data length and data pointer */
; 336  :     *pdl = dlen;

  001b2	48 8b 44 24 78	 mov	 rax, QWORD PTR pdl$[rsp]
  001b7	0f b7 4c 24 24	 movzx	 ecx, WORD PTR dlen$[rsp]
  001bc	66 89 08	 mov	 WORD PTR [rax], cx

; 337  :     *pdp = *ppbuf;

  001bf	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pdp$[rsp]
  001c7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ppbuf$[rsp]
  001cc	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001cf	48 89 08	 mov	 QWORD PTR [rax], rcx

; 338  : 
; 339  :     /* Point past the data to the next record header */
; 340  :     *plen -= dlen;

  001d2	0f b7 44 24 24	 movzx	 eax, WORD PTR dlen$[rsp]
  001d7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR plen$[rsp]
  001dc	8b 09		 mov	 ecx, DWORD PTR [rcx]
  001de	2b c8		 sub	 ecx, eax
  001e0	8b c1		 mov	 eax, ecx
  001e2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR plen$[rsp]
  001e7	89 01		 mov	 DWORD PTR [rcx], eax

; 341  :     *ppbuf += dlen;

  001e9	0f b7 44 24 24	 movzx	 eax, WORD PTR dlen$[rsp]
  001ee	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ppbuf$[rsp]
  001f3	48 03 01	 add	 rax, QWORD PTR [rcx]
  001f6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ppbuf$[rsp]
  001fb	48 89 01	 mov	 QWORD PTR [rcx], rax

; 342  : 
; 343  :     /* Ensure next header starts on a fullword boundary */
; 344  :     if ((klen + dlen) & 3)

  001fe	0f b6 44 24 20	 movzx	 eax, BYTE PTR klen$[rsp]
  00203	0f b7 4c 24 24	 movzx	 ecx, WORD PTR dlen$[rsp]
  00208	03 c1		 add	 eax, ecx
  0020a	83 e0 03	 and	 eax, 3
  0020d	85 c0		 test	 eax, eax
  0020f	74 4d		 je	 SHORT $LN9@find_input

; 345  :     {
; 346  :         n = 4 - ((klen + dlen) % 4);

  00211	0f b6 44 24 20	 movzx	 eax, BYTE PTR klen$[rsp]
  00216	0f b7 4c 24 24	 movzx	 ecx, WORD PTR dlen$[rsp]
  0021b	03 c1		 add	 eax, ecx
  0021d	99		 cdq
  0021e	83 e2 03	 and	 edx, 3
  00221	03 c2		 add	 eax, edx
  00223	83 e0 03	 and	 eax, 3
  00226	2b c2		 sub	 eax, edx
  00228	b9 04 00 00 00	 mov	 ecx, 4
  0022d	2b c8		 sub	 ecx, eax
  0022f	8b c1		 mov	 eax, ecx
  00231	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax

; 347  :         *plen -= n;

  00235	48 8b 44 24 60	 mov	 rax, QWORD PTR plen$[rsp]
  0023a	8b 4c 24 28	 mov	 ecx, DWORD PTR n$[rsp]
  0023e	8b 00		 mov	 eax, DWORD PTR [rax]
  00240	2b c1		 sub	 eax, ecx
  00242	48 8b 4c 24 60	 mov	 rcx, QWORD PTR plen$[rsp]
  00247	89 01		 mov	 DWORD PTR [rcx], eax

; 348  :         *ppbuf += n;

  00249	48 63 44 24 28	 movsxd	 rax, DWORD PTR n$[rsp]
  0024e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ppbuf$[rsp]
  00253	48 03 01	 add	 rax, QWORD PTR [rcx]
  00256	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ppbuf$[rsp]
  0025b	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN9@find_input:

; 349  :     }
; 350  : 
; 351  :     return 0;

  0025e	33 c0		 xor	 eax, eax
$LN1@find_input:

; 352  : } /* end function find_input_record */

  00260	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00264	c3		 ret	 0
find_input_record ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdconv.c
_TEXT	SEGMENT
len$ = 80
rc$ = 84
tv76 = 88
ifd$ = 112
ifname$ = 120
buf$ = 128
reqlen$ = 136
offset$ = 144
read_input_data PROC

; 231  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 232  : int     rc;                             /* Return code               */
; 233  : int     len = 0;                        /* Number of bytes read      */

  00017	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
$LN4@read_input:

; 234  : 
; 235  :     UNREFERENCED(ifname);

  0001f	33 c0		 xor	 eax, eax
  00021	85 c0		 test	 eax, eax
  00023	75 fa		 jne	 SHORT $LN4@read_input
$LN7@read_input:

; 236  :     UNREFERENCED(offset);

  00025	33 c0		 xor	 eax, eax
  00027	85 c0		 test	 eax, eax
  00029	75 fa		 jne	 SHORT $LN7@read_input
$LN8@read_input:

; 237  :     while (len < reqlen)

  0002b	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR reqlen$[rsp]
  00032	39 44 24 50	 cmp	 DWORD PTR len$[rsp], eax
  00036	0f 8d d8 00 00
	00		 jge	 $LN9@read_input

; 238  :     {
; 239  :         rc = IFREAD (ifd, buf + len, reqlen - len);

  0003c	8b 44 24 50	 mov	 eax, DWORD PTR len$[rsp]
  00040	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR reqlen$[rsp]
  00047	2b c8		 sub	 ecx, eax
  00049	8b c1		 mov	 eax, ecx
  0004b	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR len$[rsp]
  00050	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00058	48 03 d1	 add	 rdx, rcx
  0005b	48 8b ca	 mov	 rcx, rdx
  0005e	44 8b c0	 mov	 r8d, eax
  00061	48 8b d1	 mov	 rdx, rcx
  00064	8b 4c 24 70	 mov	 ecx, DWORD PTR ifd$[rsp]
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  0006e	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax

; 240  :         if (rc == 0) break;

  00072	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  00077	75 05		 jne	 SHORT $LN10@read_input
  00079	e9 96 00 00 00	 jmp	 $LN9@read_input
$LN10@read_input:

; 241  :         if (rc < 0)

  0007e	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  00083	7d 7a		 jge	 SHORT $LN11@read_input

; 242  :         {
; 243  :             // "Error in function %s: %s"
; 244  : #if defined( HAVE_ZLIB )
; 245  :             FWRMSG( stderr, HHC02412, "E", "gzread()", strerror( errno ));
; 246  : #else
; 247  :             FWRMSG( stderr, HHC02412, "E", "read()", strerror( errno ));

  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0008b	8b 08		 mov	 ecx, DWORD PTR [rax]
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00093	48 89 44 24 58	 mov	 QWORD PTR tv76[rsp], rax
  00098	b9 02 00 00 00	 mov	 ecx, 2
  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000a3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv76[rsp]
  000a8	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168880
  000b4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168881
  000c0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168882
  000cc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000d1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d6	41 b9 03 00 00
	00		 mov	 r9d, 3
  000dc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168883
  000e3	ba f7 00 00 00	 mov	 edx, 247		; 000000f7H
  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168884
  000ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 248  : #endif
; 249  :             EXIT(3);

  000f5	b9 03 00 00 00	 mov	 ecx, 3
  000fa	e8 00 00 00 00	 call	 delayed_exit
$LN11@read_input:

; 250  :         }
; 251  :         len += rc;

  000ff	8b 44 24 54	 mov	 eax, DWORD PTR rc$[rsp]
  00103	8b 4c 24 50	 mov	 ecx, DWORD PTR len$[rsp]
  00107	03 c8		 add	 ecx, eax
  00109	8b c1		 mov	 eax, ecx
  0010b	89 44 24 50	 mov	 DWORD PTR len$[rsp], eax

; 252  :     } /* end while */

  0010f	e9 17 ff ff ff	 jmp	 $LN8@read_input
$LN9@read_input:

; 253  : 
; 254  :     if (len < reqlen)

  00114	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR reqlen$[rsp]
  0011b	39 44 24 50	 cmp	 DWORD PTR len$[rsp], eax
  0011f	7d 69		 jge	 SHORT $LN12@read_input

; 255  :     {
; 256  :         // "Error in function %s: %s"
; 257  : #if defined( HAVE_ZLIB )
; 258  :         FWRMSG( stderr, HHC02412, "E", "gzread()", "unexpected end of file" );
; 259  : #else
; 260  :         FWRMSG( stderr, HHC02412, "E", "read()", "unexpected end of file" );

  00121	b9 02 00 00 00	 mov	 ecx, 2
  00126	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0012c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168886
  00133	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00138	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168887
  0013f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00144	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168888
  0014b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00150	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168889
  00157	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0015c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00161	41 b9 03 00 00
	00		 mov	 r9d, 3
  00167	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168890
  0016e	ba 04 01 00 00	 mov	 edx, 260		; 00000104H
  00173	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168891
  0017a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 261  : #endif
; 262  :         EXIT(3);

  00180	b9 03 00 00 00	 mov	 ecx, 3
  00185	e8 00 00 00 00	 call	 delayed_exit
$LN12@read_input:

; 263  :     }
; 264  : 
; 265  : } /* end function read_input_data */

  0018a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0018e	c3		 ret	 0
read_input_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdconv.c
_TEXT	SEGMENT
code$ = 96
pgm$ = 104
argexit	PROC

; 208  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 209  :     // "Usage: %s ...
; 210  :     if (sizeof(off_t) > 4)

  0000d	33 c0		 xor	 eax, eax
  0000f	83 f8 01	 cmp	 eax, 1
  00012	74 5f		 je	 SHORT $LN2@argexit

; 211  :         WRMSG( HHC02410, "I", pgm,

  00014	b9 01 00 00 00	 mov	 ecx, 1
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168847
  00026	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0002b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pgm$[rsp]
  00030	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168848
  0003c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168849
  00048	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0004d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00052	41 b9 03 00 00
	00		 mov	 r9d, 3
  00058	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168850
  0005f	ba d4 00 00 00	 mov	 edx, 212		; 000000d4H
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168851
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  00071	eb 5d		 jmp	 SHORT $LN3@argexit
$LN2@argexit:

; 212  :                 "\nHHC02410I   -lfs   build one large output file" );
; 213  :     else
; 214  :         WRMSG( HHC02410, "I", pgm, "" );

  00073	b9 01 00 00 00	 mov	 ecx, 1
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168852
  00085	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0008a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pgm$[rsp]
  0008f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168853
  0009b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168854
  000a7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ac	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b1	41 b9 03 00 00
	00		 mov	 r9d, 3
  000b7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168855
  000be	ba d6 00 00 00	 mov	 edx, 214		; 000000d6H
  000c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168856
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN3@argexit:

; 215  : 
; 216  :     EXIT(code);

  000d0	8b 4c 24 60	 mov	 ecx, DWORD PTR code$[rsp]
  000d4	e8 00 00 00 00	 call	 delayed_exit

; 217  : } /* end function argexit */

  000d9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000dd	c3		 ret	 0
argexit	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdconv.c
_TEXT	SEGMENT
exit_code$ = 48
delayed_exit PROC

; 195  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 196  :     /* Delay exiting is to give the system
; 197  :      * time to display the error message. */
; 198  :     usleep(100000);

  00008	b9 a0 86 01 00	 mov	 ecx, 100000		; 000186a0H
  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 199  :     exit(exit_code);

  00013	8b 4c 24 30	 mov	 ecx, DWORD PTR exit_code$[rsp]
  00017	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN2@delayed_ex:

; 200  : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
delayed_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
END
