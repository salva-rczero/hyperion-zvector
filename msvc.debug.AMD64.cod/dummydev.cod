; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	dummy_kw:DWORD
_DATA	ENDS
_DATA	SEGMENT
dummydev_immed_command DB 00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
$SG159064 DB	'foo', 00H
$SG159065 DB	'%79s', 00H
	ORG $+3
$SG159066 DB	'bar', 00H
$SG159067 DB	'%79s', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	hdl_check_depends_ep
PUBLIC	hdl_define_devtypes_ep
EXTRN	__report_rangecheckfailure:PROC
EXTRN	strcmp:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_basename:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_parser:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__security_cookie:QWORD
pdata	SEGMENT
$pdata$dummydev_init_handler DD imagerel dummydev_init_handler
	DD	imagerel dummydev_init_handler+800
	DD	imagerel $unwind$dummydev_init_handler
$pdata$dummydev_query_device DD imagerel dummydev_query_device
	DD	imagerel dummydev_query_device+350
	DD	imagerel $unwind$dummydev_query_device
$pdata$dummydev_close_device DD imagerel dummydev_close_device
	DD	imagerel dummydev_close_device+47
	DD	imagerel $unwind$dummydev_close_device
$pdata$dummydev_execute_ccw DD imagerel dummydev_execute_ccw
	DD	imagerel dummydev_execute_ccw+501
	DD	imagerel $unwind$dummydev_execute_ccw
$pdata$hdl_check_depends_ep DD imagerel $LN15
	DD	imagerel $LN15+152
	DD	imagerel $unwind$hdl_check_depends_ep
$pdata$hdl_define_devtypes_ep DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$hdl_define_devtypes_ep
pdata	ENDS
_DATA	SEGMENT
	ORG $+3
ptab	DQ	FLAT:$SG159064
	DQ	FLAT:$SG159065
	DQ	FLAT:$SG159066
	DQ	FLAT:$SG159067
	DQ	0000000000000000H
	DQ	0000000000000000H
$SG159098 DB	'E', 00H
	ORG $+2
$SG159103 DB	'E', 00H
	ORG $+2
$SG159099 DB	'HHC01012%s %1d:%04X COMM: error parsing %s', 0aH, 00H
$SG159127 DB	'.', 00H
	ORG $+2
$SG159100 DB	'dummydev_init_handler', 00H
	ORG $+2
$SG159101 DB	'dummydev.c', 00H
	ORG $+1
$SG159129 DB	'%s', 00H
	ORG $+1
$SG159104 DB	'HHC01012%s %1d:%04X COMM: error parsing %s', 0aH, 00H
	ORG $+4
$SG159105 DB	'dummydev_init_handler', 00H
	ORG $+2
$SG159106 DB	'dummydev.c', 00H
	ORG $+1
$SG159121 DB	'DUMB', 00H
	ORG $+7
$SG159128 DB	'DUMMY DEVICE', 00H
	ORG $+3
$SG159227 DB	'DEVBLK', 00H
	ORG $+1
dummydev_device_hndinfo DQ FLAT:dummydev_init_handler
	DQ	FLAT:dummydev_execute_ccw
	DQ	FLAT:dummydev_close_device
	DQ	FLAT:dummydev_query_device
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:dummydev_halt_or_clear
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:dummydev_immed_command
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
$SG159223 DB	'SDL 4.60', 00H
	ORG $+7
$SG159224 DB	'HERCULES', 00H
	ORG $+7
$SG159226 DB	'SDL 4.00', 00H
	ORG $+7
$SG159229 DB	'SDL 4.2', 00H
$SG159230 DB	'SYSBLK', 00H
	ORG $+1
$SG159235 DB	'dummy', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:dummydev_query_device
	DD	025H
	DD	0146H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:dummydev_init_handler
	DD	01fH
	DD	0308H
voltbl	ENDS
xdata	SEGMENT
$unwind$dummydev_init_handler DD 022719H
	DD	01d0115H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$dummydev_query_device DD 022d19H
	DD	02b011bH
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$dummydev_close_device DD 010901H
	DD	04209H
$unwind$dummydev_execute_ccw DD 031901H
	DD	070152219H
	DD	06014H
$unwind$hdl_check_depends_ep DD 010901H
	DD	06209H
$unwind$hdl_define_devtypes_ep DD 010901H
	DD	04209H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dummydev.c
_TEXT	SEGMENT
defdev$ = 48
hdl_define_devtypes_ep PROC

; 375  : HDL_DEVICE_SECTION;

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 376  : {
; 377  :     HDL_DEVICE(dummy, dummydev_device_hndinfo );

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:dummydev_device_hndinfo
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159235
  00017	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 378  : }
; 379  : END_DEVICE_SECTION

  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
hdl_define_devtypes_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dummydev.c
_TEXT	SEGMENT
depchk_rc$ = 32
depchk$ = 64
hdl_check_depends_ep PROC

; 367  : HDL_DEPENDENCY_SECTION;

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 0
$LN4@hdl_check_:

; 368  : {
; 369  :      HDL_DEPENDENCY(HERCULES);

  00011	41 b8 08 00 00
	00		 mov	 r8d, 8
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159223
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159224
  00025	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  00029	85 c0		 test	 eax, eax
  0002b	74 08		 je	 SHORT $LN11@hdl_check_
  0002d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN11@hdl_check_:
  00035	33 c0		 xor	 eax, eax
  00037	85 c0		 test	 eax, eax
  00039	75 d6		 jne	 SHORT $LN4@hdl_check_
$LN7@hdl_check_:

; 370  :      HDL_DEPENDENCY(DEVBLK);

  0003b	41 b8 a0 1b 00
	00		 mov	 r8d, 7072		; 00001ba0H
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159226
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159227
  0004f	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  00053	85 c0		 test	 eax, eax
  00055	74 08		 je	 SHORT $LN12@hdl_check_
  00057	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN12@hdl_check_:
  0005f	33 c0		 xor	 eax, eax
  00061	85 c0		 test	 eax, eax
  00063	75 d6		 jne	 SHORT $LN7@hdl_check_
$LN10@hdl_check_:

; 371  :      HDL_DEPENDENCY(SYSBLK);

  00065	41 b8 00 76 01
	00		 mov	 r8d, 95744		; 00017600H
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159229
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159230
  00079	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  0007d	85 c0		 test	 eax, eax
  0007f	74 08		 je	 SHORT $LN13@hdl_check_
  00081	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN13@hdl_check_:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d6		 jne	 SHORT $LN10@hdl_check_

; 372  : }
; 373  : END_DEPENDENCY_SECTION

  0008f	8b 44 24 20	 mov	 eax, DWORD PTR depchk_rc$[rsp]
  00093	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00097	c3		 ret	 0
hdl_check_depends_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dummydev.c
_TEXT	SEGMENT
tv69 = 0
num$ = 4
tv72 = 8
dev$ = 48
code$ = 56
flags$ = 64
chained$ = 72
count$ = 80
prevcode$ = 88
ccwseq$ = 96
iobuf$ = 104
more$ = 112
unitstat$ = 120
residual$ = 128
dummydev_execute_ccw PROC

; 243  : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 18	 sub	 rsp, 24
$LN4@dummydev_e:

; 244  :     int num;
; 245  : 
; 246  :     UNREFERENCED( flags );

  00019	33 c0		 xor	 eax, eax
  0001b	85 c0		 test	 eax, eax
  0001d	75 fa		 jne	 SHORT $LN4@dummydev_e
$LN7@dummydev_e:

; 247  :     UNREFERENCED( chained );

  0001f	33 c0		 xor	 eax, eax
  00021	85 c0		 test	 eax, eax
  00023	75 fa		 jne	 SHORT $LN7@dummydev_e
$LN10@dummydev_e:

; 248  :     UNREFERENCED( prevcode );

  00025	33 c0		 xor	 eax, eax
  00027	85 c0		 test	 eax, eax
  00029	75 fa		 jne	 SHORT $LN10@dummydev_e
$LN13@dummydev_e:

; 249  :     UNREFERENCED( ccwseq );

  0002b	33 c0		 xor	 eax, eax
  0002d	85 c0		 test	 eax, eax
  0002f	75 fa		 jne	 SHORT $LN13@dummydev_e

; 250  : 
; 251  :     switch(code)

  00031	0f b6 44 24 38	 movzx	 eax, BYTE PTR code$[rsp]
  00036	88 04 24	 mov	 BYTE PTR tv69[rsp], al
  00039	80 3c 24 01	 cmp	 BYTE PTR tv69[rsp], 1
  0003d	74 21		 je	 SHORT $LN16@dummydev_e
  0003f	80 3c 24 02	 cmp	 BYTE PTR tv69[rsp], 2
  00043	74 36		 je	 SHORT $LN17@dummydev_e
  00045	80 3c 24 03	 cmp	 BYTE PTR tv69[rsp], 3
  00049	74 62		 je	 SHORT $LN18@dummydev_e
  0004b	80 3c 24 04	 cmp	 BYTE PTR tv69[rsp], 4
  0004f	74 77		 je	 SHORT $LN19@dummydev_e
  00051	80 3c 24 e4	 cmp	 BYTE PTR tv69[rsp], 228	; 000000e4H
  00055	0f 84 07 01 00
	00		 je	 $LN22@dummydev_e
  0005b	e9 61 01 00 00	 jmp	 $LN24@dummydev_e
$LN16@dummydev_e:

; 252  :     {
; 253  :         case 0x01:
; 254  :             /* That's a basic write */
; 255  :             /* Here let's say we gobble everything */
; 256  :             *residual=0;

  00060	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  00068	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 257  :             *unitstat=CSW_CE|CSW_DE;

  0006e	48 8b 44 24 78	 mov	 rax, QWORD PTR unitstat$[rsp]
  00073	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 258  :             break;

  00076	e9 73 01 00 00	 jmp	 $LN14@dummydev_e
$LN17@dummydev_e:

; 259  :         case 0x02:
; 260  :             /* That's a basic read.. also works for IPLs */
; 261  :             /* Let's just send back something stupid here */
; 262  :             memset(iobuf,0,count);

  0007b	8b 44 24 50	 mov	 eax, DWORD PTR count$[rsp]
  0007f	48 89 44 24 08	 mov	 QWORD PTR tv72[rsp], rax
  00084	48 8b 7c 24 68	 mov	 rdi, QWORD PTR iobuf$[rsp]
  00089	33 c0		 xor	 eax, eax
  0008b	48 8b 4c 24 08	 mov	 rcx, QWORD PTR tv72[rsp]
  00090	f3 aa		 rep stosb

; 263  :             *residual=0;

  00092	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  0009a	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 264  :             *unitstat=CSW_CE|CSW_DE;

  000a0	48 8b 44 24 78	 mov	 rax, QWORD PTR unitstat$[rsp]
  000a5	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 265  :             break;

  000a8	e9 41 01 00 00	 jmp	 $LN14@dummydev_e
$LN18@dummydev_e:

; 266  :         case 0x03:
; 267  :             /* 0x03 is NO-OP and is by definition an immediate */
; 268  :             /* command so iobuf, count are void */
; 269  :             *residual=count;

  000ad	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  000b5	8b 4c 24 50	 mov	 ecx, DWORD PTR count$[rsp]
  000b9	89 08		 mov	 DWORD PTR [rax], ecx

; 270  :             *unitstat=CSW_CE|CSW_DE;

  000bb	48 8b 44 24 78	 mov	 rax, QWORD PTR unitstat$[rsp]
  000c0	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 271  :             break;

  000c3	e9 26 01 00 00	 jmp	 $LN14@dummydev_e
$LN19@dummydev_e:

; 272  :             /* PS : If you wish that the device NOT be
; 273  :                ready for any reason you see fit, only indicate
; 274  :                CSW_UC (NO CE/DE here) and put SENSE_IR in the
; 275  :                sense field
; 276  :                 something like :
; 277  :                 *unitstat=CSW_UC;
; 278  :                 dev->sense[0]=SENSE_IR;
; 279  :             */
; 280  :         case 0x04:
; 281  :             /* Basic sense... we can do this */
; 282  :             /* this is filled by any previous */
; 283  :             /* command */
; 284  :             if(dev->numsense>count)

  000c8	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  000cd	8b 4c 24 50	 mov	 ecx, DWORD PTR count$[rsp]
  000d1	39 88 60 03 00
	00		 cmp	 DWORD PTR [rax+864], ecx
  000d7	76 34		 jbe	 SHORT $LN20@dummydev_e

; 285  :             {
; 286  :                 *more=1;

  000d9	48 8b 44 24 70	 mov	 rax, QWORD PTR more$[rsp]
  000de	c6 00 01	 mov	 BYTE PTR [rax], 1

; 287  :                 memcpy(iobuf,dev->sense,count);

  000e1	8b 44 24 50	 mov	 eax, DWORD PTR count$[rsp]
  000e5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  000ea	48 81 c1 64 03
	00 00		 add	 rcx, 868		; 00000364H
  000f1	48 8b 7c 24 68	 mov	 rdi, QWORD PTR iobuf$[rsp]
  000f6	48 8b f1	 mov	 rsi, rcx
  000f9	8b c8		 mov	 ecx, eax
  000fb	f3 a4		 rep movsb

; 288  :                 *residual=0;

  000fd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  00105	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 289  :                 /* Not sure how a sense works on a short read */
; 290  :             }

  0010b	eb 48		 jmp	 SHORT $LN21@dummydev_e
$LN20@dummydev_e:

; 291  :             else
; 292  :             {
; 293  :                 /* sense fits in the IO buffer */
; 294  :                 *more=0;

  0010d	48 8b 44 24 70	 mov	 rax, QWORD PTR more$[rsp]
  00112	c6 00 00	 mov	 BYTE PTR [rax], 0

; 295  :                 memcpy(iobuf,dev->sense,dev->numsense);

  00115	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0011a	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  00120	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00125	48 81 c1 64 03
	00 00		 add	 rcx, 868		; 00000364H
  0012c	48 8b 7c 24 68	 mov	 rdi, QWORD PTR iobuf$[rsp]
  00131	48 8b f1	 mov	 rsi, rcx
  00134	8b c8		 mov	 ecx, eax
  00136	f3 a4		 rep movsb

; 296  :                 *residual=count-dev->numsense;

  00138	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0013d	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  00143	8b 4c 24 50	 mov	 ecx, DWORD PTR count$[rsp]
  00147	2b c8		 sub	 ecx, eax
  00149	8b c1		 mov	 eax, ecx
  0014b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00153	89 01		 mov	 DWORD PTR [rcx], eax
$LN21@dummydev_e:

; 297  :             }
; 298  :             *unitstat=CSW_CE|CSW_DE;

  00155	48 8b 44 24 78	 mov	 rax, QWORD PTR unitstat$[rsp]
  0015a	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 299  :             break;

  0015d	e9 8c 00 00 00	 jmp	 $LN14@dummydev_e
$LN22@dummydev_e:

; 300  :         case 0xe4:
; 301  :             /* Sense ID (device type) */
; 302  :             num=(int)dev->numdevid;

  00162	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00167	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  0016d	89 44 24 04	 mov	 DWORD PTR num$[rsp], eax

; 303  :             if((int)count<num)

  00171	8b 44 24 04	 mov	 eax, DWORD PTR num$[rsp]
  00175	39 44 24 50	 cmp	 DWORD PTR count$[rsp], eax
  00179	7d 08		 jge	 SHORT $LN23@dummydev_e

; 304  :             {
; 305  :                 num=(int)count;

  0017b	8b 44 24 50	 mov	 eax, DWORD PTR count$[rsp]
  0017f	89 44 24 04	 mov	 DWORD PTR num$[rsp], eax
$LN23@dummydev_e:

; 306  :             }
; 307  :             memcpy(iobuf,dev->devid,num);

  00183	48 63 44 24 04	 movsxd	 rax, DWORD PTR num$[rsp]
  00188	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0018d	48 81 c1 68 04
	00 00		 add	 rcx, 1128		; 00000468H
  00194	48 8b 7c 24 68	 mov	 rdi, QWORD PTR iobuf$[rsp]
  00199	48 8b f1	 mov	 rsi, rcx
  0019c	48 8b c8	 mov	 rcx, rax
  0019f	f3 a4		 rep movsb

; 308  :             *residual=count-num;

  001a1	8b 44 24 04	 mov	 eax, DWORD PTR num$[rsp]
  001a5	8b 4c 24 50	 mov	 ecx, DWORD PTR count$[rsp]
  001a9	2b c8		 sub	 ecx, eax
  001ab	8b c1		 mov	 eax, ecx
  001ad	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  001b5	89 01		 mov	 DWORD PTR [rcx], eax

; 309  :             *unitstat=CSW_CE|CSW_DE;

  001b7	48 8b 44 24 78	 mov	 rax, QWORD PTR unitstat$[rsp]
  001bc	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 310  :             break;

  001bf	eb 2d		 jmp	 SHORT $LN14@dummydev_e
$LN24@dummydev_e:

; 311  :         default:
; 312  :             /* We didn't understand.. so Command Reject */
; 313  :             *unitstat=CSW_UC;

  001c1	48 8b 44 24 78	 mov	 rax, QWORD PTR unitstat$[rsp]
  001c6	c6 00 02	 mov	 BYTE PTR [rax], 2

; 314  :             dev->sense[0]=SENSE_CR;

  001c9	b8 01 00 00 00	 mov	 eax, 1
  001ce	48 6b c0 00	 imul	 rax, rax, 0
  001d2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  001d7	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 315  :             dev->numsense=1;

  001df	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  001e4	c7 80 60 03 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+864], 1
$LN14@dummydev_e:

; 316  :             break;
; 317  :     }
; 318  : }

  001ee	48 83 c4 18	 add	 rsp, 24
  001f2	5f		 pop	 rdi
  001f3	5e		 pop	 rsi
  001f4	c3		 ret	 0
dummydev_execute_ccw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dummydev.c
_TEXT	SEGMENT
dev$ = 48
dummydev_close_device PROC

; 200  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 201  :     /* Terminate current I/O thread if necessary */
; 202  :     if (dev->busy)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00014	c1 e8 13	 shr	 eax, 19
  00017	83 e0 01	 and	 eax, 1
  0001a	85 c0		 test	 eax, eax
  0001c	74 0a		 je	 SHORT $LN2@dummydev_c

; 203  :         dummydev_halt_or_clear( dev );

  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00023	e8 00 00 00 00	 call	 dummydev_halt_or_clear
$LN2@dummydev_c:

; 204  : 
; 205  :     /* Perform more termination if needed - signal thread(s) to close
; 206  :        and whatnot
; 207  :     */
; 208  :     return 0;

  00028	33 c0		 xor	 eax, eax

; 209  : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
dummydev_close_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dummydev.c
_TEXT	SEGMENT
$T1 = 32
filename$ = 48
__$ArrayPad$ = 320
dev$ = 352
devclass$ = 360
buflen$ = 368
buffer$ = 376
dummydev_query_device PROC

; 183  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 184  :     /* This is required by the BEGIN_DEVICE_CLASS_QUERY macro.. UGLY !! */
; 185  :     char filename[ PATH_MAX + 1 ];      /* full path or just name    */
; 186  : 
; 187  :     /* This is to make it look pretty */
; 188  :     BEGIN_DEVICE_CLASS_QUERY( "DUMB", dev, devclass, buflen, buffer );

  0002d	48 83 bc 24 68
	01 00 00 00	 cmp	 QWORD PTR devclass$[rsp], 0
  00036	74 12		 je	 SHORT $LN2@dummydev_q
  00038	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR devclass$[rsp]
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159121
  00047	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN2@dummydev_q:
  0004a	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00053	74 20		 je	 SHORT $LN4@dummydev_q
  00055	48 83 bc 24 68
	01 00 00 00	 cmp	 QWORD PTR devclass$[rsp], 0
  0005e	74 15		 je	 SHORT $LN4@dummydev_q
  00060	83 bc 24 70 01
	00 00 00	 cmp	 DWORD PTR buflen$[rsp], 0
  00068	74 0b		 je	 SHORT $LN4@dummydev_q
  0006a	48 83 bc 24 78
	01 00 00 00	 cmp	 QWORD PTR buffer$[rsp], 0
  00073	75 05		 jne	 SHORT $LN3@dummydev_q
$LN4@dummydev_q:
  00075	e9 cc 00 00 00	 jmp	 $LN1@dummydev_q
$LN3@dummydev_q:
  0007a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00081	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00087	c1 e8 1a	 shr	 eax, 26
  0008a	83 e0 01	 and	 eax, 1
  0008d	85 c0		 test	 eax, eax
  0008f	74 6c		 je	 SHORT $LN5@dummydev_q
  00091	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00099	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_basename
  000a8	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  000ae	48 8b d0	 mov	 rdx, rax
  000b1	48 8d 4c 24 30	 lea	 rcx, QWORD PTR filename$[rsp]
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159127
  000c3	48 8d 4c 24 30	 lea	 rcx, QWORD PTR filename$[rsp]
  000c8	e8 00 00 00 00	 call	 strcmp
  000cd	85 c0		 test	 eax, eax
  000cf	75 2a		 jne	 SHORT $LN7@dummydev_q
  000d1	b8 01 00 00 00	 mov	 eax, 1
  000d6	48 6b c0 00	 imul	 rax, rax, 0
  000da	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  000df	48 81 7c 24 20
	05 01 00 00	 cmp	 QWORD PTR $T1[rsp], 261	; 00000105H
  000e8	73 02		 jae	 SHORT $LN9@dummydev_q
  000ea	eb 05		 jmp	 SHORT $LN10@dummydev_q
$LN9@dummydev_q:
  000ec	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN10@dummydev_q:
  000f1	48 8b 44 24 20	 mov	 rax, QWORD PTR $T1[rsp]
  000f6	c6 44 04 30 00	 mov	 BYTE PTR filename$[rsp+rax], 0
$LN7@dummydev_q:
  000fb	eb 22		 jmp	 SHORT $LN6@dummydev_q
$LN5@dummydev_q:
  000fd	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00105	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0010b	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  00111	48 8b d0	 mov	 rdx, rax
  00114	48 8d 4c 24 30	 lea	 rcx, QWORD PTR filename$[rsp]
  00119	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN6@dummydev_q:

; 189  : 
; 190  :     /* and then some device specifiic stuff */
; 191  : 
; 192  :     snprintf(buffer,buflen,"%s","DUMMY DEVICE");

  0011f	48 63 84 24 70
	01 00 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  00127	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159128
  0012e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159129
  00135	48 8b d0	 mov	 rdx, rax
  00138	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  00140	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN1@dummydev_q:
$LN8@dummydev_q:

; 193  : }

  00146	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0014e	48 33 cc	 xor	 rcx, rsp
  00151	e8 00 00 00 00	 call	 __security_check_cookie
  00156	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  0015d	c3		 ret	 0
dummydev_query_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dummydev.c
_TEXT	SEGMENT
i$ = 80
errcnt$ = 84
pc$ = 88
tv81 = 92
tv87 = 96
tv139 = 100
tv145 = 104
tv157 = 108
tv74 = 112
tv132 = 120
res$ = 128
__$ArrayPad$ = 208
dev$ = 240
argc$ = 248
argv$ = 256
dummydev_init_handler PROC

; 126  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 127  :     int     i,pc;
; 128  :     int     errcnt=0;

  00027	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR errcnt$[rsp], 0

; 129  :     union   { int num; char text[MAX_PARSER_STRLEN+1];  /* (+1 for null terminator) */ } res;
; 130  : 
; 131  :     /*
; 132  :      Initialise stuff such as
; 133  :      Allocate private structures, buffers, set up default values, etc..
; 134  :     */
; 135  : 
; 136  :     for(i=0;i<argc;i++)

  0002f	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00037	eb 0a		 jmp	 SHORT $LN4@dummydev_i
$LN2@dummydev_i:
  00039	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  0003d	ff c0		 inc	 eax
  0003f	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN4@dummydev_i:
  00043	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  0004a	39 44 24 50	 cmp	 DWORD PTR i$[rsp], eax
  0004e	0f 8d f1 01 00
	00		 jge	 $LN3@dummydev_i

; 137  :     {
; 138  :         pc=parser(ptab,argv[i],&res);

  00054	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00059	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR res$[rsp]
  00061	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00069	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ptab
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_parser
  0007a	89 44 24 58	 mov	 DWORD PTR pc$[rsp], eax

; 139  :         if(pc<0)

  0007e	83 7c 24 58 00	 cmp	 DWORD PTR pc$[rsp], 0
  00083	0f 8d d2 00 00
	00		 jge	 $LN7@dummydev_i

; 140  :         {
; 141  :             WRMSG(HHC01012, "E",LCSS_DEVNUM,argv[i]);

  00089	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00092	74 12		 je	 SHORT $LN11@dummydev_i
  00094	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0009c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000a0	89 44 24 5c	 mov	 DWORD PTR tv81[rsp], eax
  000a4	eb 08		 jmp	 SHORT $LN12@dummydev_i
$LN11@dummydev_i:
  000a6	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN12@dummydev_i:
  000ae	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000b7	74 14		 je	 SHORT $LN13@dummydev_i
  000b9	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000c1	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000c5	d1 f8		 sar	 eax, 1
  000c7	89 44 24 60	 mov	 DWORD PTR tv87[rsp], eax
  000cb	eb 08		 jmp	 SHORT $LN14@dummydev_i
$LN13@dummydev_i:
  000cd	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
$LN14@dummydev_i:
  000d5	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  000da	48 89 44 24 70	 mov	 QWORD PTR tv74[rsp], rax
  000df	b9 01 00 00 00	 mov	 ecx, 1
  000e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000ea	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000f2	48 8b 54 24 70	 mov	 rdx, QWORD PTR tv74[rsp]
  000f7	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  000fb	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00100	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv81[rsp]
  00104	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00108	8b 4c 24 60	 mov	 ecx, DWORD PTR tv87[rsp]
  0010c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00110	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159098
  00117	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0011c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159099
  00123	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00128	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0012d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00133	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159100
  0013a	ba 8d 00 00 00	 mov	 edx, 141		; 0000008dH
  0013f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159101
  00146	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 142  :             errcnt++;

  0014c	8b 44 24 54	 mov	 eax, DWORD PTR errcnt$[rsp]
  00150	ff c0		 inc	 eax
  00152	89 44 24 54	 mov	 DWORD PTR errcnt$[rsp], eax

; 143  :             continue;

  00156	e9 de fe ff ff	 jmp	 $LN2@dummydev_i
$LN7@dummydev_i:

; 144  :         }
; 145  :         if(pc==0)

  0015b	83 7c 24 58 00	 cmp	 DWORD PTR pc$[rsp], 0
  00160	0f 85 d2 00 00
	00		 jne	 $LN8@dummydev_i

; 146  :         {
; 147  :             WRMSG(HHC01012, "E",LCSS_DEVNUM,argv[i]);

  00166	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0016f	74 12		 je	 SHORT $LN15@dummydev_i
  00171	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00179	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0017d	89 44 24 64	 mov	 DWORD PTR tv139[rsp], eax
  00181	eb 08		 jmp	 SHORT $LN16@dummydev_i
$LN15@dummydev_i:
  00183	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv139[rsp], 0
$LN16@dummydev_i:
  0018b	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00194	74 14		 je	 SHORT $LN17@dummydev_i
  00196	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0019e	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001a2	d1 f8		 sar	 eax, 1
  001a4	89 44 24 68	 mov	 DWORD PTR tv145[rsp], eax
  001a8	eb 08		 jmp	 SHORT $LN18@dummydev_i
$LN17@dummydev_i:
  001aa	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN18@dummydev_i:
  001b2	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  001b7	48 89 44 24 78	 mov	 QWORD PTR tv132[rsp], rax
  001bc	b9 01 00 00 00	 mov	 ecx, 1
  001c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001c7	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001cf	48 8b 54 24 78	 mov	 rdx, QWORD PTR tv132[rsp]
  001d4	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  001d8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001dd	8b 4c 24 64	 mov	 ecx, DWORD PTR tv139[rsp]
  001e1	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001e5	8b 4c 24 68	 mov	 ecx, DWORD PTR tv145[rsp]
  001e9	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159103
  001f4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159104
  00200	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00205	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0020a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00210	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159105
  00217	ba 93 00 00 00	 mov	 edx, 147		; 00000093H
  0021c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159106
  00223	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 148  :             errcnt++;

  00229	8b 44 24 54	 mov	 eax, DWORD PTR errcnt$[rsp]
  0022d	ff c0		 inc	 eax
  0022f	89 44 24 54	 mov	 DWORD PTR errcnt$[rsp], eax

; 149  :             continue;

  00233	e9 01 fe ff ff	 jmp	 $LN2@dummydev_i
$LN8@dummydev_i:

; 150  :         }
; 151  :         switch(pc)

  00238	8b 44 24 58	 mov	 eax, DWORD PTR pc$[rsp]
  0023c	89 44 24 6c	 mov	 DWORD PTR tv157[rsp], eax

; 152  :         {
; 153  :             default:
; 154  :                 break;
; 155  :         }
; 156  :     }

  00240	e9 f4 fd ff ff	 jmp	 $LN2@dummydev_i
$LN3@dummydev_i:

; 157  :     /*
; 158  :      * Check parameters consistency
; 159  :     */
; 160  :     /*
; 161  :      Set the sense ID */
; 162  :     dev->numdevid=7;

  00245	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0024d	c7 80 64 04 00
	00 07 00 00 00	 mov	 DWORD PTR [rax+1124], 7

; 163  :     dev->devid[0]=0xff;

  00257	b8 01 00 00 00	 mov	 eax, 1
  0025c	48 6b c0 00	 imul	 rax, rax, 0
  00260	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00268	c6 84 01 68 04
	00 00 ff	 mov	 BYTE PTR [rcx+rax+1128], 255 ; 000000ffH

; 164  :     dev->devid[1]=0x30;

  00270	b8 01 00 00 00	 mov	 eax, 1
  00275	48 6b c0 01	 imul	 rax, rax, 1
  00279	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00281	c6 84 01 68 04
	00 00 30	 mov	 BYTE PTR [rcx+rax+1128], 48 ; 00000030H

; 165  :     dev->devid[2]=0x88;

  00289	b8 01 00 00 00	 mov	 eax, 1
  0028e	48 6b c0 02	 imul	 rax, rax, 2
  00292	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0029a	c6 84 01 68 04
	00 00 88	 mov	 BYTE PTR [rcx+rax+1128], 136 ; 00000088H

; 166  :     dev->devid[3]=0x01;

  002a2	b8 01 00 00 00	 mov	 eax, 1
  002a7	48 6b c0 03	 imul	 rax, rax, 3
  002ab	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002b3	c6 84 01 68 04
	00 00 01	 mov	 BYTE PTR [rcx+rax+1128], 1

; 167  :     dev->devid[4]=0x30;

  002bb	b8 01 00 00 00	 mov	 eax, 1
  002c0	48 6b c0 04	 imul	 rax, rax, 4
  002c4	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002cc	c6 84 01 68 04
	00 00 30	 mov	 BYTE PTR [rcx+rax+1128], 48 ; 00000030H

; 168  :     dev->devid[5]=0x88;

  002d4	b8 01 00 00 00	 mov	 eax, 1
  002d9	48 6b c0 05	 imul	 rax, rax, 5
  002dd	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002e5	c6 84 01 68 04
	00 00 88	 mov	 BYTE PTR [rcx+rax+1128], 136 ; 00000088H

; 169  :     dev->devid[6]=0x01;

  002ed	b8 01 00 00 00	 mov	 eax, 1
  002f2	48 6b c0 06	 imul	 rax, rax, 6
  002f6	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002fe	c6 84 01 68 04
	00 00 01	 mov	 BYTE PTR [rcx+rax+1128], 1

; 170  :     /*
; 171  :      Init device private information
; 172  :      here base on parameters given
; 173  :      return -1 if this is not consistent */
; 174  :     return 0;

  00306	33 c0		 xor	 eax, eax

; 175  : }

  00308	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00310	48 33 cc	 xor	 rcx, rsp
  00313	e8 00 00 00 00	 call	 __security_check_cookie
  00318	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  0031f	c3		 ret	 0
dummydev_init_handler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dummydev.c
_TEXT	SEGMENT
dev$ = 8
dummydev_halt_or_clear PROC

; 103  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 104  :     /* The lock on the DEVBLK is held... don't touch it..
; 105  :        do NOT reset the dev->busy flag if it is set
; 106  :        if dev->busy is not set then there is nothing else to do */
; 107  :     if (dev->busy)

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR dev$[rsp]
  0000a	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00010	c1 e8 13	 shr	 eax, 19
  00013	83 e0 01	 and	 eax, 1

; 108  :     {
; 109  :         /* Perform any action necessary to terminate
; 110  :            any ongoing I/O in progress. Only return
; 111  :            when it is sure the I/O was terminated */
; 112  :     }
; 113  : }

  00016	c3		 ret	 0
dummydev_halt_or_clear ENDP
_TEXT	ENDS
END
