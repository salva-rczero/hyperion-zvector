; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	g_nDictSize
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
g_nDictSize DD	01000H
	DD	02000H
	DD	04000H
	DD	08000H
	DD	010000H
CONST	ENDS
PUBLIC	s370_cmpsc_2012
PUBLIC	fetch_hw_noswap
PUBLIC	s370_maddr_l
PUBLIC	s370_vfetch2_full
PUBLIC	s370_vfetch2
PUBLIC	s370_cmpsc_Expand
PUBLIC	s370_cmpsc_Compress
PUBLIC	s370_cmpsc_Expand_Index
PUBLIC	s390_cmpsc_2012
PUBLIC	s390_maddr_l
PUBLIC	s390_vfetch2_full
PUBLIC	s390_vfetch2
PUBLIC	s390_cmpsc_Expand
PUBLIC	s390_cmpsc_Compress
PUBLIC	s390_cmpsc_Expand_Index
PUBLIC	z900_cmpsc_2012
PUBLIC	z900_is_per3_event_suppressed
PUBLIC	z900_per3_zero
PUBLIC	z900_maddr_l
PUBLIC	z900_vfetch2_full
PUBLIC	z900_vfetch2
PUBLIC	z900_cmpsc_Expand
PUBLIC	z900_cmpsc_Compress
PUBLIC	z900_cmpsc_Expand_Index
EXTRN	_byteswap_ushort:PROC
EXTRN	longjmp:PROC
EXTRN	s370_store_int_timer:PROC
EXTRN	txf_maddr_l:PROC
EXTRN	s370_program_interrupt:PROC
EXTRN	s390_program_interrupt:PROC
EXTRN	z900_program_interrupt:PROC
EXTRN	s370_logical_to_main_l:PROC
EXTRN	s390_logical_to_main_l:PROC
EXTRN	z900_logical_to_main_l:PROC
EXTRN	s370_cmpsc_vfetchb:PROC
EXTRN	s370_cmpsc_vfetchc:PROC
EXTRN	s370_cmpsc_vstoreb:PROC
EXTRN	s370_cmpsc_vstorec:PROC
EXTRN	s370_cmpsc_SetREGS:PROC
EXTRN	s370_cmpsc_SetCMPSC:PROC
EXTRN	s370_GetECE:PROC
EXTRN	s370_GetCCE:PROC
EXTRN	s370_GetSD0:PROC
EXTRN	s370_GetSD1:PROC
EXTRN	s390_cmpsc_vfetchb:PROC
EXTRN	s390_cmpsc_vfetchc:PROC
EXTRN	s390_cmpsc_vstoreb:PROC
EXTRN	s390_cmpsc_vstorec:PROC
EXTRN	s390_cmpsc_SetREGS:PROC
EXTRN	s390_cmpsc_SetCMPSC:PROC
EXTRN	s390_GetECE:PROC
EXTRN	s390_GetCCE:PROC
EXTRN	s390_GetSD0:PROC
EXTRN	s390_GetSD1:PROC
EXTRN	z900_cmpsc_vfetchb:PROC
EXTRN	z900_cmpsc_vfetchc:PROC
EXTRN	z900_cmpsc_vstoreb:PROC
EXTRN	z900_cmpsc_vstorec:PROC
EXTRN	z900_cmpsc_SetREGS:PROC
EXTRN	z900_cmpsc_SetCMPSC:PROC
EXTRN	z900_GetECE:PROC
EXTRN	z900_GetCCE:PROC
EXTRN	z900_GetSD0:PROC
EXTRN	z900_GetSD1:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	s370_GetIndexCDSSTab:BYTE
EXTRN	s370_Get8IndexCDSSTab:BYTE
EXTRN	s370_PutGetCBNTab:BYTE
EXTRN	s370_PutIndexCDSSTab:BYTE
EXTRN	s390_GetIndexCDSSTab:BYTE
EXTRN	s390_Get8IndexCDSSTab:BYTE
EXTRN	s390_PutGetCBNTab:BYTE
EXTRN	s390_PutIndexCDSSTab:BYTE
EXTRN	z900_GetIndexCDSSTab:BYTE
EXTRN	z900_Get8IndexCDSSTab:BYTE
EXTRN	z900_PutGetCBNTab:BYTE
EXTRN	z900_PutIndexCDSSTab:BYTE
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
?zeroes@?5??z900_ZeroPadOp1@@9@9 DB 01000H DUP (?)	; `z900_ZeroPadOp1'::`6'::zeroes
_BSS	ENDS
pdata	SEGMENT
$pdata$s370_cmpsc_2012 DD imagerel $LN22
	DD	imagerel $LN22+479
	DD	imagerel $unwind$s370_cmpsc_2012
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s370_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch2_full DD imagerel $LN3
	DD	imagerel $LN3+174
	DD	imagerel $unwind$s370_vfetch2_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch2 DD imagerel $LN26
	DD	imagerel $LN26+275
	DD	imagerel $unwind$s370_vfetch2
pdata	ENDS
pdata	SEGMENT
$pdata$s370_cmpsc_Expand DD imagerel $LN105
	DD	imagerel $LN105+3121
	DD	imagerel $unwind$s370_cmpsc_Expand
$pdata$s370_cmpsc_Compress DD imagerel $LN177
	DD	imagerel $LN177+5822
	DD	imagerel $unwind$s370_cmpsc_Compress
$pdata$s370_EXPERR DD imagerel s370_EXPERR
	DD	imagerel s370_EXPERR+56
	DD	imagerel $unwind$s370_EXPERR
$pdata$s370_EXPCC1 DD imagerel s370_EXPCC1
	DD	imagerel s370_EXPCC1+56
	DD	imagerel $unwind$s370_EXPCC1
$pdata$s370_cmpsc_Expand_Index DD imagerel $LN53
	DD	imagerel $LN53+1532
	DD	imagerel $unwind$s370_cmpsc_Expand_Index
$pdata$s390_cmpsc_2012 DD imagerel $LN22
	DD	imagerel $LN22+479
	DD	imagerel $unwind$s390_cmpsc_2012
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s390_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetch2_full DD imagerel $LN3
	DD	imagerel $LN3+180
	DD	imagerel $unwind$s390_vfetch2_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetch2 DD imagerel $LN11
	DD	imagerel $LN11+187
	DD	imagerel $unwind$s390_vfetch2
pdata	ENDS
pdata	SEGMENT
$pdata$s390_cmpsc_Expand DD imagerel $LN105
	DD	imagerel $LN105+3121
	DD	imagerel $unwind$s390_cmpsc_Expand
$pdata$s390_cmpsc_Compress DD imagerel $LN177
	DD	imagerel $LN177+5870
	DD	imagerel $unwind$s390_cmpsc_Compress
$pdata$s390_EXPERR DD imagerel s390_EXPERR
	DD	imagerel s390_EXPERR+56
	DD	imagerel $unwind$s390_EXPERR
$pdata$s390_EXPCC1 DD imagerel s390_EXPCC1
	DD	imagerel s390_EXPCC1+56
	DD	imagerel $unwind$s390_EXPCC1
$pdata$s390_cmpsc_Expand_Index DD imagerel $LN53
	DD	imagerel $LN53+1532
	DD	imagerel $unwind$s390_cmpsc_Expand_Index
$pdata$z900_cmpsc_2012 DD imagerel $LN30
	DD	imagerel $LN30+760
	DD	imagerel $unwind$z900_cmpsc_2012
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero DD imagerel $LN12
	DD	imagerel $LN12+215
	DD	imagerel $unwind$z900_per3_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_maddr_l DD imagerel $LN18
	DD	imagerel $LN18+657
	DD	imagerel $unwind$z900_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch2_full DD imagerel $LN3
	DD	imagerel $LN3+186
	DD	imagerel $unwind$z900_vfetch2_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch2 DD imagerel $LN11
	DD	imagerel $LN11+196
	DD	imagerel $unwind$z900_vfetch2
pdata	ENDS
pdata	SEGMENT
$pdata$z900_cmpsc_Expand DD imagerel $LN105
	DD	imagerel $LN105+3121
	DD	imagerel $unwind$z900_cmpsc_Expand
$pdata$z900_cmpsc_Compress DD imagerel $LN177
	DD	imagerel $LN177+5877
	DD	imagerel $unwind$z900_cmpsc_Compress
$pdata$z900_ZeroPadOp1 DD imagerel z900_ZeroPadOp1
	DD	imagerel z900_ZeroPadOp1+510
	DD	imagerel $unwind$z900_ZeroPadOp1
$pdata$z900_CC3 DD imagerel z900_CC3
	DD	imagerel z900_CC3+69
	DD	imagerel $unwind$z900_CC3
$pdata$z900_CC1 DD imagerel z900_CC1
	DD	imagerel z900_CC1+69
	DD	imagerel $unwind$z900_CC1
$pdata$z900_CC0 DD imagerel z900_CC0
	DD	imagerel z900_CC0+69
	DD	imagerel $unwind$z900_CC0
$pdata$z900_EXPERR DD imagerel z900_EXPERR
	DD	imagerel z900_EXPERR+56
	DD	imagerel $unwind$z900_EXPERR
$pdata$z900_EXPCC1 DD imagerel z900_EXPCC1
	DD	imagerel z900_EXPCC1+56
	DD	imagerel $unwind$z900_EXPCC1
$pdata$z900_cmpsc_Expand_Index DD imagerel $LN53
	DD	imagerel $LN53+1533
	DD	imagerel $unwind$z900_cmpsc_Expand_Index
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch2 DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch2_full DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_maddr_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetch2 DD 011101H
	DD	08211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetch2_full DD 011101H
	DD	08211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_cmpsc_Compress
	DD	01eH
	DD	016dbH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_cmpsc_Expand
	DD	01eH
	DD	0c17H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_cmpsc_Compress
	DD	01eH
	DD	016d4H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_cmpsc_Expand
	DD	01eH
	DD	0c17H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_cmpsc_Compress
	DD	01eH
	DD	016a4H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_cmpsc_Expand
	DD	01eH
	DD	0c17H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch2 DD 011101H
	DD	0a211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch2_full DD 011101H
	DD	08211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
xdata	SEGMENT
$unwind$s370_cmpsc_2012 DD 021101H
	DD	0130111H
$unwind$s370_cmpsc_Expand DD 042619H
	DD	060650114H
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	030310H
$unwind$s370_cmpsc_Compress DD 042619H
	DD	0e0b30114H
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	070580H
$unwind$s370_EXPERR DD 010e01H
	DD	0420eH
$unwind$s370_EXPCC1 DD 010e01H
	DD	0420eH
$unwind$s370_cmpsc_Expand_Index DD 010e01H
	DD	0e20eH
$unwind$s390_cmpsc_2012 DD 021101H
	DD	0130111H
$unwind$s390_cmpsc_Expand DD 042619H
	DD	060650114H
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	030310H
$unwind$s390_cmpsc_Compress DD 042619H
	DD	0e0b30114H
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	070580H
$unwind$s390_EXPERR DD 010e01H
	DD	0420eH
$unwind$s390_EXPCC1 DD 010e01H
	DD	0420eH
$unwind$s390_cmpsc_Expand_Index DD 010e01H
	DD	0e20eH
$unwind$z900_cmpsc_2012 DD 021101H
	DD	0170111H
$unwind$z900_cmpsc_Expand DD 042619H
	DD	060650114H
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	030310H
$unwind$z900_cmpsc_Compress DD 042619H
	DD	0e0b30114H
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	070580H
$unwind$z900_ZeroPadOp1 DD 010e01H
	DD	0a20eH
$unwind$z900_CC3 DD 010e01H
	DD	0420eH
$unwind$z900_CC1 DD 010e01H
	DD	0420eH
$unwind$z900_CC0 DD 010e01H
	DD	0420eH
$unwind$z900_EXPERR DD 010e01H
	DD	0420eH
$unwind$z900_EXPCC1 DD 010e01H
	DD	0420eH
$unwind$z900_cmpsc_Expand_Index DD 010e01H
	DD	0e20eH
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
dicts$ = 32
tv263 = 34
tv66 = 36
tv72 = 40
tv85 = 44
tv161 = 48
tv172 = 52
tv186 = 56
tv202 = 60
tv228 = 64
tv239 = 68
tv252 = 72
tv274 = 76
tv152 = 80
tv219 = 88
tv288 = 96
tv323 = 104
pCMPSCBLK$ = 128
pEXPBLK$ = 136
z900_cmpsc_Expand_Index PROC

; 453  : {

$LN53:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 454  :     U8  dicts;  // Counts dictionary entries processed
; 455  : 
; 456  :     if (unlikely( !pCMPSCBLK->nLen1 ))

  0000e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00016	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0001a	75 0a		 jne	 SHORT $LN19@z900_cmpsc
  0001c	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00024	eb 08		 jmp	 SHORT $LN20@z900_cmpsc
$LN19@z900_cmpsc:
  00026	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN20@z900_cmpsc:
  0002e	83 7c 24 24 00	 cmp	 DWORD PTR tv66[rsp], 0
  00033	74 0a		 je	 SHORT $LN23@z900_cmpsc
  00035	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0003d	eb 08		 jmp	 SHORT $LN24@z900_cmpsc
$LN23@z900_cmpsc:
  0003f	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN24@z900_cmpsc:
  00047	83 7c 24 28 00	 cmp	 DWORD PTR tv72[rsp], 0
  0004c	74 1a		 je	 SHORT $LN5@z900_cmpsc

; 457  :         EXP_RETCC1();

  0004e	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  00056	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0005e	e8 00 00 00 00	 call	 z900_EXPCC1
  00063	e9 90 05 00 00	 jmp	 $LN1@z900_cmpsc
$LN5@z900_cmpsc:

; 458  : 
; 459  :     if (likely( pEXPBLK->index >= 256 ))

  00068	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00070	0f b7 80 9a 01
	03 00		 movzx	 eax, WORD PTR [rax+197018]
  00077	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0007c	7c 0a		 jl	 SHORT $LN27@z900_cmpsc
  0007e	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv85[rsp], 1
  00086	eb 08		 jmp	 SHORT $LN28@z900_cmpsc
$LN27@z900_cmpsc:
  00088	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv85[rsp], 0
$LN28@z900_cmpsc:
  00090	83 7c 24 2c 00	 cmp	 DWORD PTR tv85[rsp], 0
  00095	0f 84 03 05 00
	00		 je	 $LN6@z900_cmpsc

; 460  :     {
; 461  : #ifdef CMPSC_SYMCACHE
; 462  :         // Check our cache of previously expanded index symbols
; 463  :         // to see if we've already expanded this symbol before
; 464  :         // and if we have room in the o/p buffer to expand it.
; 465  : 
; 466  :         if (1
; 467  :             && (pEXPBLK->symlen  = pEXPBLK->symcctl[ pEXPBLK->index ].len) > 0
; 468  :             &&  pEXPBLK->symlen <= pCMPSCBLK->nLen1

  0009b	33 c0		 xor	 eax, eax
  0009d	83 f8 01	 cmp	 eax, 1
  000a0	0f 84 d2 00 00
	00		 je	 $LN8@z900_cmpsc
  000a6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  000ae	0f b7 80 9a 01
	03 00		 movzx	 eax, WORD PTR [rax+197018]
  000b5	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  000bd	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  000c5	0f b7 44 82 02	 movzx	 eax, WORD PTR [rdx+rax*4+2]
  000ca	66 89 81 98 01
	03 00		 mov	 WORD PTR [rcx+197016], ax
  000d1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  000d9	0f b7 80 98 01
	03 00		 movzx	 eax, WORD PTR [rax+197016]
  000e0	85 c0		 test	 eax, eax
  000e2	0f 8e 90 00 00
	00		 jle	 $LN8@z900_cmpsc
  000e8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  000f0	0f b7 80 98 01
	03 00		 movzx	 eax, WORD PTR [rax+197016]
  000f7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  000ff	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  00102	77 74		 ja	 SHORT $LN8@z900_cmpsc

; 469  :         )
; 470  :         {
; 471  :             store_op_str( &pEXPBLK->symcache[ pEXPBLK->symcctl[ pEXPBLK->index ].idx ], pEXPBLK->symlen-1, pCMPSCBLK->pOp1, &pEXPBLK->op1blk );

  00104	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  0010c	48 05 38 01 03
	00		 add	 rax, 196920		; 00030138H
  00112	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  0011a	0f b7 89 98 01
	03 00		 movzx	 ecx, WORD PTR [rcx+197016]
  00121	ff c9		 dec	 ecx
  00123	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  0012b	0f b7 92 9a 01
	03 00		 movzx	 edx, WORD PTR [rdx+197018]
  00132	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR pEXPBLK$[rsp]
  0013a	41 0f b7 14 90	 movzx	 edx, WORD PTR [r8+rdx*4]
  0013f	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR pEXPBLK$[rsp]
  00147	49 8d 94 10 00
	80 00 00	 lea	 rdx, QWORD PTR [r8+rdx+32768]
  0014f	48 89 54 24 50	 mov	 QWORD PTR tv152[rsp], rdx
  00154	4c 8b c8	 mov	 r9, rax
  00157	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0015f	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  00163	0f b7 d1	 movzx	 edx, cx
  00166	48 8b 44 24 50	 mov	 rax, QWORD PTR tv152[rsp]
  0016b	48 8b c8	 mov	 rcx, rax
  0016e	e8 00 00 00 00	 call	 z900_cmpsc_vstorec

; 472  :         }

  00173	e9 24 04 00 00	 jmp	 $LN9@z900_cmpsc
$LN8@z900_cmpsc:

; 473  :         else
; 474  : #endif // CMPSC_SYMCACHE
; 475  :         {
; 476  :             // We need to expand this index symbol: fetch the ECE...
; 477  : 
; 478  :             if (unlikely( !ARCH_DEP( GetECE )( pEXPBLK->index, &pEXPBLK->eceblk )))

  00178	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00180	48 05 20 01 01
	00		 add	 rax, 65824		; 00010120H
  00186	48 8b d0	 mov	 rdx, rax
  00189	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00191	0f b7 88 9a 01
	03 00		 movzx	 ecx, WORD PTR [rax+197018]
  00198	e8 00 00 00 00	 call	 z900_GetECE
  0019d	0f b6 c0	 movzx	 eax, al
  001a0	85 c0		 test	 eax, eax
  001a2	75 0a		 jne	 SHORT $LN29@z900_cmpsc
  001a4	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv161[rsp], 1
  001ac	eb 08		 jmp	 SHORT $LN30@z900_cmpsc
$LN29@z900_cmpsc:
  001ae	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv161[rsp], 0
$LN30@z900_cmpsc:
  001b6	83 7c 24 30 00	 cmp	 DWORD PTR tv161[rsp], 0
  001bb	74 0a		 je	 SHORT $LN33@z900_cmpsc
  001bd	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv172[rsp], 1
  001c5	eb 08		 jmp	 SHORT $LN34@z900_cmpsc
$LN33@z900_cmpsc:
  001c7	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv172[rsp], 0
$LN34@z900_cmpsc:
  001cf	83 7c 24 34 00	 cmp	 DWORD PTR tv172[rsp], 0
  001d4	74 1a		 je	 SHORT $LN10@z900_cmpsc

; 479  :                 EXP_RETERR();

  001d6	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  001de	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  001e6	e8 00 00 00 00	 call	 z900_EXPERR
  001eb	e9 08 04 00 00	 jmp	 $LN1@z900_cmpsc
$LN10@z900_cmpsc:

; 480  : 
; 481  :             if (pEXPBLK->ece.psl)

  001f0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  001f8	0f b6 80 93 01
	03 00		 movzx	 eax, BYTE PTR [rax+197011]
  001ff	85 c0		 test	 eax, eax
  00201	0f 84 bc 01 00
	00		 je	 $LN11@z900_cmpsc

; 482  :             {
; 483  :                 // Preceded (i.e. partial symbol)...
; 484  :                 // Do we have room for the complete symbol?
; 485  : 
; 486  :                 if (unlikely( pCMPSCBLK->nLen1 < (pEXPBLK->symlen = pEXPBLK->ece.psl + pEXPBLK->ece.ofst)))

  00207	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  0020f	0f b6 80 93 01
	03 00		 movzx	 eax, BYTE PTR [rax+197011]
  00216	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  0021e	0f b6 89 94 01
	03 00		 movzx	 ecx, BYTE PTR [rcx+197012]
  00225	03 c1		 add	 eax, ecx
  00227	89 44 24 38	 mov	 DWORD PTR tv186[rsp], eax
  0022b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00233	0f b7 4c 24 38	 movzx	 ecx, WORD PTR tv186[rsp]
  00238	66 89 88 98 01
	03 00		 mov	 WORD PTR [rax+197016], cx
  0023f	0f b7 44 24 38	 movzx	 eax, WORD PTR tv186[rsp]
  00244	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0024c	48 39 01	 cmp	 QWORD PTR [rcx], rax
  0024f	73 0a		 jae	 SHORT $LN37@z900_cmpsc
  00251	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv202[rsp], 1
  00259	eb 08		 jmp	 SHORT $LN38@z900_cmpsc
$LN37@z900_cmpsc:
  0025b	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv202[rsp], 0
$LN38@z900_cmpsc:
  00263	83 7c 24 3c 00	 cmp	 DWORD PTR tv202[rsp], 0
  00268	74 1a		 je	 SHORT $LN13@z900_cmpsc

; 487  :                     EXP_RETCC1();

  0026a	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  00272	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0027a	e8 00 00 00 00	 call	 z900_EXPCC1
  0027f	e9 74 03 00 00	 jmp	 $LN1@z900_cmpsc
$LN13@z900_cmpsc:

; 488  : 
; 489  :                 dicts = 1;

  00284	c6 44 24 20 01	 mov	 BYTE PTR dicts$[rsp], 1
$LN4@z900_cmpsc:

; 490  : 
; 491  :                 do
; 492  :                 {
; 493  :                     // Expand this partial ("preceded") chunk of this index symbol...
; 494  : 
; 495  :                     store_op_str( pEXPBLK->ece.ec, pEXPBLK->ece.psl-1, pCMPSCBLK->pOp1 + pEXPBLK->ece.ofst, &pEXPBLK->op1blk );

  00289	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00291	48 05 38 01 03
	00		 add	 rax, 196920		; 00030138H
  00297	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  0029f	0f b6 89 94 01
	03 00		 movzx	 ecx, BYTE PTR [rcx+197012]
  002a6	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pCMPSCBLK$[rsp]
  002ae	48 03 4a 20	 add	 rcx, QWORD PTR [rdx+32]
  002b2	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  002ba	0f b6 92 93 01
	03 00		 movzx	 edx, BYTE PTR [rdx+197011]
  002c1	ff ca		 dec	 edx
  002c3	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR pEXPBLK$[rsp]
  002cb	49 81 c0 88 01
	03 00		 add	 r8, 197000		; 00030188H
  002d2	4c 89 44 24 58	 mov	 QWORD PTR tv219[rsp], r8
  002d7	4c 8b c8	 mov	 r9, rax
  002da	4c 8b c1	 mov	 r8, rcx
  002dd	48 8b 44 24 58	 mov	 rax, QWORD PTR tv219[rsp]
  002e2	48 8b c8	 mov	 rcx, rax
  002e5	e8 00 00 00 00	 call	 z900_cmpsc_vstorec

; 496  : 
; 497  :                     // Get the ECE for the next chunk...
; 498  : 
; 499  :                     if (unlikely( !ARCH_DEP( GetECE )( pEXPBLK->ece.pptr, &pEXPBLK->eceblk )))

  002ea	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  002f2	48 05 20 01 01
	00		 add	 rax, 65824		; 00010120H
  002f8	48 8b d0	 mov	 rdx, rax
  002fb	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00303	0f b7 88 90 01
	03 00		 movzx	 ecx, WORD PTR [rax+197008]
  0030a	e8 00 00 00 00	 call	 z900_GetECE
  0030f	0f b6 c0	 movzx	 eax, al
  00312	85 c0		 test	 eax, eax
  00314	75 0a		 jne	 SHORT $LN39@z900_cmpsc
  00316	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv228[rsp], 1
  0031e	eb 08		 jmp	 SHORT $LN40@z900_cmpsc
$LN39@z900_cmpsc:
  00320	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv228[rsp], 0
$LN40@z900_cmpsc:
  00328	83 7c 24 40 00	 cmp	 DWORD PTR tv228[rsp], 0
  0032d	74 0a		 je	 SHORT $LN43@z900_cmpsc
  0032f	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv239[rsp], 1
  00337	eb 08		 jmp	 SHORT $LN44@z900_cmpsc
$LN43@z900_cmpsc:
  00339	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv239[rsp], 0
$LN44@z900_cmpsc:
  00341	83 7c 24 44 00	 cmp	 DWORD PTR tv239[rsp], 0
  00346	74 1a		 je	 SHORT $LN14@z900_cmpsc

; 500  :                         EXP_RETERR();

  00348	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  00350	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00358	e8 00 00 00 00	 call	 z900_EXPERR
  0035d	e9 96 02 00 00	 jmp	 $LN1@z900_cmpsc
$LN14@z900_cmpsc:

; 501  : 
; 502  :                     if (unlikely( ++dicts > 127 ))

  00362	0f b6 44 24 20	 movzx	 eax, BYTE PTR dicts$[rsp]
  00367	fe c0		 inc	 al
  00369	88 44 24 20	 mov	 BYTE PTR dicts$[rsp], al
  0036d	0f b6 44 24 20	 movzx	 eax, BYTE PTR dicts$[rsp]
  00372	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00375	7e 0a		 jle	 SHORT $LN47@z900_cmpsc
  00377	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv252[rsp], 1
  0037f	eb 08		 jmp	 SHORT $LN48@z900_cmpsc
$LN47@z900_cmpsc:
  00381	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv252[rsp], 0
$LN48@z900_cmpsc:
  00389	83 7c 24 48 00	 cmp	 DWORD PTR tv252[rsp], 0
  0038e	74 1a		 je	 SHORT $LN15@z900_cmpsc

; 503  :                         EXP_RETERR();

  00390	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  00398	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  003a0	e8 00 00 00 00	 call	 z900_EXPERR
  003a5	e9 4e 02 00 00	 jmp	 $LN1@z900_cmpsc
$LN15@z900_cmpsc:

; 504  :                 }
; 505  :                 while (pEXPBLK->ece.psl);

  003aa	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  003b2	0f b6 80 93 01
	03 00		 movzx	 eax, BYTE PTR [rax+197011]
  003b9	85 c0		 test	 eax, eax
  003bb	0f 85 c8 fe ff
	ff		 jne	 $LN4@z900_cmpsc

; 506  : 
; 507  :                 // we're done with the partial ("preceded") part of this
; 508  :                 // symbol's expansion. Fall through to the "complete" symbol
; 509  :                 // expansion logic to finish up this symbol's expansion...
; 510  :             }

  003c1	eb 6d		 jmp	 SHORT $LN12@z900_cmpsc
$LN11@z900_cmpsc:

; 511  :             else
; 512  :             {
; 513  :                 // Unpreceded (i.e. complete symbol)...
; 514  :                 // Do we have room for the complete symbol?
; 515  : 
; 516  :                 if (unlikely( pCMPSCBLK->nLen1 < (pEXPBLK->symlen = pEXPBLK->ece.csl)))

  003c3	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  003cb	0f b6 80 92 01
	03 00		 movzx	 eax, BYTE PTR [rax+197010]
  003d2	66 89 44 24 22	 mov	 WORD PTR tv263[rsp], ax
  003d7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  003df	0f b7 4c 24 22	 movzx	 ecx, WORD PTR tv263[rsp]
  003e4	66 89 88 98 01
	03 00		 mov	 WORD PTR [rax+197016], cx
  003eb	0f b7 44 24 22	 movzx	 eax, WORD PTR tv263[rsp]
  003f0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  003f8	48 39 01	 cmp	 QWORD PTR [rcx], rax
  003fb	73 0a		 jae	 SHORT $LN51@z900_cmpsc
  003fd	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv274[rsp], 1
  00405	eb 08		 jmp	 SHORT $LN52@z900_cmpsc
$LN51@z900_cmpsc:
  00407	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv274[rsp], 0
$LN52@z900_cmpsc:
  0040f	83 7c 24 4c 00	 cmp	 DWORD PTR tv274[rsp], 0
  00414	74 1a		 je	 SHORT $LN16@z900_cmpsc

; 517  :                     EXP_RETCC1();

  00416	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  0041e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00426	e8 00 00 00 00	 call	 z900_EXPCC1
  0042b	e9 c8 01 00 00	 jmp	 $LN1@z900_cmpsc
$LN16@z900_cmpsc:
$LN12@z900_cmpsc:

; 518  :             }
; 519  : 
; 520  :             // Complete the expansion of this index symbol...
; 521  : 
; 522  :             store_op_str( pEXPBLK->ece.ec, pEXPBLK->ece.csl-1, pCMPSCBLK->pOp1, &pEXPBLK->op1blk );

  00430	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00438	48 05 38 01 03
	00		 add	 rax, 196920		; 00030138H
  0043e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  00446	0f b6 89 92 01
	03 00		 movzx	 ecx, BYTE PTR [rcx+197010]
  0044d	ff c9		 dec	 ecx
  0044f	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  00457	48 81 c2 88 01
	03 00		 add	 rdx, 197000		; 00030188H
  0045e	48 89 54 24 60	 mov	 QWORD PTR tv288[rsp], rdx
  00463	4c 8b c8	 mov	 r9, rax
  00466	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0046e	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  00472	0f b7 d1	 movzx	 edx, cx
  00475	48 8b 44 24 60	 mov	 rax, QWORD PTR tv288[rsp]
  0047a	48 8b c8	 mov	 rcx, rax
  0047d	e8 00 00 00 00	 call	 z900_cmpsc_vstorec

; 523  : 
; 524  : #ifdef CMPSC_SYMCACHE
; 525  :             // If there's room for it, add this symbol to our expanded symbols cache
; 526  : 
; 527  :             if (pEXPBLK->symlen <= (sizeof( pEXPBLK->symcache ) - pEXPBLK->symindex))

  00482	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  0048a	0f b7 80 98 01
	03 00		 movzx	 eax, WORD PTR [rax+197016]
  00491	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  00499	0f b7 89 00 00
	01 00		 movzx	 ecx, WORD PTR [rcx+65536]
  004a0	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  004a5	48 2b d1	 sub	 rdx, rcx
  004a8	48 8b ca	 mov	 rcx, rdx
  004ab	48 3b c1	 cmp	 rax, rcx
  004ae	0f 87 e8 00 00
	00		 ja	 $LN17@z900_cmpsc

; 528  :             {
; 529  :                 pEXPBLK->symcctl[ pEXPBLK->index ].len = pEXPBLK->symlen;

  004b4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  004bc	0f b7 80 9a 01
	03 00		 movzx	 eax, WORD PTR [rax+197018]
  004c3	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  004cb	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  004d3	0f b7 92 98 01
	03 00		 movzx	 edx, WORD PTR [rdx+197016]
  004da	66 89 54 81 02	 mov	 WORD PTR [rcx+rax*4+2], dx

; 530  :                 pEXPBLK->symcctl[ pEXPBLK->index ].idx = pEXPBLK->symindex;

  004df	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  004e7	0f b7 80 9a 01
	03 00		 movzx	 eax, WORD PTR [rax+197018]
  004ee	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  004f6	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  004fe	0f b7 92 00 00
	01 00		 movzx	 edx, WORD PTR [rdx+65536]
  00505	66 89 14 81	 mov	 WORD PTR [rcx+rax*4], dx

; 531  : 
; 532  :                 // (add this symbol to our previously expanded symbols cache)
; 533  : 
; 534  :                 fetch_op_str( &pEXPBLK->symcache[ pEXPBLK->symindex ], pEXPBLK->symlen-1, pCMPSCBLK->pOp1, &pEXPBLK->op1blk );

  00509	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00511	48 05 38 01 03
	00		 add	 rax, 196920		; 00030138H
  00517	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  0051f	0f b7 89 98 01
	03 00		 movzx	 ecx, WORD PTR [rcx+197016]
  00526	ff c9		 dec	 ecx
  00528	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  00530	0f b7 92 00 00
	01 00		 movzx	 edx, WORD PTR [rdx+65536]
  00537	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR pEXPBLK$[rsp]
  0053f	49 8d 94 10 00
	80 00 00	 lea	 rdx, QWORD PTR [r8+rdx+32768]
  00547	48 89 54 24 68	 mov	 QWORD PTR tv323[rsp], rdx
  0054c	4c 8b c8	 mov	 r9, rax
  0054f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00557	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  0055b	0f b7 d1	 movzx	 edx, cx
  0055e	48 8b 44 24 68	 mov	 rax, QWORD PTR tv323[rsp]
  00563	48 8b c8	 mov	 rcx, rax
  00566	e8 00 00 00 00	 call	 z900_cmpsc_vfetchc

; 535  : 
; 536  :                 pEXPBLK->symindex += pEXPBLK->symlen;

  0056b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00573	0f b7 80 98 01
	03 00		 movzx	 eax, WORD PTR [rax+197016]
  0057a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  00582	0f b7 89 00 00
	01 00		 movzx	 ecx, WORD PTR [rcx+65536]
  00589	03 c8		 add	 ecx, eax
  0058b	8b c1		 mov	 eax, ecx
  0058d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  00595	66 89 81 00 00
	01 00		 mov	 WORD PTR [rcx+65536], ax
$LN17@z900_cmpsc:
$LN9@z900_cmpsc:

; 537  :             }
; 538  : #endif // CMPSC_SYMCACHE
; 539  :         }
; 540  :     }

  0059c	eb 45		 jmp	 SHORT $LN7@z900_cmpsc
$LN6@z900_cmpsc:

; 541  :     else // (pEXPBLK->index < 256)
; 542  :     {
; 543  :         // The index symbol is an alphabet entry (i.e. an index symbol
; 544  :         // corresponding to a one-byte symbol). The expanded symbol it
; 545  :         // represents is the value of the alphabet index symbol itself.
; 546  : 
; 547  :         store_op_b( (U8)pEXPBLK->index, pCMPSCBLK->pOp1, &pEXPBLK->op1blk );

  0059e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  005a6	48 05 38 01 03
	00		 add	 rax, 196920		; 00030138H
  005ac	4c 8b c0	 mov	 r8, rax
  005af	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  005b7	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  005bb	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  005c3	0f b6 88 9a 01
	03 00		 movzx	 ecx, BYTE PTR [rax+197018]
  005ca	e8 00 00 00 00	 call	 z900_cmpsc_vstoreb

; 548  :         pEXPBLK->symlen = 1;

  005cf	b8 01 00 00 00	 mov	 eax, 1
  005d4	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  005dc	66 89 81 98 01
	03 00		 mov	 WORD PTR [rcx+197016], ax
$LN7@z900_cmpsc:

; 549  :     }
; 550  : 
; 551  :     EXP_RETOK();

  005e3	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  005eb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  005f3	e8 00 00 00 00	 call	 z900_EXPOK
$LN1@z900_cmpsc:

; 552  : }

  005f8	48 83 c4 78	 add	 rsp, 120		; 00000078H
  005fc	c3		 ret	 0
z900_cmpsc_Expand_Index ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
pCMPSCBLK$ = 48
pEXPBLK$ = 56
z900_EXPCC1 PROC

; 212  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 213  :     pEXPBLK->rc = ARCH_DEP( CC1 )( pCMPSCBLK, &pEXPBLK->op1blk ); return FALSE; // (break)

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00013	48 05 38 01 03
	00		 add	 rax, 196920		; 00030138H
  00019	48 8b d0	 mov	 rdx, rax
  0001c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00021	e8 00 00 00 00	 call	 z900_CC1
  00026	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  0002b	88 81 9d 01 03
	00		 mov	 BYTE PTR [rcx+197021], al
  00031	32 c0		 xor	 al, al

; 214  : }

  00033	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00037	c3		 ret	 0
z900_EXPCC1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
pCMPSCBLK$ = 48
pEXPBLK$ = 56
z900_EXPERR PROC

; 204  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 205  :     pEXPBLK->rc = ARCH_DEP( ERR )( pCMPSCBLK, &pEXPBLK->op1blk ); return FALSE; // (break)

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00013	48 05 38 01 03
	00		 add	 rax, 196920		; 00030138H
  00019	48 8b d0	 mov	 rdx, rax
  0001c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00021	e8 00 00 00 00	 call	 z900_ERR
  00026	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  0002b	88 81 9d 01 03
	00		 mov	 BYTE PTR [rcx+197021], al
  00031	32 c0		 xor	 al, al

; 206  : }

  00033	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00037	c3		 ret	 0
z900_EXPERR ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
pCMPSCBLK$ = 8
pEXPBLK$ = 16
z900_EXPOK PROC

; 198  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@z900_EXPOK:

; 199  :     UNREFERENCED( pCMPSCBLK );

  0000a	33 c0		 xor	 eax, eax
  0000c	85 c0		 test	 eax, eax
  0000e	75 fa		 jne	 SHORT $LN4@z900_EXPOK
$LN7@z900_EXPOK:

; 200  :     UNREFERENCED( pEXPBLK   );

  00010	33 c0		 xor	 eax, eax
  00012	85 c0		 test	 eax, eax
  00014	75 fa		 jne	 SHORT $LN7@z900_EXPOK

; 201  :     return TRUE; // (success; keep going)

  00016	b0 01		 mov	 al, 1

; 202  : }

  00018	c3		 ret	 0
z900_EXPOK ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
pCMPSCBLK$ = 48
pOp1MemBlk$ = 56
z900_CC0 PROC

; 189  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 190  :     ZERO_PAD_OP1( pCMPSCBLK, pOp1MemBlk );

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00013	0f b6 40 47	 movzx	 eax, BYTE PTR [rax+71]
  00017	85 c0		 test	 eax, eax
  00019	74 0f		 je	 SHORT $LN2@z900_CC0
  0001b	48 8b 54 24 38	 mov	 rdx, QWORD PTR pOp1MemBlk$[rsp]
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00025	e8 00 00 00 00	 call	 z900_ZeroPadOp1
$LN2@z900_CC0:

; 191  :     pCMPSCBLK->pic = 0;

  0002a	33 c0		 xor	 eax, eax
  0002c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00031	66 89 41 3e	 mov	 WORD PTR [rcx+62], ax

; 192  :     pCMPSCBLK->cc = 0;

  00035	48 8b 44 24 30	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0003a	c6 40 46 00	 mov	 BYTE PTR [rax+70], 0

; 193  :     return TRUE;

  0003e	b0 01		 mov	 al, 1

; 194  : }

  00040	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00044	c3		 ret	 0
z900_CC0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
pCMPSCBLK$ = 48
pOp1MemBlk$ = 56
z900_CC1 PROC

; 182  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 183  :     ZERO_PAD_OP1( pCMPSCBLK, pOp1MemBlk );

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00013	0f b6 40 47	 movzx	 eax, BYTE PTR [rax+71]
  00017	85 c0		 test	 eax, eax
  00019	74 0f		 je	 SHORT $LN2@z900_CC1
  0001b	48 8b 54 24 38	 mov	 rdx, QWORD PTR pOp1MemBlk$[rsp]
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00025	e8 00 00 00 00	 call	 z900_ZeroPadOp1
$LN2@z900_CC1:

; 184  :     pCMPSCBLK->pic = 0;

  0002a	33 c0		 xor	 eax, eax
  0002c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00031	66 89 41 3e	 mov	 WORD PTR [rcx+62], ax

; 185  :     pCMPSCBLK->cc = 1;

  00035	48 8b 44 24 30	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0003a	c6 40 46 01	 mov	 BYTE PTR [rax+70], 1

; 186  :     return TRUE;

  0003e	b0 01		 mov	 al, 1

; 187  : }

  00040	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00044	c3		 ret	 0
z900_CC1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
pCMPSCBLK$ = 48
pOp1MemBlk$ = 56
z900_CC3 PROC

; 175  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 176  :     ZERO_PAD_OP1( pCMPSCBLK, pOp1MemBlk );

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00013	0f b6 40 47	 movzx	 eax, BYTE PTR [rax+71]
  00017	85 c0		 test	 eax, eax
  00019	74 0f		 je	 SHORT $LN2@z900_CC3
  0001b	48 8b 54 24 38	 mov	 rdx, QWORD PTR pOp1MemBlk$[rsp]
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00025	e8 00 00 00 00	 call	 z900_ZeroPadOp1
$LN2@z900_CC3:

; 177  :     pCMPSCBLK->pic = 0;

  0002a	33 c0		 xor	 eax, eax
  0002c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00031	66 89 41 3e	 mov	 WORD PTR [rcx+62], ax

; 178  :     pCMPSCBLK->cc = 3;

  00035	48 8b 44 24 30	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0003a	c6 40 46 03	 mov	 BYTE PTR [rax+70], 3

; 179  :     return TRUE;

  0003e	b0 01		 mov	 al, 1

; 180  : }

  00040	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00044	c3		 ret	 0
z900_CC3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
pCMPSCBLK$ = 8
pOp1MemBlk$ = 16
z900_ERR PROC

; 169  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@z900_ERR:

; 170  :     UNREFERENCED( pOp1MemBlk );

  0000a	33 c0		 xor	 eax, eax
  0000c	85 c0		 test	 eax, eax
  0000e	75 fa		 jne	 SHORT $LN4@z900_ERR

; 171  :     pCMPSCBLK->pic = 7;

  00010	b8 07 00 00 00	 mov	 eax, 7
  00015	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0001a	66 89 41 3e	 mov	 WORD PTR [rcx+62], ax

; 172  :     return FALSE;

  0001e	32 c0		 xor	 al, al

; 173  : }

  00020	c3		 ret	 0
z900_ERR ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
nPadAmt$1 = 32
tv91 = 36
tv212 = 40
pOp1$ = 48
nLen1$ = 56
tv207 = 64
pCMPSCBLK$ = 96
pOp1MemBlk$ = 104
z900_ZeroPadOp1 PROC

; 123  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 124  :     U64  pOp1   = pCMPSCBLK->pOp1;              // (operand-1 output)

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00013	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00017	48 89 44 24 30	 mov	 QWORD PTR pOp1$[rsp], rax

; 125  :     U64  nLen1  = pCMPSCBLK->nLen1;             // (operand-1 length)

  0001c	48 8b 44 24 60	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00021	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00024	48 89 44 24 38	 mov	 QWORD PTR nLen1$[rsp], rax

; 126  : 
; 127  :     if (1
; 128  :         && !(pCMPSCBLK->regs->GR_L(0) & 0x100)  // (compression?)
; 129  :         && pCMPSCBLK->cbn                       // (partial byte?)
; 130  :         && nLen1                                // (rem >= 1 byte?)

  00029	33 c0		 xor	 eax, eax
  0002b	83 f8 01	 cmp	 eax, 1
  0002e	74 51		 je	 SHORT $LN5@z900_ZeroP
  00030	48 8b 44 24 60	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00035	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00039	b9 08 00 00 00	 mov	 ecx, 8
  0003e	48 6b c9 00	 imul	 rcx, rcx, 0
  00042	8b 84 08 80 02
	00 00		 mov	 eax, DWORD PTR [rax+rcx+640]
  00049	25 00 01 00 00	 and	 eax, 256		; 00000100H
  0004e	85 c0		 test	 eax, eax
  00050	75 2f		 jne	 SHORT $LN5@z900_ZeroP
  00052	48 8b 44 24 60	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00057	0f b6 40 45	 movzx	 eax, BYTE PTR [rax+69]
  0005b	85 c0		 test	 eax, eax
  0005d	74 22		 je	 SHORT $LN5@z900_ZeroP
  0005f	48 83 7c 24 38
	00		 cmp	 QWORD PTR nLen1$[rsp], 0
  00065	74 1a		 je	 SHORT $LN5@z900_ZeroP

; 131  :     )
; 132  :     {
; 133  :         pOp1++;                                 // (skip past byte)

  00067	48 8b 44 24 30	 mov	 rax, QWORD PTR pOp1$[rsp]
  0006c	48 ff c0	 inc	 rax
  0006f	48 89 44 24 30	 mov	 QWORD PTR pOp1$[rsp], rax

; 134  :         nLen1--;                                // (length remaining)

  00074	48 8b 44 24 38	 mov	 rax, QWORD PTR nLen1$[rsp]
  00079	48 ff c8	 dec	 rax
  0007c	48 89 44 24 38	 mov	 QWORD PTR nLen1$[rsp], rax
$LN5@z900_ZeroP:

; 135  :     }
; 136  : 
; 137  :     pOp1 &= ADDRESS_MAXWRAP( pCMPSCBLK->regs ); // (wrap if needed)

  00081	48 8b 44 24 60	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00086	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0008a	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00091	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pOp1$[rsp]
  00096	48 23 c8	 and	 rcx, rax
  00099	48 8b c1	 mov	 rax, rcx
  0009c	48 89 44 24 30	 mov	 QWORD PTR pOp1$[rsp], rax
$LN4@z900_ZeroP:

; 138  :     MEMBLK_BUMP( pOp1MemBlk, pOp1 );            // (bump if needed)

  000a1	48 8b 44 24 68	 mov	 rax, QWORD PTR pOp1MemBlk$[rsp]
  000a6	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000aa	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  000b0	48 39 44 24 30	 cmp	 QWORD PTR pOp1$[rsp], rax
  000b5	73 0a		 jae	 SHORT $LN12@z900_ZeroP
  000b7	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv91[rsp], 1
  000bf	eb 08		 jmp	 SHORT $LN13@z900_ZeroP
$LN12@z900_ZeroP:
  000c1	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
$LN13@z900_ZeroP:
  000c9	83 7c 24 24 00	 cmp	 DWORD PTR tv91[rsp], 0
  000ce	75 55		 jne	 SHORT $LN6@z900_ZeroP
  000d0	48 8b 44 24 68	 mov	 rax, QWORD PTR pOp1MemBlk$[rsp]
  000d5	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000d9	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  000df	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pOp1MemBlk$[rsp]
  000e4	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  000e8	b8 08 00 00 00	 mov	 eax, 8
  000ed	48 6b c0 01	 imul	 rax, rax, 1
  000f1	b9 08 00 00 00	 mov	 ecx, 8
  000f6	48 6b c9 00	 imul	 rcx, rcx, 0
  000fa	48 8b 54 24 68	 mov	 rdx, QWORD PTR pOp1MemBlk$[rsp]
  000ff	4c 8b 44 24 68	 mov	 r8, QWORD PTR pOp1MemBlk$[rsp]
  00104	49 8b 44 00 10	 mov	 rax, QWORD PTR [r8+rax+16]
  00109	48 89 44 0a 10	 mov	 QWORD PTR [rdx+rcx+16], rax
  0010e	b8 08 00 00 00	 mov	 eax, 8
  00113	48 6b c0 01	 imul	 rax, rax, 1
  00117	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pOp1MemBlk$[rsp]
  0011c	48 c7 44 01 10
	00 00 00 00	 mov	 QWORD PTR [rcx+rax+16], 0
$LN6@z900_ZeroP:
  00125	33 c0		 xor	 eax, eax
  00127	85 c0		 test	 eax, eax
  00129	0f 85 72 ff ff
	ff		 jne	 $LN4@z900_ZeroP

; 139  : 
; 140  :     if (pOp1 & CMPSC_ZP_MASK)                   // (is padding needed?)

  0012f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00136	0f b6 80 99 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3737]
  0013d	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00142	2b c8		 sub	 ecx, eax
  00144	8b c1		 mov	 eax, ecx
  00146	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  0014d	48 89 4c 24 40	 mov	 QWORD PTR tv207[rsp], rcx
  00152	0f b6 c8	 movzx	 ecx, al
  00155	48 8b 44 24 40	 mov	 rax, QWORD PTR tv207[rsp]
  0015a	48 d3 e8	 shr	 rax, cl
  0015d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pOp1$[rsp]
  00162	48 23 c8	 and	 rcx, rax
  00165	48 8b c1	 mov	 rax, rcx
  00168	48 85 c0	 test	 rax, rax
  0016b	0f 84 88 00 00
	00		 je	 $LN7@z900_ZeroP

; 141  :     {
; 142  :         U16 nPadAmt = ((U16)CMPSC_ZP_BYTES - (U16)(pOp1 & CMPSC_ZP_MASK));

  00171	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00178	0f b6 80 99 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3737]
  0017f	b9 01 00 00 00	 mov	 ecx, 1
  00184	89 4c 24 28	 mov	 DWORD PTR tv212[rsp], ecx
  00188	0f b6 c8	 movzx	 ecx, al
  0018b	8b 44 24 28	 mov	 eax, DWORD PTR tv212[rsp]
  0018f	d3 e0		 shl	 eax, cl
  00191	0f b7 c0	 movzx	 eax, ax
  00194	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0019b	0f b6 89 99 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3737]
  001a2	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001a7	2b d1		 sub	 edx, ecx
  001a9	8b ca		 mov	 ecx, edx
  001ab	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  001b2	48 d3 ea	 shr	 rdx, cl
  001b5	48 8b ca	 mov	 rcx, rdx
  001b8	48 8b 54 24 30	 mov	 rdx, QWORD PTR pOp1$[rsp]
  001bd	48 23 d1	 and	 rdx, rcx
  001c0	48 8b ca	 mov	 rcx, rdx
  001c3	0f b7 c9	 movzx	 ecx, cx
  001c6	2b c1		 sub	 eax, ecx
  001c8	66 89 44 24 20	 mov	 WORD PTR nPadAmt$1[rsp], ax

; 143  : 
; 144  :         if (nLen1 >= (U64) nPadAmt)             // (enough room for pad?)

  001cd	0f b7 44 24 20	 movzx	 eax, WORD PTR nPadAmt$1[rsp]
  001d2	48 39 44 24 38	 cmp	 QWORD PTR nLen1$[rsp], rax
  001d7	72 20		 jb	 SHORT $LN8@z900_ZeroP

; 145  :         {
; 146  :             static U8 zeroes[ (1 << MAX_CMPSC_ZP_BITS) ] = {0};
; 147  :             store_op_str( zeroes, nPadAmt-1, pOp1, pOp1MemBlk );

  001d9	0f b7 44 24 20	 movzx	 eax, WORD PTR nPadAmt$1[rsp]
  001de	ff c8		 dec	 eax
  001e0	4c 8b 4c 24 68	 mov	 r9, QWORD PTR pOp1MemBlk$[rsp]
  001e5	4c 8b 44 24 30	 mov	 r8, QWORD PTR pOp1$[rsp]
  001ea	0f b7 d0	 movzx	 edx, ax
  001ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?zeroes@?5??z900_ZeroPadOp1@@9@9
  001f4	e8 00 00 00 00	 call	 z900_cmpsc_vstorec
$LN8@z900_ZeroP:
$LN7@z900_ZeroP:

; 148  :         }
; 149  :     }
; 150  : }

  001f9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001fd	c3		 ret	 0
z900_ZeroPadOp1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
scnum$ = 32
ccnum$ = 33
byt$ = 34
eodst$ = 35
parent_index$ = 36
child_index$ = 40
children$ = 44
bits$ = 48
flag$ = 49
sibling_index$ = 52
pPutIndex$ = 56
pPutGetCBN$ = 64
nCPUAmt$ = 72
pBegOp2$ = 80
max_index$ = 88
tv287 = 92
tv303 = 96
tv321 = 100
tv330 = 104
tv355 = 108
tv373 = 112
tv387 = 116
tv393 = 120
tv460 = 124
tv469 = 128
tv563 = 132
tv572 = 136
tv588 = 140
tv600 = 144
tv618 = 148
tv630 = 152
tv642 = 156
tv660 = 160
tv672 = 164
tv694 = 168
tv703 = 172
tv725 = 176
tv792 = 180
tv815 = 184
tv824 = 188
tv866 = 192
tv878 = 196
tv896 = 200
tv922 = 204
tv934 = 208
tv952 = 212
tv259 = 216
tv263 = 220
tv267 = 224
tv273 = 228
op1blk$ = 232
pSymTab$ = 272
tv1111 = 280
op2blk$ = 288
tv129 = 328
tv133 = 336
pGetSD$ = 344
piblk$ = 352
ppPutIndex$ = 384
dctblk$ = 400
dctblk2$ = 688
cceblk$ = 976
sdeblk$ = 263152
sibling$ = 459792
parent$ = 459816
child$ = 459848
wrk$ = 459888
__$ArrayPad$ = 460160
pCMPSCBLK$ = 460208
z900_cmpsc_Compress PROC

; 558  : {

$LN177:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	b8 98 05 07 00	 mov	 eax, 460184		; 00070598H
  0000c	e8 00 00 00 00	 call	 __chkstk
  00011	48 2b e0	 sub	 rsp, rax
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 80
	05 07 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 559  :     U64         nCPUAmt;            // CPU determined processing limit
; 560  :     U64         pBegOp2;            // Ptr to beginning of operand-2
; 561  :     PutGetCBN*  pPutGetCBN;         // Ptr to PutGetCBN function for this CDSS-1
; 562  :     PutIndex**  ppPutIndex;         // Ptr to PutNextIndex table for this CDSS-1
; 563  :     PutIndex*   pPutIndex;          // Ptr to PutNextIndex function for this CBN
; 564  :     U64         pSymTab;            // Symbol-Translation Table
; 565  :     GETSD*      pGetSD;             // Pointer to Get-Sibling-Descriptor function
; 566  :     CCE         parent;             // Parent Compression Character Entry data
; 567  :     CCE         child;              // Child  Compression Character Entry data
; 568  :     SDE         sibling;            // Sibling Descriptor Entry data
; 569  :     MEMBLK      op1blk;             // Operand-1 memory access control block
; 570  :     MEMBLK      op2blk;             // Operand-2 memory access control block
; 571  :     DCTBLK      dctblk;             // GetDCT parameters block  (cmp dict)
; 572  :     DCTBLK      dctblk2;            // GetDCT parameters block  (exp dict)
; 573  :     CCEBLK      cceblk;             // GetCCE parameters block
; 574  :     SDEBLK      sdeblk;             // GetSDn parameters block
; 575  :     PIBLK       piblk;              // PutIndex parameters block
; 576  :     U16         parent_index;       // Parent's CE Index value
; 577  :     U16         child_index;        // Child's CE Index value
; 578  :     U16         sibling_index;      // Sibling's SDE Index value
; 579  :     U16         max_index;          // Maximum Index value
; 580  :     U16         children;           // Counts children
; 581  :     U8          ccnum, scnum, byt;  // (work variables)
; 582  :     U8          eodst, flag;        // (work flags)
; 583  :     U8          bits;               // Number of bits per index
; 584  :     U8          wrk[ MAX_SYMLEN ];  // (work buffer)
; 585  : 
; 586  :     bits       = 8 + pCMPSCBLK->cdss;

  00026	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0002e	0f b6 40 44	 movzx	 eax, BYTE PTR [rax+68]
  00032	83 c0 08	 add	 eax, 8
  00035	88 44 24 30	 mov	 BYTE PTR bits$[rsp], al

; 587  :     max_index  = (0xFFFF >> (16 - bits));

  00039	0f b6 44 24 30	 movzx	 eax, BYTE PTR bits$[rsp]
  0003e	b9 10 00 00 00	 mov	 ecx, 16
  00043	2b c8		 sub	 ecx, eax
  00045	8b c1		 mov	 eax, ecx
  00047	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0004c	89 8c 24 18 01
	00 00		 mov	 DWORD PTR tv1111[rsp], ecx
  00053	0f b6 c8	 movzx	 ecx, al
  00056	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR tv1111[rsp]
  0005d	d3 f8		 sar	 eax, cl
  0005f	66 89 44 24 58	 mov	 WORD PTR max_index$[rsp], ax

; 588  :     pPutGetCBN = ARCH_DEP( PutGetCBNTab    )[ pCMPSCBLK->cdss - 1 ];

  00064	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0006c	0f b6 40 44	 movzx	 eax, BYTE PTR [rax+68]
  00070	ff c8		 dec	 eax
  00072	48 98		 cdqe
  00074	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:z900_PutGetCBNTab
  0007b	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0007f	48 89 44 24 40	 mov	 QWORD PTR pPutGetCBN$[rsp], rax

; 589  :     ppPutIndex = ARCH_DEP( PutIndexCDSSTab )[ pCMPSCBLK->cdss - 1 ];

  00084	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0008c	0f b6 40 44	 movzx	 eax, BYTE PTR [rax+68]
  00090	ff c8		 dec	 eax
  00092	48 98		 cdqe
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:z900_PutIndexCDSSTab
  0009b	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0009f	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR ppPutIndex$[rsp], rax

; 590  :     pPutIndex  = ppPutIndex[ pCMPSCBLK->cbn ];

  000a7	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  000af	0f b6 40 45	 movzx	 eax, BYTE PTR [rax+69]
  000b3	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR ppPutIndex$[rsp]
  000bb	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  000bf	48 89 44 24 38	 mov	 QWORD PTR pPutIndex$[rsp], rax

; 591  :     pSymTab    = pCMPSCBLK->st ? pCMPSCBLK->pDict + ((U32)pCMPSCBLK->stt << 7) : 0;

  000c4	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  000cc	0f b6 40 42	 movzx	 eax, BYTE PTR [rax+66]
  000d0	85 c0		 test	 eax, eax
  000d2	74 27		 je	 SHORT $LN63@z900_cmpsc
  000d4	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  000dc	0f b7 40 3c	 movzx	 eax, WORD PTR [rax+60]
  000e0	c1 e0 07	 shl	 eax, 7
  000e3	8b c0		 mov	 eax, eax
  000e5	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  000ed	48 03 41 30	 add	 rax, QWORD PTR [rcx+48]
  000f1	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv129[rsp], rax
  000f9	eb 0c		 jmp	 SHORT $LN64@z900_cmpsc
$LN63@z900_cmpsc:
  000fb	48 c7 84 24 48
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv129[rsp], 0
$LN64@z900_cmpsc:
  00107	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR tv129[rsp]
  0010f	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR pSymTab$[rsp], rax

; 592  :     pGetSD     = pCMPSCBLK->f1 ? ARCH_DEP( GetSD1 ) : ARCH_DEP( GetSD0 );

  00117	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0011f	0f b6 40 43	 movzx	 eax, BYTE PTR [rax+67]
  00123	85 c0		 test	 eax, eax
  00125	74 11		 je	 SHORT $LN65@z900_cmpsc
  00127	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:z900_GetSD1
  0012e	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv133[rsp], rax
  00136	eb 0f		 jmp	 SHORT $LN66@z900_cmpsc
$LN65@z900_cmpsc:
  00138	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:z900_GetSD0
  0013f	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv133[rsp], rax
$LN66@z900_cmpsc:
  00147	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR tv133[rsp]
  0014f	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR pGetSD$[rsp], rax

; 593  : 
; 594  : #define PUTSETCBN()     pCMPSCBLK->cbn = pPutGetCBN( pPutIndex )
; 595  : 
; 596  :     memset( &dctblk,  0, sizeof( dctblk ) );

  00157	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR dctblk$[rsp]
  0015f	48 8b f8	 mov	 rdi, rax
  00162	33 c0		 xor	 eax, eax
  00164	b9 18 01 00 00	 mov	 ecx, 280		; 00000118H
  00169	f3 aa		 rep stosb

; 597  :     memset( &dctblk2, 0, sizeof( dctblk ) );

  0016b	48 8d 84 24 b0
	02 00 00	 lea	 rax, QWORD PTR dctblk2$[rsp]
  00173	48 8b f8	 mov	 rdi, rax
  00176	33 c0		 xor	 eax, eax
  00178	b9 18 01 00 00	 mov	 ecx, 280		; 00000118H
  0017d	f3 aa		 rep stosb

; 598  : 
; 599  :     dctblk.regs       = pCMPSCBLK->regs;

  0017f	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00187	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0018b	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR dctblk$[rsp], rax

; 600  :     dctblk.arn        = pCMPSCBLK->r2;

  00193	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0019b	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  0019f	89 84 24 a0 02
	00 00		 mov	 DWORD PTR dctblk$[rsp+272], eax

; 601  :     dctblk.pkey       = pCMPSCBLK->regs->psw.pkey;

  001a6	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  001ae	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001b2	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  001b6	88 84 24 a4 02
	00 00		 mov	 BYTE PTR dctblk$[rsp+276], al

; 602  :     dctblk.pDict      = pCMPSCBLK->pDict;

  001bd	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  001c5	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  001c9	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR dctblk$[rsp+8], rax

; 603  : 
; 604  :     dctblk2.regs      = pCMPSCBLK->regs;

  001d1	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  001d9	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001dd	48 89 84 24 b0
	02 00 00	 mov	 QWORD PTR dctblk2$[rsp], rax

; 605  :     dctblk2.arn       = pCMPSCBLK->r2;

  001e5	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  001ed	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  001f1	89 84 24 c0 03
	00 00		 mov	 DWORD PTR dctblk2$[rsp+272], eax

; 606  :     dctblk2.pkey      = pCMPSCBLK->regs->psw.pkey;

  001f8	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00200	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00204	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00208	88 84 24 c4 03
	00 00		 mov	 BYTE PTR dctblk2$[rsp+276], al

; 607  :     dctblk2.pDict     = pCMPSCBLK->pDict + g_nDictSize[ pCMPSCBLK->cdss - 1 ];

  0020f	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00217	0f b6 40 44	 movzx	 eax, BYTE PTR [rax+68]
  0021b	ff c8		 dec	 eax
  0021d	48 98		 cdqe
  0021f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_nDictSize
  00226	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00229	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00231	48 03 41 30	 add	 rax, QWORD PTR [rcx+48]
  00235	48 89 84 24 b8
	02 00 00	 mov	 QWORD PTR dctblk2$[rsp+8], rax

; 608  : 
; 609  :     cceblk.pDCTBLK    = &dctblk;

  0023d	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR dctblk$[rsp]
  00245	48 89 84 24 d0
	03 00 00	 mov	 QWORD PTR cceblk$[rsp], rax

; 610  :     cceblk.max_index  = max_index;

  0024d	0f b7 44 24 58	 movzx	 eax, WORD PTR max_index$[rsp]
  00252	66 89 84 24 e0
	03 00 00	 mov	 WORD PTR cceblk$[rsp+16], ax

; 611  :     cceblk.pCCE       = NULL;           // (filled in before each call)

  0025a	48 c7 84 24 d8
	03 00 00 00 00
	00 00		 mov	 QWORD PTR cceblk$[rsp+8], 0

; 612  : 
; 613  :     memset( &cceblk.cce, 0, sizeof( cceblk.cce ) );

  00266	48 8d 84 24 e8
	03 00 00	 lea	 rax, QWORD PTR cceblk$[rsp+24]
  0026e	48 8b f8	 mov	 rdi, rax
  00271	33 c0		 xor	 eax, eax
  00273	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00278	f3 aa		 rep stosb

; 614  : 
; 615  :     sdeblk.pDCTBLK    = &dctblk;

  0027a	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR dctblk$[rsp]
  00282	48 89 84 24 f0
	03 04 00	 mov	 QWORD PTR sdeblk$[rsp], rax

; 616  :     sdeblk.pDCTBLK2   = &dctblk2;

  0028a	48 8d 84 24 b0
	02 00 00	 lea	 rax, QWORD PTR dctblk2$[rsp]
  00292	48 89 84 24 f8
	03 04 00	 mov	 QWORD PTR sdeblk$[rsp+8], rax

; 617  :     sdeblk.pSDE       = &sibling;

  0029a	48 8d 84 24 10
	04 07 00	 lea	 rax, QWORD PTR sibling$[rsp]
  002a2	48 89 84 24 00
	04 04 00	 mov	 QWORD PTR sdeblk$[rsp+16], rax

; 618  :     sdeblk.pCCE       = NULL;           // (depends if first sibling)

  002aa	48 c7 84 24 08
	04 04 00 00 00
	00 00		 mov	 QWORD PTR sdeblk$[rsp+24], 0

; 619  : 
; 620  :     memset( &sdeblk.sde, 0, sizeof( sdeblk.sde ) );

  002b6	48 8d 84 24 10
	04 04 00	 lea	 rax, QWORD PTR sdeblk$[rsp+32]
  002be	48 8b f8	 mov	 rdi, rax
  002c1	33 c0		 xor	 eax, eax
  002c3	b9 00 00 03 00	 mov	 ecx, 196608		; 00030000H
  002c8	f3 aa		 rep stosb

; 621  : 
; 622  :     piblk.ppPutIndex  = (void**) &pPutIndex;

  002ca	48 8d 44 24 38	 lea	 rax, QWORD PTR pPutIndex$[rsp]
  002cf	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR piblk$[rsp+16], rax

; 623  :     piblk.pCMPSCBLK   = pCMPSCBLK;

  002d7	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  002df	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR piblk$[rsp], rax

; 624  :     piblk.pMEMBLK     = &op1blk;        // (we put indexes into op-1)

  002e7	48 8d 84 24 e8
	00 00 00	 lea	 rax, QWORD PTR op1blk$[rsp]
  002ef	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR piblk$[rsp+8], rax

; 625  :     piblk.index       = 0;              // (filled in before each call)

  002f7	33 c0		 xor	 eax, eax
  002f9	66 89 84 24 78
	01 00 00	 mov	 WORD PTR piblk$[rsp+24], ax

; 626  : 
; 627  :     op1blk.arn        = pCMPSCBLK->r1;

  00301	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00309	0f b6 40 40	 movzx	 eax, BYTE PTR [rax+64]
  0030d	89 84 24 08 01
	00 00		 mov	 DWORD PTR op1blk$[rsp+32], eax

; 628  :     op1blk.regs       = pCMPSCBLK->regs;

  00314	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0031c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00320	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR op1blk$[rsp], rax

; 629  :     op1blk.pkey       = pCMPSCBLK->regs->psw.pkey;

  00328	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00330	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00334	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00338	88 84 24 0c 01
	00 00		 mov	 BYTE PTR op1blk$[rsp+36], al

; 630  :     op1blk.vpagebeg   = 0;

  0033f	48 c7 84 24 f0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR op1blk$[rsp+8], 0

; 631  :     op1blk.maddr[0]   = 0;

  0034b	b8 08 00 00 00	 mov	 eax, 8
  00350	48 6b c0 00	 imul	 rax, rax, 0
  00354	48 c7 84 04 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR op1blk$[rsp+rax+16], 0

; 632  :     op1blk.maddr[1]   = 0;

  00360	b8 08 00 00 00	 mov	 eax, 8
  00365	48 6b c0 01	 imul	 rax, rax, 1
  00369	48 c7 84 04 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR op1blk$[rsp+rax+16], 0

; 633  : 
; 634  :     op2blk.arn        = pCMPSCBLK->r2;

  00375	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0037d	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  00381	89 84 24 40 01
	00 00		 mov	 DWORD PTR op2blk$[rsp+32], eax

; 635  :     op2blk.regs       = pCMPSCBLK->regs;

  00388	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00390	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00394	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR op2blk$[rsp], rax

; 636  :     op2blk.pkey       = pCMPSCBLK->regs->psw.pkey;

  0039c	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  003a4	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  003a8	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  003ac	88 84 24 44 01
	00 00		 mov	 BYTE PTR op2blk$[rsp+36], al

; 637  :     op2blk.vpagebeg   = 0;

  003b3	48 c7 84 24 28
	01 00 00 00 00
	00 00		 mov	 QWORD PTR op2blk$[rsp+8], 0

; 638  :     op2blk.maddr[0]   = 0;

  003bf	b8 08 00 00 00	 mov	 eax, 8
  003c4	48 6b c0 00	 imul	 rax, rax, 0
  003c8	48 c7 84 04 30
	01 00 00 00 00
	00 00		 mov	 QWORD PTR op2blk$[rsp+rax+16], 0

; 639  :     op2blk.maddr[1]   = 0;

  003d4	b8 08 00 00 00	 mov	 eax, 8
  003d9	48 6b c0 01	 imul	 rax, rax, 1
  003dd	48 c7 84 04 30
	01 00 00 00 00
	00 00		 mov	 QWORD PTR op2blk$[rsp+rax+16], 0

; 640  : 
; 641  :     // GET STARTED...
; 642  : 
; 643  :     pBegOp2  =  pCMPSCBLK->pOp2;

  003e9	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  003f1	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  003f5	48 89 44 24 50	 mov	 QWORD PTR pBegOp2$[rsp], rax

; 644  :     eodst    =  (pCMPSCBLK->nLen1 < (2 + ((pCMPSCBLK->cbn > (16 - bits)) ? 1 : 0)))

  003fa	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00402	0f b6 40 45	 movzx	 eax, BYTE PTR [rax+69]
  00406	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR bits$[rsp]
  0040b	ba 10 00 00 00	 mov	 edx, 16
  00410	2b d1		 sub	 edx, ecx
  00412	8b ca		 mov	 ecx, edx
  00414	3b c1		 cmp	 eax, ecx
  00416	7e 0d		 jle	 SHORT $LN67@z900_cmpsc
  00418	c7 84 24 d8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv259[rsp], 1
  00423	eb 0b		 jmp	 SHORT $LN68@z900_cmpsc
$LN67@z900_cmpsc:
  00425	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv259[rsp], 0
$LN68@z900_cmpsc:
  00430	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR tv259[rsp]
  00437	83 c0 02	 add	 eax, 2
  0043a	48 98		 cdqe
  0043c	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00444	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00447	73 0d		 jae	 SHORT $LN69@z900_cmpsc
  00449	c7 84 24 dc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv263[rsp], 1
  00454	eb 0b		 jmp	 SHORT $LN70@z900_cmpsc
$LN69@z900_cmpsc:
  00456	c7 84 24 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv263[rsp], 0
$LN70@z900_cmpsc:
  00461	0f b6 84 24 dc
	00 00 00	 movzx	 eax, BYTE PTR tv263[rsp]
  00469	88 44 24 23	 mov	 BYTE PTR eodst$[rsp], al

; 645  :              ?  TRUE : FALSE;
; 646  :     nCPUAmt  =  0;

  0046d	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR nCPUAmt$[rsp], 0
$LN173@z900_cmpsc:
$cmp1$178:

; 647  : 
; 648  :     //-------------------------------------------------------------------------
; 649  :     // PROGRAMMING NOTE: the following compression algorithm follows exactly
; 650  :     // the algorithm documented by IBM in their Principles of Operation manual.
; 651  :     // Most labels and all primary comments match the algorithm's flowchart.
; 652  :     //-------------------------------------------------------------------------
; 653  : 
; 654  : cmp1:
; 655  : 
; 656  :     // Another SRC char exists?
; 657  :     // No, set CC0 and endop.
; 658  : 
; 659  :     if (unlikely( !pCMPSCBLK->nLen2 ))

  00476	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0047e	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00483	75 0d		 jne	 SHORT $LN71@z900_cmpsc
  00485	c7 84 24 e0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv267[rsp], 1
  00490	eb 0b		 jmp	 SHORT $LN72@z900_cmpsc
$LN71@z900_cmpsc:
  00492	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv267[rsp], 0
$LN72@z900_cmpsc:
  0049d	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR tv267[rsp], 0
  004a5	74 0d		 je	 SHORT $LN75@z900_cmpsc
  004a7	c7 84 24 e4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv273[rsp], 1
  004b2	eb 0b		 jmp	 SHORT $LN76@z900_cmpsc
$LN75@z900_cmpsc:
  004b4	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv273[rsp], 0
$LN76@z900_cmpsc:
  004bf	83 bc 24 e4 00
	00 00 00	 cmp	 DWORD PTR tv273[rsp], 0
  004c7	74 2e		 je	 SHORT $LN8@z900_cmpsc

; 660  :     {
; 661  :         PUTSETCBN();

  004c9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  004ce	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  004d2	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  004da	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 662  :         RETCC0( &op1blk );

  004dd	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  004e5	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  004ed	e8 00 00 00 00	 call	 z900_CC0
  004f2	e9 e4 11 00 00	 jmp	 $LN1@z900_cmpsc
$LN8@z900_cmpsc:
$cmp2$179:

; 663  :     }
; 664  : 
; 665  : cmp2:
; 666  : 
; 667  :     // Another DST index position exists?
; 668  :     // No, set CC1 and endop.
; 669  : 
; 670  :     if (unlikely( eodst ))

  004f7	0f b6 44 24 23	 movzx	 eax, BYTE PTR eodst$[rsp]
  004fc	85 c0		 test	 eax, eax
  004fe	74 0a		 je	 SHORT $LN79@z900_cmpsc
  00500	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv287[rsp], 1
  00508	eb 08		 jmp	 SHORT $LN80@z900_cmpsc
$LN79@z900_cmpsc:
  0050a	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv287[rsp], 0
$LN80@z900_cmpsc:
  00512	83 7c 24 5c 00	 cmp	 DWORD PTR tv287[rsp], 0
  00517	74 2e		 je	 SHORT $LN9@z900_cmpsc

; 671  :     {
; 672  :         PUTSETCBN();

  00519	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  0051e	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  00522	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0052a	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 673  :         RETCC1( &op1blk );

  0052d	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  00535	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0053d	e8 00 00 00 00	 call	 z900_CC1
  00542	e9 94 11 00 00	 jmp	 $LN1@z900_cmpsc
$LN9@z900_cmpsc:

; 674  :     }
; 675  : 
; 676  :     if (unlikely( nCPUAmt >= (U64) pCMPSCBLK->nCPUAmt ))  // (max bytes processed?)

  00547	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0054f	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00552	48 39 44 24 48	 cmp	 QWORD PTR nCPUAmt$[rsp], rax
  00557	72 0a		 jb	 SHORT $LN83@z900_cmpsc
  00559	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv303[rsp], 1
  00561	eb 08		 jmp	 SHORT $LN84@z900_cmpsc
$LN83@z900_cmpsc:
  00563	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv303[rsp], 0
$LN84@z900_cmpsc:
  0056b	83 7c 24 60 00	 cmp	 DWORD PTR tv303[rsp], 0
  00570	74 2e		 je	 SHORT $LN10@z900_cmpsc

; 677  :     {
; 678  :         PUTSETCBN();

  00572	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  00577	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  0057b	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00583	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 679  :         RETCC3( &op1blk );                                // (return cc3 to caller)

  00586	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  0058e	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00596	e8 00 00 00 00	 call	 z900_CC3
  0059b	e9 3b 11 00 00	 jmp	 $LN1@z900_cmpsc
$LN10@z900_cmpsc:

; 680  :     }
; 681  : 
; 682  :     children = 0;

  005a0	33 c0		 xor	 eax, eax
  005a2	66 89 44 24 2c	 mov	 WORD PTR children$[rsp], ax

; 683  : 
; 684  :     // Use next SRC char as index of alphabet entry.
; 685  :     // Call this entry the parent.
; 686  :     // Advance 1 byte in SRC.
; 687  : 
; 688  :     parent_index = (U16) fetch_op_b( pCMPSCBLK->pOp2, &op2blk );

  005a7	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR op2blk$[rsp]
  005af	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  005b7	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  005bb	e8 00 00 00 00	 call	 z900_cmpsc_vfetchb
  005c0	0f b6 c0	 movzx	 eax, al
  005c3	66 89 44 24 24	 mov	 WORD PTR parent_index$[rsp], ax

; 689  : 
; 690  :     cceblk.pCCE = &parent;

  005c8	48 8d 84 24 28
	04 07 00	 lea	 rax, QWORD PTR parent$[rsp]
  005d0	48 89 84 24 d8
	03 00 00	 mov	 QWORD PTR cceblk$[rsp+8], rax

; 691  :     if (unlikely( !ARCH_DEP( GetCCE )( parent_index, &cceblk )))

  005d8	48 8d 94 24 d0
	03 00 00	 lea	 rdx, QWORD PTR cceblk$[rsp]
  005e0	0f b7 4c 24 24	 movzx	 ecx, WORD PTR parent_index$[rsp]
  005e5	e8 00 00 00 00	 call	 z900_GetCCE
  005ea	0f b6 c0	 movzx	 eax, al
  005ed	85 c0		 test	 eax, eax
  005ef	75 0a		 jne	 SHORT $LN85@z900_cmpsc
  005f1	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv321[rsp], 1
  005f9	eb 08		 jmp	 SHORT $LN86@z900_cmpsc
$LN85@z900_cmpsc:
  005fb	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv321[rsp], 0
$LN86@z900_cmpsc:
  00603	83 7c 24 64 00	 cmp	 DWORD PTR tv321[rsp], 0
  00608	74 0a		 je	 SHORT $LN89@z900_cmpsc
  0060a	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv330[rsp], 1
  00612	eb 08		 jmp	 SHORT $LN90@z900_cmpsc
$LN89@z900_cmpsc:
  00614	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv330[rsp], 0
$LN90@z900_cmpsc:
  0061c	83 7c 24 68 00	 cmp	 DWORD PTR tv330[rsp], 0
  00621	74 2e		 je	 SHORT $LN11@z900_cmpsc

; 692  :     {
; 693  :         PUTSETCBN();

  00623	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  00628	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  0062c	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00634	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 694  :         RETERR( &op1blk );

  00637	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  0063f	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00647	e8 00 00 00 00	 call	 z900_ERR
  0064c	e9 8a 10 00 00	 jmp	 $LN1@z900_cmpsc
$LN11@z900_cmpsc:

; 695  :     }
; 696  : 
; 697  :     nCPUAmt++;

  00651	48 8b 44 24 48	 mov	 rax, QWORD PTR nCPUAmt$[rsp]
  00656	48 ff c0	 inc	 rax
  00659	48 89 44 24 48	 mov	 QWORD PTR nCPUAmt$[rsp], rax

; 698  :     pCMPSCBLK->pOp2++;

  0065e	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00666	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0066a	48 ff c0	 inc	 rax
  0066d	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00675	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 699  :     pCMPSCBLK->nLen2--;

  00679	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00681	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00685	48 ff c8	 dec	 rax
  00688	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00690	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
$LN174@z900_cmpsc:
$cmp3$180:
$LN4@z900_cmpsc:

; 700  : 
; 701  : cmp3:
; 702  : 
; 703  :     MEMBLK_BUMP( &op1blk, pCMPSCBLK->pOp1 );

  00694	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR op1blk$[rsp+8]
  0069c	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  006a2	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  006aa	48 39 41 20	 cmp	 QWORD PTR [rcx+32], rax
  006ae	73 0a		 jae	 SHORT $LN93@z900_cmpsc
  006b0	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv355[rsp], 1
  006b8	eb 08		 jmp	 SHORT $LN94@z900_cmpsc
$LN93@z900_cmpsc:
  006ba	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv355[rsp], 0
$LN94@z900_cmpsc:
  006c2	83 7c 24 6c 00	 cmp	 DWORD PTR tv355[rsp], 0
  006c7	75 4d		 jne	 SHORT $LN12@z900_cmpsc
  006c9	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR op1blk$[rsp+8]
  006d1	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  006d7	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR op1blk$[rsp+8], rax
  006df	b8 08 00 00 00	 mov	 eax, 8
  006e4	48 6b c0 01	 imul	 rax, rax, 1
  006e8	b9 08 00 00 00	 mov	 ecx, 8
  006ed	48 6b c9 00	 imul	 rcx, rcx, 0
  006f1	48 8b 84 04 f8
	00 00 00	 mov	 rax, QWORD PTR op1blk$[rsp+rax+16]
  006f9	48 89 84 0c f8
	00 00 00	 mov	 QWORD PTR op1blk$[rsp+rcx+16], rax
  00701	b8 08 00 00 00	 mov	 eax, 8
  00706	48 6b c0 01	 imul	 rax, rax, 1
  0070a	48 c7 84 04 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR op1blk$[rsp+rax+16], 0
$LN12@z900_cmpsc:
  00716	33 c0		 xor	 eax, eax
  00718	85 c0		 test	 eax, eax
  0071a	0f 85 74 ff ff
	ff		 jne	 $LN4@z900_cmpsc
$LN7@z900_cmpsc:

; 704  :     MEMBLK_BUMP( &op2blk, pCMPSCBLK->pOp2 );

  00720	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR op2blk$[rsp+8]
  00728	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  0072e	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00736	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  0073a	73 0a		 jae	 SHORT $LN97@z900_cmpsc
  0073c	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv373[rsp], 1
  00744	eb 08		 jmp	 SHORT $LN98@z900_cmpsc
$LN97@z900_cmpsc:
  00746	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv373[rsp], 0
$LN98@z900_cmpsc:
  0074e	83 7c 24 70 00	 cmp	 DWORD PTR tv373[rsp], 0
  00753	75 4d		 jne	 SHORT $LN13@z900_cmpsc
  00755	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR op2blk$[rsp+8]
  0075d	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00763	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR op2blk$[rsp+8], rax
  0076b	b8 08 00 00 00	 mov	 eax, 8
  00770	48 6b c0 01	 imul	 rax, rax, 1
  00774	b9 08 00 00 00	 mov	 ecx, 8
  00779	48 6b c9 00	 imul	 rcx, rcx, 0
  0077d	48 8b 84 04 30
	01 00 00	 mov	 rax, QWORD PTR op2blk$[rsp+rax+16]
  00785	48 89 84 0c 30
	01 00 00	 mov	 QWORD PTR op2blk$[rsp+rcx+16], rax
  0078d	b8 08 00 00 00	 mov	 eax, 8
  00792	48 6b c0 01	 imul	 rax, rax, 1
  00796	48 c7 84 04 30
	01 00 00 00 00
	00 00		 mov	 QWORD PTR op2blk$[rsp+rax+16], 0
$LN13@z900_cmpsc:
  007a2	33 c0		 xor	 eax, eax
  007a4	85 c0		 test	 eax, eax
  007a6	0f 85 74 ff ff
	ff		 jne	 $LN7@z900_cmpsc

; 705  : 
; 706  :     // CCT=0?
; 707  :     // Yes, goto cmp9;
; 708  : 
; 709  :     if (!parent.cct)

  007ac	0f b6 84 24 3e
	04 07 00	 movzx	 eax, BYTE PTR parent$[rsp+22]
  007b4	85 c0		 test	 eax, eax
  007b6	75 05		 jne	 SHORT $LN14@z900_cmpsc

; 710  :         goto cmp9;

  007b8	e9 14 06 00 00	 jmp	 $cmp9$181
$LN14@z900_cmpsc:

; 711  : 
; 712  : //cmp4:
; 713  : 
; 714  :     ccnum = 0;

  007bd	c6 44 24 21 00	 mov	 BYTE PTR ccnum$[rsp], 0

; 715  : 
; 716  :     // Set flag=1.
; 717  : 
; 718  :     flag = TRUE;

  007c2	c6 44 24 31 01	 mov	 BYTE PTR flag$[rsp], 1

; 719  : 
; 720  :     // Another SRC char exists?
; 721  :     // No, goto cmp13;
; 722  : 
; 723  :     if (unlikely( !pCMPSCBLK->nLen2 ))

  007c7	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  007cf	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  007d4	75 0a		 jne	 SHORT $LN99@z900_cmpsc
  007d6	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv387[rsp], 1
  007de	eb 08		 jmp	 SHORT $LN100@z900_cmpsc
$LN99@z900_cmpsc:
  007e0	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv387[rsp], 0
$LN100@z900_cmpsc:
  007e8	83 7c 24 74 00	 cmp	 DWORD PTR tv387[rsp], 0
  007ed	74 0a		 je	 SHORT $LN103@z900_cmpsc
  007ef	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv393[rsp], 1
  007f7	eb 08		 jmp	 SHORT $LN104@z900_cmpsc
$LN103@z900_cmpsc:
  007f9	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv393[rsp], 0
$LN104@z900_cmpsc:
  00801	83 7c 24 78 00	 cmp	 DWORD PTR tv393[rsp], 0
  00806	74 05		 je	 SHORT $LN15@z900_cmpsc

; 724  :         goto cmp13;

  00808	e9 f5 0a 00 00	 jmp	 $cmp13$182
$LN15@z900_cmpsc:
$LN175@z900_cmpsc:
$cmp5$183:

; 725  : 
; 726  :     // (REPEAT FOR EACH CC)...
; 727  : 
; 728  : cmp5:
; 729  : 
; 730  :     // ---------------- UNROLL #1 ----------------
; 731  : 
; 732  :     // Next SRC char = CC?
; 733  :     // Yes, goto cmp10;
; 734  : 
; 735  :     byt = fetch_op_b( pCMPSCBLK->pOp2, &op2blk );

  0080d	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR op2blk$[rsp]
  00815	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0081d	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00821	e8 00 00 00 00	 call	 z900_cmpsc_vfetchb
  00826	88 44 24 22	 mov	 BYTE PTR byt$[rsp], al

; 736  : 
; 737  :     if (byt == parent.cc[ ccnum ])

  0082a	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  0082f	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR ccnum$[rsp]
  00834	0f b6 8c 0c 30
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+rcx+8]
  0083c	3b c1		 cmp	 eax, ecx
  0083e	75 05		 jne	 SHORT $LN16@z900_cmpsc

; 738  :         goto cmp10;

  00840	e9 c2 06 00 00	 jmp	 $cmp10$184
$LN16@z900_cmpsc:

; 739  : 
; 740  :     // Set flag=0;
; 741  :     flag = FALSE;

  00845	c6 44 24 31 00	 mov	 BYTE PTR flag$[rsp], 0

; 742  : 
; 743  :     // Another CC?
; 744  :     // Yes, goto cmp5;
; 745  : 
; 746  :     if (++ccnum >= parent.cct)

  0084a	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  0084f	fe c0		 inc	 al
  00851	88 44 24 21	 mov	 BYTE PTR ccnum$[rsp], al
  00855	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  0085a	0f b6 8c 24 3e
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+22]
  00862	3b c1		 cmp	 eax, ecx
  00864	7c 05		 jl	 SHORT $LN17@z900_cmpsc

; 747  :         goto cmp5E;

  00866	e9 ea 00 00 00	 jmp	 $cmp5E$185
$LN17@z900_cmpsc:

; 748  : 
; 749  :     // ---------------- UNROLL #2 ----------------
; 750  : 
; 751  :     // Next SRC char = CC?
; 752  :     // Yes, goto cmp10;
; 753  : 
; 754  :     if (byt == parent.cc[ ccnum ])

  0086b	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  00870	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR ccnum$[rsp]
  00875	0f b6 8c 0c 30
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+rcx+8]
  0087d	3b c1		 cmp	 eax, ecx
  0087f	75 05		 jne	 SHORT $LN18@z900_cmpsc

; 755  :         goto cmp10;

  00881	e9 81 06 00 00	 jmp	 $cmp10$184
$LN18@z900_cmpsc:

; 756  : 
; 757  :     // Set flag=0;
; 758  : //  flag = FALSE;   // (already done by UNROLL #1)
; 759  : 
; 760  :     // Another CC?
; 761  :     // Yes, goto cmp5;
; 762  : 
; 763  :     if (++ccnum >= parent.cct)

  00886	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  0088b	fe c0		 inc	 al
  0088d	88 44 24 21	 mov	 BYTE PTR ccnum$[rsp], al
  00891	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  00896	0f b6 8c 24 3e
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+22]
  0089e	3b c1		 cmp	 eax, ecx
  008a0	7c 05		 jl	 SHORT $LN19@z900_cmpsc

; 764  :         goto cmp5E;

  008a2	e9 ae 00 00 00	 jmp	 $cmp5E$185
$LN19@z900_cmpsc:

; 765  : 
; 766  :     // ---------------- UNROLL #3 ----------------
; 767  : 
; 768  :     // Next SRC char = CC?
; 769  :     // Yes, goto cmp10;
; 770  : 
; 771  :     if (byt == parent.cc[ ccnum ])

  008a7	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  008ac	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR ccnum$[rsp]
  008b1	0f b6 8c 0c 30
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+rcx+8]
  008b9	3b c1		 cmp	 eax, ecx
  008bb	75 05		 jne	 SHORT $LN20@z900_cmpsc

; 772  :         goto cmp10;

  008bd	e9 45 06 00 00	 jmp	 $cmp10$184
$LN20@z900_cmpsc:

; 773  : 
; 774  :     // Set flag=0;
; 775  : //  flag = FALSE;   // (already done by UNROLL #1)
; 776  : 
; 777  :     // Another CC?
; 778  :     // Yes, goto cmp5;
; 779  : 
; 780  :     if (++ccnum >= parent.cct)

  008c2	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  008c7	fe c0		 inc	 al
  008c9	88 44 24 21	 mov	 BYTE PTR ccnum$[rsp], al
  008cd	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  008d2	0f b6 8c 24 3e
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+22]
  008da	3b c1		 cmp	 eax, ecx
  008dc	7c 02		 jl	 SHORT $LN21@z900_cmpsc

; 781  :         goto cmp5E;

  008de	eb 75		 jmp	 SHORT $cmp5E$185
$LN21@z900_cmpsc:

; 782  : 
; 783  :     // ---------------- UNROLL #4 ----------------
; 784  : 
; 785  :     // Next SRC char = CC?
; 786  :     // Yes, goto cmp10;
; 787  : 
; 788  :     if (byt == parent.cc[ ccnum ])

  008e0	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  008e5	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR ccnum$[rsp]
  008ea	0f b6 8c 0c 30
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+rcx+8]
  008f2	3b c1		 cmp	 eax, ecx
  008f4	75 05		 jne	 SHORT $LN22@z900_cmpsc

; 789  :         goto cmp10;

  008f6	e9 0c 06 00 00	 jmp	 $cmp10$184
$LN22@z900_cmpsc:

; 790  : 
; 791  :     // Set flag=0;
; 792  : //  flag = FALSE;   // (already done by UNROLL #1)
; 793  : 
; 794  :     // Another CC?
; 795  :     // Yes, goto cmp5;
; 796  : 
; 797  :     if (++ccnum >= parent.cct)

  008fb	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  00900	fe c0		 inc	 al
  00902	88 44 24 21	 mov	 BYTE PTR ccnum$[rsp], al
  00906	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  0090b	0f b6 8c 24 3e
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+22]
  00913	3b c1		 cmp	 eax, ecx
  00915	7c 02		 jl	 SHORT $LN23@z900_cmpsc

; 798  :         goto cmp5E;

  00917	eb 3c		 jmp	 SHORT $cmp5E$185
$LN23@z900_cmpsc:

; 799  : 
; 800  :     // ---------------- UNROLL #5 ----------------
; 801  : 
; 802  :     // Next SRC char = CC?
; 803  :     // Yes, goto cmp10;
; 804  : 
; 805  :     if (byt == parent.cc[ ccnum ])

  00919	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  0091e	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR ccnum$[rsp]
  00923	0f b6 8c 0c 30
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+rcx+8]
  0092b	3b c1		 cmp	 eax, ecx
  0092d	75 05		 jne	 SHORT $LN24@z900_cmpsc

; 806  :         goto cmp10;

  0092f	e9 d3 05 00 00	 jmp	 $cmp10$184
$LN24@z900_cmpsc:

; 807  : 
; 808  :     // Set flag=0;
; 809  : //  flag = FALSE;   // (already done by UNROLL #1)
; 810  : 
; 811  :     // Another CC?
; 812  :     // Yes, goto cmp5;
; 813  : 
; 814  :     if (++ccnum < parent.cct)   // (** last UNROLL **)

  00934	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  00939	fe c0		 inc	 al
  0093b	88 44 24 21	 mov	 BYTE PTR ccnum$[rsp], al
  0093f	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  00944	0f b6 8c 24 3e
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+22]
  0094c	3b c1		 cmp	 eax, ecx
  0094e	7d 05		 jge	 SHORT $LN25@z900_cmpsc

; 815  :         goto cmp5;

  00950	e9 b8 fe ff ff	 jmp	 $cmp5$183
$LN25@z900_cmpsc:
$cmp5E$185:

; 816  : 
; 817  : cmp5E:
; 818  : 
; 819  :     // CCT indicates more children?
; 820  :     // No, goto cmp8;
; 821  : 
; 822  :     if (!parent.mc)

  00955	0f b6 84 24 40
	04 07 00	 movzx	 eax, BYTE PTR parent$[rsp+24]
  0095d	85 c0		 test	 eax, eax
  0095f	75 05		 jne	 SHORT $LN26@z900_cmpsc

; 823  :         goto cmp8;

  00961	e9 35 03 00 00	 jmp	 $cmp8$186
$LN26@z900_cmpsc:

; 824  : 
; 825  : //cmp6:
; 826  : 
; 827  :     // Set SD index = CPTR + #of CC's.
; 828  : 
; 829  :     sibling_index = (parent.cptr + parent.cct);

  00966	0f b7 84 24 38
	04 07 00	 movzx	 eax, WORD PTR parent$[rsp+16]
  0096e	0f b6 8c 24 3e
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+22]
  00976	03 c1		 add	 eax, ecx
  00978	66 89 44 24 34	 mov	 WORD PTR sibling_index$[rsp], ax

; 830  : 
; 831  :     sdeblk.pCCE = &parent;

  0097d	48 8d 84 24 28
	04 07 00	 lea	 rax, QWORD PTR parent$[rsp]
  00985	48 89 84 24 08
	04 04 00	 mov	 QWORD PTR sdeblk$[rsp+24], rax

; 832  :     if (unlikely( !pGetSD( sibling_index, &sdeblk )))

  0098d	48 8d 94 24 f0
	03 04 00	 lea	 rdx, QWORD PTR sdeblk$[rsp]
  00995	0f b7 4c 24 34	 movzx	 ecx, WORD PTR sibling_index$[rsp]
  0099a	ff 94 24 58 01
	00 00		 call	 QWORD PTR pGetSD$[rsp]
  009a1	0f b6 c0	 movzx	 eax, al
  009a4	85 c0		 test	 eax, eax
  009a6	75 0a		 jne	 SHORT $LN105@z900_cmpsc
  009a8	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR tv460[rsp], 1
  009b0	eb 08		 jmp	 SHORT $LN106@z900_cmpsc
$LN105@z900_cmpsc:
  009b2	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv460[rsp], 0
$LN106@z900_cmpsc:
  009ba	83 7c 24 7c 00	 cmp	 DWORD PTR tv460[rsp], 0
  009bf	74 0d		 je	 SHORT $LN109@z900_cmpsc
  009c1	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv469[rsp], 1
  009cc	eb 0b		 jmp	 SHORT $LN110@z900_cmpsc
$LN109@z900_cmpsc:
  009ce	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv469[rsp], 0
$LN110@z900_cmpsc:
  009d9	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR tv469[rsp], 0
  009e1	74 2e		 je	 SHORT $LN27@z900_cmpsc

; 833  :     {
; 834  :         PUTSETCBN();

  009e3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  009e8	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  009ec	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  009f4	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 835  :         RETERR( &op1blk );

  009f7	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  009ff	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00a07	e8 00 00 00 00	 call	 z900_ERR
  00a0c	e9 ca 0c 00 00	 jmp	 $LN1@z900_cmpsc
$LN27@z900_cmpsc:

; 836  :     }
; 837  :     scnum = 0;

  00a11	c6 44 24 20 00	 mov	 BYTE PTR scnum$[rsp], 0
$LN176@z900_cmpsc:
$cmp7$187:

; 838  : 
; 839  :     // (REPEAT FOR EACH SC IN SD)...
; 840  : 
; 841  : cmp7:
; 842  : 
; 843  :     // ---------------- UNROLL #1 ----------------
; 844  : 
; 845  :     // Next SRC char = SC?
; 846  :     // Yes, goto cmp12;
; 847  : 
; 848  :     byt = fetch_op_b( pCMPSCBLK->pOp2, &op2blk );

  00a16	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR op2blk$[rsp]
  00a1e	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00a26	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00a2a	e8 00 00 00 00	 call	 z900_cmpsc_vfetchb
  00a2f	88 44 24 22	 mov	 BYTE PTR byt$[rsp], al

; 849  : 
; 850  :     if (byt == sibling.sc[ scnum ])

  00a33	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  00a38	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR scnum$[rsp]
  00a3d	0f b6 8c 0c 10
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+rcx]
  00a45	3b c1		 cmp	 eax, ecx
  00a47	75 05		 jne	 SHORT $LN28@z900_cmpsc

; 851  :         goto cmp12;

  00a49	e9 de 06 00 00	 jmp	 $cmp12$188
$LN28@z900_cmpsc:

; 852  : 
; 853  :     // Another SC?
; 854  :     // Yes, goto cmp7;
; 855  : 
; 856  :     if (++scnum >= sibling.sct)

  00a4e	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00a53	fe c0		 inc	 al
  00a55	88 44 24 20	 mov	 BYTE PTR scnum$[rsp], al
  00a59	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00a5e	0f b6 8c 24 22
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+18]
  00a66	3b c1		 cmp	 eax, ecx
  00a68	7c 05		 jl	 SHORT $LN29@z900_cmpsc

; 857  :         goto cmp7E;

  00a6a	e9 62 01 00 00	 jmp	 $cmp7E$189
$LN29@z900_cmpsc:

; 858  : 
; 859  :     // ---------------- UNROLL #2 ----------------
; 860  : 
; 861  :     // Next SRC char = SC?
; 862  :     // Yes, goto cmp12;
; 863  : 
; 864  :     if (byt == sibling.sc[ scnum ])

  00a6f	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  00a74	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR scnum$[rsp]
  00a79	0f b6 8c 0c 10
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+rcx]
  00a81	3b c1		 cmp	 eax, ecx
  00a83	75 05		 jne	 SHORT $LN30@z900_cmpsc

; 865  :         goto cmp12;

  00a85	e9 a2 06 00 00	 jmp	 $cmp12$188
$LN30@z900_cmpsc:

; 866  : 
; 867  :     // Another SC?
; 868  :     // Yes, goto cmp7;
; 869  : 
; 870  :     if (++scnum >= sibling.sct)

  00a8a	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00a8f	fe c0		 inc	 al
  00a91	88 44 24 20	 mov	 BYTE PTR scnum$[rsp], al
  00a95	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00a9a	0f b6 8c 24 22
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+18]
  00aa2	3b c1		 cmp	 eax, ecx
  00aa4	7c 05		 jl	 SHORT $LN31@z900_cmpsc

; 871  :         goto cmp7E;

  00aa6	e9 26 01 00 00	 jmp	 $cmp7E$189
$LN31@z900_cmpsc:

; 872  : 
; 873  :     // ---------------- UNROLL #3 ----------------
; 874  : 
; 875  :     // Next SRC char = SC?
; 876  :     // Yes, goto cmp12;
; 877  : 
; 878  :     if (byt == sibling.sc[ scnum ])

  00aab	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  00ab0	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR scnum$[rsp]
  00ab5	0f b6 8c 0c 10
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+rcx]
  00abd	3b c1		 cmp	 eax, ecx
  00abf	75 05		 jne	 SHORT $LN32@z900_cmpsc

; 879  :         goto cmp12;

  00ac1	e9 66 06 00 00	 jmp	 $cmp12$188
$LN32@z900_cmpsc:

; 880  : 
; 881  :     // Another SC?
; 882  :     // Yes, goto cmp7;
; 883  : 
; 884  :     if (++scnum >= sibling.sct)

  00ac6	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00acb	fe c0		 inc	 al
  00acd	88 44 24 20	 mov	 BYTE PTR scnum$[rsp], al
  00ad1	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00ad6	0f b6 8c 24 22
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+18]
  00ade	3b c1		 cmp	 eax, ecx
  00ae0	7c 05		 jl	 SHORT $LN33@z900_cmpsc

; 885  :         goto cmp7E;

  00ae2	e9 ea 00 00 00	 jmp	 $cmp7E$189
$LN33@z900_cmpsc:

; 886  : 
; 887  :     // ---------------- UNROLL #4 ----------------
; 888  : 
; 889  :     // Next SRC char = SC?
; 890  :     // Yes, goto cmp12;
; 891  : 
; 892  :     if (byt == sibling.sc[ scnum ])

  00ae7	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  00aec	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR scnum$[rsp]
  00af1	0f b6 8c 0c 10
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+rcx]
  00af9	3b c1		 cmp	 eax, ecx
  00afb	75 05		 jne	 SHORT $LN34@z900_cmpsc

; 893  :         goto cmp12;

  00afd	e9 2a 06 00 00	 jmp	 $cmp12$188
$LN34@z900_cmpsc:

; 894  : 
; 895  :     // Another SC?
; 896  :     // Yes, goto cmp7;
; 897  : 
; 898  :     if (++scnum >= sibling.sct)

  00b02	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00b07	fe c0		 inc	 al
  00b09	88 44 24 20	 mov	 BYTE PTR scnum$[rsp], al
  00b0d	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00b12	0f b6 8c 24 22
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+18]
  00b1a	3b c1		 cmp	 eax, ecx
  00b1c	7c 05		 jl	 SHORT $LN35@z900_cmpsc

; 899  :         goto cmp7E;

  00b1e	e9 ae 00 00 00	 jmp	 $cmp7E$189
$LN35@z900_cmpsc:

; 900  : 
; 901  :     // ---------------- UNROLL #5 ----------------
; 902  : 
; 903  :     // Next SRC char = SC?
; 904  :     // Yes, goto cmp12;
; 905  : 
; 906  :     if (byt == sibling.sc[ scnum ])

  00b23	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  00b28	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR scnum$[rsp]
  00b2d	0f b6 8c 0c 10
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+rcx]
  00b35	3b c1		 cmp	 eax, ecx
  00b37	75 05		 jne	 SHORT $LN36@z900_cmpsc

; 907  :         goto cmp12;

  00b39	e9 ee 05 00 00	 jmp	 $cmp12$188
$LN36@z900_cmpsc:

; 908  : 
; 909  :     // Another SC?
; 910  :     // Yes, goto cmp7;
; 911  : 
; 912  :     if (++scnum >= sibling.sct)

  00b3e	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00b43	fe c0		 inc	 al
  00b45	88 44 24 20	 mov	 BYTE PTR scnum$[rsp], al
  00b49	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00b4e	0f b6 8c 24 22
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+18]
  00b56	3b c1		 cmp	 eax, ecx
  00b58	7c 02		 jl	 SHORT $LN37@z900_cmpsc

; 913  :         goto cmp7E;

  00b5a	eb 75		 jmp	 SHORT $cmp7E$189
$LN37@z900_cmpsc:

; 914  : 
; 915  :     // ---------------- UNROLL #6 ----------------
; 916  : 
; 917  :     // Next SRC char = SC?
; 918  :     // Yes, goto cmp12;
; 919  : 
; 920  :     if (byt == sibling.sc[ scnum ])

  00b5c	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  00b61	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR scnum$[rsp]
  00b66	0f b6 8c 0c 10
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+rcx]
  00b6e	3b c1		 cmp	 eax, ecx
  00b70	75 05		 jne	 SHORT $LN38@z900_cmpsc

; 921  :         goto cmp12;

  00b72	e9 b5 05 00 00	 jmp	 $cmp12$188
$LN38@z900_cmpsc:

; 922  : 
; 923  :     // Another SC?
; 924  :     // Yes, goto cmp7;
; 925  : 
; 926  :     if (++scnum >= sibling.sct)

  00b77	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00b7c	fe c0		 inc	 al
  00b7e	88 44 24 20	 mov	 BYTE PTR scnum$[rsp], al
  00b82	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00b87	0f b6 8c 24 22
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+18]
  00b8f	3b c1		 cmp	 eax, ecx
  00b91	7c 02		 jl	 SHORT $LN39@z900_cmpsc

; 927  :         goto cmp7E;

  00b93	eb 3c		 jmp	 SHORT $cmp7E$189
$LN39@z900_cmpsc:

; 928  : 
; 929  :     // ---------------- UNROLL #7 ----------------
; 930  : 
; 931  :     // Next SRC char = SC?
; 932  :     // Yes, goto cmp12;
; 933  : 
; 934  :     if (byt == sibling.sc[ scnum ])

  00b95	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  00b9a	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR scnum$[rsp]
  00b9f	0f b6 8c 0c 10
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+rcx]
  00ba7	3b c1		 cmp	 eax, ecx
  00ba9	75 05		 jne	 SHORT $LN40@z900_cmpsc

; 935  :         goto cmp12;

  00bab	e9 7c 05 00 00	 jmp	 $cmp12$188
$LN40@z900_cmpsc:

; 936  : 
; 937  :     // Another SC?
; 938  :     // Yes, goto cmp7;
; 939  : 
; 940  :     if (++scnum < sibling.sct)  // (** last UNROLL **)

  00bb0	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00bb5	fe c0		 inc	 al
  00bb7	88 44 24 20	 mov	 BYTE PTR scnum$[rsp], al
  00bbb	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00bc0	0f b6 8c 24 22
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+18]
  00bc8	3b c1		 cmp	 eax, ecx
  00bca	7d 05		 jge	 SHORT $LN41@z900_cmpsc

; 941  :         goto cmp7;

  00bcc	e9 45 fe ff ff	 jmp	 $cmp7$187
$LN41@z900_cmpsc:
$cmp7E$189:

; 942  : 
; 943  : cmp7E:
; 944  : 
; 945  :     // SCT indicates more children?
; 946  :     // No, goto cmp8;
; 947  : 
; 948  :     if (!sibling.ms)

  00bd1	0f b6 84 24 23
	04 07 00	 movzx	 eax, BYTE PTR sibling$[rsp+19]
  00bd9	85 c0		 test	 eax, eax
  00bdb	75 05		 jne	 SHORT $LN42@z900_cmpsc

; 949  :         goto cmp8;

  00bdd	e9 b9 00 00 00	 jmp	 $cmp8$186
$LN42@z900_cmpsc:

; 950  : 
; 951  :     // Set SD index = current SD index + #of SC's + 1.
; 952  : 
; 953  :     sibling_index += sibling.sct + 1;

  00be2	0f b6 84 24 22
	04 07 00	 movzx	 eax, BYTE PTR sibling$[rsp+18]
  00bea	0f b7 4c 24 34	 movzx	 ecx, WORD PTR sibling_index$[rsp]
  00bef	8d 44 01 01	 lea	 eax, DWORD PTR [rcx+rax+1]
  00bf3	66 89 44 24 34	 mov	 WORD PTR sibling_index$[rsp], ax

; 954  : 
; 955  :     sdeblk.pCCE = NULL;

  00bf8	48 c7 84 24 08
	04 04 00 00 00
	00 00		 mov	 QWORD PTR sdeblk$[rsp+24], 0

; 956  :     if (unlikely( !pGetSD( sibling_index, &sdeblk )))

  00c04	48 8d 94 24 f0
	03 04 00	 lea	 rdx, QWORD PTR sdeblk$[rsp]
  00c0c	0f b7 4c 24 34	 movzx	 ecx, WORD PTR sibling_index$[rsp]
  00c11	ff 94 24 58 01
	00 00		 call	 QWORD PTR pGetSD$[rsp]
  00c18	0f b6 c0	 movzx	 eax, al
  00c1b	85 c0		 test	 eax, eax
  00c1d	75 0d		 jne	 SHORT $LN111@z900_cmpsc
  00c1f	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv563[rsp], 1
  00c2a	eb 0b		 jmp	 SHORT $LN112@z900_cmpsc
$LN111@z900_cmpsc:
  00c2c	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv563[rsp], 0
$LN112@z900_cmpsc:
  00c37	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR tv563[rsp], 0
  00c3f	74 0d		 je	 SHORT $LN115@z900_cmpsc
  00c41	c7 84 24 88 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv572[rsp], 1
  00c4c	eb 0b		 jmp	 SHORT $LN116@z900_cmpsc
$LN115@z900_cmpsc:
  00c4e	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv572[rsp], 0
$LN116@z900_cmpsc:
  00c59	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR tv572[rsp], 0
  00c61	74 2e		 je	 SHORT $LN43@z900_cmpsc

; 957  :     {
; 958  :         PUTSETCBN();

  00c63	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  00c68	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  00c6c	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00c74	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 959  :         RETERR( &op1blk );

  00c77	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  00c7f	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00c87	e8 00 00 00 00	 call	 z900_ERR
  00c8c	e9 4a 0a 00 00	 jmp	 $LN1@z900_cmpsc
$LN43@z900_cmpsc:

; 960  :     }
; 961  :     scnum = 0;

  00c91	c6 44 24 20 00	 mov	 BYTE PTR scnum$[rsp], 0

; 962  : 
; 963  :     // goto cmp7;
; 964  : 
; 965  :     goto cmp7;

  00c96	e9 7b fd ff ff	 jmp	 $LN176@z900_cmpsc
$cmp8$186:

; 966  : 
; 967  : cmp8:
; 968  : 
; 969  :     // Store parent index in DST.
; 970  :     // Advance 1 index in DST.
; 971  :     // goto cmp2;
; 972  : 
; 973  :     if (unlikely( (pCMPSCBLK->pOp2 - pBegOp2) > MAX_SYMLEN ))

  00c9b	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00ca3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pBegOp2$[rsp]
  00ca8	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00cac	48 2b c1	 sub	 rax, rcx
  00caf	48 3d 04 01 00
	00		 cmp	 rax, 260		; 00000104H
  00cb5	76 0d		 jbe	 SHORT $LN119@z900_cmpsc
  00cb7	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv588[rsp], 1
  00cc2	eb 0b		 jmp	 SHORT $LN120@z900_cmpsc
$LN119@z900_cmpsc:
  00cc4	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv588[rsp], 0
$LN120@z900_cmpsc:
  00ccf	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR tv588[rsp], 0
  00cd7	74 2e		 je	 SHORT $LN44@z900_cmpsc

; 974  :     {
; 975  :         PUTSETCBN();

  00cd9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  00cde	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  00ce2	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00cea	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 976  :         RETERR( &op1blk );

  00ced	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  00cf5	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00cfd	e8 00 00 00 00	 call	 z900_ERR
  00d02	e9 d4 09 00 00	 jmp	 $LN1@z900_cmpsc
$LN44@z900_cmpsc:

; 977  :     }
; 978  :     pBegOp2  =  pCMPSCBLK->pOp2;

  00d07	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00d0f	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00d13	48 89 44 24 50	 mov	 QWORD PTR pBegOp2$[rsp], rax

; 979  : 
; 980  :     piblk.index = (!pCMPSCBLK->st) ? parent_index

  00d18	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00d20	0f b6 40 42	 movzx	 eax, BYTE PTR [rax+66]
  00d24	85 c0		 test	 eax, eax
  00d26	75 0d		 jne	 SHORT $LN121@z900_cmpsc
  00d28	c7 84 24 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv600[rsp], 1
  00d33	eb 0b		 jmp	 SHORT $LN122@z900_cmpsc
$LN121@z900_cmpsc:
  00d35	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv600[rsp], 0
$LN122@z900_cmpsc:
  00d40	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR tv600[rsp], 0
  00d48	74 0e		 je	 SHORT $LN123@z900_cmpsc
  00d4a	0f b7 44 24 24	 movzx	 eax, WORD PTR parent_index$[rsp]
  00d4f	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv618[rsp], eax
  00d56	eb 54		 jmp	 SHORT $LN124@z900_cmpsc
$LN123@z900_cmpsc:
  00d58	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00d60	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  00d64	0f b7 4c 24 24	 movzx	 ecx, WORD PTR parent_index$[rsp]
  00d69	d1 e1		 shl	 ecx, 1
  00d6b	48 63 c9	 movsxd	 rcx, ecx
  00d6e	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR pSymTab$[rsp]
  00d76	48 03 d1	 add	 rdx, rcx
  00d79	48 8b ca	 mov	 rcx, rdx
  00d7c	48 8b 94 24 b0
	05 07 00	 mov	 rdx, QWORD PTR pCMPSCBLK$[rsp]
  00d84	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00d88	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  00d8f	48 8b 94 24 b0
	05 07 00	 mov	 rdx, QWORD PTR pCMPSCBLK$[rsp]
  00d97	4c 8b 42 18	 mov	 r8, QWORD PTR [rdx+24]
  00d9b	8b d0		 mov	 edx, eax
  00d9d	e8 00 00 00 00	 call	 z900_vfetch2
  00da2	0f b7 c0	 movzx	 eax, ax
  00da5	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv618[rsp], eax
$LN124@z900_cmpsc:
  00dac	0f b7 84 24 94
	00 00 00	 movzx	 eax, WORD PTR tv618[rsp]
  00db4	66 89 84 24 78
	01 00 00	 mov	 WORD PTR piblk$[rsp+24], ax

; 981  :           : fetch_dct_hw( pSymTab + (parent_index << 1), pCMPSCBLK );
; 982  :     eodst = pPutIndex( &piblk );

  00dbc	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR piblk$[rsp]
  00dc4	ff 54 24 38	 call	 QWORD PTR pPutIndex$[rsp]
  00dc8	88 44 24 23	 mov	 BYTE PTR eodst$[rsp], al

; 983  :     goto cmp2;

  00dcc	e9 26 f7 ff ff	 jmp	 $cmp2$179
$cmp9$181:

; 984  : 
; 985  : cmp9:
; 986  : 
; 987  :     // Store parent index in DST.
; 988  :     // Advance 1 index in DST.
; 989  :     // goto cmp1;
; 990  : 
; 991  :     if (unlikely( (pCMPSCBLK->pOp2 - pBegOp2) > MAX_SYMLEN ))

  00dd1	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00dd9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pBegOp2$[rsp]
  00dde	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00de2	48 2b c1	 sub	 rax, rcx
  00de5	48 3d 04 01 00
	00		 cmp	 rax, 260		; 00000104H
  00deb	76 0d		 jbe	 SHORT $LN127@z900_cmpsc
  00ded	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv630[rsp], 1
  00df8	eb 0b		 jmp	 SHORT $LN128@z900_cmpsc
$LN127@z900_cmpsc:
  00dfa	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv630[rsp], 0
$LN128@z900_cmpsc:
  00e05	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR tv630[rsp], 0
  00e0d	74 2e		 je	 SHORT $LN45@z900_cmpsc

; 992  :     {
; 993  :         PUTSETCBN();

  00e0f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  00e14	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  00e18	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00e20	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 994  :         RETERR( &op1blk );

  00e23	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  00e2b	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00e33	e8 00 00 00 00	 call	 z900_ERR
  00e38	e9 9e 08 00 00	 jmp	 $LN1@z900_cmpsc
$LN45@z900_cmpsc:

; 995  :     }
; 996  :     pBegOp2  =  pCMPSCBLK->pOp2;

  00e3d	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00e45	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00e49	48 89 44 24 50	 mov	 QWORD PTR pBegOp2$[rsp], rax

; 997  : 
; 998  :     piblk.index = (!pCMPSCBLK->st) ? parent_index

  00e4e	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00e56	0f b6 40 42	 movzx	 eax, BYTE PTR [rax+66]
  00e5a	85 c0		 test	 eax, eax
  00e5c	75 0d		 jne	 SHORT $LN129@z900_cmpsc
  00e5e	c7 84 24 9c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv642[rsp], 1
  00e69	eb 0b		 jmp	 SHORT $LN130@z900_cmpsc
$LN129@z900_cmpsc:
  00e6b	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv642[rsp], 0
$LN130@z900_cmpsc:
  00e76	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR tv642[rsp], 0
  00e7e	74 0e		 je	 SHORT $LN131@z900_cmpsc
  00e80	0f b7 44 24 24	 movzx	 eax, WORD PTR parent_index$[rsp]
  00e85	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv660[rsp], eax
  00e8c	eb 54		 jmp	 SHORT $LN132@z900_cmpsc
$LN131@z900_cmpsc:
  00e8e	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00e96	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  00e9a	0f b7 4c 24 24	 movzx	 ecx, WORD PTR parent_index$[rsp]
  00e9f	d1 e1		 shl	 ecx, 1
  00ea1	48 63 c9	 movsxd	 rcx, ecx
  00ea4	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR pSymTab$[rsp]
  00eac	48 03 d1	 add	 rdx, rcx
  00eaf	48 8b ca	 mov	 rcx, rdx
  00eb2	48 8b 94 24 b0
	05 07 00	 mov	 rdx, QWORD PTR pCMPSCBLK$[rsp]
  00eba	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00ebe	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  00ec5	48 8b 94 24 b0
	05 07 00	 mov	 rdx, QWORD PTR pCMPSCBLK$[rsp]
  00ecd	4c 8b 42 18	 mov	 r8, QWORD PTR [rdx+24]
  00ed1	8b d0		 mov	 edx, eax
  00ed3	e8 00 00 00 00	 call	 z900_vfetch2
  00ed8	0f b7 c0	 movzx	 eax, ax
  00edb	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv660[rsp], eax
$LN132@z900_cmpsc:
  00ee2	0f b7 84 24 a0
	00 00 00	 movzx	 eax, WORD PTR tv660[rsp]
  00eea	66 89 84 24 78
	01 00 00	 mov	 WORD PTR piblk$[rsp+24], ax

; 999  :           : fetch_dct_hw( pSymTab + (parent_index << 1), pCMPSCBLK );
; 1000 :     eodst = pPutIndex( &piblk );

  00ef2	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR piblk$[rsp]
  00efa	ff 54 24 38	 call	 QWORD PTR pPutIndex$[rsp]
  00efe	88 44 24 23	 mov	 BYTE PTR eodst$[rsp], al

; 1001 :     goto cmp1;

  00f02	e9 6f f5 ff ff	 jmp	 $cmp1$178
$cmp10$184:

; 1002 : 
; 1003 : cmp10:
; 1004 : 
; 1005 :     if (unlikely( ++children > MAX_CHILDREN ))

  00f07	0f b7 44 24 2c	 movzx	 eax, WORD PTR children$[rsp]
  00f0c	66 ff c0	 inc	 ax
  00f0f	66 89 44 24 2c	 mov	 WORD PTR children$[rsp], ax
  00f14	0f b7 44 24 2c	 movzx	 eax, WORD PTR children$[rsp]
  00f19	3d 04 01 00 00	 cmp	 eax, 260		; 00000104H
  00f1e	7e 0d		 jle	 SHORT $LN135@z900_cmpsc
  00f20	c7 84 24 a4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv672[rsp], 1
  00f2b	eb 0b		 jmp	 SHORT $LN136@z900_cmpsc
$LN135@z900_cmpsc:
  00f2d	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv672[rsp], 0
$LN136@z900_cmpsc:
  00f38	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR tv672[rsp], 0
  00f40	74 2e		 je	 SHORT $LN46@z900_cmpsc

; 1006 :     {
; 1007 :         PUTSETCBN();

  00f42	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  00f47	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  00f4b	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00f53	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 1008 :         RETERR( &op1blk );

  00f56	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  00f5e	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00f66	e8 00 00 00 00	 call	 z900_ERR
  00f6b	e9 6b 07 00 00	 jmp	 $LN1@z900_cmpsc
$LN46@z900_cmpsc:

; 1009 :     }
; 1010 : 
; 1011 :     // Set child index = CPTR + CC number (0-origin numbering).
; 1012 : 
; 1013 :     child_index = parent.cptr + ccnum;

  00f70	0f b7 84 24 38
	04 07 00	 movzx	 eax, WORD PTR parent$[rsp+16]
  00f78	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR ccnum$[rsp]
  00f7d	03 c1		 add	 eax, ecx
  00f7f	66 89 44 24 28	 mov	 WORD PTR child_index$[rsp], ax

; 1014 : 
; 1015 :     // X=1 for child?
; 1016 :     // No, goto cmp14;
; 1017 : 
; 1018 :     if (!(parent.ecb & (0x8000 >> ccnum)))

  00f84	0f b7 84 24 3a
	04 07 00	 movzx	 eax, WORD PTR parent$[rsp+18]
  00f8c	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR ccnum$[rsp]
  00f91	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  00f96	d3 fa		 sar	 edx, cl
  00f98	8b ca		 mov	 ecx, edx
  00f9a	23 c1		 and	 eax, ecx
  00f9c	85 c0		 test	 eax, eax
  00f9e	75 05		 jne	 SHORT $LN47@z900_cmpsc

; 1019 :         goto cmp14;

  00fa0	e9 b8 04 00 00	 jmp	 $cmp14$190
$LN47@z900_cmpsc:

; 1020 : 
; 1021 :     // ACT=0 or D=0 in child?
; 1022 :     // Yes, goto cmp15;
; 1023 : 
; 1024 :     cceblk.pCCE = &child;

  00fa5	48 8d 84 24 48
	04 07 00	 lea	 rax, QWORD PTR child$[rsp]
  00fad	48 89 84 24 d8
	03 00 00	 mov	 QWORD PTR cceblk$[rsp+8], rax

; 1025 :     if (unlikely( !ARCH_DEP( GetCCE )( child_index, &cceblk )))

  00fb5	48 8d 94 24 d0
	03 00 00	 lea	 rdx, QWORD PTR cceblk$[rsp]
  00fbd	0f b7 4c 24 28	 movzx	 ecx, WORD PTR child_index$[rsp]
  00fc2	e8 00 00 00 00	 call	 z900_GetCCE
  00fc7	0f b6 c0	 movzx	 eax, al
  00fca	85 c0		 test	 eax, eax
  00fcc	75 0d		 jne	 SHORT $LN137@z900_cmpsc
  00fce	c7 84 24 a8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv694[rsp], 1
  00fd9	eb 0b		 jmp	 SHORT $LN138@z900_cmpsc
$LN137@z900_cmpsc:
  00fdb	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv694[rsp], 0
$LN138@z900_cmpsc:
  00fe6	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR tv694[rsp], 0
  00fee	74 0d		 je	 SHORT $LN141@z900_cmpsc
  00ff0	c7 84 24 ac 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv703[rsp], 1
  00ffb	eb 0b		 jmp	 SHORT $LN142@z900_cmpsc
$LN141@z900_cmpsc:
  00ffd	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv703[rsp], 0
$LN142@z900_cmpsc:
  01008	83 bc 24 ac 00
	00 00 00	 cmp	 DWORD PTR tv703[rsp], 0
  01010	74 2e		 je	 SHORT $LN48@z900_cmpsc

; 1026 :     {
; 1027 :         PUTSETCBN();

  01012	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  01017	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  0101b	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01023	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 1028 :         RETERR( &op1blk );

  01026	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  0102e	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01036	e8 00 00 00 00	 call	 z900_ERR
  0103b	e9 9b 06 00 00	 jmp	 $LN1@z900_cmpsc
$LN48@z900_cmpsc:

; 1029 :     }
; 1030 : 
; 1031 :     if (!child.act)

  01040	0f b6 84 24 5f
	04 07 00	 movzx	 eax, BYTE PTR child$[rsp+23]
  01048	85 c0		 test	 eax, eax
  0104a	75 05		 jne	 SHORT $LN49@z900_cmpsc

; 1032 :         goto cmp15;

  0104c	e9 85 05 00 00	 jmp	 $cmp15$191
$LN49@z900_cmpsc:

; 1033 : 
; 1034 :     // (compare SRC chars after next char to AEC's in child)...
; 1035 : 
; 1036 :     // Enough SRC chars for comparison?
; 1037 :     // No, goto cmp11;
; 1038 : 
; 1039 :     if (unlikely( pCMPSCBLK->nLen2 < (U64)(1 + child.act)))

  01051	0f b6 84 24 5f
	04 07 00	 movzx	 eax, BYTE PTR child$[rsp+23]
  01059	ff c0		 inc	 eax
  0105b	48 98		 cdqe
  0105d	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01065	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  01069	73 0d		 jae	 SHORT $LN145@z900_cmpsc
  0106b	c7 84 24 b0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv725[rsp], 1
  01076	eb 0b		 jmp	 SHORT $LN146@z900_cmpsc
$LN145@z900_cmpsc:
  01078	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv725[rsp], 0
$LN146@z900_cmpsc:
  01083	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR tv725[rsp], 0
  0108b	74 02		 je	 SHORT $LN50@z900_cmpsc

; 1040 :         goto cmp11;

  0108d	eb 69		 jmp	 SHORT $cmp11$192
$LN50@z900_cmpsc:

; 1041 : 
; 1042 :     // Chars equal?
; 1043 :     // Yes, goto cmp16;
; 1044 : 
; 1045 :     fetch_op_str( wrk, child.act-1, pCMPSCBLK->pOp2 + 1, &op2blk );

  0108f	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  01097	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0109b	48 ff c0	 inc	 rax
  0109e	0f b6 8c 24 5f
	04 07 00	 movzx	 ecx, BYTE PTR child$[rsp+23]
  010a6	ff c9		 dec	 ecx
  010a8	4c 8d 8c 24 20
	01 00 00	 lea	 r9, QWORD PTR op2blk$[rsp]
  010b0	4c 8b c0	 mov	 r8, rax
  010b3	0f b7 d1	 movzx	 edx, cx
  010b6	48 8d 8c 24 70
	04 07 00	 lea	 rcx, QWORD PTR wrk$[rsp]
  010be	e8 00 00 00 00	 call	 z900_cmpsc_vfetchc

; 1046 : 
; 1047 :     if (memcmp( wrk, &child.ec[0], child.act ) == 0)

  010c3	0f b6 84 24 5f
	04 07 00	 movzx	 eax, BYTE PTR child$[rsp+23]
  010cb	b9 01 00 00 00	 mov	 ecx, 1
  010d0	48 6b c9 00	 imul	 rcx, rcx, 0
  010d4	48 8d 8c 0c 48
	04 07 00	 lea	 rcx, QWORD PTR child$[rsp+rcx]
  010dc	44 8b c0	 mov	 r8d, eax
  010df	48 8b d1	 mov	 rdx, rcx
  010e2	48 8d 8c 24 70
	04 07 00	 lea	 rcx, QWORD PTR wrk$[rsp]
  010ea	e8 00 00 00 00	 call	 memcmp
  010ef	85 c0		 test	 eax, eax
  010f1	75 05		 jne	 SHORT $LN51@z900_cmpsc

; 1048 :         goto cmp16;

  010f3	e9 4d 05 00 00	 jmp	 $cmp16$193
$LN51@z900_cmpsc:
$cmp11$192:

; 1049 : 
; 1050 : cmp11:
; 1051 : 
; 1052 :     // Flag=1?
; 1053 :     // No, goto cmp8;
; 1054 : 
; 1055 :     if (!flag)

  010f8	0f b6 44 24 31	 movzx	 eax, BYTE PTR flag$[rsp]
  010fd	85 c0		 test	 eax, eax
  010ff	75 05		 jne	 SHORT $LN52@z900_cmpsc

; 1056 :         goto cmp8;

  01101	e9 95 fb ff ff	 jmp	 $cmp8$186
$LN52@z900_cmpsc:

; 1057 : 
; 1058 :     // Another CC?
; 1059 :     // No, goto cmp8;
; 1060 : 
; 1061 :     if (++ccnum >= parent.cct)

  01106	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  0110b	fe c0		 inc	 al
  0110d	88 44 24 21	 mov	 BYTE PTR ccnum$[rsp], al
  01111	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  01116	0f b6 8c 24 3e
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+22]
  0111e	3b c1		 cmp	 eax, ecx
  01120	7c 05		 jl	 SHORT $LN53@z900_cmpsc

; 1062 :         goto cmp8;

  01122	e9 74 fb ff ff	 jmp	 $cmp8$186
$LN53@z900_cmpsc:

; 1063 : 
; 1064 :     // goto cmp5;
; 1065 : 
; 1066 :     goto cmp5;

  01127	e9 e1 f6 ff ff	 jmp	 $LN175@z900_cmpsc
$cmp12$188:

; 1067 : 
; 1068 : cmp12:
; 1069 : 
; 1070 :     if (unlikely( ++children > MAX_CHILDREN ))

  0112c	0f b7 44 24 2c	 movzx	 eax, WORD PTR children$[rsp]
  01131	66 ff c0	 inc	 ax
  01134	66 89 44 24 2c	 mov	 WORD PTR children$[rsp], ax
  01139	0f b7 44 24 2c	 movzx	 eax, WORD PTR children$[rsp]
  0113e	3d 04 01 00 00	 cmp	 eax, 260		; 00000104H
  01143	7e 0d		 jle	 SHORT $LN149@z900_cmpsc
  01145	c7 84 24 b4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv792[rsp], 1
  01150	eb 0b		 jmp	 SHORT $LN150@z900_cmpsc
$LN149@z900_cmpsc:
  01152	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv792[rsp], 0
$LN150@z900_cmpsc:
  0115d	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR tv792[rsp], 0
  01165	74 2e		 je	 SHORT $LN54@z900_cmpsc

; 1071 :     {
; 1072 :         PUTSETCBN();

  01167	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  0116c	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  01170	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01178	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 1073 :         RETERR( &op1blk );

  0117b	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  01183	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0118b	e8 00 00 00 00	 call	 z900_ERR
  01190	e9 46 05 00 00	 jmp	 $LN1@z900_cmpsc
$LN54@z900_cmpsc:

; 1074 :     }
; 1075 : 
; 1076 :     // Set child index = SD index + SC number (1-origin numbering).
; 1077 : 
; 1078 :     child_index = sibling_index + (scnum + 1);

  01195	0f b7 44 24 34	 movzx	 eax, WORD PTR sibling_index$[rsp]
  0119a	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR scnum$[rsp]
  0119f	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  011a3	66 89 44 24 28	 mov	 WORD PTR child_index$[rsp], ax

; 1079 : 
; 1080 :     // Y=1 for child or no Y?
; 1081 :     // No, goto cmp14;
; 1082 : 
; 1083 :     if (!(sibling.ecb & (0x8000 >> scnum)))

  011a8	0f b7 84 24 20
	04 07 00	 movzx	 eax, WORD PTR sibling$[rsp+16]
  011b0	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR scnum$[rsp]
  011b5	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  011ba	d3 fa		 sar	 edx, cl
  011bc	8b ca		 mov	 ecx, edx
  011be	23 c1		 and	 eax, ecx
  011c0	85 c0		 test	 eax, eax
  011c2	75 05		 jne	 SHORT $LN55@z900_cmpsc

; 1084 :         goto cmp14;

  011c4	e9 94 02 00 00	 jmp	 $cmp14$190
$LN55@z900_cmpsc:

; 1085 : 
; 1086 :     // ACT=0 or D=0 in child?
; 1087 :     // Yes, goto cmp15;
; 1088 : 
; 1089 :     cceblk.pCCE = &child;

  011c9	48 8d 84 24 48
	04 07 00	 lea	 rax, QWORD PTR child$[rsp]
  011d1	48 89 84 24 d8
	03 00 00	 mov	 QWORD PTR cceblk$[rsp+8], rax

; 1090 :     if (unlikely( !ARCH_DEP( GetCCE )( child_index, &cceblk )))

  011d9	48 8d 94 24 d0
	03 00 00	 lea	 rdx, QWORD PTR cceblk$[rsp]
  011e1	0f b7 4c 24 28	 movzx	 ecx, WORD PTR child_index$[rsp]
  011e6	e8 00 00 00 00	 call	 z900_GetCCE
  011eb	0f b6 c0	 movzx	 eax, al
  011ee	85 c0		 test	 eax, eax
  011f0	75 0d		 jne	 SHORT $LN151@z900_cmpsc
  011f2	c7 84 24 b8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv815[rsp], 1
  011fd	eb 0b		 jmp	 SHORT $LN152@z900_cmpsc
$LN151@z900_cmpsc:
  011ff	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv815[rsp], 0
$LN152@z900_cmpsc:
  0120a	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR tv815[rsp], 0
  01212	74 0d		 je	 SHORT $LN155@z900_cmpsc
  01214	c7 84 24 bc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv824[rsp], 1
  0121f	eb 0b		 jmp	 SHORT $LN156@z900_cmpsc
$LN155@z900_cmpsc:
  01221	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv824[rsp], 0
$LN156@z900_cmpsc:
  0122c	83 bc 24 bc 00
	00 00 00	 cmp	 DWORD PTR tv824[rsp], 0
  01234	74 2e		 je	 SHORT $LN56@z900_cmpsc

; 1091 :     {
; 1092 :         PUTSETCBN();

  01236	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  0123b	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  0123f	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01247	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 1093 :         RETERR( &op1blk );

  0124a	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  01252	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0125a	e8 00 00 00 00	 call	 z900_ERR
  0125f	e9 77 04 00 00	 jmp	 $LN1@z900_cmpsc
$LN56@z900_cmpsc:

; 1094 :     }
; 1095 : 
; 1096 :     if (!child.act)

  01264	0f b6 84 24 5f
	04 07 00	 movzx	 eax, BYTE PTR child$[rsp+23]
  0126c	85 c0		 test	 eax, eax
  0126e	75 05		 jne	 SHORT $LN57@z900_cmpsc

; 1097 :         goto cmp15;

  01270	e9 61 03 00 00	 jmp	 $cmp15$191
$LN57@z900_cmpsc:

; 1098 : 
; 1099 :     // (compare SRC chars after next char to AEC's in child)...
; 1100 : 
; 1101 :     // Enough SRC chars for comparison?
; 1102 :     // No, goto cmp8;
; 1103 : 
; 1104 :     if (pCMPSCBLK->nLen2 < (U64)(1 + child.act))

  01275	0f b6 84 24 5f
	04 07 00	 movzx	 eax, BYTE PTR child$[rsp+23]
  0127d	ff c0		 inc	 eax
  0127f	48 98		 cdqe
  01281	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01289	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  0128d	73 05		 jae	 SHORT $LN58@z900_cmpsc

; 1105 :         goto cmp8;

  0128f	e9 07 fa ff ff	 jmp	 $cmp8$186
$LN58@z900_cmpsc:

; 1106 : 
; 1107 :     // Chars equal?
; 1108 :     // Yes, goto cmp16;
; 1109 : 
; 1110 :     fetch_op_str( wrk, child.act-1, pCMPSCBLK->pOp2 + 1, &op2blk );

  01294	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0129c	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  012a0	48 ff c0	 inc	 rax
  012a3	0f b6 8c 24 5f
	04 07 00	 movzx	 ecx, BYTE PTR child$[rsp+23]
  012ab	ff c9		 dec	 ecx
  012ad	4c 8d 8c 24 20
	01 00 00	 lea	 r9, QWORD PTR op2blk$[rsp]
  012b5	4c 8b c0	 mov	 r8, rax
  012b8	0f b7 d1	 movzx	 edx, cx
  012bb	48 8d 8c 24 70
	04 07 00	 lea	 rcx, QWORD PTR wrk$[rsp]
  012c3	e8 00 00 00 00	 call	 z900_cmpsc_vfetchc

; 1111 : 
; 1112 :     if (memcmp( wrk, &child.ec[0], child.act ) == 0)

  012c8	0f b6 84 24 5f
	04 07 00	 movzx	 eax, BYTE PTR child$[rsp+23]
  012d0	b9 01 00 00 00	 mov	 ecx, 1
  012d5	48 6b c9 00	 imul	 rcx, rcx, 0
  012d9	48 8d 8c 0c 48
	04 07 00	 lea	 rcx, QWORD PTR child$[rsp+rcx]
  012e1	44 8b c0	 mov	 r8d, eax
  012e4	48 8b d1	 mov	 rdx, rcx
  012e7	48 8d 8c 24 70
	04 07 00	 lea	 rcx, QWORD PTR wrk$[rsp]
  012ef	e8 00 00 00 00	 call	 memcmp
  012f4	85 c0		 test	 eax, eax
  012f6	75 05		 jne	 SHORT $LN59@z900_cmpsc

; 1113 :         goto cmp16;

  012f8	e9 48 03 00 00	 jmp	 $cmp16$193
$LN59@z900_cmpsc:

; 1114 : 
; 1115 :     // goto cmp8;
; 1116 : 
; 1117 :     goto cmp8;

  012fd	e9 99 f9 ff ff	 jmp	 $cmp8$186
$cmp13$182:

; 1118 : 
; 1119 : cmp13:
; 1120 : 
; 1121 :     // Store parent index in DST.
; 1122 :     // Advance 1 index in DST;
; 1123 :     // Set CC0 and endop.
; 1124 : 
; 1125 :     if (unlikely( (pCMPSCBLK->pOp2 - pBegOp2) > MAX_SYMLEN ))

  01302	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0130a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pBegOp2$[rsp]
  0130f	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  01313	48 2b c1	 sub	 rax, rcx
  01316	48 3d 04 01 00
	00		 cmp	 rax, 260		; 00000104H
  0131c	76 0d		 jbe	 SHORT $LN159@z900_cmpsc
  0131e	c7 84 24 c0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv866[rsp], 1
  01329	eb 0b		 jmp	 SHORT $LN160@z900_cmpsc
$LN159@z900_cmpsc:
  0132b	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv866[rsp], 0
$LN160@z900_cmpsc:
  01336	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR tv866[rsp], 0
  0133e	74 2e		 je	 SHORT $LN60@z900_cmpsc

; 1126 :     {
; 1127 :         PUTSETCBN();

  01340	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  01345	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  01349	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01351	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 1128 :         RETERR( &op1blk );

  01354	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  0135c	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01364	e8 00 00 00 00	 call	 z900_ERR
  01369	e9 6d 03 00 00	 jmp	 $LN1@z900_cmpsc
$LN60@z900_cmpsc:

; 1129 :     }
; 1130 :     pBegOp2  =  pCMPSCBLK->pOp2;

  0136e	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  01376	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0137a	48 89 44 24 50	 mov	 QWORD PTR pBegOp2$[rsp], rax

; 1131 : 
; 1132 :     piblk.index = (!pCMPSCBLK->st) ? parent_index

  0137f	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  01387	0f b6 40 42	 movzx	 eax, BYTE PTR [rax+66]
  0138b	85 c0		 test	 eax, eax
  0138d	75 0d		 jne	 SHORT $LN161@z900_cmpsc
  0138f	c7 84 24 c4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv878[rsp], 1
  0139a	eb 0b		 jmp	 SHORT $LN162@z900_cmpsc
$LN161@z900_cmpsc:
  0139c	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv878[rsp], 0
$LN162@z900_cmpsc:
  013a7	83 bc 24 c4 00
	00 00 00	 cmp	 DWORD PTR tv878[rsp], 0
  013af	74 0e		 je	 SHORT $LN163@z900_cmpsc
  013b1	0f b7 44 24 24	 movzx	 eax, WORD PTR parent_index$[rsp]
  013b6	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv896[rsp], eax
  013bd	eb 54		 jmp	 SHORT $LN164@z900_cmpsc
$LN163@z900_cmpsc:
  013bf	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  013c7	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  013cb	0f b7 4c 24 24	 movzx	 ecx, WORD PTR parent_index$[rsp]
  013d0	d1 e1		 shl	 ecx, 1
  013d2	48 63 c9	 movsxd	 rcx, ecx
  013d5	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR pSymTab$[rsp]
  013dd	48 03 d1	 add	 rdx, rcx
  013e0	48 8b ca	 mov	 rcx, rdx
  013e3	48 8b 94 24 b0
	05 07 00	 mov	 rdx, QWORD PTR pCMPSCBLK$[rsp]
  013eb	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  013ef	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  013f6	48 8b 94 24 b0
	05 07 00	 mov	 rdx, QWORD PTR pCMPSCBLK$[rsp]
  013fe	4c 8b 42 18	 mov	 r8, QWORD PTR [rdx+24]
  01402	8b d0		 mov	 edx, eax
  01404	e8 00 00 00 00	 call	 z900_vfetch2
  01409	0f b7 c0	 movzx	 eax, ax
  0140c	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv896[rsp], eax
$LN164@z900_cmpsc:
  01413	0f b7 84 24 c8
	00 00 00	 movzx	 eax, WORD PTR tv896[rsp]
  0141b	66 89 84 24 78
	01 00 00	 mov	 WORD PTR piblk$[rsp+24], ax

; 1133 :           : fetch_dct_hw( pSymTab + (parent_index << 1), pCMPSCBLK );
; 1134 :     pPutIndex( &piblk );

  01423	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR piblk$[rsp]
  0142b	ff 54 24 38	 call	 QWORD PTR pPutIndex$[rsp]

; 1135 :     PUTSETCBN();

  0142f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  01434	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  01438	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01440	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 1136 :     RETCC0( &op1blk );

  01443	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  0144b	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01453	e8 00 00 00 00	 call	 z900_CC0
  01458	e9 7e 02 00 00	 jmp	 $LN1@z900_cmpsc
$cmp14$190:

; 1137 : 
; 1138 : cmp14:
; 1139 : 
; 1140 :     // Store child index in DST.
; 1141 :     // Advance 1 index in DST.
; 1142 :     // Advance 1 byte in SRC.
; 1143 :     // goto cmp1;
; 1144 : 
; 1145 :     nCPUAmt++;

  0145d	48 8b 44 24 48	 mov	 rax, QWORD PTR nCPUAmt$[rsp]
  01462	48 ff c0	 inc	 rax
  01465	48 89 44 24 48	 mov	 QWORD PTR nCPUAmt$[rsp], rax

; 1146 :     pCMPSCBLK->pOp2++;

  0146a	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  01472	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  01476	48 ff c0	 inc	 rax
  01479	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01481	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1147 :     pCMPSCBLK->nLen2--;

  01485	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0148d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  01491	48 ff c8	 dec	 rax
  01494	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0149c	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1148 : 
; 1149 :     if (unlikely( (pCMPSCBLK->pOp2 - pBegOp2) > MAX_SYMLEN ))

  014a0	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  014a8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pBegOp2$[rsp]
  014ad	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  014b1	48 2b c1	 sub	 rax, rcx
  014b4	48 3d 04 01 00
	00		 cmp	 rax, 260		; 00000104H
  014ba	76 0d		 jbe	 SHORT $LN167@z900_cmpsc
  014bc	c7 84 24 cc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv922[rsp], 1
  014c7	eb 0b		 jmp	 SHORT $LN168@z900_cmpsc
$LN167@z900_cmpsc:
  014c9	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv922[rsp], 0
$LN168@z900_cmpsc:
  014d4	83 bc 24 cc 00
	00 00 00	 cmp	 DWORD PTR tv922[rsp], 0
  014dc	74 2e		 je	 SHORT $LN61@z900_cmpsc

; 1150 :     {
; 1151 :         PUTSETCBN();

  014de	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  014e3	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  014e7	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  014ef	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 1152 :         RETERR( &op1blk );

  014f2	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  014fa	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01502	e8 00 00 00 00	 call	 z900_ERR
  01507	e9 cf 01 00 00	 jmp	 $LN1@z900_cmpsc
$LN61@z900_cmpsc:

; 1153 :     }
; 1154 :     pBegOp2  =  pCMPSCBLK->pOp2;

  0150c	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  01514	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  01518	48 89 44 24 50	 mov	 QWORD PTR pBegOp2$[rsp], rax

; 1155 : 
; 1156 :     piblk.index = (!pCMPSCBLK->st) ? child_index

  0151d	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  01525	0f b6 40 42	 movzx	 eax, BYTE PTR [rax+66]
  01529	85 c0		 test	 eax, eax
  0152b	75 0d		 jne	 SHORT $LN169@z900_cmpsc
  0152d	c7 84 24 d0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv934[rsp], 1
  01538	eb 0b		 jmp	 SHORT $LN170@z900_cmpsc
$LN169@z900_cmpsc:
  0153a	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv934[rsp], 0
$LN170@z900_cmpsc:
  01545	83 bc 24 d0 00
	00 00 00	 cmp	 DWORD PTR tv934[rsp], 0
  0154d	74 0e		 je	 SHORT $LN171@z900_cmpsc
  0154f	0f b7 44 24 28	 movzx	 eax, WORD PTR child_index$[rsp]
  01554	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv952[rsp], eax
  0155b	eb 54		 jmp	 SHORT $LN172@z900_cmpsc
$LN171@z900_cmpsc:
  0155d	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  01565	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  01569	0f b7 4c 24 28	 movzx	 ecx, WORD PTR child_index$[rsp]
  0156e	d1 e1		 shl	 ecx, 1
  01570	48 63 c9	 movsxd	 rcx, ecx
  01573	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR pSymTab$[rsp]
  0157b	48 03 d1	 add	 rdx, rcx
  0157e	48 8b ca	 mov	 rcx, rdx
  01581	48 8b 94 24 b0
	05 07 00	 mov	 rdx, QWORD PTR pCMPSCBLK$[rsp]
  01589	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  0158d	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  01594	48 8b 94 24 b0
	05 07 00	 mov	 rdx, QWORD PTR pCMPSCBLK$[rsp]
  0159c	4c 8b 42 18	 mov	 r8, QWORD PTR [rdx+24]
  015a0	8b d0		 mov	 edx, eax
  015a2	e8 00 00 00 00	 call	 z900_vfetch2
  015a7	0f b7 c0	 movzx	 eax, ax
  015aa	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv952[rsp], eax
$LN172@z900_cmpsc:
  015b1	0f b7 84 24 d4
	00 00 00	 movzx	 eax, WORD PTR tv952[rsp]
  015b9	66 89 84 24 78
	01 00 00	 mov	 WORD PTR piblk$[rsp+24], ax

; 1157 :           : fetch_dct_hw( pSymTab + (child_index << 1), pCMPSCBLK );
; 1158 :     eodst = pPutIndex( &piblk );

  015c1	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR piblk$[rsp]
  015c9	ff 54 24 38	 call	 QWORD PTR pPutIndex$[rsp]
  015cd	88 44 24 23	 mov	 BYTE PTR eodst$[rsp], al

; 1159 :     goto cmp1;

  015d1	e9 a0 ee ff ff	 jmp	 $LN173@z900_cmpsc
$cmp15$191:

; 1160 : 
; 1161 : cmp15:
; 1162 : 
; 1163 :     // Call child the parent.
; 1164 :     // Advance 1 byte in SRC.
; 1165 :     // goto cmp3;
; 1166 : 
; 1167 :     parent       = child;

  015d6	48 8d 84 24 28
	04 07 00	 lea	 rax, QWORD PTR parent$[rsp]
  015de	48 8d 8c 24 48
	04 07 00	 lea	 rcx, QWORD PTR child$[rsp]
  015e6	48 8b f8	 mov	 rdi, rax
  015e9	48 8b f1	 mov	 rsi, rcx
  015ec	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  015f1	f3 a4		 rep movsb

; 1168 :     parent_index = child_index;

  015f3	0f b7 44 24 28	 movzx	 eax, WORD PTR child_index$[rsp]
  015f8	66 89 44 24 24	 mov	 WORD PTR parent_index$[rsp], ax

; 1169 : 
; 1170 :     nCPUAmt++;

  015fd	48 8b 44 24 48	 mov	 rax, QWORD PTR nCPUAmt$[rsp]
  01602	48 ff c0	 inc	 rax
  01605	48 89 44 24 48	 mov	 QWORD PTR nCPUAmt$[rsp], rax

; 1171 :     pCMPSCBLK->pOp2++;

  0160a	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  01612	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  01616	48 ff c0	 inc	 rax
  01619	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01621	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1172 :     pCMPSCBLK->nLen2--;

  01625	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0162d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  01631	48 ff c8	 dec	 rax
  01634	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0163c	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1173 : 
; 1174 :     goto cmp3;

  01640	e9 4f f0 ff ff	 jmp	 $cmp3$180
$cmp16$193:

; 1175 : 
; 1176 : cmp16:
; 1177 : 
; 1178 :     // Call child the parent.
; 1179 :     // Advance in SRC by 1 + #of AEC bytes.
; 1180 :     // goto cmp3;
; 1181 : 
; 1182 :     parent       = child;

  01645	48 8d 84 24 28
	04 07 00	 lea	 rax, QWORD PTR parent$[rsp]
  0164d	48 8d 8c 24 48
	04 07 00	 lea	 rcx, QWORD PTR child$[rsp]
  01655	48 8b f8	 mov	 rdi, rax
  01658	48 8b f1	 mov	 rsi, rcx
  0165b	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01660	f3 a4		 rep movsb

; 1183 :     parent_index = child_index;

  01662	0f b7 44 24 28	 movzx	 eax, WORD PTR child_index$[rsp]
  01667	66 89 44 24 24	 mov	 WORD PTR parent_index$[rsp], ax

; 1184 : 
; 1185 :     nCPUAmt           += 1 + child.act;

  0166c	0f b6 84 24 5f
	04 07 00	 movzx	 eax, BYTE PTR child$[rsp+23]
  01674	ff c0		 inc	 eax
  01676	48 98		 cdqe
  01678	48 8b 4c 24 48	 mov	 rcx, QWORD PTR nCPUAmt$[rsp]
  0167d	48 03 c8	 add	 rcx, rax
  01680	48 8b c1	 mov	 rax, rcx
  01683	48 89 44 24 48	 mov	 QWORD PTR nCPUAmt$[rsp], rax

; 1186 :     pCMPSCBLK->pOp2   += 1 + child.act;

  01688	0f b6 84 24 5f
	04 07 00	 movzx	 eax, BYTE PTR child$[rsp+23]
  01690	ff c0		 inc	 eax
  01692	48 98		 cdqe
  01694	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0169c	48 03 41 28	 add	 rax, QWORD PTR [rcx+40]
  016a0	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  016a8	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1187 :     pCMPSCBLK->nLen2  -= 1 + child.act;

  016ac	0f b6 84 24 5f
	04 07 00	 movzx	 eax, BYTE PTR child$[rsp+23]
  016b4	ff c0		 inc	 eax
  016b6	48 98		 cdqe
  016b8	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  016c0	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  016c4	48 2b c8	 sub	 rcx, rax
  016c7	48 8b c1	 mov	 rax, rcx
  016ca	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  016d2	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1188 : 
; 1189 :     goto cmp3;

  016d6	e9 b9 ef ff ff	 jmp	 $LN174@z900_cmpsc
$LN1@z900_cmpsc:

; 1190 : }

  016db	48 8b 8c 24 80
	05 07 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  016e3	48 33 cc	 xor	 rcx, rsp
  016e6	e8 00 00 00 00	 call	 __security_check_cookie
  016eb	48 81 c4 98 05
	07 00		 add	 rsp, 460184		; 00070598H
  016f2	5f		 pop	 rdi
  016f3	5e		 pop	 rsi
  016f4	c3		 ret	 0
z900_cmpsc_Compress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
i$1 = 32
bits$ = 33
nCPUAmt$ = 40
tv155 = 48
tv195 = 52
tv207 = 56
tv216 = 60
tv242 = 64
tv268 = 68
tv318 = 72
tv358 = 76
tv378 = 80
tv399 = 84
tv408 = 88
tv447 = 92
tv487 = 96
tv495 = 100
tv507 = 104
tv516 = 108
tv542 = 112
tv568 = 116
tv642 = 120
pGetIndex$ = 128
ppGetIndex$ = 136
ppGet8Index$2 = 144
pGet8Index$3 = 152
giblk$ = 160
save_op1blk$4 = 192
save_op2blk$5 = 232
save_cmpsc$6 = 272
expblk$ = 352
index$ = 197376
__$ArrayPad$ = 197392
pCMPSCBLK$ = 197440
z900_cmpsc_Expand PROC

; 258  : {

$LN105:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	b8 28 03 03 00	 mov	 eax, 197416		; 00030328H
  0000c	e8 00 00 00 00	 call	 __chkstk
  00011	48 2b e0	 sub	 rsp, rax
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 10
	03 03 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 259  :     U64         nCPUAmt;        // CPU determined processing limit
; 260  :     GetIndex**  ppGetIndex;     // Ptr to GetNextIndex table for this CDSS-1
; 261  :     GetIndex*   pGetIndex;      // Ptr to GetNextIndex function for this CBN
; 262  :     GIBLK       giblk;          // GetIndex parameters block
; 263  :     EXPBLK      expblk;         // EXPAND Index Symbol parameters block
; 264  :     U16         index[8];       // SRC Index values
; 265  :     U8          bits;           // Number of bits per index
; 266  : 
; 267  :     nCPUAmt     = 0;

  00026	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR nCPUAmt$[rsp], 0

; 268  :     ppGetIndex  = ARCH_DEP( GetIndexCDSSTab  )[ pCMPSCBLK->cdss - 1 ];

  0002f	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00037	0f b6 40 44	 movzx	 eax, BYTE PTR [rax+68]
  0003b	ff c8		 dec	 eax
  0003d	48 98		 cdqe
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:z900_GetIndexCDSSTab
  00046	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0004a	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR ppGetIndex$[rsp], rax

; 269  :     pGetIndex   = ppGetIndex [ pCMPSCBLK->cbn ];

  00052	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0005a	0f b6 40 45	 movzx	 eax, BYTE PTR [rax+69]
  0005e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ppGetIndex$[rsp]
  00066	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0006a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pGetIndex$[rsp], rax

; 270  :     bits        = pCMPSCBLK->cdss + 8;

  00072	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0007a	0f b6 40 44	 movzx	 eax, BYTE PTR [rax+68]
  0007e	83 c0 08	 add	 eax, 8
  00081	88 44 24 21	 mov	 BYTE PTR bits$[rsp], al

; 271  : 
; 272  :     // Initialize GetIndex parameters block
; 273  : 
; 274  :     memset( &giblk, 0, sizeof( giblk ));

  00085	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR giblk$[rsp]
  0008d	48 8b f8	 mov	 rdi, rax
  00090	33 c0		 xor	 eax, eax
  00092	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00097	f3 aa		 rep stosb

; 275  : 
; 276  :     giblk.pCMPSCBLK   =  pCMPSCBLK;

  00099	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  000a1	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR giblk$[rsp], rax

; 277  :     giblk.pMEMBLK     =  &expblk.op2blk;    // (we get indexes from op-2)

  000a9	48 8d 84 24 c0
	02 03 00	 lea	 rax, QWORD PTR expblk$[rsp+196960]
  000b1	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR giblk$[rsp+8], rax

; 278  :     giblk.pIndex      =  &index[0];

  000b9	b8 02 00 00 00	 mov	 eax, 2
  000be	48 6b c0 00	 imul	 rax, rax, 0
  000c2	48 8d 84 04 00
	03 03 00	 lea	 rax, QWORD PTR index$[rsp+rax]
  000ca	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR giblk$[rsp+16], rax

; 279  :     giblk.ppGetIndex  =  (void**) &pGetIndex;

  000d2	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR pGetIndex$[rsp]
  000da	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR giblk$[rsp+24], rax

; 280  : 
; 281  :     // Initialize EXPAND Index Symbol parameters block
; 282  : 
; 283  :     memset( &expblk, 0, sizeof( expblk ));

  000e2	48 8d 84 24 60
	01 00 00	 lea	 rax, QWORD PTR expblk$[rsp]
  000ea	48 8b f8	 mov	 rdi, rax
  000ed	33 c0		 xor	 eax, eax
  000ef	b9 a0 01 03 00	 mov	 ecx, 197024		; 000301a0H
  000f4	f3 aa		 rep stosb

; 284  : 
; 285  :     expblk.dctblk.regs      = pCMPSCBLK->regs;

  000f6	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  000fe	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00102	48 89 84 24 68
	01 01 00	 mov	 QWORD PTR expblk$[rsp+65544], rax

; 286  :     expblk.dctblk.arn       = pCMPSCBLK->r2;

  0010a	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00112	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  00116	89 84 24 78 02
	01 00		 mov	 DWORD PTR expblk$[rsp+65816], eax

; 287  :     expblk.dctblk.pkey      = pCMPSCBLK->regs->psw.pkey;

  0011d	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00125	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00129	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0012d	88 84 24 7c 02
	01 00		 mov	 BYTE PTR expblk$[rsp+65820], al

; 288  :     expblk.dctblk.pDict     = pCMPSCBLK->pDict;

  00134	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0013c	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00140	48 89 84 24 70
	01 01 00	 mov	 QWORD PTR expblk$[rsp+65552], rax

; 289  : 
; 290  :     expblk.eceblk.pDCTBLK   = &expblk.dctblk;

  00148	48 8d 84 24 68
	01 01 00	 lea	 rax, QWORD PTR expblk$[rsp+65544]
  00150	48 89 84 24 80
	02 01 00	 mov	 QWORD PTR expblk$[rsp+65824], rax

; 291  :     expblk.eceblk.max_index = 0xFFFF >> (16 - bits);

  00158	0f b6 44 24 21	 movzx	 eax, BYTE PTR bits$[rsp]
  0015d	b9 10 00 00 00	 mov	 ecx, 16
  00162	2b c8		 sub	 ecx, eax
  00164	8b c1		 mov	 eax, ecx
  00166	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0016b	89 4c 24 78	 mov	 DWORD PTR tv642[rsp], ecx
  0016f	0f b6 c8	 movzx	 ecx, al
  00172	8b 44 24 78	 mov	 eax, DWORD PTR tv642[rsp]
  00176	d3 f8		 sar	 eax, cl
  00178	66 89 84 24 90
	02 01 00	 mov	 WORD PTR expblk$[rsp+65840], ax

; 292  :     expblk.eceblk.pECE      = &expblk.ece;

  00180	48 8d 84 24 e8
	02 03 00	 lea	 rax, QWORD PTR expblk$[rsp+197000]
  00188	48 89 84 24 88
	02 01 00	 mov	 QWORD PTR expblk$[rsp+65832], rax

; 293  : 
; 294  :     expblk.op1blk.arn       = pCMPSCBLK->r1;

  00190	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00198	0f b6 40 40	 movzx	 eax, BYTE PTR [rax+64]
  0019c	89 84 24 b8 02
	03 00		 mov	 DWORD PTR expblk$[rsp+196952], eax

; 295  :     expblk.op1blk.regs      = pCMPSCBLK->regs;

  001a3	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  001ab	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001af	48 89 84 24 98
	02 03 00	 mov	 QWORD PTR expblk$[rsp+196920], rax

; 296  :     expblk.op1blk.pkey      = pCMPSCBLK->regs->psw.pkey;

  001b7	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  001bf	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001c3	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  001c7	88 84 24 bc 02
	03 00		 mov	 BYTE PTR expblk$[rsp+196956], al

; 297  : 
; 298  :     expblk.op2blk.arn       = pCMPSCBLK->r2;

  001ce	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  001d6	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  001da	89 84 24 e0 02
	03 00		 mov	 DWORD PTR expblk$[rsp+196992], eax

; 299  :     expblk.op2blk.regs      = pCMPSCBLK->regs;

  001e1	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  001e9	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001ed	48 89 84 24 c0
	02 03 00	 mov	 QWORD PTR expblk$[rsp+196960], rax

; 300  :     expblk.op2blk.pkey      = pCMPSCBLK->regs->psw.pkey;

  001f5	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  001fd	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00201	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00205	88 84 24 e4 02
	03 00		 mov	 BYTE PTR expblk$[rsp+196996], al

; 301  : 
; 302  : #ifdef CMPSC_EXPAND8
; 303  : 
; 304  :     // Expand individual index symbols until CBN==0...
; 305  : 
; 306  :     if ((pCMPSCBLK->cbn & 7) != 0)

  0020c	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00214	0f b6 40 45	 movzx	 eax, BYTE PTR [rax+69]
  00218	83 e0 07	 and	 eax, 7
  0021b	85 c0		 test	 eax, eax
  0021d	0f 84 ee 02 00
	00		 je	 $LN29@z900_cmpsc
$LN2@z900_cmpsc:

; 307  :     {
; 308  :         while (nCPUAmt < (U64) pCMPSCBLK->nCPUAmt && (pCMPSCBLK->cbn & 7) != 0)

  00223	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0022b	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  0022e	48 39 44 24 28	 cmp	 QWORD PTR nCPUAmt$[rsp], rax
  00233	0f 83 d8 02 00
	00		 jae	 $LN3@z900_cmpsc
  00239	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00241	0f b6 40 45	 movzx	 eax, BYTE PTR [rax+69]
  00245	83 e0 07	 and	 eax, 7
  00248	85 c0		 test	 eax, eax
  0024a	0f 84 c1 02 00
	00		 je	 $LN3@z900_cmpsc

; 309  :         {
; 310  :             // Get index symbol...
; 311  : 
; 312  :             if (unlikely( !(expblk.SRC_bytes = pGetIndex( &giblk ))))

  00250	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR giblk$[rsp]
  00258	ff 94 24 80 00
	00 00		 call	 QWORD PTR pGetIndex$[rsp]
  0025f	88 84 24 fc 02
	03 00		 mov	 BYTE PTR expblk$[rsp+197020], al
  00266	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  0026e	85 c0		 test	 eax, eax
  00270	75 0a		 jne	 SHORT $LN45@z900_cmpsc
  00272	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv155[rsp], 1
  0027a	eb 08		 jmp	 SHORT $LN46@z900_cmpsc
$LN45@z900_cmpsc:
  0027c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv155[rsp], 0
$LN46@z900_cmpsc:
  00284	83 7c 24 30 00	 cmp	 DWORD PTR tv155[rsp], 0
  00289	74 0a		 je	 SHORT $LN49@z900_cmpsc
  0028b	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv195[rsp], 1
  00293	eb 08		 jmp	 SHORT $LN50@z900_cmpsc
$LN49@z900_cmpsc:
  00295	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv195[rsp], 0
$LN50@z900_cmpsc:
  0029d	83 7c 24 34 00	 cmp	 DWORD PTR tv195[rsp], 0
  002a2	74 1a		 je	 SHORT $LN30@z900_cmpsc

; 313  :                 RETCC0( &expblk.op1blk );

  002a4	48 8d 94 24 98
	02 03 00	 lea	 rdx, QWORD PTR expblk$[rsp+196920]
  002ac	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  002b4	e8 00 00 00 00	 call	 z900_CC0
  002b9	e9 59 09 00 00	 jmp	 $LN1@z900_cmpsc
$LN30@z900_cmpsc:

; 314  : 
; 315  :             // Expand it...
; 316  : 
; 317  :             expblk.index = index[0];

  002be	b8 02 00 00 00	 mov	 eax, 2
  002c3	48 6b c0 00	 imul	 rax, rax, 0
  002c7	0f b7 84 04 00
	03 03 00	 movzx	 eax, WORD PTR index$[rsp+rax]
  002cf	66 89 84 24 fa
	02 03 00	 mov	 WORD PTR expblk$[rsp+197018], ax

; 318  : 
; 319  :             if (unlikely( !ARCH_DEP( cmpsc_Expand_Index )( pCMPSCBLK, &expblk )))

  002d7	48 8d 94 24 60
	01 00 00	 lea	 rdx, QWORD PTR expblk$[rsp]
  002df	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  002e7	e8 00 00 00 00	 call	 z900_cmpsc_Expand_Index
  002ec	0f b6 c0	 movzx	 eax, al
  002ef	85 c0		 test	 eax, eax
  002f1	75 0a		 jne	 SHORT $LN51@z900_cmpsc
  002f3	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv207[rsp], 1
  002fb	eb 08		 jmp	 SHORT $LN52@z900_cmpsc
$LN51@z900_cmpsc:
  002fd	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv207[rsp], 0
$LN52@z900_cmpsc:
  00305	83 7c 24 38 00	 cmp	 DWORD PTR tv207[rsp], 0
  0030a	74 0a		 je	 SHORT $LN55@z900_cmpsc
  0030c	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv216[rsp], 1
  00314	eb 08		 jmp	 SHORT $LN56@z900_cmpsc
$LN55@z900_cmpsc:
  00316	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv216[rsp], 0
$LN56@z900_cmpsc:
  0031e	83 7c 24 3c 00	 cmp	 DWORD PTR tv216[rsp], 0
  00323	74 0d		 je	 SHORT $LN31@z900_cmpsc

; 320  :                 return expblk.rc;

  00325	0f b6 84 24 fd
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197021]
  0032d	e9 e5 08 00 00	 jmp	 $LN1@z900_cmpsc
$LN31@z900_cmpsc:

; 321  : 
; 322  :             // Bump source...
; 323  : 
; 324  :             nCPUAmt          += expblk.SRC_bytes;

  00332	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  0033a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR nCPUAmt$[rsp]
  0033f	48 03 c8	 add	 rcx, rax
  00342	48 8b c1	 mov	 rax, rcx
  00345	48 89 44 24 28	 mov	 QWORD PTR nCPUAmt$[rsp], rax

; 325  :             pCMPSCBLK->pOp2  += expblk.SRC_bytes;

  0034a	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  00352	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0035a	48 03 41 28	 add	 rax, QWORD PTR [rcx+40]
  0035e	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00366	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 326  :             pCMPSCBLK->nLen2 -= expblk.SRC_bytes;

  0036a	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  00372	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0037a	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0037e	48 2b c8	 sub	 rcx, rax
  00381	48 8b c1	 mov	 rax, rcx
  00384	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0038c	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 327  :             pCMPSCBLK->cbn   += bits;

  00390	0f b6 44 24 21	 movzx	 eax, BYTE PTR bits$[rsp]
  00395	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0039d	0f b6 49 45	 movzx	 ecx, BYTE PTR [rcx+69]
  003a1	03 c8		 add	 ecx, eax
  003a3	8b c1		 mov	 eax, ecx
  003a5	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  003ad	88 41 45	 mov	 BYTE PTR [rcx+69], al
$LN6@z900_cmpsc:

; 328  : 
; 329  :             MEMBLK_BUMP( &expblk.op2blk, pCMPSCBLK->pOp2 );

  003b0	48 8b 84 24 c8
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196968]
  003b8	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  003be	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  003c6	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  003ca	73 0a		 jae	 SHORT $LN59@z900_cmpsc
  003cc	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv242[rsp], 1
  003d4	eb 08		 jmp	 SHORT $LN60@z900_cmpsc
$LN59@z900_cmpsc:
  003d6	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv242[rsp], 0
$LN60@z900_cmpsc:
  003de	83 7c 24 40 00	 cmp	 DWORD PTR tv242[rsp], 0
  003e3	75 4d		 jne	 SHORT $LN32@z900_cmpsc
  003e5	48 8b 84 24 c8
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196968]
  003ed	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  003f3	48 89 84 24 c8
	02 03 00	 mov	 QWORD PTR expblk$[rsp+196968], rax
  003fb	b8 08 00 00 00	 mov	 eax, 8
  00400	48 6b c0 01	 imul	 rax, rax, 1
  00404	b9 08 00 00 00	 mov	 ecx, 8
  00409	48 6b c9 00	 imul	 rcx, rcx, 0
  0040d	48 8b 84 04 d0
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+rax+196976]
  00415	48 89 84 0c d0
	02 03 00	 mov	 QWORD PTR expblk$[rsp+rcx+196976], rax
  0041d	b8 08 00 00 00	 mov	 eax, 8
  00422	48 6b c0 01	 imul	 rax, rax, 1
  00426	48 c7 84 04 d0
	02 03 00 00 00
	00 00		 mov	 QWORD PTR expblk$[rsp+rax+196976], 0
$LN32@z900_cmpsc:
  00432	33 c0		 xor	 eax, eax
  00434	85 c0		 test	 eax, eax
  00436	0f 85 74 ff ff
	ff		 jne	 $LN6@z900_cmpsc

; 330  : 
; 331  :             // Bump destination...
; 332  : 
; 333  :             pCMPSCBLK->pOp1  += expblk.symlen;

  0043c	0f b7 84 24 f8
	02 03 00	 movzx	 eax, WORD PTR expblk$[rsp+197016]
  00444	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0044c	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00450	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00458	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 334  :             pCMPSCBLK->nLen1 -= expblk.symlen;

  0045c	0f b7 84 24 f8
	02 03 00	 movzx	 eax, WORD PTR expblk$[rsp+197016]
  00464	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0046c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0046f	48 2b c8	 sub	 rcx, rax
  00472	48 8b c1	 mov	 rax, rcx
  00475	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0047d	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN9@z900_cmpsc:

; 335  : 
; 336  :             MEMBLK_BUMP( &expblk.op1blk, pCMPSCBLK->pOp1 );

  00480	48 8b 84 24 a0
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196928]
  00488	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  0048e	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00496	48 39 41 20	 cmp	 QWORD PTR [rcx+32], rax
  0049a	73 0a		 jae	 SHORT $LN63@z900_cmpsc
  0049c	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv268[rsp], 1
  004a4	eb 08		 jmp	 SHORT $LN64@z900_cmpsc
$LN63@z900_cmpsc:
  004a6	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv268[rsp], 0
$LN64@z900_cmpsc:
  004ae	83 7c 24 44 00	 cmp	 DWORD PTR tv268[rsp], 0
  004b3	75 4d		 jne	 SHORT $LN33@z900_cmpsc
  004b5	48 8b 84 24 a0
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196928]
  004bd	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  004c3	48 89 84 24 a0
	02 03 00	 mov	 QWORD PTR expblk$[rsp+196928], rax
  004cb	b8 08 00 00 00	 mov	 eax, 8
  004d0	48 6b c0 01	 imul	 rax, rax, 1
  004d4	b9 08 00 00 00	 mov	 ecx, 8
  004d9	48 6b c9 00	 imul	 rcx, rcx, 0
  004dd	48 8b 84 04 a8
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+rax+196936]
  004e5	48 89 84 0c a8
	02 03 00	 mov	 QWORD PTR expblk$[rsp+rcx+196936], rax
  004ed	b8 08 00 00 00	 mov	 eax, 8
  004f2	48 6b c0 01	 imul	 rax, rax, 1
  004f6	48 c7 84 04 a8
	02 03 00 00 00
	00 00		 mov	 QWORD PTR expblk$[rsp+rax+196936], 0
$LN33@z900_cmpsc:
  00502	33 c0		 xor	 eax, eax
  00504	85 c0		 test	 eax, eax
  00506	0f 85 74 ff ff
	ff		 jne	 $LN9@z900_cmpsc

; 337  :         }

  0050c	e9 12 fd ff ff	 jmp	 $LN2@z900_cmpsc
$LN3@z900_cmpsc:
$LN29@z900_cmpsc:

; 338  :     }
; 339  : 
; 340  :     // Now expand eight (8) index symbols at a time...
; 341  : 
; 342  :     if ((pCMPSCBLK->cbn & 7) == 0)

  00511	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00519	0f b6 40 45	 movzx	 eax, BYTE PTR [rax+69]
  0051d	83 e0 07	 and	 eax, 7
  00520	85 c0		 test	 eax, eax
  00522	0f 85 03 04 00
	00		 jne	 $LN34@z900_cmpsc

; 343  :     {
; 344  :         GetIndex**  ppGet8Index;    // Ptr to GetNext8Index table for this CDSS-1
; 345  :         GetIndex*   pGet8Index;     // Ptr to GetNext8Index function for this CBN
; 346  :         CMPSCBLK    save_cmpsc;     // Work context
; 347  :         MEMBLK      save_op1blk;    // Work context
; 348  :         MEMBLK      save_op2blk;    // Work context
; 349  :         U8          i;              // (work)
; 350  : 
; 351  :         ppGet8Index = ARCH_DEP( Get8IndexCDSSTab )[ pCMPSCBLK->cdss - 1 ];

  00528	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00530	0f b6 40 44	 movzx	 eax, BYTE PTR [rax+68]
  00534	ff c8		 dec	 eax
  00536	48 98		 cdqe
  00538	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:z900_Get8IndexCDSSTab
  0053f	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00543	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR ppGet8Index$2[rsp], rax

; 352  :         pGet8Index  = ppGet8Index[ 0 ]; // (always CBN==0)

  0054b	b8 08 00 00 00	 mov	 eax, 8
  00550	48 6b c0 00	 imul	 rax, rax, 0
  00554	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ppGet8Index$2[rsp]
  0055c	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00560	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pGet8Index$3[rsp], rax

; 353  : 
; 354  :         // Save context
; 355  : 
; 356  :         memcpy( &save_cmpsc,  pCMPSCBLK,      sizeof( CMPSCBLK ));

  00568	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR save_cmpsc$6[rsp]
  00570	48 8b f8	 mov	 rdi, rax
  00573	48 8b b4 24 40
	03 03 00	 mov	 rsi, QWORD PTR pCMPSCBLK$[rsp]
  0057b	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00580	f3 a4		 rep movsb

; 357  :         memcpy( &save_op1blk, &expblk.op1blk, sizeof( MEMBLK   ));

  00582	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR save_op1blk$4[rsp]
  0058a	48 8d 8c 24 98
	02 03 00	 lea	 rcx, QWORD PTR expblk$[rsp+196920]
  00592	48 8b f8	 mov	 rdi, rax
  00595	48 8b f1	 mov	 rsi, rcx
  00598	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  0059d	f3 a4		 rep movsb

; 358  :         memcpy( &save_op2blk, &expblk.op2blk, sizeof( MEMBLK   ));

  0059f	48 8d 84 24 e8
	00 00 00	 lea	 rax, QWORD PTR save_op2blk$5[rsp]
  005a7	48 8d 8c 24 c0
	02 03 00	 lea	 rcx, QWORD PTR expblk$[rsp+196960]
  005af	48 8b f8	 mov	 rdi, rax
  005b2	48 8b f1	 mov	 rsi, rcx
  005b5	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  005ba	f3 a4		 rep movsb
$LN10@z900_cmpsc:

; 359  : 
; 360  :         while (nCPUAmt < (U64) pCMPSCBLK->nCPUAmt)

  005bc	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  005c4	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  005c7	48 39 44 24 28	 cmp	 QWORD PTR nCPUAmt$[rsp], rax
  005cc	0f 83 59 03 00
	00		 jae	 $LN11@z900_cmpsc

; 361  :         {
; 362  :             // Retrieve 8 index symbols from operand-2...
; 363  : 
; 364  :             if (unlikely( !(expblk.SRC_bytes = pGet8Index( &giblk ))))

  005d2	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR giblk$[rsp]
  005da	ff 94 24 98 00
	00 00		 call	 QWORD PTR pGet8Index$3[rsp]
  005e1	88 84 24 fc 02
	03 00		 mov	 BYTE PTR expblk$[rsp+197020], al
  005e8	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  005f0	85 c0		 test	 eax, eax
  005f2	75 0a		 jne	 SHORT $LN65@z900_cmpsc
  005f4	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv318[rsp], 1
  005fc	eb 08		 jmp	 SHORT $LN66@z900_cmpsc
$LN65@z900_cmpsc:
  005fe	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv318[rsp], 0
$LN66@z900_cmpsc:
  00606	83 7c 24 48 00	 cmp	 DWORD PTR tv318[rsp], 0
  0060b	74 0a		 je	 SHORT $LN69@z900_cmpsc
  0060d	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv358[rsp], 1
  00615	eb 08		 jmp	 SHORT $LN70@z900_cmpsc
$LN69@z900_cmpsc:
  00617	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv358[rsp], 0
$LN70@z900_cmpsc:
  0061f	83 7c 24 4c 00	 cmp	 DWORD PTR tv358[rsp], 0
  00624	74 05		 je	 SHORT $LN35@z900_cmpsc

; 365  :                 break;

  00626	e9 00 03 00 00	 jmp	 $LN11@z900_cmpsc
$LN35@z900_cmpsc:

; 366  : 
; 367  :             // Bump source...
; 368  : 
; 369  :             nCPUAmt          += expblk.SRC_bytes;

  0062b	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  00633	48 8b 4c 24 28	 mov	 rcx, QWORD PTR nCPUAmt$[rsp]
  00638	48 03 c8	 add	 rcx, rax
  0063b	48 8b c1	 mov	 rax, rcx
  0063e	48 89 44 24 28	 mov	 QWORD PTR nCPUAmt$[rsp], rax

; 370  :             pCMPSCBLK->pOp2  += expblk.SRC_bytes;

  00643	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  0064b	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00653	48 03 41 28	 add	 rax, QWORD PTR [rcx+40]
  00657	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0065f	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 371  :             pCMPSCBLK->nLen2 -= expblk.SRC_bytes;

  00663	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  0066b	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00673	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00677	48 2b c8	 sub	 rcx, rax
  0067a	48 8b c1	 mov	 rax, rcx
  0067d	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00685	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
$LN14@z900_cmpsc:

; 372  : 
; 373  :             MEMBLK_BUMP( &expblk.op2blk, pCMPSCBLK->pOp2 );

  00689	48 8b 84 24 c8
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196968]
  00691	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00697	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0069f	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  006a3	73 0a		 jae	 SHORT $LN73@z900_cmpsc
  006a5	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv378[rsp], 1
  006ad	eb 08		 jmp	 SHORT $LN74@z900_cmpsc
$LN73@z900_cmpsc:
  006af	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv378[rsp], 0
$LN74@z900_cmpsc:
  006b7	83 7c 24 50 00	 cmp	 DWORD PTR tv378[rsp], 0
  006bc	75 4d		 jne	 SHORT $LN36@z900_cmpsc
  006be	48 8b 84 24 c8
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196968]
  006c6	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  006cc	48 89 84 24 c8
	02 03 00	 mov	 QWORD PTR expblk$[rsp+196968], rax
  006d4	b8 08 00 00 00	 mov	 eax, 8
  006d9	48 6b c0 01	 imul	 rax, rax, 1
  006dd	b9 08 00 00 00	 mov	 ecx, 8
  006e2	48 6b c9 00	 imul	 rcx, rcx, 0
  006e6	48 8b 84 04 d0
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+rax+196976]
  006ee	48 89 84 0c d0
	02 03 00	 mov	 QWORD PTR expblk$[rsp+rcx+196976], rax
  006f6	b8 08 00 00 00	 mov	 eax, 8
  006fb	48 6b c0 01	 imul	 rax, rax, 1
  006ff	48 c7 84 04 d0
	02 03 00 00 00
	00 00		 mov	 QWORD PTR expblk$[rsp+rax+196976], 0
$LN36@z900_cmpsc:
  0070b	33 c0		 xor	 eax, eax
  0070d	85 c0		 test	 eax, eax
  0070f	0f 85 74 ff ff
	ff		 jne	 $LN14@z900_cmpsc

; 374  : 
; 375  :             // Expand each of the 8 individually into operand-1...
; 376  : 
; 377  :             for (i=0; i < 8; i++)

  00715	c6 44 24 20 00	 mov	 BYTE PTR i$1[rsp], 0
  0071a	eb 0b		 jmp	 SHORT $LN17@z900_cmpsc
$LN15@z900_cmpsc:
  0071c	0f b6 44 24 20	 movzx	 eax, BYTE PTR i$1[rsp]
  00721	fe c0		 inc	 al
  00723	88 44 24 20	 mov	 BYTE PTR i$1[rsp], al
$LN17@z900_cmpsc:
  00727	0f b6 44 24 20	 movzx	 eax, BYTE PTR i$1[rsp]
  0072c	83 f8 08	 cmp	 eax, 8
  0072f	0f 8d 91 01 00
	00		 jge	 $LN16@z900_cmpsc

; 378  :             {
; 379  :                 expblk.index = index[i];

  00735	0f b6 44 24 20	 movzx	 eax, BYTE PTR i$1[rsp]
  0073a	0f b7 84 44 00
	03 03 00	 movzx	 eax, WORD PTR index$[rsp+rax*2]
  00742	66 89 84 24 fa
	02 03 00	 mov	 WORD PTR expblk$[rsp+197018], ax

; 380  : 
; 381  :                 if (unlikely( !ARCH_DEP( cmpsc_Expand_Index )( pCMPSCBLK, &expblk )))

  0074a	48 8d 94 24 60
	01 00 00	 lea	 rdx, QWORD PTR expblk$[rsp]
  00752	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0075a	e8 00 00 00 00	 call	 z900_cmpsc_Expand_Index
  0075f	0f b6 c0	 movzx	 eax, al
  00762	85 c0		 test	 eax, eax
  00764	75 0a		 jne	 SHORT $LN75@z900_cmpsc
  00766	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv399[rsp], 1
  0076e	eb 08		 jmp	 SHORT $LN76@z900_cmpsc
$LN75@z900_cmpsc:
  00770	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv399[rsp], 0
$LN76@z900_cmpsc:
  00778	83 7c 24 54 00	 cmp	 DWORD PTR tv399[rsp], 0
  0077d	74 0a		 je	 SHORT $LN79@z900_cmpsc
  0077f	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv408[rsp], 1
  00787	eb 08		 jmp	 SHORT $LN80@z900_cmpsc
$LN79@z900_cmpsc:
  00789	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv408[rsp], 0
$LN80@z900_cmpsc:
  00791	83 7c 24 58 00	 cmp	 DWORD PTR tv408[rsp], 0
  00796	74 59		 je	 SHORT $LN37@z900_cmpsc

; 382  :                 {
; 383  :                     // Restore context
; 384  : 
; 385  :                     memcpy( pCMPSCBLK,      &save_cmpsc,  sizeof( CMPSCBLK ));

  00798	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR save_cmpsc$6[rsp]
  007a0	48 8b bc 24 40
	03 03 00	 mov	 rdi, QWORD PTR pCMPSCBLK$[rsp]
  007a8	48 8b f0	 mov	 rsi, rax
  007ab	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  007b0	f3 a4		 rep movsb

; 386  :                     memcpy( &expblk.op1blk, &save_op1blk, sizeof( MEMBLK   ));

  007b2	48 8d 84 24 98
	02 03 00	 lea	 rax, QWORD PTR expblk$[rsp+196920]
  007ba	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR save_op1blk$4[rsp]
  007c2	48 8b f8	 mov	 rdi, rax
  007c5	48 8b f1	 mov	 rsi, rcx
  007c8	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  007cd	f3 a4		 rep movsb

; 387  :                     memcpy( &expblk.op2blk, &save_op2blk, sizeof( MEMBLK   ));

  007cf	48 8d 84 24 c0
	02 03 00	 lea	 rax, QWORD PTR expblk$[rsp+196960]
  007d7	48 8d 8c 24 e8
	00 00 00	 lea	 rcx, QWORD PTR save_op2blk$5[rsp]
  007df	48 8b f8	 mov	 rdi, rax
  007e2	48 8b f1	 mov	 rsi, rcx
  007e5	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  007ea	f3 a4		 rep movsb

; 388  :                     break; // (i < 8)

  007ec	e9 d5 00 00 00	 jmp	 $LN16@z900_cmpsc
$LN37@z900_cmpsc:

; 389  :                 }
; 390  : 
; 391  :                 // Bump destination...
; 392  : 
; 393  :                 pCMPSCBLK->pOp1  += expblk.symlen;

  007f1	0f b7 84 24 f8
	02 03 00	 movzx	 eax, WORD PTR expblk$[rsp+197016]
  007f9	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00801	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00805	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0080d	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 394  :                 pCMPSCBLK->nLen1 -= expblk.symlen;

  00811	0f b7 84 24 f8
	02 03 00	 movzx	 eax, WORD PTR expblk$[rsp+197016]
  00819	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00821	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00824	48 2b c8	 sub	 rcx, rax
  00827	48 8b c1	 mov	 rax, rcx
  0082a	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00832	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN20@z900_cmpsc:

; 395  : //              pCMPSCBLK->cbn   += bits;
; 396  : 
; 397  :                 MEMBLK_BUMP( &expblk.op1blk, pCMPSCBLK->pOp1 );

  00835	48 8b 84 24 a0
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196928]
  0083d	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00843	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0084b	48 39 41 20	 cmp	 QWORD PTR [rcx+32], rax
  0084f	73 0a		 jae	 SHORT $LN83@z900_cmpsc
  00851	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv447[rsp], 1
  00859	eb 08		 jmp	 SHORT $LN84@z900_cmpsc
$LN83@z900_cmpsc:
  0085b	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv447[rsp], 0
$LN84@z900_cmpsc:
  00863	83 7c 24 5c 00	 cmp	 DWORD PTR tv447[rsp], 0
  00868	75 4d		 jne	 SHORT $LN38@z900_cmpsc
  0086a	48 8b 84 24 a0
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196928]
  00872	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00878	48 89 84 24 a0
	02 03 00	 mov	 QWORD PTR expblk$[rsp+196928], rax
  00880	b8 08 00 00 00	 mov	 eax, 8
  00885	48 6b c0 01	 imul	 rax, rax, 1
  00889	b9 08 00 00 00	 mov	 ecx, 8
  0088e	48 6b c9 00	 imul	 rcx, rcx, 0
  00892	48 8b 84 04 a8
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+rax+196936]
  0089a	48 89 84 0c a8
	02 03 00	 mov	 QWORD PTR expblk$[rsp+rcx+196936], rax
  008a2	b8 08 00 00 00	 mov	 eax, 8
  008a7	48 6b c0 01	 imul	 rax, rax, 1
  008ab	48 c7 84 04 a8
	02 03 00 00 00
	00 00		 mov	 QWORD PTR expblk$[rsp+rax+196936], 0
$LN38@z900_cmpsc:
  008b7	33 c0		 xor	 eax, eax
  008b9	85 c0		 test	 eax, eax
  008bb	0f 85 74 ff ff
	ff		 jne	 $LN20@z900_cmpsc

; 398  :             }

  008c1	e9 56 fe ff ff	 jmp	 $LN15@z900_cmpsc
$LN16@z900_cmpsc:

; 399  : 
; 400  :             if (i < 8)

  008c6	0f b6 44 24 20	 movzx	 eax, BYTE PTR i$1[rsp]
  008cb	83 f8 08	 cmp	 eax, 8
  008ce	7d 02		 jge	 SHORT $LN39@z900_cmpsc

; 401  :                 break;

  008d0	eb 59		 jmp	 SHORT $LN11@z900_cmpsc
$LN39@z900_cmpsc:

; 402  : 
; 403  :             // Save context
; 404  : 
; 405  :             memcpy( &save_cmpsc,  pCMPSCBLK,      sizeof( CMPSCBLK ));

  008d2	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR save_cmpsc$6[rsp]
  008da	48 8b f8	 mov	 rdi, rax
  008dd	48 8b b4 24 40
	03 03 00	 mov	 rsi, QWORD PTR pCMPSCBLK$[rsp]
  008e5	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  008ea	f3 a4		 rep movsb

; 406  :             memcpy( &save_op1blk, &expblk.op1blk, sizeof( MEMBLK   ));

  008ec	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR save_op1blk$4[rsp]
  008f4	48 8d 8c 24 98
	02 03 00	 lea	 rcx, QWORD PTR expblk$[rsp+196920]
  008fc	48 8b f8	 mov	 rdi, rax
  008ff	48 8b f1	 mov	 rsi, rcx
  00902	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00907	f3 a4		 rep movsb

; 407  :             memcpy( &save_op2blk, &expblk.op2blk, sizeof( MEMBLK   ));

  00909	48 8d 84 24 e8
	00 00 00	 lea	 rax, QWORD PTR save_op2blk$5[rsp]
  00911	48 8d 8c 24 c0
	02 03 00	 lea	 rcx, QWORD PTR expblk$[rsp+196960]
  00919	48 8b f8	 mov	 rdi, rax
  0091c	48 8b f1	 mov	 rsi, rcx
  0091f	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00924	f3 a4		 rep movsb

; 408  :         }

  00926	e9 91 fc ff ff	 jmp	 $LN10@z900_cmpsc
$LN11@z900_cmpsc:
$LN34@z900_cmpsc:
$LN21@z900_cmpsc:

; 409  :     }
; 410  : 
; 411  : #endif // CMPSC_EXPAND8
; 412  : 
; 413  :     // Finish up any remainder...
; 414  : 
; 415  :     while (nCPUAmt < (U64) pCMPSCBLK->nCPUAmt)

  0092b	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00933	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00936	48 39 44 24 28	 cmp	 QWORD PTR nCPUAmt$[rsp], rax
  0093b	0f 83 c1 02 00
	00		 jae	 $LN22@z900_cmpsc

; 416  :     {
; 417  :         // Get index symbol...
; 418  : 
; 419  :         if (unlikely( !(expblk.SRC_bytes = pGetIndex( &giblk ))))

  00941	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR giblk$[rsp]
  00949	ff 94 24 80 00
	00 00		 call	 QWORD PTR pGetIndex$[rsp]
  00950	88 84 24 fc 02
	03 00		 mov	 BYTE PTR expblk$[rsp+197020], al
  00957	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  0095f	85 c0		 test	 eax, eax
  00961	75 0a		 jne	 SHORT $LN85@z900_cmpsc
  00963	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv487[rsp], 1
  0096b	eb 08		 jmp	 SHORT $LN86@z900_cmpsc
$LN85@z900_cmpsc:
  0096d	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv487[rsp], 0
$LN86@z900_cmpsc:
  00975	83 7c 24 60 00	 cmp	 DWORD PTR tv487[rsp], 0
  0097a	74 0a		 je	 SHORT $LN89@z900_cmpsc
  0097c	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv495[rsp], 1
  00984	eb 08		 jmp	 SHORT $LN90@z900_cmpsc
$LN89@z900_cmpsc:
  00986	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv495[rsp], 0
$LN90@z900_cmpsc:
  0098e	83 7c 24 64 00	 cmp	 DWORD PTR tv495[rsp], 0
  00993	74 1a		 je	 SHORT $LN40@z900_cmpsc

; 420  :             RETCC0( &expblk.op1blk );

  00995	48 8d 94 24 98
	02 03 00	 lea	 rdx, QWORD PTR expblk$[rsp+196920]
  0099d	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  009a5	e8 00 00 00 00	 call	 z900_CC0
  009aa	e9 68 02 00 00	 jmp	 $LN1@z900_cmpsc
$LN40@z900_cmpsc:

; 421  : 
; 422  :         // Expand it...
; 423  : 
; 424  :         expblk.index = index[0];

  009af	b8 02 00 00 00	 mov	 eax, 2
  009b4	48 6b c0 00	 imul	 rax, rax, 0
  009b8	0f b7 84 04 00
	03 03 00	 movzx	 eax, WORD PTR index$[rsp+rax]
  009c0	66 89 84 24 fa
	02 03 00	 mov	 WORD PTR expblk$[rsp+197018], ax

; 425  : 
; 426  :         if (unlikely( !ARCH_DEP( cmpsc_Expand_Index )( pCMPSCBLK, &expblk )))

  009c8	48 8d 94 24 60
	01 00 00	 lea	 rdx, QWORD PTR expblk$[rsp]
  009d0	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  009d8	e8 00 00 00 00	 call	 z900_cmpsc_Expand_Index
  009dd	0f b6 c0	 movzx	 eax, al
  009e0	85 c0		 test	 eax, eax
  009e2	75 0a		 jne	 SHORT $LN91@z900_cmpsc
  009e4	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv507[rsp], 1
  009ec	eb 08		 jmp	 SHORT $LN92@z900_cmpsc
$LN91@z900_cmpsc:
  009ee	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv507[rsp], 0
$LN92@z900_cmpsc:
  009f6	83 7c 24 68 00	 cmp	 DWORD PTR tv507[rsp], 0
  009fb	74 0a		 je	 SHORT $LN95@z900_cmpsc
  009fd	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv516[rsp], 1
  00a05	eb 08		 jmp	 SHORT $LN96@z900_cmpsc
$LN95@z900_cmpsc:
  00a07	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv516[rsp], 0
$LN96@z900_cmpsc:
  00a0f	83 7c 24 6c 00	 cmp	 DWORD PTR tv516[rsp], 0
  00a14	74 0d		 je	 SHORT $LN41@z900_cmpsc

; 427  :             return expblk.rc;

  00a16	0f b6 84 24 fd
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197021]
  00a1e	e9 f4 01 00 00	 jmp	 $LN1@z900_cmpsc
$LN41@z900_cmpsc:

; 428  : 
; 429  :         // Bump source...
; 430  : 
; 431  :         nCPUAmt          += expblk.SRC_bytes;

  00a23	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  00a2b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR nCPUAmt$[rsp]
  00a30	48 03 c8	 add	 rcx, rax
  00a33	48 8b c1	 mov	 rax, rcx
  00a36	48 89 44 24 28	 mov	 QWORD PTR nCPUAmt$[rsp], rax

; 432  :         pCMPSCBLK->pOp2  += expblk.SRC_bytes;

  00a3b	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  00a43	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00a4b	48 03 41 28	 add	 rax, QWORD PTR [rcx+40]
  00a4f	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00a57	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 433  :         pCMPSCBLK->nLen2 -= expblk.SRC_bytes;

  00a5b	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  00a63	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00a6b	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00a6f	48 2b c8	 sub	 rcx, rax
  00a72	48 8b c1	 mov	 rax, rcx
  00a75	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00a7d	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 434  :         pCMPSCBLK->cbn   += bits;

  00a81	0f b6 44 24 21	 movzx	 eax, BYTE PTR bits$[rsp]
  00a86	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00a8e	0f b6 49 45	 movzx	 ecx, BYTE PTR [rcx+69]
  00a92	03 c8		 add	 ecx, eax
  00a94	8b c1		 mov	 eax, ecx
  00a96	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00a9e	88 41 45	 mov	 BYTE PTR [rcx+69], al
$LN25@z900_cmpsc:

; 435  : 
; 436  :         MEMBLK_BUMP( &expblk.op2blk, pCMPSCBLK->pOp2 );

  00aa1	48 8b 84 24 c8
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196968]
  00aa9	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00aaf	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00ab7	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  00abb	73 0a		 jae	 SHORT $LN99@z900_cmpsc
  00abd	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv542[rsp], 1
  00ac5	eb 08		 jmp	 SHORT $LN100@z900_cmpsc
$LN99@z900_cmpsc:
  00ac7	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv542[rsp], 0
$LN100@z900_cmpsc:
  00acf	83 7c 24 70 00	 cmp	 DWORD PTR tv542[rsp], 0
  00ad4	75 4d		 jne	 SHORT $LN42@z900_cmpsc
  00ad6	48 8b 84 24 c8
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196968]
  00ade	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00ae4	48 89 84 24 c8
	02 03 00	 mov	 QWORD PTR expblk$[rsp+196968], rax
  00aec	b8 08 00 00 00	 mov	 eax, 8
  00af1	48 6b c0 01	 imul	 rax, rax, 1
  00af5	b9 08 00 00 00	 mov	 ecx, 8
  00afa	48 6b c9 00	 imul	 rcx, rcx, 0
  00afe	48 8b 84 04 d0
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+rax+196976]
  00b06	48 89 84 0c d0
	02 03 00	 mov	 QWORD PTR expblk$[rsp+rcx+196976], rax
  00b0e	b8 08 00 00 00	 mov	 eax, 8
  00b13	48 6b c0 01	 imul	 rax, rax, 1
  00b17	48 c7 84 04 d0
	02 03 00 00 00
	00 00		 mov	 QWORD PTR expblk$[rsp+rax+196976], 0
$LN42@z900_cmpsc:
  00b23	33 c0		 xor	 eax, eax
  00b25	85 c0		 test	 eax, eax
  00b27	0f 85 74 ff ff
	ff		 jne	 $LN25@z900_cmpsc

; 437  : 
; 438  :         // Bump destination...
; 439  : 
; 440  :         pCMPSCBLK->pOp1  += expblk.symlen;

  00b2d	0f b7 84 24 f8
	02 03 00	 movzx	 eax, WORD PTR expblk$[rsp+197016]
  00b35	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00b3d	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00b41	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00b49	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 441  :         pCMPSCBLK->nLen1 -= expblk.symlen;

  00b4d	0f b7 84 24 f8
	02 03 00	 movzx	 eax, WORD PTR expblk$[rsp+197016]
  00b55	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00b5d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00b60	48 2b c8	 sub	 rcx, rax
  00b63	48 8b c1	 mov	 rax, rcx
  00b66	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00b6e	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN28@z900_cmpsc:

; 442  : 
; 443  :         MEMBLK_BUMP( &expblk.op1blk, pCMPSCBLK->pOp1 );

  00b71	48 8b 84 24 a0
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196928]
  00b79	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00b7f	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00b87	48 39 41 20	 cmp	 QWORD PTR [rcx+32], rax
  00b8b	73 0a		 jae	 SHORT $LN103@z900_cmpsc
  00b8d	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv568[rsp], 1
  00b95	eb 08		 jmp	 SHORT $LN104@z900_cmpsc
$LN103@z900_cmpsc:
  00b97	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv568[rsp], 0
$LN104@z900_cmpsc:
  00b9f	83 7c 24 74 00	 cmp	 DWORD PTR tv568[rsp], 0
  00ba4	75 4d		 jne	 SHORT $LN43@z900_cmpsc
  00ba6	48 8b 84 24 a0
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196928]
  00bae	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00bb4	48 89 84 24 a0
	02 03 00	 mov	 QWORD PTR expblk$[rsp+196928], rax
  00bbc	b8 08 00 00 00	 mov	 eax, 8
  00bc1	48 6b c0 01	 imul	 rax, rax, 1
  00bc5	b9 08 00 00 00	 mov	 ecx, 8
  00bca	48 6b c9 00	 imul	 rcx, rcx, 0
  00bce	48 8b 84 04 a8
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+rax+196936]
  00bd6	48 89 84 0c a8
	02 03 00	 mov	 QWORD PTR expblk$[rsp+rcx+196936], rax
  00bde	b8 08 00 00 00	 mov	 eax, 8
  00be3	48 6b c0 01	 imul	 rax, rax, 1
  00be7	48 c7 84 04 a8
	02 03 00 00 00
	00 00		 mov	 QWORD PTR expblk$[rsp+rax+196936], 0
$LN43@z900_cmpsc:
  00bf3	33 c0		 xor	 eax, eax
  00bf5	85 c0		 test	 eax, eax
  00bf7	0f 85 74 ff ff
	ff		 jne	 $LN28@z900_cmpsc

; 444  :     }

  00bfd	e9 29 fd ff ff	 jmp	 $LN21@z900_cmpsc
$LN22@z900_cmpsc:

; 445  : 
; 446  :     RETCC3( &expblk.op1blk );

  00c02	48 8d 94 24 98
	02 03 00	 lea	 rdx, QWORD PTR expblk$[rsp+196920]
  00c0a	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00c12	e8 00 00 00 00	 call	 z900_CC3
$LN1@z900_cmpsc:

; 447  : }

  00c17	48 8b 8c 24 10
	03 03 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00c1f	48 33 cc	 xor	 rcx, rsp
  00c22	e8 00 00 00 00	 call	 __security_check_cookie
  00c27	48 81 c4 28 03
	03 00		 add	 rsp, 197416		; 00030328H
  00c2e	5f		 pop	 rdi
  00c2f	5e		 pop	 rsi
  00c30	c3		 ret	 0
z900_cmpsc_Expand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch2
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
z900_vfetch2 PROC					; COMDAT

; 679  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 680  :     if (likely(!((VADR_L)addr & 0x01))
; 681  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) != PAGEFRAME_BYTEMASK ))

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00017	48 83 e0 01	 and	 rax, 1
  0001b	48 85 c0	 test	 rax, rax
  0001e	75 0a		 jne	 SHORT $LN5@z900_vfetc
  00020	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00028	eb 08		 jmp	 SHORT $LN6@z900_vfetc
$LN5@z900_vfetc:
  0002a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN6@z900_vfetc:
  00032	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00037	74 0a		 je	 SHORT $LN9@z900_vfetc
  00039	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00041	eb 08		 jmp	 SHORT $LN10@z900_vfetc
$LN9@z900_vfetc:
  00043	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN10@z900_vfetc:
  0004b	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00050	75 13		 jne	 SHORT $LN3@z900_vfetc
  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00057	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0005d	48 3d ff 0f 00
	00		 cmp	 rax, 4095		; 00000fffH
  00063	74 47		 je	 SHORT $LN2@z900_vfetc
$LN3@z900_vfetc:

; 682  :     {
; 683  :         BYTE *mn;
; 684  :         ITIMER_SYNC( addr, 2-1, regs );
; 685  :         mn = MADDRL( addr, 2,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00065	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0006e	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00072	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0007a	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0007f	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00084	ba 02 00 00 00	 mov	 edx, 2
  00089	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  0008e	e8 00 00 00 00	 call	 z900_maddr_l
  00093	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 686  :         return fetch_hw( mn );

  00098	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  0009d	e8 00 00 00 00	 call	 fetch_hw_noswap
  000a2	0f b7 c8	 movzx	 ecx, ax
  000a5	e8 00 00 00 00	 call	 _byteswap_ushort
  000aa	eb 13		 jmp	 SHORT $LN1@z900_vfetc
$LN2@z900_vfetc:

; 687  :     }
; 688  :     return ARCH_DEP( vfetch2_full )( addr, arn, regs );

  000ac	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  000b1	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  000b5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  000ba	e8 00 00 00 00	 call	 z900_vfetch2_full
$LN1@z900_vfetc:

; 689  : }

  000bf	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c3	c3		 ret	 0
z900_vfetch2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch2_full
_TEXT	SEGMENT
value$ = 48
mn$ = 56
addr$ = 80
arn$ = 88
regs$ = 96
z900_vfetch2_full PROC					; COMDAT

; 401  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 402  : BYTE   *mn;                             /* Main storage addresses    */
; 403  : U16     value;
; 404  : 
; 405  :     mn = MADDR( addr, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00012	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00017	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001b	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0001f	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00027	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0002c	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00031	ba 01 00 00 00	 mov	 edx, 1
  00036	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  0003b	e8 00 00 00 00	 call	 z900_maddr_l
  00040	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 406  :     value = *mn << 8;

  00045	48 8b 44 24 38	 mov	 rax, QWORD PTR mn$[rsp]
  0004a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0004d	c1 e0 08	 shl	 eax, 8
  00050	66 89 44 24 30	 mov	 WORD PTR value$[rsp], ax

; 407  :     mn = MADDR( (addr + 1) & ADDRESS_MAXWRAP( regs ), arn, regs,

  00055	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  0005a	48 ff c0	 inc	 rax
  0005d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00062	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00069	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0006e	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00072	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00076	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0007e	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  00083	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00088	ba 01 00 00 00	 mov	 edx, 1
  0008d	48 8b c8	 mov	 rcx, rax
  00090	e8 00 00 00 00	 call	 z900_maddr_l
  00095	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 408  :                  ACCTYPE_READ, regs->psw.pkey );
; 409  :     value |= *mn;

  0009a	48 8b 44 24 38	 mov	 rax, QWORD PTR mn$[rsp]
  0009f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000a2	0f b7 4c 24 30	 movzx	 ecx, WORD PTR value$[rsp]
  000a7	0b c8		 or	 ecx, eax
  000a9	8b c1		 mov	 eax, ecx
  000ab	66 89 44 24 30	 mov	 WORD PTR value$[rsp], ax

; 410  :     return value;

  000b0	0f b7 44 24 30	 movzx	 eax, WORD PTR value$[rsp]

; 411  : }

  000b5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b9	c3		 ret	 0
z900_vfetch2_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
z900_maddr_l PROC					; COMDAT

; 307  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00018	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001d	7c 0a		 jl	 SHORT $LN16@z900_maddr
  0001f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00027	eb 19		 jmp	 SHORT $LN17@z900_maddr
$LN16@z900_maddr:
  00029	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002d	83 c0 05	 add	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003e	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN17@z900_maddr:
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00046	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0004f	48 c1 e8 0c	 shr	 rax, 12
  00053	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  00059	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00067	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  0006c	0f 84 2d 01 00
	00		 je	 $LN2@z900_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 5a		 jne	 SHORT $LN4@z900_maddr
  00078	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	48 98		 cdqe
  00080	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00085	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	49 8b 8c c8 60
	b0 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+45152]
  00097	48 39 8c c2 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax*8+1536], rcx
  0009f	74 31		 je	 SHORT $LN4@z900_maddr
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	48 98		 cdqe
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b6	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000c0	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c8	23 c1		 and	 eax, ecx
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 cd 00 00
	00		 je	 $LN3@z900_maddr
$LN4@z900_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 2e		 jne	 SHORT $LN6@z900_maddr
  000d8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 22		 je	 SHORT $LN6@z900_maddr
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000ec	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f6	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000fe	3b c1		 cmp	 eax, ecx
  00100	0f 85 99 00 00
	00		 jne	 $LN5@z900_maddr
$LN6@z900_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0010b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0011c	48 0b c1	 or	 rax, rcx
  0011f	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00131	75 6c		 jne	 SHORT $LN7@z900_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00133	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  00145	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  0014c	23 c8		 and	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	85 c0		 test	 eax, eax
  00152	74 4b		 je	 SHORT $LN8@z900_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00154	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 1e		 je	 SHORT $LN9@z900_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00162	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00167	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  00179	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@z900_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00180	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 54 24 60	 mov	 rdx, QWORD PTR addr$[rsp]
  0018f	48 8b 84 c1 60
	10 01 00	 mov	 rax, QWORD PTR [rcx+rax*8+69728]
  00197	48 33 c2	 xor	 rax, rdx
  0019a	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@z900_maddr:
$LN7@z900_maddr:
$LN5@z900_maddr:
$LN3@z900_maddr:
$LN2@z900_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  001a5	75 36		 jne	 SHORT $LN10@z900_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001b9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001bd	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001c5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  001d3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001d8	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@z900_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 09	 imul	 rax, rax, 9
  001e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001f3	83 e0 40	 and	 eax, 64			; 00000040H
  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 89 00 00
	00		 je	 $LN11@z900_maddr

; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */

  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	75 26		 jne	 SHORT $LN13@z900_maddr
  00204	48 83 7c 24 78
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0020a	74 1e		 je	 SHORT $LN13@z900_maddr
  0020c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00211	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00218	85 c0		 test	 eax, eax
  0021a	74 0e		 je	 SHORT $LN13@z900_maddr
  0021c	83 7c 24 70 ff	 cmp	 DWORD PTR arn$[rsp], -1
  00221	74 07		 je	 SHORT $LN13@z900_maddr
  00223	83 7c 24 70 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00228	75 07		 jne	 SHORT $LN12@z900_maddr
$LN13@z900_maddr:

; 385  :         )
; 386  :             return maddr;

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  0022f	eb 5b		 jmp	 SHORT $LN1@z900_maddr
$LN12@z900_maddr:

; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	0f b6 80 4b 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3659]
  0023d	85 c0		 test	 eax, eax
  0023f	74 13		 je	 SHORT $LN14@z900_maddr

; 390  :         {
; 391  :             regs->txf_NTSTG = false;

  00241	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00246	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 392  :             return maddr;

  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00252	eb 38		 jmp	 SHORT $LN1@z900_maddr
$LN14@z900_maddr:

; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );

  00254	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00259	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00265	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00269	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0026e	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00273	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00278	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  0027d	e8 00 00 00 00	 call	 txf_maddr_l
  00282	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN11@z900_maddr:

; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
$LN1@z900_maddr:

; 401  : }

  0028c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00290	c3		 ret	 0
z900_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero
_TEXT	SEGMENT
tv75 = 32
regs$ = 64
z900_per3_zero PROC					; COMDAT

; 602  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 603  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 604  :     if (1
; 605  :         && EN_IC_PER_ZEROADDR( regs )
; 606  :         && !IS_PER_SUPRESS( regs, CR9_ZEROADDR )

  00009	33 c0		 xor	 eax, eax
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	0f 84 be 00 00
	00		 je	 $LN5@z900_per3_
  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00019	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0001f	c1 e8 02	 shr	 eax, 2
  00022	83 e0 01	 and	 eax, 1
  00025	85 c0		 test	 eax, eax
  00027	74 0a		 je	 SHORT $LN10@z900_per3_
  00029	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00031	eb 08		 jmp	 SHORT $LN11@z900_per3_
$LN10@z900_per3_:
  00033	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN11@z900_per3_:
  0003b	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00040	0f 84 8c 00 00
	00		 je	 $LN5@z900_per3_
  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0004e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00053	85 c0		 test	 eax, eax
  00055	74 7b		 je	 SHORT $LN5@z900_per3_
  00057	ba 00 00 00 04	 mov	 edx, 67108864		; 04000000H
  0005c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	e8 00 00 00 00	 call	 z900_is_per3_event_suppressed
  00066	0f b6 c0	 movzx	 eax, al
  00069	85 c0		 test	 eax, eax
  0006b	75 65		 jne	 SHORT $LN5@z900_per3_

; 607  :     )
; 608  :     {
; 609  :         regs->peradr = regs->periaddr;

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 8b 89 e8 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2280]
  0007e	48 89 88 d8 08
	00 00		 mov	 QWORD PTR [rax+2264], rcx
$LN4@z900_per3_:

; 610  :         ON_IC_PER_ZEROADDR( regs );

  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0008d	0f ba e8 12	 bts	 eax, 18
  00091	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00096	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00099	33 c0		 xor	 eax, eax
  0009b	85 c0		 test	 eax, eax
  0009d	75 e6		 jne	 SHORT $LN4@z900_per3_

; 611  :         if (OPEN_IC_PER_ZEROADDR( regs ))

  0009f	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  000ac	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000af	23 c1		 and	 eax, ecx
  000b1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b6	85 c0		 test	 eax, eax
  000b8	74 18		 je	 SHORT $LN6@z900_per3_

; 612  :             RETURN_INTCHECK( regs );

  000ba	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000bf	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000c5	ba ff ff ff ff	 mov	 edx, -1
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 longjmp
$LN6@z900_per3_:
$LN5@z900_per3_:
$LN7@z900_per3_:

; 613  :     }
; 614  : #else
; 615  :     UNREFERENCED( regs );
; 616  : #endif
; 617  : }

  000d2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d6	c3		 ret	 0
z900_per3_zero ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_is_per3_event_suppressed
_TEXT	SEGMENT
regs$ = 8
cr9_per_event$ = 16
z900_is_per3_event_suppressed PROC			; COMDAT

; 566  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 567  : #if !defined( FEATURE_PER3 )
; 568  :     UNREFERENCED( regs );
; 569  :     UNREFERENCED( cr9_per_event );
; 570  : #else
; 571  :     /* DON'T suppress this event if Event Suppression isn't enabled */
; 572  :     if (!(regs->CR_L(9) & CR9_SUPPRESS))

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 0a	 imul	 rax, rax, 10
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0001e	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00023	85 c0		 test	 eax, eax
  00025	75 04		 jne	 SHORT $LN2@z900_is_pe

; 573  :         return false;

  00027	32 c0		 xor	 al, al
  00029	eb 78		 jmp	 SHORT $LN1@z900_is_pe
$LN2@z900_is_pe:

; 574  : 
; 575  :     /* Is this PER event one that is ALLOWED to be suppressed? */
; 576  :     if (cr9_per_event & CR9_SUPPRESSABLE)

  0002b	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  0002f	25 00 00 00 ed	 and	 eax, -318767104		; ed000000H
  00034	85 c0		 test	 eax, eax
  00036	74 69		 je	 SHORT $LN3@z900_is_pe

; 577  :     {
; 578  :         /* Is there an active transaction? */
; 579  :         if (regs->txf_tnd)

  00038	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00044	85 c0		 test	 eax, eax
  00046	74 04		 je	 SHORT $LN4@z900_is_pe

; 580  :             return true;        /* Yes, then suppress it! */

  00048	b0 01		 mov	 al, 1
  0004a	eb 57		 jmp	 SHORT $LN1@z900_is_pe
$LN4@z900_is_pe:

; 581  : 
; 582  :         /* Suppress instruction-fetch events for TBEGIN/TBEGINC */
; 583  :         if (1
; 584  :             && cr9_per_event & CR9_IF
; 585  :             && *(regs->ip+0) == 0xE5
; 586  :             && (0

  0004c	33 c0		 xor	 eax, eax
  0004e	83 f8 01	 cmp	 eax, 1
  00051	74 4e		 je	 SHORT $LN5@z900_is_pe
  00053	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  00057	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0005c	85 c0		 test	 eax, eax
  0005e	74 41		 je	 SHORT $LN5@z900_is_pe
  00060	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006c	3d e5 00 00 00	 cmp	 eax, 229		; 000000e5H
  00071	75 2e		 jne	 SHORT $LN5@z900_is_pe
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 24		 jne	 SHORT $LN6@z900_is_pe
  00079	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00086	83 f8 60	 cmp	 eax, 96			; 00000060H
  00089	74 12		 je	 SHORT $LN6@z900_is_pe
  0008b	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00098	83 f8 61	 cmp	 eax, 97			; 00000061H
  0009b	75 04		 jne	 SHORT $LN5@z900_is_pe
$LN6@z900_is_pe:

; 587  :                 || *(regs->ip+1) == 0x60
; 588  :                 || *(regs->ip+1) == 0x61
; 589  :                )
; 590  :         )
; 591  :             return true;        /* TBEGIN/TBEGINC: suppress it! */

  0009d	b0 01		 mov	 al, 1
  0009f	eb 02		 jmp	 SHORT $LN1@z900_is_pe
$LN5@z900_is_pe:
$LN3@z900_is_pe:

; 592  :     }
; 593  : #endif
; 594  :     /* Otherwise DON'T suppress this PER event */
; 595  :     return false;

  000a1	32 c0		 xor	 al, al
$LN1@z900_is_pe:

; 596  : }

  000a3	c3		 ret	 0
z900_is_per3_event_suppressed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
r2$ = 32
r1$ = 36
i$1 = 40
tv184 = 44
tv198 = 48
tv207 = 52
tv212 = 56
rc$2 = 60
tv89 = 64
tv137 = 72
tv153 = 80
cmpsc$ = 96
inst$ = 192
regs$ = 200
z900_cmpsc_2012 PROC

; 1196 : {

$LN30:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 1197 :     CMPSCBLK cmpsc;                     /* Compression Call parameters block */
; 1198 :     int  r1, r2;                        /* Operand register numbers          */
; 1199 :     RRE( inst, regs, r1, r2 );          /* Decode the instruction...         */

  00011	b8 01 00 00 00	 mov	 eax, 1
  00016	48 6b c0 03	 imul	 rax, rax, 3
  0001a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00022	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00026	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
  0002a	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  0002e	83 e0 0f	 and	 eax, 15
  00031	89 44 24 20	 mov	 DWORD PTR r2$[rsp], eax
  00035	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00039	c1 f8 04	 sar	 eax, 4
  0003c	83 e0 0f	 and	 eax, 15
  0003f	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_cmpsc:
  00043	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004f	48 83 c0 04	 add	 rax, 4
  00053	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0005b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005f	33 c0		 xor	 eax, eax
  00061	83 f8 04	 cmp	 eax, 4
  00064	74 0f		 je	 SHORT $LN5@z900_cmpsc
  00066	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@z900_cmpsc:
  00075	33 c0		 xor	 eax, eax
  00077	85 c0		 test	 eax, eax
  00079	75 c8		 jne	 SHORT $LN4@z900_cmpsc

; 1200 : 
; 1201 : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 1202 :     if (0
; 1203 :         || GR_A( 1,  regs ) == 0
; 1204 :         || GR_A( r1, regs ) == 0
; 1205 :         || GR_A( r2, regs ) == 0

  0007b	33 c0		 xor	 eax, eax
  0007d	85 c0		 test	 eax, eax
  0007f	0f 85 02 01 00
	00		 jne	 $LN7@z900_cmpsc
  00085	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00093	83 e0 01	 and	 eax, 1
  00096	85 c0		 test	 eax, eax
  00098	74 20		 je	 SHORT $LN12@z900_cmpsc
  0009a	b8 08 00 00 00	 mov	 eax, 8
  0009f	48 6b c0 01	 imul	 rax, rax, 1
  000a3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  000b3	48 89 44 24 40	 mov	 QWORD PTR tv89[rsp], rax
  000b8	eb 1d		 jmp	 SHORT $LN13@z900_cmpsc
$LN12@z900_cmpsc:
  000ba	b8 08 00 00 00	 mov	 eax, 8
  000bf	48 6b c0 01	 imul	 rax, rax, 1
  000c3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000cb	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000d2	48 89 44 24 40	 mov	 QWORD PTR tv89[rsp], rax
$LN13@z900_cmpsc:
  000d7	48 83 7c 24 40
	00		 cmp	 QWORD PTR tv89[rsp], 0
  000dd	0f 84 a4 00 00
	00		 je	 $LN7@z900_cmpsc
  000e3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000f1	83 e0 01	 and	 eax, 1
  000f4	85 c0		 test	 eax, eax
  000f6	74 1c		 je	 SHORT $LN14@z900_cmpsc
  000f8	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  000fd	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00105	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0010d	48 89 44 24 48	 mov	 QWORD PTR tv137[rsp], rax
  00112	eb 19		 jmp	 SHORT $LN15@z900_cmpsc
$LN14@z900_cmpsc:
  00114	48 63 44 24 24	 movsxd	 rax, DWORD PTR r1$[rsp]
  00119	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00121	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00128	48 89 44 24 48	 mov	 QWORD PTR tv137[rsp], rax
$LN15@z900_cmpsc:
  0012d	48 83 7c 24 48
	00		 cmp	 QWORD PTR tv137[rsp], 0
  00133	74 52		 je	 SHORT $LN7@z900_cmpsc
  00135	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013d	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00143	83 e0 01	 and	 eax, 1
  00146	85 c0		 test	 eax, eax
  00148	74 1c		 je	 SHORT $LN16@z900_cmpsc
  0014a	48 63 44 24 20	 movsxd	 rax, DWORD PTR r2$[rsp]
  0014f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00157	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0015f	48 89 44 24 50	 mov	 QWORD PTR tv153[rsp], rax
  00164	eb 19		 jmp	 SHORT $LN17@z900_cmpsc
$LN16@z900_cmpsc:
  00166	48 63 44 24 20	 movsxd	 rax, DWORD PTR r2$[rsp]
  0016b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00173	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0017a	48 89 44 24 50	 mov	 QWORD PTR tv153[rsp], rax
$LN17@z900_cmpsc:
  0017f	48 83 7c 24 50
	00		 cmp	 QWORD PTR tv153[rsp], 0
  00185	75 0d		 jne	 SHORT $LN6@z900_cmpsc
$LN7@z900_cmpsc:

; 1206 :     )
; 1207 :         ARCH_DEP( per3_zero )( regs );

  00187	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018f	e8 00 00 00 00	 call	 z900_per3_zero
$LN6@z900_cmpsc:

; 1208 : #endif
; 1209 : 
; 1210 :     /* Build our internal Compression Call parameters block */
; 1211 : 
; 1212 :     ARCH_DEP( cmpsc_SetCMPSC )( &cmpsc, regs, r1, r2 );

  00194	44 8b 4c 24 20	 mov	 r9d, DWORD PTR r2$[rsp]
  00199	44 8b 44 24 24	 mov	 r8d, DWORD PTR r1$[rsp]
  0019e	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001a6	48 8d 4c 24 60	 lea	 rcx, QWORD PTR cmpsc$[rsp]
  001ab	e8 00 00 00 00	 call	 z900_cmpsc_SetCMPSC

; 1213 : 
; 1214 :     /* Verify that an even-odd register pair was specified
; 1215 :        and that the compressed-data symbol size is valid. */
; 1216 : 
; 1217 :     if (likely( 1

  001b0	33 c0		 xor	 eax, eax
  001b2	83 f8 01	 cmp	 eax, 1
  001b5	74 3a		 je	 SHORT $LN18@z900_cmpsc
  001b7	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  001bb	83 e0 01	 and	 eax, 1
  001be	85 c0		 test	 eax, eax
  001c0	75 2f		 jne	 SHORT $LN18@z900_cmpsc
  001c2	8b 44 24 20	 mov	 eax, DWORD PTR r2$[rsp]
  001c6	83 e0 01	 and	 eax, 1
  001c9	85 c0		 test	 eax, eax
  001cb	75 24		 jne	 SHORT $LN18@z900_cmpsc
  001cd	0f b6 84 24 a4
	00 00 00	 movzx	 eax, BYTE PTR cmpsc$[rsp+68]
  001d5	83 f8 01	 cmp	 eax, 1
  001d8	7c 17		 jl	 SHORT $LN18@z900_cmpsc
  001da	0f b6 84 24 a4
	00 00 00	 movzx	 eax, BYTE PTR cmpsc$[rsp+68]
  001e2	83 f8 05	 cmp	 eax, 5
  001e5	7f 0a		 jg	 SHORT $LN18@z900_cmpsc
  001e7	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv184[rsp], 1
  001ef	eb 08		 jmp	 SHORT $LN21@z900_cmpsc
$LN18@z900_cmpsc:
  001f1	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv184[rsp], 0
$LN21@z900_cmpsc:
  001f9	83 7c 24 2c 00	 cmp	 DWORD PTR tv184[rsp], 0
  001fe	0f 84 da 00 00
	00		 je	 $LN8@z900_cmpsc

; 1218 :         && !(r1 & 0x01)       /* (even register number?) */
; 1219 :         && !(r2 & 0x01)       /* (even register number?) */
; 1220 :         && cmpsc.cdss >= 1    /* (is symbol size valid?) */
; 1221 :         && cmpsc.cdss <= 5    /* (is symbol size valid?) */
; 1222 :     ))
; 1223 :     {
; 1224 :         /* Perform the Compression or Expansion */
; 1225 : 
; 1226 :         int rc = (regs->GR_L(0) & 0x100)

  00204	b8 08 00 00 00	 mov	 eax, 8
  00209	48 6b c0 00	 imul	 rax, rax, 0
  0020d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00215	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0021c	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00221	85 c0		 test	 eax, eax
  00223	74 13		 je	 SHORT $LN22@z900_cmpsc
  00225	48 8d 4c 24 60	 lea	 rcx, QWORD PTR cmpsc$[rsp]
  0022a	e8 00 00 00 00	 call	 z900_cmpsc_Expand
  0022f	0f b6 c0	 movzx	 eax, al
  00232	89 44 24 30	 mov	 DWORD PTR tv198[rsp], eax
  00236	eb 11		 jmp	 SHORT $LN23@z900_cmpsc
$LN22@z900_cmpsc:
  00238	48 8d 4c 24 60	 lea	 rcx, QWORD PTR cmpsc$[rsp]
  0023d	e8 00 00 00 00	 call	 z900_cmpsc_Compress
  00242	0f b6 c0	 movzx	 eax, al
  00245	89 44 24 30	 mov	 DWORD PTR tv198[rsp], eax
$LN23@z900_cmpsc:
  00249	8b 44 24 30	 mov	 eax, DWORD PTR tv198[rsp]
  0024d	89 44 24 3c	 mov	 DWORD PTR rc$2[rsp], eax

; 1227 :                ? ARCH_DEP( cmpsc_Expand   )( &cmpsc )
; 1228 :                : ARCH_DEP( cmpsc_Compress )( &cmpsc );
; 1229 : 
; 1230 :         /* Update register context with results */
; 1231 : 
; 1232 :         cmpsc.cbn &= 0x07;

  00251	0f b6 84 24 a5
	00 00 00	 movzx	 eax, BYTE PTR cmpsc$[rsp+69]
  00259	83 e0 07	 and	 eax, 7
  0025c	88 84 24 a5 00
	00 00		 mov	 BYTE PTR cmpsc$[rsp+69], al

; 1233 :         ARCH_DEP( cmpsc_SetREGS )( &cmpsc, regs, r1, r2 );

  00263	44 8b 4c 24 20	 mov	 r9d, DWORD PTR r2$[rsp]
  00268	44 8b 44 24 24	 mov	 r8d, DWORD PTR r1$[rsp]
  0026d	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00275	48 8d 4c 24 60	 lea	 rcx, QWORD PTR cmpsc$[rsp]
  0027a	e8 00 00 00 00	 call	 z900_cmpsc_SetREGS

; 1234 : 
; 1235 :         /* Program Check Interrupt if we failed */
; 1236 : 
; 1237 :         if (unlikely( !rc ))

  0027f	83 7c 24 3c 00	 cmp	 DWORD PTR rc$2[rsp], 0
  00284	75 0a		 jne	 SHORT $LN24@z900_cmpsc
  00286	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv207[rsp], 1
  0028e	eb 08		 jmp	 SHORT $LN25@z900_cmpsc
$LN24@z900_cmpsc:
  00290	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv207[rsp], 0
$LN25@z900_cmpsc:
  00298	83 7c 24 34 00	 cmp	 DWORD PTR tv207[rsp], 0
  0029d	74 0a		 je	 SHORT $LN28@z900_cmpsc
  0029f	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv212[rsp], 1
  002a7	eb 08		 jmp	 SHORT $LN29@z900_cmpsc
$LN28@z900_cmpsc:
  002a9	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv212[rsp], 0
$LN29@z900_cmpsc:
  002b1	83 7c 24 38 00	 cmp	 DWORD PTR tv212[rsp], 0
  002b6	74 24		 je	 SHORT $LN10@z900_cmpsc

; 1238 :         {
; 1239 :             regs->dxc = DXC_DECIMAL; /* Set Data Exception code */

  002b8	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c0	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 1240 :             ARCH_DEP( program_interrupt )( regs, PGM_DATA_EXCEPTION );

  002ca	ba 07 00 00 00	 mov	 edx, 7
  002cf	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d7	e8 00 00 00 00	 call	 z900_program_interrupt
$LN10@z900_cmpsc:

; 1241 :         }
; 1242 :     }

  002dc	eb 12		 jmp	 SHORT $LN9@z900_cmpsc
$LN8@z900_cmpsc:

; 1243 :     else
; 1244 :         ARCH_DEP( program_interrupt )( regs, PGM_SPECIFICATION_EXCEPTION );

  002de	ba 06 00 00 00	 mov	 edx, 6
  002e3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002eb	e8 00 00 00 00	 call	 z900_program_interrupt
$LN9@z900_cmpsc:

; 1245 : }

  002f0	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  002f7	c3		 ret	 0
z900_cmpsc_2012 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
dicts$ = 32
tv264 = 34
tv66 = 36
tv72 = 40
tv85 = 44
tv161 = 48
tv172 = 52
tv186 = 56
tv202 = 60
tv229 = 64
tv240 = 68
tv253 = 72
tv275 = 76
tv152 = 80
tv220 = 88
tv289 = 96
tv324 = 104
pCMPSCBLK$ = 128
pEXPBLK$ = 136
s390_cmpsc_Expand_Index PROC

; 453  : {

$LN53:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 454  :     U8  dicts;  // Counts dictionary entries processed
; 455  : 
; 456  :     if (unlikely( !pCMPSCBLK->nLen1 ))

  0000e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00016	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0001a	75 0a		 jne	 SHORT $LN19@s390_cmpsc
  0001c	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00024	eb 08		 jmp	 SHORT $LN20@s390_cmpsc
$LN19@s390_cmpsc:
  00026	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN20@s390_cmpsc:
  0002e	83 7c 24 24 00	 cmp	 DWORD PTR tv66[rsp], 0
  00033	74 0a		 je	 SHORT $LN23@s390_cmpsc
  00035	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0003d	eb 08		 jmp	 SHORT $LN24@s390_cmpsc
$LN23@s390_cmpsc:
  0003f	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN24@s390_cmpsc:
  00047	83 7c 24 28 00	 cmp	 DWORD PTR tv72[rsp], 0
  0004c	74 1a		 je	 SHORT $LN5@s390_cmpsc

; 457  :         EXP_RETCC1();

  0004e	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  00056	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0005e	e8 00 00 00 00	 call	 s390_EXPCC1
  00063	e9 8f 05 00 00	 jmp	 $LN1@s390_cmpsc
$LN5@s390_cmpsc:

; 458  : 
; 459  :     if (likely( pEXPBLK->index >= 256 ))

  00068	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00070	0f b7 80 9a 01
	03 00		 movzx	 eax, WORD PTR [rax+197018]
  00077	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0007c	7c 0a		 jl	 SHORT $LN27@s390_cmpsc
  0007e	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv85[rsp], 1
  00086	eb 08		 jmp	 SHORT $LN28@s390_cmpsc
$LN27@s390_cmpsc:
  00088	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv85[rsp], 0
$LN28@s390_cmpsc:
  00090	83 7c 24 2c 00	 cmp	 DWORD PTR tv85[rsp], 0
  00095	0f 84 03 05 00
	00		 je	 $LN6@s390_cmpsc

; 460  :     {
; 461  : #ifdef CMPSC_SYMCACHE
; 462  :         // Check our cache of previously expanded index symbols
; 463  :         // to see if we've already expanded this symbol before
; 464  :         // and if we have room in the o/p buffer to expand it.
; 465  : 
; 466  :         if (1
; 467  :             && (pEXPBLK->symlen  = pEXPBLK->symcctl[ pEXPBLK->index ].len) > 0
; 468  :             &&  pEXPBLK->symlen <= pCMPSCBLK->nLen1

  0009b	33 c0		 xor	 eax, eax
  0009d	83 f8 01	 cmp	 eax, 1
  000a0	0f 84 d2 00 00
	00		 je	 $LN8@s390_cmpsc
  000a6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  000ae	0f b7 80 9a 01
	03 00		 movzx	 eax, WORD PTR [rax+197018]
  000b5	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  000bd	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  000c5	0f b7 44 82 02	 movzx	 eax, WORD PTR [rdx+rax*4+2]
  000ca	66 89 81 98 01
	03 00		 mov	 WORD PTR [rcx+197016], ax
  000d1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  000d9	0f b7 80 98 01
	03 00		 movzx	 eax, WORD PTR [rax+197016]
  000e0	85 c0		 test	 eax, eax
  000e2	0f 8e 90 00 00
	00		 jle	 $LN8@s390_cmpsc
  000e8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  000f0	0f b7 80 98 01
	03 00		 movzx	 eax, WORD PTR [rax+197016]
  000f7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  000ff	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  00102	77 74		 ja	 SHORT $LN8@s390_cmpsc

; 469  :         )
; 470  :         {
; 471  :             store_op_str( &pEXPBLK->symcache[ pEXPBLK->symcctl[ pEXPBLK->index ].idx ], pEXPBLK->symlen-1, pCMPSCBLK->pOp1, &pEXPBLK->op1blk );

  00104	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  0010c	48 05 38 01 03
	00		 add	 rax, 196920		; 00030138H
  00112	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  0011a	0f b7 89 98 01
	03 00		 movzx	 ecx, WORD PTR [rcx+197016]
  00121	ff c9		 dec	 ecx
  00123	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  0012b	0f b7 92 9a 01
	03 00		 movzx	 edx, WORD PTR [rdx+197018]
  00132	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR pEXPBLK$[rsp]
  0013a	41 0f b7 14 90	 movzx	 edx, WORD PTR [r8+rdx*4]
  0013f	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR pEXPBLK$[rsp]
  00147	49 8d 94 10 00
	80 00 00	 lea	 rdx, QWORD PTR [r8+rdx+32768]
  0014f	48 89 54 24 50	 mov	 QWORD PTR tv152[rsp], rdx
  00154	4c 8b c8	 mov	 r9, rax
  00157	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0015f	44 8b 40 20	 mov	 r8d, DWORD PTR [rax+32]
  00163	0f b7 d1	 movzx	 edx, cx
  00166	48 8b 44 24 50	 mov	 rax, QWORD PTR tv152[rsp]
  0016b	48 8b c8	 mov	 rcx, rax
  0016e	e8 00 00 00 00	 call	 s390_cmpsc_vstorec

; 472  :         }

  00173	e9 24 04 00 00	 jmp	 $LN9@s390_cmpsc
$LN8@s390_cmpsc:

; 473  :         else
; 474  : #endif // CMPSC_SYMCACHE
; 475  :         {
; 476  :             // We need to expand this index symbol: fetch the ECE...
; 477  : 
; 478  :             if (unlikely( !ARCH_DEP( GetECE )( pEXPBLK->index, &pEXPBLK->eceblk )))

  00178	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00180	48 05 20 01 01
	00		 add	 rax, 65824		; 00010120H
  00186	48 8b d0	 mov	 rdx, rax
  00189	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00191	0f b7 88 9a 01
	03 00		 movzx	 ecx, WORD PTR [rax+197018]
  00198	e8 00 00 00 00	 call	 s390_GetECE
  0019d	0f b6 c0	 movzx	 eax, al
  001a0	85 c0		 test	 eax, eax
  001a2	75 0a		 jne	 SHORT $LN29@s390_cmpsc
  001a4	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv161[rsp], 1
  001ac	eb 08		 jmp	 SHORT $LN30@s390_cmpsc
$LN29@s390_cmpsc:
  001ae	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv161[rsp], 0
$LN30@s390_cmpsc:
  001b6	83 7c 24 30 00	 cmp	 DWORD PTR tv161[rsp], 0
  001bb	74 0a		 je	 SHORT $LN33@s390_cmpsc
  001bd	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv172[rsp], 1
  001c5	eb 08		 jmp	 SHORT $LN34@s390_cmpsc
$LN33@s390_cmpsc:
  001c7	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv172[rsp], 0
$LN34@s390_cmpsc:
  001cf	83 7c 24 34 00	 cmp	 DWORD PTR tv172[rsp], 0
  001d4	74 1a		 je	 SHORT $LN10@s390_cmpsc

; 479  :                 EXP_RETERR();

  001d6	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  001de	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  001e6	e8 00 00 00 00	 call	 s390_EXPERR
  001eb	e9 07 04 00 00	 jmp	 $LN1@s390_cmpsc
$LN10@s390_cmpsc:

; 480  : 
; 481  :             if (pEXPBLK->ece.psl)

  001f0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  001f8	0f b6 80 93 01
	03 00		 movzx	 eax, BYTE PTR [rax+197011]
  001ff	85 c0		 test	 eax, eax
  00201	0f 84 bc 01 00
	00		 je	 $LN11@s390_cmpsc

; 482  :             {
; 483  :                 // Preceded (i.e. partial symbol)...
; 484  :                 // Do we have room for the complete symbol?
; 485  : 
; 486  :                 if (unlikely( pCMPSCBLK->nLen1 < (pEXPBLK->symlen = pEXPBLK->ece.psl + pEXPBLK->ece.ofst)))

  00207	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  0020f	0f b6 80 93 01
	03 00		 movzx	 eax, BYTE PTR [rax+197011]
  00216	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  0021e	0f b6 89 94 01
	03 00		 movzx	 ecx, BYTE PTR [rcx+197012]
  00225	03 c1		 add	 eax, ecx
  00227	89 44 24 38	 mov	 DWORD PTR tv186[rsp], eax
  0022b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00233	0f b7 4c 24 38	 movzx	 ecx, WORD PTR tv186[rsp]
  00238	66 89 88 98 01
	03 00		 mov	 WORD PTR [rax+197016], cx
  0023f	0f b7 44 24 38	 movzx	 eax, WORD PTR tv186[rsp]
  00244	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0024c	48 39 01	 cmp	 QWORD PTR [rcx], rax
  0024f	73 0a		 jae	 SHORT $LN37@s390_cmpsc
  00251	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv202[rsp], 1
  00259	eb 08		 jmp	 SHORT $LN38@s390_cmpsc
$LN37@s390_cmpsc:
  0025b	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv202[rsp], 0
$LN38@s390_cmpsc:
  00263	83 7c 24 3c 00	 cmp	 DWORD PTR tv202[rsp], 0
  00268	74 1a		 je	 SHORT $LN13@s390_cmpsc

; 487  :                     EXP_RETCC1();

  0026a	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  00272	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0027a	e8 00 00 00 00	 call	 s390_EXPCC1
  0027f	e9 73 03 00 00	 jmp	 $LN1@s390_cmpsc
$LN13@s390_cmpsc:

; 488  : 
; 489  :                 dicts = 1;

  00284	c6 44 24 20 01	 mov	 BYTE PTR dicts$[rsp], 1
$LN4@s390_cmpsc:

; 490  : 
; 491  :                 do
; 492  :                 {
; 493  :                     // Expand this partial ("preceded") chunk of this index symbol...
; 494  : 
; 495  :                     store_op_str( pEXPBLK->ece.ec, pEXPBLK->ece.psl-1, pCMPSCBLK->pOp1 + pEXPBLK->ece.ofst, &pEXPBLK->op1blk );

  00289	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00291	48 05 38 01 03
	00		 add	 rax, 196920		; 00030138H
  00297	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  0029f	0f b6 89 94 01
	03 00		 movzx	 ecx, BYTE PTR [rcx+197012]
  002a6	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pCMPSCBLK$[rsp]
  002ae	48 03 4a 20	 add	 rcx, QWORD PTR [rdx+32]
  002b2	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  002ba	0f b6 92 93 01
	03 00		 movzx	 edx, BYTE PTR [rdx+197011]
  002c1	ff ca		 dec	 edx
  002c3	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR pEXPBLK$[rsp]
  002cb	49 81 c0 88 01
	03 00		 add	 r8, 197000		; 00030188H
  002d2	4c 89 44 24 58	 mov	 QWORD PTR tv220[rsp], r8
  002d7	4c 8b c8	 mov	 r9, rax
  002da	44 8b c1	 mov	 r8d, ecx
  002dd	48 8b 44 24 58	 mov	 rax, QWORD PTR tv220[rsp]
  002e2	48 8b c8	 mov	 rcx, rax
  002e5	e8 00 00 00 00	 call	 s390_cmpsc_vstorec

; 496  : 
; 497  :                     // Get the ECE for the next chunk...
; 498  : 
; 499  :                     if (unlikely( !ARCH_DEP( GetECE )( pEXPBLK->ece.pptr, &pEXPBLK->eceblk )))

  002ea	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  002f2	48 05 20 01 01
	00		 add	 rax, 65824		; 00010120H
  002f8	48 8b d0	 mov	 rdx, rax
  002fb	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00303	0f b7 88 90 01
	03 00		 movzx	 ecx, WORD PTR [rax+197008]
  0030a	e8 00 00 00 00	 call	 s390_GetECE
  0030f	0f b6 c0	 movzx	 eax, al
  00312	85 c0		 test	 eax, eax
  00314	75 0a		 jne	 SHORT $LN39@s390_cmpsc
  00316	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv229[rsp], 1
  0031e	eb 08		 jmp	 SHORT $LN40@s390_cmpsc
$LN39@s390_cmpsc:
  00320	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv229[rsp], 0
$LN40@s390_cmpsc:
  00328	83 7c 24 40 00	 cmp	 DWORD PTR tv229[rsp], 0
  0032d	74 0a		 je	 SHORT $LN43@s390_cmpsc
  0032f	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv240[rsp], 1
  00337	eb 08		 jmp	 SHORT $LN44@s390_cmpsc
$LN43@s390_cmpsc:
  00339	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv240[rsp], 0
$LN44@s390_cmpsc:
  00341	83 7c 24 44 00	 cmp	 DWORD PTR tv240[rsp], 0
  00346	74 1a		 je	 SHORT $LN14@s390_cmpsc

; 500  :                         EXP_RETERR();

  00348	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  00350	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00358	e8 00 00 00 00	 call	 s390_EXPERR
  0035d	e9 95 02 00 00	 jmp	 $LN1@s390_cmpsc
$LN14@s390_cmpsc:

; 501  : 
; 502  :                     if (unlikely( ++dicts > 127 ))

  00362	0f b6 44 24 20	 movzx	 eax, BYTE PTR dicts$[rsp]
  00367	fe c0		 inc	 al
  00369	88 44 24 20	 mov	 BYTE PTR dicts$[rsp], al
  0036d	0f b6 44 24 20	 movzx	 eax, BYTE PTR dicts$[rsp]
  00372	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00375	7e 0a		 jle	 SHORT $LN47@s390_cmpsc
  00377	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv253[rsp], 1
  0037f	eb 08		 jmp	 SHORT $LN48@s390_cmpsc
$LN47@s390_cmpsc:
  00381	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv253[rsp], 0
$LN48@s390_cmpsc:
  00389	83 7c 24 48 00	 cmp	 DWORD PTR tv253[rsp], 0
  0038e	74 1a		 je	 SHORT $LN15@s390_cmpsc

; 503  :                         EXP_RETERR();

  00390	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  00398	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  003a0	e8 00 00 00 00	 call	 s390_EXPERR
  003a5	e9 4d 02 00 00	 jmp	 $LN1@s390_cmpsc
$LN15@s390_cmpsc:

; 504  :                 }
; 505  :                 while (pEXPBLK->ece.psl);

  003aa	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  003b2	0f b6 80 93 01
	03 00		 movzx	 eax, BYTE PTR [rax+197011]
  003b9	85 c0		 test	 eax, eax
  003bb	0f 85 c8 fe ff
	ff		 jne	 $LN4@s390_cmpsc

; 506  : 
; 507  :                 // we're done with the partial ("preceded") part of this
; 508  :                 // symbol's expansion. Fall through to the "complete" symbol
; 509  :                 // expansion logic to finish up this symbol's expansion...
; 510  :             }

  003c1	eb 6d		 jmp	 SHORT $LN12@s390_cmpsc
$LN11@s390_cmpsc:

; 511  :             else
; 512  :             {
; 513  :                 // Unpreceded (i.e. complete symbol)...
; 514  :                 // Do we have room for the complete symbol?
; 515  : 
; 516  :                 if (unlikely( pCMPSCBLK->nLen1 < (pEXPBLK->symlen = pEXPBLK->ece.csl)))

  003c3	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  003cb	0f b6 80 92 01
	03 00		 movzx	 eax, BYTE PTR [rax+197010]
  003d2	66 89 44 24 22	 mov	 WORD PTR tv264[rsp], ax
  003d7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  003df	0f b7 4c 24 22	 movzx	 ecx, WORD PTR tv264[rsp]
  003e4	66 89 88 98 01
	03 00		 mov	 WORD PTR [rax+197016], cx
  003eb	0f b7 44 24 22	 movzx	 eax, WORD PTR tv264[rsp]
  003f0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  003f8	48 39 01	 cmp	 QWORD PTR [rcx], rax
  003fb	73 0a		 jae	 SHORT $LN51@s390_cmpsc
  003fd	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv275[rsp], 1
  00405	eb 08		 jmp	 SHORT $LN52@s390_cmpsc
$LN51@s390_cmpsc:
  00407	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv275[rsp], 0
$LN52@s390_cmpsc:
  0040f	83 7c 24 4c 00	 cmp	 DWORD PTR tv275[rsp], 0
  00414	74 1a		 je	 SHORT $LN16@s390_cmpsc

; 517  :                     EXP_RETCC1();

  00416	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  0041e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00426	e8 00 00 00 00	 call	 s390_EXPCC1
  0042b	e9 c7 01 00 00	 jmp	 $LN1@s390_cmpsc
$LN16@s390_cmpsc:
$LN12@s390_cmpsc:

; 518  :             }
; 519  : 
; 520  :             // Complete the expansion of this index symbol...
; 521  : 
; 522  :             store_op_str( pEXPBLK->ece.ec, pEXPBLK->ece.csl-1, pCMPSCBLK->pOp1, &pEXPBLK->op1blk );

  00430	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00438	48 05 38 01 03
	00		 add	 rax, 196920		; 00030138H
  0043e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  00446	0f b6 89 92 01
	03 00		 movzx	 ecx, BYTE PTR [rcx+197010]
  0044d	ff c9		 dec	 ecx
  0044f	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  00457	48 81 c2 88 01
	03 00		 add	 rdx, 197000		; 00030188H
  0045e	48 89 54 24 60	 mov	 QWORD PTR tv289[rsp], rdx
  00463	4c 8b c8	 mov	 r9, rax
  00466	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0046e	44 8b 40 20	 mov	 r8d, DWORD PTR [rax+32]
  00472	0f b7 d1	 movzx	 edx, cx
  00475	48 8b 44 24 60	 mov	 rax, QWORD PTR tv289[rsp]
  0047a	48 8b c8	 mov	 rcx, rax
  0047d	e8 00 00 00 00	 call	 s390_cmpsc_vstorec

; 523  : 
; 524  : #ifdef CMPSC_SYMCACHE
; 525  :             // If there's room for it, add this symbol to our expanded symbols cache
; 526  : 
; 527  :             if (pEXPBLK->symlen <= (sizeof( pEXPBLK->symcache ) - pEXPBLK->symindex))

  00482	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  0048a	0f b7 80 98 01
	03 00		 movzx	 eax, WORD PTR [rax+197016]
  00491	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  00499	0f b7 89 00 00
	01 00		 movzx	 ecx, WORD PTR [rcx+65536]
  004a0	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  004a5	48 2b d1	 sub	 rdx, rcx
  004a8	48 8b ca	 mov	 rcx, rdx
  004ab	48 3b c1	 cmp	 rax, rcx
  004ae	0f 87 e8 00 00
	00		 ja	 $LN17@s390_cmpsc

; 528  :             {
; 529  :                 pEXPBLK->symcctl[ pEXPBLK->index ].len = pEXPBLK->symlen;

  004b4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  004bc	0f b7 80 9a 01
	03 00		 movzx	 eax, WORD PTR [rax+197018]
  004c3	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  004cb	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  004d3	0f b7 92 98 01
	03 00		 movzx	 edx, WORD PTR [rdx+197016]
  004da	66 89 54 81 02	 mov	 WORD PTR [rcx+rax*4+2], dx

; 530  :                 pEXPBLK->symcctl[ pEXPBLK->index ].idx = pEXPBLK->symindex;

  004df	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  004e7	0f b7 80 9a 01
	03 00		 movzx	 eax, WORD PTR [rax+197018]
  004ee	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  004f6	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  004fe	0f b7 92 00 00
	01 00		 movzx	 edx, WORD PTR [rdx+65536]
  00505	66 89 14 81	 mov	 WORD PTR [rcx+rax*4], dx

; 531  : 
; 532  :                 // (add this symbol to our previously expanded symbols cache)
; 533  : 
; 534  :                 fetch_op_str( &pEXPBLK->symcache[ pEXPBLK->symindex ], pEXPBLK->symlen-1, pCMPSCBLK->pOp1, &pEXPBLK->op1blk );

  00509	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00511	48 05 38 01 03
	00		 add	 rax, 196920		; 00030138H
  00517	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  0051f	0f b7 89 98 01
	03 00		 movzx	 ecx, WORD PTR [rcx+197016]
  00526	ff c9		 dec	 ecx
  00528	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  00530	0f b7 92 00 00
	01 00		 movzx	 edx, WORD PTR [rdx+65536]
  00537	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR pEXPBLK$[rsp]
  0053f	49 8d 94 10 00
	80 00 00	 lea	 rdx, QWORD PTR [r8+rdx+32768]
  00547	48 89 54 24 68	 mov	 QWORD PTR tv324[rsp], rdx
  0054c	4c 8b c8	 mov	 r9, rax
  0054f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00557	44 8b 40 20	 mov	 r8d, DWORD PTR [rax+32]
  0055b	0f b7 d1	 movzx	 edx, cx
  0055e	48 8b 44 24 68	 mov	 rax, QWORD PTR tv324[rsp]
  00563	48 8b c8	 mov	 rcx, rax
  00566	e8 00 00 00 00	 call	 s390_cmpsc_vfetchc

; 535  : 
; 536  :                 pEXPBLK->symindex += pEXPBLK->symlen;

  0056b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00573	0f b7 80 98 01
	03 00		 movzx	 eax, WORD PTR [rax+197016]
  0057a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  00582	0f b7 89 00 00
	01 00		 movzx	 ecx, WORD PTR [rcx+65536]
  00589	03 c8		 add	 ecx, eax
  0058b	8b c1		 mov	 eax, ecx
  0058d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  00595	66 89 81 00 00
	01 00		 mov	 WORD PTR [rcx+65536], ax
$LN17@s390_cmpsc:
$LN9@s390_cmpsc:

; 537  :             }
; 538  : #endif // CMPSC_SYMCACHE
; 539  :         }
; 540  :     }

  0059c	eb 44		 jmp	 SHORT $LN7@s390_cmpsc
$LN6@s390_cmpsc:

; 541  :     else // (pEXPBLK->index < 256)
; 542  :     {
; 543  :         // The index symbol is an alphabet entry (i.e. an index symbol
; 544  :         // corresponding to a one-byte symbol). The expanded symbol it
; 545  :         // represents is the value of the alphabet index symbol itself.
; 546  : 
; 547  :         store_op_b( (U8)pEXPBLK->index, pCMPSCBLK->pOp1, &pEXPBLK->op1blk );

  0059e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  005a6	48 05 38 01 03
	00		 add	 rax, 196920		; 00030138H
  005ac	4c 8b c0	 mov	 r8, rax
  005af	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  005b7	8b 50 20	 mov	 edx, DWORD PTR [rax+32]
  005ba	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  005c2	0f b6 88 9a 01
	03 00		 movzx	 ecx, BYTE PTR [rax+197018]
  005c9	e8 00 00 00 00	 call	 s390_cmpsc_vstoreb

; 548  :         pEXPBLK->symlen = 1;

  005ce	b8 01 00 00 00	 mov	 eax, 1
  005d3	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  005db	66 89 81 98 01
	03 00		 mov	 WORD PTR [rcx+197016], ax
$LN7@s390_cmpsc:

; 549  :     }
; 550  : 
; 551  :     EXP_RETOK();

  005e2	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  005ea	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  005f2	e8 00 00 00 00	 call	 s390_EXPOK
$LN1@s390_cmpsc:

; 552  : }

  005f7	48 83 c4 78	 add	 rsp, 120		; 00000078H
  005fb	c3		 ret	 0
s390_cmpsc_Expand_Index ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
pCMPSCBLK$ = 48
pEXPBLK$ = 56
s390_EXPCC1 PROC

; 212  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 213  :     pEXPBLK->rc = ARCH_DEP( CC1 )( pCMPSCBLK, &pEXPBLK->op1blk ); return FALSE; // (break)

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00013	48 05 38 01 03
	00		 add	 rax, 196920		; 00030138H
  00019	48 8b d0	 mov	 rdx, rax
  0001c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00021	e8 00 00 00 00	 call	 s390_CC1
  00026	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  0002b	88 81 9d 01 03
	00		 mov	 BYTE PTR [rcx+197021], al
  00031	32 c0		 xor	 al, al

; 214  : }

  00033	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00037	c3		 ret	 0
s390_EXPCC1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
pCMPSCBLK$ = 48
pEXPBLK$ = 56
s390_EXPERR PROC

; 204  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 205  :     pEXPBLK->rc = ARCH_DEP( ERR )( pCMPSCBLK, &pEXPBLK->op1blk ); return FALSE; // (break)

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00013	48 05 38 01 03
	00		 add	 rax, 196920		; 00030138H
  00019	48 8b d0	 mov	 rdx, rax
  0001c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00021	e8 00 00 00 00	 call	 s390_ERR
  00026	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  0002b	88 81 9d 01 03
	00		 mov	 BYTE PTR [rcx+197021], al
  00031	32 c0		 xor	 al, al

; 206  : }

  00033	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00037	c3		 ret	 0
s390_EXPERR ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
pCMPSCBLK$ = 8
pEXPBLK$ = 16
s390_EXPOK PROC

; 198  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s390_EXPOK:

; 199  :     UNREFERENCED( pCMPSCBLK );

  0000a	33 c0		 xor	 eax, eax
  0000c	85 c0		 test	 eax, eax
  0000e	75 fa		 jne	 SHORT $LN4@s390_EXPOK
$LN7@s390_EXPOK:

; 200  :     UNREFERENCED( pEXPBLK   );

  00010	33 c0		 xor	 eax, eax
  00012	85 c0		 test	 eax, eax
  00014	75 fa		 jne	 SHORT $LN7@s390_EXPOK

; 201  :     return TRUE; // (success; keep going)

  00016	b0 01		 mov	 al, 1

; 202  : }

  00018	c3		 ret	 0
s390_EXPOK ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
pCMPSCBLK$ = 8
pOp1MemBlk$ = 16
s390_CC0 PROC

; 189  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s390_CC0:

; 190  :     ZERO_PAD_OP1( pCMPSCBLK, pOp1MemBlk );

  0000a	33 c0		 xor	 eax, eax
  0000c	85 c0		 test	 eax, eax
  0000e	75 fa		 jne	 SHORT $LN4@s390_CC0

; 191  :     pCMPSCBLK->pic = 0;

  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00017	66 89 41 3e	 mov	 WORD PTR [rcx+62], ax

; 192  :     pCMPSCBLK->cc = 0;

  0001b	48 8b 44 24 08	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00020	c6 40 46 00	 mov	 BYTE PTR [rax+70], 0

; 193  :     return TRUE;

  00024	b0 01		 mov	 al, 1

; 194  : }

  00026	c3		 ret	 0
s390_CC0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
pCMPSCBLK$ = 8
pOp1MemBlk$ = 16
s390_CC1 PROC

; 182  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s390_CC1:

; 183  :     ZERO_PAD_OP1( pCMPSCBLK, pOp1MemBlk );

  0000a	33 c0		 xor	 eax, eax
  0000c	85 c0		 test	 eax, eax
  0000e	75 fa		 jne	 SHORT $LN4@s390_CC1

; 184  :     pCMPSCBLK->pic = 0;

  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00017	66 89 41 3e	 mov	 WORD PTR [rcx+62], ax

; 185  :     pCMPSCBLK->cc = 1;

  0001b	48 8b 44 24 08	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00020	c6 40 46 01	 mov	 BYTE PTR [rax+70], 1

; 186  :     return TRUE;

  00024	b0 01		 mov	 al, 1

; 187  : }

  00026	c3		 ret	 0
s390_CC1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
pCMPSCBLK$ = 8
pOp1MemBlk$ = 16
s390_CC3 PROC

; 175  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s390_CC3:

; 176  :     ZERO_PAD_OP1( pCMPSCBLK, pOp1MemBlk );

  0000a	33 c0		 xor	 eax, eax
  0000c	85 c0		 test	 eax, eax
  0000e	75 fa		 jne	 SHORT $LN4@s390_CC3

; 177  :     pCMPSCBLK->pic = 0;

  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00017	66 89 41 3e	 mov	 WORD PTR [rcx+62], ax

; 178  :     pCMPSCBLK->cc = 3;

  0001b	48 8b 44 24 08	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00020	c6 40 46 03	 mov	 BYTE PTR [rax+70], 3

; 179  :     return TRUE;

  00024	b0 01		 mov	 al, 1

; 180  : }

  00026	c3		 ret	 0
s390_CC3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
pCMPSCBLK$ = 8
pOp1MemBlk$ = 16
s390_ERR PROC

; 169  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s390_ERR:

; 170  :     UNREFERENCED( pOp1MemBlk );

  0000a	33 c0		 xor	 eax, eax
  0000c	85 c0		 test	 eax, eax
  0000e	75 fa		 jne	 SHORT $LN4@s390_ERR

; 171  :     pCMPSCBLK->pic = 7;

  00010	b8 07 00 00 00	 mov	 eax, 7
  00015	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0001a	66 89 41 3e	 mov	 WORD PTR [rcx+62], ax

; 172  :     return FALSE;

  0001e	32 c0		 xor	 al, al

; 173  : }

  00020	c3		 ret	 0
s390_ERR ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
scnum$ = 32
ccnum$ = 33
byt$ = 34
eodst$ = 35
parent_index$ = 36
child_index$ = 40
children$ = 44
bits$ = 48
flag$ = 49
sibling_index$ = 52
pPutIndex$ = 56
pPutGetCBN$ = 64
nCPUAmt$ = 72
pBegOp2$ = 80
max_index$ = 88
tv287 = 92
tv303 = 96
tv321 = 100
tv330 = 104
tv355 = 108
tv373 = 112
tv387 = 116
tv393 = 120
tv460 = 124
tv469 = 128
tv563 = 132
tv572 = 136
tv588 = 140
tv600 = 144
tv619 = 148
tv631 = 152
tv643 = 156
tv662 = 160
tv674 = 164
tv696 = 168
tv705 = 172
tv727 = 176
tv795 = 180
tv818 = 184
tv827 = 188
tv870 = 192
tv882 = 196
tv901 = 200
tv927 = 204
tv939 = 208
tv958 = 212
tv259 = 216
tv263 = 220
tv267 = 224
tv273 = 228
op1blk$ = 232
pSymTab$ = 272
tv1117 = 280
op2blk$ = 288
tv129 = 328
tv133 = 336
pGetSD$ = 344
piblk$ = 352
ppPutIndex$ = 384
dctblk$ = 400
dctblk2$ = 688
cceblk$ = 976
sdeblk$ = 263152
sibling$ = 459792
parent$ = 459816
child$ = 459848
wrk$ = 459888
__$ArrayPad$ = 460160
pCMPSCBLK$ = 460208
s390_cmpsc_Compress PROC

; 558  : {

$LN177:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	b8 98 05 07 00	 mov	 eax, 460184		; 00070598H
  0000c	e8 00 00 00 00	 call	 __chkstk
  00011	48 2b e0	 sub	 rsp, rax
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 80
	05 07 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 559  :     U64         nCPUAmt;            // CPU determined processing limit
; 560  :     U64         pBegOp2;            // Ptr to beginning of operand-2
; 561  :     PutGetCBN*  pPutGetCBN;         // Ptr to PutGetCBN function for this CDSS-1
; 562  :     PutIndex**  ppPutIndex;         // Ptr to PutNextIndex table for this CDSS-1
; 563  :     PutIndex*   pPutIndex;          // Ptr to PutNextIndex function for this CBN
; 564  :     U64         pSymTab;            // Symbol-Translation Table
; 565  :     GETSD*      pGetSD;             // Pointer to Get-Sibling-Descriptor function
; 566  :     CCE         parent;             // Parent Compression Character Entry data
; 567  :     CCE         child;              // Child  Compression Character Entry data
; 568  :     SDE         sibling;            // Sibling Descriptor Entry data
; 569  :     MEMBLK      op1blk;             // Operand-1 memory access control block
; 570  :     MEMBLK      op2blk;             // Operand-2 memory access control block
; 571  :     DCTBLK      dctblk;             // GetDCT parameters block  (cmp dict)
; 572  :     DCTBLK      dctblk2;            // GetDCT parameters block  (exp dict)
; 573  :     CCEBLK      cceblk;             // GetCCE parameters block
; 574  :     SDEBLK      sdeblk;             // GetSDn parameters block
; 575  :     PIBLK       piblk;              // PutIndex parameters block
; 576  :     U16         parent_index;       // Parent's CE Index value
; 577  :     U16         child_index;        // Child's CE Index value
; 578  :     U16         sibling_index;      // Sibling's SDE Index value
; 579  :     U16         max_index;          // Maximum Index value
; 580  :     U16         children;           // Counts children
; 581  :     U8          ccnum, scnum, byt;  // (work variables)
; 582  :     U8          eodst, flag;        // (work flags)
; 583  :     U8          bits;               // Number of bits per index
; 584  :     U8          wrk[ MAX_SYMLEN ];  // (work buffer)
; 585  : 
; 586  :     bits       = 8 + pCMPSCBLK->cdss;

  00026	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0002e	0f b6 40 44	 movzx	 eax, BYTE PTR [rax+68]
  00032	83 c0 08	 add	 eax, 8
  00035	88 44 24 30	 mov	 BYTE PTR bits$[rsp], al

; 587  :     max_index  = (0xFFFF >> (16 - bits));

  00039	0f b6 44 24 30	 movzx	 eax, BYTE PTR bits$[rsp]
  0003e	b9 10 00 00 00	 mov	 ecx, 16
  00043	2b c8		 sub	 ecx, eax
  00045	8b c1		 mov	 eax, ecx
  00047	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0004c	89 8c 24 18 01
	00 00		 mov	 DWORD PTR tv1117[rsp], ecx
  00053	0f b6 c8	 movzx	 ecx, al
  00056	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR tv1117[rsp]
  0005d	d3 f8		 sar	 eax, cl
  0005f	66 89 44 24 58	 mov	 WORD PTR max_index$[rsp], ax

; 588  :     pPutGetCBN = ARCH_DEP( PutGetCBNTab    )[ pCMPSCBLK->cdss - 1 ];

  00064	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0006c	0f b6 40 44	 movzx	 eax, BYTE PTR [rax+68]
  00070	ff c8		 dec	 eax
  00072	48 98		 cdqe
  00074	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:s390_PutGetCBNTab
  0007b	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0007f	48 89 44 24 40	 mov	 QWORD PTR pPutGetCBN$[rsp], rax

; 589  :     ppPutIndex = ARCH_DEP( PutIndexCDSSTab )[ pCMPSCBLK->cdss - 1 ];

  00084	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0008c	0f b6 40 44	 movzx	 eax, BYTE PTR [rax+68]
  00090	ff c8		 dec	 eax
  00092	48 98		 cdqe
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:s390_PutIndexCDSSTab
  0009b	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0009f	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR ppPutIndex$[rsp], rax

; 590  :     pPutIndex  = ppPutIndex[ pCMPSCBLK->cbn ];

  000a7	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  000af	0f b6 40 45	 movzx	 eax, BYTE PTR [rax+69]
  000b3	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR ppPutIndex$[rsp]
  000bb	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  000bf	48 89 44 24 38	 mov	 QWORD PTR pPutIndex$[rsp], rax

; 591  :     pSymTab    = pCMPSCBLK->st ? pCMPSCBLK->pDict + ((U32)pCMPSCBLK->stt << 7) : 0;

  000c4	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  000cc	0f b6 40 42	 movzx	 eax, BYTE PTR [rax+66]
  000d0	85 c0		 test	 eax, eax
  000d2	74 27		 je	 SHORT $LN63@s390_cmpsc
  000d4	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  000dc	0f b7 40 3c	 movzx	 eax, WORD PTR [rax+60]
  000e0	c1 e0 07	 shl	 eax, 7
  000e3	8b c0		 mov	 eax, eax
  000e5	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  000ed	48 03 41 30	 add	 rax, QWORD PTR [rcx+48]
  000f1	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv129[rsp], rax
  000f9	eb 0c		 jmp	 SHORT $LN64@s390_cmpsc
$LN63@s390_cmpsc:
  000fb	48 c7 84 24 48
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv129[rsp], 0
$LN64@s390_cmpsc:
  00107	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR tv129[rsp]
  0010f	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR pSymTab$[rsp], rax

; 592  :     pGetSD     = pCMPSCBLK->f1 ? ARCH_DEP( GetSD1 ) : ARCH_DEP( GetSD0 );

  00117	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0011f	0f b6 40 43	 movzx	 eax, BYTE PTR [rax+67]
  00123	85 c0		 test	 eax, eax
  00125	74 11		 je	 SHORT $LN65@s390_cmpsc
  00127	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:s390_GetSD1
  0012e	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv133[rsp], rax
  00136	eb 0f		 jmp	 SHORT $LN66@s390_cmpsc
$LN65@s390_cmpsc:
  00138	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:s390_GetSD0
  0013f	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv133[rsp], rax
$LN66@s390_cmpsc:
  00147	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR tv133[rsp]
  0014f	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR pGetSD$[rsp], rax

; 593  : 
; 594  : #define PUTSETCBN()     pCMPSCBLK->cbn = pPutGetCBN( pPutIndex )
; 595  : 
; 596  :     memset( &dctblk,  0, sizeof( dctblk ) );

  00157	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR dctblk$[rsp]
  0015f	48 8b f8	 mov	 rdi, rax
  00162	33 c0		 xor	 eax, eax
  00164	b9 18 01 00 00	 mov	 ecx, 280		; 00000118H
  00169	f3 aa		 rep stosb

; 597  :     memset( &dctblk2, 0, sizeof( dctblk ) );

  0016b	48 8d 84 24 b0
	02 00 00	 lea	 rax, QWORD PTR dctblk2$[rsp]
  00173	48 8b f8	 mov	 rdi, rax
  00176	33 c0		 xor	 eax, eax
  00178	b9 18 01 00 00	 mov	 ecx, 280		; 00000118H
  0017d	f3 aa		 rep stosb

; 598  : 
; 599  :     dctblk.regs       = pCMPSCBLK->regs;

  0017f	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00187	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0018b	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR dctblk$[rsp], rax

; 600  :     dctblk.arn        = pCMPSCBLK->r2;

  00193	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0019b	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  0019f	89 84 24 a0 02
	00 00		 mov	 DWORD PTR dctblk$[rsp+272], eax

; 601  :     dctblk.pkey       = pCMPSCBLK->regs->psw.pkey;

  001a6	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  001ae	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001b2	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  001b6	88 84 24 a4 02
	00 00		 mov	 BYTE PTR dctblk$[rsp+276], al

; 602  :     dctblk.pDict      = pCMPSCBLK->pDict;

  001bd	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  001c5	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  001c9	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR dctblk$[rsp+8], rax

; 603  : 
; 604  :     dctblk2.regs      = pCMPSCBLK->regs;

  001d1	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  001d9	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001dd	48 89 84 24 b0
	02 00 00	 mov	 QWORD PTR dctblk2$[rsp], rax

; 605  :     dctblk2.arn       = pCMPSCBLK->r2;

  001e5	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  001ed	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  001f1	89 84 24 c0 03
	00 00		 mov	 DWORD PTR dctblk2$[rsp+272], eax

; 606  :     dctblk2.pkey      = pCMPSCBLK->regs->psw.pkey;

  001f8	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00200	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00204	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00208	88 84 24 c4 03
	00 00		 mov	 BYTE PTR dctblk2$[rsp+276], al

; 607  :     dctblk2.pDict     = pCMPSCBLK->pDict + g_nDictSize[ pCMPSCBLK->cdss - 1 ];

  0020f	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00217	0f b6 40 44	 movzx	 eax, BYTE PTR [rax+68]
  0021b	ff c8		 dec	 eax
  0021d	48 98		 cdqe
  0021f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_nDictSize
  00226	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00229	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00231	48 03 41 30	 add	 rax, QWORD PTR [rcx+48]
  00235	48 89 84 24 b8
	02 00 00	 mov	 QWORD PTR dctblk2$[rsp+8], rax

; 608  : 
; 609  :     cceblk.pDCTBLK    = &dctblk;

  0023d	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR dctblk$[rsp]
  00245	48 89 84 24 d0
	03 00 00	 mov	 QWORD PTR cceblk$[rsp], rax

; 610  :     cceblk.max_index  = max_index;

  0024d	0f b7 44 24 58	 movzx	 eax, WORD PTR max_index$[rsp]
  00252	66 89 84 24 e0
	03 00 00	 mov	 WORD PTR cceblk$[rsp+16], ax

; 611  :     cceblk.pCCE       = NULL;           // (filled in before each call)

  0025a	48 c7 84 24 d8
	03 00 00 00 00
	00 00		 mov	 QWORD PTR cceblk$[rsp+8], 0

; 612  : 
; 613  :     memset( &cceblk.cce, 0, sizeof( cceblk.cce ) );

  00266	48 8d 84 24 e8
	03 00 00	 lea	 rax, QWORD PTR cceblk$[rsp+24]
  0026e	48 8b f8	 mov	 rdi, rax
  00271	33 c0		 xor	 eax, eax
  00273	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00278	f3 aa		 rep stosb

; 614  : 
; 615  :     sdeblk.pDCTBLK    = &dctblk;

  0027a	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR dctblk$[rsp]
  00282	48 89 84 24 f0
	03 04 00	 mov	 QWORD PTR sdeblk$[rsp], rax

; 616  :     sdeblk.pDCTBLK2   = &dctblk2;

  0028a	48 8d 84 24 b0
	02 00 00	 lea	 rax, QWORD PTR dctblk2$[rsp]
  00292	48 89 84 24 f8
	03 04 00	 mov	 QWORD PTR sdeblk$[rsp+8], rax

; 617  :     sdeblk.pSDE       = &sibling;

  0029a	48 8d 84 24 10
	04 07 00	 lea	 rax, QWORD PTR sibling$[rsp]
  002a2	48 89 84 24 00
	04 04 00	 mov	 QWORD PTR sdeblk$[rsp+16], rax

; 618  :     sdeblk.pCCE       = NULL;           // (depends if first sibling)

  002aa	48 c7 84 24 08
	04 04 00 00 00
	00 00		 mov	 QWORD PTR sdeblk$[rsp+24], 0

; 619  : 
; 620  :     memset( &sdeblk.sde, 0, sizeof( sdeblk.sde ) );

  002b6	48 8d 84 24 10
	04 04 00	 lea	 rax, QWORD PTR sdeblk$[rsp+32]
  002be	48 8b f8	 mov	 rdi, rax
  002c1	33 c0		 xor	 eax, eax
  002c3	b9 00 00 03 00	 mov	 ecx, 196608		; 00030000H
  002c8	f3 aa		 rep stosb

; 621  : 
; 622  :     piblk.ppPutIndex  = (void**) &pPutIndex;

  002ca	48 8d 44 24 38	 lea	 rax, QWORD PTR pPutIndex$[rsp]
  002cf	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR piblk$[rsp+16], rax

; 623  :     piblk.pCMPSCBLK   = pCMPSCBLK;

  002d7	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  002df	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR piblk$[rsp], rax

; 624  :     piblk.pMEMBLK     = &op1blk;        // (we put indexes into op-1)

  002e7	48 8d 84 24 e8
	00 00 00	 lea	 rax, QWORD PTR op1blk$[rsp]
  002ef	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR piblk$[rsp+8], rax

; 625  :     piblk.index       = 0;              // (filled in before each call)

  002f7	33 c0		 xor	 eax, eax
  002f9	66 89 84 24 78
	01 00 00	 mov	 WORD PTR piblk$[rsp+24], ax

; 626  : 
; 627  :     op1blk.arn        = pCMPSCBLK->r1;

  00301	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00309	0f b6 40 40	 movzx	 eax, BYTE PTR [rax+64]
  0030d	89 84 24 08 01
	00 00		 mov	 DWORD PTR op1blk$[rsp+32], eax

; 628  :     op1blk.regs       = pCMPSCBLK->regs;

  00314	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0031c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00320	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR op1blk$[rsp], rax

; 629  :     op1blk.pkey       = pCMPSCBLK->regs->psw.pkey;

  00328	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00330	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00334	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00338	88 84 24 0c 01
	00 00		 mov	 BYTE PTR op1blk$[rsp+36], al

; 630  :     op1blk.vpagebeg   = 0;

  0033f	48 c7 84 24 f0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR op1blk$[rsp+8], 0

; 631  :     op1blk.maddr[0]   = 0;

  0034b	b8 08 00 00 00	 mov	 eax, 8
  00350	48 6b c0 00	 imul	 rax, rax, 0
  00354	48 c7 84 04 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR op1blk$[rsp+rax+16], 0

; 632  :     op1blk.maddr[1]   = 0;

  00360	b8 08 00 00 00	 mov	 eax, 8
  00365	48 6b c0 01	 imul	 rax, rax, 1
  00369	48 c7 84 04 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR op1blk$[rsp+rax+16], 0

; 633  : 
; 634  :     op2blk.arn        = pCMPSCBLK->r2;

  00375	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0037d	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  00381	89 84 24 40 01
	00 00		 mov	 DWORD PTR op2blk$[rsp+32], eax

; 635  :     op2blk.regs       = pCMPSCBLK->regs;

  00388	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00390	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00394	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR op2blk$[rsp], rax

; 636  :     op2blk.pkey       = pCMPSCBLK->regs->psw.pkey;

  0039c	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  003a4	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  003a8	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  003ac	88 84 24 44 01
	00 00		 mov	 BYTE PTR op2blk$[rsp+36], al

; 637  :     op2blk.vpagebeg   = 0;

  003b3	48 c7 84 24 28
	01 00 00 00 00
	00 00		 mov	 QWORD PTR op2blk$[rsp+8], 0

; 638  :     op2blk.maddr[0]   = 0;

  003bf	b8 08 00 00 00	 mov	 eax, 8
  003c4	48 6b c0 00	 imul	 rax, rax, 0
  003c8	48 c7 84 04 30
	01 00 00 00 00
	00 00		 mov	 QWORD PTR op2blk$[rsp+rax+16], 0

; 639  :     op2blk.maddr[1]   = 0;

  003d4	b8 08 00 00 00	 mov	 eax, 8
  003d9	48 6b c0 01	 imul	 rax, rax, 1
  003dd	48 c7 84 04 30
	01 00 00 00 00
	00 00		 mov	 QWORD PTR op2blk$[rsp+rax+16], 0

; 640  : 
; 641  :     // GET STARTED...
; 642  : 
; 643  :     pBegOp2  =  pCMPSCBLK->pOp2;

  003e9	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  003f1	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  003f5	48 89 44 24 50	 mov	 QWORD PTR pBegOp2$[rsp], rax

; 644  :     eodst    =  (pCMPSCBLK->nLen1 < (2 + ((pCMPSCBLK->cbn > (16 - bits)) ? 1 : 0)))

  003fa	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00402	0f b6 40 45	 movzx	 eax, BYTE PTR [rax+69]
  00406	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR bits$[rsp]
  0040b	ba 10 00 00 00	 mov	 edx, 16
  00410	2b d1		 sub	 edx, ecx
  00412	8b ca		 mov	 ecx, edx
  00414	3b c1		 cmp	 eax, ecx
  00416	7e 0d		 jle	 SHORT $LN67@s390_cmpsc
  00418	c7 84 24 d8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv259[rsp], 1
  00423	eb 0b		 jmp	 SHORT $LN68@s390_cmpsc
$LN67@s390_cmpsc:
  00425	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv259[rsp], 0
$LN68@s390_cmpsc:
  00430	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR tv259[rsp]
  00437	83 c0 02	 add	 eax, 2
  0043a	48 98		 cdqe
  0043c	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00444	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00447	73 0d		 jae	 SHORT $LN69@s390_cmpsc
  00449	c7 84 24 dc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv263[rsp], 1
  00454	eb 0b		 jmp	 SHORT $LN70@s390_cmpsc
$LN69@s390_cmpsc:
  00456	c7 84 24 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv263[rsp], 0
$LN70@s390_cmpsc:
  00461	0f b6 84 24 dc
	00 00 00	 movzx	 eax, BYTE PTR tv263[rsp]
  00469	88 44 24 23	 mov	 BYTE PTR eodst$[rsp], al

; 645  :              ?  TRUE : FALSE;
; 646  :     nCPUAmt  =  0;

  0046d	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR nCPUAmt$[rsp], 0
$LN173@s390_cmpsc:
$cmp1$178:

; 647  : 
; 648  :     //-------------------------------------------------------------------------
; 649  :     // PROGRAMMING NOTE: the following compression algorithm follows exactly
; 650  :     // the algorithm documented by IBM in their Principles of Operation manual.
; 651  :     // Most labels and all primary comments match the algorithm's flowchart.
; 652  :     //-------------------------------------------------------------------------
; 653  : 
; 654  : cmp1:
; 655  : 
; 656  :     // Another SRC char exists?
; 657  :     // No, set CC0 and endop.
; 658  : 
; 659  :     if (unlikely( !pCMPSCBLK->nLen2 ))

  00476	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0047e	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00483	75 0d		 jne	 SHORT $LN71@s390_cmpsc
  00485	c7 84 24 e0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv267[rsp], 1
  00490	eb 0b		 jmp	 SHORT $LN72@s390_cmpsc
$LN71@s390_cmpsc:
  00492	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv267[rsp], 0
$LN72@s390_cmpsc:
  0049d	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR tv267[rsp], 0
  004a5	74 0d		 je	 SHORT $LN75@s390_cmpsc
  004a7	c7 84 24 e4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv273[rsp], 1
  004b2	eb 0b		 jmp	 SHORT $LN76@s390_cmpsc
$LN75@s390_cmpsc:
  004b4	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv273[rsp], 0
$LN76@s390_cmpsc:
  004bf	83 bc 24 e4 00
	00 00 00	 cmp	 DWORD PTR tv273[rsp], 0
  004c7	74 2e		 je	 SHORT $LN8@s390_cmpsc

; 660  :     {
; 661  :         PUTSETCBN();

  004c9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  004ce	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  004d2	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  004da	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 662  :         RETCC0( &op1blk );

  004dd	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  004e5	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  004ed	e8 00 00 00 00	 call	 s390_CC0
  004f2	e9 dd 11 00 00	 jmp	 $LN1@s390_cmpsc
$LN8@s390_cmpsc:
$cmp2$179:

; 663  :     }
; 664  : 
; 665  : cmp2:
; 666  : 
; 667  :     // Another DST index position exists?
; 668  :     // No, set CC1 and endop.
; 669  : 
; 670  :     if (unlikely( eodst ))

  004f7	0f b6 44 24 23	 movzx	 eax, BYTE PTR eodst$[rsp]
  004fc	85 c0		 test	 eax, eax
  004fe	74 0a		 je	 SHORT $LN79@s390_cmpsc
  00500	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv287[rsp], 1
  00508	eb 08		 jmp	 SHORT $LN80@s390_cmpsc
$LN79@s390_cmpsc:
  0050a	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv287[rsp], 0
$LN80@s390_cmpsc:
  00512	83 7c 24 5c 00	 cmp	 DWORD PTR tv287[rsp], 0
  00517	74 2e		 je	 SHORT $LN9@s390_cmpsc

; 671  :     {
; 672  :         PUTSETCBN();

  00519	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  0051e	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  00522	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0052a	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 673  :         RETCC1( &op1blk );

  0052d	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  00535	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0053d	e8 00 00 00 00	 call	 s390_CC1
  00542	e9 8d 11 00 00	 jmp	 $LN1@s390_cmpsc
$LN9@s390_cmpsc:

; 674  :     }
; 675  : 
; 676  :     if (unlikely( nCPUAmt >= (U64) pCMPSCBLK->nCPUAmt ))  // (max bytes processed?)

  00547	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0054f	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00552	48 39 44 24 48	 cmp	 QWORD PTR nCPUAmt$[rsp], rax
  00557	72 0a		 jb	 SHORT $LN83@s390_cmpsc
  00559	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv303[rsp], 1
  00561	eb 08		 jmp	 SHORT $LN84@s390_cmpsc
$LN83@s390_cmpsc:
  00563	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv303[rsp], 0
$LN84@s390_cmpsc:
  0056b	83 7c 24 60 00	 cmp	 DWORD PTR tv303[rsp], 0
  00570	74 2e		 je	 SHORT $LN10@s390_cmpsc

; 677  :     {
; 678  :         PUTSETCBN();

  00572	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  00577	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  0057b	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00583	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 679  :         RETCC3( &op1blk );                                // (return cc3 to caller)

  00586	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  0058e	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00596	e8 00 00 00 00	 call	 s390_CC3
  0059b	e9 34 11 00 00	 jmp	 $LN1@s390_cmpsc
$LN10@s390_cmpsc:

; 680  :     }
; 681  : 
; 682  :     children = 0;

  005a0	33 c0		 xor	 eax, eax
  005a2	66 89 44 24 2c	 mov	 WORD PTR children$[rsp], ax

; 683  : 
; 684  :     // Use next SRC char as index of alphabet entry.
; 685  :     // Call this entry the parent.
; 686  :     // Advance 1 byte in SRC.
; 687  : 
; 688  :     parent_index = (U16) fetch_op_b( pCMPSCBLK->pOp2, &op2blk );

  005a7	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR op2blk$[rsp]
  005af	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  005b7	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  005ba	e8 00 00 00 00	 call	 s390_cmpsc_vfetchb
  005bf	0f b6 c0	 movzx	 eax, al
  005c2	66 89 44 24 24	 mov	 WORD PTR parent_index$[rsp], ax

; 689  : 
; 690  :     cceblk.pCCE = &parent;

  005c7	48 8d 84 24 28
	04 07 00	 lea	 rax, QWORD PTR parent$[rsp]
  005cf	48 89 84 24 d8
	03 00 00	 mov	 QWORD PTR cceblk$[rsp+8], rax

; 691  :     if (unlikely( !ARCH_DEP( GetCCE )( parent_index, &cceblk )))

  005d7	48 8d 94 24 d0
	03 00 00	 lea	 rdx, QWORD PTR cceblk$[rsp]
  005df	0f b7 4c 24 24	 movzx	 ecx, WORD PTR parent_index$[rsp]
  005e4	e8 00 00 00 00	 call	 s390_GetCCE
  005e9	0f b6 c0	 movzx	 eax, al
  005ec	85 c0		 test	 eax, eax
  005ee	75 0a		 jne	 SHORT $LN85@s390_cmpsc
  005f0	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv321[rsp], 1
  005f8	eb 08		 jmp	 SHORT $LN86@s390_cmpsc
$LN85@s390_cmpsc:
  005fa	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv321[rsp], 0
$LN86@s390_cmpsc:
  00602	83 7c 24 64 00	 cmp	 DWORD PTR tv321[rsp], 0
  00607	74 0a		 je	 SHORT $LN89@s390_cmpsc
  00609	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv330[rsp], 1
  00611	eb 08		 jmp	 SHORT $LN90@s390_cmpsc
$LN89@s390_cmpsc:
  00613	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv330[rsp], 0
$LN90@s390_cmpsc:
  0061b	83 7c 24 68 00	 cmp	 DWORD PTR tv330[rsp], 0
  00620	74 2e		 je	 SHORT $LN11@s390_cmpsc

; 692  :     {
; 693  :         PUTSETCBN();

  00622	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  00627	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  0062b	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00633	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 694  :         RETERR( &op1blk );

  00636	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  0063e	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00646	e8 00 00 00 00	 call	 s390_ERR
  0064b	e9 84 10 00 00	 jmp	 $LN1@s390_cmpsc
$LN11@s390_cmpsc:

; 695  :     }
; 696  : 
; 697  :     nCPUAmt++;

  00650	48 8b 44 24 48	 mov	 rax, QWORD PTR nCPUAmt$[rsp]
  00655	48 ff c0	 inc	 rax
  00658	48 89 44 24 48	 mov	 QWORD PTR nCPUAmt$[rsp], rax

; 698  :     pCMPSCBLK->pOp2++;

  0065d	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00665	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00669	48 ff c0	 inc	 rax
  0066c	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00674	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 699  :     pCMPSCBLK->nLen2--;

  00678	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00680	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00684	48 ff c8	 dec	 rax
  00687	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0068f	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
$LN174@s390_cmpsc:
$cmp3$180:
$LN4@s390_cmpsc:

; 700  : 
; 701  : cmp3:
; 702  : 
; 703  :     MEMBLK_BUMP( &op1blk, pCMPSCBLK->pOp1 );

  00693	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR op1blk$[rsp+8]
  0069b	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  006a1	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  006a9	48 39 41 20	 cmp	 QWORD PTR [rcx+32], rax
  006ad	73 0a		 jae	 SHORT $LN93@s390_cmpsc
  006af	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv355[rsp], 1
  006b7	eb 08		 jmp	 SHORT $LN94@s390_cmpsc
$LN93@s390_cmpsc:
  006b9	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv355[rsp], 0
$LN94@s390_cmpsc:
  006c1	83 7c 24 6c 00	 cmp	 DWORD PTR tv355[rsp], 0
  006c6	75 4d		 jne	 SHORT $LN12@s390_cmpsc
  006c8	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR op1blk$[rsp+8]
  006d0	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  006d6	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR op1blk$[rsp+8], rax
  006de	b8 08 00 00 00	 mov	 eax, 8
  006e3	48 6b c0 01	 imul	 rax, rax, 1
  006e7	b9 08 00 00 00	 mov	 ecx, 8
  006ec	48 6b c9 00	 imul	 rcx, rcx, 0
  006f0	48 8b 84 04 f8
	00 00 00	 mov	 rax, QWORD PTR op1blk$[rsp+rax+16]
  006f8	48 89 84 0c f8
	00 00 00	 mov	 QWORD PTR op1blk$[rsp+rcx+16], rax
  00700	b8 08 00 00 00	 mov	 eax, 8
  00705	48 6b c0 01	 imul	 rax, rax, 1
  00709	48 c7 84 04 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR op1blk$[rsp+rax+16], 0
$LN12@s390_cmpsc:
  00715	33 c0		 xor	 eax, eax
  00717	85 c0		 test	 eax, eax
  00719	0f 85 74 ff ff
	ff		 jne	 $LN4@s390_cmpsc
$LN7@s390_cmpsc:

; 704  :     MEMBLK_BUMP( &op2blk, pCMPSCBLK->pOp2 );

  0071f	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR op2blk$[rsp+8]
  00727	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  0072d	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00735	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  00739	73 0a		 jae	 SHORT $LN97@s390_cmpsc
  0073b	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv373[rsp], 1
  00743	eb 08		 jmp	 SHORT $LN98@s390_cmpsc
$LN97@s390_cmpsc:
  00745	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv373[rsp], 0
$LN98@s390_cmpsc:
  0074d	83 7c 24 70 00	 cmp	 DWORD PTR tv373[rsp], 0
  00752	75 4d		 jne	 SHORT $LN13@s390_cmpsc
  00754	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR op2blk$[rsp+8]
  0075c	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00762	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR op2blk$[rsp+8], rax
  0076a	b8 08 00 00 00	 mov	 eax, 8
  0076f	48 6b c0 01	 imul	 rax, rax, 1
  00773	b9 08 00 00 00	 mov	 ecx, 8
  00778	48 6b c9 00	 imul	 rcx, rcx, 0
  0077c	48 8b 84 04 30
	01 00 00	 mov	 rax, QWORD PTR op2blk$[rsp+rax+16]
  00784	48 89 84 0c 30
	01 00 00	 mov	 QWORD PTR op2blk$[rsp+rcx+16], rax
  0078c	b8 08 00 00 00	 mov	 eax, 8
  00791	48 6b c0 01	 imul	 rax, rax, 1
  00795	48 c7 84 04 30
	01 00 00 00 00
	00 00		 mov	 QWORD PTR op2blk$[rsp+rax+16], 0
$LN13@s390_cmpsc:
  007a1	33 c0		 xor	 eax, eax
  007a3	85 c0		 test	 eax, eax
  007a5	0f 85 74 ff ff
	ff		 jne	 $LN7@s390_cmpsc

; 705  : 
; 706  :     // CCT=0?
; 707  :     // Yes, goto cmp9;
; 708  : 
; 709  :     if (!parent.cct)

  007ab	0f b6 84 24 3e
	04 07 00	 movzx	 eax, BYTE PTR parent$[rsp+22]
  007b3	85 c0		 test	 eax, eax
  007b5	75 05		 jne	 SHORT $LN14@s390_cmpsc

; 710  :         goto cmp9;

  007b7	e9 11 06 00 00	 jmp	 $cmp9$181
$LN14@s390_cmpsc:

; 711  : 
; 712  : //cmp4:
; 713  : 
; 714  :     ccnum = 0;

  007bc	c6 44 24 21 00	 mov	 BYTE PTR ccnum$[rsp], 0

; 715  : 
; 716  :     // Set flag=1.
; 717  : 
; 718  :     flag = TRUE;

  007c1	c6 44 24 31 01	 mov	 BYTE PTR flag$[rsp], 1

; 719  : 
; 720  :     // Another SRC char exists?
; 721  :     // No, goto cmp13;
; 722  : 
; 723  :     if (unlikely( !pCMPSCBLK->nLen2 ))

  007c6	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  007ce	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  007d3	75 0a		 jne	 SHORT $LN99@s390_cmpsc
  007d5	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv387[rsp], 1
  007dd	eb 08		 jmp	 SHORT $LN100@s390_cmpsc
$LN99@s390_cmpsc:
  007df	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv387[rsp], 0
$LN100@s390_cmpsc:
  007e7	83 7c 24 74 00	 cmp	 DWORD PTR tv387[rsp], 0
  007ec	74 0a		 je	 SHORT $LN103@s390_cmpsc
  007ee	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv393[rsp], 1
  007f6	eb 08		 jmp	 SHORT $LN104@s390_cmpsc
$LN103@s390_cmpsc:
  007f8	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv393[rsp], 0
$LN104@s390_cmpsc:
  00800	83 7c 24 78 00	 cmp	 DWORD PTR tv393[rsp], 0
  00805	74 05		 je	 SHORT $LN15@s390_cmpsc

; 724  :         goto cmp13;

  00807	e9 f1 0a 00 00	 jmp	 $cmp13$182
$LN15@s390_cmpsc:
$LN175@s390_cmpsc:
$cmp5$183:

; 725  : 
; 726  :     // (REPEAT FOR EACH CC)...
; 727  : 
; 728  : cmp5:
; 729  : 
; 730  :     // ---------------- UNROLL #1 ----------------
; 731  : 
; 732  :     // Next SRC char = CC?
; 733  :     // Yes, goto cmp10;
; 734  : 
; 735  :     byt = fetch_op_b( pCMPSCBLK->pOp2, &op2blk );

  0080c	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR op2blk$[rsp]
  00814	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0081c	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0081f	e8 00 00 00 00	 call	 s390_cmpsc_vfetchb
  00824	88 44 24 22	 mov	 BYTE PTR byt$[rsp], al

; 736  : 
; 737  :     if (byt == parent.cc[ ccnum ])

  00828	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  0082d	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR ccnum$[rsp]
  00832	0f b6 8c 0c 30
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+rcx+8]
  0083a	3b c1		 cmp	 eax, ecx
  0083c	75 05		 jne	 SHORT $LN16@s390_cmpsc

; 738  :         goto cmp10;

  0083e	e9 bf 06 00 00	 jmp	 $cmp10$184
$LN16@s390_cmpsc:

; 739  : 
; 740  :     // Set flag=0;
; 741  :     flag = FALSE;

  00843	c6 44 24 31 00	 mov	 BYTE PTR flag$[rsp], 0

; 742  : 
; 743  :     // Another CC?
; 744  :     // Yes, goto cmp5;
; 745  : 
; 746  :     if (++ccnum >= parent.cct)

  00848	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  0084d	fe c0		 inc	 al
  0084f	88 44 24 21	 mov	 BYTE PTR ccnum$[rsp], al
  00853	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  00858	0f b6 8c 24 3e
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+22]
  00860	3b c1		 cmp	 eax, ecx
  00862	7c 05		 jl	 SHORT $LN17@s390_cmpsc

; 747  :         goto cmp5E;

  00864	e9 ea 00 00 00	 jmp	 $cmp5E$185
$LN17@s390_cmpsc:

; 748  : 
; 749  :     // ---------------- UNROLL #2 ----------------
; 750  : 
; 751  :     // Next SRC char = CC?
; 752  :     // Yes, goto cmp10;
; 753  : 
; 754  :     if (byt == parent.cc[ ccnum ])

  00869	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  0086e	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR ccnum$[rsp]
  00873	0f b6 8c 0c 30
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+rcx+8]
  0087b	3b c1		 cmp	 eax, ecx
  0087d	75 05		 jne	 SHORT $LN18@s390_cmpsc

; 755  :         goto cmp10;

  0087f	e9 7e 06 00 00	 jmp	 $cmp10$184
$LN18@s390_cmpsc:

; 756  : 
; 757  :     // Set flag=0;
; 758  : //  flag = FALSE;   // (already done by UNROLL #1)
; 759  : 
; 760  :     // Another CC?
; 761  :     // Yes, goto cmp5;
; 762  : 
; 763  :     if (++ccnum >= parent.cct)

  00884	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  00889	fe c0		 inc	 al
  0088b	88 44 24 21	 mov	 BYTE PTR ccnum$[rsp], al
  0088f	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  00894	0f b6 8c 24 3e
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+22]
  0089c	3b c1		 cmp	 eax, ecx
  0089e	7c 05		 jl	 SHORT $LN19@s390_cmpsc

; 764  :         goto cmp5E;

  008a0	e9 ae 00 00 00	 jmp	 $cmp5E$185
$LN19@s390_cmpsc:

; 765  : 
; 766  :     // ---------------- UNROLL #3 ----------------
; 767  : 
; 768  :     // Next SRC char = CC?
; 769  :     // Yes, goto cmp10;
; 770  : 
; 771  :     if (byt == parent.cc[ ccnum ])

  008a5	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  008aa	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR ccnum$[rsp]
  008af	0f b6 8c 0c 30
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+rcx+8]
  008b7	3b c1		 cmp	 eax, ecx
  008b9	75 05		 jne	 SHORT $LN20@s390_cmpsc

; 772  :         goto cmp10;

  008bb	e9 42 06 00 00	 jmp	 $cmp10$184
$LN20@s390_cmpsc:

; 773  : 
; 774  :     // Set flag=0;
; 775  : //  flag = FALSE;   // (already done by UNROLL #1)
; 776  : 
; 777  :     // Another CC?
; 778  :     // Yes, goto cmp5;
; 779  : 
; 780  :     if (++ccnum >= parent.cct)

  008c0	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  008c5	fe c0		 inc	 al
  008c7	88 44 24 21	 mov	 BYTE PTR ccnum$[rsp], al
  008cb	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  008d0	0f b6 8c 24 3e
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+22]
  008d8	3b c1		 cmp	 eax, ecx
  008da	7c 02		 jl	 SHORT $LN21@s390_cmpsc

; 781  :         goto cmp5E;

  008dc	eb 75		 jmp	 SHORT $cmp5E$185
$LN21@s390_cmpsc:

; 782  : 
; 783  :     // ---------------- UNROLL #4 ----------------
; 784  : 
; 785  :     // Next SRC char = CC?
; 786  :     // Yes, goto cmp10;
; 787  : 
; 788  :     if (byt == parent.cc[ ccnum ])

  008de	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  008e3	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR ccnum$[rsp]
  008e8	0f b6 8c 0c 30
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+rcx+8]
  008f0	3b c1		 cmp	 eax, ecx
  008f2	75 05		 jne	 SHORT $LN22@s390_cmpsc

; 789  :         goto cmp10;

  008f4	e9 09 06 00 00	 jmp	 $cmp10$184
$LN22@s390_cmpsc:

; 790  : 
; 791  :     // Set flag=0;
; 792  : //  flag = FALSE;   // (already done by UNROLL #1)
; 793  : 
; 794  :     // Another CC?
; 795  :     // Yes, goto cmp5;
; 796  : 
; 797  :     if (++ccnum >= parent.cct)

  008f9	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  008fe	fe c0		 inc	 al
  00900	88 44 24 21	 mov	 BYTE PTR ccnum$[rsp], al
  00904	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  00909	0f b6 8c 24 3e
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+22]
  00911	3b c1		 cmp	 eax, ecx
  00913	7c 02		 jl	 SHORT $LN23@s390_cmpsc

; 798  :         goto cmp5E;

  00915	eb 3c		 jmp	 SHORT $cmp5E$185
$LN23@s390_cmpsc:

; 799  : 
; 800  :     // ---------------- UNROLL #5 ----------------
; 801  : 
; 802  :     // Next SRC char = CC?
; 803  :     // Yes, goto cmp10;
; 804  : 
; 805  :     if (byt == parent.cc[ ccnum ])

  00917	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  0091c	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR ccnum$[rsp]
  00921	0f b6 8c 0c 30
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+rcx+8]
  00929	3b c1		 cmp	 eax, ecx
  0092b	75 05		 jne	 SHORT $LN24@s390_cmpsc

; 806  :         goto cmp10;

  0092d	e9 d0 05 00 00	 jmp	 $cmp10$184
$LN24@s390_cmpsc:

; 807  : 
; 808  :     // Set flag=0;
; 809  : //  flag = FALSE;   // (already done by UNROLL #1)
; 810  : 
; 811  :     // Another CC?
; 812  :     // Yes, goto cmp5;
; 813  : 
; 814  :     if (++ccnum < parent.cct)   // (** last UNROLL **)

  00932	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  00937	fe c0		 inc	 al
  00939	88 44 24 21	 mov	 BYTE PTR ccnum$[rsp], al
  0093d	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  00942	0f b6 8c 24 3e
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+22]
  0094a	3b c1		 cmp	 eax, ecx
  0094c	7d 05		 jge	 SHORT $LN25@s390_cmpsc

; 815  :         goto cmp5;

  0094e	e9 b9 fe ff ff	 jmp	 $cmp5$183
$LN25@s390_cmpsc:
$cmp5E$185:

; 816  : 
; 817  : cmp5E:
; 818  : 
; 819  :     // CCT indicates more children?
; 820  :     // No, goto cmp8;
; 821  : 
; 822  :     if (!parent.mc)

  00953	0f b6 84 24 40
	04 07 00	 movzx	 eax, BYTE PTR parent$[rsp+24]
  0095b	85 c0		 test	 eax, eax
  0095d	75 05		 jne	 SHORT $LN26@s390_cmpsc

; 823  :         goto cmp8;

  0095f	e9 34 03 00 00	 jmp	 $cmp8$186
$LN26@s390_cmpsc:

; 824  : 
; 825  : //cmp6:
; 826  : 
; 827  :     // Set SD index = CPTR + #of CC's.
; 828  : 
; 829  :     sibling_index = (parent.cptr + parent.cct);

  00964	0f b7 84 24 38
	04 07 00	 movzx	 eax, WORD PTR parent$[rsp+16]
  0096c	0f b6 8c 24 3e
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+22]
  00974	03 c1		 add	 eax, ecx
  00976	66 89 44 24 34	 mov	 WORD PTR sibling_index$[rsp], ax

; 830  : 
; 831  :     sdeblk.pCCE = &parent;

  0097b	48 8d 84 24 28
	04 07 00	 lea	 rax, QWORD PTR parent$[rsp]
  00983	48 89 84 24 08
	04 04 00	 mov	 QWORD PTR sdeblk$[rsp+24], rax

; 832  :     if (unlikely( !pGetSD( sibling_index, &sdeblk )))

  0098b	48 8d 94 24 f0
	03 04 00	 lea	 rdx, QWORD PTR sdeblk$[rsp]
  00993	0f b7 4c 24 34	 movzx	 ecx, WORD PTR sibling_index$[rsp]
  00998	ff 94 24 58 01
	00 00		 call	 QWORD PTR pGetSD$[rsp]
  0099f	0f b6 c0	 movzx	 eax, al
  009a2	85 c0		 test	 eax, eax
  009a4	75 0a		 jne	 SHORT $LN105@s390_cmpsc
  009a6	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR tv460[rsp], 1
  009ae	eb 08		 jmp	 SHORT $LN106@s390_cmpsc
$LN105@s390_cmpsc:
  009b0	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv460[rsp], 0
$LN106@s390_cmpsc:
  009b8	83 7c 24 7c 00	 cmp	 DWORD PTR tv460[rsp], 0
  009bd	74 0d		 je	 SHORT $LN109@s390_cmpsc
  009bf	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv469[rsp], 1
  009ca	eb 0b		 jmp	 SHORT $LN110@s390_cmpsc
$LN109@s390_cmpsc:
  009cc	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv469[rsp], 0
$LN110@s390_cmpsc:
  009d7	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR tv469[rsp], 0
  009df	74 2e		 je	 SHORT $LN27@s390_cmpsc

; 833  :     {
; 834  :         PUTSETCBN();

  009e1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  009e6	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  009ea	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  009f2	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 835  :         RETERR( &op1blk );

  009f5	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  009fd	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00a05	e8 00 00 00 00	 call	 s390_ERR
  00a0a	e9 c5 0c 00 00	 jmp	 $LN1@s390_cmpsc
$LN27@s390_cmpsc:

; 836  :     }
; 837  :     scnum = 0;

  00a0f	c6 44 24 20 00	 mov	 BYTE PTR scnum$[rsp], 0
$LN176@s390_cmpsc:
$cmp7$187:

; 838  : 
; 839  :     // (REPEAT FOR EACH SC IN SD)...
; 840  : 
; 841  : cmp7:
; 842  : 
; 843  :     // ---------------- UNROLL #1 ----------------
; 844  : 
; 845  :     // Next SRC char = SC?
; 846  :     // Yes, goto cmp12;
; 847  : 
; 848  :     byt = fetch_op_b( pCMPSCBLK->pOp2, &op2blk );

  00a14	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR op2blk$[rsp]
  00a1c	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00a24	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00a27	e8 00 00 00 00	 call	 s390_cmpsc_vfetchb
  00a2c	88 44 24 22	 mov	 BYTE PTR byt$[rsp], al

; 849  : 
; 850  :     if (byt == sibling.sc[ scnum ])

  00a30	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  00a35	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR scnum$[rsp]
  00a3a	0f b6 8c 0c 10
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+rcx]
  00a42	3b c1		 cmp	 eax, ecx
  00a44	75 05		 jne	 SHORT $LN28@s390_cmpsc

; 851  :         goto cmp12;

  00a46	e9 dc 06 00 00	 jmp	 $cmp12$188
$LN28@s390_cmpsc:

; 852  : 
; 853  :     // Another SC?
; 854  :     // Yes, goto cmp7;
; 855  : 
; 856  :     if (++scnum >= sibling.sct)

  00a4b	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00a50	fe c0		 inc	 al
  00a52	88 44 24 20	 mov	 BYTE PTR scnum$[rsp], al
  00a56	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00a5b	0f b6 8c 24 22
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+18]
  00a63	3b c1		 cmp	 eax, ecx
  00a65	7c 05		 jl	 SHORT $LN29@s390_cmpsc

; 857  :         goto cmp7E;

  00a67	e9 62 01 00 00	 jmp	 $cmp7E$189
$LN29@s390_cmpsc:

; 858  : 
; 859  :     // ---------------- UNROLL #2 ----------------
; 860  : 
; 861  :     // Next SRC char = SC?
; 862  :     // Yes, goto cmp12;
; 863  : 
; 864  :     if (byt == sibling.sc[ scnum ])

  00a6c	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  00a71	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR scnum$[rsp]
  00a76	0f b6 8c 0c 10
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+rcx]
  00a7e	3b c1		 cmp	 eax, ecx
  00a80	75 05		 jne	 SHORT $LN30@s390_cmpsc

; 865  :         goto cmp12;

  00a82	e9 a0 06 00 00	 jmp	 $cmp12$188
$LN30@s390_cmpsc:

; 866  : 
; 867  :     // Another SC?
; 868  :     // Yes, goto cmp7;
; 869  : 
; 870  :     if (++scnum >= sibling.sct)

  00a87	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00a8c	fe c0		 inc	 al
  00a8e	88 44 24 20	 mov	 BYTE PTR scnum$[rsp], al
  00a92	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00a97	0f b6 8c 24 22
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+18]
  00a9f	3b c1		 cmp	 eax, ecx
  00aa1	7c 05		 jl	 SHORT $LN31@s390_cmpsc

; 871  :         goto cmp7E;

  00aa3	e9 26 01 00 00	 jmp	 $cmp7E$189
$LN31@s390_cmpsc:

; 872  : 
; 873  :     // ---------------- UNROLL #3 ----------------
; 874  : 
; 875  :     // Next SRC char = SC?
; 876  :     // Yes, goto cmp12;
; 877  : 
; 878  :     if (byt == sibling.sc[ scnum ])

  00aa8	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  00aad	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR scnum$[rsp]
  00ab2	0f b6 8c 0c 10
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+rcx]
  00aba	3b c1		 cmp	 eax, ecx
  00abc	75 05		 jne	 SHORT $LN32@s390_cmpsc

; 879  :         goto cmp12;

  00abe	e9 64 06 00 00	 jmp	 $cmp12$188
$LN32@s390_cmpsc:

; 880  : 
; 881  :     // Another SC?
; 882  :     // Yes, goto cmp7;
; 883  : 
; 884  :     if (++scnum >= sibling.sct)

  00ac3	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00ac8	fe c0		 inc	 al
  00aca	88 44 24 20	 mov	 BYTE PTR scnum$[rsp], al
  00ace	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00ad3	0f b6 8c 24 22
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+18]
  00adb	3b c1		 cmp	 eax, ecx
  00add	7c 05		 jl	 SHORT $LN33@s390_cmpsc

; 885  :         goto cmp7E;

  00adf	e9 ea 00 00 00	 jmp	 $cmp7E$189
$LN33@s390_cmpsc:

; 886  : 
; 887  :     // ---------------- UNROLL #4 ----------------
; 888  : 
; 889  :     // Next SRC char = SC?
; 890  :     // Yes, goto cmp12;
; 891  : 
; 892  :     if (byt == sibling.sc[ scnum ])

  00ae4	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  00ae9	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR scnum$[rsp]
  00aee	0f b6 8c 0c 10
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+rcx]
  00af6	3b c1		 cmp	 eax, ecx
  00af8	75 05		 jne	 SHORT $LN34@s390_cmpsc

; 893  :         goto cmp12;

  00afa	e9 28 06 00 00	 jmp	 $cmp12$188
$LN34@s390_cmpsc:

; 894  : 
; 895  :     // Another SC?
; 896  :     // Yes, goto cmp7;
; 897  : 
; 898  :     if (++scnum >= sibling.sct)

  00aff	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00b04	fe c0		 inc	 al
  00b06	88 44 24 20	 mov	 BYTE PTR scnum$[rsp], al
  00b0a	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00b0f	0f b6 8c 24 22
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+18]
  00b17	3b c1		 cmp	 eax, ecx
  00b19	7c 05		 jl	 SHORT $LN35@s390_cmpsc

; 899  :         goto cmp7E;

  00b1b	e9 ae 00 00 00	 jmp	 $cmp7E$189
$LN35@s390_cmpsc:

; 900  : 
; 901  :     // ---------------- UNROLL #5 ----------------
; 902  : 
; 903  :     // Next SRC char = SC?
; 904  :     // Yes, goto cmp12;
; 905  : 
; 906  :     if (byt == sibling.sc[ scnum ])

  00b20	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  00b25	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR scnum$[rsp]
  00b2a	0f b6 8c 0c 10
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+rcx]
  00b32	3b c1		 cmp	 eax, ecx
  00b34	75 05		 jne	 SHORT $LN36@s390_cmpsc

; 907  :         goto cmp12;

  00b36	e9 ec 05 00 00	 jmp	 $cmp12$188
$LN36@s390_cmpsc:

; 908  : 
; 909  :     // Another SC?
; 910  :     // Yes, goto cmp7;
; 911  : 
; 912  :     if (++scnum >= sibling.sct)

  00b3b	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00b40	fe c0		 inc	 al
  00b42	88 44 24 20	 mov	 BYTE PTR scnum$[rsp], al
  00b46	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00b4b	0f b6 8c 24 22
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+18]
  00b53	3b c1		 cmp	 eax, ecx
  00b55	7c 02		 jl	 SHORT $LN37@s390_cmpsc

; 913  :         goto cmp7E;

  00b57	eb 75		 jmp	 SHORT $cmp7E$189
$LN37@s390_cmpsc:

; 914  : 
; 915  :     // ---------------- UNROLL #6 ----------------
; 916  : 
; 917  :     // Next SRC char = SC?
; 918  :     // Yes, goto cmp12;
; 919  : 
; 920  :     if (byt == sibling.sc[ scnum ])

  00b59	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  00b5e	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR scnum$[rsp]
  00b63	0f b6 8c 0c 10
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+rcx]
  00b6b	3b c1		 cmp	 eax, ecx
  00b6d	75 05		 jne	 SHORT $LN38@s390_cmpsc

; 921  :         goto cmp12;

  00b6f	e9 b3 05 00 00	 jmp	 $cmp12$188
$LN38@s390_cmpsc:

; 922  : 
; 923  :     // Another SC?
; 924  :     // Yes, goto cmp7;
; 925  : 
; 926  :     if (++scnum >= sibling.sct)

  00b74	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00b79	fe c0		 inc	 al
  00b7b	88 44 24 20	 mov	 BYTE PTR scnum$[rsp], al
  00b7f	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00b84	0f b6 8c 24 22
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+18]
  00b8c	3b c1		 cmp	 eax, ecx
  00b8e	7c 02		 jl	 SHORT $LN39@s390_cmpsc

; 927  :         goto cmp7E;

  00b90	eb 3c		 jmp	 SHORT $cmp7E$189
$LN39@s390_cmpsc:

; 928  : 
; 929  :     // ---------------- UNROLL #7 ----------------
; 930  : 
; 931  :     // Next SRC char = SC?
; 932  :     // Yes, goto cmp12;
; 933  : 
; 934  :     if (byt == sibling.sc[ scnum ])

  00b92	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  00b97	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR scnum$[rsp]
  00b9c	0f b6 8c 0c 10
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+rcx]
  00ba4	3b c1		 cmp	 eax, ecx
  00ba6	75 05		 jne	 SHORT $LN40@s390_cmpsc

; 935  :         goto cmp12;

  00ba8	e9 7a 05 00 00	 jmp	 $cmp12$188
$LN40@s390_cmpsc:

; 936  : 
; 937  :     // Another SC?
; 938  :     // Yes, goto cmp7;
; 939  : 
; 940  :     if (++scnum < sibling.sct)  // (** last UNROLL **)

  00bad	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00bb2	fe c0		 inc	 al
  00bb4	88 44 24 20	 mov	 BYTE PTR scnum$[rsp], al
  00bb8	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00bbd	0f b6 8c 24 22
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+18]
  00bc5	3b c1		 cmp	 eax, ecx
  00bc7	7d 05		 jge	 SHORT $LN41@s390_cmpsc

; 941  :         goto cmp7;

  00bc9	e9 46 fe ff ff	 jmp	 $cmp7$187
$LN41@s390_cmpsc:
$cmp7E$189:

; 942  : 
; 943  : cmp7E:
; 944  : 
; 945  :     // SCT indicates more children?
; 946  :     // No, goto cmp8;
; 947  : 
; 948  :     if (!sibling.ms)

  00bce	0f b6 84 24 23
	04 07 00	 movzx	 eax, BYTE PTR sibling$[rsp+19]
  00bd6	85 c0		 test	 eax, eax
  00bd8	75 05		 jne	 SHORT $LN42@s390_cmpsc

; 949  :         goto cmp8;

  00bda	e9 b9 00 00 00	 jmp	 $cmp8$186
$LN42@s390_cmpsc:

; 950  : 
; 951  :     // Set SD index = current SD index + #of SC's + 1.
; 952  : 
; 953  :     sibling_index += sibling.sct + 1;

  00bdf	0f b6 84 24 22
	04 07 00	 movzx	 eax, BYTE PTR sibling$[rsp+18]
  00be7	0f b7 4c 24 34	 movzx	 ecx, WORD PTR sibling_index$[rsp]
  00bec	8d 44 01 01	 lea	 eax, DWORD PTR [rcx+rax+1]
  00bf0	66 89 44 24 34	 mov	 WORD PTR sibling_index$[rsp], ax

; 954  : 
; 955  :     sdeblk.pCCE = NULL;

  00bf5	48 c7 84 24 08
	04 04 00 00 00
	00 00		 mov	 QWORD PTR sdeblk$[rsp+24], 0

; 956  :     if (unlikely( !pGetSD( sibling_index, &sdeblk )))

  00c01	48 8d 94 24 f0
	03 04 00	 lea	 rdx, QWORD PTR sdeblk$[rsp]
  00c09	0f b7 4c 24 34	 movzx	 ecx, WORD PTR sibling_index$[rsp]
  00c0e	ff 94 24 58 01
	00 00		 call	 QWORD PTR pGetSD$[rsp]
  00c15	0f b6 c0	 movzx	 eax, al
  00c18	85 c0		 test	 eax, eax
  00c1a	75 0d		 jne	 SHORT $LN111@s390_cmpsc
  00c1c	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv563[rsp], 1
  00c27	eb 0b		 jmp	 SHORT $LN112@s390_cmpsc
$LN111@s390_cmpsc:
  00c29	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv563[rsp], 0
$LN112@s390_cmpsc:
  00c34	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR tv563[rsp], 0
  00c3c	74 0d		 je	 SHORT $LN115@s390_cmpsc
  00c3e	c7 84 24 88 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv572[rsp], 1
  00c49	eb 0b		 jmp	 SHORT $LN116@s390_cmpsc
$LN115@s390_cmpsc:
  00c4b	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv572[rsp], 0
$LN116@s390_cmpsc:
  00c56	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR tv572[rsp], 0
  00c5e	74 2e		 je	 SHORT $LN43@s390_cmpsc

; 957  :     {
; 958  :         PUTSETCBN();

  00c60	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  00c65	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  00c69	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00c71	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 959  :         RETERR( &op1blk );

  00c74	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  00c7c	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00c84	e8 00 00 00 00	 call	 s390_ERR
  00c89	e9 46 0a 00 00	 jmp	 $LN1@s390_cmpsc
$LN43@s390_cmpsc:

; 960  :     }
; 961  :     scnum = 0;

  00c8e	c6 44 24 20 00	 mov	 BYTE PTR scnum$[rsp], 0

; 962  : 
; 963  :     // goto cmp7;
; 964  : 
; 965  :     goto cmp7;

  00c93	e9 7c fd ff ff	 jmp	 $LN176@s390_cmpsc
$cmp8$186:

; 966  : 
; 967  : cmp8:
; 968  : 
; 969  :     // Store parent index in DST.
; 970  :     // Advance 1 index in DST.
; 971  :     // goto cmp2;
; 972  : 
; 973  :     if (unlikely( (pCMPSCBLK->pOp2 - pBegOp2) > MAX_SYMLEN ))

  00c98	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00ca0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pBegOp2$[rsp]
  00ca5	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00ca9	48 2b c1	 sub	 rax, rcx
  00cac	48 3d 04 01 00
	00		 cmp	 rax, 260		; 00000104H
  00cb2	76 0d		 jbe	 SHORT $LN119@s390_cmpsc
  00cb4	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv588[rsp], 1
  00cbf	eb 0b		 jmp	 SHORT $LN120@s390_cmpsc
$LN119@s390_cmpsc:
  00cc1	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv588[rsp], 0
$LN120@s390_cmpsc:
  00ccc	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR tv588[rsp], 0
  00cd4	74 2e		 je	 SHORT $LN44@s390_cmpsc

; 974  :     {
; 975  :         PUTSETCBN();

  00cd6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  00cdb	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  00cdf	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00ce7	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 976  :         RETERR( &op1blk );

  00cea	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  00cf2	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00cfa	e8 00 00 00 00	 call	 s390_ERR
  00cff	e9 d0 09 00 00	 jmp	 $LN1@s390_cmpsc
$LN44@s390_cmpsc:

; 977  :     }
; 978  :     pBegOp2  =  pCMPSCBLK->pOp2;

  00d04	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00d0c	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00d10	48 89 44 24 50	 mov	 QWORD PTR pBegOp2$[rsp], rax

; 979  : 
; 980  :     piblk.index = (!pCMPSCBLK->st) ? parent_index

  00d15	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00d1d	0f b6 40 42	 movzx	 eax, BYTE PTR [rax+66]
  00d21	85 c0		 test	 eax, eax
  00d23	75 0d		 jne	 SHORT $LN121@s390_cmpsc
  00d25	c7 84 24 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv600[rsp], 1
  00d30	eb 0b		 jmp	 SHORT $LN122@s390_cmpsc
$LN121@s390_cmpsc:
  00d32	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv600[rsp], 0
$LN122@s390_cmpsc:
  00d3d	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR tv600[rsp], 0
  00d45	74 0e		 je	 SHORT $LN123@s390_cmpsc
  00d47	0f b7 44 24 24	 movzx	 eax, WORD PTR parent_index$[rsp]
  00d4c	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv619[rsp], eax
  00d53	eb 53		 jmp	 SHORT $LN124@s390_cmpsc
$LN123@s390_cmpsc:
  00d55	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00d5d	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  00d61	0f b7 4c 24 24	 movzx	 ecx, WORD PTR parent_index$[rsp]
  00d66	d1 e1		 shl	 ecx, 1
  00d68	48 63 c9	 movsxd	 rcx, ecx
  00d6b	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR pSymTab$[rsp]
  00d73	48 03 d1	 add	 rdx, rcx
  00d76	48 8b ca	 mov	 rcx, rdx
  00d79	48 8b 94 24 b0
	05 07 00	 mov	 rdx, QWORD PTR pCMPSCBLK$[rsp]
  00d81	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00d85	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  00d8b	48 8b 94 24 b0
	05 07 00	 mov	 rdx, QWORD PTR pCMPSCBLK$[rsp]
  00d93	4c 8b 42 18	 mov	 r8, QWORD PTR [rdx+24]
  00d97	8b d0		 mov	 edx, eax
  00d99	e8 00 00 00 00	 call	 s390_vfetch2
  00d9e	0f b7 c0	 movzx	 eax, ax
  00da1	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv619[rsp], eax
$LN124@s390_cmpsc:
  00da8	0f b7 84 24 94
	00 00 00	 movzx	 eax, WORD PTR tv619[rsp]
  00db0	66 89 84 24 78
	01 00 00	 mov	 WORD PTR piblk$[rsp+24], ax

; 981  :           : fetch_dct_hw( pSymTab + (parent_index << 1), pCMPSCBLK );
; 982  :     eodst = pPutIndex( &piblk );

  00db8	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR piblk$[rsp]
  00dc0	ff 54 24 38	 call	 QWORD PTR pPutIndex$[rsp]
  00dc4	88 44 24 23	 mov	 BYTE PTR eodst$[rsp], al

; 983  :     goto cmp2;

  00dc8	e9 2a f7 ff ff	 jmp	 $cmp2$179
$cmp9$181:

; 984  : 
; 985  : cmp9:
; 986  : 
; 987  :     // Store parent index in DST.
; 988  :     // Advance 1 index in DST.
; 989  :     // goto cmp1;
; 990  : 
; 991  :     if (unlikely( (pCMPSCBLK->pOp2 - pBegOp2) > MAX_SYMLEN ))

  00dcd	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00dd5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pBegOp2$[rsp]
  00dda	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00dde	48 2b c1	 sub	 rax, rcx
  00de1	48 3d 04 01 00
	00		 cmp	 rax, 260		; 00000104H
  00de7	76 0d		 jbe	 SHORT $LN127@s390_cmpsc
  00de9	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv631[rsp], 1
  00df4	eb 0b		 jmp	 SHORT $LN128@s390_cmpsc
$LN127@s390_cmpsc:
  00df6	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv631[rsp], 0
$LN128@s390_cmpsc:
  00e01	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR tv631[rsp], 0
  00e09	74 2e		 je	 SHORT $LN45@s390_cmpsc

; 992  :     {
; 993  :         PUTSETCBN();

  00e0b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  00e10	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  00e14	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00e1c	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 994  :         RETERR( &op1blk );

  00e1f	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  00e27	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00e2f	e8 00 00 00 00	 call	 s390_ERR
  00e34	e9 9b 08 00 00	 jmp	 $LN1@s390_cmpsc
$LN45@s390_cmpsc:

; 995  :     }
; 996  :     pBegOp2  =  pCMPSCBLK->pOp2;

  00e39	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00e41	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00e45	48 89 44 24 50	 mov	 QWORD PTR pBegOp2$[rsp], rax

; 997  : 
; 998  :     piblk.index = (!pCMPSCBLK->st) ? parent_index

  00e4a	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00e52	0f b6 40 42	 movzx	 eax, BYTE PTR [rax+66]
  00e56	85 c0		 test	 eax, eax
  00e58	75 0d		 jne	 SHORT $LN129@s390_cmpsc
  00e5a	c7 84 24 9c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv643[rsp], 1
  00e65	eb 0b		 jmp	 SHORT $LN130@s390_cmpsc
$LN129@s390_cmpsc:
  00e67	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv643[rsp], 0
$LN130@s390_cmpsc:
  00e72	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR tv643[rsp], 0
  00e7a	74 0e		 je	 SHORT $LN131@s390_cmpsc
  00e7c	0f b7 44 24 24	 movzx	 eax, WORD PTR parent_index$[rsp]
  00e81	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv662[rsp], eax
  00e88	eb 53		 jmp	 SHORT $LN132@s390_cmpsc
$LN131@s390_cmpsc:
  00e8a	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00e92	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  00e96	0f b7 4c 24 24	 movzx	 ecx, WORD PTR parent_index$[rsp]
  00e9b	d1 e1		 shl	 ecx, 1
  00e9d	48 63 c9	 movsxd	 rcx, ecx
  00ea0	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR pSymTab$[rsp]
  00ea8	48 03 d1	 add	 rdx, rcx
  00eab	48 8b ca	 mov	 rcx, rdx
  00eae	48 8b 94 24 b0
	05 07 00	 mov	 rdx, QWORD PTR pCMPSCBLK$[rsp]
  00eb6	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00eba	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  00ec0	48 8b 94 24 b0
	05 07 00	 mov	 rdx, QWORD PTR pCMPSCBLK$[rsp]
  00ec8	4c 8b 42 18	 mov	 r8, QWORD PTR [rdx+24]
  00ecc	8b d0		 mov	 edx, eax
  00ece	e8 00 00 00 00	 call	 s390_vfetch2
  00ed3	0f b7 c0	 movzx	 eax, ax
  00ed6	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv662[rsp], eax
$LN132@s390_cmpsc:
  00edd	0f b7 84 24 a0
	00 00 00	 movzx	 eax, WORD PTR tv662[rsp]
  00ee5	66 89 84 24 78
	01 00 00	 mov	 WORD PTR piblk$[rsp+24], ax

; 999  :           : fetch_dct_hw( pSymTab + (parent_index << 1), pCMPSCBLK );
; 1000 :     eodst = pPutIndex( &piblk );

  00eed	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR piblk$[rsp]
  00ef5	ff 54 24 38	 call	 QWORD PTR pPutIndex$[rsp]
  00ef9	88 44 24 23	 mov	 BYTE PTR eodst$[rsp], al

; 1001 :     goto cmp1;

  00efd	e9 74 f5 ff ff	 jmp	 $cmp1$178
$cmp10$184:

; 1002 : 
; 1003 : cmp10:
; 1004 : 
; 1005 :     if (unlikely( ++children > MAX_CHILDREN ))

  00f02	0f b7 44 24 2c	 movzx	 eax, WORD PTR children$[rsp]
  00f07	66 ff c0	 inc	 ax
  00f0a	66 89 44 24 2c	 mov	 WORD PTR children$[rsp], ax
  00f0f	0f b7 44 24 2c	 movzx	 eax, WORD PTR children$[rsp]
  00f14	3d 04 01 00 00	 cmp	 eax, 260		; 00000104H
  00f19	7e 0d		 jle	 SHORT $LN135@s390_cmpsc
  00f1b	c7 84 24 a4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv674[rsp], 1
  00f26	eb 0b		 jmp	 SHORT $LN136@s390_cmpsc
$LN135@s390_cmpsc:
  00f28	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv674[rsp], 0
$LN136@s390_cmpsc:
  00f33	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR tv674[rsp], 0
  00f3b	74 2e		 je	 SHORT $LN46@s390_cmpsc

; 1006 :     {
; 1007 :         PUTSETCBN();

  00f3d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  00f42	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  00f46	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00f4e	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 1008 :         RETERR( &op1blk );

  00f51	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  00f59	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00f61	e8 00 00 00 00	 call	 s390_ERR
  00f66	e9 69 07 00 00	 jmp	 $LN1@s390_cmpsc
$LN46@s390_cmpsc:

; 1009 :     }
; 1010 : 
; 1011 :     // Set child index = CPTR + CC number (0-origin numbering).
; 1012 : 
; 1013 :     child_index = parent.cptr + ccnum;

  00f6b	0f b7 84 24 38
	04 07 00	 movzx	 eax, WORD PTR parent$[rsp+16]
  00f73	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR ccnum$[rsp]
  00f78	03 c1		 add	 eax, ecx
  00f7a	66 89 44 24 28	 mov	 WORD PTR child_index$[rsp], ax

; 1014 : 
; 1015 :     // X=1 for child?
; 1016 :     // No, goto cmp14;
; 1017 : 
; 1018 :     if (!(parent.ecb & (0x8000 >> ccnum)))

  00f7f	0f b7 84 24 3a
	04 07 00	 movzx	 eax, WORD PTR parent$[rsp+18]
  00f87	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR ccnum$[rsp]
  00f8c	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  00f91	d3 fa		 sar	 edx, cl
  00f93	8b ca		 mov	 ecx, edx
  00f95	23 c1		 and	 eax, ecx
  00f97	85 c0		 test	 eax, eax
  00f99	75 05		 jne	 SHORT $LN47@s390_cmpsc

; 1019 :         goto cmp14;

  00f9b	e9 b7 04 00 00	 jmp	 $cmp14$190
$LN47@s390_cmpsc:

; 1020 : 
; 1021 :     // ACT=0 or D=0 in child?
; 1022 :     // Yes, goto cmp15;
; 1023 : 
; 1024 :     cceblk.pCCE = &child;

  00fa0	48 8d 84 24 48
	04 07 00	 lea	 rax, QWORD PTR child$[rsp]
  00fa8	48 89 84 24 d8
	03 00 00	 mov	 QWORD PTR cceblk$[rsp+8], rax

; 1025 :     if (unlikely( !ARCH_DEP( GetCCE )( child_index, &cceblk )))

  00fb0	48 8d 94 24 d0
	03 00 00	 lea	 rdx, QWORD PTR cceblk$[rsp]
  00fb8	0f b7 4c 24 28	 movzx	 ecx, WORD PTR child_index$[rsp]
  00fbd	e8 00 00 00 00	 call	 s390_GetCCE
  00fc2	0f b6 c0	 movzx	 eax, al
  00fc5	85 c0		 test	 eax, eax
  00fc7	75 0d		 jne	 SHORT $LN137@s390_cmpsc
  00fc9	c7 84 24 a8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv696[rsp], 1
  00fd4	eb 0b		 jmp	 SHORT $LN138@s390_cmpsc
$LN137@s390_cmpsc:
  00fd6	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv696[rsp], 0
$LN138@s390_cmpsc:
  00fe1	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR tv696[rsp], 0
  00fe9	74 0d		 je	 SHORT $LN141@s390_cmpsc
  00feb	c7 84 24 ac 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv705[rsp], 1
  00ff6	eb 0b		 jmp	 SHORT $LN142@s390_cmpsc
$LN141@s390_cmpsc:
  00ff8	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv705[rsp], 0
$LN142@s390_cmpsc:
  01003	83 bc 24 ac 00
	00 00 00	 cmp	 DWORD PTR tv705[rsp], 0
  0100b	74 2e		 je	 SHORT $LN48@s390_cmpsc

; 1026 :     {
; 1027 :         PUTSETCBN();

  0100d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  01012	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  01016	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0101e	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 1028 :         RETERR( &op1blk );

  01021	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  01029	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01031	e8 00 00 00 00	 call	 s390_ERR
  01036	e9 99 06 00 00	 jmp	 $LN1@s390_cmpsc
$LN48@s390_cmpsc:

; 1029 :     }
; 1030 : 
; 1031 :     if (!child.act)

  0103b	0f b6 84 24 5f
	04 07 00	 movzx	 eax, BYTE PTR child$[rsp+23]
  01043	85 c0		 test	 eax, eax
  01045	75 05		 jne	 SHORT $LN49@s390_cmpsc

; 1032 :         goto cmp15;

  01047	e9 83 05 00 00	 jmp	 $cmp15$191
$LN49@s390_cmpsc:

; 1033 : 
; 1034 :     // (compare SRC chars after next char to AEC's in child)...
; 1035 : 
; 1036 :     // Enough SRC chars for comparison?
; 1037 :     // No, goto cmp11;
; 1038 : 
; 1039 :     if (unlikely( pCMPSCBLK->nLen2 < (U64)(1 + child.act)))

  0104c	0f b6 84 24 5f
	04 07 00	 movzx	 eax, BYTE PTR child$[rsp+23]
  01054	ff c0		 inc	 eax
  01056	48 98		 cdqe
  01058	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01060	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  01064	73 0d		 jae	 SHORT $LN145@s390_cmpsc
  01066	c7 84 24 b0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv727[rsp], 1
  01071	eb 0b		 jmp	 SHORT $LN146@s390_cmpsc
$LN145@s390_cmpsc:
  01073	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv727[rsp], 0
$LN146@s390_cmpsc:
  0107e	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR tv727[rsp], 0
  01086	74 02		 je	 SHORT $LN50@s390_cmpsc

; 1040 :         goto cmp11;

  01088	eb 69		 jmp	 SHORT $cmp11$192
$LN50@s390_cmpsc:

; 1041 : 
; 1042 :     // Chars equal?
; 1043 :     // Yes, goto cmp16;
; 1044 : 
; 1045 :     fetch_op_str( wrk, child.act-1, pCMPSCBLK->pOp2 + 1, &op2blk );

  0108a	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  01092	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  01096	48 ff c0	 inc	 rax
  01099	0f b6 8c 24 5f
	04 07 00	 movzx	 ecx, BYTE PTR child$[rsp+23]
  010a1	ff c9		 dec	 ecx
  010a3	4c 8d 8c 24 20
	01 00 00	 lea	 r9, QWORD PTR op2blk$[rsp]
  010ab	44 8b c0	 mov	 r8d, eax
  010ae	0f b7 d1	 movzx	 edx, cx
  010b1	48 8d 8c 24 70
	04 07 00	 lea	 rcx, QWORD PTR wrk$[rsp]
  010b9	e8 00 00 00 00	 call	 s390_cmpsc_vfetchc

; 1046 : 
; 1047 :     if (memcmp( wrk, &child.ec[0], child.act ) == 0)

  010be	0f b6 84 24 5f
	04 07 00	 movzx	 eax, BYTE PTR child$[rsp+23]
  010c6	b9 01 00 00 00	 mov	 ecx, 1
  010cb	48 6b c9 00	 imul	 rcx, rcx, 0
  010cf	48 8d 8c 0c 48
	04 07 00	 lea	 rcx, QWORD PTR child$[rsp+rcx]
  010d7	44 8b c0	 mov	 r8d, eax
  010da	48 8b d1	 mov	 rdx, rcx
  010dd	48 8d 8c 24 70
	04 07 00	 lea	 rcx, QWORD PTR wrk$[rsp]
  010e5	e8 00 00 00 00	 call	 memcmp
  010ea	85 c0		 test	 eax, eax
  010ec	75 05		 jne	 SHORT $LN51@s390_cmpsc

; 1048 :         goto cmp16;

  010ee	e9 4b 05 00 00	 jmp	 $cmp16$193
$LN51@s390_cmpsc:
$cmp11$192:

; 1049 : 
; 1050 : cmp11:
; 1051 : 
; 1052 :     // Flag=1?
; 1053 :     // No, goto cmp8;
; 1054 : 
; 1055 :     if (!flag)

  010f3	0f b6 44 24 31	 movzx	 eax, BYTE PTR flag$[rsp]
  010f8	85 c0		 test	 eax, eax
  010fa	75 05		 jne	 SHORT $LN52@s390_cmpsc

; 1056 :         goto cmp8;

  010fc	e9 97 fb ff ff	 jmp	 $cmp8$186
$LN52@s390_cmpsc:

; 1057 : 
; 1058 :     // Another CC?
; 1059 :     // No, goto cmp8;
; 1060 : 
; 1061 :     if (++ccnum >= parent.cct)

  01101	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  01106	fe c0		 inc	 al
  01108	88 44 24 21	 mov	 BYTE PTR ccnum$[rsp], al
  0110c	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  01111	0f b6 8c 24 3e
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+22]
  01119	3b c1		 cmp	 eax, ecx
  0111b	7c 05		 jl	 SHORT $LN53@s390_cmpsc

; 1062 :         goto cmp8;

  0111d	e9 76 fb ff ff	 jmp	 $cmp8$186
$LN53@s390_cmpsc:

; 1063 : 
; 1064 :     // goto cmp5;
; 1065 : 
; 1066 :     goto cmp5;

  01122	e9 e5 f6 ff ff	 jmp	 $LN175@s390_cmpsc
$cmp12$188:

; 1067 : 
; 1068 : cmp12:
; 1069 : 
; 1070 :     if (unlikely( ++children > MAX_CHILDREN ))

  01127	0f b7 44 24 2c	 movzx	 eax, WORD PTR children$[rsp]
  0112c	66 ff c0	 inc	 ax
  0112f	66 89 44 24 2c	 mov	 WORD PTR children$[rsp], ax
  01134	0f b7 44 24 2c	 movzx	 eax, WORD PTR children$[rsp]
  01139	3d 04 01 00 00	 cmp	 eax, 260		; 00000104H
  0113e	7e 0d		 jle	 SHORT $LN149@s390_cmpsc
  01140	c7 84 24 b4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv795[rsp], 1
  0114b	eb 0b		 jmp	 SHORT $LN150@s390_cmpsc
$LN149@s390_cmpsc:
  0114d	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv795[rsp], 0
$LN150@s390_cmpsc:
  01158	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR tv795[rsp], 0
  01160	74 2e		 je	 SHORT $LN54@s390_cmpsc

; 1071 :     {
; 1072 :         PUTSETCBN();

  01162	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  01167	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  0116b	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01173	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 1073 :         RETERR( &op1blk );

  01176	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  0117e	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01186	e8 00 00 00 00	 call	 s390_ERR
  0118b	e9 44 05 00 00	 jmp	 $LN1@s390_cmpsc
$LN54@s390_cmpsc:

; 1074 :     }
; 1075 : 
; 1076 :     // Set child index = SD index + SC number (1-origin numbering).
; 1077 : 
; 1078 :     child_index = sibling_index + (scnum + 1);

  01190	0f b7 44 24 34	 movzx	 eax, WORD PTR sibling_index$[rsp]
  01195	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR scnum$[rsp]
  0119a	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  0119e	66 89 44 24 28	 mov	 WORD PTR child_index$[rsp], ax

; 1079 : 
; 1080 :     // Y=1 for child or no Y?
; 1081 :     // No, goto cmp14;
; 1082 : 
; 1083 :     if (!(sibling.ecb & (0x8000 >> scnum)))

  011a3	0f b7 84 24 20
	04 07 00	 movzx	 eax, WORD PTR sibling$[rsp+16]
  011ab	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR scnum$[rsp]
  011b0	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  011b5	d3 fa		 sar	 edx, cl
  011b7	8b ca		 mov	 ecx, edx
  011b9	23 c1		 and	 eax, ecx
  011bb	85 c0		 test	 eax, eax
  011bd	75 05		 jne	 SHORT $LN55@s390_cmpsc

; 1084 :         goto cmp14;

  011bf	e9 93 02 00 00	 jmp	 $cmp14$190
$LN55@s390_cmpsc:

; 1085 : 
; 1086 :     // ACT=0 or D=0 in child?
; 1087 :     // Yes, goto cmp15;
; 1088 : 
; 1089 :     cceblk.pCCE = &child;

  011c4	48 8d 84 24 48
	04 07 00	 lea	 rax, QWORD PTR child$[rsp]
  011cc	48 89 84 24 d8
	03 00 00	 mov	 QWORD PTR cceblk$[rsp+8], rax

; 1090 :     if (unlikely( !ARCH_DEP( GetCCE )( child_index, &cceblk )))

  011d4	48 8d 94 24 d0
	03 00 00	 lea	 rdx, QWORD PTR cceblk$[rsp]
  011dc	0f b7 4c 24 28	 movzx	 ecx, WORD PTR child_index$[rsp]
  011e1	e8 00 00 00 00	 call	 s390_GetCCE
  011e6	0f b6 c0	 movzx	 eax, al
  011e9	85 c0		 test	 eax, eax
  011eb	75 0d		 jne	 SHORT $LN151@s390_cmpsc
  011ed	c7 84 24 b8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv818[rsp], 1
  011f8	eb 0b		 jmp	 SHORT $LN152@s390_cmpsc
$LN151@s390_cmpsc:
  011fa	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv818[rsp], 0
$LN152@s390_cmpsc:
  01205	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR tv818[rsp], 0
  0120d	74 0d		 je	 SHORT $LN155@s390_cmpsc
  0120f	c7 84 24 bc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv827[rsp], 1
  0121a	eb 0b		 jmp	 SHORT $LN156@s390_cmpsc
$LN155@s390_cmpsc:
  0121c	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv827[rsp], 0
$LN156@s390_cmpsc:
  01227	83 bc 24 bc 00
	00 00 00	 cmp	 DWORD PTR tv827[rsp], 0
  0122f	74 2e		 je	 SHORT $LN56@s390_cmpsc

; 1091 :     {
; 1092 :         PUTSETCBN();

  01231	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  01236	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  0123a	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01242	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 1093 :         RETERR( &op1blk );

  01245	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  0124d	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01255	e8 00 00 00 00	 call	 s390_ERR
  0125a	e9 75 04 00 00	 jmp	 $LN1@s390_cmpsc
$LN56@s390_cmpsc:

; 1094 :     }
; 1095 : 
; 1096 :     if (!child.act)

  0125f	0f b6 84 24 5f
	04 07 00	 movzx	 eax, BYTE PTR child$[rsp+23]
  01267	85 c0		 test	 eax, eax
  01269	75 05		 jne	 SHORT $LN57@s390_cmpsc

; 1097 :         goto cmp15;

  0126b	e9 5f 03 00 00	 jmp	 $cmp15$191
$LN57@s390_cmpsc:

; 1098 : 
; 1099 :     // (compare SRC chars after next char to AEC's in child)...
; 1100 : 
; 1101 :     // Enough SRC chars for comparison?
; 1102 :     // No, goto cmp8;
; 1103 : 
; 1104 :     if (pCMPSCBLK->nLen2 < (U64)(1 + child.act))

  01270	0f b6 84 24 5f
	04 07 00	 movzx	 eax, BYTE PTR child$[rsp+23]
  01278	ff c0		 inc	 eax
  0127a	48 98		 cdqe
  0127c	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01284	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  01288	73 05		 jae	 SHORT $LN58@s390_cmpsc

; 1105 :         goto cmp8;

  0128a	e9 09 fa ff ff	 jmp	 $cmp8$186
$LN58@s390_cmpsc:

; 1106 : 
; 1107 :     // Chars equal?
; 1108 :     // Yes, goto cmp16;
; 1109 : 
; 1110 :     fetch_op_str( wrk, child.act-1, pCMPSCBLK->pOp2 + 1, &op2blk );

  0128f	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  01297	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0129b	48 ff c0	 inc	 rax
  0129e	0f b6 8c 24 5f
	04 07 00	 movzx	 ecx, BYTE PTR child$[rsp+23]
  012a6	ff c9		 dec	 ecx
  012a8	4c 8d 8c 24 20
	01 00 00	 lea	 r9, QWORD PTR op2blk$[rsp]
  012b0	44 8b c0	 mov	 r8d, eax
  012b3	0f b7 d1	 movzx	 edx, cx
  012b6	48 8d 8c 24 70
	04 07 00	 lea	 rcx, QWORD PTR wrk$[rsp]
  012be	e8 00 00 00 00	 call	 s390_cmpsc_vfetchc

; 1111 : 
; 1112 :     if (memcmp( wrk, &child.ec[0], child.act ) == 0)

  012c3	0f b6 84 24 5f
	04 07 00	 movzx	 eax, BYTE PTR child$[rsp+23]
  012cb	b9 01 00 00 00	 mov	 ecx, 1
  012d0	48 6b c9 00	 imul	 rcx, rcx, 0
  012d4	48 8d 8c 0c 48
	04 07 00	 lea	 rcx, QWORD PTR child$[rsp+rcx]
  012dc	44 8b c0	 mov	 r8d, eax
  012df	48 8b d1	 mov	 rdx, rcx
  012e2	48 8d 8c 24 70
	04 07 00	 lea	 rcx, QWORD PTR wrk$[rsp]
  012ea	e8 00 00 00 00	 call	 memcmp
  012ef	85 c0		 test	 eax, eax
  012f1	75 05		 jne	 SHORT $LN59@s390_cmpsc

; 1113 :         goto cmp16;

  012f3	e9 46 03 00 00	 jmp	 $cmp16$193
$LN59@s390_cmpsc:

; 1114 : 
; 1115 :     // goto cmp8;
; 1116 : 
; 1117 :     goto cmp8;

  012f8	e9 9b f9 ff ff	 jmp	 $cmp8$186
$cmp13$182:

; 1118 : 
; 1119 : cmp13:
; 1120 : 
; 1121 :     // Store parent index in DST.
; 1122 :     // Advance 1 index in DST;
; 1123 :     // Set CC0 and endop.
; 1124 : 
; 1125 :     if (unlikely( (pCMPSCBLK->pOp2 - pBegOp2) > MAX_SYMLEN ))

  012fd	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  01305	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pBegOp2$[rsp]
  0130a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0130e	48 2b c1	 sub	 rax, rcx
  01311	48 3d 04 01 00
	00		 cmp	 rax, 260		; 00000104H
  01317	76 0d		 jbe	 SHORT $LN159@s390_cmpsc
  01319	c7 84 24 c0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv870[rsp], 1
  01324	eb 0b		 jmp	 SHORT $LN160@s390_cmpsc
$LN159@s390_cmpsc:
  01326	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv870[rsp], 0
$LN160@s390_cmpsc:
  01331	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR tv870[rsp], 0
  01339	74 2e		 je	 SHORT $LN60@s390_cmpsc

; 1126 :     {
; 1127 :         PUTSETCBN();

  0133b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  01340	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  01344	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0134c	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 1128 :         RETERR( &op1blk );

  0134f	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  01357	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0135f	e8 00 00 00 00	 call	 s390_ERR
  01364	e9 6b 03 00 00	 jmp	 $LN1@s390_cmpsc
$LN60@s390_cmpsc:

; 1129 :     }
; 1130 :     pBegOp2  =  pCMPSCBLK->pOp2;

  01369	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  01371	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  01375	48 89 44 24 50	 mov	 QWORD PTR pBegOp2$[rsp], rax

; 1131 : 
; 1132 :     piblk.index = (!pCMPSCBLK->st) ? parent_index

  0137a	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  01382	0f b6 40 42	 movzx	 eax, BYTE PTR [rax+66]
  01386	85 c0		 test	 eax, eax
  01388	75 0d		 jne	 SHORT $LN161@s390_cmpsc
  0138a	c7 84 24 c4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv882[rsp], 1
  01395	eb 0b		 jmp	 SHORT $LN162@s390_cmpsc
$LN161@s390_cmpsc:
  01397	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv882[rsp], 0
$LN162@s390_cmpsc:
  013a2	83 bc 24 c4 00
	00 00 00	 cmp	 DWORD PTR tv882[rsp], 0
  013aa	74 0e		 je	 SHORT $LN163@s390_cmpsc
  013ac	0f b7 44 24 24	 movzx	 eax, WORD PTR parent_index$[rsp]
  013b1	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv901[rsp], eax
  013b8	eb 53		 jmp	 SHORT $LN164@s390_cmpsc
$LN163@s390_cmpsc:
  013ba	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  013c2	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  013c6	0f b7 4c 24 24	 movzx	 ecx, WORD PTR parent_index$[rsp]
  013cb	d1 e1		 shl	 ecx, 1
  013cd	48 63 c9	 movsxd	 rcx, ecx
  013d0	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR pSymTab$[rsp]
  013d8	48 03 d1	 add	 rdx, rcx
  013db	48 8b ca	 mov	 rcx, rdx
  013de	48 8b 94 24 b0
	05 07 00	 mov	 rdx, QWORD PTR pCMPSCBLK$[rsp]
  013e6	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  013ea	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  013f0	48 8b 94 24 b0
	05 07 00	 mov	 rdx, QWORD PTR pCMPSCBLK$[rsp]
  013f8	4c 8b 42 18	 mov	 r8, QWORD PTR [rdx+24]
  013fc	8b d0		 mov	 edx, eax
  013fe	e8 00 00 00 00	 call	 s390_vfetch2
  01403	0f b7 c0	 movzx	 eax, ax
  01406	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv901[rsp], eax
$LN164@s390_cmpsc:
  0140d	0f b7 84 24 c8
	00 00 00	 movzx	 eax, WORD PTR tv901[rsp]
  01415	66 89 84 24 78
	01 00 00	 mov	 WORD PTR piblk$[rsp+24], ax

; 1133 :           : fetch_dct_hw( pSymTab + (parent_index << 1), pCMPSCBLK );
; 1134 :     pPutIndex( &piblk );

  0141d	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR piblk$[rsp]
  01425	ff 54 24 38	 call	 QWORD PTR pPutIndex$[rsp]

; 1135 :     PUTSETCBN();

  01429	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  0142e	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  01432	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0143a	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 1136 :     RETCC0( &op1blk );

  0143d	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  01445	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0144d	e8 00 00 00 00	 call	 s390_CC0
  01452	e9 7d 02 00 00	 jmp	 $LN1@s390_cmpsc
$cmp14$190:

; 1137 : 
; 1138 : cmp14:
; 1139 : 
; 1140 :     // Store child index in DST.
; 1141 :     // Advance 1 index in DST.
; 1142 :     // Advance 1 byte in SRC.
; 1143 :     // goto cmp1;
; 1144 : 
; 1145 :     nCPUAmt++;

  01457	48 8b 44 24 48	 mov	 rax, QWORD PTR nCPUAmt$[rsp]
  0145c	48 ff c0	 inc	 rax
  0145f	48 89 44 24 48	 mov	 QWORD PTR nCPUAmt$[rsp], rax

; 1146 :     pCMPSCBLK->pOp2++;

  01464	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0146c	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  01470	48 ff c0	 inc	 rax
  01473	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0147b	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1147 :     pCMPSCBLK->nLen2--;

  0147f	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  01487	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0148b	48 ff c8	 dec	 rax
  0148e	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01496	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1148 : 
; 1149 :     if (unlikely( (pCMPSCBLK->pOp2 - pBegOp2) > MAX_SYMLEN ))

  0149a	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  014a2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pBegOp2$[rsp]
  014a7	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  014ab	48 2b c1	 sub	 rax, rcx
  014ae	48 3d 04 01 00
	00		 cmp	 rax, 260		; 00000104H
  014b4	76 0d		 jbe	 SHORT $LN167@s390_cmpsc
  014b6	c7 84 24 cc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv927[rsp], 1
  014c1	eb 0b		 jmp	 SHORT $LN168@s390_cmpsc
$LN167@s390_cmpsc:
  014c3	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv927[rsp], 0
$LN168@s390_cmpsc:
  014ce	83 bc 24 cc 00
	00 00 00	 cmp	 DWORD PTR tv927[rsp], 0
  014d6	74 2e		 je	 SHORT $LN61@s390_cmpsc

; 1150 :     {
; 1151 :         PUTSETCBN();

  014d8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  014dd	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  014e1	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  014e9	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 1152 :         RETERR( &op1blk );

  014ec	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  014f4	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  014fc	e8 00 00 00 00	 call	 s390_ERR
  01501	e9 ce 01 00 00	 jmp	 $LN1@s390_cmpsc
$LN61@s390_cmpsc:

; 1153 :     }
; 1154 :     pBegOp2  =  pCMPSCBLK->pOp2;

  01506	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0150e	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  01512	48 89 44 24 50	 mov	 QWORD PTR pBegOp2$[rsp], rax

; 1155 : 
; 1156 :     piblk.index = (!pCMPSCBLK->st) ? child_index

  01517	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0151f	0f b6 40 42	 movzx	 eax, BYTE PTR [rax+66]
  01523	85 c0		 test	 eax, eax
  01525	75 0d		 jne	 SHORT $LN169@s390_cmpsc
  01527	c7 84 24 d0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv939[rsp], 1
  01532	eb 0b		 jmp	 SHORT $LN170@s390_cmpsc
$LN169@s390_cmpsc:
  01534	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv939[rsp], 0
$LN170@s390_cmpsc:
  0153f	83 bc 24 d0 00
	00 00 00	 cmp	 DWORD PTR tv939[rsp], 0
  01547	74 0e		 je	 SHORT $LN171@s390_cmpsc
  01549	0f b7 44 24 28	 movzx	 eax, WORD PTR child_index$[rsp]
  0154e	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv958[rsp], eax
  01555	eb 53		 jmp	 SHORT $LN172@s390_cmpsc
$LN171@s390_cmpsc:
  01557	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0155f	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  01563	0f b7 4c 24 28	 movzx	 ecx, WORD PTR child_index$[rsp]
  01568	d1 e1		 shl	 ecx, 1
  0156a	48 63 c9	 movsxd	 rcx, ecx
  0156d	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR pSymTab$[rsp]
  01575	48 03 d1	 add	 rdx, rcx
  01578	48 8b ca	 mov	 rcx, rdx
  0157b	48 8b 94 24 b0
	05 07 00	 mov	 rdx, QWORD PTR pCMPSCBLK$[rsp]
  01583	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  01587	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  0158d	48 8b 94 24 b0
	05 07 00	 mov	 rdx, QWORD PTR pCMPSCBLK$[rsp]
  01595	4c 8b 42 18	 mov	 r8, QWORD PTR [rdx+24]
  01599	8b d0		 mov	 edx, eax
  0159b	e8 00 00 00 00	 call	 s390_vfetch2
  015a0	0f b7 c0	 movzx	 eax, ax
  015a3	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv958[rsp], eax
$LN172@s390_cmpsc:
  015aa	0f b7 84 24 d4
	00 00 00	 movzx	 eax, WORD PTR tv958[rsp]
  015b2	66 89 84 24 78
	01 00 00	 mov	 WORD PTR piblk$[rsp+24], ax

; 1157 :           : fetch_dct_hw( pSymTab + (child_index << 1), pCMPSCBLK );
; 1158 :     eodst = pPutIndex( &piblk );

  015ba	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR piblk$[rsp]
  015c2	ff 54 24 38	 call	 QWORD PTR pPutIndex$[rsp]
  015c6	88 44 24 23	 mov	 BYTE PTR eodst$[rsp], al

; 1159 :     goto cmp1;

  015ca	e9 a7 ee ff ff	 jmp	 $LN173@s390_cmpsc
$cmp15$191:

; 1160 : 
; 1161 : cmp15:
; 1162 : 
; 1163 :     // Call child the parent.
; 1164 :     // Advance 1 byte in SRC.
; 1165 :     // goto cmp3;
; 1166 : 
; 1167 :     parent       = child;

  015cf	48 8d 84 24 28
	04 07 00	 lea	 rax, QWORD PTR parent$[rsp]
  015d7	48 8d 8c 24 48
	04 07 00	 lea	 rcx, QWORD PTR child$[rsp]
  015df	48 8b f8	 mov	 rdi, rax
  015e2	48 8b f1	 mov	 rsi, rcx
  015e5	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  015ea	f3 a4		 rep movsb

; 1168 :     parent_index = child_index;

  015ec	0f b7 44 24 28	 movzx	 eax, WORD PTR child_index$[rsp]
  015f1	66 89 44 24 24	 mov	 WORD PTR parent_index$[rsp], ax

; 1169 : 
; 1170 :     nCPUAmt++;

  015f6	48 8b 44 24 48	 mov	 rax, QWORD PTR nCPUAmt$[rsp]
  015fb	48 ff c0	 inc	 rax
  015fe	48 89 44 24 48	 mov	 QWORD PTR nCPUAmt$[rsp], rax

; 1171 :     pCMPSCBLK->pOp2++;

  01603	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0160b	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0160f	48 ff c0	 inc	 rax
  01612	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0161a	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1172 :     pCMPSCBLK->nLen2--;

  0161e	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  01626	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0162a	48 ff c8	 dec	 rax
  0162d	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01635	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1173 : 
; 1174 :     goto cmp3;

  01639	e9 55 f0 ff ff	 jmp	 $cmp3$180
$cmp16$193:

; 1175 : 
; 1176 : cmp16:
; 1177 : 
; 1178 :     // Call child the parent.
; 1179 :     // Advance in SRC by 1 + #of AEC bytes.
; 1180 :     // goto cmp3;
; 1181 : 
; 1182 :     parent       = child;

  0163e	48 8d 84 24 28
	04 07 00	 lea	 rax, QWORD PTR parent$[rsp]
  01646	48 8d 8c 24 48
	04 07 00	 lea	 rcx, QWORD PTR child$[rsp]
  0164e	48 8b f8	 mov	 rdi, rax
  01651	48 8b f1	 mov	 rsi, rcx
  01654	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01659	f3 a4		 rep movsb

; 1183 :     parent_index = child_index;

  0165b	0f b7 44 24 28	 movzx	 eax, WORD PTR child_index$[rsp]
  01660	66 89 44 24 24	 mov	 WORD PTR parent_index$[rsp], ax

; 1184 : 
; 1185 :     nCPUAmt           += 1 + child.act;

  01665	0f b6 84 24 5f
	04 07 00	 movzx	 eax, BYTE PTR child$[rsp+23]
  0166d	ff c0		 inc	 eax
  0166f	48 98		 cdqe
  01671	48 8b 4c 24 48	 mov	 rcx, QWORD PTR nCPUAmt$[rsp]
  01676	48 03 c8	 add	 rcx, rax
  01679	48 8b c1	 mov	 rax, rcx
  0167c	48 89 44 24 48	 mov	 QWORD PTR nCPUAmt$[rsp], rax

; 1186 :     pCMPSCBLK->pOp2   += 1 + child.act;

  01681	0f b6 84 24 5f
	04 07 00	 movzx	 eax, BYTE PTR child$[rsp+23]
  01689	ff c0		 inc	 eax
  0168b	48 98		 cdqe
  0168d	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01695	48 03 41 28	 add	 rax, QWORD PTR [rcx+40]
  01699	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  016a1	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1187 :     pCMPSCBLK->nLen2  -= 1 + child.act;

  016a5	0f b6 84 24 5f
	04 07 00	 movzx	 eax, BYTE PTR child$[rsp+23]
  016ad	ff c0		 inc	 eax
  016af	48 98		 cdqe
  016b1	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  016b9	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  016bd	48 2b c8	 sub	 rcx, rax
  016c0	48 8b c1	 mov	 rax, rcx
  016c3	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  016cb	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1188 : 
; 1189 :     goto cmp3;

  016cf	e9 bf ef ff ff	 jmp	 $LN174@s390_cmpsc
$LN1@s390_cmpsc:

; 1190 : }

  016d4	48 8b 8c 24 80
	05 07 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  016dc	48 33 cc	 xor	 rcx, rsp
  016df	e8 00 00 00 00	 call	 __security_check_cookie
  016e4	48 81 c4 98 05
	07 00		 add	 rsp, 460184		; 00070598H
  016eb	5f		 pop	 rdi
  016ec	5e		 pop	 rsi
  016ed	c3		 ret	 0
s390_cmpsc_Compress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
i$1 = 32
bits$ = 33
nCPUAmt$ = 40
tv155 = 48
tv195 = 52
tv207 = 56
tv216 = 60
tv242 = 64
tv268 = 68
tv318 = 72
tv358 = 76
tv378 = 80
tv399 = 84
tv408 = 88
tv447 = 92
tv487 = 96
tv495 = 100
tv507 = 104
tv516 = 108
tv542 = 112
tv568 = 116
tv642 = 120
pGetIndex$ = 128
ppGetIndex$ = 136
ppGet8Index$2 = 144
pGet8Index$3 = 152
giblk$ = 160
save_op1blk$4 = 192
save_op2blk$5 = 232
save_cmpsc$6 = 272
expblk$ = 352
index$ = 197376
__$ArrayPad$ = 197392
pCMPSCBLK$ = 197440
s390_cmpsc_Expand PROC

; 258  : {

$LN105:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	b8 28 03 03 00	 mov	 eax, 197416		; 00030328H
  0000c	e8 00 00 00 00	 call	 __chkstk
  00011	48 2b e0	 sub	 rsp, rax
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 10
	03 03 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 259  :     U64         nCPUAmt;        // CPU determined processing limit
; 260  :     GetIndex**  ppGetIndex;     // Ptr to GetNextIndex table for this CDSS-1
; 261  :     GetIndex*   pGetIndex;      // Ptr to GetNextIndex function for this CBN
; 262  :     GIBLK       giblk;          // GetIndex parameters block
; 263  :     EXPBLK      expblk;         // EXPAND Index Symbol parameters block
; 264  :     U16         index[8];       // SRC Index values
; 265  :     U8          bits;           // Number of bits per index
; 266  : 
; 267  :     nCPUAmt     = 0;

  00026	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR nCPUAmt$[rsp], 0

; 268  :     ppGetIndex  = ARCH_DEP( GetIndexCDSSTab  )[ pCMPSCBLK->cdss - 1 ];

  0002f	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00037	0f b6 40 44	 movzx	 eax, BYTE PTR [rax+68]
  0003b	ff c8		 dec	 eax
  0003d	48 98		 cdqe
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:s390_GetIndexCDSSTab
  00046	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0004a	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR ppGetIndex$[rsp], rax

; 269  :     pGetIndex   = ppGetIndex [ pCMPSCBLK->cbn ];

  00052	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0005a	0f b6 40 45	 movzx	 eax, BYTE PTR [rax+69]
  0005e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ppGetIndex$[rsp]
  00066	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0006a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pGetIndex$[rsp], rax

; 270  :     bits        = pCMPSCBLK->cdss + 8;

  00072	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0007a	0f b6 40 44	 movzx	 eax, BYTE PTR [rax+68]
  0007e	83 c0 08	 add	 eax, 8
  00081	88 44 24 21	 mov	 BYTE PTR bits$[rsp], al

; 271  : 
; 272  :     // Initialize GetIndex parameters block
; 273  : 
; 274  :     memset( &giblk, 0, sizeof( giblk ));

  00085	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR giblk$[rsp]
  0008d	48 8b f8	 mov	 rdi, rax
  00090	33 c0		 xor	 eax, eax
  00092	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00097	f3 aa		 rep stosb

; 275  : 
; 276  :     giblk.pCMPSCBLK   =  pCMPSCBLK;

  00099	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  000a1	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR giblk$[rsp], rax

; 277  :     giblk.pMEMBLK     =  &expblk.op2blk;    // (we get indexes from op-2)

  000a9	48 8d 84 24 c0
	02 03 00	 lea	 rax, QWORD PTR expblk$[rsp+196960]
  000b1	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR giblk$[rsp+8], rax

; 278  :     giblk.pIndex      =  &index[0];

  000b9	b8 02 00 00 00	 mov	 eax, 2
  000be	48 6b c0 00	 imul	 rax, rax, 0
  000c2	48 8d 84 04 00
	03 03 00	 lea	 rax, QWORD PTR index$[rsp+rax]
  000ca	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR giblk$[rsp+16], rax

; 279  :     giblk.ppGetIndex  =  (void**) &pGetIndex;

  000d2	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR pGetIndex$[rsp]
  000da	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR giblk$[rsp+24], rax

; 280  : 
; 281  :     // Initialize EXPAND Index Symbol parameters block
; 282  : 
; 283  :     memset( &expblk, 0, sizeof( expblk ));

  000e2	48 8d 84 24 60
	01 00 00	 lea	 rax, QWORD PTR expblk$[rsp]
  000ea	48 8b f8	 mov	 rdi, rax
  000ed	33 c0		 xor	 eax, eax
  000ef	b9 a0 01 03 00	 mov	 ecx, 197024		; 000301a0H
  000f4	f3 aa		 rep stosb

; 284  : 
; 285  :     expblk.dctblk.regs      = pCMPSCBLK->regs;

  000f6	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  000fe	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00102	48 89 84 24 68
	01 01 00	 mov	 QWORD PTR expblk$[rsp+65544], rax

; 286  :     expblk.dctblk.arn       = pCMPSCBLK->r2;

  0010a	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00112	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  00116	89 84 24 78 02
	01 00		 mov	 DWORD PTR expblk$[rsp+65816], eax

; 287  :     expblk.dctblk.pkey      = pCMPSCBLK->regs->psw.pkey;

  0011d	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00125	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00129	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0012d	88 84 24 7c 02
	01 00		 mov	 BYTE PTR expblk$[rsp+65820], al

; 288  :     expblk.dctblk.pDict     = pCMPSCBLK->pDict;

  00134	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0013c	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00140	48 89 84 24 70
	01 01 00	 mov	 QWORD PTR expblk$[rsp+65552], rax

; 289  : 
; 290  :     expblk.eceblk.pDCTBLK   = &expblk.dctblk;

  00148	48 8d 84 24 68
	01 01 00	 lea	 rax, QWORD PTR expblk$[rsp+65544]
  00150	48 89 84 24 80
	02 01 00	 mov	 QWORD PTR expblk$[rsp+65824], rax

; 291  :     expblk.eceblk.max_index = 0xFFFF >> (16 - bits);

  00158	0f b6 44 24 21	 movzx	 eax, BYTE PTR bits$[rsp]
  0015d	b9 10 00 00 00	 mov	 ecx, 16
  00162	2b c8		 sub	 ecx, eax
  00164	8b c1		 mov	 eax, ecx
  00166	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0016b	89 4c 24 78	 mov	 DWORD PTR tv642[rsp], ecx
  0016f	0f b6 c8	 movzx	 ecx, al
  00172	8b 44 24 78	 mov	 eax, DWORD PTR tv642[rsp]
  00176	d3 f8		 sar	 eax, cl
  00178	66 89 84 24 90
	02 01 00	 mov	 WORD PTR expblk$[rsp+65840], ax

; 292  :     expblk.eceblk.pECE      = &expblk.ece;

  00180	48 8d 84 24 e8
	02 03 00	 lea	 rax, QWORD PTR expblk$[rsp+197000]
  00188	48 89 84 24 88
	02 01 00	 mov	 QWORD PTR expblk$[rsp+65832], rax

; 293  : 
; 294  :     expblk.op1blk.arn       = pCMPSCBLK->r1;

  00190	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00198	0f b6 40 40	 movzx	 eax, BYTE PTR [rax+64]
  0019c	89 84 24 b8 02
	03 00		 mov	 DWORD PTR expblk$[rsp+196952], eax

; 295  :     expblk.op1blk.regs      = pCMPSCBLK->regs;

  001a3	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  001ab	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001af	48 89 84 24 98
	02 03 00	 mov	 QWORD PTR expblk$[rsp+196920], rax

; 296  :     expblk.op1blk.pkey      = pCMPSCBLK->regs->psw.pkey;

  001b7	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  001bf	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001c3	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  001c7	88 84 24 bc 02
	03 00		 mov	 BYTE PTR expblk$[rsp+196956], al

; 297  : 
; 298  :     expblk.op2blk.arn       = pCMPSCBLK->r2;

  001ce	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  001d6	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  001da	89 84 24 e0 02
	03 00		 mov	 DWORD PTR expblk$[rsp+196992], eax

; 299  :     expblk.op2blk.regs      = pCMPSCBLK->regs;

  001e1	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  001e9	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001ed	48 89 84 24 c0
	02 03 00	 mov	 QWORD PTR expblk$[rsp+196960], rax

; 300  :     expblk.op2blk.pkey      = pCMPSCBLK->regs->psw.pkey;

  001f5	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  001fd	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00201	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00205	88 84 24 e4 02
	03 00		 mov	 BYTE PTR expblk$[rsp+196996], al

; 301  : 
; 302  : #ifdef CMPSC_EXPAND8
; 303  : 
; 304  :     // Expand individual index symbols until CBN==0...
; 305  : 
; 306  :     if ((pCMPSCBLK->cbn & 7) != 0)

  0020c	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00214	0f b6 40 45	 movzx	 eax, BYTE PTR [rax+69]
  00218	83 e0 07	 and	 eax, 7
  0021b	85 c0		 test	 eax, eax
  0021d	0f 84 ee 02 00
	00		 je	 $LN29@s390_cmpsc
$LN2@s390_cmpsc:

; 307  :     {
; 308  :         while (nCPUAmt < (U64) pCMPSCBLK->nCPUAmt && (pCMPSCBLK->cbn & 7) != 0)

  00223	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0022b	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  0022e	48 39 44 24 28	 cmp	 QWORD PTR nCPUAmt$[rsp], rax
  00233	0f 83 d8 02 00
	00		 jae	 $LN3@s390_cmpsc
  00239	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00241	0f b6 40 45	 movzx	 eax, BYTE PTR [rax+69]
  00245	83 e0 07	 and	 eax, 7
  00248	85 c0		 test	 eax, eax
  0024a	0f 84 c1 02 00
	00		 je	 $LN3@s390_cmpsc

; 309  :         {
; 310  :             // Get index symbol...
; 311  : 
; 312  :             if (unlikely( !(expblk.SRC_bytes = pGetIndex( &giblk ))))

  00250	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR giblk$[rsp]
  00258	ff 94 24 80 00
	00 00		 call	 QWORD PTR pGetIndex$[rsp]
  0025f	88 84 24 fc 02
	03 00		 mov	 BYTE PTR expblk$[rsp+197020], al
  00266	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  0026e	85 c0		 test	 eax, eax
  00270	75 0a		 jne	 SHORT $LN45@s390_cmpsc
  00272	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv155[rsp], 1
  0027a	eb 08		 jmp	 SHORT $LN46@s390_cmpsc
$LN45@s390_cmpsc:
  0027c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv155[rsp], 0
$LN46@s390_cmpsc:
  00284	83 7c 24 30 00	 cmp	 DWORD PTR tv155[rsp], 0
  00289	74 0a		 je	 SHORT $LN49@s390_cmpsc
  0028b	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv195[rsp], 1
  00293	eb 08		 jmp	 SHORT $LN50@s390_cmpsc
$LN49@s390_cmpsc:
  00295	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv195[rsp], 0
$LN50@s390_cmpsc:
  0029d	83 7c 24 34 00	 cmp	 DWORD PTR tv195[rsp], 0
  002a2	74 1a		 je	 SHORT $LN30@s390_cmpsc

; 313  :                 RETCC0( &expblk.op1blk );

  002a4	48 8d 94 24 98
	02 03 00	 lea	 rdx, QWORD PTR expblk$[rsp+196920]
  002ac	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  002b4	e8 00 00 00 00	 call	 s390_CC0
  002b9	e9 59 09 00 00	 jmp	 $LN1@s390_cmpsc
$LN30@s390_cmpsc:

; 314  : 
; 315  :             // Expand it...
; 316  : 
; 317  :             expblk.index = index[0];

  002be	b8 02 00 00 00	 mov	 eax, 2
  002c3	48 6b c0 00	 imul	 rax, rax, 0
  002c7	0f b7 84 04 00
	03 03 00	 movzx	 eax, WORD PTR index$[rsp+rax]
  002cf	66 89 84 24 fa
	02 03 00	 mov	 WORD PTR expblk$[rsp+197018], ax

; 318  : 
; 319  :             if (unlikely( !ARCH_DEP( cmpsc_Expand_Index )( pCMPSCBLK, &expblk )))

  002d7	48 8d 94 24 60
	01 00 00	 lea	 rdx, QWORD PTR expblk$[rsp]
  002df	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  002e7	e8 00 00 00 00	 call	 s390_cmpsc_Expand_Index
  002ec	0f b6 c0	 movzx	 eax, al
  002ef	85 c0		 test	 eax, eax
  002f1	75 0a		 jne	 SHORT $LN51@s390_cmpsc
  002f3	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv207[rsp], 1
  002fb	eb 08		 jmp	 SHORT $LN52@s390_cmpsc
$LN51@s390_cmpsc:
  002fd	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv207[rsp], 0
$LN52@s390_cmpsc:
  00305	83 7c 24 38 00	 cmp	 DWORD PTR tv207[rsp], 0
  0030a	74 0a		 je	 SHORT $LN55@s390_cmpsc
  0030c	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv216[rsp], 1
  00314	eb 08		 jmp	 SHORT $LN56@s390_cmpsc
$LN55@s390_cmpsc:
  00316	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv216[rsp], 0
$LN56@s390_cmpsc:
  0031e	83 7c 24 3c 00	 cmp	 DWORD PTR tv216[rsp], 0
  00323	74 0d		 je	 SHORT $LN31@s390_cmpsc

; 320  :                 return expblk.rc;

  00325	0f b6 84 24 fd
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197021]
  0032d	e9 e5 08 00 00	 jmp	 $LN1@s390_cmpsc
$LN31@s390_cmpsc:

; 321  : 
; 322  :             // Bump source...
; 323  : 
; 324  :             nCPUAmt          += expblk.SRC_bytes;

  00332	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  0033a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR nCPUAmt$[rsp]
  0033f	48 03 c8	 add	 rcx, rax
  00342	48 8b c1	 mov	 rax, rcx
  00345	48 89 44 24 28	 mov	 QWORD PTR nCPUAmt$[rsp], rax

; 325  :             pCMPSCBLK->pOp2  += expblk.SRC_bytes;

  0034a	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  00352	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0035a	48 03 41 28	 add	 rax, QWORD PTR [rcx+40]
  0035e	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00366	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 326  :             pCMPSCBLK->nLen2 -= expblk.SRC_bytes;

  0036a	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  00372	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0037a	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0037e	48 2b c8	 sub	 rcx, rax
  00381	48 8b c1	 mov	 rax, rcx
  00384	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0038c	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 327  :             pCMPSCBLK->cbn   += bits;

  00390	0f b6 44 24 21	 movzx	 eax, BYTE PTR bits$[rsp]
  00395	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0039d	0f b6 49 45	 movzx	 ecx, BYTE PTR [rcx+69]
  003a1	03 c8		 add	 ecx, eax
  003a3	8b c1		 mov	 eax, ecx
  003a5	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  003ad	88 41 45	 mov	 BYTE PTR [rcx+69], al
$LN6@s390_cmpsc:

; 328  : 
; 329  :             MEMBLK_BUMP( &expblk.op2blk, pCMPSCBLK->pOp2 );

  003b0	48 8b 84 24 c8
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196968]
  003b8	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  003be	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  003c6	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  003ca	73 0a		 jae	 SHORT $LN59@s390_cmpsc
  003cc	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv242[rsp], 1
  003d4	eb 08		 jmp	 SHORT $LN60@s390_cmpsc
$LN59@s390_cmpsc:
  003d6	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv242[rsp], 0
$LN60@s390_cmpsc:
  003de	83 7c 24 40 00	 cmp	 DWORD PTR tv242[rsp], 0
  003e3	75 4d		 jne	 SHORT $LN32@s390_cmpsc
  003e5	48 8b 84 24 c8
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196968]
  003ed	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  003f3	48 89 84 24 c8
	02 03 00	 mov	 QWORD PTR expblk$[rsp+196968], rax
  003fb	b8 08 00 00 00	 mov	 eax, 8
  00400	48 6b c0 01	 imul	 rax, rax, 1
  00404	b9 08 00 00 00	 mov	 ecx, 8
  00409	48 6b c9 00	 imul	 rcx, rcx, 0
  0040d	48 8b 84 04 d0
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+rax+196976]
  00415	48 89 84 0c d0
	02 03 00	 mov	 QWORD PTR expblk$[rsp+rcx+196976], rax
  0041d	b8 08 00 00 00	 mov	 eax, 8
  00422	48 6b c0 01	 imul	 rax, rax, 1
  00426	48 c7 84 04 d0
	02 03 00 00 00
	00 00		 mov	 QWORD PTR expblk$[rsp+rax+196976], 0
$LN32@s390_cmpsc:
  00432	33 c0		 xor	 eax, eax
  00434	85 c0		 test	 eax, eax
  00436	0f 85 74 ff ff
	ff		 jne	 $LN6@s390_cmpsc

; 330  : 
; 331  :             // Bump destination...
; 332  : 
; 333  :             pCMPSCBLK->pOp1  += expblk.symlen;

  0043c	0f b7 84 24 f8
	02 03 00	 movzx	 eax, WORD PTR expblk$[rsp+197016]
  00444	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0044c	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00450	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00458	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 334  :             pCMPSCBLK->nLen1 -= expblk.symlen;

  0045c	0f b7 84 24 f8
	02 03 00	 movzx	 eax, WORD PTR expblk$[rsp+197016]
  00464	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0046c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0046f	48 2b c8	 sub	 rcx, rax
  00472	48 8b c1	 mov	 rax, rcx
  00475	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0047d	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN9@s390_cmpsc:

; 335  : 
; 336  :             MEMBLK_BUMP( &expblk.op1blk, pCMPSCBLK->pOp1 );

  00480	48 8b 84 24 a0
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196928]
  00488	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  0048e	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00496	48 39 41 20	 cmp	 QWORD PTR [rcx+32], rax
  0049a	73 0a		 jae	 SHORT $LN63@s390_cmpsc
  0049c	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv268[rsp], 1
  004a4	eb 08		 jmp	 SHORT $LN64@s390_cmpsc
$LN63@s390_cmpsc:
  004a6	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv268[rsp], 0
$LN64@s390_cmpsc:
  004ae	83 7c 24 44 00	 cmp	 DWORD PTR tv268[rsp], 0
  004b3	75 4d		 jne	 SHORT $LN33@s390_cmpsc
  004b5	48 8b 84 24 a0
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196928]
  004bd	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  004c3	48 89 84 24 a0
	02 03 00	 mov	 QWORD PTR expblk$[rsp+196928], rax
  004cb	b8 08 00 00 00	 mov	 eax, 8
  004d0	48 6b c0 01	 imul	 rax, rax, 1
  004d4	b9 08 00 00 00	 mov	 ecx, 8
  004d9	48 6b c9 00	 imul	 rcx, rcx, 0
  004dd	48 8b 84 04 a8
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+rax+196936]
  004e5	48 89 84 0c a8
	02 03 00	 mov	 QWORD PTR expblk$[rsp+rcx+196936], rax
  004ed	b8 08 00 00 00	 mov	 eax, 8
  004f2	48 6b c0 01	 imul	 rax, rax, 1
  004f6	48 c7 84 04 a8
	02 03 00 00 00
	00 00		 mov	 QWORD PTR expblk$[rsp+rax+196936], 0
$LN33@s390_cmpsc:
  00502	33 c0		 xor	 eax, eax
  00504	85 c0		 test	 eax, eax
  00506	0f 85 74 ff ff
	ff		 jne	 $LN9@s390_cmpsc

; 337  :         }

  0050c	e9 12 fd ff ff	 jmp	 $LN2@s390_cmpsc
$LN3@s390_cmpsc:
$LN29@s390_cmpsc:

; 338  :     }
; 339  : 
; 340  :     // Now expand eight (8) index symbols at a time...
; 341  : 
; 342  :     if ((pCMPSCBLK->cbn & 7) == 0)

  00511	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00519	0f b6 40 45	 movzx	 eax, BYTE PTR [rax+69]
  0051d	83 e0 07	 and	 eax, 7
  00520	85 c0		 test	 eax, eax
  00522	0f 85 03 04 00
	00		 jne	 $LN34@s390_cmpsc

; 343  :     {
; 344  :         GetIndex**  ppGet8Index;    // Ptr to GetNext8Index table for this CDSS-1
; 345  :         GetIndex*   pGet8Index;     // Ptr to GetNext8Index function for this CBN
; 346  :         CMPSCBLK    save_cmpsc;     // Work context
; 347  :         MEMBLK      save_op1blk;    // Work context
; 348  :         MEMBLK      save_op2blk;    // Work context
; 349  :         U8          i;              // (work)
; 350  : 
; 351  :         ppGet8Index = ARCH_DEP( Get8IndexCDSSTab )[ pCMPSCBLK->cdss - 1 ];

  00528	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00530	0f b6 40 44	 movzx	 eax, BYTE PTR [rax+68]
  00534	ff c8		 dec	 eax
  00536	48 98		 cdqe
  00538	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:s390_Get8IndexCDSSTab
  0053f	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00543	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR ppGet8Index$2[rsp], rax

; 352  :         pGet8Index  = ppGet8Index[ 0 ]; // (always CBN==0)

  0054b	b8 08 00 00 00	 mov	 eax, 8
  00550	48 6b c0 00	 imul	 rax, rax, 0
  00554	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ppGet8Index$2[rsp]
  0055c	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00560	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pGet8Index$3[rsp], rax

; 353  : 
; 354  :         // Save context
; 355  : 
; 356  :         memcpy( &save_cmpsc,  pCMPSCBLK,      sizeof( CMPSCBLK ));

  00568	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR save_cmpsc$6[rsp]
  00570	48 8b f8	 mov	 rdi, rax
  00573	48 8b b4 24 40
	03 03 00	 mov	 rsi, QWORD PTR pCMPSCBLK$[rsp]
  0057b	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00580	f3 a4		 rep movsb

; 357  :         memcpy( &save_op1blk, &expblk.op1blk, sizeof( MEMBLK   ));

  00582	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR save_op1blk$4[rsp]
  0058a	48 8d 8c 24 98
	02 03 00	 lea	 rcx, QWORD PTR expblk$[rsp+196920]
  00592	48 8b f8	 mov	 rdi, rax
  00595	48 8b f1	 mov	 rsi, rcx
  00598	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  0059d	f3 a4		 rep movsb

; 358  :         memcpy( &save_op2blk, &expblk.op2blk, sizeof( MEMBLK   ));

  0059f	48 8d 84 24 e8
	00 00 00	 lea	 rax, QWORD PTR save_op2blk$5[rsp]
  005a7	48 8d 8c 24 c0
	02 03 00	 lea	 rcx, QWORD PTR expblk$[rsp+196960]
  005af	48 8b f8	 mov	 rdi, rax
  005b2	48 8b f1	 mov	 rsi, rcx
  005b5	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  005ba	f3 a4		 rep movsb
$LN10@s390_cmpsc:

; 359  : 
; 360  :         while (nCPUAmt < (U64) pCMPSCBLK->nCPUAmt)

  005bc	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  005c4	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  005c7	48 39 44 24 28	 cmp	 QWORD PTR nCPUAmt$[rsp], rax
  005cc	0f 83 59 03 00
	00		 jae	 $LN11@s390_cmpsc

; 361  :         {
; 362  :             // Retrieve 8 index symbols from operand-2...
; 363  : 
; 364  :             if (unlikely( !(expblk.SRC_bytes = pGet8Index( &giblk ))))

  005d2	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR giblk$[rsp]
  005da	ff 94 24 98 00
	00 00		 call	 QWORD PTR pGet8Index$3[rsp]
  005e1	88 84 24 fc 02
	03 00		 mov	 BYTE PTR expblk$[rsp+197020], al
  005e8	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  005f0	85 c0		 test	 eax, eax
  005f2	75 0a		 jne	 SHORT $LN65@s390_cmpsc
  005f4	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv318[rsp], 1
  005fc	eb 08		 jmp	 SHORT $LN66@s390_cmpsc
$LN65@s390_cmpsc:
  005fe	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv318[rsp], 0
$LN66@s390_cmpsc:
  00606	83 7c 24 48 00	 cmp	 DWORD PTR tv318[rsp], 0
  0060b	74 0a		 je	 SHORT $LN69@s390_cmpsc
  0060d	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv358[rsp], 1
  00615	eb 08		 jmp	 SHORT $LN70@s390_cmpsc
$LN69@s390_cmpsc:
  00617	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv358[rsp], 0
$LN70@s390_cmpsc:
  0061f	83 7c 24 4c 00	 cmp	 DWORD PTR tv358[rsp], 0
  00624	74 05		 je	 SHORT $LN35@s390_cmpsc

; 365  :                 break;

  00626	e9 00 03 00 00	 jmp	 $LN11@s390_cmpsc
$LN35@s390_cmpsc:

; 366  : 
; 367  :             // Bump source...
; 368  : 
; 369  :             nCPUAmt          += expblk.SRC_bytes;

  0062b	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  00633	48 8b 4c 24 28	 mov	 rcx, QWORD PTR nCPUAmt$[rsp]
  00638	48 03 c8	 add	 rcx, rax
  0063b	48 8b c1	 mov	 rax, rcx
  0063e	48 89 44 24 28	 mov	 QWORD PTR nCPUAmt$[rsp], rax

; 370  :             pCMPSCBLK->pOp2  += expblk.SRC_bytes;

  00643	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  0064b	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00653	48 03 41 28	 add	 rax, QWORD PTR [rcx+40]
  00657	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0065f	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 371  :             pCMPSCBLK->nLen2 -= expblk.SRC_bytes;

  00663	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  0066b	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00673	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00677	48 2b c8	 sub	 rcx, rax
  0067a	48 8b c1	 mov	 rax, rcx
  0067d	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00685	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
$LN14@s390_cmpsc:

; 372  : 
; 373  :             MEMBLK_BUMP( &expblk.op2blk, pCMPSCBLK->pOp2 );

  00689	48 8b 84 24 c8
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196968]
  00691	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00697	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0069f	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  006a3	73 0a		 jae	 SHORT $LN73@s390_cmpsc
  006a5	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv378[rsp], 1
  006ad	eb 08		 jmp	 SHORT $LN74@s390_cmpsc
$LN73@s390_cmpsc:
  006af	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv378[rsp], 0
$LN74@s390_cmpsc:
  006b7	83 7c 24 50 00	 cmp	 DWORD PTR tv378[rsp], 0
  006bc	75 4d		 jne	 SHORT $LN36@s390_cmpsc
  006be	48 8b 84 24 c8
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196968]
  006c6	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  006cc	48 89 84 24 c8
	02 03 00	 mov	 QWORD PTR expblk$[rsp+196968], rax
  006d4	b8 08 00 00 00	 mov	 eax, 8
  006d9	48 6b c0 01	 imul	 rax, rax, 1
  006dd	b9 08 00 00 00	 mov	 ecx, 8
  006e2	48 6b c9 00	 imul	 rcx, rcx, 0
  006e6	48 8b 84 04 d0
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+rax+196976]
  006ee	48 89 84 0c d0
	02 03 00	 mov	 QWORD PTR expblk$[rsp+rcx+196976], rax
  006f6	b8 08 00 00 00	 mov	 eax, 8
  006fb	48 6b c0 01	 imul	 rax, rax, 1
  006ff	48 c7 84 04 d0
	02 03 00 00 00
	00 00		 mov	 QWORD PTR expblk$[rsp+rax+196976], 0
$LN36@s390_cmpsc:
  0070b	33 c0		 xor	 eax, eax
  0070d	85 c0		 test	 eax, eax
  0070f	0f 85 74 ff ff
	ff		 jne	 $LN14@s390_cmpsc

; 374  : 
; 375  :             // Expand each of the 8 individually into operand-1...
; 376  : 
; 377  :             for (i=0; i < 8; i++)

  00715	c6 44 24 20 00	 mov	 BYTE PTR i$1[rsp], 0
  0071a	eb 0b		 jmp	 SHORT $LN17@s390_cmpsc
$LN15@s390_cmpsc:
  0071c	0f b6 44 24 20	 movzx	 eax, BYTE PTR i$1[rsp]
  00721	fe c0		 inc	 al
  00723	88 44 24 20	 mov	 BYTE PTR i$1[rsp], al
$LN17@s390_cmpsc:
  00727	0f b6 44 24 20	 movzx	 eax, BYTE PTR i$1[rsp]
  0072c	83 f8 08	 cmp	 eax, 8
  0072f	0f 8d 91 01 00
	00		 jge	 $LN16@s390_cmpsc

; 378  :             {
; 379  :                 expblk.index = index[i];

  00735	0f b6 44 24 20	 movzx	 eax, BYTE PTR i$1[rsp]
  0073a	0f b7 84 44 00
	03 03 00	 movzx	 eax, WORD PTR index$[rsp+rax*2]
  00742	66 89 84 24 fa
	02 03 00	 mov	 WORD PTR expblk$[rsp+197018], ax

; 380  : 
; 381  :                 if (unlikely( !ARCH_DEP( cmpsc_Expand_Index )( pCMPSCBLK, &expblk )))

  0074a	48 8d 94 24 60
	01 00 00	 lea	 rdx, QWORD PTR expblk$[rsp]
  00752	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0075a	e8 00 00 00 00	 call	 s390_cmpsc_Expand_Index
  0075f	0f b6 c0	 movzx	 eax, al
  00762	85 c0		 test	 eax, eax
  00764	75 0a		 jne	 SHORT $LN75@s390_cmpsc
  00766	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv399[rsp], 1
  0076e	eb 08		 jmp	 SHORT $LN76@s390_cmpsc
$LN75@s390_cmpsc:
  00770	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv399[rsp], 0
$LN76@s390_cmpsc:
  00778	83 7c 24 54 00	 cmp	 DWORD PTR tv399[rsp], 0
  0077d	74 0a		 je	 SHORT $LN79@s390_cmpsc
  0077f	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv408[rsp], 1
  00787	eb 08		 jmp	 SHORT $LN80@s390_cmpsc
$LN79@s390_cmpsc:
  00789	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv408[rsp], 0
$LN80@s390_cmpsc:
  00791	83 7c 24 58 00	 cmp	 DWORD PTR tv408[rsp], 0
  00796	74 59		 je	 SHORT $LN37@s390_cmpsc

; 382  :                 {
; 383  :                     // Restore context
; 384  : 
; 385  :                     memcpy( pCMPSCBLK,      &save_cmpsc,  sizeof( CMPSCBLK ));

  00798	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR save_cmpsc$6[rsp]
  007a0	48 8b bc 24 40
	03 03 00	 mov	 rdi, QWORD PTR pCMPSCBLK$[rsp]
  007a8	48 8b f0	 mov	 rsi, rax
  007ab	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  007b0	f3 a4		 rep movsb

; 386  :                     memcpy( &expblk.op1blk, &save_op1blk, sizeof( MEMBLK   ));

  007b2	48 8d 84 24 98
	02 03 00	 lea	 rax, QWORD PTR expblk$[rsp+196920]
  007ba	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR save_op1blk$4[rsp]
  007c2	48 8b f8	 mov	 rdi, rax
  007c5	48 8b f1	 mov	 rsi, rcx
  007c8	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  007cd	f3 a4		 rep movsb

; 387  :                     memcpy( &expblk.op2blk, &save_op2blk, sizeof( MEMBLK   ));

  007cf	48 8d 84 24 c0
	02 03 00	 lea	 rax, QWORD PTR expblk$[rsp+196960]
  007d7	48 8d 8c 24 e8
	00 00 00	 lea	 rcx, QWORD PTR save_op2blk$5[rsp]
  007df	48 8b f8	 mov	 rdi, rax
  007e2	48 8b f1	 mov	 rsi, rcx
  007e5	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  007ea	f3 a4		 rep movsb

; 388  :                     break; // (i < 8)

  007ec	e9 d5 00 00 00	 jmp	 $LN16@s390_cmpsc
$LN37@s390_cmpsc:

; 389  :                 }
; 390  : 
; 391  :                 // Bump destination...
; 392  : 
; 393  :                 pCMPSCBLK->pOp1  += expblk.symlen;

  007f1	0f b7 84 24 f8
	02 03 00	 movzx	 eax, WORD PTR expblk$[rsp+197016]
  007f9	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00801	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00805	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0080d	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 394  :                 pCMPSCBLK->nLen1 -= expblk.symlen;

  00811	0f b7 84 24 f8
	02 03 00	 movzx	 eax, WORD PTR expblk$[rsp+197016]
  00819	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00821	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00824	48 2b c8	 sub	 rcx, rax
  00827	48 8b c1	 mov	 rax, rcx
  0082a	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00832	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN20@s390_cmpsc:

; 395  : //              pCMPSCBLK->cbn   += bits;
; 396  : 
; 397  :                 MEMBLK_BUMP( &expblk.op1blk, pCMPSCBLK->pOp1 );

  00835	48 8b 84 24 a0
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196928]
  0083d	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00843	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0084b	48 39 41 20	 cmp	 QWORD PTR [rcx+32], rax
  0084f	73 0a		 jae	 SHORT $LN83@s390_cmpsc
  00851	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv447[rsp], 1
  00859	eb 08		 jmp	 SHORT $LN84@s390_cmpsc
$LN83@s390_cmpsc:
  0085b	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv447[rsp], 0
$LN84@s390_cmpsc:
  00863	83 7c 24 5c 00	 cmp	 DWORD PTR tv447[rsp], 0
  00868	75 4d		 jne	 SHORT $LN38@s390_cmpsc
  0086a	48 8b 84 24 a0
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196928]
  00872	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00878	48 89 84 24 a0
	02 03 00	 mov	 QWORD PTR expblk$[rsp+196928], rax
  00880	b8 08 00 00 00	 mov	 eax, 8
  00885	48 6b c0 01	 imul	 rax, rax, 1
  00889	b9 08 00 00 00	 mov	 ecx, 8
  0088e	48 6b c9 00	 imul	 rcx, rcx, 0
  00892	48 8b 84 04 a8
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+rax+196936]
  0089a	48 89 84 0c a8
	02 03 00	 mov	 QWORD PTR expblk$[rsp+rcx+196936], rax
  008a2	b8 08 00 00 00	 mov	 eax, 8
  008a7	48 6b c0 01	 imul	 rax, rax, 1
  008ab	48 c7 84 04 a8
	02 03 00 00 00
	00 00		 mov	 QWORD PTR expblk$[rsp+rax+196936], 0
$LN38@s390_cmpsc:
  008b7	33 c0		 xor	 eax, eax
  008b9	85 c0		 test	 eax, eax
  008bb	0f 85 74 ff ff
	ff		 jne	 $LN20@s390_cmpsc

; 398  :             }

  008c1	e9 56 fe ff ff	 jmp	 $LN15@s390_cmpsc
$LN16@s390_cmpsc:

; 399  : 
; 400  :             if (i < 8)

  008c6	0f b6 44 24 20	 movzx	 eax, BYTE PTR i$1[rsp]
  008cb	83 f8 08	 cmp	 eax, 8
  008ce	7d 02		 jge	 SHORT $LN39@s390_cmpsc

; 401  :                 break;

  008d0	eb 59		 jmp	 SHORT $LN11@s390_cmpsc
$LN39@s390_cmpsc:

; 402  : 
; 403  :             // Save context
; 404  : 
; 405  :             memcpy( &save_cmpsc,  pCMPSCBLK,      sizeof( CMPSCBLK ));

  008d2	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR save_cmpsc$6[rsp]
  008da	48 8b f8	 mov	 rdi, rax
  008dd	48 8b b4 24 40
	03 03 00	 mov	 rsi, QWORD PTR pCMPSCBLK$[rsp]
  008e5	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  008ea	f3 a4		 rep movsb

; 406  :             memcpy( &save_op1blk, &expblk.op1blk, sizeof( MEMBLK   ));

  008ec	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR save_op1blk$4[rsp]
  008f4	48 8d 8c 24 98
	02 03 00	 lea	 rcx, QWORD PTR expblk$[rsp+196920]
  008fc	48 8b f8	 mov	 rdi, rax
  008ff	48 8b f1	 mov	 rsi, rcx
  00902	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00907	f3 a4		 rep movsb

; 407  :             memcpy( &save_op2blk, &expblk.op2blk, sizeof( MEMBLK   ));

  00909	48 8d 84 24 e8
	00 00 00	 lea	 rax, QWORD PTR save_op2blk$5[rsp]
  00911	48 8d 8c 24 c0
	02 03 00	 lea	 rcx, QWORD PTR expblk$[rsp+196960]
  00919	48 8b f8	 mov	 rdi, rax
  0091c	48 8b f1	 mov	 rsi, rcx
  0091f	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00924	f3 a4		 rep movsb

; 408  :         }

  00926	e9 91 fc ff ff	 jmp	 $LN10@s390_cmpsc
$LN11@s390_cmpsc:
$LN34@s390_cmpsc:
$LN21@s390_cmpsc:

; 409  :     }
; 410  : 
; 411  : #endif // CMPSC_EXPAND8
; 412  : 
; 413  :     // Finish up any remainder...
; 414  : 
; 415  :     while (nCPUAmt < (U64) pCMPSCBLK->nCPUAmt)

  0092b	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00933	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00936	48 39 44 24 28	 cmp	 QWORD PTR nCPUAmt$[rsp], rax
  0093b	0f 83 c1 02 00
	00		 jae	 $LN22@s390_cmpsc

; 416  :     {
; 417  :         // Get index symbol...
; 418  : 
; 419  :         if (unlikely( !(expblk.SRC_bytes = pGetIndex( &giblk ))))

  00941	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR giblk$[rsp]
  00949	ff 94 24 80 00
	00 00		 call	 QWORD PTR pGetIndex$[rsp]
  00950	88 84 24 fc 02
	03 00		 mov	 BYTE PTR expblk$[rsp+197020], al
  00957	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  0095f	85 c0		 test	 eax, eax
  00961	75 0a		 jne	 SHORT $LN85@s390_cmpsc
  00963	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv487[rsp], 1
  0096b	eb 08		 jmp	 SHORT $LN86@s390_cmpsc
$LN85@s390_cmpsc:
  0096d	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv487[rsp], 0
$LN86@s390_cmpsc:
  00975	83 7c 24 60 00	 cmp	 DWORD PTR tv487[rsp], 0
  0097a	74 0a		 je	 SHORT $LN89@s390_cmpsc
  0097c	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv495[rsp], 1
  00984	eb 08		 jmp	 SHORT $LN90@s390_cmpsc
$LN89@s390_cmpsc:
  00986	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv495[rsp], 0
$LN90@s390_cmpsc:
  0098e	83 7c 24 64 00	 cmp	 DWORD PTR tv495[rsp], 0
  00993	74 1a		 je	 SHORT $LN40@s390_cmpsc

; 420  :             RETCC0( &expblk.op1blk );

  00995	48 8d 94 24 98
	02 03 00	 lea	 rdx, QWORD PTR expblk$[rsp+196920]
  0099d	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  009a5	e8 00 00 00 00	 call	 s390_CC0
  009aa	e9 68 02 00 00	 jmp	 $LN1@s390_cmpsc
$LN40@s390_cmpsc:

; 421  : 
; 422  :         // Expand it...
; 423  : 
; 424  :         expblk.index = index[0];

  009af	b8 02 00 00 00	 mov	 eax, 2
  009b4	48 6b c0 00	 imul	 rax, rax, 0
  009b8	0f b7 84 04 00
	03 03 00	 movzx	 eax, WORD PTR index$[rsp+rax]
  009c0	66 89 84 24 fa
	02 03 00	 mov	 WORD PTR expblk$[rsp+197018], ax

; 425  : 
; 426  :         if (unlikely( !ARCH_DEP( cmpsc_Expand_Index )( pCMPSCBLK, &expblk )))

  009c8	48 8d 94 24 60
	01 00 00	 lea	 rdx, QWORD PTR expblk$[rsp]
  009d0	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  009d8	e8 00 00 00 00	 call	 s390_cmpsc_Expand_Index
  009dd	0f b6 c0	 movzx	 eax, al
  009e0	85 c0		 test	 eax, eax
  009e2	75 0a		 jne	 SHORT $LN91@s390_cmpsc
  009e4	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv507[rsp], 1
  009ec	eb 08		 jmp	 SHORT $LN92@s390_cmpsc
$LN91@s390_cmpsc:
  009ee	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv507[rsp], 0
$LN92@s390_cmpsc:
  009f6	83 7c 24 68 00	 cmp	 DWORD PTR tv507[rsp], 0
  009fb	74 0a		 je	 SHORT $LN95@s390_cmpsc
  009fd	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv516[rsp], 1
  00a05	eb 08		 jmp	 SHORT $LN96@s390_cmpsc
$LN95@s390_cmpsc:
  00a07	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv516[rsp], 0
$LN96@s390_cmpsc:
  00a0f	83 7c 24 6c 00	 cmp	 DWORD PTR tv516[rsp], 0
  00a14	74 0d		 je	 SHORT $LN41@s390_cmpsc

; 427  :             return expblk.rc;

  00a16	0f b6 84 24 fd
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197021]
  00a1e	e9 f4 01 00 00	 jmp	 $LN1@s390_cmpsc
$LN41@s390_cmpsc:

; 428  : 
; 429  :         // Bump source...
; 430  : 
; 431  :         nCPUAmt          += expblk.SRC_bytes;

  00a23	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  00a2b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR nCPUAmt$[rsp]
  00a30	48 03 c8	 add	 rcx, rax
  00a33	48 8b c1	 mov	 rax, rcx
  00a36	48 89 44 24 28	 mov	 QWORD PTR nCPUAmt$[rsp], rax

; 432  :         pCMPSCBLK->pOp2  += expblk.SRC_bytes;

  00a3b	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  00a43	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00a4b	48 03 41 28	 add	 rax, QWORD PTR [rcx+40]
  00a4f	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00a57	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 433  :         pCMPSCBLK->nLen2 -= expblk.SRC_bytes;

  00a5b	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  00a63	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00a6b	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00a6f	48 2b c8	 sub	 rcx, rax
  00a72	48 8b c1	 mov	 rax, rcx
  00a75	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00a7d	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 434  :         pCMPSCBLK->cbn   += bits;

  00a81	0f b6 44 24 21	 movzx	 eax, BYTE PTR bits$[rsp]
  00a86	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00a8e	0f b6 49 45	 movzx	 ecx, BYTE PTR [rcx+69]
  00a92	03 c8		 add	 ecx, eax
  00a94	8b c1		 mov	 eax, ecx
  00a96	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00a9e	88 41 45	 mov	 BYTE PTR [rcx+69], al
$LN25@s390_cmpsc:

; 435  : 
; 436  :         MEMBLK_BUMP( &expblk.op2blk, pCMPSCBLK->pOp2 );

  00aa1	48 8b 84 24 c8
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196968]
  00aa9	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00aaf	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00ab7	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  00abb	73 0a		 jae	 SHORT $LN99@s390_cmpsc
  00abd	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv542[rsp], 1
  00ac5	eb 08		 jmp	 SHORT $LN100@s390_cmpsc
$LN99@s390_cmpsc:
  00ac7	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv542[rsp], 0
$LN100@s390_cmpsc:
  00acf	83 7c 24 70 00	 cmp	 DWORD PTR tv542[rsp], 0
  00ad4	75 4d		 jne	 SHORT $LN42@s390_cmpsc
  00ad6	48 8b 84 24 c8
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196968]
  00ade	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00ae4	48 89 84 24 c8
	02 03 00	 mov	 QWORD PTR expblk$[rsp+196968], rax
  00aec	b8 08 00 00 00	 mov	 eax, 8
  00af1	48 6b c0 01	 imul	 rax, rax, 1
  00af5	b9 08 00 00 00	 mov	 ecx, 8
  00afa	48 6b c9 00	 imul	 rcx, rcx, 0
  00afe	48 8b 84 04 d0
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+rax+196976]
  00b06	48 89 84 0c d0
	02 03 00	 mov	 QWORD PTR expblk$[rsp+rcx+196976], rax
  00b0e	b8 08 00 00 00	 mov	 eax, 8
  00b13	48 6b c0 01	 imul	 rax, rax, 1
  00b17	48 c7 84 04 d0
	02 03 00 00 00
	00 00		 mov	 QWORD PTR expblk$[rsp+rax+196976], 0
$LN42@s390_cmpsc:
  00b23	33 c0		 xor	 eax, eax
  00b25	85 c0		 test	 eax, eax
  00b27	0f 85 74 ff ff
	ff		 jne	 $LN25@s390_cmpsc

; 437  : 
; 438  :         // Bump destination...
; 439  : 
; 440  :         pCMPSCBLK->pOp1  += expblk.symlen;

  00b2d	0f b7 84 24 f8
	02 03 00	 movzx	 eax, WORD PTR expblk$[rsp+197016]
  00b35	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00b3d	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00b41	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00b49	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 441  :         pCMPSCBLK->nLen1 -= expblk.symlen;

  00b4d	0f b7 84 24 f8
	02 03 00	 movzx	 eax, WORD PTR expblk$[rsp+197016]
  00b55	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00b5d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00b60	48 2b c8	 sub	 rcx, rax
  00b63	48 8b c1	 mov	 rax, rcx
  00b66	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00b6e	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN28@s390_cmpsc:

; 442  : 
; 443  :         MEMBLK_BUMP( &expblk.op1blk, pCMPSCBLK->pOp1 );

  00b71	48 8b 84 24 a0
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196928]
  00b79	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00b7f	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00b87	48 39 41 20	 cmp	 QWORD PTR [rcx+32], rax
  00b8b	73 0a		 jae	 SHORT $LN103@s390_cmpsc
  00b8d	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv568[rsp], 1
  00b95	eb 08		 jmp	 SHORT $LN104@s390_cmpsc
$LN103@s390_cmpsc:
  00b97	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv568[rsp], 0
$LN104@s390_cmpsc:
  00b9f	83 7c 24 74 00	 cmp	 DWORD PTR tv568[rsp], 0
  00ba4	75 4d		 jne	 SHORT $LN43@s390_cmpsc
  00ba6	48 8b 84 24 a0
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196928]
  00bae	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00bb4	48 89 84 24 a0
	02 03 00	 mov	 QWORD PTR expblk$[rsp+196928], rax
  00bbc	b8 08 00 00 00	 mov	 eax, 8
  00bc1	48 6b c0 01	 imul	 rax, rax, 1
  00bc5	b9 08 00 00 00	 mov	 ecx, 8
  00bca	48 6b c9 00	 imul	 rcx, rcx, 0
  00bce	48 8b 84 04 a8
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+rax+196936]
  00bd6	48 89 84 0c a8
	02 03 00	 mov	 QWORD PTR expblk$[rsp+rcx+196936], rax
  00bde	b8 08 00 00 00	 mov	 eax, 8
  00be3	48 6b c0 01	 imul	 rax, rax, 1
  00be7	48 c7 84 04 a8
	02 03 00 00 00
	00 00		 mov	 QWORD PTR expblk$[rsp+rax+196936], 0
$LN43@s390_cmpsc:
  00bf3	33 c0		 xor	 eax, eax
  00bf5	85 c0		 test	 eax, eax
  00bf7	0f 85 74 ff ff
	ff		 jne	 $LN28@s390_cmpsc

; 444  :     }

  00bfd	e9 29 fd ff ff	 jmp	 $LN21@s390_cmpsc
$LN22@s390_cmpsc:

; 445  : 
; 446  :     RETCC3( &expblk.op1blk );

  00c02	48 8d 94 24 98
	02 03 00	 lea	 rdx, QWORD PTR expblk$[rsp+196920]
  00c0a	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00c12	e8 00 00 00 00	 call	 s390_CC3
$LN1@s390_cmpsc:

; 447  : }

  00c17	48 8b 8c 24 10
	03 03 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00c1f	48 33 cc	 xor	 rcx, rsp
  00c22	e8 00 00 00 00	 call	 __security_check_cookie
  00c27	48 81 c4 28 03
	03 00		 add	 rsp, 197416		; 00030328H
  00c2e	5f		 pop	 rdi
  00c2f	5e		 pop	 rsi
  00c30	c3		 ret	 0
s390_cmpsc_Expand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetch2
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
s390_vfetch2 PROC					; COMDAT

; 679  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 680  :     if (likely(!((VADR_L)addr & 0x01))
; 681  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) != PAGEFRAME_BYTEMASK ))

  00011	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00015	83 e0 01	 and	 eax, 1
  00018	85 c0		 test	 eax, eax
  0001a	75 0a		 jne	 SHORT $LN5@s390_vfetc
  0001c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00024	eb 08		 jmp	 SHORT $LN6@s390_vfetc
$LN5@s390_vfetc:
  00026	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN6@s390_vfetc:
  0002e	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00033	74 0a		 je	 SHORT $LN9@s390_vfetc
  00035	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0003d	eb 08		 jmp	 SHORT $LN10@s390_vfetc
$LN9@s390_vfetc:
  0003f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN10@s390_vfetc:
  00047	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  0004c	75 10		 jne	 SHORT $LN3@s390_vfetc
  0004e	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00052	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00057	3d ff 0f 00 00	 cmp	 eax, 4095		; 00000fffH
  0005c	74 46		 je	 SHORT $LN2@s390_vfetc
$LN3@s390_vfetc:

; 682  :     {
; 683  :         BYTE *mn;
; 684  :         ITIMER_SYNC( addr, 2-1, regs );
; 685  :         mn = MADDRL( addr, 2,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0005e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00063	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00067	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0006b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00073	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  00078	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  0007d	ba 02 00 00 00	 mov	 edx, 2
  00082	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  00086	e8 00 00 00 00	 call	 s390_maddr_l
  0008b	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 686  :         return fetch_hw( mn );

  00090	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00095	e8 00 00 00 00	 call	 fetch_hw_noswap
  0009a	0f b7 c8	 movzx	 ecx, ax
  0009d	e8 00 00 00 00	 call	 _byteswap_ushort
  000a2	eb 12		 jmp	 SHORT $LN1@s390_vfetc
$LN2@s390_vfetc:

; 687  :     }
; 688  :     return ARCH_DEP( vfetch2_full )( addr, arn, regs );

  000a4	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  000a9	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  000ad	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  000b1	e8 00 00 00 00	 call	 s390_vfetch2_full
$LN1@s390_vfetc:

; 689  : }

  000b6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ba	c3		 ret	 0
s390_vfetch2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetch2_full
_TEXT	SEGMENT
value$ = 48
mn$ = 56
addr$ = 80
arn$ = 88
regs$ = 96
s390_vfetch2_full PROC					; COMDAT

; 401  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 402  : BYTE   *mn;                             /* Main storage addresses    */
; 403  : U16     value;
; 404  : 
; 405  :     mn = MADDR( addr, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00011	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00016	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001a	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0001e	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00026	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0002b	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00030	ba 01 00 00 00	 mov	 edx, 1
  00035	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  00039	e8 00 00 00 00	 call	 s390_maddr_l
  0003e	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 406  :     value = *mn << 8;

  00043	48 8b 44 24 38	 mov	 rax, QWORD PTR mn$[rsp]
  00048	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0004b	c1 e0 08	 shl	 eax, 8
  0004e	66 89 44 24 30	 mov	 WORD PTR value$[rsp], ax

; 407  :     mn = MADDR( (addr + 1) & ADDRESS_MAXWRAP( regs ), arn, regs,

  00053	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00057	ff c0		 inc	 eax
  00059	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0005e	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00064	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00069	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0006d	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00071	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00079	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0007e	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00083	ba 01 00 00 00	 mov	 edx, 1
  00088	8b c8		 mov	 ecx, eax
  0008a	e8 00 00 00 00	 call	 s390_maddr_l
  0008f	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 408  :                  ACCTYPE_READ, regs->psw.pkey );
; 409  :     value |= *mn;

  00094	48 8b 44 24 38	 mov	 rax, QWORD PTR mn$[rsp]
  00099	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0009c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR value$[rsp]
  000a1	0b c8		 or	 ecx, eax
  000a3	8b c1		 mov	 eax, ecx
  000a5	66 89 44 24 30	 mov	 WORD PTR value$[rsp], ax

; 410  :     return value;

  000aa	0f b7 44 24 30	 movzx	 eax, WORD PTR value$[rsp]

; 411  : }

  000af	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b3	c3		 ret	 0
s390_vfetch2_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s390_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s390_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s390_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s390_maddr
$LN12@s390_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s390_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0c	 shr	 eax, 12
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s390_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s390_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s390_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s390_maddr
$LN4@s390_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s390_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s390_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s390_maddr
$LN6@s390_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 c0 7f	 and	 eax, 2143289344		; 7fc00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s390_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s390_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s390_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s390_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s390_maddr:
$LN7@s390_maddr:
$LN5@s390_maddr:
$LN3@s390_maddr:
$LN2@s390_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s390_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s390_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s390_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s390_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
r2$ = 32
r1$ = 36
i$1 = 40
tv136 = 44
tv150 = 48
tv159 = 52
tv164 = 56
rc$2 = 60
cmpsc$ = 64
inst$ = 160
regs$ = 168
s390_cmpsc_2012 PROC

; 1196 : {

$LN22:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1197 :     CMPSCBLK cmpsc;                     /* Compression Call parameters block */
; 1198 :     int  r1, r2;                        /* Operand register numbers          */
; 1199 :     RRE( inst, regs, r1, r2 );          /* Decode the instruction...         */

  00011	b8 01 00 00 00	 mov	 eax, 1
  00016	48 6b c0 03	 imul	 rax, rax, 3
  0001a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00022	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00026	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
  0002a	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  0002e	83 e0 0f	 and	 eax, 15
  00031	89 44 24 20	 mov	 DWORD PTR r2$[rsp], eax
  00035	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00039	c1 f8 04	 sar	 eax, 4
  0003c	83 e0 0f	 and	 eax, 15
  0003f	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_cmpsc:
  00043	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004f	48 83 c0 04	 add	 rax, 4
  00053	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0005b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005f	33 c0		 xor	 eax, eax
  00061	83 f8 04	 cmp	 eax, 4
  00064	74 0f		 je	 SHORT $LN5@s390_cmpsc
  00066	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s390_cmpsc:
  00075	33 c0		 xor	 eax, eax
  00077	85 c0		 test	 eax, eax
  00079	75 c8		 jne	 SHORT $LN4@s390_cmpsc

; 1200 : 
; 1201 : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 1202 :     if (0
; 1203 :         || GR_A( 1,  regs ) == 0
; 1204 :         || GR_A( r1, regs ) == 0
; 1205 :         || GR_A( r2, regs ) == 0
; 1206 :     )
; 1207 :         ARCH_DEP( per3_zero )( regs );
; 1208 : #endif
; 1209 : 
; 1210 :     /* Build our internal Compression Call parameters block */
; 1211 : 
; 1212 :     ARCH_DEP( cmpsc_SetCMPSC )( &cmpsc, regs, r1, r2 );

  0007b	44 8b 4c 24 20	 mov	 r9d, DWORD PTR r2$[rsp]
  00080	44 8b 44 24 24	 mov	 r8d, DWORD PTR r1$[rsp]
  00085	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0008d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR cmpsc$[rsp]
  00092	e8 00 00 00 00	 call	 s390_cmpsc_SetCMPSC

; 1213 : 
; 1214 :     /* Verify that an even-odd register pair was specified
; 1215 :        and that the compressed-data symbol size is valid. */
; 1216 : 
; 1217 :     if (likely( 1

  00097	33 c0		 xor	 eax, eax
  00099	83 f8 01	 cmp	 eax, 1
  0009c	74 3a		 je	 SHORT $LN10@s390_cmpsc
  0009e	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  000a2	83 e0 01	 and	 eax, 1
  000a5	85 c0		 test	 eax, eax
  000a7	75 2f		 jne	 SHORT $LN10@s390_cmpsc
  000a9	8b 44 24 20	 mov	 eax, DWORD PTR r2$[rsp]
  000ad	83 e0 01	 and	 eax, 1
  000b0	85 c0		 test	 eax, eax
  000b2	75 24		 jne	 SHORT $LN10@s390_cmpsc
  000b4	0f b6 84 24 84
	00 00 00	 movzx	 eax, BYTE PTR cmpsc$[rsp+68]
  000bc	83 f8 01	 cmp	 eax, 1
  000bf	7c 17		 jl	 SHORT $LN10@s390_cmpsc
  000c1	0f b6 84 24 84
	00 00 00	 movzx	 eax, BYTE PTR cmpsc$[rsp+68]
  000c9	83 f8 05	 cmp	 eax, 5
  000cc	7f 0a		 jg	 SHORT $LN10@s390_cmpsc
  000ce	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000d6	eb 08		 jmp	 SHORT $LN13@s390_cmpsc
$LN10@s390_cmpsc:
  000d8	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN13@s390_cmpsc:
  000e0	83 7c 24 2c 00	 cmp	 DWORD PTR tv136[rsp], 0
  000e5	0f 84 da 00 00
	00		 je	 $LN6@s390_cmpsc

; 1218 :         && !(r1 & 0x01)       /* (even register number?) */
; 1219 :         && !(r2 & 0x01)       /* (even register number?) */
; 1220 :         && cmpsc.cdss >= 1    /* (is symbol size valid?) */
; 1221 :         && cmpsc.cdss <= 5    /* (is symbol size valid?) */
; 1222 :     ))
; 1223 :     {
; 1224 :         /* Perform the Compression or Expansion */
; 1225 : 
; 1226 :         int rc = (regs->GR_L(0) & 0x100)

  000eb	b8 08 00 00 00	 mov	 eax, 8
  000f0	48 6b c0 00	 imul	 rax, rax, 0
  000f4	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00103	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00108	85 c0		 test	 eax, eax
  0010a	74 13		 je	 SHORT $LN14@s390_cmpsc
  0010c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR cmpsc$[rsp]
  00111	e8 00 00 00 00	 call	 s390_cmpsc_Expand
  00116	0f b6 c0	 movzx	 eax, al
  00119	89 44 24 30	 mov	 DWORD PTR tv150[rsp], eax
  0011d	eb 11		 jmp	 SHORT $LN15@s390_cmpsc
$LN14@s390_cmpsc:
  0011f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR cmpsc$[rsp]
  00124	e8 00 00 00 00	 call	 s390_cmpsc_Compress
  00129	0f b6 c0	 movzx	 eax, al
  0012c	89 44 24 30	 mov	 DWORD PTR tv150[rsp], eax
$LN15@s390_cmpsc:
  00130	8b 44 24 30	 mov	 eax, DWORD PTR tv150[rsp]
  00134	89 44 24 3c	 mov	 DWORD PTR rc$2[rsp], eax

; 1227 :                ? ARCH_DEP( cmpsc_Expand   )( &cmpsc )
; 1228 :                : ARCH_DEP( cmpsc_Compress )( &cmpsc );
; 1229 : 
; 1230 :         /* Update register context with results */
; 1231 : 
; 1232 :         cmpsc.cbn &= 0x07;

  00138	0f b6 84 24 85
	00 00 00	 movzx	 eax, BYTE PTR cmpsc$[rsp+69]
  00140	83 e0 07	 and	 eax, 7
  00143	88 84 24 85 00
	00 00		 mov	 BYTE PTR cmpsc$[rsp+69], al

; 1233 :         ARCH_DEP( cmpsc_SetREGS )( &cmpsc, regs, r1, r2 );

  0014a	44 8b 4c 24 20	 mov	 r9d, DWORD PTR r2$[rsp]
  0014f	44 8b 44 24 24	 mov	 r8d, DWORD PTR r1$[rsp]
  00154	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0015c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR cmpsc$[rsp]
  00161	e8 00 00 00 00	 call	 s390_cmpsc_SetREGS

; 1234 : 
; 1235 :         /* Program Check Interrupt if we failed */
; 1236 : 
; 1237 :         if (unlikely( !rc ))

  00166	83 7c 24 3c 00	 cmp	 DWORD PTR rc$2[rsp], 0
  0016b	75 0a		 jne	 SHORT $LN16@s390_cmpsc
  0016d	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv159[rsp], 1
  00175	eb 08		 jmp	 SHORT $LN17@s390_cmpsc
$LN16@s390_cmpsc:
  00177	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
$LN17@s390_cmpsc:
  0017f	83 7c 24 34 00	 cmp	 DWORD PTR tv159[rsp], 0
  00184	74 0a		 je	 SHORT $LN20@s390_cmpsc
  00186	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv164[rsp], 1
  0018e	eb 08		 jmp	 SHORT $LN21@s390_cmpsc
$LN20@s390_cmpsc:
  00190	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv164[rsp], 0
$LN21@s390_cmpsc:
  00198	83 7c 24 38 00	 cmp	 DWORD PTR tv164[rsp], 0
  0019d	74 24		 je	 SHORT $LN8@s390_cmpsc

; 1238 :         {
; 1239 :             regs->dxc = DXC_DECIMAL; /* Set Data Exception code */

  0019f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a7	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 1240 :             ARCH_DEP( program_interrupt )( regs, PGM_DATA_EXCEPTION );

  001b1	ba 07 00 00 00	 mov	 edx, 7
  001b6	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001be	e8 00 00 00 00	 call	 s390_program_interrupt
$LN8@s390_cmpsc:

; 1241 :         }
; 1242 :     }

  001c3	eb 12		 jmp	 SHORT $LN7@s390_cmpsc
$LN6@s390_cmpsc:

; 1243 :     else
; 1244 :         ARCH_DEP( program_interrupt )( regs, PGM_SPECIFICATION_EXCEPTION );

  001c5	ba 06 00 00 00	 mov	 edx, 6
  001ca	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d2	e8 00 00 00 00	 call	 s390_program_interrupt
$LN7@s390_cmpsc:

; 1245 : }

  001d7	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  001de	c3		 ret	 0
s390_cmpsc_2012 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
dicts$ = 32
tv264 = 34
tv66 = 36
tv72 = 40
tv85 = 44
tv161 = 48
tv172 = 52
tv186 = 56
tv202 = 60
tv229 = 64
tv240 = 68
tv253 = 72
tv275 = 76
tv152 = 80
tv220 = 88
tv289 = 96
tv324 = 104
pCMPSCBLK$ = 128
pEXPBLK$ = 136
s370_cmpsc_Expand_Index PROC

; 453  : {

$LN53:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 454  :     U8  dicts;  // Counts dictionary entries processed
; 455  : 
; 456  :     if (unlikely( !pCMPSCBLK->nLen1 ))

  0000e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00016	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0001a	75 0a		 jne	 SHORT $LN19@s370_cmpsc
  0001c	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00024	eb 08		 jmp	 SHORT $LN20@s370_cmpsc
$LN19@s370_cmpsc:
  00026	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN20@s370_cmpsc:
  0002e	83 7c 24 24 00	 cmp	 DWORD PTR tv66[rsp], 0
  00033	74 0a		 je	 SHORT $LN23@s370_cmpsc
  00035	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0003d	eb 08		 jmp	 SHORT $LN24@s370_cmpsc
$LN23@s370_cmpsc:
  0003f	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN24@s370_cmpsc:
  00047	83 7c 24 28 00	 cmp	 DWORD PTR tv72[rsp], 0
  0004c	74 1a		 je	 SHORT $LN5@s370_cmpsc

; 457  :         EXP_RETCC1();

  0004e	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  00056	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0005e	e8 00 00 00 00	 call	 s370_EXPCC1
  00063	e9 8f 05 00 00	 jmp	 $LN1@s370_cmpsc
$LN5@s370_cmpsc:

; 458  : 
; 459  :     if (likely( pEXPBLK->index >= 256 ))

  00068	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00070	0f b7 80 9a 01
	03 00		 movzx	 eax, WORD PTR [rax+197018]
  00077	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0007c	7c 0a		 jl	 SHORT $LN27@s370_cmpsc
  0007e	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv85[rsp], 1
  00086	eb 08		 jmp	 SHORT $LN28@s370_cmpsc
$LN27@s370_cmpsc:
  00088	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv85[rsp], 0
$LN28@s370_cmpsc:
  00090	83 7c 24 2c 00	 cmp	 DWORD PTR tv85[rsp], 0
  00095	0f 84 03 05 00
	00		 je	 $LN6@s370_cmpsc

; 460  :     {
; 461  : #ifdef CMPSC_SYMCACHE
; 462  :         // Check our cache of previously expanded index symbols
; 463  :         // to see if we've already expanded this symbol before
; 464  :         // and if we have room in the o/p buffer to expand it.
; 465  : 
; 466  :         if (1
; 467  :             && (pEXPBLK->symlen  = pEXPBLK->symcctl[ pEXPBLK->index ].len) > 0
; 468  :             &&  pEXPBLK->symlen <= pCMPSCBLK->nLen1

  0009b	33 c0		 xor	 eax, eax
  0009d	83 f8 01	 cmp	 eax, 1
  000a0	0f 84 d2 00 00
	00		 je	 $LN8@s370_cmpsc
  000a6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  000ae	0f b7 80 9a 01
	03 00		 movzx	 eax, WORD PTR [rax+197018]
  000b5	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  000bd	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  000c5	0f b7 44 82 02	 movzx	 eax, WORD PTR [rdx+rax*4+2]
  000ca	66 89 81 98 01
	03 00		 mov	 WORD PTR [rcx+197016], ax
  000d1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  000d9	0f b7 80 98 01
	03 00		 movzx	 eax, WORD PTR [rax+197016]
  000e0	85 c0		 test	 eax, eax
  000e2	0f 8e 90 00 00
	00		 jle	 $LN8@s370_cmpsc
  000e8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  000f0	0f b7 80 98 01
	03 00		 movzx	 eax, WORD PTR [rax+197016]
  000f7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  000ff	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  00102	77 74		 ja	 SHORT $LN8@s370_cmpsc

; 469  :         )
; 470  :         {
; 471  :             store_op_str( &pEXPBLK->symcache[ pEXPBLK->symcctl[ pEXPBLK->index ].idx ], pEXPBLK->symlen-1, pCMPSCBLK->pOp1, &pEXPBLK->op1blk );

  00104	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  0010c	48 05 38 01 03
	00		 add	 rax, 196920		; 00030138H
  00112	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  0011a	0f b7 89 98 01
	03 00		 movzx	 ecx, WORD PTR [rcx+197016]
  00121	ff c9		 dec	 ecx
  00123	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  0012b	0f b7 92 9a 01
	03 00		 movzx	 edx, WORD PTR [rdx+197018]
  00132	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR pEXPBLK$[rsp]
  0013a	41 0f b7 14 90	 movzx	 edx, WORD PTR [r8+rdx*4]
  0013f	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR pEXPBLK$[rsp]
  00147	49 8d 94 10 00
	80 00 00	 lea	 rdx, QWORD PTR [r8+rdx+32768]
  0014f	48 89 54 24 50	 mov	 QWORD PTR tv152[rsp], rdx
  00154	4c 8b c8	 mov	 r9, rax
  00157	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0015f	44 8b 40 20	 mov	 r8d, DWORD PTR [rax+32]
  00163	0f b7 d1	 movzx	 edx, cx
  00166	48 8b 44 24 50	 mov	 rax, QWORD PTR tv152[rsp]
  0016b	48 8b c8	 mov	 rcx, rax
  0016e	e8 00 00 00 00	 call	 s370_cmpsc_vstorec

; 472  :         }

  00173	e9 24 04 00 00	 jmp	 $LN9@s370_cmpsc
$LN8@s370_cmpsc:

; 473  :         else
; 474  : #endif // CMPSC_SYMCACHE
; 475  :         {
; 476  :             // We need to expand this index symbol: fetch the ECE...
; 477  : 
; 478  :             if (unlikely( !ARCH_DEP( GetECE )( pEXPBLK->index, &pEXPBLK->eceblk )))

  00178	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00180	48 05 20 01 01
	00		 add	 rax, 65824		; 00010120H
  00186	48 8b d0	 mov	 rdx, rax
  00189	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00191	0f b7 88 9a 01
	03 00		 movzx	 ecx, WORD PTR [rax+197018]
  00198	e8 00 00 00 00	 call	 s370_GetECE
  0019d	0f b6 c0	 movzx	 eax, al
  001a0	85 c0		 test	 eax, eax
  001a2	75 0a		 jne	 SHORT $LN29@s370_cmpsc
  001a4	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv161[rsp], 1
  001ac	eb 08		 jmp	 SHORT $LN30@s370_cmpsc
$LN29@s370_cmpsc:
  001ae	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv161[rsp], 0
$LN30@s370_cmpsc:
  001b6	83 7c 24 30 00	 cmp	 DWORD PTR tv161[rsp], 0
  001bb	74 0a		 je	 SHORT $LN33@s370_cmpsc
  001bd	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv172[rsp], 1
  001c5	eb 08		 jmp	 SHORT $LN34@s370_cmpsc
$LN33@s370_cmpsc:
  001c7	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv172[rsp], 0
$LN34@s370_cmpsc:
  001cf	83 7c 24 34 00	 cmp	 DWORD PTR tv172[rsp], 0
  001d4	74 1a		 je	 SHORT $LN10@s370_cmpsc

; 479  :                 EXP_RETERR();

  001d6	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  001de	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  001e6	e8 00 00 00 00	 call	 s370_EXPERR
  001eb	e9 07 04 00 00	 jmp	 $LN1@s370_cmpsc
$LN10@s370_cmpsc:

; 480  : 
; 481  :             if (pEXPBLK->ece.psl)

  001f0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  001f8	0f b6 80 93 01
	03 00		 movzx	 eax, BYTE PTR [rax+197011]
  001ff	85 c0		 test	 eax, eax
  00201	0f 84 bc 01 00
	00		 je	 $LN11@s370_cmpsc

; 482  :             {
; 483  :                 // Preceded (i.e. partial symbol)...
; 484  :                 // Do we have room for the complete symbol?
; 485  : 
; 486  :                 if (unlikely( pCMPSCBLK->nLen1 < (pEXPBLK->symlen = pEXPBLK->ece.psl + pEXPBLK->ece.ofst)))

  00207	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  0020f	0f b6 80 93 01
	03 00		 movzx	 eax, BYTE PTR [rax+197011]
  00216	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  0021e	0f b6 89 94 01
	03 00		 movzx	 ecx, BYTE PTR [rcx+197012]
  00225	03 c1		 add	 eax, ecx
  00227	89 44 24 38	 mov	 DWORD PTR tv186[rsp], eax
  0022b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00233	0f b7 4c 24 38	 movzx	 ecx, WORD PTR tv186[rsp]
  00238	66 89 88 98 01
	03 00		 mov	 WORD PTR [rax+197016], cx
  0023f	0f b7 44 24 38	 movzx	 eax, WORD PTR tv186[rsp]
  00244	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0024c	48 39 01	 cmp	 QWORD PTR [rcx], rax
  0024f	73 0a		 jae	 SHORT $LN37@s370_cmpsc
  00251	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv202[rsp], 1
  00259	eb 08		 jmp	 SHORT $LN38@s370_cmpsc
$LN37@s370_cmpsc:
  0025b	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv202[rsp], 0
$LN38@s370_cmpsc:
  00263	83 7c 24 3c 00	 cmp	 DWORD PTR tv202[rsp], 0
  00268	74 1a		 je	 SHORT $LN13@s370_cmpsc

; 487  :                     EXP_RETCC1();

  0026a	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  00272	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0027a	e8 00 00 00 00	 call	 s370_EXPCC1
  0027f	e9 73 03 00 00	 jmp	 $LN1@s370_cmpsc
$LN13@s370_cmpsc:

; 488  : 
; 489  :                 dicts = 1;

  00284	c6 44 24 20 01	 mov	 BYTE PTR dicts$[rsp], 1
$LN4@s370_cmpsc:

; 490  : 
; 491  :                 do
; 492  :                 {
; 493  :                     // Expand this partial ("preceded") chunk of this index symbol...
; 494  : 
; 495  :                     store_op_str( pEXPBLK->ece.ec, pEXPBLK->ece.psl-1, pCMPSCBLK->pOp1 + pEXPBLK->ece.ofst, &pEXPBLK->op1blk );

  00289	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00291	48 05 38 01 03
	00		 add	 rax, 196920		; 00030138H
  00297	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  0029f	0f b6 89 94 01
	03 00		 movzx	 ecx, BYTE PTR [rcx+197012]
  002a6	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pCMPSCBLK$[rsp]
  002ae	48 03 4a 20	 add	 rcx, QWORD PTR [rdx+32]
  002b2	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  002ba	0f b6 92 93 01
	03 00		 movzx	 edx, BYTE PTR [rdx+197011]
  002c1	ff ca		 dec	 edx
  002c3	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR pEXPBLK$[rsp]
  002cb	49 81 c0 88 01
	03 00		 add	 r8, 197000		; 00030188H
  002d2	4c 89 44 24 58	 mov	 QWORD PTR tv220[rsp], r8
  002d7	4c 8b c8	 mov	 r9, rax
  002da	44 8b c1	 mov	 r8d, ecx
  002dd	48 8b 44 24 58	 mov	 rax, QWORD PTR tv220[rsp]
  002e2	48 8b c8	 mov	 rcx, rax
  002e5	e8 00 00 00 00	 call	 s370_cmpsc_vstorec

; 496  : 
; 497  :                     // Get the ECE for the next chunk...
; 498  : 
; 499  :                     if (unlikely( !ARCH_DEP( GetECE )( pEXPBLK->ece.pptr, &pEXPBLK->eceblk )))

  002ea	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  002f2	48 05 20 01 01
	00		 add	 rax, 65824		; 00010120H
  002f8	48 8b d0	 mov	 rdx, rax
  002fb	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00303	0f b7 88 90 01
	03 00		 movzx	 ecx, WORD PTR [rax+197008]
  0030a	e8 00 00 00 00	 call	 s370_GetECE
  0030f	0f b6 c0	 movzx	 eax, al
  00312	85 c0		 test	 eax, eax
  00314	75 0a		 jne	 SHORT $LN39@s370_cmpsc
  00316	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv229[rsp], 1
  0031e	eb 08		 jmp	 SHORT $LN40@s370_cmpsc
$LN39@s370_cmpsc:
  00320	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv229[rsp], 0
$LN40@s370_cmpsc:
  00328	83 7c 24 40 00	 cmp	 DWORD PTR tv229[rsp], 0
  0032d	74 0a		 je	 SHORT $LN43@s370_cmpsc
  0032f	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv240[rsp], 1
  00337	eb 08		 jmp	 SHORT $LN44@s370_cmpsc
$LN43@s370_cmpsc:
  00339	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv240[rsp], 0
$LN44@s370_cmpsc:
  00341	83 7c 24 44 00	 cmp	 DWORD PTR tv240[rsp], 0
  00346	74 1a		 je	 SHORT $LN14@s370_cmpsc

; 500  :                         EXP_RETERR();

  00348	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  00350	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00358	e8 00 00 00 00	 call	 s370_EXPERR
  0035d	e9 95 02 00 00	 jmp	 $LN1@s370_cmpsc
$LN14@s370_cmpsc:

; 501  : 
; 502  :                     if (unlikely( ++dicts > 127 ))

  00362	0f b6 44 24 20	 movzx	 eax, BYTE PTR dicts$[rsp]
  00367	fe c0		 inc	 al
  00369	88 44 24 20	 mov	 BYTE PTR dicts$[rsp], al
  0036d	0f b6 44 24 20	 movzx	 eax, BYTE PTR dicts$[rsp]
  00372	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00375	7e 0a		 jle	 SHORT $LN47@s370_cmpsc
  00377	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv253[rsp], 1
  0037f	eb 08		 jmp	 SHORT $LN48@s370_cmpsc
$LN47@s370_cmpsc:
  00381	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv253[rsp], 0
$LN48@s370_cmpsc:
  00389	83 7c 24 48 00	 cmp	 DWORD PTR tv253[rsp], 0
  0038e	74 1a		 je	 SHORT $LN15@s370_cmpsc

; 503  :                         EXP_RETERR();

  00390	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  00398	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  003a0	e8 00 00 00 00	 call	 s370_EXPERR
  003a5	e9 4d 02 00 00	 jmp	 $LN1@s370_cmpsc
$LN15@s370_cmpsc:

; 504  :                 }
; 505  :                 while (pEXPBLK->ece.psl);

  003aa	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  003b2	0f b6 80 93 01
	03 00		 movzx	 eax, BYTE PTR [rax+197011]
  003b9	85 c0		 test	 eax, eax
  003bb	0f 85 c8 fe ff
	ff		 jne	 $LN4@s370_cmpsc

; 506  : 
; 507  :                 // we're done with the partial ("preceded") part of this
; 508  :                 // symbol's expansion. Fall through to the "complete" symbol
; 509  :                 // expansion logic to finish up this symbol's expansion...
; 510  :             }

  003c1	eb 6d		 jmp	 SHORT $LN12@s370_cmpsc
$LN11@s370_cmpsc:

; 511  :             else
; 512  :             {
; 513  :                 // Unpreceded (i.e. complete symbol)...
; 514  :                 // Do we have room for the complete symbol?
; 515  : 
; 516  :                 if (unlikely( pCMPSCBLK->nLen1 < (pEXPBLK->symlen = pEXPBLK->ece.csl)))

  003c3	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  003cb	0f b6 80 92 01
	03 00		 movzx	 eax, BYTE PTR [rax+197010]
  003d2	66 89 44 24 22	 mov	 WORD PTR tv264[rsp], ax
  003d7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  003df	0f b7 4c 24 22	 movzx	 ecx, WORD PTR tv264[rsp]
  003e4	66 89 88 98 01
	03 00		 mov	 WORD PTR [rax+197016], cx
  003eb	0f b7 44 24 22	 movzx	 eax, WORD PTR tv264[rsp]
  003f0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  003f8	48 39 01	 cmp	 QWORD PTR [rcx], rax
  003fb	73 0a		 jae	 SHORT $LN51@s370_cmpsc
  003fd	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv275[rsp], 1
  00405	eb 08		 jmp	 SHORT $LN52@s370_cmpsc
$LN51@s370_cmpsc:
  00407	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv275[rsp], 0
$LN52@s370_cmpsc:
  0040f	83 7c 24 4c 00	 cmp	 DWORD PTR tv275[rsp], 0
  00414	74 1a		 je	 SHORT $LN16@s370_cmpsc

; 517  :                     EXP_RETCC1();

  00416	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  0041e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00426	e8 00 00 00 00	 call	 s370_EXPCC1
  0042b	e9 c7 01 00 00	 jmp	 $LN1@s370_cmpsc
$LN16@s370_cmpsc:
$LN12@s370_cmpsc:

; 518  :             }
; 519  : 
; 520  :             // Complete the expansion of this index symbol...
; 521  : 
; 522  :             store_op_str( pEXPBLK->ece.ec, pEXPBLK->ece.csl-1, pCMPSCBLK->pOp1, &pEXPBLK->op1blk );

  00430	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00438	48 05 38 01 03
	00		 add	 rax, 196920		; 00030138H
  0043e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  00446	0f b6 89 92 01
	03 00		 movzx	 ecx, BYTE PTR [rcx+197010]
  0044d	ff c9		 dec	 ecx
  0044f	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  00457	48 81 c2 88 01
	03 00		 add	 rdx, 197000		; 00030188H
  0045e	48 89 54 24 60	 mov	 QWORD PTR tv289[rsp], rdx
  00463	4c 8b c8	 mov	 r9, rax
  00466	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0046e	44 8b 40 20	 mov	 r8d, DWORD PTR [rax+32]
  00472	0f b7 d1	 movzx	 edx, cx
  00475	48 8b 44 24 60	 mov	 rax, QWORD PTR tv289[rsp]
  0047a	48 8b c8	 mov	 rcx, rax
  0047d	e8 00 00 00 00	 call	 s370_cmpsc_vstorec

; 523  : 
; 524  : #ifdef CMPSC_SYMCACHE
; 525  :             // If there's room for it, add this symbol to our expanded symbols cache
; 526  : 
; 527  :             if (pEXPBLK->symlen <= (sizeof( pEXPBLK->symcache ) - pEXPBLK->symindex))

  00482	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  0048a	0f b7 80 98 01
	03 00		 movzx	 eax, WORD PTR [rax+197016]
  00491	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  00499	0f b7 89 00 00
	01 00		 movzx	 ecx, WORD PTR [rcx+65536]
  004a0	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  004a5	48 2b d1	 sub	 rdx, rcx
  004a8	48 8b ca	 mov	 rcx, rdx
  004ab	48 3b c1	 cmp	 rax, rcx
  004ae	0f 87 e8 00 00
	00		 ja	 $LN17@s370_cmpsc

; 528  :             {
; 529  :                 pEXPBLK->symcctl[ pEXPBLK->index ].len = pEXPBLK->symlen;

  004b4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  004bc	0f b7 80 9a 01
	03 00		 movzx	 eax, WORD PTR [rax+197018]
  004c3	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  004cb	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  004d3	0f b7 92 98 01
	03 00		 movzx	 edx, WORD PTR [rdx+197016]
  004da	66 89 54 81 02	 mov	 WORD PTR [rcx+rax*4+2], dx

; 530  :                 pEXPBLK->symcctl[ pEXPBLK->index ].idx = pEXPBLK->symindex;

  004df	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  004e7	0f b7 80 9a 01
	03 00		 movzx	 eax, WORD PTR [rax+197018]
  004ee	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  004f6	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  004fe	0f b7 92 00 00
	01 00		 movzx	 edx, WORD PTR [rdx+65536]
  00505	66 89 14 81	 mov	 WORD PTR [rcx+rax*4], dx

; 531  : 
; 532  :                 // (add this symbol to our previously expanded symbols cache)
; 533  : 
; 534  :                 fetch_op_str( &pEXPBLK->symcache[ pEXPBLK->symindex ], pEXPBLK->symlen-1, pCMPSCBLK->pOp1, &pEXPBLK->op1blk );

  00509	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00511	48 05 38 01 03
	00		 add	 rax, 196920		; 00030138H
  00517	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  0051f	0f b7 89 98 01
	03 00		 movzx	 ecx, WORD PTR [rcx+197016]
  00526	ff c9		 dec	 ecx
  00528	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  00530	0f b7 92 00 00
	01 00		 movzx	 edx, WORD PTR [rdx+65536]
  00537	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR pEXPBLK$[rsp]
  0053f	49 8d 94 10 00
	80 00 00	 lea	 rdx, QWORD PTR [r8+rdx+32768]
  00547	48 89 54 24 68	 mov	 QWORD PTR tv324[rsp], rdx
  0054c	4c 8b c8	 mov	 r9, rax
  0054f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00557	44 8b 40 20	 mov	 r8d, DWORD PTR [rax+32]
  0055b	0f b7 d1	 movzx	 edx, cx
  0055e	48 8b 44 24 68	 mov	 rax, QWORD PTR tv324[rsp]
  00563	48 8b c8	 mov	 rcx, rax
  00566	e8 00 00 00 00	 call	 s370_cmpsc_vfetchc

; 535  : 
; 536  :                 pEXPBLK->symindex += pEXPBLK->symlen;

  0056b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00573	0f b7 80 98 01
	03 00		 movzx	 eax, WORD PTR [rax+197016]
  0057a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  00582	0f b7 89 00 00
	01 00		 movzx	 ecx, WORD PTR [rcx+65536]
  00589	03 c8		 add	 ecx, eax
  0058b	8b c1		 mov	 eax, ecx
  0058d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  00595	66 89 81 00 00
	01 00		 mov	 WORD PTR [rcx+65536], ax
$LN17@s370_cmpsc:
$LN9@s370_cmpsc:

; 537  :             }
; 538  : #endif // CMPSC_SYMCACHE
; 539  :         }
; 540  :     }

  0059c	eb 44		 jmp	 SHORT $LN7@s370_cmpsc
$LN6@s370_cmpsc:

; 541  :     else // (pEXPBLK->index < 256)
; 542  :     {
; 543  :         // The index symbol is an alphabet entry (i.e. an index symbol
; 544  :         // corresponding to a one-byte symbol). The expanded symbol it
; 545  :         // represents is the value of the alphabet index symbol itself.
; 546  : 
; 547  :         store_op_b( (U8)pEXPBLK->index, pCMPSCBLK->pOp1, &pEXPBLK->op1blk );

  0059e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  005a6	48 05 38 01 03
	00		 add	 rax, 196920		; 00030138H
  005ac	4c 8b c0	 mov	 r8, rax
  005af	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  005b7	8b 50 20	 mov	 edx, DWORD PTR [rax+32]
  005ba	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  005c2	0f b6 88 9a 01
	03 00		 movzx	 ecx, BYTE PTR [rax+197018]
  005c9	e8 00 00 00 00	 call	 s370_cmpsc_vstoreb

; 548  :         pEXPBLK->symlen = 1;

  005ce	b8 01 00 00 00	 mov	 eax, 1
  005d3	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  005db	66 89 81 98 01
	03 00		 mov	 WORD PTR [rcx+197016], ax
$LN7@s370_cmpsc:

; 549  :     }
; 550  : 
; 551  :     EXP_RETOK();

  005e2	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEXPBLK$[rsp]
  005ea	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  005f2	e8 00 00 00 00	 call	 s370_EXPOK
$LN1@s370_cmpsc:

; 552  : }

  005f7	48 83 c4 78	 add	 rsp, 120		; 00000078H
  005fb	c3		 ret	 0
s370_cmpsc_Expand_Index ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
pCMPSCBLK$ = 48
pEXPBLK$ = 56
s370_EXPCC1 PROC

; 212  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 213  :     pEXPBLK->rc = ARCH_DEP( CC1 )( pCMPSCBLK, &pEXPBLK->op1blk ); return FALSE; // (break)

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00013	48 05 38 01 03
	00		 add	 rax, 196920		; 00030138H
  00019	48 8b d0	 mov	 rdx, rax
  0001c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00021	e8 00 00 00 00	 call	 s370_CC1
  00026	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  0002b	88 81 9d 01 03
	00		 mov	 BYTE PTR [rcx+197021], al
  00031	32 c0		 xor	 al, al

; 214  : }

  00033	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00037	c3		 ret	 0
s370_EXPCC1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
pCMPSCBLK$ = 48
pEXPBLK$ = 56
s370_EXPERR PROC

; 204  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 205  :     pEXPBLK->rc = ARCH_DEP( ERR )( pCMPSCBLK, &pEXPBLK->op1blk ); return FALSE; // (break)

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR pEXPBLK$[rsp]
  00013	48 05 38 01 03
	00		 add	 rax, 196920		; 00030138H
  00019	48 8b d0	 mov	 rdx, rax
  0001c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00021	e8 00 00 00 00	 call	 s370_ERR
  00026	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pEXPBLK$[rsp]
  0002b	88 81 9d 01 03
	00		 mov	 BYTE PTR [rcx+197021], al
  00031	32 c0		 xor	 al, al

; 206  : }

  00033	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00037	c3		 ret	 0
s370_EXPERR ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
pCMPSCBLK$ = 8
pEXPBLK$ = 16
s370_EXPOK PROC

; 198  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s370_EXPOK:

; 199  :     UNREFERENCED( pCMPSCBLK );

  0000a	33 c0		 xor	 eax, eax
  0000c	85 c0		 test	 eax, eax
  0000e	75 fa		 jne	 SHORT $LN4@s370_EXPOK
$LN7@s370_EXPOK:

; 200  :     UNREFERENCED( pEXPBLK   );

  00010	33 c0		 xor	 eax, eax
  00012	85 c0		 test	 eax, eax
  00014	75 fa		 jne	 SHORT $LN7@s370_EXPOK

; 201  :     return TRUE; // (success; keep going)

  00016	b0 01		 mov	 al, 1

; 202  : }

  00018	c3		 ret	 0
s370_EXPOK ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
pCMPSCBLK$ = 8
pOp1MemBlk$ = 16
s370_CC0 PROC

; 189  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s370_CC0:

; 190  :     ZERO_PAD_OP1( pCMPSCBLK, pOp1MemBlk );

  0000a	33 c0		 xor	 eax, eax
  0000c	85 c0		 test	 eax, eax
  0000e	75 fa		 jne	 SHORT $LN4@s370_CC0

; 191  :     pCMPSCBLK->pic = 0;

  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00017	66 89 41 3e	 mov	 WORD PTR [rcx+62], ax

; 192  :     pCMPSCBLK->cc = 0;

  0001b	48 8b 44 24 08	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00020	c6 40 46 00	 mov	 BYTE PTR [rax+70], 0

; 193  :     return TRUE;

  00024	b0 01		 mov	 al, 1

; 194  : }

  00026	c3		 ret	 0
s370_CC0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
pCMPSCBLK$ = 8
pOp1MemBlk$ = 16
s370_CC1 PROC

; 182  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s370_CC1:

; 183  :     ZERO_PAD_OP1( pCMPSCBLK, pOp1MemBlk );

  0000a	33 c0		 xor	 eax, eax
  0000c	85 c0		 test	 eax, eax
  0000e	75 fa		 jne	 SHORT $LN4@s370_CC1

; 184  :     pCMPSCBLK->pic = 0;

  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00017	66 89 41 3e	 mov	 WORD PTR [rcx+62], ax

; 185  :     pCMPSCBLK->cc = 1;

  0001b	48 8b 44 24 08	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00020	c6 40 46 01	 mov	 BYTE PTR [rax+70], 1

; 186  :     return TRUE;

  00024	b0 01		 mov	 al, 1

; 187  : }

  00026	c3		 ret	 0
s370_CC1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
pCMPSCBLK$ = 8
pOp1MemBlk$ = 16
s370_CC3 PROC

; 175  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s370_CC3:

; 176  :     ZERO_PAD_OP1( pCMPSCBLK, pOp1MemBlk );

  0000a	33 c0		 xor	 eax, eax
  0000c	85 c0		 test	 eax, eax
  0000e	75 fa		 jne	 SHORT $LN4@s370_CC3

; 177  :     pCMPSCBLK->pic = 0;

  00010	33 c0		 xor	 eax, eax
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00017	66 89 41 3e	 mov	 WORD PTR [rcx+62], ax

; 178  :     pCMPSCBLK->cc = 3;

  0001b	48 8b 44 24 08	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00020	c6 40 46 03	 mov	 BYTE PTR [rax+70], 3

; 179  :     return TRUE;

  00024	b0 01		 mov	 al, 1

; 180  : }

  00026	c3		 ret	 0
s370_CC3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
pCMPSCBLK$ = 8
pOp1MemBlk$ = 16
s370_ERR PROC

; 169  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s370_ERR:

; 170  :     UNREFERENCED( pOp1MemBlk );

  0000a	33 c0		 xor	 eax, eax
  0000c	85 c0		 test	 eax, eax
  0000e	75 fa		 jne	 SHORT $LN4@s370_ERR

; 171  :     pCMPSCBLK->pic = 7;

  00010	b8 07 00 00 00	 mov	 eax, 7
  00015	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0001a	66 89 41 3e	 mov	 WORD PTR [rcx+62], ax

; 172  :     return FALSE;

  0001e	32 c0		 xor	 al, al

; 173  : }

  00020	c3		 ret	 0
s370_ERR ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
scnum$ = 32
ccnum$ = 33
byt$ = 34
eodst$ = 35
parent_index$ = 36
child_index$ = 40
children$ = 44
bits$ = 48
flag$ = 49
sibling_index$ = 52
pPutIndex$ = 56
pPutGetCBN$ = 64
nCPUAmt$ = 72
pBegOp2$ = 80
max_index$ = 88
tv287 = 92
tv303 = 96
tv321 = 100
tv330 = 104
tv355 = 108
tv373 = 112
tv387 = 116
tv393 = 120
tv460 = 124
tv469 = 128
tv563 = 132
tv572 = 136
tv588 = 140
tv600 = 144
tv617 = 148
tv629 = 152
tv641 = 156
tv658 = 160
tv670 = 164
tv692 = 168
tv701 = 172
tv723 = 176
tv791 = 180
tv814 = 184
tv823 = 188
tv866 = 192
tv878 = 196
tv895 = 200
tv921 = 204
tv933 = 208
tv950 = 212
tv259 = 216
tv263 = 220
tv267 = 224
tv273 = 228
op1blk$ = 232
pSymTab$ = 272
tv1105 = 280
op2blk$ = 288
tv129 = 328
tv133 = 336
pGetSD$ = 344
piblk$ = 352
ppPutIndex$ = 384
dctblk$ = 400
dctblk2$ = 688
cceblk$ = 976
sdeblk$ = 263152
sibling$ = 459792
parent$ = 459816
child$ = 459848
wrk$ = 459888
__$ArrayPad$ = 460160
pCMPSCBLK$ = 460208
s370_cmpsc_Compress PROC

; 558  : {

$LN177:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	b8 98 05 07 00	 mov	 eax, 460184		; 00070598H
  0000c	e8 00 00 00 00	 call	 __chkstk
  00011	48 2b e0	 sub	 rsp, rax
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 80
	05 07 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 559  :     U64         nCPUAmt;            // CPU determined processing limit
; 560  :     U64         pBegOp2;            // Ptr to beginning of operand-2
; 561  :     PutGetCBN*  pPutGetCBN;         // Ptr to PutGetCBN function for this CDSS-1
; 562  :     PutIndex**  ppPutIndex;         // Ptr to PutNextIndex table for this CDSS-1
; 563  :     PutIndex*   pPutIndex;          // Ptr to PutNextIndex function for this CBN
; 564  :     U64         pSymTab;            // Symbol-Translation Table
; 565  :     GETSD*      pGetSD;             // Pointer to Get-Sibling-Descriptor function
; 566  :     CCE         parent;             // Parent Compression Character Entry data
; 567  :     CCE         child;              // Child  Compression Character Entry data
; 568  :     SDE         sibling;            // Sibling Descriptor Entry data
; 569  :     MEMBLK      op1blk;             // Operand-1 memory access control block
; 570  :     MEMBLK      op2blk;             // Operand-2 memory access control block
; 571  :     DCTBLK      dctblk;             // GetDCT parameters block  (cmp dict)
; 572  :     DCTBLK      dctblk2;            // GetDCT parameters block  (exp dict)
; 573  :     CCEBLK      cceblk;             // GetCCE parameters block
; 574  :     SDEBLK      sdeblk;             // GetSDn parameters block
; 575  :     PIBLK       piblk;              // PutIndex parameters block
; 576  :     U16         parent_index;       // Parent's CE Index value
; 577  :     U16         child_index;        // Child's CE Index value
; 578  :     U16         sibling_index;      // Sibling's SDE Index value
; 579  :     U16         max_index;          // Maximum Index value
; 580  :     U16         children;           // Counts children
; 581  :     U8          ccnum, scnum, byt;  // (work variables)
; 582  :     U8          eodst, flag;        // (work flags)
; 583  :     U8          bits;               // Number of bits per index
; 584  :     U8          wrk[ MAX_SYMLEN ];  // (work buffer)
; 585  : 
; 586  :     bits       = 8 + pCMPSCBLK->cdss;

  00026	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0002e	0f b6 40 44	 movzx	 eax, BYTE PTR [rax+68]
  00032	83 c0 08	 add	 eax, 8
  00035	88 44 24 30	 mov	 BYTE PTR bits$[rsp], al

; 587  :     max_index  = (0xFFFF >> (16 - bits));

  00039	0f b6 44 24 30	 movzx	 eax, BYTE PTR bits$[rsp]
  0003e	b9 10 00 00 00	 mov	 ecx, 16
  00043	2b c8		 sub	 ecx, eax
  00045	8b c1		 mov	 eax, ecx
  00047	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0004c	89 8c 24 18 01
	00 00		 mov	 DWORD PTR tv1105[rsp], ecx
  00053	0f b6 c8	 movzx	 ecx, al
  00056	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR tv1105[rsp]
  0005d	d3 f8		 sar	 eax, cl
  0005f	66 89 44 24 58	 mov	 WORD PTR max_index$[rsp], ax

; 588  :     pPutGetCBN = ARCH_DEP( PutGetCBNTab    )[ pCMPSCBLK->cdss - 1 ];

  00064	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0006c	0f b6 40 44	 movzx	 eax, BYTE PTR [rax+68]
  00070	ff c8		 dec	 eax
  00072	48 98		 cdqe
  00074	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:s370_PutGetCBNTab
  0007b	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0007f	48 89 44 24 40	 mov	 QWORD PTR pPutGetCBN$[rsp], rax

; 589  :     ppPutIndex = ARCH_DEP( PutIndexCDSSTab )[ pCMPSCBLK->cdss - 1 ];

  00084	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0008c	0f b6 40 44	 movzx	 eax, BYTE PTR [rax+68]
  00090	ff c8		 dec	 eax
  00092	48 98		 cdqe
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:s370_PutIndexCDSSTab
  0009b	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0009f	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR ppPutIndex$[rsp], rax

; 590  :     pPutIndex  = ppPutIndex[ pCMPSCBLK->cbn ];

  000a7	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  000af	0f b6 40 45	 movzx	 eax, BYTE PTR [rax+69]
  000b3	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR ppPutIndex$[rsp]
  000bb	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  000bf	48 89 44 24 38	 mov	 QWORD PTR pPutIndex$[rsp], rax

; 591  :     pSymTab    = pCMPSCBLK->st ? pCMPSCBLK->pDict + ((U32)pCMPSCBLK->stt << 7) : 0;

  000c4	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  000cc	0f b6 40 42	 movzx	 eax, BYTE PTR [rax+66]
  000d0	85 c0		 test	 eax, eax
  000d2	74 27		 je	 SHORT $LN63@s370_cmpsc
  000d4	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  000dc	0f b7 40 3c	 movzx	 eax, WORD PTR [rax+60]
  000e0	c1 e0 07	 shl	 eax, 7
  000e3	8b c0		 mov	 eax, eax
  000e5	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  000ed	48 03 41 30	 add	 rax, QWORD PTR [rcx+48]
  000f1	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv129[rsp], rax
  000f9	eb 0c		 jmp	 SHORT $LN64@s370_cmpsc
$LN63@s370_cmpsc:
  000fb	48 c7 84 24 48
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv129[rsp], 0
$LN64@s370_cmpsc:
  00107	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR tv129[rsp]
  0010f	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR pSymTab$[rsp], rax

; 592  :     pGetSD     = pCMPSCBLK->f1 ? ARCH_DEP( GetSD1 ) : ARCH_DEP( GetSD0 );

  00117	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0011f	0f b6 40 43	 movzx	 eax, BYTE PTR [rax+67]
  00123	85 c0		 test	 eax, eax
  00125	74 11		 je	 SHORT $LN65@s370_cmpsc
  00127	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:s370_GetSD1
  0012e	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv133[rsp], rax
  00136	eb 0f		 jmp	 SHORT $LN66@s370_cmpsc
$LN65@s370_cmpsc:
  00138	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:s370_GetSD0
  0013f	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv133[rsp], rax
$LN66@s370_cmpsc:
  00147	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR tv133[rsp]
  0014f	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR pGetSD$[rsp], rax

; 593  : 
; 594  : #define PUTSETCBN()     pCMPSCBLK->cbn = pPutGetCBN( pPutIndex )
; 595  : 
; 596  :     memset( &dctblk,  0, sizeof( dctblk ) );

  00157	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR dctblk$[rsp]
  0015f	48 8b f8	 mov	 rdi, rax
  00162	33 c0		 xor	 eax, eax
  00164	b9 18 01 00 00	 mov	 ecx, 280		; 00000118H
  00169	f3 aa		 rep stosb

; 597  :     memset( &dctblk2, 0, sizeof( dctblk ) );

  0016b	48 8d 84 24 b0
	02 00 00	 lea	 rax, QWORD PTR dctblk2$[rsp]
  00173	48 8b f8	 mov	 rdi, rax
  00176	33 c0		 xor	 eax, eax
  00178	b9 18 01 00 00	 mov	 ecx, 280		; 00000118H
  0017d	f3 aa		 rep stosb

; 598  : 
; 599  :     dctblk.regs       = pCMPSCBLK->regs;

  0017f	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00187	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0018b	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR dctblk$[rsp], rax

; 600  :     dctblk.arn        = pCMPSCBLK->r2;

  00193	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0019b	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  0019f	89 84 24 a0 02
	00 00		 mov	 DWORD PTR dctblk$[rsp+272], eax

; 601  :     dctblk.pkey       = pCMPSCBLK->regs->psw.pkey;

  001a6	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  001ae	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001b2	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  001b6	88 84 24 a4 02
	00 00		 mov	 BYTE PTR dctblk$[rsp+276], al

; 602  :     dctblk.pDict      = pCMPSCBLK->pDict;

  001bd	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  001c5	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  001c9	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR dctblk$[rsp+8], rax

; 603  : 
; 604  :     dctblk2.regs      = pCMPSCBLK->regs;

  001d1	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  001d9	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001dd	48 89 84 24 b0
	02 00 00	 mov	 QWORD PTR dctblk2$[rsp], rax

; 605  :     dctblk2.arn       = pCMPSCBLK->r2;

  001e5	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  001ed	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  001f1	89 84 24 c0 03
	00 00		 mov	 DWORD PTR dctblk2$[rsp+272], eax

; 606  :     dctblk2.pkey      = pCMPSCBLK->regs->psw.pkey;

  001f8	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00200	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00204	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00208	88 84 24 c4 03
	00 00		 mov	 BYTE PTR dctblk2$[rsp+276], al

; 607  :     dctblk2.pDict     = pCMPSCBLK->pDict + g_nDictSize[ pCMPSCBLK->cdss - 1 ];

  0020f	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00217	0f b6 40 44	 movzx	 eax, BYTE PTR [rax+68]
  0021b	ff c8		 dec	 eax
  0021d	48 98		 cdqe
  0021f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_nDictSize
  00226	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00229	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00231	48 03 41 30	 add	 rax, QWORD PTR [rcx+48]
  00235	48 89 84 24 b8
	02 00 00	 mov	 QWORD PTR dctblk2$[rsp+8], rax

; 608  : 
; 609  :     cceblk.pDCTBLK    = &dctblk;

  0023d	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR dctblk$[rsp]
  00245	48 89 84 24 d0
	03 00 00	 mov	 QWORD PTR cceblk$[rsp], rax

; 610  :     cceblk.max_index  = max_index;

  0024d	0f b7 44 24 58	 movzx	 eax, WORD PTR max_index$[rsp]
  00252	66 89 84 24 e0
	03 00 00	 mov	 WORD PTR cceblk$[rsp+16], ax

; 611  :     cceblk.pCCE       = NULL;           // (filled in before each call)

  0025a	48 c7 84 24 d8
	03 00 00 00 00
	00 00		 mov	 QWORD PTR cceblk$[rsp+8], 0

; 612  : 
; 613  :     memset( &cceblk.cce, 0, sizeof( cceblk.cce ) );

  00266	48 8d 84 24 e8
	03 00 00	 lea	 rax, QWORD PTR cceblk$[rsp+24]
  0026e	48 8b f8	 mov	 rdi, rax
  00271	33 c0		 xor	 eax, eax
  00273	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00278	f3 aa		 rep stosb

; 614  : 
; 615  :     sdeblk.pDCTBLK    = &dctblk;

  0027a	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR dctblk$[rsp]
  00282	48 89 84 24 f0
	03 04 00	 mov	 QWORD PTR sdeblk$[rsp], rax

; 616  :     sdeblk.pDCTBLK2   = &dctblk2;

  0028a	48 8d 84 24 b0
	02 00 00	 lea	 rax, QWORD PTR dctblk2$[rsp]
  00292	48 89 84 24 f8
	03 04 00	 mov	 QWORD PTR sdeblk$[rsp+8], rax

; 617  :     sdeblk.pSDE       = &sibling;

  0029a	48 8d 84 24 10
	04 07 00	 lea	 rax, QWORD PTR sibling$[rsp]
  002a2	48 89 84 24 00
	04 04 00	 mov	 QWORD PTR sdeblk$[rsp+16], rax

; 618  :     sdeblk.pCCE       = NULL;           // (depends if first sibling)

  002aa	48 c7 84 24 08
	04 04 00 00 00
	00 00		 mov	 QWORD PTR sdeblk$[rsp+24], 0

; 619  : 
; 620  :     memset( &sdeblk.sde, 0, sizeof( sdeblk.sde ) );

  002b6	48 8d 84 24 10
	04 04 00	 lea	 rax, QWORD PTR sdeblk$[rsp+32]
  002be	48 8b f8	 mov	 rdi, rax
  002c1	33 c0		 xor	 eax, eax
  002c3	b9 00 00 03 00	 mov	 ecx, 196608		; 00030000H
  002c8	f3 aa		 rep stosb

; 621  : 
; 622  :     piblk.ppPutIndex  = (void**) &pPutIndex;

  002ca	48 8d 44 24 38	 lea	 rax, QWORD PTR pPutIndex$[rsp]
  002cf	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR piblk$[rsp+16], rax

; 623  :     piblk.pCMPSCBLK   = pCMPSCBLK;

  002d7	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  002df	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR piblk$[rsp], rax

; 624  :     piblk.pMEMBLK     = &op1blk;        // (we put indexes into op-1)

  002e7	48 8d 84 24 e8
	00 00 00	 lea	 rax, QWORD PTR op1blk$[rsp]
  002ef	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR piblk$[rsp+8], rax

; 625  :     piblk.index       = 0;              // (filled in before each call)

  002f7	33 c0		 xor	 eax, eax
  002f9	66 89 84 24 78
	01 00 00	 mov	 WORD PTR piblk$[rsp+24], ax

; 626  : 
; 627  :     op1blk.arn        = pCMPSCBLK->r1;

  00301	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00309	0f b6 40 40	 movzx	 eax, BYTE PTR [rax+64]
  0030d	89 84 24 08 01
	00 00		 mov	 DWORD PTR op1blk$[rsp+32], eax

; 628  :     op1blk.regs       = pCMPSCBLK->regs;

  00314	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0031c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00320	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR op1blk$[rsp], rax

; 629  :     op1blk.pkey       = pCMPSCBLK->regs->psw.pkey;

  00328	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00330	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00334	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00338	88 84 24 0c 01
	00 00		 mov	 BYTE PTR op1blk$[rsp+36], al

; 630  :     op1blk.vpagebeg   = 0;

  0033f	48 c7 84 24 f0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR op1blk$[rsp+8], 0

; 631  :     op1blk.maddr[0]   = 0;

  0034b	b8 08 00 00 00	 mov	 eax, 8
  00350	48 6b c0 00	 imul	 rax, rax, 0
  00354	48 c7 84 04 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR op1blk$[rsp+rax+16], 0

; 632  :     op1blk.maddr[1]   = 0;

  00360	b8 08 00 00 00	 mov	 eax, 8
  00365	48 6b c0 01	 imul	 rax, rax, 1
  00369	48 c7 84 04 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR op1blk$[rsp+rax+16], 0

; 633  : 
; 634  :     op2blk.arn        = pCMPSCBLK->r2;

  00375	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0037d	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  00381	89 84 24 40 01
	00 00		 mov	 DWORD PTR op2blk$[rsp+32], eax

; 635  :     op2blk.regs       = pCMPSCBLK->regs;

  00388	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00390	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00394	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR op2blk$[rsp], rax

; 636  :     op2blk.pkey       = pCMPSCBLK->regs->psw.pkey;

  0039c	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  003a4	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  003a8	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  003ac	88 84 24 44 01
	00 00		 mov	 BYTE PTR op2blk$[rsp+36], al

; 637  :     op2blk.vpagebeg   = 0;

  003b3	48 c7 84 24 28
	01 00 00 00 00
	00 00		 mov	 QWORD PTR op2blk$[rsp+8], 0

; 638  :     op2blk.maddr[0]   = 0;

  003bf	b8 08 00 00 00	 mov	 eax, 8
  003c4	48 6b c0 00	 imul	 rax, rax, 0
  003c8	48 c7 84 04 30
	01 00 00 00 00
	00 00		 mov	 QWORD PTR op2blk$[rsp+rax+16], 0

; 639  :     op2blk.maddr[1]   = 0;

  003d4	b8 08 00 00 00	 mov	 eax, 8
  003d9	48 6b c0 01	 imul	 rax, rax, 1
  003dd	48 c7 84 04 30
	01 00 00 00 00
	00 00		 mov	 QWORD PTR op2blk$[rsp+rax+16], 0

; 640  : 
; 641  :     // GET STARTED...
; 642  : 
; 643  :     pBegOp2  =  pCMPSCBLK->pOp2;

  003e9	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  003f1	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  003f5	48 89 44 24 50	 mov	 QWORD PTR pBegOp2$[rsp], rax

; 644  :     eodst    =  (pCMPSCBLK->nLen1 < (2 + ((pCMPSCBLK->cbn > (16 - bits)) ? 1 : 0)))

  003fa	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00402	0f b6 40 45	 movzx	 eax, BYTE PTR [rax+69]
  00406	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR bits$[rsp]
  0040b	ba 10 00 00 00	 mov	 edx, 16
  00410	2b d1		 sub	 edx, ecx
  00412	8b ca		 mov	 ecx, edx
  00414	3b c1		 cmp	 eax, ecx
  00416	7e 0d		 jle	 SHORT $LN67@s370_cmpsc
  00418	c7 84 24 d8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv259[rsp], 1
  00423	eb 0b		 jmp	 SHORT $LN68@s370_cmpsc
$LN67@s370_cmpsc:
  00425	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv259[rsp], 0
$LN68@s370_cmpsc:
  00430	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR tv259[rsp]
  00437	83 c0 02	 add	 eax, 2
  0043a	48 98		 cdqe
  0043c	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00444	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00447	73 0d		 jae	 SHORT $LN69@s370_cmpsc
  00449	c7 84 24 dc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv263[rsp], 1
  00454	eb 0b		 jmp	 SHORT $LN70@s370_cmpsc
$LN69@s370_cmpsc:
  00456	c7 84 24 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv263[rsp], 0
$LN70@s370_cmpsc:
  00461	0f b6 84 24 dc
	00 00 00	 movzx	 eax, BYTE PTR tv263[rsp]
  00469	88 44 24 23	 mov	 BYTE PTR eodst$[rsp], al

; 645  :              ?  TRUE : FALSE;
; 646  :     nCPUAmt  =  0;

  0046d	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR nCPUAmt$[rsp], 0
$LN173@s370_cmpsc:
$cmp1$178:

; 647  : 
; 648  :     //-------------------------------------------------------------------------
; 649  :     // PROGRAMMING NOTE: the following compression algorithm follows exactly
; 650  :     // the algorithm documented by IBM in their Principles of Operation manual.
; 651  :     // Most labels and all primary comments match the algorithm's flowchart.
; 652  :     //-------------------------------------------------------------------------
; 653  : 
; 654  : cmp1:
; 655  : 
; 656  :     // Another SRC char exists?
; 657  :     // No, set CC0 and endop.
; 658  : 
; 659  :     if (unlikely( !pCMPSCBLK->nLen2 ))

  00476	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0047e	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00483	75 0d		 jne	 SHORT $LN71@s370_cmpsc
  00485	c7 84 24 e0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv267[rsp], 1
  00490	eb 0b		 jmp	 SHORT $LN72@s370_cmpsc
$LN71@s370_cmpsc:
  00492	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv267[rsp], 0
$LN72@s370_cmpsc:
  0049d	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR tv267[rsp], 0
  004a5	74 0d		 je	 SHORT $LN75@s370_cmpsc
  004a7	c7 84 24 e4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv273[rsp], 1
  004b2	eb 0b		 jmp	 SHORT $LN76@s370_cmpsc
$LN75@s370_cmpsc:
  004b4	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv273[rsp], 0
$LN76@s370_cmpsc:
  004bf	83 bc 24 e4 00
	00 00 00	 cmp	 DWORD PTR tv273[rsp], 0
  004c7	74 2e		 je	 SHORT $LN8@s370_cmpsc

; 660  :     {
; 661  :         PUTSETCBN();

  004c9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  004ce	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  004d2	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  004da	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 662  :         RETCC0( &op1blk );

  004dd	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  004e5	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  004ed	e8 00 00 00 00	 call	 s370_CC0
  004f2	e9 ad 11 00 00	 jmp	 $LN1@s370_cmpsc
$LN8@s370_cmpsc:
$cmp2$179:

; 663  :     }
; 664  : 
; 665  : cmp2:
; 666  : 
; 667  :     // Another DST index position exists?
; 668  :     // No, set CC1 and endop.
; 669  : 
; 670  :     if (unlikely( eodst ))

  004f7	0f b6 44 24 23	 movzx	 eax, BYTE PTR eodst$[rsp]
  004fc	85 c0		 test	 eax, eax
  004fe	74 0a		 je	 SHORT $LN79@s370_cmpsc
  00500	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv287[rsp], 1
  00508	eb 08		 jmp	 SHORT $LN80@s370_cmpsc
$LN79@s370_cmpsc:
  0050a	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv287[rsp], 0
$LN80@s370_cmpsc:
  00512	83 7c 24 5c 00	 cmp	 DWORD PTR tv287[rsp], 0
  00517	74 2e		 je	 SHORT $LN9@s370_cmpsc

; 671  :     {
; 672  :         PUTSETCBN();

  00519	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  0051e	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  00522	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0052a	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 673  :         RETCC1( &op1blk );

  0052d	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  00535	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0053d	e8 00 00 00 00	 call	 s370_CC1
  00542	e9 5d 11 00 00	 jmp	 $LN1@s370_cmpsc
$LN9@s370_cmpsc:

; 674  :     }
; 675  : 
; 676  :     if (unlikely( nCPUAmt >= (U64) pCMPSCBLK->nCPUAmt ))  // (max bytes processed?)

  00547	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0054f	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00552	48 39 44 24 48	 cmp	 QWORD PTR nCPUAmt$[rsp], rax
  00557	72 0a		 jb	 SHORT $LN83@s370_cmpsc
  00559	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv303[rsp], 1
  00561	eb 08		 jmp	 SHORT $LN84@s370_cmpsc
$LN83@s370_cmpsc:
  00563	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv303[rsp], 0
$LN84@s370_cmpsc:
  0056b	83 7c 24 60 00	 cmp	 DWORD PTR tv303[rsp], 0
  00570	74 2e		 je	 SHORT $LN10@s370_cmpsc

; 677  :     {
; 678  :         PUTSETCBN();

  00572	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  00577	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  0057b	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00583	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 679  :         RETCC3( &op1blk );                                // (return cc3 to caller)

  00586	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  0058e	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00596	e8 00 00 00 00	 call	 s370_CC3
  0059b	e9 04 11 00 00	 jmp	 $LN1@s370_cmpsc
$LN10@s370_cmpsc:

; 680  :     }
; 681  : 
; 682  :     children = 0;

  005a0	33 c0		 xor	 eax, eax
  005a2	66 89 44 24 2c	 mov	 WORD PTR children$[rsp], ax

; 683  : 
; 684  :     // Use next SRC char as index of alphabet entry.
; 685  :     // Call this entry the parent.
; 686  :     // Advance 1 byte in SRC.
; 687  : 
; 688  :     parent_index = (U16) fetch_op_b( pCMPSCBLK->pOp2, &op2blk );

  005a7	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR op2blk$[rsp]
  005af	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  005b7	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  005ba	e8 00 00 00 00	 call	 s370_cmpsc_vfetchb
  005bf	0f b6 c0	 movzx	 eax, al
  005c2	66 89 44 24 24	 mov	 WORD PTR parent_index$[rsp], ax

; 689  : 
; 690  :     cceblk.pCCE = &parent;

  005c7	48 8d 84 24 28
	04 07 00	 lea	 rax, QWORD PTR parent$[rsp]
  005cf	48 89 84 24 d8
	03 00 00	 mov	 QWORD PTR cceblk$[rsp+8], rax

; 691  :     if (unlikely( !ARCH_DEP( GetCCE )( parent_index, &cceblk )))

  005d7	48 8d 94 24 d0
	03 00 00	 lea	 rdx, QWORD PTR cceblk$[rsp]
  005df	0f b7 4c 24 24	 movzx	 ecx, WORD PTR parent_index$[rsp]
  005e4	e8 00 00 00 00	 call	 s370_GetCCE
  005e9	0f b6 c0	 movzx	 eax, al
  005ec	85 c0		 test	 eax, eax
  005ee	75 0a		 jne	 SHORT $LN85@s370_cmpsc
  005f0	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv321[rsp], 1
  005f8	eb 08		 jmp	 SHORT $LN86@s370_cmpsc
$LN85@s370_cmpsc:
  005fa	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv321[rsp], 0
$LN86@s370_cmpsc:
  00602	83 7c 24 64 00	 cmp	 DWORD PTR tv321[rsp], 0
  00607	74 0a		 je	 SHORT $LN89@s370_cmpsc
  00609	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv330[rsp], 1
  00611	eb 08		 jmp	 SHORT $LN90@s370_cmpsc
$LN89@s370_cmpsc:
  00613	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv330[rsp], 0
$LN90@s370_cmpsc:
  0061b	83 7c 24 68 00	 cmp	 DWORD PTR tv330[rsp], 0
  00620	74 2e		 je	 SHORT $LN11@s370_cmpsc

; 692  :     {
; 693  :         PUTSETCBN();

  00622	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  00627	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  0062b	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00633	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 694  :         RETERR( &op1blk );

  00636	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  0063e	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00646	e8 00 00 00 00	 call	 s370_ERR
  0064b	e9 54 10 00 00	 jmp	 $LN1@s370_cmpsc
$LN11@s370_cmpsc:

; 695  :     }
; 696  : 
; 697  :     nCPUAmt++;

  00650	48 8b 44 24 48	 mov	 rax, QWORD PTR nCPUAmt$[rsp]
  00655	48 ff c0	 inc	 rax
  00658	48 89 44 24 48	 mov	 QWORD PTR nCPUAmt$[rsp], rax

; 698  :     pCMPSCBLK->pOp2++;

  0065d	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00665	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00669	48 ff c0	 inc	 rax
  0066c	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00674	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 699  :     pCMPSCBLK->nLen2--;

  00678	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00680	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00684	48 ff c8	 dec	 rax
  00687	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0068f	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
$LN174@s370_cmpsc:
$cmp3$180:
$LN4@s370_cmpsc:

; 700  : 
; 701  : cmp3:
; 702  : 
; 703  :     MEMBLK_BUMP( &op1blk, pCMPSCBLK->pOp1 );

  00693	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR op1blk$[rsp+8]
  0069b	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  006a1	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  006a9	48 39 41 20	 cmp	 QWORD PTR [rcx+32], rax
  006ad	73 0a		 jae	 SHORT $LN93@s370_cmpsc
  006af	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv355[rsp], 1
  006b7	eb 08		 jmp	 SHORT $LN94@s370_cmpsc
$LN93@s370_cmpsc:
  006b9	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv355[rsp], 0
$LN94@s370_cmpsc:
  006c1	83 7c 24 6c 00	 cmp	 DWORD PTR tv355[rsp], 0
  006c6	75 4d		 jne	 SHORT $LN12@s370_cmpsc
  006c8	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR op1blk$[rsp+8]
  006d0	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  006d6	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR op1blk$[rsp+8], rax
  006de	b8 08 00 00 00	 mov	 eax, 8
  006e3	48 6b c0 01	 imul	 rax, rax, 1
  006e7	b9 08 00 00 00	 mov	 ecx, 8
  006ec	48 6b c9 00	 imul	 rcx, rcx, 0
  006f0	48 8b 84 04 f8
	00 00 00	 mov	 rax, QWORD PTR op1blk$[rsp+rax+16]
  006f8	48 89 84 0c f8
	00 00 00	 mov	 QWORD PTR op1blk$[rsp+rcx+16], rax
  00700	b8 08 00 00 00	 mov	 eax, 8
  00705	48 6b c0 01	 imul	 rax, rax, 1
  00709	48 c7 84 04 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR op1blk$[rsp+rax+16], 0
$LN12@s370_cmpsc:
  00715	33 c0		 xor	 eax, eax
  00717	85 c0		 test	 eax, eax
  00719	0f 85 74 ff ff
	ff		 jne	 $LN4@s370_cmpsc
$LN7@s370_cmpsc:

; 704  :     MEMBLK_BUMP( &op2blk, pCMPSCBLK->pOp2 );

  0071f	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR op2blk$[rsp+8]
  00727	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  0072d	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00735	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  00739	73 0a		 jae	 SHORT $LN97@s370_cmpsc
  0073b	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv373[rsp], 1
  00743	eb 08		 jmp	 SHORT $LN98@s370_cmpsc
$LN97@s370_cmpsc:
  00745	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv373[rsp], 0
$LN98@s370_cmpsc:
  0074d	83 7c 24 70 00	 cmp	 DWORD PTR tv373[rsp], 0
  00752	75 4d		 jne	 SHORT $LN13@s370_cmpsc
  00754	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR op2blk$[rsp+8]
  0075c	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  00762	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR op2blk$[rsp+8], rax
  0076a	b8 08 00 00 00	 mov	 eax, 8
  0076f	48 6b c0 01	 imul	 rax, rax, 1
  00773	b9 08 00 00 00	 mov	 ecx, 8
  00778	48 6b c9 00	 imul	 rcx, rcx, 0
  0077c	48 8b 84 04 30
	01 00 00	 mov	 rax, QWORD PTR op2blk$[rsp+rax+16]
  00784	48 89 84 0c 30
	01 00 00	 mov	 QWORD PTR op2blk$[rsp+rcx+16], rax
  0078c	b8 08 00 00 00	 mov	 eax, 8
  00791	48 6b c0 01	 imul	 rax, rax, 1
  00795	48 c7 84 04 30
	01 00 00 00 00
	00 00		 mov	 QWORD PTR op2blk$[rsp+rax+16], 0
$LN13@s370_cmpsc:
  007a1	33 c0		 xor	 eax, eax
  007a3	85 c0		 test	 eax, eax
  007a5	0f 85 74 ff ff
	ff		 jne	 $LN7@s370_cmpsc

; 705  : 
; 706  :     // CCT=0?
; 707  :     // Yes, goto cmp9;
; 708  : 
; 709  :     if (!parent.cct)

  007ab	0f b6 84 24 3e
	04 07 00	 movzx	 eax, BYTE PTR parent$[rsp+22]
  007b3	85 c0		 test	 eax, eax
  007b5	75 05		 jne	 SHORT $LN14@s370_cmpsc

; 710  :         goto cmp9;

  007b7	e9 05 06 00 00	 jmp	 $cmp9$181
$LN14@s370_cmpsc:

; 711  : 
; 712  : //cmp4:
; 713  : 
; 714  :     ccnum = 0;

  007bc	c6 44 24 21 00	 mov	 BYTE PTR ccnum$[rsp], 0

; 715  : 
; 716  :     // Set flag=1.
; 717  : 
; 718  :     flag = TRUE;

  007c1	c6 44 24 31 01	 mov	 BYTE PTR flag$[rsp], 1

; 719  : 
; 720  :     // Another SRC char exists?
; 721  :     // No, goto cmp13;
; 722  : 
; 723  :     if (unlikely( !pCMPSCBLK->nLen2 ))

  007c6	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  007ce	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  007d3	75 0a		 jne	 SHORT $LN99@s370_cmpsc
  007d5	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv387[rsp], 1
  007dd	eb 08		 jmp	 SHORT $LN100@s370_cmpsc
$LN99@s370_cmpsc:
  007df	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv387[rsp], 0
$LN100@s370_cmpsc:
  007e7	83 7c 24 74 00	 cmp	 DWORD PTR tv387[rsp], 0
  007ec	74 0a		 je	 SHORT $LN103@s370_cmpsc
  007ee	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv393[rsp], 1
  007f6	eb 08		 jmp	 SHORT $LN104@s370_cmpsc
$LN103@s370_cmpsc:
  007f8	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv393[rsp], 0
$LN104@s370_cmpsc:
  00800	83 7c 24 78 00	 cmp	 DWORD PTR tv393[rsp], 0
  00805	74 05		 je	 SHORT $LN15@s370_cmpsc

; 724  :         goto cmp13;

  00807	e9 d9 0a 00 00	 jmp	 $cmp13$182
$LN15@s370_cmpsc:
$LN175@s370_cmpsc:
$cmp5$183:

; 725  : 
; 726  :     // (REPEAT FOR EACH CC)...
; 727  : 
; 728  : cmp5:
; 729  : 
; 730  :     // ---------------- UNROLL #1 ----------------
; 731  : 
; 732  :     // Next SRC char = CC?
; 733  :     // Yes, goto cmp10;
; 734  : 
; 735  :     byt = fetch_op_b( pCMPSCBLK->pOp2, &op2blk );

  0080c	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR op2blk$[rsp]
  00814	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0081c	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0081f	e8 00 00 00 00	 call	 s370_cmpsc_vfetchb
  00824	88 44 24 22	 mov	 BYTE PTR byt$[rsp], al

; 736  : 
; 737  :     if (byt == parent.cc[ ccnum ])

  00828	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  0082d	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR ccnum$[rsp]
  00832	0f b6 8c 0c 30
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+rcx+8]
  0083a	3b c1		 cmp	 eax, ecx
  0083c	75 05		 jne	 SHORT $LN16@s370_cmpsc

; 738  :         goto cmp10;

  0083e	e9 a7 06 00 00	 jmp	 $cmp10$184
$LN16@s370_cmpsc:

; 739  : 
; 740  :     // Set flag=0;
; 741  :     flag = FALSE;

  00843	c6 44 24 31 00	 mov	 BYTE PTR flag$[rsp], 0

; 742  : 
; 743  :     // Another CC?
; 744  :     // Yes, goto cmp5;
; 745  : 
; 746  :     if (++ccnum >= parent.cct)

  00848	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  0084d	fe c0		 inc	 al
  0084f	88 44 24 21	 mov	 BYTE PTR ccnum$[rsp], al
  00853	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  00858	0f b6 8c 24 3e
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+22]
  00860	3b c1		 cmp	 eax, ecx
  00862	7c 05		 jl	 SHORT $LN17@s370_cmpsc

; 747  :         goto cmp5E;

  00864	e9 ea 00 00 00	 jmp	 $cmp5E$185
$LN17@s370_cmpsc:

; 748  : 
; 749  :     // ---------------- UNROLL #2 ----------------
; 750  : 
; 751  :     // Next SRC char = CC?
; 752  :     // Yes, goto cmp10;
; 753  : 
; 754  :     if (byt == parent.cc[ ccnum ])

  00869	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  0086e	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR ccnum$[rsp]
  00873	0f b6 8c 0c 30
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+rcx+8]
  0087b	3b c1		 cmp	 eax, ecx
  0087d	75 05		 jne	 SHORT $LN18@s370_cmpsc

; 755  :         goto cmp10;

  0087f	e9 66 06 00 00	 jmp	 $cmp10$184
$LN18@s370_cmpsc:

; 756  : 
; 757  :     // Set flag=0;
; 758  : //  flag = FALSE;   // (already done by UNROLL #1)
; 759  : 
; 760  :     // Another CC?
; 761  :     // Yes, goto cmp5;
; 762  : 
; 763  :     if (++ccnum >= parent.cct)

  00884	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  00889	fe c0		 inc	 al
  0088b	88 44 24 21	 mov	 BYTE PTR ccnum$[rsp], al
  0088f	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  00894	0f b6 8c 24 3e
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+22]
  0089c	3b c1		 cmp	 eax, ecx
  0089e	7c 05		 jl	 SHORT $LN19@s370_cmpsc

; 764  :         goto cmp5E;

  008a0	e9 ae 00 00 00	 jmp	 $cmp5E$185
$LN19@s370_cmpsc:

; 765  : 
; 766  :     // ---------------- UNROLL #3 ----------------
; 767  : 
; 768  :     // Next SRC char = CC?
; 769  :     // Yes, goto cmp10;
; 770  : 
; 771  :     if (byt == parent.cc[ ccnum ])

  008a5	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  008aa	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR ccnum$[rsp]
  008af	0f b6 8c 0c 30
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+rcx+8]
  008b7	3b c1		 cmp	 eax, ecx
  008b9	75 05		 jne	 SHORT $LN20@s370_cmpsc

; 772  :         goto cmp10;

  008bb	e9 2a 06 00 00	 jmp	 $cmp10$184
$LN20@s370_cmpsc:

; 773  : 
; 774  :     // Set flag=0;
; 775  : //  flag = FALSE;   // (already done by UNROLL #1)
; 776  : 
; 777  :     // Another CC?
; 778  :     // Yes, goto cmp5;
; 779  : 
; 780  :     if (++ccnum >= parent.cct)

  008c0	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  008c5	fe c0		 inc	 al
  008c7	88 44 24 21	 mov	 BYTE PTR ccnum$[rsp], al
  008cb	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  008d0	0f b6 8c 24 3e
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+22]
  008d8	3b c1		 cmp	 eax, ecx
  008da	7c 02		 jl	 SHORT $LN21@s370_cmpsc

; 781  :         goto cmp5E;

  008dc	eb 75		 jmp	 SHORT $cmp5E$185
$LN21@s370_cmpsc:

; 782  : 
; 783  :     // ---------------- UNROLL #4 ----------------
; 784  : 
; 785  :     // Next SRC char = CC?
; 786  :     // Yes, goto cmp10;
; 787  : 
; 788  :     if (byt == parent.cc[ ccnum ])

  008de	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  008e3	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR ccnum$[rsp]
  008e8	0f b6 8c 0c 30
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+rcx+8]
  008f0	3b c1		 cmp	 eax, ecx
  008f2	75 05		 jne	 SHORT $LN22@s370_cmpsc

; 789  :         goto cmp10;

  008f4	e9 f1 05 00 00	 jmp	 $cmp10$184
$LN22@s370_cmpsc:

; 790  : 
; 791  :     // Set flag=0;
; 792  : //  flag = FALSE;   // (already done by UNROLL #1)
; 793  : 
; 794  :     // Another CC?
; 795  :     // Yes, goto cmp5;
; 796  : 
; 797  :     if (++ccnum >= parent.cct)

  008f9	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  008fe	fe c0		 inc	 al
  00900	88 44 24 21	 mov	 BYTE PTR ccnum$[rsp], al
  00904	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  00909	0f b6 8c 24 3e
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+22]
  00911	3b c1		 cmp	 eax, ecx
  00913	7c 02		 jl	 SHORT $LN23@s370_cmpsc

; 798  :         goto cmp5E;

  00915	eb 3c		 jmp	 SHORT $cmp5E$185
$LN23@s370_cmpsc:

; 799  : 
; 800  :     // ---------------- UNROLL #5 ----------------
; 801  : 
; 802  :     // Next SRC char = CC?
; 803  :     // Yes, goto cmp10;
; 804  : 
; 805  :     if (byt == parent.cc[ ccnum ])

  00917	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  0091c	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR ccnum$[rsp]
  00921	0f b6 8c 0c 30
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+rcx+8]
  00929	3b c1		 cmp	 eax, ecx
  0092b	75 05		 jne	 SHORT $LN24@s370_cmpsc

; 806  :         goto cmp10;

  0092d	e9 b8 05 00 00	 jmp	 $cmp10$184
$LN24@s370_cmpsc:

; 807  : 
; 808  :     // Set flag=0;
; 809  : //  flag = FALSE;   // (already done by UNROLL #1)
; 810  : 
; 811  :     // Another CC?
; 812  :     // Yes, goto cmp5;
; 813  : 
; 814  :     if (++ccnum < parent.cct)   // (** last UNROLL **)

  00932	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  00937	fe c0		 inc	 al
  00939	88 44 24 21	 mov	 BYTE PTR ccnum$[rsp], al
  0093d	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  00942	0f b6 8c 24 3e
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+22]
  0094a	3b c1		 cmp	 eax, ecx
  0094c	7d 05		 jge	 SHORT $LN25@s370_cmpsc

; 815  :         goto cmp5;

  0094e	e9 b9 fe ff ff	 jmp	 $cmp5$183
$LN25@s370_cmpsc:
$cmp5E$185:

; 816  : 
; 817  : cmp5E:
; 818  : 
; 819  :     // CCT indicates more children?
; 820  :     // No, goto cmp8;
; 821  : 
; 822  :     if (!parent.mc)

  00953	0f b6 84 24 40
	04 07 00	 movzx	 eax, BYTE PTR parent$[rsp+24]
  0095b	85 c0		 test	 eax, eax
  0095d	75 05		 jne	 SHORT $LN26@s370_cmpsc

; 823  :         goto cmp8;

  0095f	e9 34 03 00 00	 jmp	 $cmp8$186
$LN26@s370_cmpsc:

; 824  : 
; 825  : //cmp6:
; 826  : 
; 827  :     // Set SD index = CPTR + #of CC's.
; 828  : 
; 829  :     sibling_index = (parent.cptr + parent.cct);

  00964	0f b7 84 24 38
	04 07 00	 movzx	 eax, WORD PTR parent$[rsp+16]
  0096c	0f b6 8c 24 3e
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+22]
  00974	03 c1		 add	 eax, ecx
  00976	66 89 44 24 34	 mov	 WORD PTR sibling_index$[rsp], ax

; 830  : 
; 831  :     sdeblk.pCCE = &parent;

  0097b	48 8d 84 24 28
	04 07 00	 lea	 rax, QWORD PTR parent$[rsp]
  00983	48 89 84 24 08
	04 04 00	 mov	 QWORD PTR sdeblk$[rsp+24], rax

; 832  :     if (unlikely( !pGetSD( sibling_index, &sdeblk )))

  0098b	48 8d 94 24 f0
	03 04 00	 lea	 rdx, QWORD PTR sdeblk$[rsp]
  00993	0f b7 4c 24 34	 movzx	 ecx, WORD PTR sibling_index$[rsp]
  00998	ff 94 24 58 01
	00 00		 call	 QWORD PTR pGetSD$[rsp]
  0099f	0f b6 c0	 movzx	 eax, al
  009a2	85 c0		 test	 eax, eax
  009a4	75 0a		 jne	 SHORT $LN105@s370_cmpsc
  009a6	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR tv460[rsp], 1
  009ae	eb 08		 jmp	 SHORT $LN106@s370_cmpsc
$LN105@s370_cmpsc:
  009b0	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv460[rsp], 0
$LN106@s370_cmpsc:
  009b8	83 7c 24 7c 00	 cmp	 DWORD PTR tv460[rsp], 0
  009bd	74 0d		 je	 SHORT $LN109@s370_cmpsc
  009bf	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv469[rsp], 1
  009ca	eb 0b		 jmp	 SHORT $LN110@s370_cmpsc
$LN109@s370_cmpsc:
  009cc	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv469[rsp], 0
$LN110@s370_cmpsc:
  009d7	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR tv469[rsp], 0
  009df	74 2e		 je	 SHORT $LN27@s370_cmpsc

; 833  :     {
; 834  :         PUTSETCBN();

  009e1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  009e6	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  009ea	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  009f2	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 835  :         RETERR( &op1blk );

  009f5	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  009fd	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00a05	e8 00 00 00 00	 call	 s370_ERR
  00a0a	e9 95 0c 00 00	 jmp	 $LN1@s370_cmpsc
$LN27@s370_cmpsc:

; 836  :     }
; 837  :     scnum = 0;

  00a0f	c6 44 24 20 00	 mov	 BYTE PTR scnum$[rsp], 0
$LN176@s370_cmpsc:
$cmp7$187:

; 838  : 
; 839  :     // (REPEAT FOR EACH SC IN SD)...
; 840  : 
; 841  : cmp7:
; 842  : 
; 843  :     // ---------------- UNROLL #1 ----------------
; 844  : 
; 845  :     // Next SRC char = SC?
; 846  :     // Yes, goto cmp12;
; 847  : 
; 848  :     byt = fetch_op_b( pCMPSCBLK->pOp2, &op2blk );

  00a14	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR op2blk$[rsp]
  00a1c	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00a24	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00a27	e8 00 00 00 00	 call	 s370_cmpsc_vfetchb
  00a2c	88 44 24 22	 mov	 BYTE PTR byt$[rsp], al

; 849  : 
; 850  :     if (byt == sibling.sc[ scnum ])

  00a30	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  00a35	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR scnum$[rsp]
  00a3a	0f b6 8c 0c 10
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+rcx]
  00a42	3b c1		 cmp	 eax, ecx
  00a44	75 05		 jne	 SHORT $LN28@s370_cmpsc

; 851  :         goto cmp12;

  00a46	e9 c4 06 00 00	 jmp	 $cmp12$188
$LN28@s370_cmpsc:

; 852  : 
; 853  :     // Another SC?
; 854  :     // Yes, goto cmp7;
; 855  : 
; 856  :     if (++scnum >= sibling.sct)

  00a4b	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00a50	fe c0		 inc	 al
  00a52	88 44 24 20	 mov	 BYTE PTR scnum$[rsp], al
  00a56	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00a5b	0f b6 8c 24 22
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+18]
  00a63	3b c1		 cmp	 eax, ecx
  00a65	7c 05		 jl	 SHORT $LN29@s370_cmpsc

; 857  :         goto cmp7E;

  00a67	e9 62 01 00 00	 jmp	 $cmp7E$189
$LN29@s370_cmpsc:

; 858  : 
; 859  :     // ---------------- UNROLL #2 ----------------
; 860  : 
; 861  :     // Next SRC char = SC?
; 862  :     // Yes, goto cmp12;
; 863  : 
; 864  :     if (byt == sibling.sc[ scnum ])

  00a6c	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  00a71	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR scnum$[rsp]
  00a76	0f b6 8c 0c 10
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+rcx]
  00a7e	3b c1		 cmp	 eax, ecx
  00a80	75 05		 jne	 SHORT $LN30@s370_cmpsc

; 865  :         goto cmp12;

  00a82	e9 88 06 00 00	 jmp	 $cmp12$188
$LN30@s370_cmpsc:

; 866  : 
; 867  :     // Another SC?
; 868  :     // Yes, goto cmp7;
; 869  : 
; 870  :     if (++scnum >= sibling.sct)

  00a87	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00a8c	fe c0		 inc	 al
  00a8e	88 44 24 20	 mov	 BYTE PTR scnum$[rsp], al
  00a92	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00a97	0f b6 8c 24 22
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+18]
  00a9f	3b c1		 cmp	 eax, ecx
  00aa1	7c 05		 jl	 SHORT $LN31@s370_cmpsc

; 871  :         goto cmp7E;

  00aa3	e9 26 01 00 00	 jmp	 $cmp7E$189
$LN31@s370_cmpsc:

; 872  : 
; 873  :     // ---------------- UNROLL #3 ----------------
; 874  : 
; 875  :     // Next SRC char = SC?
; 876  :     // Yes, goto cmp12;
; 877  : 
; 878  :     if (byt == sibling.sc[ scnum ])

  00aa8	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  00aad	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR scnum$[rsp]
  00ab2	0f b6 8c 0c 10
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+rcx]
  00aba	3b c1		 cmp	 eax, ecx
  00abc	75 05		 jne	 SHORT $LN32@s370_cmpsc

; 879  :         goto cmp12;

  00abe	e9 4c 06 00 00	 jmp	 $cmp12$188
$LN32@s370_cmpsc:

; 880  : 
; 881  :     // Another SC?
; 882  :     // Yes, goto cmp7;
; 883  : 
; 884  :     if (++scnum >= sibling.sct)

  00ac3	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00ac8	fe c0		 inc	 al
  00aca	88 44 24 20	 mov	 BYTE PTR scnum$[rsp], al
  00ace	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00ad3	0f b6 8c 24 22
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+18]
  00adb	3b c1		 cmp	 eax, ecx
  00add	7c 05		 jl	 SHORT $LN33@s370_cmpsc

; 885  :         goto cmp7E;

  00adf	e9 ea 00 00 00	 jmp	 $cmp7E$189
$LN33@s370_cmpsc:

; 886  : 
; 887  :     // ---------------- UNROLL #4 ----------------
; 888  : 
; 889  :     // Next SRC char = SC?
; 890  :     // Yes, goto cmp12;
; 891  : 
; 892  :     if (byt == sibling.sc[ scnum ])

  00ae4	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  00ae9	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR scnum$[rsp]
  00aee	0f b6 8c 0c 10
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+rcx]
  00af6	3b c1		 cmp	 eax, ecx
  00af8	75 05		 jne	 SHORT $LN34@s370_cmpsc

; 893  :         goto cmp12;

  00afa	e9 10 06 00 00	 jmp	 $cmp12$188
$LN34@s370_cmpsc:

; 894  : 
; 895  :     // Another SC?
; 896  :     // Yes, goto cmp7;
; 897  : 
; 898  :     if (++scnum >= sibling.sct)

  00aff	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00b04	fe c0		 inc	 al
  00b06	88 44 24 20	 mov	 BYTE PTR scnum$[rsp], al
  00b0a	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00b0f	0f b6 8c 24 22
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+18]
  00b17	3b c1		 cmp	 eax, ecx
  00b19	7c 05		 jl	 SHORT $LN35@s370_cmpsc

; 899  :         goto cmp7E;

  00b1b	e9 ae 00 00 00	 jmp	 $cmp7E$189
$LN35@s370_cmpsc:

; 900  : 
; 901  :     // ---------------- UNROLL #5 ----------------
; 902  : 
; 903  :     // Next SRC char = SC?
; 904  :     // Yes, goto cmp12;
; 905  : 
; 906  :     if (byt == sibling.sc[ scnum ])

  00b20	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  00b25	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR scnum$[rsp]
  00b2a	0f b6 8c 0c 10
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+rcx]
  00b32	3b c1		 cmp	 eax, ecx
  00b34	75 05		 jne	 SHORT $LN36@s370_cmpsc

; 907  :         goto cmp12;

  00b36	e9 d4 05 00 00	 jmp	 $cmp12$188
$LN36@s370_cmpsc:

; 908  : 
; 909  :     // Another SC?
; 910  :     // Yes, goto cmp7;
; 911  : 
; 912  :     if (++scnum >= sibling.sct)

  00b3b	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00b40	fe c0		 inc	 al
  00b42	88 44 24 20	 mov	 BYTE PTR scnum$[rsp], al
  00b46	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00b4b	0f b6 8c 24 22
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+18]
  00b53	3b c1		 cmp	 eax, ecx
  00b55	7c 02		 jl	 SHORT $LN37@s370_cmpsc

; 913  :         goto cmp7E;

  00b57	eb 75		 jmp	 SHORT $cmp7E$189
$LN37@s370_cmpsc:

; 914  : 
; 915  :     // ---------------- UNROLL #6 ----------------
; 916  : 
; 917  :     // Next SRC char = SC?
; 918  :     // Yes, goto cmp12;
; 919  : 
; 920  :     if (byt == sibling.sc[ scnum ])

  00b59	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  00b5e	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR scnum$[rsp]
  00b63	0f b6 8c 0c 10
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+rcx]
  00b6b	3b c1		 cmp	 eax, ecx
  00b6d	75 05		 jne	 SHORT $LN38@s370_cmpsc

; 921  :         goto cmp12;

  00b6f	e9 9b 05 00 00	 jmp	 $cmp12$188
$LN38@s370_cmpsc:

; 922  : 
; 923  :     // Another SC?
; 924  :     // Yes, goto cmp7;
; 925  : 
; 926  :     if (++scnum >= sibling.sct)

  00b74	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00b79	fe c0		 inc	 al
  00b7b	88 44 24 20	 mov	 BYTE PTR scnum$[rsp], al
  00b7f	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00b84	0f b6 8c 24 22
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+18]
  00b8c	3b c1		 cmp	 eax, ecx
  00b8e	7c 02		 jl	 SHORT $LN39@s370_cmpsc

; 927  :         goto cmp7E;

  00b90	eb 3c		 jmp	 SHORT $cmp7E$189
$LN39@s370_cmpsc:

; 928  : 
; 929  :     // ---------------- UNROLL #7 ----------------
; 930  : 
; 931  :     // Next SRC char = SC?
; 932  :     // Yes, goto cmp12;
; 933  : 
; 934  :     if (byt == sibling.sc[ scnum ])

  00b92	0f b6 44 24 22	 movzx	 eax, BYTE PTR byt$[rsp]
  00b97	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR scnum$[rsp]
  00b9c	0f b6 8c 0c 10
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+rcx]
  00ba4	3b c1		 cmp	 eax, ecx
  00ba6	75 05		 jne	 SHORT $LN40@s370_cmpsc

; 935  :         goto cmp12;

  00ba8	e9 62 05 00 00	 jmp	 $cmp12$188
$LN40@s370_cmpsc:

; 936  : 
; 937  :     // Another SC?
; 938  :     // Yes, goto cmp7;
; 939  : 
; 940  :     if (++scnum < sibling.sct)  // (** last UNROLL **)

  00bad	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00bb2	fe c0		 inc	 al
  00bb4	88 44 24 20	 mov	 BYTE PTR scnum$[rsp], al
  00bb8	0f b6 44 24 20	 movzx	 eax, BYTE PTR scnum$[rsp]
  00bbd	0f b6 8c 24 22
	04 07 00	 movzx	 ecx, BYTE PTR sibling$[rsp+18]
  00bc5	3b c1		 cmp	 eax, ecx
  00bc7	7d 05		 jge	 SHORT $LN41@s370_cmpsc

; 941  :         goto cmp7;

  00bc9	e9 46 fe ff ff	 jmp	 $cmp7$187
$LN41@s370_cmpsc:
$cmp7E$189:

; 942  : 
; 943  : cmp7E:
; 944  : 
; 945  :     // SCT indicates more children?
; 946  :     // No, goto cmp8;
; 947  : 
; 948  :     if (!sibling.ms)

  00bce	0f b6 84 24 23
	04 07 00	 movzx	 eax, BYTE PTR sibling$[rsp+19]
  00bd6	85 c0		 test	 eax, eax
  00bd8	75 05		 jne	 SHORT $LN42@s370_cmpsc

; 949  :         goto cmp8;

  00bda	e9 b9 00 00 00	 jmp	 $cmp8$186
$LN42@s370_cmpsc:

; 950  : 
; 951  :     // Set SD index = current SD index + #of SC's + 1.
; 952  : 
; 953  :     sibling_index += sibling.sct + 1;

  00bdf	0f b6 84 24 22
	04 07 00	 movzx	 eax, BYTE PTR sibling$[rsp+18]
  00be7	0f b7 4c 24 34	 movzx	 ecx, WORD PTR sibling_index$[rsp]
  00bec	8d 44 01 01	 lea	 eax, DWORD PTR [rcx+rax+1]
  00bf0	66 89 44 24 34	 mov	 WORD PTR sibling_index$[rsp], ax

; 954  : 
; 955  :     sdeblk.pCCE = NULL;

  00bf5	48 c7 84 24 08
	04 04 00 00 00
	00 00		 mov	 QWORD PTR sdeblk$[rsp+24], 0

; 956  :     if (unlikely( !pGetSD( sibling_index, &sdeblk )))

  00c01	48 8d 94 24 f0
	03 04 00	 lea	 rdx, QWORD PTR sdeblk$[rsp]
  00c09	0f b7 4c 24 34	 movzx	 ecx, WORD PTR sibling_index$[rsp]
  00c0e	ff 94 24 58 01
	00 00		 call	 QWORD PTR pGetSD$[rsp]
  00c15	0f b6 c0	 movzx	 eax, al
  00c18	85 c0		 test	 eax, eax
  00c1a	75 0d		 jne	 SHORT $LN111@s370_cmpsc
  00c1c	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv563[rsp], 1
  00c27	eb 0b		 jmp	 SHORT $LN112@s370_cmpsc
$LN111@s370_cmpsc:
  00c29	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv563[rsp], 0
$LN112@s370_cmpsc:
  00c34	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR tv563[rsp], 0
  00c3c	74 0d		 je	 SHORT $LN115@s370_cmpsc
  00c3e	c7 84 24 88 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv572[rsp], 1
  00c49	eb 0b		 jmp	 SHORT $LN116@s370_cmpsc
$LN115@s370_cmpsc:
  00c4b	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv572[rsp], 0
$LN116@s370_cmpsc:
  00c56	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR tv572[rsp], 0
  00c5e	74 2e		 je	 SHORT $LN43@s370_cmpsc

; 957  :     {
; 958  :         PUTSETCBN();

  00c60	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  00c65	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  00c69	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00c71	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 959  :         RETERR( &op1blk );

  00c74	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  00c7c	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00c84	e8 00 00 00 00	 call	 s370_ERR
  00c89	e9 16 0a 00 00	 jmp	 $LN1@s370_cmpsc
$LN43@s370_cmpsc:

; 960  :     }
; 961  :     scnum = 0;

  00c8e	c6 44 24 20 00	 mov	 BYTE PTR scnum$[rsp], 0

; 962  : 
; 963  :     // goto cmp7;
; 964  : 
; 965  :     goto cmp7;

  00c93	e9 7c fd ff ff	 jmp	 $LN176@s370_cmpsc
$cmp8$186:

; 966  : 
; 967  : cmp8:
; 968  : 
; 969  :     // Store parent index in DST.
; 970  :     // Advance 1 index in DST.
; 971  :     // goto cmp2;
; 972  : 
; 973  :     if (unlikely( (pCMPSCBLK->pOp2 - pBegOp2) > MAX_SYMLEN ))

  00c98	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00ca0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pBegOp2$[rsp]
  00ca5	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00ca9	48 2b c1	 sub	 rax, rcx
  00cac	48 3d 04 01 00
	00		 cmp	 rax, 260		; 00000104H
  00cb2	76 0d		 jbe	 SHORT $LN119@s370_cmpsc
  00cb4	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv588[rsp], 1
  00cbf	eb 0b		 jmp	 SHORT $LN120@s370_cmpsc
$LN119@s370_cmpsc:
  00cc1	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv588[rsp], 0
$LN120@s370_cmpsc:
  00ccc	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR tv588[rsp], 0
  00cd4	74 2e		 je	 SHORT $LN44@s370_cmpsc

; 974  :     {
; 975  :         PUTSETCBN();

  00cd6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  00cdb	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  00cdf	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00ce7	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 976  :         RETERR( &op1blk );

  00cea	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  00cf2	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00cfa	e8 00 00 00 00	 call	 s370_ERR
  00cff	e9 a0 09 00 00	 jmp	 $LN1@s370_cmpsc
$LN44@s370_cmpsc:

; 977  :     }
; 978  :     pBegOp2  =  pCMPSCBLK->pOp2;

  00d04	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00d0c	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00d10	48 89 44 24 50	 mov	 QWORD PTR pBegOp2$[rsp], rax

; 979  : 
; 980  :     piblk.index = (!pCMPSCBLK->st) ? parent_index

  00d15	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00d1d	0f b6 40 42	 movzx	 eax, BYTE PTR [rax+66]
  00d21	85 c0		 test	 eax, eax
  00d23	75 0d		 jne	 SHORT $LN121@s370_cmpsc
  00d25	c7 84 24 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv600[rsp], 1
  00d30	eb 0b		 jmp	 SHORT $LN122@s370_cmpsc
$LN121@s370_cmpsc:
  00d32	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv600[rsp], 0
$LN122@s370_cmpsc:
  00d3d	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR tv600[rsp], 0
  00d45	74 0e		 je	 SHORT $LN123@s370_cmpsc
  00d47	0f b7 44 24 24	 movzx	 eax, WORD PTR parent_index$[rsp]
  00d4c	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv617[rsp], eax
  00d53	eb 47		 jmp	 SHORT $LN124@s370_cmpsc
$LN123@s370_cmpsc:
  00d55	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00d5d	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  00d61	0f b7 4c 24 24	 movzx	 ecx, WORD PTR parent_index$[rsp]
  00d66	d1 e1		 shl	 ecx, 1
  00d68	48 63 c9	 movsxd	 rcx, ecx
  00d6b	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR pSymTab$[rsp]
  00d73	48 03 d1	 add	 rdx, rcx
  00d76	48 8b ca	 mov	 rcx, rdx
  00d79	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  00d7f	48 8b 94 24 b0
	05 07 00	 mov	 rdx, QWORD PTR pCMPSCBLK$[rsp]
  00d87	4c 8b 42 18	 mov	 r8, QWORD PTR [rdx+24]
  00d8b	8b d0		 mov	 edx, eax
  00d8d	e8 00 00 00 00	 call	 s370_vfetch2
  00d92	0f b7 c0	 movzx	 eax, ax
  00d95	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv617[rsp], eax
$LN124@s370_cmpsc:
  00d9c	0f b7 84 24 94
	00 00 00	 movzx	 eax, WORD PTR tv617[rsp]
  00da4	66 89 84 24 78
	01 00 00	 mov	 WORD PTR piblk$[rsp+24], ax

; 981  :           : fetch_dct_hw( pSymTab + (parent_index << 1), pCMPSCBLK );
; 982  :     eodst = pPutIndex( &piblk );

  00dac	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR piblk$[rsp]
  00db4	ff 54 24 38	 call	 QWORD PTR pPutIndex$[rsp]
  00db8	88 44 24 23	 mov	 BYTE PTR eodst$[rsp], al

; 983  :     goto cmp2;

  00dbc	e9 36 f7 ff ff	 jmp	 $cmp2$179
$cmp9$181:

; 984  : 
; 985  : cmp9:
; 986  : 
; 987  :     // Store parent index in DST.
; 988  :     // Advance 1 index in DST.
; 989  :     // goto cmp1;
; 990  : 
; 991  :     if (unlikely( (pCMPSCBLK->pOp2 - pBegOp2) > MAX_SYMLEN ))

  00dc1	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00dc9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pBegOp2$[rsp]
  00dce	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00dd2	48 2b c1	 sub	 rax, rcx
  00dd5	48 3d 04 01 00
	00		 cmp	 rax, 260		; 00000104H
  00ddb	76 0d		 jbe	 SHORT $LN127@s370_cmpsc
  00ddd	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv629[rsp], 1
  00de8	eb 0b		 jmp	 SHORT $LN128@s370_cmpsc
$LN127@s370_cmpsc:
  00dea	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv629[rsp], 0
$LN128@s370_cmpsc:
  00df5	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR tv629[rsp], 0
  00dfd	74 2e		 je	 SHORT $LN45@s370_cmpsc

; 992  :     {
; 993  :         PUTSETCBN();

  00dff	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  00e04	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  00e08	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00e10	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 994  :         RETERR( &op1blk );

  00e13	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  00e1b	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00e23	e8 00 00 00 00	 call	 s370_ERR
  00e28	e9 77 08 00 00	 jmp	 $LN1@s370_cmpsc
$LN45@s370_cmpsc:

; 995  :     }
; 996  :     pBegOp2  =  pCMPSCBLK->pOp2;

  00e2d	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00e35	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00e39	48 89 44 24 50	 mov	 QWORD PTR pBegOp2$[rsp], rax

; 997  : 
; 998  :     piblk.index = (!pCMPSCBLK->st) ? parent_index

  00e3e	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00e46	0f b6 40 42	 movzx	 eax, BYTE PTR [rax+66]
  00e4a	85 c0		 test	 eax, eax
  00e4c	75 0d		 jne	 SHORT $LN129@s370_cmpsc
  00e4e	c7 84 24 9c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv641[rsp], 1
  00e59	eb 0b		 jmp	 SHORT $LN130@s370_cmpsc
$LN129@s370_cmpsc:
  00e5b	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv641[rsp], 0
$LN130@s370_cmpsc:
  00e66	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR tv641[rsp], 0
  00e6e	74 0e		 je	 SHORT $LN131@s370_cmpsc
  00e70	0f b7 44 24 24	 movzx	 eax, WORD PTR parent_index$[rsp]
  00e75	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv658[rsp], eax
  00e7c	eb 47		 jmp	 SHORT $LN132@s370_cmpsc
$LN131@s370_cmpsc:
  00e7e	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00e86	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  00e8a	0f b7 4c 24 24	 movzx	 ecx, WORD PTR parent_index$[rsp]
  00e8f	d1 e1		 shl	 ecx, 1
  00e91	48 63 c9	 movsxd	 rcx, ecx
  00e94	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR pSymTab$[rsp]
  00e9c	48 03 d1	 add	 rdx, rcx
  00e9f	48 8b ca	 mov	 rcx, rdx
  00ea2	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  00ea8	48 8b 94 24 b0
	05 07 00	 mov	 rdx, QWORD PTR pCMPSCBLK$[rsp]
  00eb0	4c 8b 42 18	 mov	 r8, QWORD PTR [rdx+24]
  00eb4	8b d0		 mov	 edx, eax
  00eb6	e8 00 00 00 00	 call	 s370_vfetch2
  00ebb	0f b7 c0	 movzx	 eax, ax
  00ebe	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv658[rsp], eax
$LN132@s370_cmpsc:
  00ec5	0f b7 84 24 a0
	00 00 00	 movzx	 eax, WORD PTR tv658[rsp]
  00ecd	66 89 84 24 78
	01 00 00	 mov	 WORD PTR piblk$[rsp+24], ax

; 999  :           : fetch_dct_hw( pSymTab + (parent_index << 1), pCMPSCBLK );
; 1000 :     eodst = pPutIndex( &piblk );

  00ed5	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR piblk$[rsp]
  00edd	ff 54 24 38	 call	 QWORD PTR pPutIndex$[rsp]
  00ee1	88 44 24 23	 mov	 BYTE PTR eodst$[rsp], al

; 1001 :     goto cmp1;

  00ee5	e9 8c f5 ff ff	 jmp	 $cmp1$178
$cmp10$184:

; 1002 : 
; 1003 : cmp10:
; 1004 : 
; 1005 :     if (unlikely( ++children > MAX_CHILDREN ))

  00eea	0f b7 44 24 2c	 movzx	 eax, WORD PTR children$[rsp]
  00eef	66 ff c0	 inc	 ax
  00ef2	66 89 44 24 2c	 mov	 WORD PTR children$[rsp], ax
  00ef7	0f b7 44 24 2c	 movzx	 eax, WORD PTR children$[rsp]
  00efc	3d 04 01 00 00	 cmp	 eax, 260		; 00000104H
  00f01	7e 0d		 jle	 SHORT $LN135@s370_cmpsc
  00f03	c7 84 24 a4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv670[rsp], 1
  00f0e	eb 0b		 jmp	 SHORT $LN136@s370_cmpsc
$LN135@s370_cmpsc:
  00f10	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv670[rsp], 0
$LN136@s370_cmpsc:
  00f1b	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR tv670[rsp], 0
  00f23	74 2e		 je	 SHORT $LN46@s370_cmpsc

; 1006 :     {
; 1007 :         PUTSETCBN();

  00f25	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  00f2a	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  00f2e	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00f36	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 1008 :         RETERR( &op1blk );

  00f39	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  00f41	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00f49	e8 00 00 00 00	 call	 s370_ERR
  00f4e	e9 51 07 00 00	 jmp	 $LN1@s370_cmpsc
$LN46@s370_cmpsc:

; 1009 :     }
; 1010 : 
; 1011 :     // Set child index = CPTR + CC number (0-origin numbering).
; 1012 : 
; 1013 :     child_index = parent.cptr + ccnum;

  00f53	0f b7 84 24 38
	04 07 00	 movzx	 eax, WORD PTR parent$[rsp+16]
  00f5b	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR ccnum$[rsp]
  00f60	03 c1		 add	 eax, ecx
  00f62	66 89 44 24 28	 mov	 WORD PTR child_index$[rsp], ax

; 1014 : 
; 1015 :     // X=1 for child?
; 1016 :     // No, goto cmp14;
; 1017 : 
; 1018 :     if (!(parent.ecb & (0x8000 >> ccnum)))

  00f67	0f b7 84 24 3a
	04 07 00	 movzx	 eax, WORD PTR parent$[rsp+18]
  00f6f	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR ccnum$[rsp]
  00f74	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  00f79	d3 fa		 sar	 edx, cl
  00f7b	8b ca		 mov	 ecx, edx
  00f7d	23 c1		 and	 eax, ecx
  00f7f	85 c0		 test	 eax, eax
  00f81	75 05		 jne	 SHORT $LN47@s370_cmpsc

; 1019 :         goto cmp14;

  00f83	e9 ab 04 00 00	 jmp	 $cmp14$190
$LN47@s370_cmpsc:

; 1020 : 
; 1021 :     // ACT=0 or D=0 in child?
; 1022 :     // Yes, goto cmp15;
; 1023 : 
; 1024 :     cceblk.pCCE = &child;

  00f88	48 8d 84 24 48
	04 07 00	 lea	 rax, QWORD PTR child$[rsp]
  00f90	48 89 84 24 d8
	03 00 00	 mov	 QWORD PTR cceblk$[rsp+8], rax

; 1025 :     if (unlikely( !ARCH_DEP( GetCCE )( child_index, &cceblk )))

  00f98	48 8d 94 24 d0
	03 00 00	 lea	 rdx, QWORD PTR cceblk$[rsp]
  00fa0	0f b7 4c 24 28	 movzx	 ecx, WORD PTR child_index$[rsp]
  00fa5	e8 00 00 00 00	 call	 s370_GetCCE
  00faa	0f b6 c0	 movzx	 eax, al
  00fad	85 c0		 test	 eax, eax
  00faf	75 0d		 jne	 SHORT $LN137@s370_cmpsc
  00fb1	c7 84 24 a8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv692[rsp], 1
  00fbc	eb 0b		 jmp	 SHORT $LN138@s370_cmpsc
$LN137@s370_cmpsc:
  00fbe	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv692[rsp], 0
$LN138@s370_cmpsc:
  00fc9	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR tv692[rsp], 0
  00fd1	74 0d		 je	 SHORT $LN141@s370_cmpsc
  00fd3	c7 84 24 ac 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv701[rsp], 1
  00fde	eb 0b		 jmp	 SHORT $LN142@s370_cmpsc
$LN141@s370_cmpsc:
  00fe0	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv701[rsp], 0
$LN142@s370_cmpsc:
  00feb	83 bc 24 ac 00
	00 00 00	 cmp	 DWORD PTR tv701[rsp], 0
  00ff3	74 2e		 je	 SHORT $LN48@s370_cmpsc

; 1026 :     {
; 1027 :         PUTSETCBN();

  00ff5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  00ffa	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  00ffe	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01006	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 1028 :         RETERR( &op1blk );

  01009	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  01011	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01019	e8 00 00 00 00	 call	 s370_ERR
  0101e	e9 81 06 00 00	 jmp	 $LN1@s370_cmpsc
$LN48@s370_cmpsc:

; 1029 :     }
; 1030 : 
; 1031 :     if (!child.act)

  01023	0f b6 84 24 5f
	04 07 00	 movzx	 eax, BYTE PTR child$[rsp+23]
  0102b	85 c0		 test	 eax, eax
  0102d	75 05		 jne	 SHORT $LN49@s370_cmpsc

; 1032 :         goto cmp15;

  0102f	e9 6b 05 00 00	 jmp	 $cmp15$191
$LN49@s370_cmpsc:

; 1033 : 
; 1034 :     // (compare SRC chars after next char to AEC's in child)...
; 1035 : 
; 1036 :     // Enough SRC chars for comparison?
; 1037 :     // No, goto cmp11;
; 1038 : 
; 1039 :     if (unlikely( pCMPSCBLK->nLen2 < (U64)(1 + child.act)))

  01034	0f b6 84 24 5f
	04 07 00	 movzx	 eax, BYTE PTR child$[rsp+23]
  0103c	ff c0		 inc	 eax
  0103e	48 98		 cdqe
  01040	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01048	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  0104c	73 0d		 jae	 SHORT $LN145@s370_cmpsc
  0104e	c7 84 24 b0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv723[rsp], 1
  01059	eb 0b		 jmp	 SHORT $LN146@s370_cmpsc
$LN145@s370_cmpsc:
  0105b	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv723[rsp], 0
$LN146@s370_cmpsc:
  01066	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR tv723[rsp], 0
  0106e	74 02		 je	 SHORT $LN50@s370_cmpsc

; 1040 :         goto cmp11;

  01070	eb 69		 jmp	 SHORT $cmp11$192
$LN50@s370_cmpsc:

; 1041 : 
; 1042 :     // Chars equal?
; 1043 :     // Yes, goto cmp16;
; 1044 : 
; 1045 :     fetch_op_str( wrk, child.act-1, pCMPSCBLK->pOp2 + 1, &op2blk );

  01072	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0107a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0107e	48 ff c0	 inc	 rax
  01081	0f b6 8c 24 5f
	04 07 00	 movzx	 ecx, BYTE PTR child$[rsp+23]
  01089	ff c9		 dec	 ecx
  0108b	4c 8d 8c 24 20
	01 00 00	 lea	 r9, QWORD PTR op2blk$[rsp]
  01093	44 8b c0	 mov	 r8d, eax
  01096	0f b7 d1	 movzx	 edx, cx
  01099	48 8d 8c 24 70
	04 07 00	 lea	 rcx, QWORD PTR wrk$[rsp]
  010a1	e8 00 00 00 00	 call	 s370_cmpsc_vfetchc

; 1046 : 
; 1047 :     if (memcmp( wrk, &child.ec[0], child.act ) == 0)

  010a6	0f b6 84 24 5f
	04 07 00	 movzx	 eax, BYTE PTR child$[rsp+23]
  010ae	b9 01 00 00 00	 mov	 ecx, 1
  010b3	48 6b c9 00	 imul	 rcx, rcx, 0
  010b7	48 8d 8c 0c 48
	04 07 00	 lea	 rcx, QWORD PTR child$[rsp+rcx]
  010bf	44 8b c0	 mov	 r8d, eax
  010c2	48 8b d1	 mov	 rdx, rcx
  010c5	48 8d 8c 24 70
	04 07 00	 lea	 rcx, QWORD PTR wrk$[rsp]
  010cd	e8 00 00 00 00	 call	 memcmp
  010d2	85 c0		 test	 eax, eax
  010d4	75 05		 jne	 SHORT $LN51@s370_cmpsc

; 1048 :         goto cmp16;

  010d6	e9 33 05 00 00	 jmp	 $cmp16$193
$LN51@s370_cmpsc:
$cmp11$192:

; 1049 : 
; 1050 : cmp11:
; 1051 : 
; 1052 :     // Flag=1?
; 1053 :     // No, goto cmp8;
; 1054 : 
; 1055 :     if (!flag)

  010db	0f b6 44 24 31	 movzx	 eax, BYTE PTR flag$[rsp]
  010e0	85 c0		 test	 eax, eax
  010e2	75 05		 jne	 SHORT $LN52@s370_cmpsc

; 1056 :         goto cmp8;

  010e4	e9 af fb ff ff	 jmp	 $cmp8$186
$LN52@s370_cmpsc:

; 1057 : 
; 1058 :     // Another CC?
; 1059 :     // No, goto cmp8;
; 1060 : 
; 1061 :     if (++ccnum >= parent.cct)

  010e9	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  010ee	fe c0		 inc	 al
  010f0	88 44 24 21	 mov	 BYTE PTR ccnum$[rsp], al
  010f4	0f b6 44 24 21	 movzx	 eax, BYTE PTR ccnum$[rsp]
  010f9	0f b6 8c 24 3e
	04 07 00	 movzx	 ecx, BYTE PTR parent$[rsp+22]
  01101	3b c1		 cmp	 eax, ecx
  01103	7c 05		 jl	 SHORT $LN53@s370_cmpsc

; 1062 :         goto cmp8;

  01105	e9 8e fb ff ff	 jmp	 $cmp8$186
$LN53@s370_cmpsc:

; 1063 : 
; 1064 :     // goto cmp5;
; 1065 : 
; 1066 :     goto cmp5;

  0110a	e9 fd f6 ff ff	 jmp	 $LN175@s370_cmpsc
$cmp12$188:

; 1067 : 
; 1068 : cmp12:
; 1069 : 
; 1070 :     if (unlikely( ++children > MAX_CHILDREN ))

  0110f	0f b7 44 24 2c	 movzx	 eax, WORD PTR children$[rsp]
  01114	66 ff c0	 inc	 ax
  01117	66 89 44 24 2c	 mov	 WORD PTR children$[rsp], ax
  0111c	0f b7 44 24 2c	 movzx	 eax, WORD PTR children$[rsp]
  01121	3d 04 01 00 00	 cmp	 eax, 260		; 00000104H
  01126	7e 0d		 jle	 SHORT $LN149@s370_cmpsc
  01128	c7 84 24 b4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv791[rsp], 1
  01133	eb 0b		 jmp	 SHORT $LN150@s370_cmpsc
$LN149@s370_cmpsc:
  01135	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv791[rsp], 0
$LN150@s370_cmpsc:
  01140	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR tv791[rsp], 0
  01148	74 2e		 je	 SHORT $LN54@s370_cmpsc

; 1071 :     {
; 1072 :         PUTSETCBN();

  0114a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  0114f	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  01153	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0115b	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 1073 :         RETERR( &op1blk );

  0115e	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  01166	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0116e	e8 00 00 00 00	 call	 s370_ERR
  01173	e9 2c 05 00 00	 jmp	 $LN1@s370_cmpsc
$LN54@s370_cmpsc:

; 1074 :     }
; 1075 : 
; 1076 :     // Set child index = SD index + SC number (1-origin numbering).
; 1077 : 
; 1078 :     child_index = sibling_index + (scnum + 1);

  01178	0f b7 44 24 34	 movzx	 eax, WORD PTR sibling_index$[rsp]
  0117d	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR scnum$[rsp]
  01182	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  01186	66 89 44 24 28	 mov	 WORD PTR child_index$[rsp], ax

; 1079 : 
; 1080 :     // Y=1 for child or no Y?
; 1081 :     // No, goto cmp14;
; 1082 : 
; 1083 :     if (!(sibling.ecb & (0x8000 >> scnum)))

  0118b	0f b7 84 24 20
	04 07 00	 movzx	 eax, WORD PTR sibling$[rsp+16]
  01193	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR scnum$[rsp]
  01198	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  0119d	d3 fa		 sar	 edx, cl
  0119f	8b ca		 mov	 ecx, edx
  011a1	23 c1		 and	 eax, ecx
  011a3	85 c0		 test	 eax, eax
  011a5	75 05		 jne	 SHORT $LN55@s370_cmpsc

; 1084 :         goto cmp14;

  011a7	e9 87 02 00 00	 jmp	 $cmp14$190
$LN55@s370_cmpsc:

; 1085 : 
; 1086 :     // ACT=0 or D=0 in child?
; 1087 :     // Yes, goto cmp15;
; 1088 : 
; 1089 :     cceblk.pCCE = &child;

  011ac	48 8d 84 24 48
	04 07 00	 lea	 rax, QWORD PTR child$[rsp]
  011b4	48 89 84 24 d8
	03 00 00	 mov	 QWORD PTR cceblk$[rsp+8], rax

; 1090 :     if (unlikely( !ARCH_DEP( GetCCE )( child_index, &cceblk )))

  011bc	48 8d 94 24 d0
	03 00 00	 lea	 rdx, QWORD PTR cceblk$[rsp]
  011c4	0f b7 4c 24 28	 movzx	 ecx, WORD PTR child_index$[rsp]
  011c9	e8 00 00 00 00	 call	 s370_GetCCE
  011ce	0f b6 c0	 movzx	 eax, al
  011d1	85 c0		 test	 eax, eax
  011d3	75 0d		 jne	 SHORT $LN151@s370_cmpsc
  011d5	c7 84 24 b8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv814[rsp], 1
  011e0	eb 0b		 jmp	 SHORT $LN152@s370_cmpsc
$LN151@s370_cmpsc:
  011e2	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv814[rsp], 0
$LN152@s370_cmpsc:
  011ed	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR tv814[rsp], 0
  011f5	74 0d		 je	 SHORT $LN155@s370_cmpsc
  011f7	c7 84 24 bc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv823[rsp], 1
  01202	eb 0b		 jmp	 SHORT $LN156@s370_cmpsc
$LN155@s370_cmpsc:
  01204	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv823[rsp], 0
$LN156@s370_cmpsc:
  0120f	83 bc 24 bc 00
	00 00 00	 cmp	 DWORD PTR tv823[rsp], 0
  01217	74 2e		 je	 SHORT $LN56@s370_cmpsc

; 1091 :     {
; 1092 :         PUTSETCBN();

  01219	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  0121e	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  01222	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0122a	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 1093 :         RETERR( &op1blk );

  0122d	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  01235	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0123d	e8 00 00 00 00	 call	 s370_ERR
  01242	e9 5d 04 00 00	 jmp	 $LN1@s370_cmpsc
$LN56@s370_cmpsc:

; 1094 :     }
; 1095 : 
; 1096 :     if (!child.act)

  01247	0f b6 84 24 5f
	04 07 00	 movzx	 eax, BYTE PTR child$[rsp+23]
  0124f	85 c0		 test	 eax, eax
  01251	75 05		 jne	 SHORT $LN57@s370_cmpsc

; 1097 :         goto cmp15;

  01253	e9 47 03 00 00	 jmp	 $cmp15$191
$LN57@s370_cmpsc:

; 1098 : 
; 1099 :     // (compare SRC chars after next char to AEC's in child)...
; 1100 : 
; 1101 :     // Enough SRC chars for comparison?
; 1102 :     // No, goto cmp8;
; 1103 : 
; 1104 :     if (pCMPSCBLK->nLen2 < (U64)(1 + child.act))

  01258	0f b6 84 24 5f
	04 07 00	 movzx	 eax, BYTE PTR child$[rsp+23]
  01260	ff c0		 inc	 eax
  01262	48 98		 cdqe
  01264	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0126c	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  01270	73 05		 jae	 SHORT $LN58@s370_cmpsc

; 1105 :         goto cmp8;

  01272	e9 21 fa ff ff	 jmp	 $cmp8$186
$LN58@s370_cmpsc:

; 1106 : 
; 1107 :     // Chars equal?
; 1108 :     // Yes, goto cmp16;
; 1109 : 
; 1110 :     fetch_op_str( wrk, child.act-1, pCMPSCBLK->pOp2 + 1, &op2blk );

  01277	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0127f	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  01283	48 ff c0	 inc	 rax
  01286	0f b6 8c 24 5f
	04 07 00	 movzx	 ecx, BYTE PTR child$[rsp+23]
  0128e	ff c9		 dec	 ecx
  01290	4c 8d 8c 24 20
	01 00 00	 lea	 r9, QWORD PTR op2blk$[rsp]
  01298	44 8b c0	 mov	 r8d, eax
  0129b	0f b7 d1	 movzx	 edx, cx
  0129e	48 8d 8c 24 70
	04 07 00	 lea	 rcx, QWORD PTR wrk$[rsp]
  012a6	e8 00 00 00 00	 call	 s370_cmpsc_vfetchc

; 1111 : 
; 1112 :     if (memcmp( wrk, &child.ec[0], child.act ) == 0)

  012ab	0f b6 84 24 5f
	04 07 00	 movzx	 eax, BYTE PTR child$[rsp+23]
  012b3	b9 01 00 00 00	 mov	 ecx, 1
  012b8	48 6b c9 00	 imul	 rcx, rcx, 0
  012bc	48 8d 8c 0c 48
	04 07 00	 lea	 rcx, QWORD PTR child$[rsp+rcx]
  012c4	44 8b c0	 mov	 r8d, eax
  012c7	48 8b d1	 mov	 rdx, rcx
  012ca	48 8d 8c 24 70
	04 07 00	 lea	 rcx, QWORD PTR wrk$[rsp]
  012d2	e8 00 00 00 00	 call	 memcmp
  012d7	85 c0		 test	 eax, eax
  012d9	75 05		 jne	 SHORT $LN59@s370_cmpsc

; 1113 :         goto cmp16;

  012db	e9 2e 03 00 00	 jmp	 $cmp16$193
$LN59@s370_cmpsc:

; 1114 : 
; 1115 :     // goto cmp8;
; 1116 : 
; 1117 :     goto cmp8;

  012e0	e9 b3 f9 ff ff	 jmp	 $cmp8$186
$cmp13$182:

; 1118 : 
; 1119 : cmp13:
; 1120 : 
; 1121 :     // Store parent index in DST.
; 1122 :     // Advance 1 index in DST;
; 1123 :     // Set CC0 and endop.
; 1124 : 
; 1125 :     if (unlikely( (pCMPSCBLK->pOp2 - pBegOp2) > MAX_SYMLEN ))

  012e5	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  012ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pBegOp2$[rsp]
  012f2	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  012f6	48 2b c1	 sub	 rax, rcx
  012f9	48 3d 04 01 00
	00		 cmp	 rax, 260		; 00000104H
  012ff	76 0d		 jbe	 SHORT $LN159@s370_cmpsc
  01301	c7 84 24 c0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv866[rsp], 1
  0130c	eb 0b		 jmp	 SHORT $LN160@s370_cmpsc
$LN159@s370_cmpsc:
  0130e	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv866[rsp], 0
$LN160@s370_cmpsc:
  01319	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR tv866[rsp], 0
  01321	74 2e		 je	 SHORT $LN60@s370_cmpsc

; 1126 :     {
; 1127 :         PUTSETCBN();

  01323	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  01328	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  0132c	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01334	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 1128 :         RETERR( &op1blk );

  01337	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  0133f	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01347	e8 00 00 00 00	 call	 s370_ERR
  0134c	e9 53 03 00 00	 jmp	 $LN1@s370_cmpsc
$LN60@s370_cmpsc:

; 1129 :     }
; 1130 :     pBegOp2  =  pCMPSCBLK->pOp2;

  01351	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  01359	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0135d	48 89 44 24 50	 mov	 QWORD PTR pBegOp2$[rsp], rax

; 1131 : 
; 1132 :     piblk.index = (!pCMPSCBLK->st) ? parent_index

  01362	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0136a	0f b6 40 42	 movzx	 eax, BYTE PTR [rax+66]
  0136e	85 c0		 test	 eax, eax
  01370	75 0d		 jne	 SHORT $LN161@s370_cmpsc
  01372	c7 84 24 c4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv878[rsp], 1
  0137d	eb 0b		 jmp	 SHORT $LN162@s370_cmpsc
$LN161@s370_cmpsc:
  0137f	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv878[rsp], 0
$LN162@s370_cmpsc:
  0138a	83 bc 24 c4 00
	00 00 00	 cmp	 DWORD PTR tv878[rsp], 0
  01392	74 0e		 je	 SHORT $LN163@s370_cmpsc
  01394	0f b7 44 24 24	 movzx	 eax, WORD PTR parent_index$[rsp]
  01399	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv895[rsp], eax
  013a0	eb 47		 jmp	 SHORT $LN164@s370_cmpsc
$LN163@s370_cmpsc:
  013a2	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  013aa	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  013ae	0f b7 4c 24 24	 movzx	 ecx, WORD PTR parent_index$[rsp]
  013b3	d1 e1		 shl	 ecx, 1
  013b5	48 63 c9	 movsxd	 rcx, ecx
  013b8	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR pSymTab$[rsp]
  013c0	48 03 d1	 add	 rdx, rcx
  013c3	48 8b ca	 mov	 rcx, rdx
  013c6	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  013cc	48 8b 94 24 b0
	05 07 00	 mov	 rdx, QWORD PTR pCMPSCBLK$[rsp]
  013d4	4c 8b 42 18	 mov	 r8, QWORD PTR [rdx+24]
  013d8	8b d0		 mov	 edx, eax
  013da	e8 00 00 00 00	 call	 s370_vfetch2
  013df	0f b7 c0	 movzx	 eax, ax
  013e2	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv895[rsp], eax
$LN164@s370_cmpsc:
  013e9	0f b7 84 24 c8
	00 00 00	 movzx	 eax, WORD PTR tv895[rsp]
  013f1	66 89 84 24 78
	01 00 00	 mov	 WORD PTR piblk$[rsp+24], ax

; 1133 :           : fetch_dct_hw( pSymTab + (parent_index << 1), pCMPSCBLK );
; 1134 :     pPutIndex( &piblk );

  013f9	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR piblk$[rsp]
  01401	ff 54 24 38	 call	 QWORD PTR pPutIndex$[rsp]

; 1135 :     PUTSETCBN();

  01405	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  0140a	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  0140e	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01416	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 1136 :     RETCC0( &op1blk );

  01419	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  01421	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01429	e8 00 00 00 00	 call	 s370_CC0
  0142e	e9 71 02 00 00	 jmp	 $LN1@s370_cmpsc
$cmp14$190:

; 1137 : 
; 1138 : cmp14:
; 1139 : 
; 1140 :     // Store child index in DST.
; 1141 :     // Advance 1 index in DST.
; 1142 :     // Advance 1 byte in SRC.
; 1143 :     // goto cmp1;
; 1144 : 
; 1145 :     nCPUAmt++;

  01433	48 8b 44 24 48	 mov	 rax, QWORD PTR nCPUAmt$[rsp]
  01438	48 ff c0	 inc	 rax
  0143b	48 89 44 24 48	 mov	 QWORD PTR nCPUAmt$[rsp], rax

; 1146 :     pCMPSCBLK->pOp2++;

  01440	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  01448	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0144c	48 ff c0	 inc	 rax
  0144f	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01457	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1147 :     pCMPSCBLK->nLen2--;

  0145b	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  01463	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  01467	48 ff c8	 dec	 rax
  0146a	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01472	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1148 : 
; 1149 :     if (unlikely( (pCMPSCBLK->pOp2 - pBegOp2) > MAX_SYMLEN ))

  01476	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0147e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pBegOp2$[rsp]
  01483	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  01487	48 2b c1	 sub	 rax, rcx
  0148a	48 3d 04 01 00
	00		 cmp	 rax, 260		; 00000104H
  01490	76 0d		 jbe	 SHORT $LN167@s370_cmpsc
  01492	c7 84 24 cc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv921[rsp], 1
  0149d	eb 0b		 jmp	 SHORT $LN168@s370_cmpsc
$LN167@s370_cmpsc:
  0149f	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv921[rsp], 0
$LN168@s370_cmpsc:
  014aa	83 bc 24 cc 00
	00 00 00	 cmp	 DWORD PTR tv921[rsp], 0
  014b2	74 2e		 je	 SHORT $LN61@s370_cmpsc

; 1150 :     {
; 1151 :         PUTSETCBN();

  014b4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pPutIndex$[rsp]
  014b9	ff 54 24 40	 call	 QWORD PTR pPutGetCBN$[rsp]
  014bd	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  014c5	88 41 45	 mov	 BYTE PTR [rcx+69], al

; 1152 :         RETERR( &op1blk );

  014c8	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR op1blk$[rsp]
  014d0	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  014d8	e8 00 00 00 00	 call	 s370_ERR
  014dd	e9 c2 01 00 00	 jmp	 $LN1@s370_cmpsc
$LN61@s370_cmpsc:

; 1153 :     }
; 1154 :     pBegOp2  =  pCMPSCBLK->pOp2;

  014e2	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  014ea	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  014ee	48 89 44 24 50	 mov	 QWORD PTR pBegOp2$[rsp], rax

; 1155 : 
; 1156 :     piblk.index = (!pCMPSCBLK->st) ? child_index

  014f3	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  014fb	0f b6 40 42	 movzx	 eax, BYTE PTR [rax+66]
  014ff	85 c0		 test	 eax, eax
  01501	75 0d		 jne	 SHORT $LN169@s370_cmpsc
  01503	c7 84 24 d0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv933[rsp], 1
  0150e	eb 0b		 jmp	 SHORT $LN170@s370_cmpsc
$LN169@s370_cmpsc:
  01510	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv933[rsp], 0
$LN170@s370_cmpsc:
  0151b	83 bc 24 d0 00
	00 00 00	 cmp	 DWORD PTR tv933[rsp], 0
  01523	74 0e		 je	 SHORT $LN171@s370_cmpsc
  01525	0f b7 44 24 28	 movzx	 eax, WORD PTR child_index$[rsp]
  0152a	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv950[rsp], eax
  01531	eb 47		 jmp	 SHORT $LN172@s370_cmpsc
$LN171@s370_cmpsc:
  01533	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0153b	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  0153f	0f b7 4c 24 28	 movzx	 ecx, WORD PTR child_index$[rsp]
  01544	d1 e1		 shl	 ecx, 1
  01546	48 63 c9	 movsxd	 rcx, ecx
  01549	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR pSymTab$[rsp]
  01551	48 03 d1	 add	 rdx, rcx
  01554	48 8b ca	 mov	 rcx, rdx
  01557	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  0155d	48 8b 94 24 b0
	05 07 00	 mov	 rdx, QWORD PTR pCMPSCBLK$[rsp]
  01565	4c 8b 42 18	 mov	 r8, QWORD PTR [rdx+24]
  01569	8b d0		 mov	 edx, eax
  0156b	e8 00 00 00 00	 call	 s370_vfetch2
  01570	0f b7 c0	 movzx	 eax, ax
  01573	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv950[rsp], eax
$LN172@s370_cmpsc:
  0157a	0f b7 84 24 d4
	00 00 00	 movzx	 eax, WORD PTR tv950[rsp]
  01582	66 89 84 24 78
	01 00 00	 mov	 WORD PTR piblk$[rsp+24], ax

; 1157 :           : fetch_dct_hw( pSymTab + (child_index << 1), pCMPSCBLK );
; 1158 :     eodst = pPutIndex( &piblk );

  0158a	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR piblk$[rsp]
  01592	ff 54 24 38	 call	 QWORD PTR pPutIndex$[rsp]
  01596	88 44 24 23	 mov	 BYTE PTR eodst$[rsp], al

; 1159 :     goto cmp1;

  0159a	e9 d7 ee ff ff	 jmp	 $LN173@s370_cmpsc
$cmp15$191:

; 1160 : 
; 1161 : cmp15:
; 1162 : 
; 1163 :     // Call child the parent.
; 1164 :     // Advance 1 byte in SRC.
; 1165 :     // goto cmp3;
; 1166 : 
; 1167 :     parent       = child;

  0159f	48 8d 84 24 28
	04 07 00	 lea	 rax, QWORD PTR parent$[rsp]
  015a7	48 8d 8c 24 48
	04 07 00	 lea	 rcx, QWORD PTR child$[rsp]
  015af	48 8b f8	 mov	 rdi, rax
  015b2	48 8b f1	 mov	 rsi, rcx
  015b5	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  015ba	f3 a4		 rep movsb

; 1168 :     parent_index = child_index;

  015bc	0f b7 44 24 28	 movzx	 eax, WORD PTR child_index$[rsp]
  015c1	66 89 44 24 24	 mov	 WORD PTR parent_index$[rsp], ax

; 1169 : 
; 1170 :     nCPUAmt++;

  015c6	48 8b 44 24 48	 mov	 rax, QWORD PTR nCPUAmt$[rsp]
  015cb	48 ff c0	 inc	 rax
  015ce	48 89 44 24 48	 mov	 QWORD PTR nCPUAmt$[rsp], rax

; 1171 :     pCMPSCBLK->pOp2++;

  015d3	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  015db	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  015df	48 ff c0	 inc	 rax
  015e2	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  015ea	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1172 :     pCMPSCBLK->nLen2--;

  015ee	48 8b 84 24 b0
	05 07 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  015f6	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  015fa	48 ff c8	 dec	 rax
  015fd	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01605	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1173 : 
; 1174 :     goto cmp3;

  01609	e9 85 f0 ff ff	 jmp	 $cmp3$180
$cmp16$193:

; 1175 : 
; 1176 : cmp16:
; 1177 : 
; 1178 :     // Call child the parent.
; 1179 :     // Advance in SRC by 1 + #of AEC bytes.
; 1180 :     // goto cmp3;
; 1181 : 
; 1182 :     parent       = child;

  0160e	48 8d 84 24 28
	04 07 00	 lea	 rax, QWORD PTR parent$[rsp]
  01616	48 8d 8c 24 48
	04 07 00	 lea	 rcx, QWORD PTR child$[rsp]
  0161e	48 8b f8	 mov	 rdi, rax
  01621	48 8b f1	 mov	 rsi, rcx
  01624	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01629	f3 a4		 rep movsb

; 1183 :     parent_index = child_index;

  0162b	0f b7 44 24 28	 movzx	 eax, WORD PTR child_index$[rsp]
  01630	66 89 44 24 24	 mov	 WORD PTR parent_index$[rsp], ax

; 1184 : 
; 1185 :     nCPUAmt           += 1 + child.act;

  01635	0f b6 84 24 5f
	04 07 00	 movzx	 eax, BYTE PTR child$[rsp+23]
  0163d	ff c0		 inc	 eax
  0163f	48 98		 cdqe
  01641	48 8b 4c 24 48	 mov	 rcx, QWORD PTR nCPUAmt$[rsp]
  01646	48 03 c8	 add	 rcx, rax
  01649	48 8b c1	 mov	 rax, rcx
  0164c	48 89 44 24 48	 mov	 QWORD PTR nCPUAmt$[rsp], rax

; 1186 :     pCMPSCBLK->pOp2   += 1 + child.act;

  01651	0f b6 84 24 5f
	04 07 00	 movzx	 eax, BYTE PTR child$[rsp+23]
  01659	ff c0		 inc	 eax
  0165b	48 98		 cdqe
  0165d	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01665	48 03 41 28	 add	 rax, QWORD PTR [rcx+40]
  01669	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01671	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1187 :     pCMPSCBLK->nLen2  -= 1 + child.act;

  01675	0f b6 84 24 5f
	04 07 00	 movzx	 eax, BYTE PTR child$[rsp+23]
  0167d	ff c0		 inc	 eax
  0167f	48 98		 cdqe
  01681	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  01689	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0168d	48 2b c8	 sub	 rcx, rax
  01690	48 8b c1	 mov	 rax, rcx
  01693	48 8b 8c 24 b0
	05 07 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0169b	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1188 : 
; 1189 :     goto cmp3;

  0169f	e9 ef ef ff ff	 jmp	 $LN174@s370_cmpsc
$LN1@s370_cmpsc:

; 1190 : }

  016a4	48 8b 8c 24 80
	05 07 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  016ac	48 33 cc	 xor	 rcx, rsp
  016af	e8 00 00 00 00	 call	 __security_check_cookie
  016b4	48 81 c4 98 05
	07 00		 add	 rsp, 460184		; 00070598H
  016bb	5f		 pop	 rdi
  016bc	5e		 pop	 rsi
  016bd	c3		 ret	 0
s370_cmpsc_Compress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
i$1 = 32
bits$ = 33
nCPUAmt$ = 40
tv155 = 48
tv195 = 52
tv207 = 56
tv216 = 60
tv242 = 64
tv268 = 68
tv318 = 72
tv358 = 76
tv378 = 80
tv399 = 84
tv408 = 88
tv447 = 92
tv487 = 96
tv495 = 100
tv507 = 104
tv516 = 108
tv542 = 112
tv568 = 116
tv642 = 120
pGetIndex$ = 128
ppGetIndex$ = 136
ppGet8Index$2 = 144
pGet8Index$3 = 152
giblk$ = 160
save_op1blk$4 = 192
save_op2blk$5 = 232
save_cmpsc$6 = 272
expblk$ = 352
index$ = 197376
__$ArrayPad$ = 197392
pCMPSCBLK$ = 197440
s370_cmpsc_Expand PROC

; 258  : {

$LN105:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	b8 28 03 03 00	 mov	 eax, 197416		; 00030328H
  0000c	e8 00 00 00 00	 call	 __chkstk
  00011	48 2b e0	 sub	 rsp, rax
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 10
	03 03 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 259  :     U64         nCPUAmt;        // CPU determined processing limit
; 260  :     GetIndex**  ppGetIndex;     // Ptr to GetNextIndex table for this CDSS-1
; 261  :     GetIndex*   pGetIndex;      // Ptr to GetNextIndex function for this CBN
; 262  :     GIBLK       giblk;          // GetIndex parameters block
; 263  :     EXPBLK      expblk;         // EXPAND Index Symbol parameters block
; 264  :     U16         index[8];       // SRC Index values
; 265  :     U8          bits;           // Number of bits per index
; 266  : 
; 267  :     nCPUAmt     = 0;

  00026	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR nCPUAmt$[rsp], 0

; 268  :     ppGetIndex  = ARCH_DEP( GetIndexCDSSTab  )[ pCMPSCBLK->cdss - 1 ];

  0002f	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00037	0f b6 40 44	 movzx	 eax, BYTE PTR [rax+68]
  0003b	ff c8		 dec	 eax
  0003d	48 98		 cdqe
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:s370_GetIndexCDSSTab
  00046	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0004a	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR ppGetIndex$[rsp], rax

; 269  :     pGetIndex   = ppGetIndex [ pCMPSCBLK->cbn ];

  00052	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0005a	0f b6 40 45	 movzx	 eax, BYTE PTR [rax+69]
  0005e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ppGetIndex$[rsp]
  00066	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0006a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pGetIndex$[rsp], rax

; 270  :     bits        = pCMPSCBLK->cdss + 8;

  00072	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0007a	0f b6 40 44	 movzx	 eax, BYTE PTR [rax+68]
  0007e	83 c0 08	 add	 eax, 8
  00081	88 44 24 21	 mov	 BYTE PTR bits$[rsp], al

; 271  : 
; 272  :     // Initialize GetIndex parameters block
; 273  : 
; 274  :     memset( &giblk, 0, sizeof( giblk ));

  00085	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR giblk$[rsp]
  0008d	48 8b f8	 mov	 rdi, rax
  00090	33 c0		 xor	 eax, eax
  00092	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00097	f3 aa		 rep stosb

; 275  : 
; 276  :     giblk.pCMPSCBLK   =  pCMPSCBLK;

  00099	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  000a1	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR giblk$[rsp], rax

; 277  :     giblk.pMEMBLK     =  &expblk.op2blk;    // (we get indexes from op-2)

  000a9	48 8d 84 24 c0
	02 03 00	 lea	 rax, QWORD PTR expblk$[rsp+196960]
  000b1	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR giblk$[rsp+8], rax

; 278  :     giblk.pIndex      =  &index[0];

  000b9	b8 02 00 00 00	 mov	 eax, 2
  000be	48 6b c0 00	 imul	 rax, rax, 0
  000c2	48 8d 84 04 00
	03 03 00	 lea	 rax, QWORD PTR index$[rsp+rax]
  000ca	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR giblk$[rsp+16], rax

; 279  :     giblk.ppGetIndex  =  (void**) &pGetIndex;

  000d2	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR pGetIndex$[rsp]
  000da	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR giblk$[rsp+24], rax

; 280  : 
; 281  :     // Initialize EXPAND Index Symbol parameters block
; 282  : 
; 283  :     memset( &expblk, 0, sizeof( expblk ));

  000e2	48 8d 84 24 60
	01 00 00	 lea	 rax, QWORD PTR expblk$[rsp]
  000ea	48 8b f8	 mov	 rdi, rax
  000ed	33 c0		 xor	 eax, eax
  000ef	b9 a0 01 03 00	 mov	 ecx, 197024		; 000301a0H
  000f4	f3 aa		 rep stosb

; 284  : 
; 285  :     expblk.dctblk.regs      = pCMPSCBLK->regs;

  000f6	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  000fe	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00102	48 89 84 24 68
	01 01 00	 mov	 QWORD PTR expblk$[rsp+65544], rax

; 286  :     expblk.dctblk.arn       = pCMPSCBLK->r2;

  0010a	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00112	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  00116	89 84 24 78 02
	01 00		 mov	 DWORD PTR expblk$[rsp+65816], eax

; 287  :     expblk.dctblk.pkey      = pCMPSCBLK->regs->psw.pkey;

  0011d	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00125	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00129	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0012d	88 84 24 7c 02
	01 00		 mov	 BYTE PTR expblk$[rsp+65820], al

; 288  :     expblk.dctblk.pDict     = pCMPSCBLK->pDict;

  00134	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0013c	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00140	48 89 84 24 70
	01 01 00	 mov	 QWORD PTR expblk$[rsp+65552], rax

; 289  : 
; 290  :     expblk.eceblk.pDCTBLK   = &expblk.dctblk;

  00148	48 8d 84 24 68
	01 01 00	 lea	 rax, QWORD PTR expblk$[rsp+65544]
  00150	48 89 84 24 80
	02 01 00	 mov	 QWORD PTR expblk$[rsp+65824], rax

; 291  :     expblk.eceblk.max_index = 0xFFFF >> (16 - bits);

  00158	0f b6 44 24 21	 movzx	 eax, BYTE PTR bits$[rsp]
  0015d	b9 10 00 00 00	 mov	 ecx, 16
  00162	2b c8		 sub	 ecx, eax
  00164	8b c1		 mov	 eax, ecx
  00166	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0016b	89 4c 24 78	 mov	 DWORD PTR tv642[rsp], ecx
  0016f	0f b6 c8	 movzx	 ecx, al
  00172	8b 44 24 78	 mov	 eax, DWORD PTR tv642[rsp]
  00176	d3 f8		 sar	 eax, cl
  00178	66 89 84 24 90
	02 01 00	 mov	 WORD PTR expblk$[rsp+65840], ax

; 292  :     expblk.eceblk.pECE      = &expblk.ece;

  00180	48 8d 84 24 e8
	02 03 00	 lea	 rax, QWORD PTR expblk$[rsp+197000]
  00188	48 89 84 24 88
	02 01 00	 mov	 QWORD PTR expblk$[rsp+65832], rax

; 293  : 
; 294  :     expblk.op1blk.arn       = pCMPSCBLK->r1;

  00190	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00198	0f b6 40 40	 movzx	 eax, BYTE PTR [rax+64]
  0019c	89 84 24 b8 02
	03 00		 mov	 DWORD PTR expblk$[rsp+196952], eax

; 295  :     expblk.op1blk.regs      = pCMPSCBLK->regs;

  001a3	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  001ab	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001af	48 89 84 24 98
	02 03 00	 mov	 QWORD PTR expblk$[rsp+196920], rax

; 296  :     expblk.op1blk.pkey      = pCMPSCBLK->regs->psw.pkey;

  001b7	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  001bf	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001c3	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  001c7	88 84 24 bc 02
	03 00		 mov	 BYTE PTR expblk$[rsp+196956], al

; 297  : 
; 298  :     expblk.op2blk.arn       = pCMPSCBLK->r2;

  001ce	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  001d6	0f b6 40 41	 movzx	 eax, BYTE PTR [rax+65]
  001da	89 84 24 e0 02
	03 00		 mov	 DWORD PTR expblk$[rsp+196992], eax

; 299  :     expblk.op2blk.regs      = pCMPSCBLK->regs;

  001e1	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  001e9	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001ed	48 89 84 24 c0
	02 03 00	 mov	 QWORD PTR expblk$[rsp+196960], rax

; 300  :     expblk.op2blk.pkey      = pCMPSCBLK->regs->psw.pkey;

  001f5	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  001fd	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00201	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00205	88 84 24 e4 02
	03 00		 mov	 BYTE PTR expblk$[rsp+196996], al

; 301  : 
; 302  : #ifdef CMPSC_EXPAND8
; 303  : 
; 304  :     // Expand individual index symbols until CBN==0...
; 305  : 
; 306  :     if ((pCMPSCBLK->cbn & 7) != 0)

  0020c	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00214	0f b6 40 45	 movzx	 eax, BYTE PTR [rax+69]
  00218	83 e0 07	 and	 eax, 7
  0021b	85 c0		 test	 eax, eax
  0021d	0f 84 ee 02 00
	00		 je	 $LN29@s370_cmpsc
$LN2@s370_cmpsc:

; 307  :     {
; 308  :         while (nCPUAmt < (U64) pCMPSCBLK->nCPUAmt && (pCMPSCBLK->cbn & 7) != 0)

  00223	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  0022b	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  0022e	48 39 44 24 28	 cmp	 QWORD PTR nCPUAmt$[rsp], rax
  00233	0f 83 d8 02 00
	00		 jae	 $LN3@s370_cmpsc
  00239	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00241	0f b6 40 45	 movzx	 eax, BYTE PTR [rax+69]
  00245	83 e0 07	 and	 eax, 7
  00248	85 c0		 test	 eax, eax
  0024a	0f 84 c1 02 00
	00		 je	 $LN3@s370_cmpsc

; 309  :         {
; 310  :             // Get index symbol...
; 311  : 
; 312  :             if (unlikely( !(expblk.SRC_bytes = pGetIndex( &giblk ))))

  00250	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR giblk$[rsp]
  00258	ff 94 24 80 00
	00 00		 call	 QWORD PTR pGetIndex$[rsp]
  0025f	88 84 24 fc 02
	03 00		 mov	 BYTE PTR expblk$[rsp+197020], al
  00266	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  0026e	85 c0		 test	 eax, eax
  00270	75 0a		 jne	 SHORT $LN45@s370_cmpsc
  00272	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv155[rsp], 1
  0027a	eb 08		 jmp	 SHORT $LN46@s370_cmpsc
$LN45@s370_cmpsc:
  0027c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv155[rsp], 0
$LN46@s370_cmpsc:
  00284	83 7c 24 30 00	 cmp	 DWORD PTR tv155[rsp], 0
  00289	74 0a		 je	 SHORT $LN49@s370_cmpsc
  0028b	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv195[rsp], 1
  00293	eb 08		 jmp	 SHORT $LN50@s370_cmpsc
$LN49@s370_cmpsc:
  00295	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv195[rsp], 0
$LN50@s370_cmpsc:
  0029d	83 7c 24 34 00	 cmp	 DWORD PTR tv195[rsp], 0
  002a2	74 1a		 je	 SHORT $LN30@s370_cmpsc

; 313  :                 RETCC0( &expblk.op1blk );

  002a4	48 8d 94 24 98
	02 03 00	 lea	 rdx, QWORD PTR expblk$[rsp+196920]
  002ac	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  002b4	e8 00 00 00 00	 call	 s370_CC0
  002b9	e9 59 09 00 00	 jmp	 $LN1@s370_cmpsc
$LN30@s370_cmpsc:

; 314  : 
; 315  :             // Expand it...
; 316  : 
; 317  :             expblk.index = index[0];

  002be	b8 02 00 00 00	 mov	 eax, 2
  002c3	48 6b c0 00	 imul	 rax, rax, 0
  002c7	0f b7 84 04 00
	03 03 00	 movzx	 eax, WORD PTR index$[rsp+rax]
  002cf	66 89 84 24 fa
	02 03 00	 mov	 WORD PTR expblk$[rsp+197018], ax

; 318  : 
; 319  :             if (unlikely( !ARCH_DEP( cmpsc_Expand_Index )( pCMPSCBLK, &expblk )))

  002d7	48 8d 94 24 60
	01 00 00	 lea	 rdx, QWORD PTR expblk$[rsp]
  002df	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  002e7	e8 00 00 00 00	 call	 s370_cmpsc_Expand_Index
  002ec	0f b6 c0	 movzx	 eax, al
  002ef	85 c0		 test	 eax, eax
  002f1	75 0a		 jne	 SHORT $LN51@s370_cmpsc
  002f3	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv207[rsp], 1
  002fb	eb 08		 jmp	 SHORT $LN52@s370_cmpsc
$LN51@s370_cmpsc:
  002fd	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv207[rsp], 0
$LN52@s370_cmpsc:
  00305	83 7c 24 38 00	 cmp	 DWORD PTR tv207[rsp], 0
  0030a	74 0a		 je	 SHORT $LN55@s370_cmpsc
  0030c	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv216[rsp], 1
  00314	eb 08		 jmp	 SHORT $LN56@s370_cmpsc
$LN55@s370_cmpsc:
  00316	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv216[rsp], 0
$LN56@s370_cmpsc:
  0031e	83 7c 24 3c 00	 cmp	 DWORD PTR tv216[rsp], 0
  00323	74 0d		 je	 SHORT $LN31@s370_cmpsc

; 320  :                 return expblk.rc;

  00325	0f b6 84 24 fd
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197021]
  0032d	e9 e5 08 00 00	 jmp	 $LN1@s370_cmpsc
$LN31@s370_cmpsc:

; 321  : 
; 322  :             // Bump source...
; 323  : 
; 324  :             nCPUAmt          += expblk.SRC_bytes;

  00332	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  0033a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR nCPUAmt$[rsp]
  0033f	48 03 c8	 add	 rcx, rax
  00342	48 8b c1	 mov	 rax, rcx
  00345	48 89 44 24 28	 mov	 QWORD PTR nCPUAmt$[rsp], rax

; 325  :             pCMPSCBLK->pOp2  += expblk.SRC_bytes;

  0034a	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  00352	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0035a	48 03 41 28	 add	 rax, QWORD PTR [rcx+40]
  0035e	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00366	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 326  :             pCMPSCBLK->nLen2 -= expblk.SRC_bytes;

  0036a	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  00372	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0037a	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0037e	48 2b c8	 sub	 rcx, rax
  00381	48 8b c1	 mov	 rax, rcx
  00384	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0038c	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 327  :             pCMPSCBLK->cbn   += bits;

  00390	0f b6 44 24 21	 movzx	 eax, BYTE PTR bits$[rsp]
  00395	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0039d	0f b6 49 45	 movzx	 ecx, BYTE PTR [rcx+69]
  003a1	03 c8		 add	 ecx, eax
  003a3	8b c1		 mov	 eax, ecx
  003a5	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  003ad	88 41 45	 mov	 BYTE PTR [rcx+69], al
$LN6@s370_cmpsc:

; 328  : 
; 329  :             MEMBLK_BUMP( &expblk.op2blk, pCMPSCBLK->pOp2 );

  003b0	48 8b 84 24 c8
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196968]
  003b8	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  003be	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  003c6	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  003ca	73 0a		 jae	 SHORT $LN59@s370_cmpsc
  003cc	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv242[rsp], 1
  003d4	eb 08		 jmp	 SHORT $LN60@s370_cmpsc
$LN59@s370_cmpsc:
  003d6	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv242[rsp], 0
$LN60@s370_cmpsc:
  003de	83 7c 24 40 00	 cmp	 DWORD PTR tv242[rsp], 0
  003e3	75 4d		 jne	 SHORT $LN32@s370_cmpsc
  003e5	48 8b 84 24 c8
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196968]
  003ed	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  003f3	48 89 84 24 c8
	02 03 00	 mov	 QWORD PTR expblk$[rsp+196968], rax
  003fb	b8 08 00 00 00	 mov	 eax, 8
  00400	48 6b c0 01	 imul	 rax, rax, 1
  00404	b9 08 00 00 00	 mov	 ecx, 8
  00409	48 6b c9 00	 imul	 rcx, rcx, 0
  0040d	48 8b 84 04 d0
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+rax+196976]
  00415	48 89 84 0c d0
	02 03 00	 mov	 QWORD PTR expblk$[rsp+rcx+196976], rax
  0041d	b8 08 00 00 00	 mov	 eax, 8
  00422	48 6b c0 01	 imul	 rax, rax, 1
  00426	48 c7 84 04 d0
	02 03 00 00 00
	00 00		 mov	 QWORD PTR expblk$[rsp+rax+196976], 0
$LN32@s370_cmpsc:
  00432	33 c0		 xor	 eax, eax
  00434	85 c0		 test	 eax, eax
  00436	0f 85 74 ff ff
	ff		 jne	 $LN6@s370_cmpsc

; 330  : 
; 331  :             // Bump destination...
; 332  : 
; 333  :             pCMPSCBLK->pOp1  += expblk.symlen;

  0043c	0f b7 84 24 f8
	02 03 00	 movzx	 eax, WORD PTR expblk$[rsp+197016]
  00444	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0044c	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00450	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00458	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 334  :             pCMPSCBLK->nLen1 -= expblk.symlen;

  0045c	0f b7 84 24 f8
	02 03 00	 movzx	 eax, WORD PTR expblk$[rsp+197016]
  00464	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0046c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0046f	48 2b c8	 sub	 rcx, rax
  00472	48 8b c1	 mov	 rax, rcx
  00475	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0047d	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN9@s370_cmpsc:

; 335  : 
; 336  :             MEMBLK_BUMP( &expblk.op1blk, pCMPSCBLK->pOp1 );

  00480	48 8b 84 24 a0
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196928]
  00488	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  0048e	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00496	48 39 41 20	 cmp	 QWORD PTR [rcx+32], rax
  0049a	73 0a		 jae	 SHORT $LN63@s370_cmpsc
  0049c	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv268[rsp], 1
  004a4	eb 08		 jmp	 SHORT $LN64@s370_cmpsc
$LN63@s370_cmpsc:
  004a6	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv268[rsp], 0
$LN64@s370_cmpsc:
  004ae	83 7c 24 44 00	 cmp	 DWORD PTR tv268[rsp], 0
  004b3	75 4d		 jne	 SHORT $LN33@s370_cmpsc
  004b5	48 8b 84 24 a0
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196928]
  004bd	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  004c3	48 89 84 24 a0
	02 03 00	 mov	 QWORD PTR expblk$[rsp+196928], rax
  004cb	b8 08 00 00 00	 mov	 eax, 8
  004d0	48 6b c0 01	 imul	 rax, rax, 1
  004d4	b9 08 00 00 00	 mov	 ecx, 8
  004d9	48 6b c9 00	 imul	 rcx, rcx, 0
  004dd	48 8b 84 04 a8
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+rax+196936]
  004e5	48 89 84 0c a8
	02 03 00	 mov	 QWORD PTR expblk$[rsp+rcx+196936], rax
  004ed	b8 08 00 00 00	 mov	 eax, 8
  004f2	48 6b c0 01	 imul	 rax, rax, 1
  004f6	48 c7 84 04 a8
	02 03 00 00 00
	00 00		 mov	 QWORD PTR expblk$[rsp+rax+196936], 0
$LN33@s370_cmpsc:
  00502	33 c0		 xor	 eax, eax
  00504	85 c0		 test	 eax, eax
  00506	0f 85 74 ff ff
	ff		 jne	 $LN9@s370_cmpsc

; 337  :         }

  0050c	e9 12 fd ff ff	 jmp	 $LN2@s370_cmpsc
$LN3@s370_cmpsc:
$LN29@s370_cmpsc:

; 338  :     }
; 339  : 
; 340  :     // Now expand eight (8) index symbols at a time...
; 341  : 
; 342  :     if ((pCMPSCBLK->cbn & 7) == 0)

  00511	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00519	0f b6 40 45	 movzx	 eax, BYTE PTR [rax+69]
  0051d	83 e0 07	 and	 eax, 7
  00520	85 c0		 test	 eax, eax
  00522	0f 85 03 04 00
	00		 jne	 $LN34@s370_cmpsc

; 343  :     {
; 344  :         GetIndex**  ppGet8Index;    // Ptr to GetNext8Index table for this CDSS-1
; 345  :         GetIndex*   pGet8Index;     // Ptr to GetNext8Index function for this CBN
; 346  :         CMPSCBLK    save_cmpsc;     // Work context
; 347  :         MEMBLK      save_op1blk;    // Work context
; 348  :         MEMBLK      save_op2blk;    // Work context
; 349  :         U8          i;              // (work)
; 350  : 
; 351  :         ppGet8Index = ARCH_DEP( Get8IndexCDSSTab )[ pCMPSCBLK->cdss - 1 ];

  00528	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00530	0f b6 40 44	 movzx	 eax, BYTE PTR [rax+68]
  00534	ff c8		 dec	 eax
  00536	48 98		 cdqe
  00538	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:s370_Get8IndexCDSSTab
  0053f	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00543	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR ppGet8Index$2[rsp], rax

; 352  :         pGet8Index  = ppGet8Index[ 0 ]; // (always CBN==0)

  0054b	b8 08 00 00 00	 mov	 eax, 8
  00550	48 6b c0 00	 imul	 rax, rax, 0
  00554	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ppGet8Index$2[rsp]
  0055c	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00560	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pGet8Index$3[rsp], rax

; 353  : 
; 354  :         // Save context
; 355  : 
; 356  :         memcpy( &save_cmpsc,  pCMPSCBLK,      sizeof( CMPSCBLK ));

  00568	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR save_cmpsc$6[rsp]
  00570	48 8b f8	 mov	 rdi, rax
  00573	48 8b b4 24 40
	03 03 00	 mov	 rsi, QWORD PTR pCMPSCBLK$[rsp]
  0057b	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00580	f3 a4		 rep movsb

; 357  :         memcpy( &save_op1blk, &expblk.op1blk, sizeof( MEMBLK   ));

  00582	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR save_op1blk$4[rsp]
  0058a	48 8d 8c 24 98
	02 03 00	 lea	 rcx, QWORD PTR expblk$[rsp+196920]
  00592	48 8b f8	 mov	 rdi, rax
  00595	48 8b f1	 mov	 rsi, rcx
  00598	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  0059d	f3 a4		 rep movsb

; 358  :         memcpy( &save_op2blk, &expblk.op2blk, sizeof( MEMBLK   ));

  0059f	48 8d 84 24 e8
	00 00 00	 lea	 rax, QWORD PTR save_op2blk$5[rsp]
  005a7	48 8d 8c 24 c0
	02 03 00	 lea	 rcx, QWORD PTR expblk$[rsp+196960]
  005af	48 8b f8	 mov	 rdi, rax
  005b2	48 8b f1	 mov	 rsi, rcx
  005b5	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  005ba	f3 a4		 rep movsb
$LN10@s370_cmpsc:

; 359  : 
; 360  :         while (nCPUAmt < (U64) pCMPSCBLK->nCPUAmt)

  005bc	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  005c4	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  005c7	48 39 44 24 28	 cmp	 QWORD PTR nCPUAmt$[rsp], rax
  005cc	0f 83 59 03 00
	00		 jae	 $LN11@s370_cmpsc

; 361  :         {
; 362  :             // Retrieve 8 index symbols from operand-2...
; 363  : 
; 364  :             if (unlikely( !(expblk.SRC_bytes = pGet8Index( &giblk ))))

  005d2	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR giblk$[rsp]
  005da	ff 94 24 98 00
	00 00		 call	 QWORD PTR pGet8Index$3[rsp]
  005e1	88 84 24 fc 02
	03 00		 mov	 BYTE PTR expblk$[rsp+197020], al
  005e8	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  005f0	85 c0		 test	 eax, eax
  005f2	75 0a		 jne	 SHORT $LN65@s370_cmpsc
  005f4	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv318[rsp], 1
  005fc	eb 08		 jmp	 SHORT $LN66@s370_cmpsc
$LN65@s370_cmpsc:
  005fe	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv318[rsp], 0
$LN66@s370_cmpsc:
  00606	83 7c 24 48 00	 cmp	 DWORD PTR tv318[rsp], 0
  0060b	74 0a		 je	 SHORT $LN69@s370_cmpsc
  0060d	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv358[rsp], 1
  00615	eb 08		 jmp	 SHORT $LN70@s370_cmpsc
$LN69@s370_cmpsc:
  00617	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv358[rsp], 0
$LN70@s370_cmpsc:
  0061f	83 7c 24 4c 00	 cmp	 DWORD PTR tv358[rsp], 0
  00624	74 05		 je	 SHORT $LN35@s370_cmpsc

; 365  :                 break;

  00626	e9 00 03 00 00	 jmp	 $LN11@s370_cmpsc
$LN35@s370_cmpsc:

; 366  : 
; 367  :             // Bump source...
; 368  : 
; 369  :             nCPUAmt          += expblk.SRC_bytes;

  0062b	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  00633	48 8b 4c 24 28	 mov	 rcx, QWORD PTR nCPUAmt$[rsp]
  00638	48 03 c8	 add	 rcx, rax
  0063b	48 8b c1	 mov	 rax, rcx
  0063e	48 89 44 24 28	 mov	 QWORD PTR nCPUAmt$[rsp], rax

; 370  :             pCMPSCBLK->pOp2  += expblk.SRC_bytes;

  00643	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  0064b	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00653	48 03 41 28	 add	 rax, QWORD PTR [rcx+40]
  00657	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0065f	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 371  :             pCMPSCBLK->nLen2 -= expblk.SRC_bytes;

  00663	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  0066b	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00673	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00677	48 2b c8	 sub	 rcx, rax
  0067a	48 8b c1	 mov	 rax, rcx
  0067d	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00685	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
$LN14@s370_cmpsc:

; 372  : 
; 373  :             MEMBLK_BUMP( &expblk.op2blk, pCMPSCBLK->pOp2 );

  00689	48 8b 84 24 c8
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196968]
  00691	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  00697	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0069f	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  006a3	73 0a		 jae	 SHORT $LN73@s370_cmpsc
  006a5	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv378[rsp], 1
  006ad	eb 08		 jmp	 SHORT $LN74@s370_cmpsc
$LN73@s370_cmpsc:
  006af	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv378[rsp], 0
$LN74@s370_cmpsc:
  006b7	83 7c 24 50 00	 cmp	 DWORD PTR tv378[rsp], 0
  006bc	75 4d		 jne	 SHORT $LN36@s370_cmpsc
  006be	48 8b 84 24 c8
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196968]
  006c6	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  006cc	48 89 84 24 c8
	02 03 00	 mov	 QWORD PTR expblk$[rsp+196968], rax
  006d4	b8 08 00 00 00	 mov	 eax, 8
  006d9	48 6b c0 01	 imul	 rax, rax, 1
  006dd	b9 08 00 00 00	 mov	 ecx, 8
  006e2	48 6b c9 00	 imul	 rcx, rcx, 0
  006e6	48 8b 84 04 d0
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+rax+196976]
  006ee	48 89 84 0c d0
	02 03 00	 mov	 QWORD PTR expblk$[rsp+rcx+196976], rax
  006f6	b8 08 00 00 00	 mov	 eax, 8
  006fb	48 6b c0 01	 imul	 rax, rax, 1
  006ff	48 c7 84 04 d0
	02 03 00 00 00
	00 00		 mov	 QWORD PTR expblk$[rsp+rax+196976], 0
$LN36@s370_cmpsc:
  0070b	33 c0		 xor	 eax, eax
  0070d	85 c0		 test	 eax, eax
  0070f	0f 85 74 ff ff
	ff		 jne	 $LN14@s370_cmpsc

; 374  : 
; 375  :             // Expand each of the 8 individually into operand-1...
; 376  : 
; 377  :             for (i=0; i < 8; i++)

  00715	c6 44 24 20 00	 mov	 BYTE PTR i$1[rsp], 0
  0071a	eb 0b		 jmp	 SHORT $LN17@s370_cmpsc
$LN15@s370_cmpsc:
  0071c	0f b6 44 24 20	 movzx	 eax, BYTE PTR i$1[rsp]
  00721	fe c0		 inc	 al
  00723	88 44 24 20	 mov	 BYTE PTR i$1[rsp], al
$LN17@s370_cmpsc:
  00727	0f b6 44 24 20	 movzx	 eax, BYTE PTR i$1[rsp]
  0072c	83 f8 08	 cmp	 eax, 8
  0072f	0f 8d 91 01 00
	00		 jge	 $LN16@s370_cmpsc

; 378  :             {
; 379  :                 expblk.index = index[i];

  00735	0f b6 44 24 20	 movzx	 eax, BYTE PTR i$1[rsp]
  0073a	0f b7 84 44 00
	03 03 00	 movzx	 eax, WORD PTR index$[rsp+rax*2]
  00742	66 89 84 24 fa
	02 03 00	 mov	 WORD PTR expblk$[rsp+197018], ax

; 380  : 
; 381  :                 if (unlikely( !ARCH_DEP( cmpsc_Expand_Index )( pCMPSCBLK, &expblk )))

  0074a	48 8d 94 24 60
	01 00 00	 lea	 rdx, QWORD PTR expblk$[rsp]
  00752	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0075a	e8 00 00 00 00	 call	 s370_cmpsc_Expand_Index
  0075f	0f b6 c0	 movzx	 eax, al
  00762	85 c0		 test	 eax, eax
  00764	75 0a		 jne	 SHORT $LN75@s370_cmpsc
  00766	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv399[rsp], 1
  0076e	eb 08		 jmp	 SHORT $LN76@s370_cmpsc
$LN75@s370_cmpsc:
  00770	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv399[rsp], 0
$LN76@s370_cmpsc:
  00778	83 7c 24 54 00	 cmp	 DWORD PTR tv399[rsp], 0
  0077d	74 0a		 je	 SHORT $LN79@s370_cmpsc
  0077f	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv408[rsp], 1
  00787	eb 08		 jmp	 SHORT $LN80@s370_cmpsc
$LN79@s370_cmpsc:
  00789	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv408[rsp], 0
$LN80@s370_cmpsc:
  00791	83 7c 24 58 00	 cmp	 DWORD PTR tv408[rsp], 0
  00796	74 59		 je	 SHORT $LN37@s370_cmpsc

; 382  :                 {
; 383  :                     // Restore context
; 384  : 
; 385  :                     memcpy( pCMPSCBLK,      &save_cmpsc,  sizeof( CMPSCBLK ));

  00798	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR save_cmpsc$6[rsp]
  007a0	48 8b bc 24 40
	03 03 00	 mov	 rdi, QWORD PTR pCMPSCBLK$[rsp]
  007a8	48 8b f0	 mov	 rsi, rax
  007ab	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  007b0	f3 a4		 rep movsb

; 386  :                     memcpy( &expblk.op1blk, &save_op1blk, sizeof( MEMBLK   ));

  007b2	48 8d 84 24 98
	02 03 00	 lea	 rax, QWORD PTR expblk$[rsp+196920]
  007ba	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR save_op1blk$4[rsp]
  007c2	48 8b f8	 mov	 rdi, rax
  007c5	48 8b f1	 mov	 rsi, rcx
  007c8	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  007cd	f3 a4		 rep movsb

; 387  :                     memcpy( &expblk.op2blk, &save_op2blk, sizeof( MEMBLK   ));

  007cf	48 8d 84 24 c0
	02 03 00	 lea	 rax, QWORD PTR expblk$[rsp+196960]
  007d7	48 8d 8c 24 e8
	00 00 00	 lea	 rcx, QWORD PTR save_op2blk$5[rsp]
  007df	48 8b f8	 mov	 rdi, rax
  007e2	48 8b f1	 mov	 rsi, rcx
  007e5	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  007ea	f3 a4		 rep movsb

; 388  :                     break; // (i < 8)

  007ec	e9 d5 00 00 00	 jmp	 $LN16@s370_cmpsc
$LN37@s370_cmpsc:

; 389  :                 }
; 390  : 
; 391  :                 // Bump destination...
; 392  : 
; 393  :                 pCMPSCBLK->pOp1  += expblk.symlen;

  007f1	0f b7 84 24 f8
	02 03 00	 movzx	 eax, WORD PTR expblk$[rsp+197016]
  007f9	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00801	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00805	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0080d	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 394  :                 pCMPSCBLK->nLen1 -= expblk.symlen;

  00811	0f b7 84 24 f8
	02 03 00	 movzx	 eax, WORD PTR expblk$[rsp+197016]
  00819	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00821	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00824	48 2b c8	 sub	 rcx, rax
  00827	48 8b c1	 mov	 rax, rcx
  0082a	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00832	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN20@s370_cmpsc:

; 395  : //              pCMPSCBLK->cbn   += bits;
; 396  : 
; 397  :                 MEMBLK_BUMP( &expblk.op1blk, pCMPSCBLK->pOp1 );

  00835	48 8b 84 24 a0
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196928]
  0083d	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  00843	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  0084b	48 39 41 20	 cmp	 QWORD PTR [rcx+32], rax
  0084f	73 0a		 jae	 SHORT $LN83@s370_cmpsc
  00851	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv447[rsp], 1
  00859	eb 08		 jmp	 SHORT $LN84@s370_cmpsc
$LN83@s370_cmpsc:
  0085b	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv447[rsp], 0
$LN84@s370_cmpsc:
  00863	83 7c 24 5c 00	 cmp	 DWORD PTR tv447[rsp], 0
  00868	75 4d		 jne	 SHORT $LN38@s370_cmpsc
  0086a	48 8b 84 24 a0
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196928]
  00872	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  00878	48 89 84 24 a0
	02 03 00	 mov	 QWORD PTR expblk$[rsp+196928], rax
  00880	b8 08 00 00 00	 mov	 eax, 8
  00885	48 6b c0 01	 imul	 rax, rax, 1
  00889	b9 08 00 00 00	 mov	 ecx, 8
  0088e	48 6b c9 00	 imul	 rcx, rcx, 0
  00892	48 8b 84 04 a8
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+rax+196936]
  0089a	48 89 84 0c a8
	02 03 00	 mov	 QWORD PTR expblk$[rsp+rcx+196936], rax
  008a2	b8 08 00 00 00	 mov	 eax, 8
  008a7	48 6b c0 01	 imul	 rax, rax, 1
  008ab	48 c7 84 04 a8
	02 03 00 00 00
	00 00		 mov	 QWORD PTR expblk$[rsp+rax+196936], 0
$LN38@s370_cmpsc:
  008b7	33 c0		 xor	 eax, eax
  008b9	85 c0		 test	 eax, eax
  008bb	0f 85 74 ff ff
	ff		 jne	 $LN20@s370_cmpsc

; 398  :             }

  008c1	e9 56 fe ff ff	 jmp	 $LN15@s370_cmpsc
$LN16@s370_cmpsc:

; 399  : 
; 400  :             if (i < 8)

  008c6	0f b6 44 24 20	 movzx	 eax, BYTE PTR i$1[rsp]
  008cb	83 f8 08	 cmp	 eax, 8
  008ce	7d 02		 jge	 SHORT $LN39@s370_cmpsc

; 401  :                 break;

  008d0	eb 59		 jmp	 SHORT $LN11@s370_cmpsc
$LN39@s370_cmpsc:

; 402  : 
; 403  :             // Save context
; 404  : 
; 405  :             memcpy( &save_cmpsc,  pCMPSCBLK,      sizeof( CMPSCBLK ));

  008d2	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR save_cmpsc$6[rsp]
  008da	48 8b f8	 mov	 rdi, rax
  008dd	48 8b b4 24 40
	03 03 00	 mov	 rsi, QWORD PTR pCMPSCBLK$[rsp]
  008e5	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  008ea	f3 a4		 rep movsb

; 406  :             memcpy( &save_op1blk, &expblk.op1blk, sizeof( MEMBLK   ));

  008ec	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR save_op1blk$4[rsp]
  008f4	48 8d 8c 24 98
	02 03 00	 lea	 rcx, QWORD PTR expblk$[rsp+196920]
  008fc	48 8b f8	 mov	 rdi, rax
  008ff	48 8b f1	 mov	 rsi, rcx
  00902	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00907	f3 a4		 rep movsb

; 407  :             memcpy( &save_op2blk, &expblk.op2blk, sizeof( MEMBLK   ));

  00909	48 8d 84 24 e8
	00 00 00	 lea	 rax, QWORD PTR save_op2blk$5[rsp]
  00911	48 8d 8c 24 c0
	02 03 00	 lea	 rcx, QWORD PTR expblk$[rsp+196960]
  00919	48 8b f8	 mov	 rdi, rax
  0091c	48 8b f1	 mov	 rsi, rcx
  0091f	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00924	f3 a4		 rep movsb

; 408  :         }

  00926	e9 91 fc ff ff	 jmp	 $LN10@s370_cmpsc
$LN11@s370_cmpsc:
$LN34@s370_cmpsc:
$LN21@s370_cmpsc:

; 409  :     }
; 410  : 
; 411  : #endif // CMPSC_EXPAND8
; 412  : 
; 413  :     // Finish up any remainder...
; 414  : 
; 415  :     while (nCPUAmt < (U64) pCMPSCBLK->nCPUAmt)

  0092b	48 8b 84 24 40
	03 03 00	 mov	 rax, QWORD PTR pCMPSCBLK$[rsp]
  00933	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00936	48 39 44 24 28	 cmp	 QWORD PTR nCPUAmt$[rsp], rax
  0093b	0f 83 c1 02 00
	00		 jae	 $LN22@s370_cmpsc

; 416  :     {
; 417  :         // Get index symbol...
; 418  : 
; 419  :         if (unlikely( !(expblk.SRC_bytes = pGetIndex( &giblk ))))

  00941	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR giblk$[rsp]
  00949	ff 94 24 80 00
	00 00		 call	 QWORD PTR pGetIndex$[rsp]
  00950	88 84 24 fc 02
	03 00		 mov	 BYTE PTR expblk$[rsp+197020], al
  00957	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  0095f	85 c0		 test	 eax, eax
  00961	75 0a		 jne	 SHORT $LN85@s370_cmpsc
  00963	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv487[rsp], 1
  0096b	eb 08		 jmp	 SHORT $LN86@s370_cmpsc
$LN85@s370_cmpsc:
  0096d	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv487[rsp], 0
$LN86@s370_cmpsc:
  00975	83 7c 24 60 00	 cmp	 DWORD PTR tv487[rsp], 0
  0097a	74 0a		 je	 SHORT $LN89@s370_cmpsc
  0097c	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv495[rsp], 1
  00984	eb 08		 jmp	 SHORT $LN90@s370_cmpsc
$LN89@s370_cmpsc:
  00986	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv495[rsp], 0
$LN90@s370_cmpsc:
  0098e	83 7c 24 64 00	 cmp	 DWORD PTR tv495[rsp], 0
  00993	74 1a		 je	 SHORT $LN40@s370_cmpsc

; 420  :             RETCC0( &expblk.op1blk );

  00995	48 8d 94 24 98
	02 03 00	 lea	 rdx, QWORD PTR expblk$[rsp+196920]
  0099d	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  009a5	e8 00 00 00 00	 call	 s370_CC0
  009aa	e9 68 02 00 00	 jmp	 $LN1@s370_cmpsc
$LN40@s370_cmpsc:

; 421  : 
; 422  :         // Expand it...
; 423  : 
; 424  :         expblk.index = index[0];

  009af	b8 02 00 00 00	 mov	 eax, 2
  009b4	48 6b c0 00	 imul	 rax, rax, 0
  009b8	0f b7 84 04 00
	03 03 00	 movzx	 eax, WORD PTR index$[rsp+rax]
  009c0	66 89 84 24 fa
	02 03 00	 mov	 WORD PTR expblk$[rsp+197018], ax

; 425  : 
; 426  :         if (unlikely( !ARCH_DEP( cmpsc_Expand_Index )( pCMPSCBLK, &expblk )))

  009c8	48 8d 94 24 60
	01 00 00	 lea	 rdx, QWORD PTR expblk$[rsp]
  009d0	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  009d8	e8 00 00 00 00	 call	 s370_cmpsc_Expand_Index
  009dd	0f b6 c0	 movzx	 eax, al
  009e0	85 c0		 test	 eax, eax
  009e2	75 0a		 jne	 SHORT $LN91@s370_cmpsc
  009e4	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv507[rsp], 1
  009ec	eb 08		 jmp	 SHORT $LN92@s370_cmpsc
$LN91@s370_cmpsc:
  009ee	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv507[rsp], 0
$LN92@s370_cmpsc:
  009f6	83 7c 24 68 00	 cmp	 DWORD PTR tv507[rsp], 0
  009fb	74 0a		 je	 SHORT $LN95@s370_cmpsc
  009fd	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv516[rsp], 1
  00a05	eb 08		 jmp	 SHORT $LN96@s370_cmpsc
$LN95@s370_cmpsc:
  00a07	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv516[rsp], 0
$LN96@s370_cmpsc:
  00a0f	83 7c 24 6c 00	 cmp	 DWORD PTR tv516[rsp], 0
  00a14	74 0d		 je	 SHORT $LN41@s370_cmpsc

; 427  :             return expblk.rc;

  00a16	0f b6 84 24 fd
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197021]
  00a1e	e9 f4 01 00 00	 jmp	 $LN1@s370_cmpsc
$LN41@s370_cmpsc:

; 428  : 
; 429  :         // Bump source...
; 430  : 
; 431  :         nCPUAmt          += expblk.SRC_bytes;

  00a23	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  00a2b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR nCPUAmt$[rsp]
  00a30	48 03 c8	 add	 rcx, rax
  00a33	48 8b c1	 mov	 rax, rcx
  00a36	48 89 44 24 28	 mov	 QWORD PTR nCPUAmt$[rsp], rax

; 432  :         pCMPSCBLK->pOp2  += expblk.SRC_bytes;

  00a3b	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  00a43	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00a4b	48 03 41 28	 add	 rax, QWORD PTR [rcx+40]
  00a4f	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00a57	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 433  :         pCMPSCBLK->nLen2 -= expblk.SRC_bytes;

  00a5b	0f b6 84 24 fc
	02 03 00	 movzx	 eax, BYTE PTR expblk$[rsp+197020]
  00a63	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00a6b	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00a6f	48 2b c8	 sub	 rcx, rax
  00a72	48 8b c1	 mov	 rax, rcx
  00a75	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00a7d	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 434  :         pCMPSCBLK->cbn   += bits;

  00a81	0f b6 44 24 21	 movzx	 eax, BYTE PTR bits$[rsp]
  00a86	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00a8e	0f b6 49 45	 movzx	 ecx, BYTE PTR [rcx+69]
  00a92	03 c8		 add	 ecx, eax
  00a94	8b c1		 mov	 eax, ecx
  00a96	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00a9e	88 41 45	 mov	 BYTE PTR [rcx+69], al
$LN25@s370_cmpsc:

; 435  : 
; 436  :         MEMBLK_BUMP( &expblk.op2blk, pCMPSCBLK->pOp2 );

  00aa1	48 8b 84 24 c8
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196968]
  00aa9	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  00aaf	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00ab7	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  00abb	73 0a		 jae	 SHORT $LN99@s370_cmpsc
  00abd	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv542[rsp], 1
  00ac5	eb 08		 jmp	 SHORT $LN100@s370_cmpsc
$LN99@s370_cmpsc:
  00ac7	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv542[rsp], 0
$LN100@s370_cmpsc:
  00acf	83 7c 24 70 00	 cmp	 DWORD PTR tv542[rsp], 0
  00ad4	75 4d		 jne	 SHORT $LN42@s370_cmpsc
  00ad6	48 8b 84 24 c8
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196968]
  00ade	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  00ae4	48 89 84 24 c8
	02 03 00	 mov	 QWORD PTR expblk$[rsp+196968], rax
  00aec	b8 08 00 00 00	 mov	 eax, 8
  00af1	48 6b c0 01	 imul	 rax, rax, 1
  00af5	b9 08 00 00 00	 mov	 ecx, 8
  00afa	48 6b c9 00	 imul	 rcx, rcx, 0
  00afe	48 8b 84 04 d0
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+rax+196976]
  00b06	48 89 84 0c d0
	02 03 00	 mov	 QWORD PTR expblk$[rsp+rcx+196976], rax
  00b0e	b8 08 00 00 00	 mov	 eax, 8
  00b13	48 6b c0 01	 imul	 rax, rax, 1
  00b17	48 c7 84 04 d0
	02 03 00 00 00
	00 00		 mov	 QWORD PTR expblk$[rsp+rax+196976], 0
$LN42@s370_cmpsc:
  00b23	33 c0		 xor	 eax, eax
  00b25	85 c0		 test	 eax, eax
  00b27	0f 85 74 ff ff
	ff		 jne	 $LN25@s370_cmpsc

; 437  : 
; 438  :         // Bump destination...
; 439  : 
; 440  :         pCMPSCBLK->pOp1  += expblk.symlen;

  00b2d	0f b7 84 24 f8
	02 03 00	 movzx	 eax, WORD PTR expblk$[rsp+197016]
  00b35	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00b3d	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00b41	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00b49	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 441  :         pCMPSCBLK->nLen1 -= expblk.symlen;

  00b4d	0f b7 84 24 f8
	02 03 00	 movzx	 eax, WORD PTR expblk$[rsp+197016]
  00b55	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00b5d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00b60	48 2b c8	 sub	 rcx, rax
  00b63	48 8b c1	 mov	 rax, rcx
  00b66	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00b6e	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN28@s370_cmpsc:

; 442  : 
; 443  :         MEMBLK_BUMP( &expblk.op1blk, pCMPSCBLK->pOp1 );

  00b71	48 8b 84 24 a0
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196928]
  00b79	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  00b7f	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00b87	48 39 41 20	 cmp	 QWORD PTR [rcx+32], rax
  00b8b	73 0a		 jae	 SHORT $LN103@s370_cmpsc
  00b8d	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv568[rsp], 1
  00b95	eb 08		 jmp	 SHORT $LN104@s370_cmpsc
$LN103@s370_cmpsc:
  00b97	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv568[rsp], 0
$LN104@s370_cmpsc:
  00b9f	83 7c 24 74 00	 cmp	 DWORD PTR tv568[rsp], 0
  00ba4	75 4d		 jne	 SHORT $LN43@s370_cmpsc
  00ba6	48 8b 84 24 a0
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+196928]
  00bae	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  00bb4	48 89 84 24 a0
	02 03 00	 mov	 QWORD PTR expblk$[rsp+196928], rax
  00bbc	b8 08 00 00 00	 mov	 eax, 8
  00bc1	48 6b c0 01	 imul	 rax, rax, 1
  00bc5	b9 08 00 00 00	 mov	 ecx, 8
  00bca	48 6b c9 00	 imul	 rcx, rcx, 0
  00bce	48 8b 84 04 a8
	02 03 00	 mov	 rax, QWORD PTR expblk$[rsp+rax+196936]
  00bd6	48 89 84 0c a8
	02 03 00	 mov	 QWORD PTR expblk$[rsp+rcx+196936], rax
  00bde	b8 08 00 00 00	 mov	 eax, 8
  00be3	48 6b c0 01	 imul	 rax, rax, 1
  00be7	48 c7 84 04 a8
	02 03 00 00 00
	00 00		 mov	 QWORD PTR expblk$[rsp+rax+196936], 0
$LN43@s370_cmpsc:
  00bf3	33 c0		 xor	 eax, eax
  00bf5	85 c0		 test	 eax, eax
  00bf7	0f 85 74 ff ff
	ff		 jne	 $LN28@s370_cmpsc

; 444  :     }

  00bfd	e9 29 fd ff ff	 jmp	 $LN21@s370_cmpsc
$LN22@s370_cmpsc:

; 445  : 
; 446  :     RETCC3( &expblk.op1blk );

  00c02	48 8d 94 24 98
	02 03 00	 lea	 rdx, QWORD PTR expblk$[rsp+196920]
  00c0a	48 8b 8c 24 40
	03 03 00	 mov	 rcx, QWORD PTR pCMPSCBLK$[rsp]
  00c12	e8 00 00 00 00	 call	 s370_CC3
$LN1@s370_cmpsc:

; 447  : }

  00c17	48 8b 8c 24 10
	03 03 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00c1f	48 33 cc	 xor	 rcx, rsp
  00c22	e8 00 00 00 00	 call	 __security_check_cookie
  00c27	48 81 c4 28 03
	03 00		 add	 rsp, 197416		; 00030328H
  00c2e	5f		 pop	 rdi
  00c2f	5e		 pop	 rsi
  00c30	c3		 ret	 0
s370_cmpsc_Expand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch2
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
tv80 = 56
tv92 = 60
mn$1 = 64
addr$ = 96
arn$ = 104
regs$ = 112
s370_vfetch2 PROC					; COMDAT

; 679  : {

$LN26:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 680  :     if (likely(!((VADR_L)addr & 0x01))
; 681  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) != PAGEFRAME_BYTEMASK ))

  00011	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00015	83 e0 01	 and	 eax, 1
  00018	85 c0		 test	 eax, eax
  0001a	75 0a		 jne	 SHORT $LN9@s370_vfetc
  0001c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00024	eb 08		 jmp	 SHORT $LN10@s370_vfetc
$LN9@s370_vfetc:
  00026	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN10@s370_vfetc:
  0002e	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00033	74 0a		 je	 SHORT $LN13@s370_vfetc
  00035	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0003d	eb 08		 jmp	 SHORT $LN14@s370_vfetc
$LN13@s370_vfetc:
  0003f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN14@s370_vfetc:
  00047	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  0004c	75 14		 jne	 SHORT $LN6@s370_vfetc
  0004e	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00052	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00057	3d ff 07 00 00	 cmp	 eax, 2047		; 000007ffH
  0005c	0f 84 9a 00 00
	00		 je	 $LN5@s370_vfetc
$LN6@s370_vfetc:
$LN4@s370_vfetc:

; 682  :     {
; 683  :         BYTE *mn;
; 684  :         ITIMER_SYNC( addr, 2-1, regs );

  00062	83 7c 24 60 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  00067	73 0a		 jae	 SHORT $LN17@s370_vfetc
  00069	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  00071	eb 08		 jmp	 SHORT $LN18@s370_vfetc
$LN17@s370_vfetc:
  00073	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN18@s370_vfetc:
  0007b	83 7c 24 38 00	 cmp	 DWORD PTR tv80[rsp], 0
  00080	74 15		 je	 SHORT $LN19@s370_vfetc
  00082	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00086	ff c0		 inc	 eax
  00088	83 f8 50	 cmp	 eax, 80			; 00000050H
  0008b	72 0a		 jb	 SHORT $LN19@s370_vfetc
  0008d	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  00095	eb 08		 jmp	 SHORT $LN25@s370_vfetc
$LN19@s370_vfetc:
  00097	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN25@s370_vfetc:
  0009f	83 7c 24 3c 00	 cmp	 DWORD PTR tv92[rsp], 0
  000a4	74 0a		 je	 SHORT $LN7@s370_vfetc
  000a6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	e8 00 00 00 00	 call	 s370_store_int_timer
$LN7@s370_vfetc:
  000b0	33 c0		 xor	 eax, eax
  000b2	85 c0		 test	 eax, eax
  000b4	75 ac		 jne	 SHORT $LN4@s370_vfetc

; 685  :         mn = MADDRL( addr, 2,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000b6	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  000bf	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  000c3	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000cb	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000d0	44 8b 44 24 68	 mov	 r8d, DWORD PTR arn$[rsp]
  000d5	ba 02 00 00 00	 mov	 edx, 2
  000da	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  000de	e8 00 00 00 00	 call	 s370_maddr_l
  000e3	48 89 44 24 40	 mov	 QWORD PTR mn$1[rsp], rax

; 686  :         return fetch_hw( mn );

  000e8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mn$1[rsp]
  000ed	e8 00 00 00 00	 call	 fetch_hw_noswap
  000f2	0f b7 c8	 movzx	 ecx, ax
  000f5	e8 00 00 00 00	 call	 _byteswap_ushort
  000fa	eb 12		 jmp	 SHORT $LN1@s370_vfetc
$LN5@s370_vfetc:

; 687  :     }
; 688  :     return ARCH_DEP( vfetch2_full )( addr, arn, regs );

  000fc	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00101	8b 54 24 68	 mov	 edx, DWORD PTR arn$[rsp]
  00105	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  00109	e8 00 00 00 00	 call	 s370_vfetch2_full
$LN1@s370_vfetc:

; 689  : }

  0010e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00112	c3		 ret	 0
s370_vfetch2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch2_full
_TEXT	SEGMENT
value$ = 48
mn$ = 56
addr$ = 80
arn$ = 88
regs$ = 96
s370_vfetch2_full PROC					; COMDAT

; 401  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 402  : BYTE   *mn;                             /* Main storage addresses    */
; 403  : U16     value;
; 404  : 
; 405  :     mn = MADDR( addr, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00011	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00016	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001a	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0001e	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00026	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0002b	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00030	ba 01 00 00 00	 mov	 edx, 1
  00035	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  00039	e8 00 00 00 00	 call	 s370_maddr_l
  0003e	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 406  :     value = *mn << 8;

  00043	48 8b 44 24 38	 mov	 rax, QWORD PTR mn$[rsp]
  00048	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0004b	c1 e0 08	 shl	 eax, 8
  0004e	66 89 44 24 30	 mov	 WORD PTR value$[rsp], ax

; 407  :     mn = MADDR( (addr + 1) & ADDRESS_MAXWRAP( regs ), arn, regs,

  00053	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00057	ff c0		 inc	 eax
  00059	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0005e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00063	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00067	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0006b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00073	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  00078	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  0007d	ba 01 00 00 00	 mov	 edx, 1
  00082	8b c8		 mov	 ecx, eax
  00084	e8 00 00 00 00	 call	 s370_maddr_l
  00089	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 408  :                  ACCTYPE_READ, regs->psw.pkey );
; 409  :     value |= *mn;

  0008e	48 8b 44 24 38	 mov	 rax, QWORD PTR mn$[rsp]
  00093	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00096	0f b7 4c 24 30	 movzx	 ecx, WORD PTR value$[rsp]
  0009b	0b c8		 or	 ecx, eax
  0009d	8b c1		 mov	 eax, ecx
  0009f	66 89 44 24 30	 mov	 WORD PTR value$[rsp], ax

; 410  :     return value;

  000a4	0f b7 44 24 30	 movzx	 eax, WORD PTR value$[rsp]

; 411  : }

  000a9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ad	c3		 ret	 0
s370_vfetch2_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s370_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s370_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s370_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s370_maddr
$LN12@s370_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s370_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0b	 shr	 eax, 11
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s370_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s370_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s370_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s370_maddr
$LN4@s370_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s370_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s370_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s370_maddr
$LN6@s370_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 e0 00	 and	 eax, 14680064		; 00e00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s370_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s370_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s370_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s370_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s370_maddr:
$LN7@s370_maddr:
$LN5@s370_maddr:
$LN3@s370_maddr:
$LN2@s370_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s370_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s370_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s370_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s370_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmpsc_2012.c
_TEXT	SEGMENT
r2$ = 32
r1$ = 36
i$1 = 40
tv136 = 44
tv150 = 48
tv159 = 52
tv164 = 56
rc$2 = 60
cmpsc$ = 64
inst$ = 160
regs$ = 168
s370_cmpsc_2012 PROC

; 1196 : {

$LN22:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1197 :     CMPSCBLK cmpsc;                     /* Compression Call parameters block */
; 1198 :     int  r1, r2;                        /* Operand register numbers          */
; 1199 :     RRE( inst, regs, r1, r2 );          /* Decode the instruction...         */

  00011	b8 01 00 00 00	 mov	 eax, 1
  00016	48 6b c0 03	 imul	 rax, rax, 3
  0001a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00022	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00026	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
  0002a	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  0002e	83 e0 0f	 and	 eax, 15
  00031	89 44 24 20	 mov	 DWORD PTR r2$[rsp], eax
  00035	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00039	c1 f8 04	 sar	 eax, 4
  0003c	83 e0 0f	 and	 eax, 15
  0003f	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_cmpsc:
  00043	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004f	48 83 c0 04	 add	 rax, 4
  00053	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0005b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005f	33 c0		 xor	 eax, eax
  00061	83 f8 04	 cmp	 eax, 4
  00064	74 0f		 je	 SHORT $LN5@s370_cmpsc
  00066	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_cmpsc:
  00075	33 c0		 xor	 eax, eax
  00077	85 c0		 test	 eax, eax
  00079	75 c8		 jne	 SHORT $LN4@s370_cmpsc

; 1200 : 
; 1201 : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 1202 :     if (0
; 1203 :         || GR_A( 1,  regs ) == 0
; 1204 :         || GR_A( r1, regs ) == 0
; 1205 :         || GR_A( r2, regs ) == 0
; 1206 :     )
; 1207 :         ARCH_DEP( per3_zero )( regs );
; 1208 : #endif
; 1209 : 
; 1210 :     /* Build our internal Compression Call parameters block */
; 1211 : 
; 1212 :     ARCH_DEP( cmpsc_SetCMPSC )( &cmpsc, regs, r1, r2 );

  0007b	44 8b 4c 24 20	 mov	 r9d, DWORD PTR r2$[rsp]
  00080	44 8b 44 24 24	 mov	 r8d, DWORD PTR r1$[rsp]
  00085	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0008d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR cmpsc$[rsp]
  00092	e8 00 00 00 00	 call	 s370_cmpsc_SetCMPSC

; 1213 : 
; 1214 :     /* Verify that an even-odd register pair was specified
; 1215 :        and that the compressed-data symbol size is valid. */
; 1216 : 
; 1217 :     if (likely( 1

  00097	33 c0		 xor	 eax, eax
  00099	83 f8 01	 cmp	 eax, 1
  0009c	74 3a		 je	 SHORT $LN10@s370_cmpsc
  0009e	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  000a2	83 e0 01	 and	 eax, 1
  000a5	85 c0		 test	 eax, eax
  000a7	75 2f		 jne	 SHORT $LN10@s370_cmpsc
  000a9	8b 44 24 20	 mov	 eax, DWORD PTR r2$[rsp]
  000ad	83 e0 01	 and	 eax, 1
  000b0	85 c0		 test	 eax, eax
  000b2	75 24		 jne	 SHORT $LN10@s370_cmpsc
  000b4	0f b6 84 24 84
	00 00 00	 movzx	 eax, BYTE PTR cmpsc$[rsp+68]
  000bc	83 f8 01	 cmp	 eax, 1
  000bf	7c 17		 jl	 SHORT $LN10@s370_cmpsc
  000c1	0f b6 84 24 84
	00 00 00	 movzx	 eax, BYTE PTR cmpsc$[rsp+68]
  000c9	83 f8 05	 cmp	 eax, 5
  000cc	7f 0a		 jg	 SHORT $LN10@s370_cmpsc
  000ce	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000d6	eb 08		 jmp	 SHORT $LN13@s370_cmpsc
$LN10@s370_cmpsc:
  000d8	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN13@s370_cmpsc:
  000e0	83 7c 24 2c 00	 cmp	 DWORD PTR tv136[rsp], 0
  000e5	0f 84 da 00 00
	00		 je	 $LN6@s370_cmpsc

; 1218 :         && !(r1 & 0x01)       /* (even register number?) */
; 1219 :         && !(r2 & 0x01)       /* (even register number?) */
; 1220 :         && cmpsc.cdss >= 1    /* (is symbol size valid?) */
; 1221 :         && cmpsc.cdss <= 5    /* (is symbol size valid?) */
; 1222 :     ))
; 1223 :     {
; 1224 :         /* Perform the Compression or Expansion */
; 1225 : 
; 1226 :         int rc = (regs->GR_L(0) & 0x100)

  000eb	b8 08 00 00 00	 mov	 eax, 8
  000f0	48 6b c0 00	 imul	 rax, rax, 0
  000f4	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00103	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00108	85 c0		 test	 eax, eax
  0010a	74 13		 je	 SHORT $LN14@s370_cmpsc
  0010c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR cmpsc$[rsp]
  00111	e8 00 00 00 00	 call	 s370_cmpsc_Expand
  00116	0f b6 c0	 movzx	 eax, al
  00119	89 44 24 30	 mov	 DWORD PTR tv150[rsp], eax
  0011d	eb 11		 jmp	 SHORT $LN15@s370_cmpsc
$LN14@s370_cmpsc:
  0011f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR cmpsc$[rsp]
  00124	e8 00 00 00 00	 call	 s370_cmpsc_Compress
  00129	0f b6 c0	 movzx	 eax, al
  0012c	89 44 24 30	 mov	 DWORD PTR tv150[rsp], eax
$LN15@s370_cmpsc:
  00130	8b 44 24 30	 mov	 eax, DWORD PTR tv150[rsp]
  00134	89 44 24 3c	 mov	 DWORD PTR rc$2[rsp], eax

; 1227 :                ? ARCH_DEP( cmpsc_Expand   )( &cmpsc )
; 1228 :                : ARCH_DEP( cmpsc_Compress )( &cmpsc );
; 1229 : 
; 1230 :         /* Update register context with results */
; 1231 : 
; 1232 :         cmpsc.cbn &= 0x07;

  00138	0f b6 84 24 85
	00 00 00	 movzx	 eax, BYTE PTR cmpsc$[rsp+69]
  00140	83 e0 07	 and	 eax, 7
  00143	88 84 24 85 00
	00 00		 mov	 BYTE PTR cmpsc$[rsp+69], al

; 1233 :         ARCH_DEP( cmpsc_SetREGS )( &cmpsc, regs, r1, r2 );

  0014a	44 8b 4c 24 20	 mov	 r9d, DWORD PTR r2$[rsp]
  0014f	44 8b 44 24 24	 mov	 r8d, DWORD PTR r1$[rsp]
  00154	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0015c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR cmpsc$[rsp]
  00161	e8 00 00 00 00	 call	 s370_cmpsc_SetREGS

; 1234 : 
; 1235 :         /* Program Check Interrupt if we failed */
; 1236 : 
; 1237 :         if (unlikely( !rc ))

  00166	83 7c 24 3c 00	 cmp	 DWORD PTR rc$2[rsp], 0
  0016b	75 0a		 jne	 SHORT $LN16@s370_cmpsc
  0016d	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv159[rsp], 1
  00175	eb 08		 jmp	 SHORT $LN17@s370_cmpsc
$LN16@s370_cmpsc:
  00177	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
$LN17@s370_cmpsc:
  0017f	83 7c 24 34 00	 cmp	 DWORD PTR tv159[rsp], 0
  00184	74 0a		 je	 SHORT $LN20@s370_cmpsc
  00186	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv164[rsp], 1
  0018e	eb 08		 jmp	 SHORT $LN21@s370_cmpsc
$LN20@s370_cmpsc:
  00190	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv164[rsp], 0
$LN21@s370_cmpsc:
  00198	83 7c 24 38 00	 cmp	 DWORD PTR tv164[rsp], 0
  0019d	74 24		 je	 SHORT $LN8@s370_cmpsc

; 1238 :         {
; 1239 :             regs->dxc = DXC_DECIMAL; /* Set Data Exception code */

  0019f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a7	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 1240 :             ARCH_DEP( program_interrupt )( regs, PGM_DATA_EXCEPTION );

  001b1	ba 07 00 00 00	 mov	 edx, 7
  001b6	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001be	e8 00 00 00 00	 call	 s370_program_interrupt
$LN8@s370_cmpsc:

; 1241 :         }
; 1242 :     }

  001c3	eb 12		 jmp	 SHORT $LN7@s370_cmpsc
$LN6@s370_cmpsc:

; 1243 :     else
; 1244 :         ARCH_DEP( program_interrupt )( regs, PGM_SPECIFICATION_EXCEPTION );

  001c5	ba 06 00 00 00	 mov	 edx, 6
  001ca	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d2	e8 00 00 00 00	 call	 s370_program_interrupt
$LN7@s370_cmpsc:

; 1245 : }

  001d7	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  001de	c3		 ret	 0
s370_cmpsc_2012 ENDP
_TEXT	ENDS
END
