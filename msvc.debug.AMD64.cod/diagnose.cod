; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	s370_diagnose_call
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	_get_storekey_ptr
PUBLIC	_get_storekey1_ptr
PUBLIC	_get_storekey2_ptr
PUBLIC	s370__and_storage_key
PUBLIC	s370__or_storage_key
PUBLIC	s370_maddr_l
PUBLIC	s370_vfetch4_full
PUBLIC	s370_vstorec
PUBLIC	s370_vfetch4
PUBLIC	s370_validate_operand
PUBLIC	s390_diagnose_call
PUBLIC	s390__and_storage_key
PUBLIC	s390__or_storage_key
PUBLIC	s390_maddr_l
PUBLIC	s390_vfetch4_full
PUBLIC	s390_vstorec
PUBLIC	s390_vfetch4
PUBLIC	s390_validate_operand
PUBLIC	z900_diagnose_call
PUBLIC	z900__and_storage_key
PUBLIC	z900__or_storage_key
PUBLIC	z900_maddr_l
PUBLIC	z900_vfetch4_full
PUBLIC	z900_vstorec
PUBLIC	z900_vfetch4
PUBLIC	z900_validate_operand
EXTRN	strlen:PROC
EXTRN	__imp_exit:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	__imp_ptt_pthread_trace:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_usleep:PROC
EXTRN	__imp_sleep:PROC
EXTRN	__imp_sched_yield:PROC
EXTRN	s370_fetch_int_timer:PROC
EXTRN	s370_store_int_timer:PROC
EXTRN	__imp_str_host_to_guest:PROC
EXTRN	s370_diag_devtype:PROC
EXTRN	s370_syncblk_io:PROC
EXTRN	s370_syncgen_io:PROC
EXTRN	s370_extid_call:PROC
EXTRN	s370_cpcmd_call:PROC
EXTRN	s370_diag_ppagerel:PROC
EXTRN	s370_vm_info:PROC
EXTRN	s370_device_info:PROC
EXTRN	s370_access_reipl_data:PROC
EXTRN	s370_pseudo_timer:PROC
EXTRN	s370_vm_blockio:PROC
EXTRN	s370_scpend_call:PROC
EXTRN	s370_diagf18_call:PROC
EXTRN	txf_maddr_l:PROC
EXTRN	do_shutdown:PROC
EXTRN	s370_program_interrupt:PROC
EXTRN	s390_program_interrupt:PROC
EXTRN	z900_program_interrupt:PROC
EXTRN	s370_logical_to_main_l:PROC
EXTRN	s390_logical_to_main_l:PROC
EXTRN	z900_logical_to_main_l:PROC
EXTRN	s390_diag_devtype:PROC
EXTRN	s390_syncblk_io:PROC
EXTRN	s390_syncgen_io:PROC
EXTRN	s390_extid_call:PROC
EXTRN	s390_cpcmd_call:PROC
EXTRN	s390_diag_ppagerel:PROC
EXTRN	s390_vm_info:PROC
EXTRN	s390_device_info:PROC
EXTRN	s390_access_reipl_data:PROC
EXTRN	s390_pseudo_timer:PROC
EXTRN	s390_vm_blockio:PROC
EXTRN	s390_scpend_call:PROC
EXTRN	s390_mssf_call:PROC
EXTRN	s390_diag204_call:PROC
EXTRN	s390_diag224_call:PROC
EXTRN	s390_diagf18_call:PROC
EXTRN	s390_diagnose_002:PROC
EXTRN	z900_diag_devtype:PROC
EXTRN	z900_syncblk_io:PROC
EXTRN	z900_syncgen_io:PROC
EXTRN	z900_extid_call:PROC
EXTRN	z900_cpcmd_call:PROC
EXTRN	z900_diag_ppagerel:PROC
EXTRN	z900_vm_info:PROC
EXTRN	z900_device_info:PROC
EXTRN	z900_access_reipl_data:PROC
EXTRN	z900_pseudo_timer:PROC
EXTRN	z900_vm_blockio:PROC
EXTRN	z900_scpend_call:PROC
EXTRN	z900_diag204_call:PROC
EXTRN	z900_diag224_call:PROC
EXTRN	z900_diagf18_call:PROC
EXTRN	z900_diagnose_002:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_pttclass:QWORD
EXTRN	__imp_sysblk:BYTE
EXTRN	__imp_debug_diagnose:QWORD
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
pdata	SEGMENT
$pdata$s370_diagnose_call DD imagerel $LN150
	DD	imagerel $LN150+5498
	DD	imagerel $unwind$s370_diagnose_call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_get_storekey_ptr DD imagerel $LN5
	DD	imagerel $LN5+104
	DD	imagerel $unwind$_get_storekey_ptr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370__and_storage_key DD imagerel $LN8
	DD	imagerel $LN8+176
	DD	imagerel $unwind$s370__and_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+170
	DD	imagerel $unwind$s370__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s370_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch4_full DD imagerel $LN3
	DD	imagerel $LN3+288
	DD	imagerel $unwind$s370_vfetch4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstorec DD imagerel $LN24
	DD	imagerel $LN24+597
	DD	imagerel $unwind$s370_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch4 DD imagerel $LN26
	DD	imagerel $LN26+275
	DD	imagerel $unwind$s370_vfetch4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_validate_operand DD imagerel $LN24
	DD	imagerel $LN24+271
	DD	imagerel $unwind$s370_validate_operand
pdata	ENDS
pdata	SEGMENT
$pdata$s390_diagnose_call DD imagerel $LN153
	DD	imagerel $LN153+5674
	DD	imagerel $unwind$s390_diagnose_call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390__and_storage_key DD imagerel $LN8
	DD	imagerel $LN8+165
	DD	imagerel $unwind$s390__and_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$s390__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s390_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetch4_full DD imagerel $LN3
	DD	imagerel $LN3+296
	DD	imagerel $unwind$s390_vfetch4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstorec DD imagerel $LN9
	DD	imagerel $LN9+498
	DD	imagerel $unwind$s390_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetch4 DD imagerel $LN11
	DD	imagerel $LN11+186
	DD	imagerel $unwind$s390_vfetch4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_validate_operand DD imagerel $LN8
	DD	imagerel $LN8+185
	DD	imagerel $unwind$s390_validate_operand
pdata	ENDS
pdata	SEGMENT
$pdata$z900_diagnose_call DD imagerel $LN152
	DD	imagerel $LN152+5626
	DD	imagerel $unwind$z900_diagnose_call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900__and_storage_key DD imagerel $LN8
	DD	imagerel $LN8+165
	DD	imagerel $unwind$z900__and_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$z900__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_maddr_l DD imagerel $LN18
	DD	imagerel $LN18+657
	DD	imagerel $unwind$z900_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch4_full DD imagerel $LN3
	DD	imagerel $LN3+307
	DD	imagerel $unwind$z900_vfetch4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstorec DD imagerel $LN9
	DD	imagerel $LN9+511
	DD	imagerel $unwind$z900_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch4 DD imagerel $LN11
	DD	imagerel $LN11+195
	DD	imagerel $unwind$z900_vfetch4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_validate_operand DD imagerel $LN8
	DD	imagerel $LN8+195
	DD	imagerel $unwind$z900_validate_operand
pdata	ENDS
_DATA	SEGMENT
$SG169715 DB	'diagnose.c:522', 00H
	ORG $+1
$SG169716 DB	'*DIAG264', 00H
	ORG $+7
$SG169720 DB	'diagnose.c:538', 00H
	ORG $+1
$SG169721 DB	'*DIAG274', 00H
	ORG $+7
$SG169724 DB	'diagnose.c:548', 00H
	ORG $+1
$SG169725 DB	'*DIAG308', 00H
	ORG $+7
$SG169734 DB	'Hercules', 00H
	ORG $+7
$SG179944 DB	'C:\papa\MyGit\hyperion-zvector\diagnose.c:522', 00H
	ORG $+2
$SG179945 DB	'*DIAG264', 00H
	ORG $+7
$SG179949 DB	'C:\papa\MyGit\hyperion-zvector\diagnose.c:538', 00H
	ORG $+2
$SG179950 DB	'*DIAG274', 00H
	ORG $+7
$SG179953 DB	'C:\papa\MyGit\hyperion-zvector\diagnose.c:548', 00H
	ORG $+2
$SG179954 DB	'*DIAG308', 00H
	ORG $+7
$SG179963 DB	'Hercules', 00H
	ORG $+7
$SG193048 DB	'C:\papa\MyGit\hyperion-zvector\diagnose.c:522', 00H
	ORG $+2
$SG193049 DB	'*DIAG264', 00H
	ORG $+7
$SG193053 DB	'C:\papa\MyGit\hyperion-zvector\diagnose.c:538', 00H
	ORG $+2
$SG193054 DB	'*DIAG274', 00H
	ORG $+7
$SG193057 DB	'C:\papa\MyGit\hyperion-zvector\diagnose.c:548', 00H
	ORG $+2
$SG193058 DB	'*DIAG308', 00H
	ORG $+7
$SG193067 DB	'Hercules', 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_validate_operand DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch4 DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01eH
	DW	011fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch4_full DD 032319H
	DD	07010a214H
	DD	0600fH
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_maddr_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900__and_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_validate_operand DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetch4 DD 011101H
	DD	08211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01dH
	DW	0114H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetch4_full DD 032219H
	DD	0700fa213H
	DD	0600eH
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390__and_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_validate_operand DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch4 DD 011101H
	DD	0a211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01dH
	DW	010cH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch4_full DD 032219H
	DD	0700fa213H
	DD	0600eH
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370__and_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_get_storekey_ptr DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_diagnose_call
	DD	025H
	DD	01273H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_diagnose_call
	DD	025H
	DD	0129fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_diagnose_call
	DD	025H
	DD	01203H
voltbl	ENDS
xdata	SEGMENT
$unwind$s370_diagnose_call DD 032d19H
	DD	034011bH
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	0190H
$unwind$s390_diagnose_call DD 032d19H
	DD	034011bH
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	0190H
$unwind$z900_diagnose_call DD 032d19H
	DD	034011bH
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	0190H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_validate_operand
_TEXT	SEGMENT
tv81 = 48
addr$ = 80
arn$ = 88
len$ = 96
acctype$ = 104
regs$ = 112
z900_validate_operand PROC				; COMDAT

; 1376 : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1377 :     /* Translate address of leftmost operand byte */
; 1378 :     MADDR( addr, arn, regs, acctype, regs->psw.pkey );

  00017	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0001c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00020	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00024	8b 44 24 68	 mov	 eax, DWORD PTR acctype$[rsp]
  00028	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0002c	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  00031	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00036	ba 01 00 00 00	 mov	 edx, 1
  0003b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00040	e8 00 00 00 00	 call	 z900_maddr_l

; 1379 : 
; 1380 :     /* Translate next page if boundary crossed */
; 1381 :     if (CROSSPAGE( addr, len ))

  00045	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  0004a	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00050	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  00055	2b 4c 24 60	 sub	 ecx, DWORD PTR len$[rsp]
  00059	3b c1		 cmp	 eax, ecx
  0005b	7e 0a		 jle	 SHORT $LN6@z900_valid
  0005d	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
  00065	eb 08		 jmp	 SHORT $LN7@z900_valid
$LN6@z900_valid:
  00067	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN7@z900_valid:
  0006f	83 7c 24 30 00	 cmp	 DWORD PTR tv81[rsp], 0
  00074	74 48		 je	 SHORT $LN2@z900_valid

; 1382 :     {
; 1383 :         MADDR( (addr + len) & ADDRESS_MAXWRAP( regs ),

  00076	48 63 44 24 60	 movsxd	 rax, DWORD PTR len$[rsp]
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00080	48 03 c8	 add	 rcx, rax
  00083	48 8b c1	 mov	 rax, rcx
  00086	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0008b	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00092	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0009b	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0009f	8b 4c 24 68	 mov	 ecx, DWORD PTR acctype$[rsp]
  000a3	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  000a7	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000ac	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  000b1	ba 01 00 00 00	 mov	 edx, 1
  000b6	48 8b c8	 mov	 rcx, rax
  000b9	e8 00 00 00 00	 call	 z900_maddr_l
$LN2@z900_valid:

; 1384 :                arn, regs, acctype, regs->psw.pkey );
; 1385 :     }
; 1386 : #if defined( FEATURE_INTERVAL_TIMER )
; 1387 :     else
; 1388 :         ITIMER_SYNC( addr, len, regs );
; 1389 : #endif
; 1390 : }

  000be	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c2	c3		 ret	 0
z900_validate_operand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
z900_vfetch4 PROC					; COMDAT

; 695  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 696  :     if ((likely(!((VADR_L)addr & 0x03))
; 697  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3) )))

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00017	48 83 e0 03	 and	 rax, 3
  0001b	48 85 c0	 test	 rax, rax
  0001e	75 0a		 jne	 SHORT $LN5@z900_vfetc
  00020	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00028	eb 08		 jmp	 SHORT $LN6@z900_vfetc
$LN5@z900_vfetc:
  0002a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN6@z900_vfetc:
  00032	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00037	74 0a		 je	 SHORT $LN9@z900_vfetc
  00039	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00041	eb 08		 jmp	 SHORT $LN10@z900_vfetc
$LN9@z900_vfetc:
  00043	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN10@z900_vfetc:
  0004b	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00050	75 13		 jne	 SHORT $LN3@z900_vfetc
  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00057	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0005d	48 3d fc 0f 00
	00		 cmp	 rax, 4092		; 00000ffcH
  00063	77 46		 ja	 SHORT $LN2@z900_vfetc
$LN3@z900_vfetc:

; 698  :     {
; 699  :         BYTE *mn;
; 700  :         ITIMER_SYNC( addr, 4-1, regs );
; 701  :         mn = MADDRL( addr, 4,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00065	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0006e	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00072	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0007a	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0007f	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00084	ba 04 00 00 00	 mov	 edx, 4
  00089	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  0008e	e8 00 00 00 00	 call	 z900_maddr_l
  00093	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 702  :         return fetch_fw( mn );

  00098	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  0009d	e8 00 00 00 00	 call	 fetch_fw_noswap
  000a2	8b c8		 mov	 ecx, eax
  000a4	e8 00 00 00 00	 call	 _byteswap_ulong
  000a9	eb 13		 jmp	 SHORT $LN1@z900_vfetc
$LN2@z900_vfetc:

; 703  :     }
; 704  :     return ARCH_DEP( vfetch4_full )( addr, arn, regs );

  000ab	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  000b0	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  000b4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  000b9	e8 00 00 00 00	 call	 z900_vfetch4_full
$LN1@z900_vfetc:

; 705  : }

  000be	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c2	c3		 ret	 0
z900_vfetch4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstorec
_TEXT	SEGMENT
len2$ = 48
tv76 = 52
sk$ = 56
tv83 = 64
main1$ = 72
main2$ = 80
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
z900_vstorec PROC					; COMDAT

; 489  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00021	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00027	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002f	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00034	2b d1		 sub	 edx, ecx
  00036	8b ca		 mov	 ecx, edx
  00038	3b c1		 cmp	 eax, ecx
  0003a	7f 0a		 jg	 SHORT $LN7@z900_vstor
  0003c	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00044	eb 08		 jmp	 SHORT $LN8@z900_vstor
$LN7@z900_vstor:
  00046	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN8@z900_vstor:
  0004e	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  00053	74 70		 je	 SHORT $LN2@z900_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00055	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005d	ff c0		 inc	 eax
  0005f	48 98		 cdqe
  00061	48 89 44 24 40	 mov	 QWORD PTR tv83[rsp], rax
  00066	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0006e	ff c1		 inc	 ecx
  00070	48 63 c9	 movsxd	 rcx, ecx
  00073	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0007b	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0007f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00083	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008b	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00093	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0009b	48 8b d1	 mov	 rdx, rcx
  0009e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  000a6	e8 00 00 00 00	 call	 z900_maddr_l
  000ab	48 8b f8	 mov	 rdi, rax
  000ae	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR tv83[rsp]
  000bb	48 8b c8	 mov	 rcx, rax
  000be	f3 a4		 rep movsb

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );
; 499  :     }

  000c0	e9 33 01 00 00	 jmp	 $LN3@z900_vstor
$LN2@z900_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000c5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000cd	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000d3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000d8	48 2b c8	 sub	 rcx, rax
  000db	48 8b c1	 mov	 rax, rcx
  000de	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  000e2	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000e7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ef	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000f3	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000f7	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000ff	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00107	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0010f	48 8b d0	 mov	 rdx, rax
  00112	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0011a	e8 00 00 00 00	 call	 z900_maddr_l
  0011f	48 89 44 24 48	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  00124	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00133	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  00138	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00140	ff c0		 inc	 eax
  00142	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00146	48 98		 cdqe
  00148	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0014d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  00155	48 03 d1	 add	 rdx, rcx
  00158	48 8b ca	 mov	 rcx, rdx
  0015b	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00163	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  0016a	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00172	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00176	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0017a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00182	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0018a	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00192	48 8b d0	 mov	 rdx, rax
  00195	e8 00 00 00 00	 call	 z900_maddr_l
  0019a	48 89 44 24 50	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  0019f	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  001a4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a7	83 c8 06	 or	 eax, 6
  001aa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  001af	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  001b1	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001b6	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main1$[rsp]
  001bb	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  001c3	48 8b c8	 mov	 rcx, rax
  001c6	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  001c8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001d0	ff c0		 inc	 eax
  001d2	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001d6	48 98		 cdqe
  001d8	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001dd	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  001e5	48 03 d1	 add	 rdx, rcx
  001e8	48 8b ca	 mov	 rcx, rdx
  001eb	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main2$[rsp]
  001f0	48 8b f1	 mov	 rsi, rcx
  001f3	48 8b c8	 mov	 rcx, rax
  001f6	f3 a4		 rep movsb
$LN3@z900_vstor:

; 512  :     }
; 513  : }

  001f8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001fc	5f		 pop	 rdi
  001fd	5e		 pop	 rsi
  001fe	c3		 ret	 0
z900_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch4_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 72
addr$ = 112
arn$ = 120
regs$ = 128
z900_vfetch4_full PROC					; COMDAT

; 428  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 429  : BYTE   *mn;                             /* Main storage addresses    */
; 430  : int     len;                            /* Length to end of page     */
; 431  : BYTE    temp[8];                        /* Copy destination          */
; 432  : 
; 433  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00023	48 8b 44 24 70	 mov	 rax, QWORD PTR addr$[rsp]
  00028	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0002e	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00033	48 2b c8	 sub	 rcx, rax
  00036	48 8b c1	 mov	 rax, rcx
  00039	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 434  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0003d	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00042	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004a	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0004e	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00052	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0005a	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00062	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  00067	48 8b d0	 mov	 rdx, rax
  0006a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR addr$[rsp]
  0006f	e8 00 00 00 00	 call	 z900_maddr_l
  00074	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 435  :     memcpy( temp, mn, len);

  00079	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0007e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00083	48 8b f9	 mov	 rdi, rcx
  00086	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  0008b	48 8b c8	 mov	 rcx, rax
  0008e	f3 a4		 rep movsb

; 436  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4 - len, arn, regs,

  00090	b8 04 00 00 00	 mov	 eax, 4
  00095	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00099	48 98		 cdqe
  0009b	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000a0	48 8b 54 24 70	 mov	 rdx, QWORD PTR addr$[rsp]
  000a5	48 03 d1	 add	 rdx, rcx
  000a8	48 8b ca	 mov	 rcx, rdx
  000ab	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b3	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000ba	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000c2	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000c6	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000ca	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000d2	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000da	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  000df	48 8b d0	 mov	 rdx, rax
  000e2	e8 00 00 00 00	 call	 z900_maddr_l
  000e7	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 437  :                   ACCTYPE_READ, regs->psw.pkey );
; 438  :     memcpy( temp+len, mn, 4 - len);

  000ec	b8 04 00 00 00	 mov	 eax, 4
  000f1	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000f5	48 98		 cdqe
  000f7	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000fc	48 8d 4c 0c 40	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00101	48 8b f9	 mov	 rdi, rcx
  00104	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00109	48 8b c8	 mov	 rcx, rax
  0010c	f3 a4		 rep movsb

; 439  :     return fetch_fw( temp );

  0010e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00113	e8 00 00 00 00	 call	 fetch_fw_noswap
  00118	8b c8		 mov	 ecx, eax
  0011a	e8 00 00 00 00	 call	 _byteswap_ulong

; 440  : }

  0011f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00124	48 33 cc	 xor	 rcx, rsp
  00127	e8 00 00 00 00	 call	 __security_check_cookie
  0012c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00130	5f		 pop	 rdi
  00131	5e		 pop	 rsi
  00132	c3		 ret	 0
z900_vfetch4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
z900_maddr_l PROC					; COMDAT

; 307  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00018	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001d	7c 0a		 jl	 SHORT $LN16@z900_maddr
  0001f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00027	eb 19		 jmp	 SHORT $LN17@z900_maddr
$LN16@z900_maddr:
  00029	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002d	83 c0 05	 add	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003e	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN17@z900_maddr:
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00046	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0004f	48 c1 e8 0c	 shr	 rax, 12
  00053	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  00059	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00067	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  0006c	0f 84 2d 01 00
	00		 je	 $LN2@z900_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 5a		 jne	 SHORT $LN4@z900_maddr
  00078	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	48 98		 cdqe
  00080	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00085	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	49 8b 8c c8 60
	b0 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+45152]
  00097	48 39 8c c2 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax*8+1536], rcx
  0009f	74 31		 je	 SHORT $LN4@z900_maddr
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	48 98		 cdqe
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b6	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000c0	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c8	23 c1		 and	 eax, ecx
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 cd 00 00
	00		 je	 $LN3@z900_maddr
$LN4@z900_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 2e		 jne	 SHORT $LN6@z900_maddr
  000d8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 22		 je	 SHORT $LN6@z900_maddr
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000ec	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f6	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000fe	3b c1		 cmp	 eax, ecx
  00100	0f 85 99 00 00
	00		 jne	 $LN5@z900_maddr
$LN6@z900_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0010b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0011c	48 0b c1	 or	 rax, rcx
  0011f	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00131	75 6c		 jne	 SHORT $LN7@z900_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00133	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  00145	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  0014c	23 c8		 and	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	85 c0		 test	 eax, eax
  00152	74 4b		 je	 SHORT $LN8@z900_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00154	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 1e		 je	 SHORT $LN9@z900_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00162	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00167	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  00179	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@z900_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00180	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 54 24 60	 mov	 rdx, QWORD PTR addr$[rsp]
  0018f	48 8b 84 c1 60
	10 01 00	 mov	 rax, QWORD PTR [rcx+rax*8+69728]
  00197	48 33 c2	 xor	 rax, rdx
  0019a	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@z900_maddr:
$LN7@z900_maddr:
$LN5@z900_maddr:
$LN3@z900_maddr:
$LN2@z900_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  001a5	75 36		 jne	 SHORT $LN10@z900_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001b9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001bd	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001c5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  001d3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001d8	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@z900_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 09	 imul	 rax, rax, 9
  001e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001f3	83 e0 40	 and	 eax, 64			; 00000040H
  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 89 00 00
	00		 je	 $LN11@z900_maddr

; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */

  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	75 26		 jne	 SHORT $LN13@z900_maddr
  00204	48 83 7c 24 78
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0020a	74 1e		 je	 SHORT $LN13@z900_maddr
  0020c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00211	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00218	85 c0		 test	 eax, eax
  0021a	74 0e		 je	 SHORT $LN13@z900_maddr
  0021c	83 7c 24 70 ff	 cmp	 DWORD PTR arn$[rsp], -1
  00221	74 07		 je	 SHORT $LN13@z900_maddr
  00223	83 7c 24 70 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00228	75 07		 jne	 SHORT $LN12@z900_maddr
$LN13@z900_maddr:

; 385  :         )
; 386  :             return maddr;

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  0022f	eb 5b		 jmp	 SHORT $LN1@z900_maddr
$LN12@z900_maddr:

; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	0f b6 80 4b 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3659]
  0023d	85 c0		 test	 eax, eax
  0023f	74 13		 je	 SHORT $LN14@z900_maddr

; 390  :         {
; 391  :             regs->txf_NTSTG = false;

  00241	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00246	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 392  :             return maddr;

  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00252	eb 38		 jmp	 SHORT $LN1@z900_maddr
$LN14@z900_maddr:

; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );

  00254	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00259	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00265	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00269	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0026e	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00273	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00278	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  0027d	e8 00 00 00 00	 call	 txf_maddr_l
  00282	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN11@z900_maddr:

; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
$LN1@z900_maddr:

; 401  : }

  0028c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00290	c3		 ret	 0
z900_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
z900__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@z900__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@z900__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@z900__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@z900__or_s
$LN5@z900__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@z900__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
z900__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900__and_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
z900__and_storage_key PROC				; COMDAT

; 172  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@z900__and_:

; 173  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@z900__and_

; 174  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 54		 je	 SHORT $LN5@z900__and_

; 175  :     {
; 176  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 177  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 178  :         AND_SKEY( skey1_ptr, ~bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	f7 d0		 not	 eax
  00043	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00048	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0004b	23 c8		 and	 ecx, eax
  0004d	8b c1		 mov	 eax, ecx
  0004f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00054	88 01		 mov	 BYTE PTR [rcx], al

; 179  :         AND_SKEY( skey2_ptr, ~bits );

  00056	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  0005b	f7 d0		 not	 eax
  0005d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00062	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00065	23 c8		 and	 ecx, eax
  00067	8b c1		 mov	 eax, ecx
  00069	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006e	88 01		 mov	 BYTE PTR [rcx], al

; 180  :     }

  00070	eb 2e		 jmp	 SHORT $LN6@z900__and_
$LN5@z900__and_:

; 181  :     else
; 182  :     {
; 183  :         BYTE* skey_ptr  = _get_storekey_ptr(  abs, K );

  00072	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00077	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  0007c	e8 00 00 00 00	 call	 _get_storekey_ptr
  00081	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 184  :         AND_SKEY( skey_ptr, ~bits );

  00086	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  0008b	f7 d0		 not	 eax
  0008d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00092	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00095	23 c8		 and	 ecx, eax
  00097	8b c1		 mov	 eax, ecx
  00099	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0009e	88 01		 mov	 BYTE PTR [rcx], al
$LN6@z900__and_:

; 185  :     }
; 186  : }

  000a0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a4	c3		 ret	 0
z900__and_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\diagnose.c
_TEXT	SEGMENT
tv64 = 64
n$ = 68
opt$1 = 72
cpu$2 = 76
i$3 = 80
i$4 = 84
rc$5 = 88
rc$6 = 92
code$ = 96
bodysize$7 = 100
i$8 = 104
tv220 = 108
tv350 = 112
lopasize$9 = 116
headsize$10 = 120
usecs$11 = 124
instcount$12 = 128
stgarea$13 = 136
mask$14 = 144
mask$15 = 152
secs$16 = 160
tv601 = 168
tv670 = 176
ipb$17 = 192
__$ArrayPad$ = 400
regs$ = 432
r1$ = 440
r3$ = 448
b2$ = 456
effective_addr2$ = 464
z900_diagnose_call PROC

; 240  : {

$LN152:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 81 ec a0 01
	00 00		 sub	 rsp, 416		; 000001a0H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 241  : #ifdef FEATURE_HERCULES_DIAGCALLS
; 242  : U32   n;                                /* 32-bit operand value      */
; 243  : #endif /*FEATURE_HERCULES_DIAGCALLS*/
; 244  : U32   code;
; 245  : 
; 246  :     code = effective_addr2;

  0002d	8b 84 24 d0 01
	00 00		 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00034	89 44 24 60	 mov	 DWORD PTR code$[rsp], eax

; 247  : 
; 248  :     switch(code) {

  00038	8b 44 24 60	 mov	 eax, DWORD PTR code$[rsp]
  0003c	89 44 24 40	 mov	 DWORD PTR tv64[rsp], eax
  00040	81 7c 24 40 04
	02 00 00	 cmp	 DWORD PTR tv64[rsp], 516 ; 00000204H
  00048	77 3b		 ja	 SHORT $LN144@z900_diagn
  0004a	81 7c 24 40 04
	02 00 00	 cmp	 DWORD PTR tv64[rsp], 516 ; 00000204H
  00052	0f 84 af 01 00
	00		 je	 $LN60@z900_diagn
  00058	81 7c 24 40 dc
	00 00 00	 cmp	 DWORD PTR tv64[rsp], 220 ; 000000dcH
  00060	0f 87 a4 10 00
	00		 ja	 $LN133@z900_diagn
  00066	8b 44 24 40	 mov	 eax, DWORD PTR tv64[rsp]
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00071	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN150@z900_diagn[rcx+rax]
  00079	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN151@z900_diagn[rcx+rax*4]
  00080	48 03 c1	 add	 rax, rcx
  00083	ff e0		 jmp	 rax
$LN144@z900_diagn:
  00085	81 7c 24 40 00
	0f 00 00	 cmp	 DWORD PTR tv64[rsp], 3840 ; 00000f00H
  0008d	77 48		 ja	 SHORT $LN145@z900_diagn
  0008f	81 7c 24 40 00
	0f 00 00	 cmp	 DWORD PTR tv64[rsp], 3840 ; 00000f00H
  00097	0f 84 d5 09 00
	00		 je	 $LN100@z900_diagn
  0009d	8b 44 24 40	 mov	 eax, DWORD PTR tv64[rsp]
  000a1	2d 10 02 00 00	 sub	 eax, 528		; 00000210H
  000a6	89 44 24 40	 mov	 DWORD PTR tv64[rsp], eax
  000aa	81 7c 24 40 f8
	00 00 00	 cmp	 DWORD PTR tv64[rsp], 248 ; 000000f8H
  000b2	0f 87 52 10 00
	00		 ja	 $LN133@z900_diagn
  000b8	8b 44 24 40	 mov	 eax, DWORD PTR tv64[rsp]
  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000c3	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN148@z900_diagn[rcx+rax]
  000cb	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN149@z900_diagn[rcx+rax*4]
  000d2	48 03 c1	 add	 rax, rcx
  000d5	ff e0		 jmp	 rax
$LN145@z900_diagn:
  000d7	8b 44 24 40	 mov	 eax, DWORD PTR tv64[rsp]
  000db	2d 04 0f 00 00	 sub	 eax, 3844		; 00000f04H
  000e0	89 44 24 40	 mov	 DWORD PTR tv64[rsp], eax
  000e4	81 7c 24 40 f9
	00 00 00	 cmp	 DWORD PTR tv64[rsp], 249 ; 000000f9H
  000ec	0f 87 18 10 00
	00		 ja	 $LN133@z900_diagn
  000f2	8b 44 24 40	 mov	 eax, DWORD PTR tv64[rsp]
  000f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000fd	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN146@z900_diagn[rcx+rax]
  00105	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN147@z900_diagn[rcx+rax*4]
  0010c	48 03 c1	 add	 rax, rcx
  0010f	ff e0		 jmp	 rax
$LN53@z900_diagn:

; 249  : 
; 250  : 
; 251  : #if defined(FEATURE_IO_ASSIST)
; 252  :     case 0x002:
; 253  :     /*---------------------------------------------------------------*/
; 254  :     /* Diagnose 002: Update Interrupt Interlock Control Bit in PMCW  */
; 255  :     /*---------------------------------------------------------------*/
; 256  : 
; 257  :         ARCH_DEP(diagnose_002) (regs, r1, r3);

  00111	44 8b 84 24 c0
	01 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  00119	8b 94 24 b8 01
	00 00		 mov	 edx, DWORD PTR r1$[rsp]
  00120	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00128	e8 00 00 00 00	 call	 z900_diagnose_002

; 258  : 
; 259  :         break;

  0012d	e9 41 11 00 00	 jmp	 $LN2@z900_diagn
$LN54@z900_diagn:

; 260  : #endif
; 261  : 
; 262  : 
; 263  :     case 0x01F:
; 264  :     /*---------------------------------------------------------------*/
; 265  :     /* Diagnose 01F: Power Off                                       */
; 266  :     /*---------------------------------------------------------------*/
; 267  : 
; 268  :         /* If diag8opt is not enabled then we are not allowed
; 269  :          * to manipulate the real machine i.e. hercules itself
; 270  :          */
; 271  :         if(!(sysblk.diag8opt & DIAG8CMD_ENABLE))

  00132	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00139	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  00140	83 e0 01	 and	 eax, 1
  00143	85 c0		 test	 eax, eax
  00145	75 12		 jne	 SHORT $LN55@z900_diagn

; 272  :             ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00147	ba 06 00 00 00	 mov	 edx, 6
  0014c	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00154	e8 00 00 00 00	 call	 z900_program_interrupt
$LN55@z900_diagn:

; 273  : 
; 274  :         /* The poweroff diagnose is only valid on the 9221 */
; 275  :         if (sysblk.cpumodel != 0x9221
; 276  :           /* and r1/r3 must contain C'POWEROFF' in EBCDIC */
; 277  :           || regs->GR_L(r1) != 0xD7D6E6C5
; 278  :           || regs->GR_L(r3) != 0xD9D6C6C6)

  00159	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00160	0f b7 80 d4 00
	00 00		 movzx	 eax, WORD PTR [rax+212]
  00167	3d 21 92 00 00	 cmp	 eax, 37409		; 00009221H
  0016c	75 3a		 jne	 SHORT $LN57@z900_diagn
  0016e	48 63 84 24 b8
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00176	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017e	81 bc c1 80 02
	00 00 c5 e6 d6
	d7		 cmp	 DWORD PTR [rcx+rax*8+640], -673782075 ; d7d6e6c5H
  00189	75 1d		 jne	 SHORT $LN57@z900_diagn
  0018b	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00193	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0019b	81 bc c1 80 02
	00 00 c6 c6 d6
	d9		 cmp	 DWORD PTR [rcx+rax*8+640], -640235834 ; d9d6c6c6H
  001a6	74 12		 je	 SHORT $LN56@z900_diagn
$LN57@z900_diagn:

; 279  :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  001a8	ba 06 00 00 00	 mov	 edx, 6
  001ad	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	e8 00 00 00 00	 call	 z900_program_interrupt
$LN56@z900_diagn:

; 280  : 
; 281  :         regs->cpustate = CPUSTATE_STOPPING;

  001ba	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c2	c6 40 60 02	 mov	 BYTE PTR [rax+96], 2
$LN6@z900_diagn:

; 282  :         ON_IC_INTERRUPT(regs);

  001c6	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ce	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  001d1	0f ba e8 1f	 bts	 eax, 31
  001d5	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001dd	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  001e0	33 c0		 xor	 eax, eax
  001e2	85 c0		 test	 eax, eax
  001e4	75 e0		 jne	 SHORT $LN6@z900_diagn

; 283  : 
; 284  :         /* Release the configuration */
; 285  :         do_shutdown();

  001e6	e8 00 00 00 00	 call	 do_shutdown

; 286  : 
; 287  :         /* Power Off: exit hercules */
; 288  :         exit(0);

  001eb	33 c9		 xor	 ecx, ecx
  001ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN58@z900_diagn:

; 289  : 
; 290  : #if defined(FEATURE_HYPERVISOR) || defined(FEATURE_EMULATE_VM)
; 291  :     case 0x044:
; 292  :     /*---------------------------------------------------------------*/
; 293  :     /* Diagnose 044: Voluntary Time Slice End                        */
; 294  :     /*---------------------------------------------------------------*/
; 295  :         ARCH_DEP(scpend_call) ();

  001f3	e8 00 00 00 00	 call	 z900_scpend_call

; 296  :         break;

  001f8	e9 76 10 00 00	 jmp	 $LN2@z900_diagn
$LN59@z900_diagn:

; 297  : #endif
; 298  : 
; 299  : 
; 300  : #ifdef FEATURE_MSSF_CALL
; 301  :     case 0x080:
; 302  :     /*---------------------------------------------------------------*/
; 303  :     /* Diagnose 080: MSSF Call                                       */
; 304  :     /*---------------------------------------------------------------*/
; 305  :         regs->psw.cc = ARCH_DEP(mssf_call) (r1, r3, regs);
; 306  :         break;
; 307  : #endif /*FEATURE_MSSF_CALL*/
; 308  : 
; 309  : 
; 310  : #if defined(FEATURE_HYPERVISOR) || defined(FEATURE_EMULATE_VM)
; 311  :     case 0x09C:
; 312  :     /*---------------------------------------------------------------*/
; 313  :     /* Diagnose 09C: Voluntary Time Slice End With Target CPU        */
; 314  :     /*---------------------------------------------------------------*/
; 315  :         ARCH_DEP(scpend_call) ();   // (treat same as DIAG X'44')

  001fd	e8 00 00 00 00	 call	 z900_scpend_call

; 316  :         break;

  00202	e9 6c 10 00 00	 jmp	 $LN2@z900_diagn
$LN60@z900_diagn:

; 317  : #endif
; 318  : 
; 319  : 
; 320  : #if defined(FEATURE_HYPERVISOR)
; 321  :     case 0x204:
; 322  :     /*---------------------------------------------------------------*/
; 323  :     /* Diagnose 204: LPAR RMF Interface                              */
; 324  :     /*---------------------------------------------------------------*/
; 325  :         ARCH_DEP(diag204_call) (r1, r3, regs);

  00207	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0020f	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  00216	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  0021d	e8 00 00 00 00	 call	 z900_diag204_call

; 326  :         regs->psw.cc = 0;

  00222	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022a	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 327  :         break;

  0022e	e9 40 10 00 00	 jmp	 $LN2@z900_diagn
$LN61@z900_diagn:

; 328  : 
; 329  :     case 0x224:
; 330  :     /*---------------------------------------------------------------*/
; 331  :     /* Diagnose 224: CPU Names                                       */
; 332  :     /*---------------------------------------------------------------*/
; 333  :         ARCH_DEP(diag224_call) (r1, r3, regs);

  00233	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0023b	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  00242	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  00249	e8 00 00 00 00	 call	 z900_diag224_call

; 334  :         regs->psw.cc = 0;

  0024e	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00256	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 335  :         break;

  0025a	e9 14 10 00 00	 jmp	 $LN2@z900_diagn
$LN62@z900_diagn:

; 336  : #endif /*defined(FEATURE_HYPERVISOR)*/
; 337  : 
; 338  : #if 0
; 339  :     case 0x21C:
; 340  :     /*---------------------------------------------------------------*/
; 341  :     /* Diagnose 21C: ????                                            */
; 342  :     /*---------------------------------------------------------------*/
; 343  :         /*INCOMPLETE*/
; 344  :         regs->psw.cc = 0;
; 345  :         break;
; 346  : #endif
; 347  : 
; 348  : #if 0
; 349  :     case 0x288;:
; 350  :     /*---------------------------------------------------------------*/
; 351  :     /* Diagnose 288: Control Virtual Machine Time Bomb               */
; 352  :     /*---------------------------------------------------------------*/
; 353  :         regs->psw.cc = ARCH_DEP(vm_timebomb) (r1, r3, regs);
; 354  :         break;
; 355  : #endif
; 356  : 
; 357  : #ifdef FEATURE_EMULATE_VM
; 358  :     case 0x000:
; 359  :     /*---------------------------------------------------------------*/
; 360  :     /* Diagnose 000: Store Extended Identification Code              */
; 361  :     /*---------------------------------------------------------------*/
; 362  :         ARCH_DEP(extid_call) (r1, r3, regs);

  0025f	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00267	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  0026e	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  00275	e8 00 00 00 00	 call	 z900_extid_call

; 363  :         break;

  0027a	e9 f4 0f 00 00	 jmp	 $LN2@z900_diagn
$LN63@z900_diagn:

; 364  : 
; 365  :     case 0x008:
; 366  :     /*---------------------------------------------------------------*/
; 367  :     /* Diagnose 008: Virtual Console Function                        */
; 368  :     /*---------------------------------------------------------------*/
; 369  :         /* If diag8opt is not enabled then we are not allowed
; 370  :          * to manipulate the real machine i.e. hercules itself
; 371  :          */
; 372  :         if(!(sysblk.diag8opt & DIAG8CMD_ENABLE))

  0027f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00286	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  0028d	83 e0 01	 and	 eax, 1
  00290	85 c0		 test	 eax, eax
  00292	75 12		 jne	 SHORT $LN64@z900_diagn

; 373  :             ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00294	ba 06 00 00 00	 mov	 edx, 6
  00299	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a1	e8 00 00 00 00	 call	 z900_program_interrupt
$LN64@z900_diagn:

; 374  : 
; 375  :         /* Process CP command and set condition code */
; 376  :         regs->psw.cc = ARCH_DEP(cpcmd_call) (r1, r3, regs);

  002a6	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002ae	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  002b5	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  002bc	e8 00 00 00 00	 call	 z900_cpcmd_call
  002c1	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c9	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 377  :         break;

  002cc	e9 a2 0f 00 00	 jmp	 $LN2@z900_diagn
$LN65@z900_diagn:

; 378  : 
; 379  :     case 0x00C:
; 380  :     /*---------------------------------------------------------------*/
; 381  :     /* Diagnose 00C: Pseudo Timer                                    */
; 382  :     /*---------------------------------------------------------------*/
; 383  :         ARCH_DEP(pseudo_timer) (code, r1, r3, regs);

  002d1	4c 8b 8c 24 b0
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  002d9	44 8b 84 24 c0
	01 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  002e1	8b 94 24 b8 01
	00 00		 mov	 edx, DWORD PTR r1$[rsp]
  002e8	8b 4c 24 60	 mov	 ecx, DWORD PTR code$[rsp]
  002ec	e8 00 00 00 00	 call	 z900_pseudo_timer

; 384  :         break;

  002f1	e9 7d 0f 00 00	 jmp	 $LN2@z900_diagn
$LN66@z900_diagn:

; 385  : 
; 386  :     case 0x024:
; 387  :     /*---------------------------------------------------------------*/
; 388  :     /* Diagnose 024: Device Type and Features                        */
; 389  :     /*---------------------------------------------------------------*/
; 390  :         regs->psw.cc = ARCH_DEP(diag_devtype) (r1, r3, regs);

  002f6	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002fe	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  00305	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  0030c	e8 00 00 00 00	 call	 z900_diag_devtype
  00311	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00319	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 391  :         break;

  0031c	e9 52 0f 00 00	 jmp	 $LN2@z900_diagn
$LN67@z900_diagn:

; 392  : 
; 393  :     case 0x05C:
; 394  :     /*---------------------------------------------------------------*/
; 395  :     /* Diagnose 05C: Error Message Editing                           */
; 396  :     /*---------------------------------------------------------------*/
; 397  :         /* This function is implemented as a no-operation */
; 398  :         regs->psw.cc = 0;

  00321	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00329	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 399  :         break;

  0032d	e9 41 0f 00 00	 jmp	 $LN2@z900_diagn
$LN68@z900_diagn:

; 400  : 
; 401  :     case 0x060:
; 402  :     /*---------------------------------------------------------------*/
; 403  :     /* Diagnose 060: Virtual Machine Storage Size                    */
; 404  :     /*---------------------------------------------------------------*/
; 405  :         /* Load main storage size in bytes into R1 register */
; 406  :         regs->GR_L(r1) = regs->mainlim + 1;

  00332	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0033a	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00341	48 ff c0	 inc	 rax
  00344	48 63 8c 24 b8
	01 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0034c	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00354	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 407  :         break;

  0035b	e9 13 0f 00 00	 jmp	 $LN2@z900_diagn
$LN69@z900_diagn:

; 408  : 
; 409  :     case 0x064:
; 410  :     /*---------------------------------------------------------------*/
; 411  :     /* Diagnose 064: Named Saved Segment Manipulation                */
; 412  :     /*---------------------------------------------------------------*/
; 413  :         /* Return code 44 cond code 2 means segment does not exist */
; 414  :         regs->GR_L(r3) = 44;

  00360	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00368	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00370	c7 84 c1 80 02
	00 00 2c 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 44 ; 0000002cH

; 415  :         regs->psw.cc = 2;

  0037b	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00383	c6 40 7c 02	 mov	 BYTE PTR [rax+124], 2

; 416  :         break;

  00387	e9 e7 0e 00 00	 jmp	 $LN2@z900_diagn
$LN70@z900_diagn:

; 417  : 
; 418  :     case 0x0A4:
; 419  :     /*---------------------------------------------------------------*/
; 420  :     /* Diagnose 0A4: Synchronous I/O (Standard CMS Blocksize)        */
; 421  :     /*---------------------------------------------------------------*/
; 422  :         regs->psw.cc = ARCH_DEP(syncblk_io) (r1, r3, regs);

  0038c	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00394	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  0039b	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  003a2	e8 00 00 00 00	 call	 z900_syncblk_io
  003a7	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003af	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 423  : //      logmsg ("Diagnose X\'0A4\': CC=%d, R15=%8.8X\n",      /*debug*/
; 424  : //              regs->psw.cc, regs->GR_L(15));                 /*debug*/
; 425  :         break;

  003b2	e9 bc 0e 00 00	 jmp	 $LN2@z900_diagn
$LN71@z900_diagn:

; 426  : 
; 427  :     case 0x0A8:
; 428  :     /*---------------------------------------------------------------*/
; 429  :     /* Diagnose 0A8: Synchronous General I/O                         */
; 430  :     /*---------------------------------------------------------------*/
; 431  :         regs->psw.cc = ARCH_DEP(syncgen_io) (r1, r3, regs);

  003b7	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003bf	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  003c6	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  003cd	e8 00 00 00 00	 call	 z900_syncgen_io
  003d2	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003da	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 432  : //      logmsg ("Diagnose X\'0A8\': CC=%d, R15=%8.8X\n",      /*debug*/
; 433  : //              regs->psw.cc, regs->GR_L(15));                 /*debug*/
; 434  :         break;

  003dd	e9 91 0e 00 00	 jmp	 $LN2@z900_diagn
$LN72@z900_diagn:

; 435  : 
; 436  :     case 0x0B0:
; 437  :     /*---------------------------------------------------------------*/
; 438  :     /* Diagnose 0B0: Access Re-IPL Data                              */
; 439  :     /*---------------------------------------------------------------*/
; 440  :         ARCH_DEP(access_reipl_data) (r1, r3, regs);

  003e2	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003ea	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  003f1	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  003f8	e8 00 00 00 00	 call	 z900_access_reipl_data

; 441  :         break;

  003fd	e9 71 0e 00 00	 jmp	 $LN2@z900_diagn
$LN73@z900_diagn:

; 442  : 
; 443  :     case 0x0DC:
; 444  :     /*---------------------------------------------------------------*/
; 445  :     /* Diagnose 0DC: Control Application Monitor Record Collection   */
; 446  :     /*---------------------------------------------------------------*/
; 447  :         /* This function is implemented as a no-operation */
; 448  :         regs->GR_L(r3) = 0;

  00402	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0040a	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00412	c7 84 c1 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 0

; 449  :         regs->psw.cc = 0;

  0041d	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00425	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 450  :         break;

  00429	e9 45 0e 00 00	 jmp	 $LN2@z900_diagn
$LN74@z900_diagn:

; 451  : 
; 452  :     case 0x210:
; 453  :     /*---------------------------------------------------------------*/
; 454  :     /* Diagnose 210: Retrieve Device Information                     */
; 455  :     /*---------------------------------------------------------------*/
; 456  :         regs->psw.cc = ARCH_DEP(device_info) (r1, r3, regs);

  0042e	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00436	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  0043d	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  00444	e8 00 00 00 00	 call	 z900_device_info
  00449	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00451	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 457  :         break;

  00454	e9 1a 0e 00 00	 jmp	 $LN2@z900_diagn
$LN75@z900_diagn:

; 458  : 
; 459  :     case 0x214:
; 460  :     /*---------------------------------------------------------------*/
; 461  :     /* Diagnose 214: Pending Page Release                            */
; 462  :     /*---------------------------------------------------------------*/
; 463  :         regs->psw.cc = ARCH_DEP(diag_ppagerel) (r1, r3, regs);

  00459	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00461	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  00468	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  0046f	e8 00 00 00 00	 call	 z900_diag_ppagerel
  00474	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0047c	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 464  :         break;

  0047f	e9 ef 0d 00 00	 jmp	 $LN2@z900_diagn
$LN76@z900_diagn:

; 465  : 
; 466  : 
; 467  :     case 0x220:
; 468  :     /*---------------------------------------------------------------*/
; 469  :     /* Diagnose 220: TOD Epoch                                       */
; 470  :     /*---------------------------------------------------------------*/
; 471  :         ODD_CHECK(r3, regs);

  00484	8b 84 24 c0 01
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0048b	83 e0 01	 and	 eax, 1
  0048e	85 c0		 test	 eax, eax
  00490	74 1b		 je	 SHORT $LN77@z900_diagn
  00492	ba 06 00 00 00	 mov	 edx, 6
  00497	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0049f	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004a7	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN77@z900_diagn:

; 472  : 
; 473  :         switch(regs->GR_L(r1))

  004ad	48 63 84 24 b8
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  004b5	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004bd	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  004c4	89 44 24 6c	 mov	 DWORD PTR tv220[rsp], eax
  004c8	83 7c 24 6c 00	 cmp	 DWORD PTR tv220[rsp], 0
  004cd	74 0c		 je	 SHORT $LN78@z900_diagn
  004cf	83 7c 24 6c 01	 cmp	 DWORD PTR tv220[rsp], 1
  004d4	74 40		 je	 SHORT $LN79@z900_diagn
  004d6	e9 a5 00 00 00	 jmp	 $LN80@z900_diagn
$LN78@z900_diagn:

; 474  :         {
; 475  :             case 0:
; 476  :                 /* Obtain TOD features */
; 477  :                 regs->GR_L(r3)  =0xc0000000;

  004db	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  004e3	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004eb	c7 84 c1 80 02
	00 00 00 00 00
	c0		 mov	 DWORD PTR [rcx+rax*8+640], -1073741824 ; c0000000H

; 478  :                 regs->GR_L(r3+1)=0x00000000;

  004f6	8b 84 24 c0 01
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  004fd	ff c0		 inc	 eax
  004ff	48 98		 cdqe
  00501	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00509	c7 84 c1 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 0

; 479  :                 break;

  00514	eb 7c		 jmp	 SHORT $LN7@z900_diagn
$LN79@z900_diagn:

; 480  :             case 1:
; 481  :                 /* Obtain TOD offset to real TOD in R2, R2+1 */
; 482  :                 regs->GR_L(r3)  = (regs->tod_epoch >> 24) & 0xFFFFFFFF;

  00516	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0051e	48 8b 80 40 07
	00 00		 mov	 rax, QWORD PTR [rax+1856]
  00525	48 c1 f8 18	 sar	 rax, 24
  00529	b9 ff ff ff ff	 mov	 ecx, -1
  0052e	48 23 c1	 and	 rax, rcx
  00531	48 63 8c 24 c0
	01 00 00	 movsxd	 rcx, DWORD PTR r3$[rsp]
  00539	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00541	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 483  :                 regs->GR_L(r3+1)= (regs->tod_epoch << 8) & 0xFFFFFFFF;

  00548	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00550	48 8b 80 40 07
	00 00		 mov	 rax, QWORD PTR [rax+1856]
  00557	48 c1 e0 08	 shl	 rax, 8
  0055b	b9 ff ff ff ff	 mov	 ecx, -1
  00560	48 23 c1	 and	 rax, rcx
  00563	8b 8c 24 c0 01
	00 00		 mov	 ecx, DWORD PTR r3$[rsp]
  0056a	ff c1		 inc	 ecx
  0056c	48 63 c9	 movsxd	 rcx, ecx
  0056f	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00577	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 484  :                 break;

  0057e	eb 12		 jmp	 SHORT $LN7@z900_diagn
$LN80@z900_diagn:

; 485  :             default:
; 486  :                 ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00580	ba 06 00 00 00	 mov	 edx, 6
  00585	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0058d	e8 00 00 00 00	 call	 z900_program_interrupt
$LN7@z900_diagn:

; 487  :         }
; 488  :         break;

  00592	e9 dc 0c 00 00	 jmp	 $LN2@z900_diagn
$LN81@z900_diagn:

; 489  : 
; 490  : 
; 491  :     case 0x23C:
; 492  :     /*---------------------------------------------------------------*/
; 493  :     /* Diagnose 23C: Address Space Services                          */
; 494  :     /*---------------------------------------------------------------*/
; 495  :         /* This function is implemented as a no-operation */
; 496  :         regs->GR_L(r3) = 0;

  00597	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0059f	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005a7	c7 84 c1 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 0

; 497  :         break;

  005b2	e9 bc 0c 00 00	 jmp	 $LN2@z900_diagn
$LN82@z900_diagn:

; 498  : 
; 499  : 
; 500  : #if defined(FEATURE_VM_BLOCKIO)
; 501  :     case 0x250:
; 502  :     /*---------------------------------------------------------------*/
; 503  :     /* Diagnose 250: Standardized Block I/O                          */
; 504  :     /*---------------------------------------------------------------*/
; 505  :         regs->psw.cc = ARCH_DEP(vm_blockio) (r1, r3, regs);

  005b7	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  005bf	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  005c6	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  005cd	e8 00 00 00 00	 call	 z900_vm_blockio
  005d2	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005da	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 506  :         break;

  005dd	e9 91 0c 00 00	 jmp	 $LN2@z900_diagn
$LN83@z900_diagn:

; 507  : #endif /*defined(FEATURE_VM_BLOCKIO)*/
; 508  : 
; 509  : 
; 510  :     case 0x260:
; 511  :     /*---------------------------------------------------------------*/
; 512  :     /* Diagnose 260: Access Certain Virtual Machine Information      */
; 513  :     /*---------------------------------------------------------------*/
; 514  :         ARCH_DEP(vm_info) (r1, r3, regs);

  005e2	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  005ea	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  005f1	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  005f8	e8 00 00 00 00	 call	 z900_vm_info

; 515  :         break;

  005fd	e9 71 0c 00 00	 jmp	 $LN2@z900_diagn
$LN84@z900_diagn:
$LN11@z900_diagn:

; 516  : 
; 517  :     case 0x264:
; 518  :     /*---------------------------------------------------------------*/
; 519  :     /* Diagnose 264: CP Communication                                */
; 520  :     /*---------------------------------------------------------------*/
; 521  :         /* This function is implemented as a no-operation */
; 522  :         PTT_ERR("*DIAG264",regs->GR_L(r1),regs->GR_L(r3),regs->psw.IA_L);

  00602	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00609	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0060c	48 83 e0 10	 and	 rax, 16
  00610	48 85 c0	 test	 rax, rax
  00613	74 6f		 je	 SHORT $LN85@z900_diagn
  00615	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0061d	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00623	48 63 8c 24 c0
	01 00 00	 movsxd	 rcx, DWORD PTR r3$[rsp]
  0062b	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00633	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  0063a	48 63 94 24 b8
	01 00 00	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00642	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0064a	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  00652	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0065b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00660	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193048
  00667	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0066c	44 8b c9	 mov	 r9d, ecx
  0066f	44 8b c2	 mov	 r8d, edx
  00672	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193049
  00679	b9 10 00 00 00	 mov	 ecx, 16
  0067e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN85@z900_diagn:
  00684	33 c0		 xor	 eax, eax
  00686	85 c0		 test	 eax, eax
  00688	0f 85 74 ff ff
	ff		 jne	 $LN11@z900_diagn

; 523  :         regs->psw.cc = 0;

  0068e	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00696	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 524  :         break;

  0069a	e9 d4 0b 00 00	 jmp	 $LN2@z900_diagn
$LN86@z900_diagn:

; 525  : 
; 526  :     case 0x270:
; 527  :     /*---------------------------------------------------------------*/
; 528  :     /* Diagnose 270: Pseudo Timer Extended                           */
; 529  :     /*---------------------------------------------------------------*/
; 530  :         ARCH_DEP(pseudo_timer) (code, r1, r3, regs);

  0069f	4c 8b 8c 24 b0
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  006a7	44 8b 84 24 c0
	01 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  006af	8b 94 24 b8 01
	00 00		 mov	 edx, DWORD PTR r1$[rsp]
  006b6	8b 4c 24 60	 mov	 ecx, DWORD PTR code$[rsp]
  006ba	e8 00 00 00 00	 call	 z900_pseudo_timer

; 531  :         break;

  006bf	e9 af 0b 00 00	 jmp	 $LN2@z900_diagn
$LN87@z900_diagn:
$LN14@z900_diagn:

; 532  : 
; 533  :     case 0x274:
; 534  :     /*---------------------------------------------------------------*/
; 535  :     /* Diagnose 274: Set Timezone Interrupt Flag                     */
; 536  :     /*---------------------------------------------------------------*/
; 537  :         /* This function is implemented as a no-operation */
; 538  :         PTT_ERR("*DIAG274",regs->GR_L(r1),regs->GR_L(r3),regs->psw.IA_L);

  006c4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  006cb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006ce	48 83 e0 10	 and	 rax, 16
  006d2	48 85 c0	 test	 rax, rax
  006d5	74 6f		 je	 SHORT $LN88@z900_diagn
  006d7	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006df	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  006e5	48 63 8c 24 c0
	01 00 00	 movsxd	 rcx, DWORD PTR r3$[rsp]
  006ed	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  006f5	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  006fc	48 63 94 24 b8
	01 00 00	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00704	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0070c	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  00714	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0071d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00722	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193053
  00729	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0072e	44 8b c9	 mov	 r9d, ecx
  00731	44 8b c2	 mov	 r8d, edx
  00734	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193054
  0073b	b9 10 00 00 00	 mov	 ecx, 16
  00740	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN88@z900_diagn:
  00746	33 c0		 xor	 eax, eax
  00748	85 c0		 test	 eax, eax
  0074a	0f 85 74 ff ff
	ff		 jne	 $LN14@z900_diagn

; 539  :         regs->psw.cc = 0;

  00750	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00758	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 540  :         break;

  0075c	e9 12 0b 00 00	 jmp	 $LN2@z900_diagn
$LN89@z900_diagn:
$LN17@z900_diagn:

; 541  : #endif /*FEATURE_EMULATE_VM*/
; 542  : 
; 543  : 
; 544  :     case 0x308:
; 545  :     /*---------------------------------------------------------------*/
; 546  :     /* Diagnose 308: IPL functions                                   */
; 547  :     /*---------------------------------------------------------------*/
; 548  :         PTT_ERR("*DIAG308",regs->GR_G(r1),regs->GR_G(r3),regs->psw.IA_L);

  00761	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00768	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0076b	48 83 e0 10	 and	 rax, 16
  0076f	48 85 c0	 test	 rax, rax
  00772	74 6a		 je	 SHORT $LN90@z900_diagn
  00774	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0077c	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00782	48 63 8c 24 c0
	01 00 00	 movsxd	 rcx, DWORD PTR r3$[rsp]
  0078a	48 63 94 24 b8
	01 00 00	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00792	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0079b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  007a0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193057
  007a7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007ac	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007b4	4c 8b 8c c8 80
	02 00 00	 mov	 r9, QWORD PTR [rax+rcx*8+640]
  007bc	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007c4	4c 8b 84 d0 80
	02 00 00	 mov	 r8, QWORD PTR [rax+rdx*8+640]
  007cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193058
  007d3	b9 10 00 00 00	 mov	 ecx, 16
  007d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN90@z900_diagn:
  007de	33 c0		 xor	 eax, eax
  007e0	85 c0		 test	 eax, eax
  007e2	0f 85 79 ff ff
	ff		 jne	 $LN17@z900_diagn

; 549  : 
; 550  :         switch(regs->GR_L(r3))

  007e8	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  007f0	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007f8	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  007ff	89 44 24 70	 mov	 DWORD PTR tv350[rsp], eax
  00803	83 7c 24 70 01	 cmp	 DWORD PTR tv350[rsp], 1
  00808	74 0c		 je	 SHORT $LN91@z900_diagn
  0080a	83 7c 24 70 06	 cmp	 DWORD PTR tv350[rsp], 6
  0080f	74 0a		 je	 SHORT $LN92@z900_diagn
  00811	e9 45 02 00 00	 jmp	 $LN99@z900_diagn
$LN91@z900_diagn:

; 551  :         {
; 552  : #if defined(FEATURE_PROGRAM_DIRECTED_REIPL)
; 553  :             TID   tid;                              /* Thread identifier         */
; 554  :             char *ipltype;                          /* "ipl" or "iplc"           */
; 555  :             int   rc;
; 556  : #endif /*defined(FEATURE_PROGRAM_DIRECTED_REIPL)*/
; 557  : 
; 558  :         case DIAG308_START_KERNEL:
; 559  :             /*-------------------------------------------------------*/
; 560  :             /* Linux for z uses this function code, without a        */
; 561  :             /* defined value, in a function named start_kernel (see  */
; 562  :             /* ZIPL stage3.c). The Diagnose instruction is DIAG      */
; 563  :             /* 1,1,0x308, with GPR 1 containing DIAG308_START_KERNEL */
; 564  :             /* (i.e. equal to 1). This author has no idea what       */
; 565  :             /* function start_kernel is expecting the Diagnose       */
; 566  :             /* instruction to do (other than starting the kernel!),  */
; 567  :             /* but the function does not check a return code, or     */
; 568  :             /* anything else, and is prepared for the Diagnose       */
; 569  :             /* instruction to program check. Fortunately, the        */
; 570  :             /* function code DIAG308_START_KERNEL and the return     */
; 571  :             /* code DIAG308_RC_OK both have the same value (i.e.     */
; 572  :             /* equal to 1), so we'll simply return without doing     */
; 573  :             /* anything, letting the function code become the        */
; 574  :             /* return code.                                          */
; 575  :             /*-------------------------------------------------------*/
; 576  :             break;

  00816	e9 52 02 00 00	 jmp	 $LN18@z900_diagn
$LN92@z900_diagn:

; 577  : 
; 578  : #if defined(FEATURE_PROGRAM_DIRECTED_REIPL)
; 579  :         case DIAG308_LOAD_CLEAR:
; 580  :             ipltype = "iplc";
; 581  :             goto diag308_cthread;
; 582  :         case DIAG308_LOAD_NORMAL:
; 583  :             ipltype = "ipl";
; 584  :         diag308_cthread:
; 585  :             rc = create_thread(&tid, DETACHED, stop_cpus_and_ipl, ipltype, "Stop cpus and ipl");
; 586  :             if(rc)
; 587  :                 WRMSG(HHC00102, "E", strerror(rc));
; 588  :             regs->cpustate = CPUSTATE_STOPPING;
; 589  :             ON_IC_INTERRUPT(regs);
; 590  :             break;
; 591  :         case DIAG308_SET:
; 592  :             /* INCOMPLETE */
; 593  :             regs->GR(1) = DIAG308_RC_OK;
; 594  :             break;
; 595  : #endif /*defined(FEATURE_PROGRAM_DIRECTED_REIPL)*/
; 596  : 
; 597  :         case DIAG308_STORE:
; 598  :           {
; 599  :             /*-------------------------------------------------------*/
; 600  :             /* On entry                                              */
; 601  :             /*   Rx    Rx must be an even numbered register          */
; 602  :             /*         containing the real address of a 4K page      */
; 603  :             /*         aligned storage area into which the IPL       */
; 604  :             /*         parameter block will be copied.               */
; 605  :             /* On return                                             */
; 606  :             /*   Rx+1  Contains the return code.                     */
; 607  :             /*-------------------------------------------------------*/
; 608  :             RADR    stgarea;            /* Storage area real address */
; 609  :             U32     headsize;
; 610  :             U32     bodysize;
; 611  :             struct ipl_parameter_block  ipb;
; 612  :             int     lopasize;
; 613  : 
; 614  :             /* Program check if running problem state. */
; 615  :             PRIV_CHECK(regs);

  0081b	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00823	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00827	83 e0 01	 and	 eax, 1
  0082a	85 c0		 test	 eax, eax
  0082c	74 1b		 je	 SHORT $LN93@z900_diagn
  0082e	ba 02 00 00 00	 mov	 edx, 2
  00833	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0083b	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00843	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN93@z900_diagn:

; 616  : 
; 617  :             /* Register Rx contains the real address of the storage area. */
; 618  :             if(regs->psw.amode64) {

  00849	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00851	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00857	83 e0 01	 and	 eax, 1
  0085a	85 c0		 test	 eax, eax
  0085c	74 22		 je	 SHORT $LN94@z900_diagn

; 619  :               stgarea = regs->GR_G(r1);

  0085e	48 63 84 24 b8
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00866	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0086e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00876	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR stgarea$13[rsp], rax

; 620  :             } else {

  0087e	eb 1f		 jmp	 SHORT $LN95@z900_diagn
$LN94@z900_diagn:

; 621  :               stgarea = regs->GR_L(r1);

  00880	48 63 84 24 b8
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00888	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00890	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00897	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR stgarea$13[rsp], rax
$LN95@z900_diagn:

; 622  :             }
; 623  : 
; 624  :             /* Program check if Rx is not an even register number or     */
; 625  :             /* the address contained in Rx is not on a 4K page boundary. */
; 626  :             if (r1 & 1 || stgarea & 0xFFF)

  0089f	8b 84 24 b8 01
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  008a6	83 e0 01	 and	 eax, 1
  008a9	85 c0		 test	 eax, eax
  008ab	75 13		 jne	 SHORT $LN97@z900_diagn
  008ad	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR stgarea$13[rsp]
  008b5	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  008bb	48 85 c0	 test	 rax, rax
  008be	74 12		 je	 SHORT $LN96@z900_diagn
$LN97@z900_diagn:

; 627  :             {
; 628  :                 ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  008c0	ba 06 00 00 00	 mov	 edx, 6
  008c5	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008cd	e8 00 00 00 00	 call	 z900_program_interrupt
$LN96@z900_diagn:

; 629  :             }
; 630  : 
; 631  :             /* Ensure that the 4K storage area is addressable. */
; 632  :             ARCH_DEP(validate_operand) (stgarea, USE_REAL_ADDR, 4095, ACCTYPE_WRITE, regs);

  008d2	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008df	41 b9 02 00 00
	00		 mov	 r9d, 2
  008e5	41 b8 ff 0f 00
	00		 mov	 r8d, 4095		; 00000fffH
  008eb	ba fe ff ff ff	 mov	 edx, -2
  008f0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR stgarea$13[rsp]
  008f8	e8 00 00 00 00	 call	 z900_validate_operand

; 633  : 
; 634  :             /* Prepare the IPL parameter block. */
; 635  :             memset(&ipb, 0, sizeof(ipb));

  008fd	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR ipb$17[rsp]
  00905	48 8b f8	 mov	 rdi, rax
  00908	33 c0		 xor	 eax, eax
  0090a	b9 c8 00 00 00	 mov	 ecx, 200		; 000000c8H
  0090f	f3 aa		 rep stosb

; 636  :             /* Setup head and body values common to all. */
; 637  :             ipb.hdr.version = IPL_MAX_SUPPORTED_VERSION;

  00911	c6 84 24 c7 00
	00 00 00	 mov	 BYTE PTR ipb$17[rsp+7], 0

; 638  :             headsize = sizeof(ipb.hdr);

  00919	c7 44 24 78 08
	00 00 00	 mov	 DWORD PTR headsize$10[rsp], 8

; 639  :             memset(ipb.common.loadparm, 0x40, sizeof(ipb.common.loadparm));  /* EBCDIC spaces */

  00921	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR ipb$17[rsp+16]
  00929	48 8b f8	 mov	 rdi, rax
  0092c	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  00931	b9 08 00 00 00	 mov	 ecx, 8
  00936	f3 aa		 rep stosb

; 640  :             lopasize = strlen(sysblk.loadparm);

  00938	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0093f	48 05 38 13 00
	00		 add	 rax, 4920		; 00001338H
  00945	48 8b c8	 mov	 rcx, rax
  00948	e8 00 00 00 00	 call	 strlen
  0094d	89 44 24 74	 mov	 DWORD PTR lopasize$9[rsp], eax

; 641  :             if (lopasize)

  00951	83 7c 24 74 00	 cmp	 DWORD PTR lopasize$9[rsp], 0
  00956	74 23		 je	 SHORT $LN98@z900_diagn

; 642  :             {
; 643  :                 str_host_to_guest(ipb.common.loadparm, sysblk.loadparm, lopasize);

  00958	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0095f	48 05 38 13 00
	00		 add	 rax, 4920		; 00001338H
  00965	44 8b 44 24 74	 mov	 r8d, DWORD PTR lopasize$9[rsp]
  0096a	48 8b d0	 mov	 rdx, rax
  0096d	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR ipb$17[rsp+16]
  00975	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_str_host_to_guest
$LN98@z900_diagn:

; 644  :             }
; 645  :             /* Setup head and body values specific to CCW. */
; 646  :             bodysize = sizeof(ipb.ccw);

  0097b	c7 44 24 64 c0
	00 00 00	 mov	 DWORD PTR bodysize$7[rsp], 192 ; 000000c0H

; 647  :             STORE_FW(&ipb.hdr.len, (headsize + bodysize));

  00983	8b 44 24 64	 mov	 eax, DWORD PTR bodysize$7[rsp]
  00987	8b 4c 24 78	 mov	 ecx, DWORD PTR headsize$10[rsp]
  0098b	03 c8		 add	 ecx, eax
  0098d	8b c1		 mov	 eax, ecx
  0098f	8b c8		 mov	 ecx, eax
  00991	e8 00 00 00 00	 call	 _byteswap_ulong
  00996	8b d0		 mov	 edx, eax
  00998	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR ipb$17[rsp]
  009a0	e8 00 00 00 00	 call	 store_fw_noswap

; 648  :             STORE_FW(&ipb.ccw.len, bodysize);

  009a5	8b 4c 24 64	 mov	 ecx, DWORD PTR bodysize$7[rsp]
  009a9	e8 00 00 00 00	 call	 _byteswap_ulong
  009ae	8b d0		 mov	 edx, eax
  009b0	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR ipb$17[rsp+8]
  009b8	e8 00 00 00 00	 call	 store_fw_noswap

; 649  :             ipb.ccw.pbt = IPL_TYPE_CCW;

  009bd	c6 84 24 cc 00
	00 00 02	 mov	 BYTE PTR ipb$17[rsp+12], 2

; 650  :             STORE_HW(&ipb.ccw.devno, sysblk.ipldev);

  009c5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  009cc	0f b7 88 f2 00
	00 00		 movzx	 ecx, WORD PTR [rax+242]
  009d3	e8 00 00 00 00	 call	 _byteswap_ushort
  009d8	0f b7 d0	 movzx	 edx, ax
  009db	48 8d 8c 24 2e
	01 00 00	 lea	 rcx, QWORD PTR ipb$17[rsp+110]
  009e3	e8 00 00 00 00	 call	 store_hw_noswap

; 651  :             STRLCPY(ipb.ccw.vm_parm, "Hercules");  /* just to show its us! */

  009e8	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  009ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193067
  009f5	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR ipb$17[rsp+128]
  009fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 652  : 
; 653  :             /* Store the IPL parameter block in real storage */
; 654  :             /* Note: vstorec copies a maximum of 256 bytes.  */
; 655  :             ARCH_DEP(vstorec) (&ipb, (headsize+bodysize-1), stgarea, USE_REAL_ADDR, regs);

  00a03	8b 44 24 78	 mov	 eax, DWORD PTR headsize$10[rsp]
  00a07	8b 4c 24 64	 mov	 ecx, DWORD PTR bodysize$7[rsp]
  00a0b	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00a0f	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a17	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00a1c	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  00a22	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR stgarea$13[rsp]
  00a2a	0f b6 d0	 movzx	 edx, al
  00a2d	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR ipb$17[rsp]
  00a35	e8 00 00 00 00	 call	 z900_vstorec

; 656  : 
; 657  :             /* Successful */
; 658  :             regs->GR(r1+1) = DIAG308_RC_OK;

  00a3a	8b 84 24 b8 01
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  00a41	ff c0		 inc	 eax
  00a43	48 98		 cdqe
  00a45	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a4d	48 c7 84 c1 80
	02 00 00 01 00
	00 00		 mov	 QWORD PTR [rcx+rax*8+640], 1

; 659  :             break;

  00a59	eb 12		 jmp	 SHORT $LN18@z900_diagn
$LN99@z900_diagn:

; 660  :           }
; 661  : 
; 662  :         default:
; 663  :             ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00a5b	ba 06 00 00 00	 mov	 edx, 6
  00a60	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a68	e8 00 00 00 00	 call	 z900_program_interrupt
$LN18@z900_diagn:

; 664  :         } /* end switch(r3) */
; 665  :         break;

  00a6d	e9 01 08 00 00	 jmp	 $LN2@z900_diagn
$LN100@z900_diagn:

; 666  : 
; 667  : #ifdef FEATURE_HERCULES_DIAGCALLS
; 668  :     case 0xF00:
; 669  :     /*---------------------------------------------------------------*/
; 670  :     /* Diagnose F00: Hercules normal mode                            */
; 671  :     /*---------------------------------------------------------------*/
; 672  :         /* If diag8opt is not enabled then we are not allowed
; 673  :          * to manipulate the real machine i.e. hercules itself
; 674  :          */
; 675  :         if(!(sysblk.diag8opt & DIAG8CMD_ENABLE))

  00a72	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a79	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  00a80	83 e0 01	 and	 eax, 1
  00a83	85 c0		 test	 eax, eax
  00a85	75 12		 jne	 SHORT $LN101@z900_diagn

; 676  :             ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00a87	ba 06 00 00 00	 mov	 edx, 6
  00a8c	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a94	e8 00 00 00 00	 call	 z900_program_interrupt
$LN101@z900_diagn:

; 677  : 
; 678  :         sysblk.instbreak = 0;

  00a99	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00aa0	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00aa6	0f ba f0 0a	 btr	 eax, 10
  00aaa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00ab1	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
$LN22@z900_diagn:

; 679  :         SET_IC_TRACE;

  00ab7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00abe	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  00ac5	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR mask$14[rsp], rax
  00acd	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$3[rsp], 0
  00ad5	eb 0a		 jmp	 SHORT $LN25@z900_diagn
$LN23@z900_diagn:
  00ad7	8b 44 24 50	 mov	 eax, DWORD PTR i$3[rsp]
  00adb	ff c0		 inc	 eax
  00add	89 44 24 50	 mov	 DWORD PTR i$3[rsp], eax
$LN25@z900_diagn:
  00ae1	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR mask$14[rsp], 0
  00aea	74 58		 je	 SHORT $LN24@z900_diagn
  00aec	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR mask$14[rsp]
  00af4	48 83 e0 01	 and	 rax, 1
  00af8	48 85 c0	 test	 rax, rax
  00afb	74 32		 je	 SHORT $LN102@z900_diagn
  00afd	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$3[rsp]
  00b02	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00b09	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00b11	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00b14	0f ba e8 1f	 bts	 eax, 31
  00b18	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$3[rsp]
  00b1d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00b24	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00b2c	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN102@z900_diagn:
  00b2f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR mask$14[rsp]
  00b37	48 d1 e8	 shr	 rax, 1
  00b3a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR mask$14[rsp], rax
  00b42	eb 93		 jmp	 SHORT $LN23@z900_diagn
$LN24@z900_diagn:
  00b44	33 c0		 xor	 eax, eax
  00b46	85 c0		 test	 eax, eax
  00b48	0f 85 69 ff ff
	ff		 jne	 $LN22@z900_diagn

; 680  :         break;

  00b4e	e9 20 07 00 00	 jmp	 $LN2@z900_diagn
$LN103@z900_diagn:

; 681  : 
; 682  :     case 0xF04:
; 683  :     /*---------------------------------------------------------------*/
; 684  :     /* Diagnose F04: Hercules single step mode                       */
; 685  :     /*---------------------------------------------------------------*/
; 686  :         /* If diag8opt is not enabled then we are not allowed
; 687  :          * to manipulate the real machine i.e. hercules itself
; 688  :          */
; 689  :         if(!(sysblk.diag8opt & DIAG8CMD_ENABLE))

  00b53	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b5a	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  00b61	83 e0 01	 and	 eax, 1
  00b64	85 c0		 test	 eax, eax
  00b66	75 12		 jne	 SHORT $LN104@z900_diagn

; 690  :             ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00b68	ba 06 00 00 00	 mov	 edx, 6
  00b6d	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b75	e8 00 00 00 00	 call	 z900_program_interrupt
$LN104@z900_diagn:

; 691  : 
; 692  :         sysblk.instbreak = 1;

  00b7a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b81	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00b87	0f ba e8 0a	 bts	 eax, 10
  00b8b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00b92	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
$LN28@z900_diagn:

; 693  :         SET_IC_TRACE;

  00b98	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b9f	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  00ba6	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR mask$15[rsp], rax
  00bae	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$4[rsp], 0
  00bb6	eb 0a		 jmp	 SHORT $LN31@z900_diagn
$LN29@z900_diagn:
  00bb8	8b 44 24 54	 mov	 eax, DWORD PTR i$4[rsp]
  00bbc	ff c0		 inc	 eax
  00bbe	89 44 24 54	 mov	 DWORD PTR i$4[rsp], eax
$LN31@z900_diagn:
  00bc2	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR mask$15[rsp], 0
  00bcb	74 58		 je	 SHORT $LN30@z900_diagn
  00bcd	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR mask$15[rsp]
  00bd5	48 83 e0 01	 and	 rax, 1
  00bd9	48 85 c0	 test	 rax, rax
  00bdc	74 32		 je	 SHORT $LN105@z900_diagn
  00bde	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$4[rsp]
  00be3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00bea	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00bf2	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00bf5	0f ba e8 1f	 bts	 eax, 31
  00bf9	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR i$4[rsp]
  00bfe	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00c05	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00c0d	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN105@z900_diagn:
  00c10	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR mask$15[rsp]
  00c18	48 d1 e8	 shr	 rax, 1
  00c1b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR mask$15[rsp], rax
  00c23	eb 93		 jmp	 SHORT $LN29@z900_diagn
$LN30@z900_diagn:
  00c25	33 c0		 xor	 eax, eax
  00c27	85 c0		 test	 eax, eax
  00c29	0f 85 69 ff ff
	ff		 jne	 $LN28@z900_diagn

; 694  :         break;

  00c2f	e9 3f 06 00 00	 jmp	 $LN2@z900_diagn
$LN106@z900_diagn:

; 695  : 
; 696  :     case 0xF08:
; 697  :     /*---------------------------------------------------------------*/
; 698  :     /* Diagnose F08: Return Hercules instruction counter (32)        */
; 699  :     /*---------------------------------------------------------------*/
; 700  :         regs->GR_L( r1 ) = (U32) INSTCOUNT( regs );

  00c34	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c3c	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00c43	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c4b	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00c52	8b 89 98 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1944]
  00c58	48 03 88 90 07
	00 00		 add	 rcx, QWORD PTR [rax+1936]
  00c5f	48 8b c1	 mov	 rax, rcx
  00c62	48 63 8c 24 b8
	01 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00c6a	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00c72	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 701  :         break;

  00c79	e9 f5 05 00 00	 jmp	 $LN2@z900_diagn
$LN107@z900_diagn:

; 702  : 
; 703  :     case 0xF09:
; 704  :     /*---------------------------------------------------------------*/
; 705  :     /* Diagnose F09: Return Hercules instruction counter (64)        */
; 706  :     /*---------------------------------------------------------------*/
; 707  :     {
; 708  :         // Operand register r3 bits 32-47 specify the option code and
; 709  :         // bits 48-63 specify the CPU Address for option code 1. For
; 710  :         // option code 0, operand register r3 bits 48-63 are ignored.
; 711  :         // Bits 0-31 of operand register r3 are also always ignored.
; 712  :         // Any option code other than 0 or 1 causes a Specification
; 713  :         // Exception Program Interrupt to occur.
; 714  :         //
; 715  :         // Option 0 = instruction count for entire system (all CPUs
; 716  :         // together). Option 1 = instruction count for specific CPU
; 717  :         // identified in bits 48-63 of r3.
; 718  :         //
; 719  :         // The register and bits that the 64-bit instruction count
; 720  :         // is returned in depends on: 1) whether z/Architecture mode
; 721  :         // is active or not, and 2) whether the specified operand-1
; 722  :         // r1 register number is even or odd.
; 723  :         //
; 724  :         // If operand-1 register r1 is an even numbered register,
; 725  :         // then the high-order bits 0-31 of the 64-bit instruction
; 726  :         // count is returned in bits 32-63 of the even numbered
; 727  :         // register, the low-order bits 32-63 the 64-bit instruction
; 728  :         // count is returned in bits 32-63 of the r1+1 odd numbered
; 729  :         // register and bits 0-31 of each register remain unmodified.
; 730  :         //
; 731  :         // If operand-1 register r1 specifies an odd numbered register
; 732  :         // however, then the 64-bit instruction count is returned in
; 733  :         // bits 0-63 of register r1 in z/Architecture mode, whereas a
; 734  :         // Specification Exception Program Check Interrupt occurs in
; 735  :         // both ESA/390 and System/370 architecture modes as 64-bit
; 736  :         // registers don't exist in either of those architectures.
; 737  :         //
; 738  :         // Precluding a Specification Exception Program Interrupt,
; 739  :         // Condition Code 0 is returned for option 0, whereas for
; 740  :         // option 1, Condition Code 0 is only returned if the CPU
; 741  :         // specified in bits 48-63 of the operand-3 register r3 is
; 742  :         // currently valid and online. Otherwise if the specified
; 743  :         // CPU is offline or does not exist in the configuration,
; 744  :         // Condition Code 3 is returned and the r1 or r1 and r1+1
; 745  :         // return value register(s) is/are not modified.
; 746  : 
; 747  :         U64   instcount=0;                  // Instruction count

  00c7e	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR instcount$12[rsp], 0

; 748  :         U16   opt = regs->GR_LHH( r3 );     // Option code

  00c8a	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00c92	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c9a	0f b7 84 c1 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax*8+642]
  00ca2	66 89 44 24 48	 mov	 WORD PTR opt$1[rsp], ax

; 749  : 
; 750  :         if (regs->arch_mode != ARCH_900_IDX)// Not 64-bit architecture?

  00ca7	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00caf	83 78 64 02	 cmp	 DWORD PTR [rax+100], 2
  00cb3	74 29		 je	 SHORT $LN108@z900_diagn

; 751  :             ODD_CHECK( r1, regs );          // 64-bit regs don't exist!

  00cb5	8b 84 24 b8 01
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  00cbc	83 e0 01	 and	 eax, 1
  00cbf	85 c0		 test	 eax, eax
  00cc1	74 1b		 je	 SHORT $LN109@z900_diagn
  00cc3	ba 06 00 00 00	 mov	 edx, 6
  00cc8	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00cd0	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cd8	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN109@z900_diagn:
$LN108@z900_diagn:

; 752  : 
; 753  :         if (opt > 1)                        // Unsupported option?

  00cde	0f b7 44 24 48	 movzx	 eax, WORD PTR opt$1[rsp]
  00ce3	83 f8 01	 cmp	 eax, 1
  00ce6	7e 20		 jle	 SHORT $LN110@z900_diagn

; 754  :         {
; 755  :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  00ce8	ba 06 00 00 00	 mov	 edx, 6
  00ced	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00cf5	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cfd	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]

; 756  :         }

  00d03	e9 e5 00 00 00	 jmp	 $LN111@z900_diagn
$LN110@z900_diagn:

; 757  :         else if (opt == 1)                  // Count for specific CPU?

  00d08	0f b7 44 24 48	 movzx	 eax, WORD PTR opt$1[rsp]
  00d0d	83 f8 01	 cmp	 eax, 1
  00d10	0f 85 ac 00 00
	00		 jne	 $LN112@z900_diagn

; 758  :         {
; 759  :             int cpu = regs->GR_LHL( r3 );   // Get desired CPU from r3

  00d16	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00d1e	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d26	0f b7 84 c1 80
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax*8+640]
  00d2e	89 44 24 4c	 mov	 DWORD PTR cpu$2[rsp], eax

; 760  : 
; 761  :             if (cpu < 0 || cpu >= sysblk.maxcpu || !IS_CPU_ONLINE( cpu ))

  00d32	83 7c 24 4c 00	 cmp	 DWORD PTR cpu$2[rsp], 0
  00d37	7c 2a		 jl	 SHORT $LN115@z900_diagn
  00d39	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00d40	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00d46	39 44 24 4c	 cmp	 DWORD PTR cpu$2[rsp], eax
  00d4a	7d 17		 jge	 SHORT $LN115@z900_diagn
  00d4c	48 63 44 24 4c	 movsxd	 rax, DWORD PTR cpu$2[rsp]
  00d51	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00d58	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00d61	75 11		 jne	 SHORT $LN114@z900_diagn
$LN115@z900_diagn:

; 762  :             {
; 763  :                 regs->psw.cc = 3;           // CPU is invalid/offline

  00d63	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d6b	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 764  :                 break;                      // We are done

  00d6f	e9 ff 04 00 00	 jmp	 $LN2@z900_diagn
$LN114@z900_diagn:

; 765  :             }
; 766  : 
; 767  :             /* Retrieve the requested CPU's instruction count */
; 768  :             instcount = sysblk.regs[ cpu ]->prevcount  // (U64)

  00d74	48 63 44 24 4c	 movsxd	 rax, DWORD PTR cpu$2[rsp]
  00d79	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00d80	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00d88	48 63 4c 24 4c	 movsxd	 rcx, DWORD PTR cpu$2[rsp]
  00d8d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00d94	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00d9c	8b 89 98 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1944]
  00da2	48 03 88 90 07
	00 00		 add	 rcx, QWORD PTR [rax+1936]
  00da9	48 8b c1	 mov	 rax, rcx
  00dac	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR instcount$12[rsp], rax

; 769  :                       + sysblk.regs[ cpu ]->instcount; // (U32)
; 770  :             regs->psw.cc = 0;

  00db4	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00dbc	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 771  :         }

  00dc0	eb 2b		 jmp	 SHORT $LN113@z900_diagn
$LN112@z900_diagn:

; 772  :         else if (opt == 0)                  // Global system counter?

  00dc2	0f b7 44 24 48	 movzx	 eax, WORD PTR opt$1[rsp]
  00dc7	85 c0		 test	 eax, eax
  00dc9	75 22		 jne	 SHORT $LN116@z900_diagn

; 773  :         {
; 774  :             instcount = sysblk.instcount;   // Get total for ALL CPUs

  00dcb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00dd2	48 8b 80 80 14
	00 00		 mov	 rax, QWORD PTR [rax+5248]
  00dd9	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR instcount$12[rsp], rax

; 775  :             regs->psw.cc = 0;

  00de1	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00de9	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN116@z900_diagn:
$LN113@z900_diagn:
$LN111@z900_diagn:

; 776  :         }
; 777  : 
; 778  :         /* Return the instruction count in the requested register(s) */
; 779  :         if (r1 & 1)

  00ded	8b 84 24 b8 01
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  00df4	83 e0 01	 and	 eax, 1
  00df7	85 c0		 test	 eax, eax
  00df9	74 22		 je	 SHORT $LN117@z900_diagn

; 780  :             regs->GR_G( r1 ) = instcount;   // Contiguous 64-bit count

  00dfb	48 63 84 24 b8
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00e03	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e0b	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR instcount$12[rsp]
  00e13	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx
  00e1b	eb 59		 jmp	 SHORT $LN118@z900_diagn
$LN117@z900_diagn:

; 781  :         else
; 782  :         {
; 783  :             /* Place the high-order 32 bits of the 64-bit count into
; 784  :                bits 32-63 of the even numbered register and place the
; 785  :                low-order 32 bits of the 64-bit count into bits 32-63
; 786  :                of the r1+1 odd numbered register. For S/370 and S/390
; 787  :                mode this corresponds to bits 0-31 of the register pair
; 788  :                since registers are only 32 bits wide in 370 and 390.
; 789  :             */
; 790  :             regs->GR_L( r1    ) = (U32)((instcount >> 32) & 0xFFFFFFFF);

  00e1d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR instcount$12[rsp]
  00e25	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00e29	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00e2e	48 23 c1	 and	 rax, rcx
  00e31	48 63 8c 24 b8
	01 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00e39	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00e41	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 791  :             regs->GR_L( r1 + 1) = (U32)((instcount      ) & 0xFFFFFFFF);

  00e48	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00e4d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR instcount$12[rsp]
  00e55	48 23 c8	 and	 rcx, rax
  00e58	48 8b c1	 mov	 rax, rcx
  00e5b	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  00e62	ff c1		 inc	 ecx
  00e64	48 63 c9	 movsxd	 rcx, ecx
  00e67	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00e6f	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN118@z900_diagn:

; 792  :         }
; 793  : 
; 794  :         break;

  00e76	e9 f8 03 00 00	 jmp	 $LN2@z900_diagn
$LN119@z900_diagn:

; 795  :     }
; 796  : 
; 797  :     case 0xF0C:
; 798  :     /*---------------------------------------------------------------*/
; 799  :     /* Diagnose F0C: Set/reset bad frame indicator                   */
; 800  :     /*---------------------------------------------------------------*/
; 801  :         /* If diag8opt is not enabled then we are not allowed
; 802  :          * to manipulate the real machine i.e. hercules itself
; 803  :          */
; 804  :         if(!(sysblk.diag8opt & DIAG8CMD_ENABLE))

  00e7b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00e82	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  00e89	83 e0 01	 and	 eax, 1
  00e8c	85 c0		 test	 eax, eax
  00e8e	75 12		 jne	 SHORT $LN120@z900_diagn

; 805  :             ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00e90	ba 06 00 00 00	 mov	 edx, 6
  00e95	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e9d	e8 00 00 00 00	 call	 z900_program_interrupt
$LN120@z900_diagn:

; 806  : 
; 807  :         /* Load 4K block address from R2 register */
; 808  :         n = regs->GR_L(r3) & ADDRESS_MAXWRAP(regs);

  00ea2	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00eaa	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00eb2	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00eb9	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ec1	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00ec8	89 44 24 44	 mov	 DWORD PTR n$[rsp], eax

; 809  : 
; 810  :         /* Convert real address to absolute address */
; 811  :         n = APPLY_PREFIXING (n, regs->PX);

  00ecc	8b 44 24 44	 mov	 eax, DWORD PTR n$[rsp]
  00ed0	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  00ed6	48 85 c0	 test	 rax, rax
  00ed9	74 26		 je	 SHORT $LN140@z900_diagn
  00edb	8b 44 24 44	 mov	 eax, DWORD PTR n$[rsp]
  00edf	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  00ee5	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00eed	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  00ef1	74 0e		 je	 SHORT $LN140@z900_diagn
  00ef3	8b 44 24 44	 mov	 eax, DWORD PTR n$[rsp]
  00ef7	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv601[rsp], rax
  00eff	eb 18		 jmp	 SHORT $LN141@z900_diagn
$LN140@z900_diagn:
  00f01	8b 44 24 44	 mov	 eax, DWORD PTR n$[rsp]
  00f05	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f0d	48 33 41 70	 xor	 rax, QWORD PTR [rcx+112]
  00f11	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv601[rsp], rax
$LN141@z900_diagn:
  00f19	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv601[rsp]
  00f20	89 44 24 44	 mov	 DWORD PTR n$[rsp], eax

; 812  : 
; 813  :         /* Addressing exception if block is outside main storage */
; 814  :         if ( n > regs->mainlim )

  00f24	8b 44 24 44	 mov	 eax, DWORD PTR n$[rsp]
  00f28	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f30	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  00f37	76 17		 jbe	 SHORT $LN121@z900_diagn

; 815  :         {
; 816  :             ARCH_DEP(program_interrupt) (regs, PGM_ADDRESSING_EXCEPTION);

  00f39	ba 05 00 00 00	 mov	 edx, 5
  00f3e	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f46	e8 00 00 00 00	 call	 z900_program_interrupt

; 817  :             break;

  00f4b	e9 23 03 00 00	 jmp	 $LN2@z900_diagn
$LN121@z900_diagn:

; 818  :         }
; 819  : 
; 820  :         /* Update bad-frame bit based on low-order bit of R1 register.
; 821  :            Note: we must use the internal "_xxx_storage_key" functions
; 822  :            to directly set/clear the internal STORKEY_BADFRM bit.
; 823  :         */
; 824  :         if (regs->GR_L(r1) & STORKEY_BADFRM)

  00f50	48 63 84 24 b8
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00f58	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f60	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00f67	83 e0 01	 and	 eax, 1
  00f6a	85 c0		 test	 eax, eax
  00f6c	74 12		 je	 SHORT $LN122@z900_diagn

; 825  :             ARCH_DEP( _or_storage_key )( n, STORKEY_BADFRM, SKEY_K );

  00f6e	8b 44 24 44	 mov	 eax, DWORD PTR n$[rsp]
  00f72	41 b0 04	 mov	 r8b, 4
  00f75	b2 01		 mov	 dl, 1
  00f77	8b c8		 mov	 ecx, eax
  00f79	e8 00 00 00 00	 call	 z900__or_storage_key
  00f7e	eb 10		 jmp	 SHORT $LN123@z900_diagn
$LN122@z900_diagn:

; 826  :         else
; 827  :             ARCH_DEP( _and_storage_key )( n, STORKEY_BADFRM, SKEY_K );

  00f80	8b 44 24 44	 mov	 eax, DWORD PTR n$[rsp]
  00f84	41 b0 04	 mov	 r8b, 4
  00f87	b2 01		 mov	 dl, 1
  00f89	8b c8		 mov	 ecx, eax
  00f8b	e8 00 00 00 00	 call	 z900__and_storage_key
$LN123@z900_diagn:

; 828  : 
; 829  :         break;

  00f90	e9 de 02 00 00	 jmp	 $LN2@z900_diagn
$LN124@z900_diagn:

; 830  : 
; 831  :     case 0xF10:
; 832  :     /*---------------------------------------------------------------*/
; 833  :     /* Diagnose F10: Hercules CPU stop                               */
; 834  :     /*---------------------------------------------------------------*/
; 835  :         /* If diag8opt is not enabled then we are not allowed
; 836  :          * to manipulate the real machine i.e. hercules itself
; 837  :          */
; 838  :         if(!(sysblk.diag8opt & DIAG8CMD_ENABLE))

  00f95	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00f9c	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  00fa3	83 e0 01	 and	 eax, 1
  00fa6	85 c0		 test	 eax, eax
  00fa8	75 12		 jne	 SHORT $LN125@z900_diagn

; 839  :             ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00faa	ba 06 00 00 00	 mov	 edx, 6
  00faf	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00fb7	e8 00 00 00 00	 call	 z900_program_interrupt
$LN125@z900_diagn:

; 840  : 
; 841  :         regs->cpustate = CPUSTATE_STOPPING;

  00fbc	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00fc4	c6 40 60 02	 mov	 BYTE PTR [rax+96], 2
$LN34@z900_diagn:

; 842  :         ON_IC_INTERRUPT(regs);

  00fc8	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00fd0	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00fd3	0f ba e8 1f	 bts	 eax, 31
  00fd7	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00fdf	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00fe2	33 c0		 xor	 eax, eax
  00fe4	85 c0		 test	 eax, eax
  00fe6	75 e0		 jne	 SHORT $LN34@z900_diagn

; 843  :         break;

  00fe8	e9 86 02 00 00	 jmp	 $LN2@z900_diagn
$LN126@z900_diagn:

; 844  : 
; 845  : #if defined(_FEATURE_HOST_RESOURCE_ACCESS_FACILITY)
; 846  :     case 0xF18:
; 847  :     /*---------------------------------------------------------------*/
; 848  :     /* Diagnose F18: Hercules Access Host Resource                   */
; 849  :     /*---------------------------------------------------------------*/
; 850  :         ARCH_DEP(diagf18_call) (r1, r3, regs);

  00fed	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00ff5	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  00ffc	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  01003	e8 00 00 00 00	 call	 z900_diagf18_call

; 851  :         break;

  01008	e9 66 02 00 00	 jmp	 $LN2@z900_diagn
$LN127@z900_diagn:
$LN35@z900_diagn:

; 852  : #endif /* defined(_FEATURE_HOST_RESOURCE_ACCESS_FACILITY) */
; 853  : 
; 854  :     case 0xFF8:
; 855  :     /*---------------------------------------------------------------*/
; 856  :     /* Diagnose FF8: Hercules Infinite Loop (Malfunctioning CPU)     */
; 857  :     /*---------------------------------------------------------------*/
; 858  :         while(1);   /* (loop forever)  */

  0100d	33 c0		 xor	 eax, eax
  0100f	83 f8 01	 cmp	 eax, 1
  01012	74 02		 je	 SHORT $LN36@z900_diagn
  01014	eb f7		 jmp	 SHORT $LN35@z900_diagn
$LN36@z900_diagn:

; 859  :         break;      /* (never reached) */

  01016	e9 58 02 00 00	 jmp	 $LN2@z900_diagn
$LN128@z900_diagn:
$LN39@z900_diagn:

; 860  : 
; 861  :     case 0xFFC:
; 862  :     /*---------------------------------------------------------------*/
; 863  :     /* Diagnose FFC: Hercules SLOW Instruction (Malfunctioning CPU)  */
; 864  :     /*---------------------------------------------------------------*/
; 865  :         SLEEP(300); /* (300 seconds = 5 minutes!) */

  0101b	c7 44 24 58 2c
	01 00 00	 mov	 DWORD PTR rc$5[rsp], 300 ; 0000012cH
$LN40@z900_diagn:
  01023	83 7c 24 58 00	 cmp	 DWORD PTR rc$5[rsp], 0
  01028	74 1d		 je	 SHORT $LN41@z900_diagn
  0102a	8b 4c 24 58	 mov	 ecx, DWORD PTR rc$5[rsp]
  0102e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sleep
  01034	89 44 24 58	 mov	 DWORD PTR rc$5[rsp], eax
  01038	83 7c 24 58 00	 cmp	 DWORD PTR rc$5[rsp], 0
  0103d	74 06		 je	 SHORT $LN129@z900_diagn
  0103f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield
$LN129@z900_diagn:
  01045	eb dc		 jmp	 SHORT $LN40@z900_diagn
$LN41@z900_diagn:
  01047	33 c0		 xor	 eax, eax
  01049	85 c0		 test	 eax, eax
  0104b	75 ce		 jne	 SHORT $LN39@z900_diagn

; 866  :         break;

  0104d	e9 21 02 00 00	 jmp	 $LN2@z900_diagn
$LN130@z900_diagn:

; 867  : 
; 868  :     case 0xFFD:
; 869  :     /*---------------------------------------------------------------*/
; 870  :     /* Diagnose FFD: Hercules Dummy "Slow(?)" Instruction            */
; 871  :     /*---------------------------------------------------------------*/
; 872  :     {
; 873  :         /* r1 = microseconds */
; 874  :         unsigned int secs  = regs->GR_L(r1) / ONE_MILLION;

  01052	48 63 84 24 b8
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0105a	33 d2		 xor	 edx, edx
  0105c	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01064	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0106b	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  01070	f7 f1		 div	 ecx
  01072	89 84 24 a0 00
	00 00		 mov	 DWORD PTR secs$16[rsp], eax

; 875  :         unsigned int usecs = regs->GR_L(r1) % ONE_MILLION;

  01079	48 63 84 24 b8
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  01081	33 d2		 xor	 edx, edx
  01083	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0108b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  01092	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  01097	f7 f1		 div	 ecx
  01099	8b c2		 mov	 eax, edx
  0109b	89 44 24 7c	 mov	 DWORD PTR usecs$11[rsp], eax

; 876  :         unsigned int i;
; 877  :         for (i=0; i < secs; ++i)

  0109f	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$8[rsp], 0
  010a7	eb 0a		 jmp	 SHORT $LN44@z900_diagn
$LN42@z900_diagn:
  010a9	8b 44 24 68	 mov	 eax, DWORD PTR i$8[rsp]
  010ad	ff c0		 inc	 eax
  010af	89 44 24 68	 mov	 DWORD PTR i$8[rsp], eax
$LN44@z900_diagn:
  010b3	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR secs$16[rsp]
  010ba	39 44 24 68	 cmp	 DWORD PTR i$8[rsp], eax
  010be	73 34		 jae	 SHORT $LN43@z900_diagn
$LN47@z900_diagn:

; 878  :             SLEEP(1);       /* (sleep one second at a time) */

  010c0	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR rc$6[rsp], 1
$LN48@z900_diagn:
  010c8	83 7c 24 5c 00	 cmp	 DWORD PTR rc$6[rsp], 0
  010cd	74 1d		 je	 SHORT $LN49@z900_diagn
  010cf	8b 4c 24 5c	 mov	 ecx, DWORD PTR rc$6[rsp]
  010d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sleep
  010d9	89 44 24 5c	 mov	 DWORD PTR rc$6[rsp], eax
  010dd	83 7c 24 5c 00	 cmp	 DWORD PTR rc$6[rsp], 0
  010e2	74 06		 je	 SHORT $LN131@z900_diagn
  010e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield
$LN131@z900_diagn:
  010ea	eb dc		 jmp	 SHORT $LN48@z900_diagn
$LN49@z900_diagn:
  010ec	33 c0		 xor	 eax, eax
  010ee	85 c0		 test	 eax, eax
  010f0	75 ce		 jne	 SHORT $LN47@z900_diagn
  010f2	eb b5		 jmp	 SHORT $LN42@z900_diagn
$LN43@z900_diagn:

; 879  :         if (usecs)

  010f4	83 7c 24 7c 00	 cmp	 DWORD PTR usecs$11[rsp], 0
  010f9	74 0a		 je	 SHORT $LN132@z900_diagn

; 880  :             usleep(usecs);  /* (remaining microseconds, if any) */

  010fb	8b 4c 24 7c	 mov	 ecx, DWORD PTR usecs$11[rsp]
  010ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN132@z900_diagn:

; 881  :         break;

  01105	e9 69 01 00 00	 jmp	 $LN2@z900_diagn
$LN133@z900_diagn:

; 882  :     }
; 883  : 
; 884  : #endif /*FEATURE_HERCULES_DIAGCALLS*/
; 885  : 
; 886  :     default:
; 887  :     /*---------------------------------------------------------------*/
; 888  :     /* Diagnose xxx: Invalid function code or Power-Off diagnose     */
; 889  :     /*---------------------------------------------------------------*/
; 890  : 
; 891  :         if( HDC4(debug_diagnose, code, r1, r3, regs) )

  0110a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_diagnose
  01111	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  01115	74 2e		 je	 SHORT $LN142@z900_diagn
  01117	4c 8b 8c 24 b0
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0111f	44 8b 84 24 c0
	01 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  01127	8b 94 24 b8 01
	00 00		 mov	 edx, DWORD PTR r1$[rsp]
  0112e	8b 4c 24 60	 mov	 ecx, DWORD PTR code$[rsp]
  01132	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_diagnose
  01139	ff 10		 call	 QWORD PTR [rax]
  0113b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv670[rsp], rax
  01143	eb 0c		 jmp	 SHORT $LN143@z900_diagn
$LN142@z900_diagn:
  01145	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv670[rsp], 0
$LN143@z900_diagn:
  01151	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR tv670[rsp], 0
  0115a	74 05		 je	 SHORT $LN134@z900_diagn

; 892  :             return;

  0115c	e9 12 01 00 00	 jmp	 $LN1@z900_diagn
$LN134@z900_diagn:

; 893  : 
; 894  :         /* Power Off diagnose on 4361, 9371, 9373, 9375, 9377, 9221: */
; 895  :         /*                                                           */
; 896  :         /*          DS 0H                                            */
; 897  :         /*          DC X'8302',S(SHUTDATA)     MUST BE R0 AND R2     */
; 898  :         /*          ...                                              */
; 899  :         /*          DS 0H                                            */
; 900  :         /* SHUTDATA DC X'0000FFFF'             MUST BE X'0000FFFF'   */
; 901  : 
; 902  :         if (0 == r1 && 2 == r3
; 903  :              && sysblk.cpuversion != 0xFF
; 904  :              && (sysblk.cpumodel == 0x4361

  01161	83 bc 24 b8 01
	00 00 00	 cmp	 DWORD PTR r1$[rsp], 0
  01169	0f 85 f2 00 00
	00		 jne	 $LN135@z900_diagn
  0116f	83 bc 24 c0 01
	00 00 02	 cmp	 DWORD PTR r3$[rsp], 2
  01177	0f 85 e4 00 00
	00		 jne	 $LN135@z900_diagn
  0117d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01184	0f b6 80 d6 00
	00 00		 movzx	 eax, BYTE PTR [rax+214]
  0118b	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  01190	0f 84 cb 00 00
	00		 je	 $LN135@z900_diagn
  01196	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0119d	0f b7 80 d4 00
	00 00		 movzx	 eax, WORD PTR [rax+212]
  011a4	3d 61 43 00 00	 cmp	 eax, 17249		; 00004361H
  011a9	74 33		 je	 SHORT $LN136@z900_diagn
  011ab	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  011b2	0f b7 80 d4 00
	00 00		 movzx	 eax, WORD PTR [rax+212]
  011b9	25 f9 ff 00 00	 and	 eax, 65529		; 0000fff9H
  011be	3d 71 93 00 00	 cmp	 eax, 37745		; 00009371H
  011c3	74 19		 je	 SHORT $LN136@z900_diagn
  011c5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  011cc	0f b7 80 d4 00
	00 00		 movzx	 eax, WORD PTR [rax+212]
  011d3	3d 21 92 00 00	 cmp	 eax, 37409		; 00009221H
  011d8	0f 85 83 00 00
	00		 jne	 $LN135@z900_diagn
$LN136@z900_diagn:

; 905  :               || (sysblk.cpumodel & 0xFFF9) == 0x9371   /* (937X) */
; 906  :               || sysblk.cpumodel == 0x9221)
; 907  :            )
; 908  :         {
; 909  :             if (0x0000FFFF == ARCH_DEP(vfetch4)(effective_addr2, b2, regs))

  011de	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  011e6	8b 94 24 c8 01
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  011ed	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  011f5	e8 00 00 00 00	 call	 z900_vfetch4
  011fa	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  011ff	75 60		 jne	 SHORT $LN137@z900_diagn

; 910  :             {
; 911  :                 /* If diag8opt is not enabled then we are not allowed
; 912  :                  * to manipulate the real machine i.e. hercules itself
; 913  :                  */
; 914  :                 if(!(sysblk.diag8opt & DIAG8CMD_ENABLE))

  01201	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01208	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  0120f	83 e0 01	 and	 eax, 1
  01212	85 c0		 test	 eax, eax
  01214	75 12		 jne	 SHORT $LN138@z900_diagn

; 915  :                     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  01216	ba 06 00 00 00	 mov	 edx, 6
  0121b	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01223	e8 00 00 00 00	 call	 z900_program_interrupt
$LN138@z900_diagn:

; 916  : 
; 917  :                 regs->cpustate = CPUSTATE_STOPPING;

  01228	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01230	c6 40 60 02	 mov	 BYTE PTR [rax+96], 2
$LN52@z900_diagn:

; 918  :                 ON_IC_INTERRUPT(regs);

  01234	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0123c	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0123f	0f ba e8 1f	 bts	 eax, 31
  01243	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0124b	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  0124e	33 c0		 xor	 eax, eax
  01250	85 c0		 test	 eax, eax
  01252	75 e0		 jne	 SHORT $LN52@z900_diagn

; 919  : 
; 920  :                 /* Release the configuration */
; 921  :                 do_shutdown();

  01254	e8 00 00 00 00	 call	 do_shutdown

; 922  : 
; 923  :                 /* Power Off: exit hercules */
; 924  :                 exit(0);

  01259	33 c9		 xor	 ecx, ecx
  0125b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN137@z900_diagn:
$LN135@z900_diagn:

; 925  :             }
; 926  :         }
; 927  : 
; 928  : #if defined(FEATURE_S370_CHANNEL) && defined(OPTION_NOP_MODEL158_DIAGNOSE)
; 929  :         if (regs->cpumodel != 0x0158)
; 930  : #endif
; 931  :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  01261	ba 06 00 00 00	 mov	 edx, 6
  01266	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0126e	e8 00 00 00 00	 call	 z900_program_interrupt
$LN2@z900_diagn:
$LN1@z900_diagn:
$LN139@z900_diagn:

; 932  :         return;
; 933  : 
; 934  :     } /* end switch(code) */
; 935  : 
; 936  :     return;
; 937  : 
; 938  : } /* end function diagnose_call */

  01273	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0127b	48 33 cc	 xor	 rcx, rsp
  0127e	e8 00 00 00 00	 call	 __security_check_cookie
  01283	48 81 c4 a0 01
	00 00		 add	 rsp, 416		; 000001a0H
  0128a	5f		 pop	 rdi
  0128b	c3		 ret	 0
$LN151@z900_diagn:
  0128c	00 00 00 00	 DD	 $LN62@z900_diagn
  01290	00 00 00 00	 DD	 $LN53@z900_diagn
  01294	00 00 00 00	 DD	 $LN63@z900_diagn
  01298	00 00 00 00	 DD	 $LN65@z900_diagn
  0129c	00 00 00 00	 DD	 $LN54@z900_diagn
  012a0	00 00 00 00	 DD	 $LN66@z900_diagn
  012a4	00 00 00 00	 DD	 $LN58@z900_diagn
  012a8	00 00 00 00	 DD	 $LN67@z900_diagn
  012ac	00 00 00 00	 DD	 $LN68@z900_diagn
  012b0	00 00 00 00	 DD	 $LN69@z900_diagn
  012b4	00 00 00 00	 DD	 $LN59@z900_diagn
  012b8	00 00 00 00	 DD	 $LN70@z900_diagn
  012bc	00 00 00 00	 DD	 $LN71@z900_diagn
  012c0	00 00 00 00	 DD	 $LN72@z900_diagn
  012c4	00 00 00 00	 DD	 $LN73@z900_diagn
  012c8	00 00 00 00	 DD	 $LN133@z900_diagn
$LN150@z900_diagn:
  012cc	00		 DB	 0
  012cd	0f		 DB	 15
  012ce	01		 DB	 1
  012cf	0f		 DB	 15
  012d0	0f		 DB	 15
  012d1	0f		 DB	 15
  012d2	0f		 DB	 15
  012d3	0f		 DB	 15
  012d4	02		 DB	 2
  012d5	0f		 DB	 15
  012d6	0f		 DB	 15
  012d7	0f		 DB	 15
  012d8	03		 DB	 3
  012d9	0f		 DB	 15
  012da	0f		 DB	 15
  012db	0f		 DB	 15
  012dc	0f		 DB	 15
  012dd	0f		 DB	 15
  012de	0f		 DB	 15
  012df	0f		 DB	 15
  012e0	0f		 DB	 15
  012e1	0f		 DB	 15
  012e2	0f		 DB	 15
  012e3	0f		 DB	 15
  012e4	0f		 DB	 15
  012e5	0f		 DB	 15
  012e6	0f		 DB	 15
  012e7	0f		 DB	 15
  012e8	0f		 DB	 15
  012e9	0f		 DB	 15
  012ea	0f		 DB	 15
  012eb	04		 DB	 4
  012ec	0f		 DB	 15
  012ed	0f		 DB	 15
  012ee	0f		 DB	 15
  012ef	0f		 DB	 15
  012f0	05		 DB	 5
  012f1	0f		 DB	 15
  012f2	0f		 DB	 15
  012f3	0f		 DB	 15
  012f4	0f		 DB	 15
  012f5	0f		 DB	 15
  012f6	0f		 DB	 15
  012f7	0f		 DB	 15
  012f8	0f		 DB	 15
  012f9	0f		 DB	 15
  012fa	0f		 DB	 15
  012fb	0f		 DB	 15
  012fc	0f		 DB	 15
  012fd	0f		 DB	 15
  012fe	0f		 DB	 15
  012ff	0f		 DB	 15
  01300	0f		 DB	 15
  01301	0f		 DB	 15
  01302	0f		 DB	 15
  01303	0f		 DB	 15
  01304	0f		 DB	 15
  01305	0f		 DB	 15
  01306	0f		 DB	 15
  01307	0f		 DB	 15
  01308	0f		 DB	 15
  01309	0f		 DB	 15
  0130a	0f		 DB	 15
  0130b	0f		 DB	 15
  0130c	0f		 DB	 15
  0130d	0f		 DB	 15
  0130e	0f		 DB	 15
  0130f	0f		 DB	 15
  01310	06		 DB	 6
  01311	0f		 DB	 15
  01312	0f		 DB	 15
  01313	0f		 DB	 15
  01314	0f		 DB	 15
  01315	0f		 DB	 15
  01316	0f		 DB	 15
  01317	0f		 DB	 15
  01318	0f		 DB	 15
  01319	0f		 DB	 15
  0131a	0f		 DB	 15
  0131b	0f		 DB	 15
  0131c	0f		 DB	 15
  0131d	0f		 DB	 15
  0131e	0f		 DB	 15
  0131f	0f		 DB	 15
  01320	0f		 DB	 15
  01321	0f		 DB	 15
  01322	0f		 DB	 15
  01323	0f		 DB	 15
  01324	0f		 DB	 15
  01325	0f		 DB	 15
  01326	0f		 DB	 15
  01327	0f		 DB	 15
  01328	07		 DB	 7
  01329	0f		 DB	 15
  0132a	0f		 DB	 15
  0132b	0f		 DB	 15
  0132c	08		 DB	 8
  0132d	0f		 DB	 15
  0132e	0f		 DB	 15
  0132f	0f		 DB	 15
  01330	09		 DB	 9
  01331	0f		 DB	 15
  01332	0f		 DB	 15
  01333	0f		 DB	 15
  01334	0f		 DB	 15
  01335	0f		 DB	 15
  01336	0f		 DB	 15
  01337	0f		 DB	 15
  01338	0f		 DB	 15
  01339	0f		 DB	 15
  0133a	0f		 DB	 15
  0133b	0f		 DB	 15
  0133c	0f		 DB	 15
  0133d	0f		 DB	 15
  0133e	0f		 DB	 15
  0133f	0f		 DB	 15
  01340	0f		 DB	 15
  01341	0f		 DB	 15
  01342	0f		 DB	 15
  01343	0f		 DB	 15
  01344	0f		 DB	 15
  01345	0f		 DB	 15
  01346	0f		 DB	 15
  01347	0f		 DB	 15
  01348	0f		 DB	 15
  01349	0f		 DB	 15
  0134a	0f		 DB	 15
  0134b	0f		 DB	 15
  0134c	0f		 DB	 15
  0134d	0f		 DB	 15
  0134e	0f		 DB	 15
  0134f	0f		 DB	 15
  01350	0f		 DB	 15
  01351	0f		 DB	 15
  01352	0f		 DB	 15
  01353	0f		 DB	 15
  01354	0f		 DB	 15
  01355	0f		 DB	 15
  01356	0f		 DB	 15
  01357	0f		 DB	 15
  01358	0f		 DB	 15
  01359	0f		 DB	 15
  0135a	0f		 DB	 15
  0135b	0f		 DB	 15
  0135c	0f		 DB	 15
  0135d	0f		 DB	 15
  0135e	0f		 DB	 15
  0135f	0f		 DB	 15
  01360	0f		 DB	 15
  01361	0f		 DB	 15
  01362	0f		 DB	 15
  01363	0f		 DB	 15
  01364	0f		 DB	 15
  01365	0f		 DB	 15
  01366	0f		 DB	 15
  01367	0f		 DB	 15
  01368	0a		 DB	 10
  01369	0f		 DB	 15
  0136a	0f		 DB	 15
  0136b	0f		 DB	 15
  0136c	0f		 DB	 15
  0136d	0f		 DB	 15
  0136e	0f		 DB	 15
  0136f	0f		 DB	 15
  01370	0b		 DB	 11
  01371	0f		 DB	 15
  01372	0f		 DB	 15
  01373	0f		 DB	 15
  01374	0c		 DB	 12
  01375	0f		 DB	 15
  01376	0f		 DB	 15
  01377	0f		 DB	 15
  01378	0f		 DB	 15
  01379	0f		 DB	 15
  0137a	0f		 DB	 15
  0137b	0f		 DB	 15
  0137c	0d		 DB	 13
  0137d	0f		 DB	 15
  0137e	0f		 DB	 15
  0137f	0f		 DB	 15
  01380	0f		 DB	 15
  01381	0f		 DB	 15
  01382	0f		 DB	 15
  01383	0f		 DB	 15
  01384	0f		 DB	 15
  01385	0f		 DB	 15
  01386	0f		 DB	 15
  01387	0f		 DB	 15
  01388	0f		 DB	 15
  01389	0f		 DB	 15
  0138a	0f		 DB	 15
  0138b	0f		 DB	 15
  0138c	0f		 DB	 15
  0138d	0f		 DB	 15
  0138e	0f		 DB	 15
  0138f	0f		 DB	 15
  01390	0f		 DB	 15
  01391	0f		 DB	 15
  01392	0f		 DB	 15
  01393	0f		 DB	 15
  01394	0f		 DB	 15
  01395	0f		 DB	 15
  01396	0f		 DB	 15
  01397	0f		 DB	 15
  01398	0f		 DB	 15
  01399	0f		 DB	 15
  0139a	0f		 DB	 15
  0139b	0f		 DB	 15
  0139c	0f		 DB	 15
  0139d	0f		 DB	 15
  0139e	0f		 DB	 15
  0139f	0f		 DB	 15
  013a0	0f		 DB	 15
  013a1	0f		 DB	 15
  013a2	0f		 DB	 15
  013a3	0f		 DB	 15
  013a4	0f		 DB	 15
  013a5	0f		 DB	 15
  013a6	0f		 DB	 15
  013a7	0f		 DB	 15
  013a8	0e		 DB	 14
  013a9	0f 1f 00	 npad	 3
$LN149@z900_diagn:
  013ac	00 00 00 00	 DD	 $LN74@z900_diagn
  013b0	00 00 00 00	 DD	 $LN75@z900_diagn
  013b4	00 00 00 00	 DD	 $LN76@z900_diagn
  013b8	00 00 00 00	 DD	 $LN61@z900_diagn
  013bc	00 00 00 00	 DD	 $LN81@z900_diagn
  013c0	00 00 00 00	 DD	 $LN82@z900_diagn
  013c4	00 00 00 00	 DD	 $LN83@z900_diagn
  013c8	00 00 00 00	 DD	 $LN84@z900_diagn
  013cc	00 00 00 00	 DD	 $LN86@z900_diagn
  013d0	00 00 00 00	 DD	 $LN87@z900_diagn
  013d4	00 00 00 00	 DD	 $LN89@z900_diagn
  013d8	00 00 00 00	 DD	 $LN133@z900_diagn
$LN148@z900_diagn:
  013dc	00		 DB	 0
  013dd	0b		 DB	 11
  013de	0b		 DB	 11
  013df	0b		 DB	 11
  013e0	01		 DB	 1
  013e1	0b		 DB	 11
  013e2	0b		 DB	 11
  013e3	0b		 DB	 11
  013e4	0b		 DB	 11
  013e5	0b		 DB	 11
  013e6	0b		 DB	 11
  013e7	0b		 DB	 11
  013e8	0b		 DB	 11
  013e9	0b		 DB	 11
  013ea	0b		 DB	 11
  013eb	0b		 DB	 11
  013ec	02		 DB	 2
  013ed	0b		 DB	 11
  013ee	0b		 DB	 11
  013ef	0b		 DB	 11
  013f0	03		 DB	 3
  013f1	0b		 DB	 11
  013f2	0b		 DB	 11
  013f3	0b		 DB	 11
  013f4	0b		 DB	 11
  013f5	0b		 DB	 11
  013f6	0b		 DB	 11
  013f7	0b		 DB	 11
  013f8	0b		 DB	 11
  013f9	0b		 DB	 11
  013fa	0b		 DB	 11
  013fb	0b		 DB	 11
  013fc	0b		 DB	 11
  013fd	0b		 DB	 11
  013fe	0b		 DB	 11
  013ff	0b		 DB	 11
  01400	0b		 DB	 11
  01401	0b		 DB	 11
  01402	0b		 DB	 11
  01403	0b		 DB	 11
  01404	0b		 DB	 11
  01405	0b		 DB	 11
  01406	0b		 DB	 11
  01407	0b		 DB	 11
  01408	04		 DB	 4
  01409	0b		 DB	 11
  0140a	0b		 DB	 11
  0140b	0b		 DB	 11
  0140c	0b		 DB	 11
  0140d	0b		 DB	 11
  0140e	0b		 DB	 11
  0140f	0b		 DB	 11
  01410	0b		 DB	 11
  01411	0b		 DB	 11
  01412	0b		 DB	 11
  01413	0b		 DB	 11
  01414	0b		 DB	 11
  01415	0b		 DB	 11
  01416	0b		 DB	 11
  01417	0b		 DB	 11
  01418	0b		 DB	 11
  01419	0b		 DB	 11
  0141a	0b		 DB	 11
  0141b	0b		 DB	 11
  0141c	05		 DB	 5
  0141d	0b		 DB	 11
  0141e	0b		 DB	 11
  0141f	0b		 DB	 11
  01420	0b		 DB	 11
  01421	0b		 DB	 11
  01422	0b		 DB	 11
  01423	0b		 DB	 11
  01424	0b		 DB	 11
  01425	0b		 DB	 11
  01426	0b		 DB	 11
  01427	0b		 DB	 11
  01428	0b		 DB	 11
  01429	0b		 DB	 11
  0142a	0b		 DB	 11
  0142b	0b		 DB	 11
  0142c	06		 DB	 6
  0142d	0b		 DB	 11
  0142e	0b		 DB	 11
  0142f	0b		 DB	 11
  01430	07		 DB	 7
  01431	0b		 DB	 11
  01432	0b		 DB	 11
  01433	0b		 DB	 11
  01434	0b		 DB	 11
  01435	0b		 DB	 11
  01436	0b		 DB	 11
  01437	0b		 DB	 11
  01438	0b		 DB	 11
  01439	0b		 DB	 11
  0143a	0b		 DB	 11
  0143b	0b		 DB	 11
  0143c	08		 DB	 8
  0143d	0b		 DB	 11
  0143e	0b		 DB	 11
  0143f	0b		 DB	 11
  01440	09		 DB	 9
  01441	0b		 DB	 11
  01442	0b		 DB	 11
  01443	0b		 DB	 11
  01444	0b		 DB	 11
  01445	0b		 DB	 11
  01446	0b		 DB	 11
  01447	0b		 DB	 11
  01448	0b		 DB	 11
  01449	0b		 DB	 11
  0144a	0b		 DB	 11
  0144b	0b		 DB	 11
  0144c	0b		 DB	 11
  0144d	0b		 DB	 11
  0144e	0b		 DB	 11
  0144f	0b		 DB	 11
  01450	0b		 DB	 11
  01451	0b		 DB	 11
  01452	0b		 DB	 11
  01453	0b		 DB	 11
  01454	0b		 DB	 11
  01455	0b		 DB	 11
  01456	0b		 DB	 11
  01457	0b		 DB	 11
  01458	0b		 DB	 11
  01459	0b		 DB	 11
  0145a	0b		 DB	 11
  0145b	0b		 DB	 11
  0145c	0b		 DB	 11
  0145d	0b		 DB	 11
  0145e	0b		 DB	 11
  0145f	0b		 DB	 11
  01460	0b		 DB	 11
  01461	0b		 DB	 11
  01462	0b		 DB	 11
  01463	0b		 DB	 11
  01464	0b		 DB	 11
  01465	0b		 DB	 11
  01466	0b		 DB	 11
  01467	0b		 DB	 11
  01468	0b		 DB	 11
  01469	0b		 DB	 11
  0146a	0b		 DB	 11
  0146b	0b		 DB	 11
  0146c	0b		 DB	 11
  0146d	0b		 DB	 11
  0146e	0b		 DB	 11
  0146f	0b		 DB	 11
  01470	0b		 DB	 11
  01471	0b		 DB	 11
  01472	0b		 DB	 11
  01473	0b		 DB	 11
  01474	0b		 DB	 11
  01475	0b		 DB	 11
  01476	0b		 DB	 11
  01477	0b		 DB	 11
  01478	0b		 DB	 11
  01479	0b		 DB	 11
  0147a	0b		 DB	 11
  0147b	0b		 DB	 11
  0147c	0b		 DB	 11
  0147d	0b		 DB	 11
  0147e	0b		 DB	 11
  0147f	0b		 DB	 11
  01480	0b		 DB	 11
  01481	0b		 DB	 11
  01482	0b		 DB	 11
  01483	0b		 DB	 11
  01484	0b		 DB	 11
  01485	0b		 DB	 11
  01486	0b		 DB	 11
  01487	0b		 DB	 11
  01488	0b		 DB	 11
  01489	0b		 DB	 11
  0148a	0b		 DB	 11
  0148b	0b		 DB	 11
  0148c	0b		 DB	 11
  0148d	0b		 DB	 11
  0148e	0b		 DB	 11
  0148f	0b		 DB	 11
  01490	0b		 DB	 11
  01491	0b		 DB	 11
  01492	0b		 DB	 11
  01493	0b		 DB	 11
  01494	0b		 DB	 11
  01495	0b		 DB	 11
  01496	0b		 DB	 11
  01497	0b		 DB	 11
  01498	0b		 DB	 11
  01499	0b		 DB	 11
  0149a	0b		 DB	 11
  0149b	0b		 DB	 11
  0149c	0b		 DB	 11
  0149d	0b		 DB	 11
  0149e	0b		 DB	 11
  0149f	0b		 DB	 11
  014a0	0b		 DB	 11
  014a1	0b		 DB	 11
  014a2	0b		 DB	 11
  014a3	0b		 DB	 11
  014a4	0b		 DB	 11
  014a5	0b		 DB	 11
  014a6	0b		 DB	 11
  014a7	0b		 DB	 11
  014a8	0b		 DB	 11
  014a9	0b		 DB	 11
  014aa	0b		 DB	 11
  014ab	0b		 DB	 11
  014ac	0b		 DB	 11
  014ad	0b		 DB	 11
  014ae	0b		 DB	 11
  014af	0b		 DB	 11
  014b0	0b		 DB	 11
  014b1	0b		 DB	 11
  014b2	0b		 DB	 11
  014b3	0b		 DB	 11
  014b4	0b		 DB	 11
  014b5	0b		 DB	 11
  014b6	0b		 DB	 11
  014b7	0b		 DB	 11
  014b8	0b		 DB	 11
  014b9	0b		 DB	 11
  014ba	0b		 DB	 11
  014bb	0b		 DB	 11
  014bc	0b		 DB	 11
  014bd	0b		 DB	 11
  014be	0b		 DB	 11
  014bf	0b		 DB	 11
  014c0	0b		 DB	 11
  014c1	0b		 DB	 11
  014c2	0b		 DB	 11
  014c3	0b		 DB	 11
  014c4	0b		 DB	 11
  014c5	0b		 DB	 11
  014c6	0b		 DB	 11
  014c7	0b		 DB	 11
  014c8	0b		 DB	 11
  014c9	0b		 DB	 11
  014ca	0b		 DB	 11
  014cb	0b		 DB	 11
  014cc	0b		 DB	 11
  014cd	0b		 DB	 11
  014ce	0b		 DB	 11
  014cf	0b		 DB	 11
  014d0	0b		 DB	 11
  014d1	0b		 DB	 11
  014d2	0b		 DB	 11
  014d3	0b		 DB	 11
  014d4	0a		 DB	 10
  014d5	0f 1f 00	 npad	 3
$LN147@z900_diagn:
  014d8	00 00 00 00	 DD	 $LN103@z900_diagn
  014dc	00 00 00 00	 DD	 $LN106@z900_diagn
  014e0	00 00 00 00	 DD	 $LN107@z900_diagn
  014e4	00 00 00 00	 DD	 $LN119@z900_diagn
  014e8	00 00 00 00	 DD	 $LN124@z900_diagn
  014ec	00 00 00 00	 DD	 $LN126@z900_diagn
  014f0	00 00 00 00	 DD	 $LN127@z900_diagn
  014f4	00 00 00 00	 DD	 $LN128@z900_diagn
  014f8	00 00 00 00	 DD	 $LN130@z900_diagn
  014fc	00 00 00 00	 DD	 $LN133@z900_diagn
$LN146@z900_diagn:
  01500	00		 DB	 0
  01501	09		 DB	 9
  01502	09		 DB	 9
  01503	09		 DB	 9
  01504	01		 DB	 1
  01505	02		 DB	 2
  01506	09		 DB	 9
  01507	09		 DB	 9
  01508	03		 DB	 3
  01509	09		 DB	 9
  0150a	09		 DB	 9
  0150b	09		 DB	 9
  0150c	04		 DB	 4
  0150d	09		 DB	 9
  0150e	09		 DB	 9
  0150f	09		 DB	 9
  01510	09		 DB	 9
  01511	09		 DB	 9
  01512	09		 DB	 9
  01513	09		 DB	 9
  01514	05		 DB	 5
  01515	09		 DB	 9
  01516	09		 DB	 9
  01517	09		 DB	 9
  01518	09		 DB	 9
  01519	09		 DB	 9
  0151a	09		 DB	 9
  0151b	09		 DB	 9
  0151c	09		 DB	 9
  0151d	09		 DB	 9
  0151e	09		 DB	 9
  0151f	09		 DB	 9
  01520	09		 DB	 9
  01521	09		 DB	 9
  01522	09		 DB	 9
  01523	09		 DB	 9
  01524	09		 DB	 9
  01525	09		 DB	 9
  01526	09		 DB	 9
  01527	09		 DB	 9
  01528	09		 DB	 9
  01529	09		 DB	 9
  0152a	09		 DB	 9
  0152b	09		 DB	 9
  0152c	09		 DB	 9
  0152d	09		 DB	 9
  0152e	09		 DB	 9
  0152f	09		 DB	 9
  01530	09		 DB	 9
  01531	09		 DB	 9
  01532	09		 DB	 9
  01533	09		 DB	 9
  01534	09		 DB	 9
  01535	09		 DB	 9
  01536	09		 DB	 9
  01537	09		 DB	 9
  01538	09		 DB	 9
  01539	09		 DB	 9
  0153a	09		 DB	 9
  0153b	09		 DB	 9
  0153c	09		 DB	 9
  0153d	09		 DB	 9
  0153e	09		 DB	 9
  0153f	09		 DB	 9
  01540	09		 DB	 9
  01541	09		 DB	 9
  01542	09		 DB	 9
  01543	09		 DB	 9
  01544	09		 DB	 9
  01545	09		 DB	 9
  01546	09		 DB	 9
  01547	09		 DB	 9
  01548	09		 DB	 9
  01549	09		 DB	 9
  0154a	09		 DB	 9
  0154b	09		 DB	 9
  0154c	09		 DB	 9
  0154d	09		 DB	 9
  0154e	09		 DB	 9
  0154f	09		 DB	 9
  01550	09		 DB	 9
  01551	09		 DB	 9
  01552	09		 DB	 9
  01553	09		 DB	 9
  01554	09		 DB	 9
  01555	09		 DB	 9
  01556	09		 DB	 9
  01557	09		 DB	 9
  01558	09		 DB	 9
  01559	09		 DB	 9
  0155a	09		 DB	 9
  0155b	09		 DB	 9
  0155c	09		 DB	 9
  0155d	09		 DB	 9
  0155e	09		 DB	 9
  0155f	09		 DB	 9
  01560	09		 DB	 9
  01561	09		 DB	 9
  01562	09		 DB	 9
  01563	09		 DB	 9
  01564	09		 DB	 9
  01565	09		 DB	 9
  01566	09		 DB	 9
  01567	09		 DB	 9
  01568	09		 DB	 9
  01569	09		 DB	 9
  0156a	09		 DB	 9
  0156b	09		 DB	 9
  0156c	09		 DB	 9
  0156d	09		 DB	 9
  0156e	09		 DB	 9
  0156f	09		 DB	 9
  01570	09		 DB	 9
  01571	09		 DB	 9
  01572	09		 DB	 9
  01573	09		 DB	 9
  01574	09		 DB	 9
  01575	09		 DB	 9
  01576	09		 DB	 9
  01577	09		 DB	 9
  01578	09		 DB	 9
  01579	09		 DB	 9
  0157a	09		 DB	 9
  0157b	09		 DB	 9
  0157c	09		 DB	 9
  0157d	09		 DB	 9
  0157e	09		 DB	 9
  0157f	09		 DB	 9
  01580	09		 DB	 9
  01581	09		 DB	 9
  01582	09		 DB	 9
  01583	09		 DB	 9
  01584	09		 DB	 9
  01585	09		 DB	 9
  01586	09		 DB	 9
  01587	09		 DB	 9
  01588	09		 DB	 9
  01589	09		 DB	 9
  0158a	09		 DB	 9
  0158b	09		 DB	 9
  0158c	09		 DB	 9
  0158d	09		 DB	 9
  0158e	09		 DB	 9
  0158f	09		 DB	 9
  01590	09		 DB	 9
  01591	09		 DB	 9
  01592	09		 DB	 9
  01593	09		 DB	 9
  01594	09		 DB	 9
  01595	09		 DB	 9
  01596	09		 DB	 9
  01597	09		 DB	 9
  01598	09		 DB	 9
  01599	09		 DB	 9
  0159a	09		 DB	 9
  0159b	09		 DB	 9
  0159c	09		 DB	 9
  0159d	09		 DB	 9
  0159e	09		 DB	 9
  0159f	09		 DB	 9
  015a0	09		 DB	 9
  015a1	09		 DB	 9
  015a2	09		 DB	 9
  015a3	09		 DB	 9
  015a4	09		 DB	 9
  015a5	09		 DB	 9
  015a6	09		 DB	 9
  015a7	09		 DB	 9
  015a8	09		 DB	 9
  015a9	09		 DB	 9
  015aa	09		 DB	 9
  015ab	09		 DB	 9
  015ac	09		 DB	 9
  015ad	09		 DB	 9
  015ae	09		 DB	 9
  015af	09		 DB	 9
  015b0	09		 DB	 9
  015b1	09		 DB	 9
  015b2	09		 DB	 9
  015b3	09		 DB	 9
  015b4	09		 DB	 9
  015b5	09		 DB	 9
  015b6	09		 DB	 9
  015b7	09		 DB	 9
  015b8	09		 DB	 9
  015b9	09		 DB	 9
  015ba	09		 DB	 9
  015bb	09		 DB	 9
  015bc	09		 DB	 9
  015bd	09		 DB	 9
  015be	09		 DB	 9
  015bf	09		 DB	 9
  015c0	09		 DB	 9
  015c1	09		 DB	 9
  015c2	09		 DB	 9
  015c3	09		 DB	 9
  015c4	09		 DB	 9
  015c5	09		 DB	 9
  015c6	09		 DB	 9
  015c7	09		 DB	 9
  015c8	09		 DB	 9
  015c9	09		 DB	 9
  015ca	09		 DB	 9
  015cb	09		 DB	 9
  015cc	09		 DB	 9
  015cd	09		 DB	 9
  015ce	09		 DB	 9
  015cf	09		 DB	 9
  015d0	09		 DB	 9
  015d1	09		 DB	 9
  015d2	09		 DB	 9
  015d3	09		 DB	 9
  015d4	09		 DB	 9
  015d5	09		 DB	 9
  015d6	09		 DB	 9
  015d7	09		 DB	 9
  015d8	09		 DB	 9
  015d9	09		 DB	 9
  015da	09		 DB	 9
  015db	09		 DB	 9
  015dc	09		 DB	 9
  015dd	09		 DB	 9
  015de	09		 DB	 9
  015df	09		 DB	 9
  015e0	09		 DB	 9
  015e1	09		 DB	 9
  015e2	09		 DB	 9
  015e3	09		 DB	 9
  015e4	09		 DB	 9
  015e5	09		 DB	 9
  015e6	09		 DB	 9
  015e7	09		 DB	 9
  015e8	09		 DB	 9
  015e9	09		 DB	 9
  015ea	09		 DB	 9
  015eb	09		 DB	 9
  015ec	09		 DB	 9
  015ed	09		 DB	 9
  015ee	09		 DB	 9
  015ef	09		 DB	 9
  015f0	09		 DB	 9
  015f1	09		 DB	 9
  015f2	09		 DB	 9
  015f3	09		 DB	 9
  015f4	06		 DB	 6
  015f5	09		 DB	 9
  015f6	09		 DB	 9
  015f7	09		 DB	 9
  015f8	07		 DB	 7
  015f9	08		 DB	 8
z900_diagnose_call ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_validate_operand
_TEXT	SEGMENT
tv79 = 48
addr$ = 80
arn$ = 88
len$ = 96
acctype$ = 104
regs$ = 112
s390_validate_operand PROC				; COMDAT

; 1376 : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1377 :     /* Translate address of leftmost operand byte */
; 1378 :     MADDR( addr, arn, regs, acctype, regs->psw.pkey );

  00016	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001f	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00023	8b 44 24 68	 mov	 eax, DWORD PTR acctype$[rsp]
  00027	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0002b	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  00030	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00035	ba 01 00 00 00	 mov	 edx, 1
  0003a	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0003e	e8 00 00 00 00	 call	 s390_maddr_l

; 1379 : 
; 1380 :     /* Translate next page if boundary crossed */
; 1381 :     if (CROSSPAGE( addr, len ))

  00043	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00047	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004c	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  00051	2b 4c 24 60	 sub	 ecx, DWORD PTR len$[rsp]
  00055	3b c1		 cmp	 eax, ecx
  00057	7e 0a		 jle	 SHORT $LN6@s390_valid
  00059	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
  00061	eb 08		 jmp	 SHORT $LN7@s390_valid
$LN6@s390_valid:
  00063	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN7@s390_valid:
  0006b	83 7c 24 30 00	 cmp	 DWORD PTR tv79[rsp], 0
  00070	74 42		 je	 SHORT $LN2@s390_valid

; 1382 :     {
; 1383 :         MADDR( (addr + len) & ADDRESS_MAXWRAP( regs ),

  00072	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  00076	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0007a	03 c8		 add	 ecx, eax
  0007c	8b c1		 mov	 eax, ecx
  0007e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00083	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00089	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0008e	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00092	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00096	8b 4c 24 68	 mov	 ecx, DWORD PTR acctype$[rsp]
  0009a	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0009e	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000a3	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  000a8	ba 01 00 00 00	 mov	 edx, 1
  000ad	8b c8		 mov	 ecx, eax
  000af	e8 00 00 00 00	 call	 s390_maddr_l
$LN2@s390_valid:

; 1384 :                arn, regs, acctype, regs->psw.pkey );
; 1385 :     }
; 1386 : #if defined( FEATURE_INTERVAL_TIMER )
; 1387 :     else
; 1388 :         ITIMER_SYNC( addr, len, regs );
; 1389 : #endif
; 1390 : }

  000b4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b8	c3		 ret	 0
s390_validate_operand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetch4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
s390_vfetch4 PROC					; COMDAT

; 695  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 696  :     if ((likely(!((VADR_L)addr & 0x03))
; 697  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3) )))

  00011	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00015	83 e0 03	 and	 eax, 3
  00018	85 c0		 test	 eax, eax
  0001a	75 0a		 jne	 SHORT $LN5@s390_vfetc
  0001c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00024	eb 08		 jmp	 SHORT $LN6@s390_vfetc
$LN5@s390_vfetc:
  00026	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN6@s390_vfetc:
  0002e	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00033	74 0a		 je	 SHORT $LN9@s390_vfetc
  00035	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0003d	eb 08		 jmp	 SHORT $LN10@s390_vfetc
$LN9@s390_vfetc:
  0003f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN10@s390_vfetc:
  00047	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  0004c	75 10		 jne	 SHORT $LN3@s390_vfetc
  0004e	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00052	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00057	3d fc 0f 00 00	 cmp	 eax, 4092		; 00000ffcH
  0005c	77 45		 ja	 SHORT $LN2@s390_vfetc
$LN3@s390_vfetc:

; 698  :     {
; 699  :         BYTE *mn;
; 700  :         ITIMER_SYNC( addr, 4-1, regs );
; 701  :         mn = MADDRL( addr, 4,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0005e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00063	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00067	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0006b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00073	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  00078	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  0007d	ba 04 00 00 00	 mov	 edx, 4
  00082	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  00086	e8 00 00 00 00	 call	 s390_maddr_l
  0008b	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 702  :         return fetch_fw( mn );

  00090	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00095	e8 00 00 00 00	 call	 fetch_fw_noswap
  0009a	8b c8		 mov	 ecx, eax
  0009c	e8 00 00 00 00	 call	 _byteswap_ulong
  000a1	eb 12		 jmp	 SHORT $LN1@s390_vfetc
$LN2@s390_vfetc:

; 703  :     }
; 704  :     return ARCH_DEP( vfetch4_full )( addr, arn, regs );

  000a3	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  000a8	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  000ac	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  000b0	e8 00 00 00 00	 call	 s390_vfetch4_full
$LN1@s390_vfetc:

; 705  : }

  000b5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b9	c3		 ret	 0
s390_vfetch4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstorec
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
sk$ = 56
tv81 = 64
main1$ = 72
main2$ = 80
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
s390_vstorec PROC					; COMDAT

; 489  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00025	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002d	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00032	2b d1		 sub	 edx, ecx
  00034	8b ca		 mov	 ecx, edx
  00036	3b c1		 cmp	 eax, ecx
  00038	7f 0a		 jg	 SHORT $LN7@s390_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN8@s390_vstor
$LN7@s390_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN8@s390_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  00051	74 6f		 je	 SHORT $LN2@s390_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00053	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005b	ff c0		 inc	 eax
  0005d	48 98		 cdqe
  0005f	48 89 44 24 40	 mov	 QWORD PTR tv81[rsp], rax
  00064	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0006c	ff c1		 inc	 ecx
  0006e	48 63 c9	 movsxd	 rcx, ecx
  00071	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00079	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0007d	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00081	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00089	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00091	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00099	48 8b d1	 mov	 rdx, rcx
  0009c	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000a3	e8 00 00 00 00	 call	 s390_maddr_l
  000a8	48 8b f8	 mov	 rdi, rax
  000ab	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b3	48 8b 44 24 40	 mov	 rax, QWORD PTR tv81[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	f3 a4		 rep movsb

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );
; 499  :     }

  000bd	e9 29 01 00 00	 jmp	 $LN3@s390_vstor
$LN2@s390_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000c2	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  000c9	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  000ce	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000d3	2b c8		 sub	 ecx, eax
  000d5	8b c1		 mov	 eax, ecx
  000d7	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  000db	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000e0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e8	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000ec	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000f0	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000f8	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00100	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00108	48 8b d0	 mov	 rdx, rax
  0010b	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00112	e8 00 00 00 00	 call	 s390_maddr_l
  00117	48 89 44 24 48	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  0011c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00124	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  0012b	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  00130	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00138	ff c0		 inc	 eax
  0013a	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0013e	48 98		 cdqe
  00140	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  00144	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  0014b	03 d1		 add	 edx, ecx
  0014d	8b ca		 mov	 ecx, edx
  0014f	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00157	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  0015d	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00165	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00169	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0016d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00175	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0017d	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00185	48 8b d0	 mov	 rdx, rax
  00188	e8 00 00 00 00	 call	 s390_maddr_l
  0018d	48 89 44 24 50	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  00192	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  00197	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0019a	83 c8 06	 or	 eax, 6
  0019d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  001a2	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  001a4	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001a9	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main1$[rsp]
  001ae	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  001b6	48 8b c8	 mov	 rcx, rax
  001b9	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  001bb	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001c3	ff c0		 inc	 eax
  001c5	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001c9	48 98		 cdqe
  001cb	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001d0	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  001d8	48 03 d1	 add	 rdx, rcx
  001db	48 8b ca	 mov	 rcx, rdx
  001de	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main2$[rsp]
  001e3	48 8b f1	 mov	 rsi, rcx
  001e6	48 8b c8	 mov	 rcx, rax
  001e9	f3 a4		 rep movsb
$LN3@s390_vstor:

; 512  :     }
; 513  : }

  001eb	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001ef	5f		 pop	 rdi
  001f0	5e		 pop	 rsi
  001f1	c3		 ret	 0
s390_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetch4_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 72
addr$ = 112
arn$ = 120
regs$ = 128
s390_vfetch4_full PROC					; COMDAT

; 428  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 429  : BYTE   *mn;                             /* Main storage addresses    */
; 430  : int     len;                            /* Length to end of page     */
; 431  : BYTE    temp[8];                        /* Copy destination          */
; 432  : 
; 433  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00022	8b 44 24 70	 mov	 eax, DWORD PTR addr$[rsp]
  00026	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002b	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00030	2b c8		 sub	 ecx, eax
  00032	8b c1		 mov	 eax, ecx
  00034	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 434  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00038	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0003d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00049	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0004d	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00055	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0005d	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  00062	48 8b d0	 mov	 rdx, rax
  00065	8b 4c 24 70	 mov	 ecx, DWORD PTR addr$[rsp]
  00069	e8 00 00 00 00	 call	 s390_maddr_l
  0006e	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 435  :     memcpy( temp, mn, len);

  00073	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00078	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  0007d	48 8b f9	 mov	 rdi, rcx
  00080	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00085	48 8b c8	 mov	 rcx, rax
  00088	f3 a4		 rep movsb

; 436  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4 - len, arn, regs,

  0008a	b8 04 00 00 00	 mov	 eax, 4
  0008f	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00093	48 98		 cdqe
  00095	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  00099	8b 54 24 70	 mov	 edx, DWORD PTR addr$[rsp]
  0009d	03 d1		 add	 edx, ecx
  0009f	8b ca		 mov	 ecx, edx
  000a1	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000a9	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  000af	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b7	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000bb	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000bf	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000c7	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000cf	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  000d4	48 8b d0	 mov	 rdx, rax
  000d7	e8 00 00 00 00	 call	 s390_maddr_l
  000dc	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 437  :                   ACCTYPE_READ, regs->psw.pkey );
; 438  :     memcpy( temp+len, mn, 4 - len);

  000e1	b8 04 00 00 00	 mov	 eax, 4
  000e6	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000ea	48 98		 cdqe
  000ec	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000f1	48 8d 4c 0c 40	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  000f6	48 8b f9	 mov	 rdi, rcx
  000f9	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  000fe	48 8b c8	 mov	 rcx, rax
  00101	f3 a4		 rep movsb

; 439  :     return fetch_fw( temp );

  00103	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00108	e8 00 00 00 00	 call	 fetch_fw_noswap
  0010d	8b c8		 mov	 ecx, eax
  0010f	e8 00 00 00 00	 call	 _byteswap_ulong

; 440  : }

  00114	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00119	48 33 cc	 xor	 rcx, rsp
  0011c	e8 00 00 00 00	 call	 __security_check_cookie
  00121	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00125	5f		 pop	 rdi
  00126	5e		 pop	 rsi
  00127	c3		 ret	 0
s390_vfetch4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s390_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s390_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s390_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s390_maddr
$LN12@s390_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s390_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0c	 shr	 eax, 12
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s390_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s390_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s390_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s390_maddr
$LN4@s390_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s390_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s390_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s390_maddr
$LN6@s390_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 c0 7f	 and	 eax, 2143289344		; 7fc00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s390_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s390_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s390_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s390_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s390_maddr:
$LN7@s390_maddr:
$LN5@s390_maddr:
$LN3@s390_maddr:
$LN2@s390_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s390_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s390_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s390_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s390_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s390__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s390__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@s390__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@s390__or_s
$LN5@s390__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s390__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
s390__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390__and_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s390__and_storage_key PROC				; COMDAT

; 172  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390__and_:

; 173  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s390__and_

; 174  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 54		 je	 SHORT $LN5@s390__and_

; 175  :     {
; 176  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 177  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 178  :         AND_SKEY( skey1_ptr, ~bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	f7 d0		 not	 eax
  00043	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00048	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0004b	23 c8		 and	 ecx, eax
  0004d	8b c1		 mov	 eax, ecx
  0004f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00054	88 01		 mov	 BYTE PTR [rcx], al

; 179  :         AND_SKEY( skey2_ptr, ~bits );

  00056	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  0005b	f7 d0		 not	 eax
  0005d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00062	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00065	23 c8		 and	 ecx, eax
  00067	8b c1		 mov	 eax, ecx
  00069	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006e	88 01		 mov	 BYTE PTR [rcx], al

; 180  :     }

  00070	eb 2e		 jmp	 SHORT $LN6@s390__and_
$LN5@s390__and_:

; 181  :     else
; 182  :     {
; 183  :         BYTE* skey_ptr  = _get_storekey_ptr(  abs, K );

  00072	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00077	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  0007c	e8 00 00 00 00	 call	 _get_storekey_ptr
  00081	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 184  :         AND_SKEY( skey_ptr, ~bits );

  00086	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  0008b	f7 d0		 not	 eax
  0008d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00092	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00095	23 c8		 and	 ecx, eax
  00097	8b c1		 mov	 eax, ecx
  00099	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0009e	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s390__and_:

; 185  :     }
; 186  : }

  000a0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a4	c3		 ret	 0
s390__and_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\diagnose.c
_TEXT	SEGMENT
tv64 = 64
n$ = 68
opt$1 = 72
cpu$2 = 76
i$3 = 80
i$4 = 84
rc$5 = 88
rc$6 = 92
code$ = 96
bodysize$7 = 100
i$8 = 104
tv226 = 108
tv356 = 112
lopasize$9 = 116
headsize$10 = 120
tv604 = 124
usecs$11 = 128
instcount$12 = 136
stgarea$13 = 144
mask$14 = 152
mask$15 = 160
secs$16 = 168
tv704 = 176
ipb$17 = 192
__$ArrayPad$ = 400
regs$ = 432
r1$ = 440
r3$ = 448
b2$ = 456
effective_addr2$ = 464
s390_diagnose_call PROC

; 240  : {

$LN153:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 81 ec a0 01
	00 00		 sub	 rsp, 416		; 000001a0H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 241  : #ifdef FEATURE_HERCULES_DIAGCALLS
; 242  : U32   n;                                /* 32-bit operand value      */
; 243  : #endif /*FEATURE_HERCULES_DIAGCALLS*/
; 244  : U32   code;
; 245  : 
; 246  :     code = effective_addr2;

  0002d	8b 84 24 d0 01
	00 00		 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00034	89 44 24 60	 mov	 DWORD PTR code$[rsp], eax

; 247  : 
; 248  :     switch(code) {

  00038	8b 44 24 60	 mov	 eax, DWORD PTR code$[rsp]
  0003c	89 44 24 40	 mov	 DWORD PTR tv64[rsp], eax
  00040	81 7c 24 40 04
	02 00 00	 cmp	 DWORD PTR tv64[rsp], 516 ; 00000204H
  00048	77 3b		 ja	 SHORT $LN145@s390_diagn
  0004a	81 7c 24 40 04
	02 00 00	 cmp	 DWORD PTR tv64[rsp], 516 ; 00000204H
  00052	0f 84 da 01 00
	00		 je	 $LN61@s390_diagn
  00058	81 7c 24 40 dc
	00 00 00	 cmp	 DWORD PTR tv64[rsp], 220 ; 000000dcH
  00060	0f 87 d1 10 00
	00		 ja	 $LN134@s390_diagn
  00066	8b 44 24 40	 mov	 eax, DWORD PTR tv64[rsp]
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00071	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN151@s390_diagn[rcx+rax]
  00079	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN152@s390_diagn[rcx+rax*4]
  00080	48 03 c1	 add	 rax, rcx
  00083	ff e0		 jmp	 rax
$LN145@s390_diagn:
  00085	81 7c 24 40 00
	0f 00 00	 cmp	 DWORD PTR tv64[rsp], 3840 ; 00000f00H
  0008d	77 48		 ja	 SHORT $LN146@s390_diagn
  0008f	81 7c 24 40 00
	0f 00 00	 cmp	 DWORD PTR tv64[rsp], 3840 ; 00000f00H
  00097	0f 84 fe 09 00
	00		 je	 $LN101@s390_diagn
  0009d	8b 44 24 40	 mov	 eax, DWORD PTR tv64[rsp]
  000a1	2d 10 02 00 00	 sub	 eax, 528		; 00000210H
  000a6	89 44 24 40	 mov	 DWORD PTR tv64[rsp], eax
  000aa	81 7c 24 40 f8
	00 00 00	 cmp	 DWORD PTR tv64[rsp], 248 ; 000000f8H
  000b2	0f 87 7f 10 00
	00		 ja	 $LN134@s390_diagn
  000b8	8b 44 24 40	 mov	 eax, DWORD PTR tv64[rsp]
  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000c3	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN149@s390_diagn[rcx+rax]
  000cb	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN150@s390_diagn[rcx+rax*4]
  000d2	48 03 c1	 add	 rax, rcx
  000d5	ff e0		 jmp	 rax
$LN146@s390_diagn:
  000d7	8b 44 24 40	 mov	 eax, DWORD PTR tv64[rsp]
  000db	2d 04 0f 00 00	 sub	 eax, 3844		; 00000f04H
  000e0	89 44 24 40	 mov	 DWORD PTR tv64[rsp], eax
  000e4	81 7c 24 40 f9
	00 00 00	 cmp	 DWORD PTR tv64[rsp], 249 ; 000000f9H
  000ec	0f 87 45 10 00
	00		 ja	 $LN134@s390_diagn
  000f2	8b 44 24 40	 mov	 eax, DWORD PTR tv64[rsp]
  000f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000fd	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN147@s390_diagn[rcx+rax]
  00105	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN148@s390_diagn[rcx+rax*4]
  0010c	48 03 c1	 add	 rax, rcx
  0010f	ff e0		 jmp	 rax
$LN53@s390_diagn:

; 249  : 
; 250  : 
; 251  : #if defined(FEATURE_IO_ASSIST)
; 252  :     case 0x002:
; 253  :     /*---------------------------------------------------------------*/
; 254  :     /* Diagnose 002: Update Interrupt Interlock Control Bit in PMCW  */
; 255  :     /*---------------------------------------------------------------*/
; 256  : 
; 257  :         ARCH_DEP(diagnose_002) (regs, r1, r3);

  00111	44 8b 84 24 c0
	01 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  00119	8b 94 24 b8 01
	00 00		 mov	 edx, DWORD PTR r1$[rsp]
  00120	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00128	e8 00 00 00 00	 call	 s390_diagnose_002

; 258  : 
; 259  :         break;

  0012d	e9 6d 11 00 00	 jmp	 $LN2@s390_diagn
$LN54@s390_diagn:

; 260  : #endif
; 261  : 
; 262  : 
; 263  :     case 0x01F:
; 264  :     /*---------------------------------------------------------------*/
; 265  :     /* Diagnose 01F: Power Off                                       */
; 266  :     /*---------------------------------------------------------------*/
; 267  : 
; 268  :         /* If diag8opt is not enabled then we are not allowed
; 269  :          * to manipulate the real machine i.e. hercules itself
; 270  :          */
; 271  :         if(!(sysblk.diag8opt & DIAG8CMD_ENABLE))

  00132	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00139	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  00140	83 e0 01	 and	 eax, 1
  00143	85 c0		 test	 eax, eax
  00145	75 12		 jne	 SHORT $LN55@s390_diagn

; 272  :             ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00147	ba 06 00 00 00	 mov	 edx, 6
  0014c	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00154	e8 00 00 00 00	 call	 s390_program_interrupt
$LN55@s390_diagn:

; 273  : 
; 274  :         /* The poweroff diagnose is only valid on the 9221 */
; 275  :         if (sysblk.cpumodel != 0x9221
; 276  :           /* and r1/r3 must contain C'POWEROFF' in EBCDIC */
; 277  :           || regs->GR_L(r1) != 0xD7D6E6C5
; 278  :           || regs->GR_L(r3) != 0xD9D6C6C6)

  00159	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00160	0f b7 80 d4 00
	00 00		 movzx	 eax, WORD PTR [rax+212]
  00167	3d 21 92 00 00	 cmp	 eax, 37409		; 00009221H
  0016c	75 3a		 jne	 SHORT $LN57@s390_diagn
  0016e	48 63 84 24 b8
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00176	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017e	81 bc c1 80 02
	00 00 c5 e6 d6
	d7		 cmp	 DWORD PTR [rcx+rax*8+640], -673782075 ; d7d6e6c5H
  00189	75 1d		 jne	 SHORT $LN57@s390_diagn
  0018b	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00193	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0019b	81 bc c1 80 02
	00 00 c6 c6 d6
	d9		 cmp	 DWORD PTR [rcx+rax*8+640], -640235834 ; d9d6c6c6H
  001a6	74 12		 je	 SHORT $LN56@s390_diagn
$LN57@s390_diagn:

; 279  :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  001a8	ba 06 00 00 00	 mov	 edx, 6
  001ad	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	e8 00 00 00 00	 call	 s390_program_interrupt
$LN56@s390_diagn:

; 280  : 
; 281  :         regs->cpustate = CPUSTATE_STOPPING;

  001ba	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c2	c6 40 60 02	 mov	 BYTE PTR [rax+96], 2
$LN6@s390_diagn:

; 282  :         ON_IC_INTERRUPT(regs);

  001c6	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ce	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  001d1	0f ba e8 1f	 bts	 eax, 31
  001d5	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001dd	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  001e0	33 c0		 xor	 eax, eax
  001e2	85 c0		 test	 eax, eax
  001e4	75 e0		 jne	 SHORT $LN6@s390_diagn

; 283  : 
; 284  :         /* Release the configuration */
; 285  :         do_shutdown();

  001e6	e8 00 00 00 00	 call	 do_shutdown

; 286  : 
; 287  :         /* Power Off: exit hercules */
; 288  :         exit(0);

  001eb	33 c9		 xor	 ecx, ecx
  001ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN58@s390_diagn:

; 289  : 
; 290  : #if defined(FEATURE_HYPERVISOR) || defined(FEATURE_EMULATE_VM)
; 291  :     case 0x044:
; 292  :     /*---------------------------------------------------------------*/
; 293  :     /* Diagnose 044: Voluntary Time Slice End                        */
; 294  :     /*---------------------------------------------------------------*/
; 295  :         ARCH_DEP(scpend_call) ();

  001f3	e8 00 00 00 00	 call	 s390_scpend_call

; 296  :         break;

  001f8	e9 a2 10 00 00	 jmp	 $LN2@s390_diagn
$LN59@s390_diagn:

; 297  : #endif
; 298  : 
; 299  : 
; 300  : #ifdef FEATURE_MSSF_CALL
; 301  :     case 0x080:
; 302  :     /*---------------------------------------------------------------*/
; 303  :     /* Diagnose 080: MSSF Call                                       */
; 304  :     /*---------------------------------------------------------------*/
; 305  :         regs->psw.cc = ARCH_DEP(mssf_call) (r1, r3, regs);

  001fd	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00205	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  0020c	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  00213	e8 00 00 00 00	 call	 s390_mssf_call
  00218	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00220	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 306  :         break;

  00223	e9 77 10 00 00	 jmp	 $LN2@s390_diagn
$LN60@s390_diagn:

; 307  : #endif /*FEATURE_MSSF_CALL*/
; 308  : 
; 309  : 
; 310  : #if defined(FEATURE_HYPERVISOR) || defined(FEATURE_EMULATE_VM)
; 311  :     case 0x09C:
; 312  :     /*---------------------------------------------------------------*/
; 313  :     /* Diagnose 09C: Voluntary Time Slice End With Target CPU        */
; 314  :     /*---------------------------------------------------------------*/
; 315  :         ARCH_DEP(scpend_call) ();   // (treat same as DIAG X'44')

  00228	e8 00 00 00 00	 call	 s390_scpend_call

; 316  :         break;

  0022d	e9 6d 10 00 00	 jmp	 $LN2@s390_diagn
$LN61@s390_diagn:

; 317  : #endif
; 318  : 
; 319  : 
; 320  : #if defined(FEATURE_HYPERVISOR)
; 321  :     case 0x204:
; 322  :     /*---------------------------------------------------------------*/
; 323  :     /* Diagnose 204: LPAR RMF Interface                              */
; 324  :     /*---------------------------------------------------------------*/
; 325  :         ARCH_DEP(diag204_call) (r1, r3, regs);

  00232	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0023a	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  00241	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  00248	e8 00 00 00 00	 call	 s390_diag204_call

; 326  :         regs->psw.cc = 0;

  0024d	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00255	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 327  :         break;

  00259	e9 41 10 00 00	 jmp	 $LN2@s390_diagn
$LN62@s390_diagn:

; 328  : 
; 329  :     case 0x224:
; 330  :     /*---------------------------------------------------------------*/
; 331  :     /* Diagnose 224: CPU Names                                       */
; 332  :     /*---------------------------------------------------------------*/
; 333  :         ARCH_DEP(diag224_call) (r1, r3, regs);

  0025e	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00266	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  0026d	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  00274	e8 00 00 00 00	 call	 s390_diag224_call

; 334  :         regs->psw.cc = 0;

  00279	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00281	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 335  :         break;

  00285	e9 15 10 00 00	 jmp	 $LN2@s390_diagn
$LN63@s390_diagn:

; 336  : #endif /*defined(FEATURE_HYPERVISOR)*/
; 337  : 
; 338  : #if 0
; 339  :     case 0x21C:
; 340  :     /*---------------------------------------------------------------*/
; 341  :     /* Diagnose 21C: ????                                            */
; 342  :     /*---------------------------------------------------------------*/
; 343  :         /*INCOMPLETE*/
; 344  :         regs->psw.cc = 0;
; 345  :         break;
; 346  : #endif
; 347  : 
; 348  : #if 0
; 349  :     case 0x288;:
; 350  :     /*---------------------------------------------------------------*/
; 351  :     /* Diagnose 288: Control Virtual Machine Time Bomb               */
; 352  :     /*---------------------------------------------------------------*/
; 353  :         regs->psw.cc = ARCH_DEP(vm_timebomb) (r1, r3, regs);
; 354  :         break;
; 355  : #endif
; 356  : 
; 357  : #ifdef FEATURE_EMULATE_VM
; 358  :     case 0x000:
; 359  :     /*---------------------------------------------------------------*/
; 360  :     /* Diagnose 000: Store Extended Identification Code              */
; 361  :     /*---------------------------------------------------------------*/
; 362  :         ARCH_DEP(extid_call) (r1, r3, regs);

  0028a	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00292	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  00299	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  002a0	e8 00 00 00 00	 call	 s390_extid_call

; 363  :         break;

  002a5	e9 f5 0f 00 00	 jmp	 $LN2@s390_diagn
$LN64@s390_diagn:

; 364  : 
; 365  :     case 0x008:
; 366  :     /*---------------------------------------------------------------*/
; 367  :     /* Diagnose 008: Virtual Console Function                        */
; 368  :     /*---------------------------------------------------------------*/
; 369  :         /* If diag8opt is not enabled then we are not allowed
; 370  :          * to manipulate the real machine i.e. hercules itself
; 371  :          */
; 372  :         if(!(sysblk.diag8opt & DIAG8CMD_ENABLE))

  002aa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002b1	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  002b8	83 e0 01	 and	 eax, 1
  002bb	85 c0		 test	 eax, eax
  002bd	75 12		 jne	 SHORT $LN65@s390_diagn

; 373  :             ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  002bf	ba 06 00 00 00	 mov	 edx, 6
  002c4	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002cc	e8 00 00 00 00	 call	 s390_program_interrupt
$LN65@s390_diagn:

; 374  : 
; 375  :         /* Process CP command and set condition code */
; 376  :         regs->psw.cc = ARCH_DEP(cpcmd_call) (r1, r3, regs);

  002d1	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002d9	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  002e0	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  002e7	e8 00 00 00 00	 call	 s390_cpcmd_call
  002ec	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f4	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 377  :         break;

  002f7	e9 a3 0f 00 00	 jmp	 $LN2@s390_diagn
$LN66@s390_diagn:

; 378  : 
; 379  :     case 0x00C:
; 380  :     /*---------------------------------------------------------------*/
; 381  :     /* Diagnose 00C: Pseudo Timer                                    */
; 382  :     /*---------------------------------------------------------------*/
; 383  :         ARCH_DEP(pseudo_timer) (code, r1, r3, regs);

  002fc	4c 8b 8c 24 b0
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00304	44 8b 84 24 c0
	01 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  0030c	8b 94 24 b8 01
	00 00		 mov	 edx, DWORD PTR r1$[rsp]
  00313	8b 4c 24 60	 mov	 ecx, DWORD PTR code$[rsp]
  00317	e8 00 00 00 00	 call	 s390_pseudo_timer

; 384  :         break;

  0031c	e9 7e 0f 00 00	 jmp	 $LN2@s390_diagn
$LN67@s390_diagn:

; 385  : 
; 386  :     case 0x024:
; 387  :     /*---------------------------------------------------------------*/
; 388  :     /* Diagnose 024: Device Type and Features                        */
; 389  :     /*---------------------------------------------------------------*/
; 390  :         regs->psw.cc = ARCH_DEP(diag_devtype) (r1, r3, regs);

  00321	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00329	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  00330	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  00337	e8 00 00 00 00	 call	 s390_diag_devtype
  0033c	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00344	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 391  :         break;

  00347	e9 53 0f 00 00	 jmp	 $LN2@s390_diagn
$LN68@s390_diagn:

; 392  : 
; 393  :     case 0x05C:
; 394  :     /*---------------------------------------------------------------*/
; 395  :     /* Diagnose 05C: Error Message Editing                           */
; 396  :     /*---------------------------------------------------------------*/
; 397  :         /* This function is implemented as a no-operation */
; 398  :         regs->psw.cc = 0;

  0034c	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00354	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 399  :         break;

  00358	e9 42 0f 00 00	 jmp	 $LN2@s390_diagn
$LN69@s390_diagn:

; 400  : 
; 401  :     case 0x060:
; 402  :     /*---------------------------------------------------------------*/
; 403  :     /* Diagnose 060: Virtual Machine Storage Size                    */
; 404  :     /*---------------------------------------------------------------*/
; 405  :         /* Load main storage size in bytes into R1 register */
; 406  :         regs->GR_L(r1) = regs->mainlim + 1;

  0035d	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00365	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  0036c	48 ff c0	 inc	 rax
  0036f	48 63 8c 24 b8
	01 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00377	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0037f	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 407  :         break;

  00386	e9 14 0f 00 00	 jmp	 $LN2@s390_diagn
$LN70@s390_diagn:

; 408  : 
; 409  :     case 0x064:
; 410  :     /*---------------------------------------------------------------*/
; 411  :     /* Diagnose 064: Named Saved Segment Manipulation                */
; 412  :     /*---------------------------------------------------------------*/
; 413  :         /* Return code 44 cond code 2 means segment does not exist */
; 414  :         regs->GR_L(r3) = 44;

  0038b	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00393	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0039b	c7 84 c1 80 02
	00 00 2c 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 44 ; 0000002cH

; 415  :         regs->psw.cc = 2;

  003a6	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003ae	c6 40 7c 02	 mov	 BYTE PTR [rax+124], 2

; 416  :         break;

  003b2	e9 e8 0e 00 00	 jmp	 $LN2@s390_diagn
$LN71@s390_diagn:

; 417  : 
; 418  :     case 0x0A4:
; 419  :     /*---------------------------------------------------------------*/
; 420  :     /* Diagnose 0A4: Synchronous I/O (Standard CMS Blocksize)        */
; 421  :     /*---------------------------------------------------------------*/
; 422  :         regs->psw.cc = ARCH_DEP(syncblk_io) (r1, r3, regs);

  003b7	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003bf	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  003c6	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  003cd	e8 00 00 00 00	 call	 s390_syncblk_io
  003d2	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003da	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 423  : //      logmsg ("Diagnose X\'0A4\': CC=%d, R15=%8.8X\n",      /*debug*/
; 424  : //              regs->psw.cc, regs->GR_L(15));                 /*debug*/
; 425  :         break;

  003dd	e9 bd 0e 00 00	 jmp	 $LN2@s390_diagn
$LN72@s390_diagn:

; 426  : 
; 427  :     case 0x0A8:
; 428  :     /*---------------------------------------------------------------*/
; 429  :     /* Diagnose 0A8: Synchronous General I/O                         */
; 430  :     /*---------------------------------------------------------------*/
; 431  :         regs->psw.cc = ARCH_DEP(syncgen_io) (r1, r3, regs);

  003e2	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003ea	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  003f1	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  003f8	e8 00 00 00 00	 call	 s390_syncgen_io
  003fd	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00405	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 432  : //      logmsg ("Diagnose X\'0A8\': CC=%d, R15=%8.8X\n",      /*debug*/
; 433  : //              regs->psw.cc, regs->GR_L(15));                 /*debug*/
; 434  :         break;

  00408	e9 92 0e 00 00	 jmp	 $LN2@s390_diagn
$LN73@s390_diagn:

; 435  : 
; 436  :     case 0x0B0:
; 437  :     /*---------------------------------------------------------------*/
; 438  :     /* Diagnose 0B0: Access Re-IPL Data                              */
; 439  :     /*---------------------------------------------------------------*/
; 440  :         ARCH_DEP(access_reipl_data) (r1, r3, regs);

  0040d	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00415	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  0041c	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  00423	e8 00 00 00 00	 call	 s390_access_reipl_data

; 441  :         break;

  00428	e9 72 0e 00 00	 jmp	 $LN2@s390_diagn
$LN74@s390_diagn:

; 442  : 
; 443  :     case 0x0DC:
; 444  :     /*---------------------------------------------------------------*/
; 445  :     /* Diagnose 0DC: Control Application Monitor Record Collection   */
; 446  :     /*---------------------------------------------------------------*/
; 447  :         /* This function is implemented as a no-operation */
; 448  :         regs->GR_L(r3) = 0;

  0042d	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00435	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0043d	c7 84 c1 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 0

; 449  :         regs->psw.cc = 0;

  00448	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00450	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 450  :         break;

  00454	e9 46 0e 00 00	 jmp	 $LN2@s390_diagn
$LN75@s390_diagn:

; 451  : 
; 452  :     case 0x210:
; 453  :     /*---------------------------------------------------------------*/
; 454  :     /* Diagnose 210: Retrieve Device Information                     */
; 455  :     /*---------------------------------------------------------------*/
; 456  :         regs->psw.cc = ARCH_DEP(device_info) (r1, r3, regs);

  00459	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00461	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  00468	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  0046f	e8 00 00 00 00	 call	 s390_device_info
  00474	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0047c	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 457  :         break;

  0047f	e9 1b 0e 00 00	 jmp	 $LN2@s390_diagn
$LN76@s390_diagn:

; 458  : 
; 459  :     case 0x214:
; 460  :     /*---------------------------------------------------------------*/
; 461  :     /* Diagnose 214: Pending Page Release                            */
; 462  :     /*---------------------------------------------------------------*/
; 463  :         regs->psw.cc = ARCH_DEP(diag_ppagerel) (r1, r3, regs);

  00484	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0048c	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  00493	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  0049a	e8 00 00 00 00	 call	 s390_diag_ppagerel
  0049f	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004a7	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 464  :         break;

  004aa	e9 f0 0d 00 00	 jmp	 $LN2@s390_diagn
$LN77@s390_diagn:

; 465  : 
; 466  : 
; 467  :     case 0x220:
; 468  :     /*---------------------------------------------------------------*/
; 469  :     /* Diagnose 220: TOD Epoch                                       */
; 470  :     /*---------------------------------------------------------------*/
; 471  :         ODD_CHECK(r3, regs);

  004af	8b 84 24 c0 01
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  004b6	83 e0 01	 and	 eax, 1
  004b9	85 c0		 test	 eax, eax
  004bb	74 1b		 je	 SHORT $LN78@s390_diagn
  004bd	ba 06 00 00 00	 mov	 edx, 6
  004c2	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004ca	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004d2	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN78@s390_diagn:

; 472  : 
; 473  :         switch(regs->GR_L(r1))

  004d8	48 63 84 24 b8
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  004e0	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004e8	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  004ef	89 44 24 6c	 mov	 DWORD PTR tv226[rsp], eax
  004f3	83 7c 24 6c 00	 cmp	 DWORD PTR tv226[rsp], 0
  004f8	74 0c		 je	 SHORT $LN79@s390_diagn
  004fa	83 7c 24 6c 01	 cmp	 DWORD PTR tv226[rsp], 1
  004ff	74 40		 je	 SHORT $LN80@s390_diagn
  00501	e9 a5 00 00 00	 jmp	 $LN81@s390_diagn
$LN79@s390_diagn:

; 474  :         {
; 475  :             case 0:
; 476  :                 /* Obtain TOD features */
; 477  :                 regs->GR_L(r3)  =0xc0000000;

  00506	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0050e	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00516	c7 84 c1 80 02
	00 00 00 00 00
	c0		 mov	 DWORD PTR [rcx+rax*8+640], -1073741824 ; c0000000H

; 478  :                 regs->GR_L(r3+1)=0x00000000;

  00521	8b 84 24 c0 01
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00528	ff c0		 inc	 eax
  0052a	48 98		 cdqe
  0052c	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00534	c7 84 c1 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 0

; 479  :                 break;

  0053f	eb 7c		 jmp	 SHORT $LN7@s390_diagn
$LN80@s390_diagn:

; 480  :             case 1:
; 481  :                 /* Obtain TOD offset to real TOD in R2, R2+1 */
; 482  :                 regs->GR_L(r3)  = (regs->tod_epoch >> 24) & 0xFFFFFFFF;

  00541	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00549	48 8b 80 40 07
	00 00		 mov	 rax, QWORD PTR [rax+1856]
  00550	48 c1 f8 18	 sar	 rax, 24
  00554	b9 ff ff ff ff	 mov	 ecx, -1
  00559	48 23 c1	 and	 rax, rcx
  0055c	48 63 8c 24 c0
	01 00 00	 movsxd	 rcx, DWORD PTR r3$[rsp]
  00564	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0056c	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 483  :                 regs->GR_L(r3+1)= (regs->tod_epoch << 8) & 0xFFFFFFFF;

  00573	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0057b	48 8b 80 40 07
	00 00		 mov	 rax, QWORD PTR [rax+1856]
  00582	48 c1 e0 08	 shl	 rax, 8
  00586	b9 ff ff ff ff	 mov	 ecx, -1
  0058b	48 23 c1	 and	 rax, rcx
  0058e	8b 8c 24 c0 01
	00 00		 mov	 ecx, DWORD PTR r3$[rsp]
  00595	ff c1		 inc	 ecx
  00597	48 63 c9	 movsxd	 rcx, ecx
  0059a	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005a2	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 484  :                 break;

  005a9	eb 12		 jmp	 SHORT $LN7@s390_diagn
$LN81@s390_diagn:

; 485  :             default:
; 486  :                 ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  005ab	ba 06 00 00 00	 mov	 edx, 6
  005b0	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005b8	e8 00 00 00 00	 call	 s390_program_interrupt
$LN7@s390_diagn:

; 487  :         }
; 488  :         break;

  005bd	e9 dd 0c 00 00	 jmp	 $LN2@s390_diagn
$LN82@s390_diagn:

; 489  : 
; 490  : 
; 491  :     case 0x23C:
; 492  :     /*---------------------------------------------------------------*/
; 493  :     /* Diagnose 23C: Address Space Services                          */
; 494  :     /*---------------------------------------------------------------*/
; 495  :         /* This function is implemented as a no-operation */
; 496  :         regs->GR_L(r3) = 0;

  005c2	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  005ca	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005d2	c7 84 c1 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 0

; 497  :         break;

  005dd	e9 bd 0c 00 00	 jmp	 $LN2@s390_diagn
$LN83@s390_diagn:

; 498  : 
; 499  : 
; 500  : #if defined(FEATURE_VM_BLOCKIO)
; 501  :     case 0x250:
; 502  :     /*---------------------------------------------------------------*/
; 503  :     /* Diagnose 250: Standardized Block I/O                          */
; 504  :     /*---------------------------------------------------------------*/
; 505  :         regs->psw.cc = ARCH_DEP(vm_blockio) (r1, r3, regs);

  005e2	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  005ea	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  005f1	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  005f8	e8 00 00 00 00	 call	 s390_vm_blockio
  005fd	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00605	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 506  :         break;

  00608	e9 92 0c 00 00	 jmp	 $LN2@s390_diagn
$LN84@s390_diagn:

; 507  : #endif /*defined(FEATURE_VM_BLOCKIO)*/
; 508  : 
; 509  : 
; 510  :     case 0x260:
; 511  :     /*---------------------------------------------------------------*/
; 512  :     /* Diagnose 260: Access Certain Virtual Machine Information      */
; 513  :     /*---------------------------------------------------------------*/
; 514  :         ARCH_DEP(vm_info) (r1, r3, regs);

  0060d	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00615	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  0061c	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  00623	e8 00 00 00 00	 call	 s390_vm_info

; 515  :         break;

  00628	e9 72 0c 00 00	 jmp	 $LN2@s390_diagn
$LN85@s390_diagn:
$LN11@s390_diagn:

; 516  : 
; 517  :     case 0x264:
; 518  :     /*---------------------------------------------------------------*/
; 519  :     /* Diagnose 264: CP Communication                                */
; 520  :     /*---------------------------------------------------------------*/
; 521  :         /* This function is implemented as a no-operation */
; 522  :         PTT_ERR("*DIAG264",regs->GR_L(r1),regs->GR_L(r3),regs->psw.IA_L);

  0062d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00634	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00637	48 83 e0 10	 and	 rax, 16
  0063b	48 85 c0	 test	 rax, rax
  0063e	74 6f		 je	 SHORT $LN86@s390_diagn
  00640	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00648	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0064e	48 63 8c 24 c0
	01 00 00	 movsxd	 rcx, DWORD PTR r3$[rsp]
  00656	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0065e	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  00665	48 63 94 24 b8
	01 00 00	 movsxd	 rdx, DWORD PTR r1$[rsp]
  0066d	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00675	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  0067d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00686	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0068b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179944
  00692	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00697	44 8b c9	 mov	 r9d, ecx
  0069a	44 8b c2	 mov	 r8d, edx
  0069d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179945
  006a4	b9 10 00 00 00	 mov	 ecx, 16
  006a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN86@s390_diagn:
  006af	33 c0		 xor	 eax, eax
  006b1	85 c0		 test	 eax, eax
  006b3	0f 85 74 ff ff
	ff		 jne	 $LN11@s390_diagn

; 523  :         regs->psw.cc = 0;

  006b9	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006c1	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 524  :         break;

  006c5	e9 d5 0b 00 00	 jmp	 $LN2@s390_diagn
$LN87@s390_diagn:

; 525  : 
; 526  :     case 0x270:
; 527  :     /*---------------------------------------------------------------*/
; 528  :     /* Diagnose 270: Pseudo Timer Extended                           */
; 529  :     /*---------------------------------------------------------------*/
; 530  :         ARCH_DEP(pseudo_timer) (code, r1, r3, regs);

  006ca	4c 8b 8c 24 b0
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  006d2	44 8b 84 24 c0
	01 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  006da	8b 94 24 b8 01
	00 00		 mov	 edx, DWORD PTR r1$[rsp]
  006e1	8b 4c 24 60	 mov	 ecx, DWORD PTR code$[rsp]
  006e5	e8 00 00 00 00	 call	 s390_pseudo_timer

; 531  :         break;

  006ea	e9 b0 0b 00 00	 jmp	 $LN2@s390_diagn
$LN88@s390_diagn:
$LN14@s390_diagn:

; 532  : 
; 533  :     case 0x274:
; 534  :     /*---------------------------------------------------------------*/
; 535  :     /* Diagnose 274: Set Timezone Interrupt Flag                     */
; 536  :     /*---------------------------------------------------------------*/
; 537  :         /* This function is implemented as a no-operation */
; 538  :         PTT_ERR("*DIAG274",regs->GR_L(r1),regs->GR_L(r3),regs->psw.IA_L);

  006ef	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  006f6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006f9	48 83 e0 10	 and	 rax, 16
  006fd	48 85 c0	 test	 rax, rax
  00700	74 6f		 je	 SHORT $LN89@s390_diagn
  00702	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0070a	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00710	48 63 8c 24 c0
	01 00 00	 movsxd	 rcx, DWORD PTR r3$[rsp]
  00718	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00720	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  00727	48 63 94 24 b8
	01 00 00	 movsxd	 rdx, DWORD PTR r1$[rsp]
  0072f	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00737	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  0073f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00748	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0074d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179949
  00754	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00759	44 8b c9	 mov	 r9d, ecx
  0075c	44 8b c2	 mov	 r8d, edx
  0075f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179950
  00766	b9 10 00 00 00	 mov	 ecx, 16
  0076b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN89@s390_diagn:
  00771	33 c0		 xor	 eax, eax
  00773	85 c0		 test	 eax, eax
  00775	0f 85 74 ff ff
	ff		 jne	 $LN14@s390_diagn

; 539  :         regs->psw.cc = 0;

  0077b	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00783	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 540  :         break;

  00787	e9 13 0b 00 00	 jmp	 $LN2@s390_diagn
$LN90@s390_diagn:
$LN17@s390_diagn:

; 541  : #endif /*FEATURE_EMULATE_VM*/
; 542  : 
; 543  : 
; 544  :     case 0x308:
; 545  :     /*---------------------------------------------------------------*/
; 546  :     /* Diagnose 308: IPL functions                                   */
; 547  :     /*---------------------------------------------------------------*/
; 548  :         PTT_ERR("*DIAG308",regs->GR_G(r1),regs->GR_G(r3),regs->psw.IA_L);

  0078c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00793	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00796	48 83 e0 10	 and	 rax, 16
  0079a	48 85 c0	 test	 rax, rax
  0079d	74 6a		 je	 SHORT $LN91@s390_diagn
  0079f	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007a7	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  007ad	48 63 8c 24 c0
	01 00 00	 movsxd	 rcx, DWORD PTR r3$[rsp]
  007b5	48 63 94 24 b8
	01 00 00	 movsxd	 rdx, DWORD PTR r1$[rsp]
  007bd	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  007c6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  007cb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179953
  007d2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007d7	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007df	4c 8b 8c c8 80
	02 00 00	 mov	 r9, QWORD PTR [rax+rcx*8+640]
  007e7	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007ef	4c 8b 84 d0 80
	02 00 00	 mov	 r8, QWORD PTR [rax+rdx*8+640]
  007f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179954
  007fe	b9 10 00 00 00	 mov	 ecx, 16
  00803	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN91@s390_diagn:
  00809	33 c0		 xor	 eax, eax
  0080b	85 c0		 test	 eax, eax
  0080d	0f 85 79 ff ff
	ff		 jne	 $LN17@s390_diagn

; 549  : 
; 550  :         switch(regs->GR_L(r3))

  00813	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0081b	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00823	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0082a	89 44 24 70	 mov	 DWORD PTR tv356[rsp], eax
  0082e	83 7c 24 70 01	 cmp	 DWORD PTR tv356[rsp], 1
  00833	74 0c		 je	 SHORT $LN92@s390_diagn
  00835	83 7c 24 70 06	 cmp	 DWORD PTR tv356[rsp], 6
  0083a	74 0a		 je	 SHORT $LN93@s390_diagn
  0083c	e9 43 02 00 00	 jmp	 $LN100@s390_diagn
$LN92@s390_diagn:

; 551  :         {
; 552  : #if defined(FEATURE_PROGRAM_DIRECTED_REIPL)
; 553  :             TID   tid;                              /* Thread identifier         */
; 554  :             char *ipltype;                          /* "ipl" or "iplc"           */
; 555  :             int   rc;
; 556  : #endif /*defined(FEATURE_PROGRAM_DIRECTED_REIPL)*/
; 557  : 
; 558  :         case DIAG308_START_KERNEL:
; 559  :             /*-------------------------------------------------------*/
; 560  :             /* Linux for z uses this function code, without a        */
; 561  :             /* defined value, in a function named start_kernel (see  */
; 562  :             /* ZIPL stage3.c). The Diagnose instruction is DIAG      */
; 563  :             /* 1,1,0x308, with GPR 1 containing DIAG308_START_KERNEL */
; 564  :             /* (i.e. equal to 1). This author has no idea what       */
; 565  :             /* function start_kernel is expecting the Diagnose       */
; 566  :             /* instruction to do (other than starting the kernel!),  */
; 567  :             /* but the function does not check a return code, or     */
; 568  :             /* anything else, and is prepared for the Diagnose       */
; 569  :             /* instruction to program check. Fortunately, the        */
; 570  :             /* function code DIAG308_START_KERNEL and the return     */
; 571  :             /* code DIAG308_RC_OK both have the same value (i.e.     */
; 572  :             /* equal to 1), so we'll simply return without doing     */
; 573  :             /* anything, letting the function code become the        */
; 574  :             /* return code.                                          */
; 575  :             /*-------------------------------------------------------*/
; 576  :             break;

  00841	e9 50 02 00 00	 jmp	 $LN18@s390_diagn
$LN93@s390_diagn:

; 577  : 
; 578  : #if defined(FEATURE_PROGRAM_DIRECTED_REIPL)
; 579  :         case DIAG308_LOAD_CLEAR:
; 580  :             ipltype = "iplc";
; 581  :             goto diag308_cthread;
; 582  :         case DIAG308_LOAD_NORMAL:
; 583  :             ipltype = "ipl";
; 584  :         diag308_cthread:
; 585  :             rc = create_thread(&tid, DETACHED, stop_cpus_and_ipl, ipltype, "Stop cpus and ipl");
; 586  :             if(rc)
; 587  :                 WRMSG(HHC00102, "E", strerror(rc));
; 588  :             regs->cpustate = CPUSTATE_STOPPING;
; 589  :             ON_IC_INTERRUPT(regs);
; 590  :             break;
; 591  :         case DIAG308_SET:
; 592  :             /* INCOMPLETE */
; 593  :             regs->GR(1) = DIAG308_RC_OK;
; 594  :             break;
; 595  : #endif /*defined(FEATURE_PROGRAM_DIRECTED_REIPL)*/
; 596  : 
; 597  :         case DIAG308_STORE:
; 598  :           {
; 599  :             /*-------------------------------------------------------*/
; 600  :             /* On entry                                              */
; 601  :             /*   Rx    Rx must be an even numbered register          */
; 602  :             /*         containing the real address of a 4K page      */
; 603  :             /*         aligned storage area into which the IPL       */
; 604  :             /*         parameter block will be copied.               */
; 605  :             /* On return                                             */
; 606  :             /*   Rx+1  Contains the return code.                     */
; 607  :             /*-------------------------------------------------------*/
; 608  :             RADR    stgarea;            /* Storage area real address */
; 609  :             U32     headsize;
; 610  :             U32     bodysize;
; 611  :             struct ipl_parameter_block  ipb;
; 612  :             int     lopasize;
; 613  : 
; 614  :             /* Program check if running problem state. */
; 615  :             PRIV_CHECK(regs);

  00846	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0084e	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00852	83 e0 01	 and	 eax, 1
  00855	85 c0		 test	 eax, eax
  00857	74 1b		 je	 SHORT $LN94@s390_diagn
  00859	ba 02 00 00 00	 mov	 edx, 2
  0085e	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00866	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0086e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN94@s390_diagn:

; 616  : 
; 617  :             /* Register Rx contains the real address of the storage area. */
; 618  :             if(regs->psw.amode64) {

  00874	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0087c	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00882	83 e0 01	 and	 eax, 1
  00885	85 c0		 test	 eax, eax
  00887	74 22		 je	 SHORT $LN95@s390_diagn

; 619  :               stgarea = regs->GR_G(r1);

  00889	48 63 84 24 b8
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00891	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00899	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  008a1	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR stgarea$13[rsp], rax

; 620  :             } else {

  008a9	eb 1f		 jmp	 SHORT $LN96@s390_diagn
$LN95@s390_diagn:

; 621  :               stgarea = regs->GR_L(r1);

  008ab	48 63 84 24 b8
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  008b3	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008bb	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  008c2	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR stgarea$13[rsp], rax
$LN96@s390_diagn:

; 622  :             }
; 623  : 
; 624  :             /* Program check if Rx is not an even register number or     */
; 625  :             /* the address contained in Rx is not on a 4K page boundary. */
; 626  :             if (r1 & 1 || stgarea & 0xFFF)

  008ca	8b 84 24 b8 01
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  008d1	83 e0 01	 and	 eax, 1
  008d4	85 c0		 test	 eax, eax
  008d6	75 13		 jne	 SHORT $LN98@s390_diagn
  008d8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR stgarea$13[rsp]
  008e0	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  008e6	48 85 c0	 test	 rax, rax
  008e9	74 12		 je	 SHORT $LN97@s390_diagn
$LN98@s390_diagn:

; 627  :             {
; 628  :                 ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  008eb	ba 06 00 00 00	 mov	 edx, 6
  008f0	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008f8	e8 00 00 00 00	 call	 s390_program_interrupt
$LN97@s390_diagn:

; 629  :             }
; 630  : 
; 631  :             /* Ensure that the 4K storage area is addressable. */
; 632  :             ARCH_DEP(validate_operand) (stgarea, USE_REAL_ADDR, 4095, ACCTYPE_WRITE, regs);

  008fd	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00905	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0090a	41 b9 02 00 00
	00		 mov	 r9d, 2
  00910	41 b8 ff 0f 00
	00		 mov	 r8d, 4095		; 00000fffH
  00916	ba fe ff ff ff	 mov	 edx, -2
  0091b	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR stgarea$13[rsp]
  00922	e8 00 00 00 00	 call	 s390_validate_operand

; 633  : 
; 634  :             /* Prepare the IPL parameter block. */
; 635  :             memset(&ipb, 0, sizeof(ipb));

  00927	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR ipb$17[rsp]
  0092f	48 8b f8	 mov	 rdi, rax
  00932	33 c0		 xor	 eax, eax
  00934	b9 c8 00 00 00	 mov	 ecx, 200		; 000000c8H
  00939	f3 aa		 rep stosb

; 636  :             /* Setup head and body values common to all. */
; 637  :             ipb.hdr.version = IPL_MAX_SUPPORTED_VERSION;

  0093b	c6 84 24 c7 00
	00 00 00	 mov	 BYTE PTR ipb$17[rsp+7], 0

; 638  :             headsize = sizeof(ipb.hdr);

  00943	c7 44 24 78 08
	00 00 00	 mov	 DWORD PTR headsize$10[rsp], 8

; 639  :             memset(ipb.common.loadparm, 0x40, sizeof(ipb.common.loadparm));  /* EBCDIC spaces */

  0094b	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR ipb$17[rsp+16]
  00953	48 8b f8	 mov	 rdi, rax
  00956	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  0095b	b9 08 00 00 00	 mov	 ecx, 8
  00960	f3 aa		 rep stosb

; 640  :             lopasize = strlen(sysblk.loadparm);

  00962	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00969	48 05 38 13 00
	00		 add	 rax, 4920		; 00001338H
  0096f	48 8b c8	 mov	 rcx, rax
  00972	e8 00 00 00 00	 call	 strlen
  00977	89 44 24 74	 mov	 DWORD PTR lopasize$9[rsp], eax

; 641  :             if (lopasize)

  0097b	83 7c 24 74 00	 cmp	 DWORD PTR lopasize$9[rsp], 0
  00980	74 23		 je	 SHORT $LN99@s390_diagn

; 642  :             {
; 643  :                 str_host_to_guest(ipb.common.loadparm, sysblk.loadparm, lopasize);

  00982	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00989	48 05 38 13 00
	00		 add	 rax, 4920		; 00001338H
  0098f	44 8b 44 24 74	 mov	 r8d, DWORD PTR lopasize$9[rsp]
  00994	48 8b d0	 mov	 rdx, rax
  00997	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR ipb$17[rsp+16]
  0099f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_str_host_to_guest
$LN99@s390_diagn:

; 644  :             }
; 645  :             /* Setup head and body values specific to CCW. */
; 646  :             bodysize = sizeof(ipb.ccw);

  009a5	c7 44 24 64 c0
	00 00 00	 mov	 DWORD PTR bodysize$7[rsp], 192 ; 000000c0H

; 647  :             STORE_FW(&ipb.hdr.len, (headsize + bodysize));

  009ad	8b 44 24 64	 mov	 eax, DWORD PTR bodysize$7[rsp]
  009b1	8b 4c 24 78	 mov	 ecx, DWORD PTR headsize$10[rsp]
  009b5	03 c8		 add	 ecx, eax
  009b7	8b c1		 mov	 eax, ecx
  009b9	8b c8		 mov	 ecx, eax
  009bb	e8 00 00 00 00	 call	 _byteswap_ulong
  009c0	8b d0		 mov	 edx, eax
  009c2	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR ipb$17[rsp]
  009ca	e8 00 00 00 00	 call	 store_fw_noswap

; 648  :             STORE_FW(&ipb.ccw.len, bodysize);

  009cf	8b 4c 24 64	 mov	 ecx, DWORD PTR bodysize$7[rsp]
  009d3	e8 00 00 00 00	 call	 _byteswap_ulong
  009d8	8b d0		 mov	 edx, eax
  009da	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR ipb$17[rsp+8]
  009e2	e8 00 00 00 00	 call	 store_fw_noswap

; 649  :             ipb.ccw.pbt = IPL_TYPE_CCW;

  009e7	c6 84 24 cc 00
	00 00 02	 mov	 BYTE PTR ipb$17[rsp+12], 2

; 650  :             STORE_HW(&ipb.ccw.devno, sysblk.ipldev);

  009ef	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  009f6	0f b7 88 f2 00
	00 00		 movzx	 ecx, WORD PTR [rax+242]
  009fd	e8 00 00 00 00	 call	 _byteswap_ushort
  00a02	0f b7 d0	 movzx	 edx, ax
  00a05	48 8d 8c 24 2e
	01 00 00	 lea	 rcx, QWORD PTR ipb$17[rsp+110]
  00a0d	e8 00 00 00 00	 call	 store_hw_noswap

; 651  :             STRLCPY(ipb.ccw.vm_parm, "Hercules");  /* just to show its us! */

  00a12	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00a18	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179963
  00a1f	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR ipb$17[rsp+128]
  00a27	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 652  : 
; 653  :             /* Store the IPL parameter block in real storage */
; 654  :             /* Note: vstorec copies a maximum of 256 bytes.  */
; 655  :             ARCH_DEP(vstorec) (&ipb, (headsize+bodysize-1), stgarea, USE_REAL_ADDR, regs);

  00a2d	8b 44 24 78	 mov	 eax, DWORD PTR headsize$10[rsp]
  00a31	8b 4c 24 64	 mov	 ecx, DWORD PTR bodysize$7[rsp]
  00a35	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00a39	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a41	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00a46	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  00a4c	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR stgarea$13[rsp]
  00a54	0f b6 d0	 movzx	 edx, al
  00a57	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR ipb$17[rsp]
  00a5f	e8 00 00 00 00	 call	 s390_vstorec

; 656  : 
; 657  :             /* Successful */
; 658  :             regs->GR(r1+1) = DIAG308_RC_OK;

  00a64	8b 84 24 b8 01
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  00a6b	ff c0		 inc	 eax
  00a6d	48 98		 cdqe
  00a6f	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a77	c7 84 c1 80 02
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 1

; 659  :             break;

  00a82	eb 12		 jmp	 SHORT $LN18@s390_diagn
$LN100@s390_diagn:

; 660  :           }
; 661  : 
; 662  :         default:
; 663  :             ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00a84	ba 06 00 00 00	 mov	 edx, 6
  00a89	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a91	e8 00 00 00 00	 call	 s390_program_interrupt
$LN18@s390_diagn:

; 664  :         } /* end switch(r3) */
; 665  :         break;

  00a96	e9 04 08 00 00	 jmp	 $LN2@s390_diagn
$LN101@s390_diagn:

; 666  : 
; 667  : #ifdef FEATURE_HERCULES_DIAGCALLS
; 668  :     case 0xF00:
; 669  :     /*---------------------------------------------------------------*/
; 670  :     /* Diagnose F00: Hercules normal mode                            */
; 671  :     /*---------------------------------------------------------------*/
; 672  :         /* If diag8opt is not enabled then we are not allowed
; 673  :          * to manipulate the real machine i.e. hercules itself
; 674  :          */
; 675  :         if(!(sysblk.diag8opt & DIAG8CMD_ENABLE))

  00a9b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00aa2	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  00aa9	83 e0 01	 and	 eax, 1
  00aac	85 c0		 test	 eax, eax
  00aae	75 12		 jne	 SHORT $LN102@s390_diagn

; 676  :             ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00ab0	ba 06 00 00 00	 mov	 edx, 6
  00ab5	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00abd	e8 00 00 00 00	 call	 s390_program_interrupt
$LN102@s390_diagn:

; 677  : 
; 678  :         sysblk.instbreak = 0;

  00ac2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00ac9	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00acf	0f ba f0 0a	 btr	 eax, 10
  00ad3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00ada	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
$LN22@s390_diagn:

; 679  :         SET_IC_TRACE;

  00ae0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00ae7	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  00aee	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR mask$14[rsp], rax
  00af6	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$3[rsp], 0
  00afe	eb 0a		 jmp	 SHORT $LN25@s390_diagn
$LN23@s390_diagn:
  00b00	8b 44 24 50	 mov	 eax, DWORD PTR i$3[rsp]
  00b04	ff c0		 inc	 eax
  00b06	89 44 24 50	 mov	 DWORD PTR i$3[rsp], eax
$LN25@s390_diagn:
  00b0a	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR mask$14[rsp], 0
  00b13	74 58		 je	 SHORT $LN24@s390_diagn
  00b15	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR mask$14[rsp]
  00b1d	48 83 e0 01	 and	 rax, 1
  00b21	48 85 c0	 test	 rax, rax
  00b24	74 32		 je	 SHORT $LN103@s390_diagn
  00b26	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$3[rsp]
  00b2b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00b32	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00b3a	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00b3d	0f ba e8 1f	 bts	 eax, 31
  00b41	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$3[rsp]
  00b46	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00b4d	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00b55	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN103@s390_diagn:
  00b58	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR mask$14[rsp]
  00b60	48 d1 e8	 shr	 rax, 1
  00b63	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR mask$14[rsp], rax
  00b6b	eb 93		 jmp	 SHORT $LN23@s390_diagn
$LN24@s390_diagn:
  00b6d	33 c0		 xor	 eax, eax
  00b6f	85 c0		 test	 eax, eax
  00b71	0f 85 69 ff ff
	ff		 jne	 $LN22@s390_diagn

; 680  :         break;

  00b77	e9 23 07 00 00	 jmp	 $LN2@s390_diagn
$LN104@s390_diagn:

; 681  : 
; 682  :     case 0xF04:
; 683  :     /*---------------------------------------------------------------*/
; 684  :     /* Diagnose F04: Hercules single step mode                       */
; 685  :     /*---------------------------------------------------------------*/
; 686  :         /* If diag8opt is not enabled then we are not allowed
; 687  :          * to manipulate the real machine i.e. hercules itself
; 688  :          */
; 689  :         if(!(sysblk.diag8opt & DIAG8CMD_ENABLE))

  00b7c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b83	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  00b8a	83 e0 01	 and	 eax, 1
  00b8d	85 c0		 test	 eax, eax
  00b8f	75 12		 jne	 SHORT $LN105@s390_diagn

; 690  :             ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00b91	ba 06 00 00 00	 mov	 edx, 6
  00b96	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b9e	e8 00 00 00 00	 call	 s390_program_interrupt
$LN105@s390_diagn:

; 691  : 
; 692  :         sysblk.instbreak = 1;

  00ba3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00baa	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00bb0	0f ba e8 0a	 bts	 eax, 10
  00bb4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00bbb	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
$LN28@s390_diagn:

; 693  :         SET_IC_TRACE;

  00bc1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00bc8	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  00bcf	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR mask$15[rsp], rax
  00bd7	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$4[rsp], 0
  00bdf	eb 0a		 jmp	 SHORT $LN31@s390_diagn
$LN29@s390_diagn:
  00be1	8b 44 24 54	 mov	 eax, DWORD PTR i$4[rsp]
  00be5	ff c0		 inc	 eax
  00be7	89 44 24 54	 mov	 DWORD PTR i$4[rsp], eax
$LN31@s390_diagn:
  00beb	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR mask$15[rsp], 0
  00bf4	74 58		 je	 SHORT $LN30@s390_diagn
  00bf6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR mask$15[rsp]
  00bfe	48 83 e0 01	 and	 rax, 1
  00c02	48 85 c0	 test	 rax, rax
  00c05	74 32		 je	 SHORT $LN106@s390_diagn
  00c07	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$4[rsp]
  00c0c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00c13	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00c1b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00c1e	0f ba e8 1f	 bts	 eax, 31
  00c22	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR i$4[rsp]
  00c27	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00c2e	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00c36	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN106@s390_diagn:
  00c39	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR mask$15[rsp]
  00c41	48 d1 e8	 shr	 rax, 1
  00c44	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR mask$15[rsp], rax
  00c4c	eb 93		 jmp	 SHORT $LN29@s390_diagn
$LN30@s390_diagn:
  00c4e	33 c0		 xor	 eax, eax
  00c50	85 c0		 test	 eax, eax
  00c52	0f 85 69 ff ff
	ff		 jne	 $LN28@s390_diagn

; 694  :         break;

  00c58	e9 42 06 00 00	 jmp	 $LN2@s390_diagn
$LN107@s390_diagn:

; 695  : 
; 696  :     case 0xF08:
; 697  :     /*---------------------------------------------------------------*/
; 698  :     /* Diagnose F08: Return Hercules instruction counter (32)        */
; 699  :     /*---------------------------------------------------------------*/
; 700  :         regs->GR_L( r1 ) = (U32) INSTCOUNT( regs );

  00c5d	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c65	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00c6c	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c74	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00c7b	8b 89 98 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1944]
  00c81	48 03 88 90 07
	00 00		 add	 rcx, QWORD PTR [rax+1936]
  00c88	48 8b c1	 mov	 rax, rcx
  00c8b	48 63 8c 24 b8
	01 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00c93	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00c9b	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 701  :         break;

  00ca2	e9 f8 05 00 00	 jmp	 $LN2@s390_diagn
$LN108@s390_diagn:

; 702  : 
; 703  :     case 0xF09:
; 704  :     /*---------------------------------------------------------------*/
; 705  :     /* Diagnose F09: Return Hercules instruction counter (64)        */
; 706  :     /*---------------------------------------------------------------*/
; 707  :     {
; 708  :         // Operand register r3 bits 32-47 specify the option code and
; 709  :         // bits 48-63 specify the CPU Address for option code 1. For
; 710  :         // option code 0, operand register r3 bits 48-63 are ignored.
; 711  :         // Bits 0-31 of operand register r3 are also always ignored.
; 712  :         // Any option code other than 0 or 1 causes a Specification
; 713  :         // Exception Program Interrupt to occur.
; 714  :         //
; 715  :         // Option 0 = instruction count for entire system (all CPUs
; 716  :         // together). Option 1 = instruction count for specific CPU
; 717  :         // identified in bits 48-63 of r3.
; 718  :         //
; 719  :         // The register and bits that the 64-bit instruction count
; 720  :         // is returned in depends on: 1) whether z/Architecture mode
; 721  :         // is active or not, and 2) whether the specified operand-1
; 722  :         // r1 register number is even or odd.
; 723  :         //
; 724  :         // If operand-1 register r1 is an even numbered register,
; 725  :         // then the high-order bits 0-31 of the 64-bit instruction
; 726  :         // count is returned in bits 32-63 of the even numbered
; 727  :         // register, the low-order bits 32-63 the 64-bit instruction
; 728  :         // count is returned in bits 32-63 of the r1+1 odd numbered
; 729  :         // register and bits 0-31 of each register remain unmodified.
; 730  :         //
; 731  :         // If operand-1 register r1 specifies an odd numbered register
; 732  :         // however, then the 64-bit instruction count is returned in
; 733  :         // bits 0-63 of register r1 in z/Architecture mode, whereas a
; 734  :         // Specification Exception Program Check Interrupt occurs in
; 735  :         // both ESA/390 and System/370 architecture modes as 64-bit
; 736  :         // registers don't exist in either of those architectures.
; 737  :         //
; 738  :         // Precluding a Specification Exception Program Interrupt,
; 739  :         // Condition Code 0 is returned for option 0, whereas for
; 740  :         // option 1, Condition Code 0 is only returned if the CPU
; 741  :         // specified in bits 48-63 of the operand-3 register r3 is
; 742  :         // currently valid and online. Otherwise if the specified
; 743  :         // CPU is offline or does not exist in the configuration,
; 744  :         // Condition Code 3 is returned and the r1 or r1 and r1+1
; 745  :         // return value register(s) is/are not modified.
; 746  : 
; 747  :         U64   instcount=0;                  // Instruction count

  00ca7	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR instcount$12[rsp], 0

; 748  :         U16   opt = regs->GR_LHH( r3 );     // Option code

  00cb3	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00cbb	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00cc3	0f b7 84 c1 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax*8+642]
  00ccb	66 89 44 24 48	 mov	 WORD PTR opt$1[rsp], ax

; 749  : 
; 750  :         if (regs->arch_mode != ARCH_900_IDX)// Not 64-bit architecture?

  00cd0	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cd8	83 78 64 02	 cmp	 DWORD PTR [rax+100], 2
  00cdc	74 29		 je	 SHORT $LN109@s390_diagn

; 751  :             ODD_CHECK( r1, regs );          // 64-bit regs don't exist!

  00cde	8b 84 24 b8 01
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  00ce5	83 e0 01	 and	 eax, 1
  00ce8	85 c0		 test	 eax, eax
  00cea	74 1b		 je	 SHORT $LN110@s390_diagn
  00cec	ba 06 00 00 00	 mov	 edx, 6
  00cf1	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00cf9	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d01	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN110@s390_diagn:
$LN109@s390_diagn:

; 752  : 
; 753  :         if (opt > 1)                        // Unsupported option?

  00d07	0f b7 44 24 48	 movzx	 eax, WORD PTR opt$1[rsp]
  00d0c	83 f8 01	 cmp	 eax, 1
  00d0f	7e 20		 jle	 SHORT $LN111@s390_diagn

; 754  :         {
; 755  :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  00d11	ba 06 00 00 00	 mov	 edx, 6
  00d16	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d1e	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d26	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]

; 756  :         }

  00d2c	e9 e5 00 00 00	 jmp	 $LN112@s390_diagn
$LN111@s390_diagn:

; 757  :         else if (opt == 1)                  // Count for specific CPU?

  00d31	0f b7 44 24 48	 movzx	 eax, WORD PTR opt$1[rsp]
  00d36	83 f8 01	 cmp	 eax, 1
  00d39	0f 85 ac 00 00
	00		 jne	 $LN113@s390_diagn

; 758  :         {
; 759  :             int cpu = regs->GR_LHL( r3 );   // Get desired CPU from r3

  00d3f	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00d47	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d4f	0f b7 84 c1 80
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax*8+640]
  00d57	89 44 24 4c	 mov	 DWORD PTR cpu$2[rsp], eax

; 760  : 
; 761  :             if (cpu < 0 || cpu >= sysblk.maxcpu || !IS_CPU_ONLINE( cpu ))

  00d5b	83 7c 24 4c 00	 cmp	 DWORD PTR cpu$2[rsp], 0
  00d60	7c 2a		 jl	 SHORT $LN116@s390_diagn
  00d62	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00d69	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00d6f	39 44 24 4c	 cmp	 DWORD PTR cpu$2[rsp], eax
  00d73	7d 17		 jge	 SHORT $LN116@s390_diagn
  00d75	48 63 44 24 4c	 movsxd	 rax, DWORD PTR cpu$2[rsp]
  00d7a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00d81	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00d8a	75 11		 jne	 SHORT $LN115@s390_diagn
$LN116@s390_diagn:

; 762  :             {
; 763  :                 regs->psw.cc = 3;           // CPU is invalid/offline

  00d8c	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d94	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 764  :                 break;                      // We are done

  00d98	e9 02 05 00 00	 jmp	 $LN2@s390_diagn
$LN115@s390_diagn:

; 765  :             }
; 766  : 
; 767  :             /* Retrieve the requested CPU's instruction count */
; 768  :             instcount = sysblk.regs[ cpu ]->prevcount  // (U64)

  00d9d	48 63 44 24 4c	 movsxd	 rax, DWORD PTR cpu$2[rsp]
  00da2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00da9	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00db1	48 63 4c 24 4c	 movsxd	 rcx, DWORD PTR cpu$2[rsp]
  00db6	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00dbd	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00dc5	8b 89 98 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1944]
  00dcb	48 03 88 90 07
	00 00		 add	 rcx, QWORD PTR [rax+1936]
  00dd2	48 8b c1	 mov	 rax, rcx
  00dd5	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR instcount$12[rsp], rax

; 769  :                       + sysblk.regs[ cpu ]->instcount; // (U32)
; 770  :             regs->psw.cc = 0;

  00ddd	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00de5	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 771  :         }

  00de9	eb 2b		 jmp	 SHORT $LN114@s390_diagn
$LN113@s390_diagn:

; 772  :         else if (opt == 0)                  // Global system counter?

  00deb	0f b7 44 24 48	 movzx	 eax, WORD PTR opt$1[rsp]
  00df0	85 c0		 test	 eax, eax
  00df2	75 22		 jne	 SHORT $LN117@s390_diagn

; 773  :         {
; 774  :             instcount = sysblk.instcount;   // Get total for ALL CPUs

  00df4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00dfb	48 8b 80 80 14
	00 00		 mov	 rax, QWORD PTR [rax+5248]
  00e02	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR instcount$12[rsp], rax

; 775  :             regs->psw.cc = 0;

  00e0a	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e12	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN117@s390_diagn:
$LN114@s390_diagn:
$LN112@s390_diagn:

; 776  :         }
; 777  : 
; 778  :         /* Return the instruction count in the requested register(s) */
; 779  :         if (r1 & 1)

  00e16	8b 84 24 b8 01
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  00e1d	83 e0 01	 and	 eax, 1
  00e20	85 c0		 test	 eax, eax
  00e22	74 22		 je	 SHORT $LN118@s390_diagn

; 780  :             regs->GR_G( r1 ) = instcount;   // Contiguous 64-bit count

  00e24	48 63 84 24 b8
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00e2c	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e34	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR instcount$12[rsp]
  00e3c	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx
  00e44	eb 59		 jmp	 SHORT $LN119@s390_diagn
$LN118@s390_diagn:

; 781  :         else
; 782  :         {
; 783  :             /* Place the high-order 32 bits of the 64-bit count into
; 784  :                bits 32-63 of the even numbered register and place the
; 785  :                low-order 32 bits of the 64-bit count into bits 32-63
; 786  :                of the r1+1 odd numbered register. For S/370 and S/390
; 787  :                mode this corresponds to bits 0-31 of the register pair
; 788  :                since registers are only 32 bits wide in 370 and 390.
; 789  :             */
; 790  :             regs->GR_L( r1    ) = (U32)((instcount >> 32) & 0xFFFFFFFF);

  00e46	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR instcount$12[rsp]
  00e4e	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00e52	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00e57	48 23 c1	 and	 rax, rcx
  00e5a	48 63 8c 24 b8
	01 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00e62	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00e6a	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 791  :             regs->GR_L( r1 + 1) = (U32)((instcount      ) & 0xFFFFFFFF);

  00e71	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00e76	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR instcount$12[rsp]
  00e7e	48 23 c8	 and	 rcx, rax
  00e81	48 8b c1	 mov	 rax, rcx
  00e84	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  00e8b	ff c1		 inc	 ecx
  00e8d	48 63 c9	 movsxd	 rcx, ecx
  00e90	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00e98	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN119@s390_diagn:

; 792  :         }
; 793  : 
; 794  :         break;

  00e9f	e9 fb 03 00 00	 jmp	 $LN2@s390_diagn
$LN120@s390_diagn:

; 795  :     }
; 796  : 
; 797  :     case 0xF0C:
; 798  :     /*---------------------------------------------------------------*/
; 799  :     /* Diagnose F0C: Set/reset bad frame indicator                   */
; 800  :     /*---------------------------------------------------------------*/
; 801  :         /* If diag8opt is not enabled then we are not allowed
; 802  :          * to manipulate the real machine i.e. hercules itself
; 803  :          */
; 804  :         if(!(sysblk.diag8opt & DIAG8CMD_ENABLE))

  00ea4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00eab	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  00eb2	83 e0 01	 and	 eax, 1
  00eb5	85 c0		 test	 eax, eax
  00eb7	75 12		 jne	 SHORT $LN121@s390_diagn

; 805  :             ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00eb9	ba 06 00 00 00	 mov	 edx, 6
  00ebe	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ec6	e8 00 00 00 00	 call	 s390_program_interrupt
$LN121@s390_diagn:

; 806  : 
; 807  :         /* Load 4K block address from R2 register */
; 808  :         n = regs->GR_L(r3) & ADDRESS_MAXWRAP(regs);

  00ecb	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00ed3	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00edb	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00ee3	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  00ee9	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00ef0	23 c2		 and	 eax, edx
  00ef2	89 44 24 44	 mov	 DWORD PTR n$[rsp], eax

; 809  : 
; 810  :         /* Convert real address to absolute address */
; 811  :         n = APPLY_PREFIXING (n, regs->PX);

  00ef6	8b 44 24 44	 mov	 eax, DWORD PTR n$[rsp]
  00efa	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00f00	48 85 c0	 test	 rax, rax
  00f03	74 24		 je	 SHORT $LN141@s390_diagn
  00f05	8b 44 24 44	 mov	 eax, DWORD PTR n$[rsp]
  00f09	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00f0f	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f17	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00f1a	48 3b c1	 cmp	 rax, rcx
  00f1d	74 0a		 je	 SHORT $LN141@s390_diagn
  00f1f	8b 44 24 44	 mov	 eax, DWORD PTR n$[rsp]
  00f23	89 44 24 7c	 mov	 DWORD PTR tv604[rsp], eax
  00f27	eb 17		 jmp	 SHORT $LN142@s390_diagn
$LN141@s390_diagn:
  00f29	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f31	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00f34	8b 4c 24 44	 mov	 ecx, DWORD PTR n$[rsp]
  00f38	33 c8		 xor	 ecx, eax
  00f3a	8b c1		 mov	 eax, ecx
  00f3c	89 44 24 7c	 mov	 DWORD PTR tv604[rsp], eax
$LN142@s390_diagn:
  00f40	8b 44 24 7c	 mov	 eax, DWORD PTR tv604[rsp]
  00f44	89 44 24 44	 mov	 DWORD PTR n$[rsp], eax

; 812  : 
; 813  :         /* Addressing exception if block is outside main storage */
; 814  :         if ( n > regs->mainlim )

  00f48	8b 44 24 44	 mov	 eax, DWORD PTR n$[rsp]
  00f4c	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f54	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  00f5b	76 17		 jbe	 SHORT $LN122@s390_diagn

; 815  :         {
; 816  :             ARCH_DEP(program_interrupt) (regs, PGM_ADDRESSING_EXCEPTION);

  00f5d	ba 05 00 00 00	 mov	 edx, 5
  00f62	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f6a	e8 00 00 00 00	 call	 s390_program_interrupt

; 817  :             break;

  00f6f	e9 2b 03 00 00	 jmp	 $LN2@s390_diagn
$LN122@s390_diagn:

; 818  :         }
; 819  : 
; 820  :         /* Update bad-frame bit based on low-order bit of R1 register.
; 821  :            Note: we must use the internal "_xxx_storage_key" functions
; 822  :            to directly set/clear the internal STORKEY_BADFRM bit.
; 823  :         */
; 824  :         if (regs->GR_L(r1) & STORKEY_BADFRM)

  00f74	48 63 84 24 b8
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00f7c	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f84	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00f8b	83 e0 01	 and	 eax, 1
  00f8e	85 c0		 test	 eax, eax
  00f90	74 12		 je	 SHORT $LN123@s390_diagn

; 825  :             ARCH_DEP( _or_storage_key )( n, STORKEY_BADFRM, SKEY_K );

  00f92	8b 44 24 44	 mov	 eax, DWORD PTR n$[rsp]
  00f96	41 b0 04	 mov	 r8b, 4
  00f99	b2 01		 mov	 dl, 1
  00f9b	8b c8		 mov	 ecx, eax
  00f9d	e8 00 00 00 00	 call	 s390__or_storage_key
  00fa2	eb 10		 jmp	 SHORT $LN124@s390_diagn
$LN123@s390_diagn:

; 826  :         else
; 827  :             ARCH_DEP( _and_storage_key )( n, STORKEY_BADFRM, SKEY_K );

  00fa4	8b 44 24 44	 mov	 eax, DWORD PTR n$[rsp]
  00fa8	41 b0 04	 mov	 r8b, 4
  00fab	b2 01		 mov	 dl, 1
  00fad	8b c8		 mov	 ecx, eax
  00faf	e8 00 00 00 00	 call	 s390__and_storage_key
$LN124@s390_diagn:

; 828  : 
; 829  :         break;

  00fb4	e9 e6 02 00 00	 jmp	 $LN2@s390_diagn
$LN125@s390_diagn:

; 830  : 
; 831  :     case 0xF10:
; 832  :     /*---------------------------------------------------------------*/
; 833  :     /* Diagnose F10: Hercules CPU stop                               */
; 834  :     /*---------------------------------------------------------------*/
; 835  :         /* If diag8opt is not enabled then we are not allowed
; 836  :          * to manipulate the real machine i.e. hercules itself
; 837  :          */
; 838  :         if(!(sysblk.diag8opt & DIAG8CMD_ENABLE))

  00fb9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00fc0	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  00fc7	83 e0 01	 and	 eax, 1
  00fca	85 c0		 test	 eax, eax
  00fcc	75 12		 jne	 SHORT $LN126@s390_diagn

; 839  :             ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00fce	ba 06 00 00 00	 mov	 edx, 6
  00fd3	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00fdb	e8 00 00 00 00	 call	 s390_program_interrupt
$LN126@s390_diagn:

; 840  : 
; 841  :         regs->cpustate = CPUSTATE_STOPPING;

  00fe0	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00fe8	c6 40 60 02	 mov	 BYTE PTR [rax+96], 2
$LN34@s390_diagn:

; 842  :         ON_IC_INTERRUPT(regs);

  00fec	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ff4	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00ff7	0f ba e8 1f	 bts	 eax, 31
  00ffb	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01003	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  01006	33 c0		 xor	 eax, eax
  01008	85 c0		 test	 eax, eax
  0100a	75 e0		 jne	 SHORT $LN34@s390_diagn

; 843  :         break;

  0100c	e9 8e 02 00 00	 jmp	 $LN2@s390_diagn
$LN127@s390_diagn:

; 844  : 
; 845  : #if defined(_FEATURE_HOST_RESOURCE_ACCESS_FACILITY)
; 846  :     case 0xF18:
; 847  :     /*---------------------------------------------------------------*/
; 848  :     /* Diagnose F18: Hercules Access Host Resource                   */
; 849  :     /*---------------------------------------------------------------*/
; 850  :         ARCH_DEP(diagf18_call) (r1, r3, regs);

  01011	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  01019	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  01020	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  01027	e8 00 00 00 00	 call	 s390_diagf18_call

; 851  :         break;

  0102c	e9 6e 02 00 00	 jmp	 $LN2@s390_diagn
$LN128@s390_diagn:
$LN35@s390_diagn:

; 852  : #endif /* defined(_FEATURE_HOST_RESOURCE_ACCESS_FACILITY) */
; 853  : 
; 854  :     case 0xFF8:
; 855  :     /*---------------------------------------------------------------*/
; 856  :     /* Diagnose FF8: Hercules Infinite Loop (Malfunctioning CPU)     */
; 857  :     /*---------------------------------------------------------------*/
; 858  :         while(1);   /* (loop forever)  */

  01031	33 c0		 xor	 eax, eax
  01033	83 f8 01	 cmp	 eax, 1
  01036	74 02		 je	 SHORT $LN36@s390_diagn
  01038	eb f7		 jmp	 SHORT $LN35@s390_diagn
$LN36@s390_diagn:

; 859  :         break;      /* (never reached) */

  0103a	e9 60 02 00 00	 jmp	 $LN2@s390_diagn
$LN129@s390_diagn:
$LN39@s390_diagn:

; 860  : 
; 861  :     case 0xFFC:
; 862  :     /*---------------------------------------------------------------*/
; 863  :     /* Diagnose FFC: Hercules SLOW Instruction (Malfunctioning CPU)  */
; 864  :     /*---------------------------------------------------------------*/
; 865  :         SLEEP(300); /* (300 seconds = 5 minutes!) */

  0103f	c7 44 24 58 2c
	01 00 00	 mov	 DWORD PTR rc$5[rsp], 300 ; 0000012cH
$LN40@s390_diagn:
  01047	83 7c 24 58 00	 cmp	 DWORD PTR rc$5[rsp], 0
  0104c	74 1d		 je	 SHORT $LN41@s390_diagn
  0104e	8b 4c 24 58	 mov	 ecx, DWORD PTR rc$5[rsp]
  01052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sleep
  01058	89 44 24 58	 mov	 DWORD PTR rc$5[rsp], eax
  0105c	83 7c 24 58 00	 cmp	 DWORD PTR rc$5[rsp], 0
  01061	74 06		 je	 SHORT $LN130@s390_diagn
  01063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield
$LN130@s390_diagn:
  01069	eb dc		 jmp	 SHORT $LN40@s390_diagn
$LN41@s390_diagn:
  0106b	33 c0		 xor	 eax, eax
  0106d	85 c0		 test	 eax, eax
  0106f	75 ce		 jne	 SHORT $LN39@s390_diagn

; 866  :         break;

  01071	e9 29 02 00 00	 jmp	 $LN2@s390_diagn
$LN131@s390_diagn:

; 867  : 
; 868  :     case 0xFFD:
; 869  :     /*---------------------------------------------------------------*/
; 870  :     /* Diagnose FFD: Hercules Dummy "Slow(?)" Instruction            */
; 871  :     /*---------------------------------------------------------------*/
; 872  :     {
; 873  :         /* r1 = microseconds */
; 874  :         unsigned int secs  = regs->GR_L(r1) / ONE_MILLION;

  01076	48 63 84 24 b8
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0107e	33 d2		 xor	 edx, edx
  01080	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01088	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0108f	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  01094	f7 f1		 div	 ecx
  01096	89 84 24 a8 00
	00 00		 mov	 DWORD PTR secs$16[rsp], eax

; 875  :         unsigned int usecs = regs->GR_L(r1) % ONE_MILLION;

  0109d	48 63 84 24 b8
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  010a5	33 d2		 xor	 edx, edx
  010a7	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  010af	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  010b6	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  010bb	f7 f1		 div	 ecx
  010bd	8b c2		 mov	 eax, edx
  010bf	89 84 24 80 00
	00 00		 mov	 DWORD PTR usecs$11[rsp], eax

; 876  :         unsigned int i;
; 877  :         for (i=0; i < secs; ++i)

  010c6	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$8[rsp], 0
  010ce	eb 0a		 jmp	 SHORT $LN44@s390_diagn
$LN42@s390_diagn:
  010d0	8b 44 24 68	 mov	 eax, DWORD PTR i$8[rsp]
  010d4	ff c0		 inc	 eax
  010d6	89 44 24 68	 mov	 DWORD PTR i$8[rsp], eax
$LN44@s390_diagn:
  010da	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR secs$16[rsp]
  010e1	39 44 24 68	 cmp	 DWORD PTR i$8[rsp], eax
  010e5	73 34		 jae	 SHORT $LN43@s390_diagn
$LN47@s390_diagn:

; 878  :             SLEEP(1);       /* (sleep one second at a time) */

  010e7	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR rc$6[rsp], 1
$LN48@s390_diagn:
  010ef	83 7c 24 5c 00	 cmp	 DWORD PTR rc$6[rsp], 0
  010f4	74 1d		 je	 SHORT $LN49@s390_diagn
  010f6	8b 4c 24 5c	 mov	 ecx, DWORD PTR rc$6[rsp]
  010fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sleep
  01100	89 44 24 5c	 mov	 DWORD PTR rc$6[rsp], eax
  01104	83 7c 24 5c 00	 cmp	 DWORD PTR rc$6[rsp], 0
  01109	74 06		 je	 SHORT $LN132@s390_diagn
  0110b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield
$LN132@s390_diagn:
  01111	eb dc		 jmp	 SHORT $LN48@s390_diagn
$LN49@s390_diagn:
  01113	33 c0		 xor	 eax, eax
  01115	85 c0		 test	 eax, eax
  01117	75 ce		 jne	 SHORT $LN47@s390_diagn
  01119	eb b5		 jmp	 SHORT $LN42@s390_diagn
$LN43@s390_diagn:

; 879  :         if (usecs)

  0111b	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR usecs$11[rsp], 0
  01123	74 0d		 je	 SHORT $LN133@s390_diagn

; 880  :             usleep(usecs);  /* (remaining microseconds, if any) */

  01125	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR usecs$11[rsp]
  0112c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN133@s390_diagn:

; 881  :         break;

  01132	e9 68 01 00 00	 jmp	 $LN2@s390_diagn
$LN134@s390_diagn:

; 882  :     }
; 883  : 
; 884  : #endif /*FEATURE_HERCULES_DIAGCALLS*/
; 885  : 
; 886  :     default:
; 887  :     /*---------------------------------------------------------------*/
; 888  :     /* Diagnose xxx: Invalid function code or Power-Off diagnose     */
; 889  :     /*---------------------------------------------------------------*/
; 890  : 
; 891  :         if( HDC4(debug_diagnose, code, r1, r3, regs) )

  01137	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_diagnose
  0113e	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  01142	74 2e		 je	 SHORT $LN143@s390_diagn
  01144	4c 8b 8c 24 b0
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0114c	44 8b 84 24 c0
	01 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  01154	8b 94 24 b8 01
	00 00		 mov	 edx, DWORD PTR r1$[rsp]
  0115b	8b 4c 24 60	 mov	 ecx, DWORD PTR code$[rsp]
  0115f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_diagnose
  01166	ff 10		 call	 QWORD PTR [rax]
  01168	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv704[rsp], rax
  01170	eb 0c		 jmp	 SHORT $LN144@s390_diagn
$LN143@s390_diagn:
  01172	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv704[rsp], 0
$LN144@s390_diagn:
  0117e	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR tv704[rsp], 0
  01187	74 05		 je	 SHORT $LN135@s390_diagn

; 892  :             return;

  01189	e9 11 01 00 00	 jmp	 $LN1@s390_diagn
$LN135@s390_diagn:

; 893  : 
; 894  :         /* Power Off diagnose on 4361, 9371, 9373, 9375, 9377, 9221: */
; 895  :         /*                                                           */
; 896  :         /*          DS 0H                                            */
; 897  :         /*          DC X'8302',S(SHUTDATA)     MUST BE R0 AND R2     */
; 898  :         /*          ...                                              */
; 899  :         /*          DS 0H                                            */
; 900  :         /* SHUTDATA DC X'0000FFFF'             MUST BE X'0000FFFF'   */
; 901  : 
; 902  :         if (0 == r1 && 2 == r3
; 903  :              && sysblk.cpuversion != 0xFF
; 904  :              && (sysblk.cpumodel == 0x4361

  0118e	83 bc 24 b8 01
	00 00 00	 cmp	 DWORD PTR r1$[rsp], 0
  01196	0f 85 f1 00 00
	00		 jne	 $LN136@s390_diagn
  0119c	83 bc 24 c0 01
	00 00 02	 cmp	 DWORD PTR r3$[rsp], 2
  011a4	0f 85 e3 00 00
	00		 jne	 $LN136@s390_diagn
  011aa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  011b1	0f b6 80 d6 00
	00 00		 movzx	 eax, BYTE PTR [rax+214]
  011b8	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  011bd	0f 84 ca 00 00
	00		 je	 $LN136@s390_diagn
  011c3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  011ca	0f b7 80 d4 00
	00 00		 movzx	 eax, WORD PTR [rax+212]
  011d1	3d 61 43 00 00	 cmp	 eax, 17249		; 00004361H
  011d6	74 33		 je	 SHORT $LN137@s390_diagn
  011d8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  011df	0f b7 80 d4 00
	00 00		 movzx	 eax, WORD PTR [rax+212]
  011e6	25 f9 ff 00 00	 and	 eax, 65529		; 0000fff9H
  011eb	3d 71 93 00 00	 cmp	 eax, 37745		; 00009371H
  011f0	74 19		 je	 SHORT $LN137@s390_diagn
  011f2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  011f9	0f b7 80 d4 00
	00 00		 movzx	 eax, WORD PTR [rax+212]
  01200	3d 21 92 00 00	 cmp	 eax, 37409		; 00009221H
  01205	0f 85 82 00 00
	00		 jne	 $LN136@s390_diagn
$LN137@s390_diagn:

; 905  :               || (sysblk.cpumodel & 0xFFF9) == 0x9371   /* (937X) */
; 906  :               || sysblk.cpumodel == 0x9221)
; 907  :            )
; 908  :         {
; 909  :             if (0x0000FFFF == ARCH_DEP(vfetch4)(effective_addr2, b2, regs))

  0120b	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  01213	8b 94 24 c8 01
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  0121a	8b 8c 24 d0 01
	00 00		 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  01221	e8 00 00 00 00	 call	 s390_vfetch4
  01226	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  0122b	75 60		 jne	 SHORT $LN138@s390_diagn

; 910  :             {
; 911  :                 /* If diag8opt is not enabled then we are not allowed
; 912  :                  * to manipulate the real machine i.e. hercules itself
; 913  :                  */
; 914  :                 if(!(sysblk.diag8opt & DIAG8CMD_ENABLE))

  0122d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01234	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  0123b	83 e0 01	 and	 eax, 1
  0123e	85 c0		 test	 eax, eax
  01240	75 12		 jne	 SHORT $LN139@s390_diagn

; 915  :                     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  01242	ba 06 00 00 00	 mov	 edx, 6
  01247	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0124f	e8 00 00 00 00	 call	 s390_program_interrupt
$LN139@s390_diagn:

; 916  : 
; 917  :                 regs->cpustate = CPUSTATE_STOPPING;

  01254	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0125c	c6 40 60 02	 mov	 BYTE PTR [rax+96], 2
$LN52@s390_diagn:

; 918  :                 ON_IC_INTERRUPT(regs);

  01260	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01268	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0126b	0f ba e8 1f	 bts	 eax, 31
  0126f	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01277	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  0127a	33 c0		 xor	 eax, eax
  0127c	85 c0		 test	 eax, eax
  0127e	75 e0		 jne	 SHORT $LN52@s390_diagn

; 919  : 
; 920  :                 /* Release the configuration */
; 921  :                 do_shutdown();

  01280	e8 00 00 00 00	 call	 do_shutdown

; 922  : 
; 923  :                 /* Power Off: exit hercules */
; 924  :                 exit(0);

  01285	33 c9		 xor	 ecx, ecx
  01287	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN138@s390_diagn:
$LN136@s390_diagn:

; 925  :             }
; 926  :         }
; 927  : 
; 928  : #if defined(FEATURE_S370_CHANNEL) && defined(OPTION_NOP_MODEL158_DIAGNOSE)
; 929  :         if (regs->cpumodel != 0x0158)
; 930  : #endif
; 931  :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0128d	ba 06 00 00 00	 mov	 edx, 6
  01292	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0129a	e8 00 00 00 00	 call	 s390_program_interrupt
$LN2@s390_diagn:
$LN1@s390_diagn:
$LN140@s390_diagn:

; 932  :         return;
; 933  : 
; 934  :     } /* end switch(code) */
; 935  : 
; 936  :     return;
; 937  : 
; 938  : } /* end function diagnose_call */

  0129f	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  012a7	48 33 cc	 xor	 rcx, rsp
  012aa	e8 00 00 00 00	 call	 __security_check_cookie
  012af	48 81 c4 a0 01
	00 00		 add	 rsp, 416		; 000001a0H
  012b6	5f		 pop	 rdi
  012b7	c3		 ret	 0
$LN152@s390_diagn:
  012b8	00 00 00 00	 DD	 $LN63@s390_diagn
  012bc	00 00 00 00	 DD	 $LN53@s390_diagn
  012c0	00 00 00 00	 DD	 $LN64@s390_diagn
  012c4	00 00 00 00	 DD	 $LN66@s390_diagn
  012c8	00 00 00 00	 DD	 $LN54@s390_diagn
  012cc	00 00 00 00	 DD	 $LN67@s390_diagn
  012d0	00 00 00 00	 DD	 $LN58@s390_diagn
  012d4	00 00 00 00	 DD	 $LN68@s390_diagn
  012d8	00 00 00 00	 DD	 $LN69@s390_diagn
  012dc	00 00 00 00	 DD	 $LN70@s390_diagn
  012e0	00 00 00 00	 DD	 $LN59@s390_diagn
  012e4	00 00 00 00	 DD	 $LN60@s390_diagn
  012e8	00 00 00 00	 DD	 $LN71@s390_diagn
  012ec	00 00 00 00	 DD	 $LN72@s390_diagn
  012f0	00 00 00 00	 DD	 $LN73@s390_diagn
  012f4	00 00 00 00	 DD	 $LN74@s390_diagn
  012f8	00 00 00 00	 DD	 $LN134@s390_diagn
$LN151@s390_diagn:
  012fc	00		 DB	 0
  012fd	10		 DB	 16
  012fe	01		 DB	 1
  012ff	10		 DB	 16
  01300	10		 DB	 16
  01301	10		 DB	 16
  01302	10		 DB	 16
  01303	10		 DB	 16
  01304	02		 DB	 2
  01305	10		 DB	 16
  01306	10		 DB	 16
  01307	10		 DB	 16
  01308	03		 DB	 3
  01309	10		 DB	 16
  0130a	10		 DB	 16
  0130b	10		 DB	 16
  0130c	10		 DB	 16
  0130d	10		 DB	 16
  0130e	10		 DB	 16
  0130f	10		 DB	 16
  01310	10		 DB	 16
  01311	10		 DB	 16
  01312	10		 DB	 16
  01313	10		 DB	 16
  01314	10		 DB	 16
  01315	10		 DB	 16
  01316	10		 DB	 16
  01317	10		 DB	 16
  01318	10		 DB	 16
  01319	10		 DB	 16
  0131a	10		 DB	 16
  0131b	04		 DB	 4
  0131c	10		 DB	 16
  0131d	10		 DB	 16
  0131e	10		 DB	 16
  0131f	10		 DB	 16
  01320	05		 DB	 5
  01321	10		 DB	 16
  01322	10		 DB	 16
  01323	10		 DB	 16
  01324	10		 DB	 16
  01325	10		 DB	 16
  01326	10		 DB	 16
  01327	10		 DB	 16
  01328	10		 DB	 16
  01329	10		 DB	 16
  0132a	10		 DB	 16
  0132b	10		 DB	 16
  0132c	10		 DB	 16
  0132d	10		 DB	 16
  0132e	10		 DB	 16
  0132f	10		 DB	 16
  01330	10		 DB	 16
  01331	10		 DB	 16
  01332	10		 DB	 16
  01333	10		 DB	 16
  01334	10		 DB	 16
  01335	10		 DB	 16
  01336	10		 DB	 16
  01337	10		 DB	 16
  01338	10		 DB	 16
  01339	10		 DB	 16
  0133a	10		 DB	 16
  0133b	10		 DB	 16
  0133c	10		 DB	 16
  0133d	10		 DB	 16
  0133e	10		 DB	 16
  0133f	10		 DB	 16
  01340	06		 DB	 6
  01341	10		 DB	 16
  01342	10		 DB	 16
  01343	10		 DB	 16
  01344	10		 DB	 16
  01345	10		 DB	 16
  01346	10		 DB	 16
  01347	10		 DB	 16
  01348	10		 DB	 16
  01349	10		 DB	 16
  0134a	10		 DB	 16
  0134b	10		 DB	 16
  0134c	10		 DB	 16
  0134d	10		 DB	 16
  0134e	10		 DB	 16
  0134f	10		 DB	 16
  01350	10		 DB	 16
  01351	10		 DB	 16
  01352	10		 DB	 16
  01353	10		 DB	 16
  01354	10		 DB	 16
  01355	10		 DB	 16
  01356	10		 DB	 16
  01357	10		 DB	 16
  01358	07		 DB	 7
  01359	10		 DB	 16
  0135a	10		 DB	 16
  0135b	10		 DB	 16
  0135c	08		 DB	 8
  0135d	10		 DB	 16
  0135e	10		 DB	 16
  0135f	10		 DB	 16
  01360	09		 DB	 9
  01361	10		 DB	 16
  01362	10		 DB	 16
  01363	10		 DB	 16
  01364	10		 DB	 16
  01365	10		 DB	 16
  01366	10		 DB	 16
  01367	10		 DB	 16
  01368	10		 DB	 16
  01369	10		 DB	 16
  0136a	10		 DB	 16
  0136b	10		 DB	 16
  0136c	10		 DB	 16
  0136d	10		 DB	 16
  0136e	10		 DB	 16
  0136f	10		 DB	 16
  01370	10		 DB	 16
  01371	10		 DB	 16
  01372	10		 DB	 16
  01373	10		 DB	 16
  01374	10		 DB	 16
  01375	10		 DB	 16
  01376	10		 DB	 16
  01377	10		 DB	 16
  01378	10		 DB	 16
  01379	10		 DB	 16
  0137a	10		 DB	 16
  0137b	10		 DB	 16
  0137c	0a		 DB	 10
  0137d	10		 DB	 16
  0137e	10		 DB	 16
  0137f	10		 DB	 16
  01380	10		 DB	 16
  01381	10		 DB	 16
  01382	10		 DB	 16
  01383	10		 DB	 16
  01384	10		 DB	 16
  01385	10		 DB	 16
  01386	10		 DB	 16
  01387	10		 DB	 16
  01388	10		 DB	 16
  01389	10		 DB	 16
  0138a	10		 DB	 16
  0138b	10		 DB	 16
  0138c	10		 DB	 16
  0138d	10		 DB	 16
  0138e	10		 DB	 16
  0138f	10		 DB	 16
  01390	10		 DB	 16
  01391	10		 DB	 16
  01392	10		 DB	 16
  01393	10		 DB	 16
  01394	10		 DB	 16
  01395	10		 DB	 16
  01396	10		 DB	 16
  01397	10		 DB	 16
  01398	0b		 DB	 11
  01399	10		 DB	 16
  0139a	10		 DB	 16
  0139b	10		 DB	 16
  0139c	10		 DB	 16
  0139d	10		 DB	 16
  0139e	10		 DB	 16
  0139f	10		 DB	 16
  013a0	0c		 DB	 12
  013a1	10		 DB	 16
  013a2	10		 DB	 16
  013a3	10		 DB	 16
  013a4	0d		 DB	 13
  013a5	10		 DB	 16
  013a6	10		 DB	 16
  013a7	10		 DB	 16
  013a8	10		 DB	 16
  013a9	10		 DB	 16
  013aa	10		 DB	 16
  013ab	10		 DB	 16
  013ac	0e		 DB	 14
  013ad	10		 DB	 16
  013ae	10		 DB	 16
  013af	10		 DB	 16
  013b0	10		 DB	 16
  013b1	10		 DB	 16
  013b2	10		 DB	 16
  013b3	10		 DB	 16
  013b4	10		 DB	 16
  013b5	10		 DB	 16
  013b6	10		 DB	 16
  013b7	10		 DB	 16
  013b8	10		 DB	 16
  013b9	10		 DB	 16
  013ba	10		 DB	 16
  013bb	10		 DB	 16
  013bc	10		 DB	 16
  013bd	10		 DB	 16
  013be	10		 DB	 16
  013bf	10		 DB	 16
  013c0	10		 DB	 16
  013c1	10		 DB	 16
  013c2	10		 DB	 16
  013c3	10		 DB	 16
  013c4	10		 DB	 16
  013c5	10		 DB	 16
  013c6	10		 DB	 16
  013c7	10		 DB	 16
  013c8	10		 DB	 16
  013c9	10		 DB	 16
  013ca	10		 DB	 16
  013cb	10		 DB	 16
  013cc	10		 DB	 16
  013cd	10		 DB	 16
  013ce	10		 DB	 16
  013cf	10		 DB	 16
  013d0	10		 DB	 16
  013d1	10		 DB	 16
  013d2	10		 DB	 16
  013d3	10		 DB	 16
  013d4	10		 DB	 16
  013d5	10		 DB	 16
  013d6	10		 DB	 16
  013d7	10		 DB	 16
  013d8	0f		 DB	 15
  013d9	0f 1f 00	 npad	 3
$LN150@s390_diagn:
  013dc	00 00 00 00	 DD	 $LN75@s390_diagn
  013e0	00 00 00 00	 DD	 $LN76@s390_diagn
  013e4	00 00 00 00	 DD	 $LN77@s390_diagn
  013e8	00 00 00 00	 DD	 $LN62@s390_diagn
  013ec	00 00 00 00	 DD	 $LN82@s390_diagn
  013f0	00 00 00 00	 DD	 $LN83@s390_diagn
  013f4	00 00 00 00	 DD	 $LN84@s390_diagn
  013f8	00 00 00 00	 DD	 $LN85@s390_diagn
  013fc	00 00 00 00	 DD	 $LN87@s390_diagn
  01400	00 00 00 00	 DD	 $LN88@s390_diagn
  01404	00 00 00 00	 DD	 $LN90@s390_diagn
  01408	00 00 00 00	 DD	 $LN134@s390_diagn
$LN149@s390_diagn:
  0140c	00		 DB	 0
  0140d	0b		 DB	 11
  0140e	0b		 DB	 11
  0140f	0b		 DB	 11
  01410	01		 DB	 1
  01411	0b		 DB	 11
  01412	0b		 DB	 11
  01413	0b		 DB	 11
  01414	0b		 DB	 11
  01415	0b		 DB	 11
  01416	0b		 DB	 11
  01417	0b		 DB	 11
  01418	0b		 DB	 11
  01419	0b		 DB	 11
  0141a	0b		 DB	 11
  0141b	0b		 DB	 11
  0141c	02		 DB	 2
  0141d	0b		 DB	 11
  0141e	0b		 DB	 11
  0141f	0b		 DB	 11
  01420	03		 DB	 3
  01421	0b		 DB	 11
  01422	0b		 DB	 11
  01423	0b		 DB	 11
  01424	0b		 DB	 11
  01425	0b		 DB	 11
  01426	0b		 DB	 11
  01427	0b		 DB	 11
  01428	0b		 DB	 11
  01429	0b		 DB	 11
  0142a	0b		 DB	 11
  0142b	0b		 DB	 11
  0142c	0b		 DB	 11
  0142d	0b		 DB	 11
  0142e	0b		 DB	 11
  0142f	0b		 DB	 11
  01430	0b		 DB	 11
  01431	0b		 DB	 11
  01432	0b		 DB	 11
  01433	0b		 DB	 11
  01434	0b		 DB	 11
  01435	0b		 DB	 11
  01436	0b		 DB	 11
  01437	0b		 DB	 11
  01438	04		 DB	 4
  01439	0b		 DB	 11
  0143a	0b		 DB	 11
  0143b	0b		 DB	 11
  0143c	0b		 DB	 11
  0143d	0b		 DB	 11
  0143e	0b		 DB	 11
  0143f	0b		 DB	 11
  01440	0b		 DB	 11
  01441	0b		 DB	 11
  01442	0b		 DB	 11
  01443	0b		 DB	 11
  01444	0b		 DB	 11
  01445	0b		 DB	 11
  01446	0b		 DB	 11
  01447	0b		 DB	 11
  01448	0b		 DB	 11
  01449	0b		 DB	 11
  0144a	0b		 DB	 11
  0144b	0b		 DB	 11
  0144c	05		 DB	 5
  0144d	0b		 DB	 11
  0144e	0b		 DB	 11
  0144f	0b		 DB	 11
  01450	0b		 DB	 11
  01451	0b		 DB	 11
  01452	0b		 DB	 11
  01453	0b		 DB	 11
  01454	0b		 DB	 11
  01455	0b		 DB	 11
  01456	0b		 DB	 11
  01457	0b		 DB	 11
  01458	0b		 DB	 11
  01459	0b		 DB	 11
  0145a	0b		 DB	 11
  0145b	0b		 DB	 11
  0145c	06		 DB	 6
  0145d	0b		 DB	 11
  0145e	0b		 DB	 11
  0145f	0b		 DB	 11
  01460	07		 DB	 7
  01461	0b		 DB	 11
  01462	0b		 DB	 11
  01463	0b		 DB	 11
  01464	0b		 DB	 11
  01465	0b		 DB	 11
  01466	0b		 DB	 11
  01467	0b		 DB	 11
  01468	0b		 DB	 11
  01469	0b		 DB	 11
  0146a	0b		 DB	 11
  0146b	0b		 DB	 11
  0146c	08		 DB	 8
  0146d	0b		 DB	 11
  0146e	0b		 DB	 11
  0146f	0b		 DB	 11
  01470	09		 DB	 9
  01471	0b		 DB	 11
  01472	0b		 DB	 11
  01473	0b		 DB	 11
  01474	0b		 DB	 11
  01475	0b		 DB	 11
  01476	0b		 DB	 11
  01477	0b		 DB	 11
  01478	0b		 DB	 11
  01479	0b		 DB	 11
  0147a	0b		 DB	 11
  0147b	0b		 DB	 11
  0147c	0b		 DB	 11
  0147d	0b		 DB	 11
  0147e	0b		 DB	 11
  0147f	0b		 DB	 11
  01480	0b		 DB	 11
  01481	0b		 DB	 11
  01482	0b		 DB	 11
  01483	0b		 DB	 11
  01484	0b		 DB	 11
  01485	0b		 DB	 11
  01486	0b		 DB	 11
  01487	0b		 DB	 11
  01488	0b		 DB	 11
  01489	0b		 DB	 11
  0148a	0b		 DB	 11
  0148b	0b		 DB	 11
  0148c	0b		 DB	 11
  0148d	0b		 DB	 11
  0148e	0b		 DB	 11
  0148f	0b		 DB	 11
  01490	0b		 DB	 11
  01491	0b		 DB	 11
  01492	0b		 DB	 11
  01493	0b		 DB	 11
  01494	0b		 DB	 11
  01495	0b		 DB	 11
  01496	0b		 DB	 11
  01497	0b		 DB	 11
  01498	0b		 DB	 11
  01499	0b		 DB	 11
  0149a	0b		 DB	 11
  0149b	0b		 DB	 11
  0149c	0b		 DB	 11
  0149d	0b		 DB	 11
  0149e	0b		 DB	 11
  0149f	0b		 DB	 11
  014a0	0b		 DB	 11
  014a1	0b		 DB	 11
  014a2	0b		 DB	 11
  014a3	0b		 DB	 11
  014a4	0b		 DB	 11
  014a5	0b		 DB	 11
  014a6	0b		 DB	 11
  014a7	0b		 DB	 11
  014a8	0b		 DB	 11
  014a9	0b		 DB	 11
  014aa	0b		 DB	 11
  014ab	0b		 DB	 11
  014ac	0b		 DB	 11
  014ad	0b		 DB	 11
  014ae	0b		 DB	 11
  014af	0b		 DB	 11
  014b0	0b		 DB	 11
  014b1	0b		 DB	 11
  014b2	0b		 DB	 11
  014b3	0b		 DB	 11
  014b4	0b		 DB	 11
  014b5	0b		 DB	 11
  014b6	0b		 DB	 11
  014b7	0b		 DB	 11
  014b8	0b		 DB	 11
  014b9	0b		 DB	 11
  014ba	0b		 DB	 11
  014bb	0b		 DB	 11
  014bc	0b		 DB	 11
  014bd	0b		 DB	 11
  014be	0b		 DB	 11
  014bf	0b		 DB	 11
  014c0	0b		 DB	 11
  014c1	0b		 DB	 11
  014c2	0b		 DB	 11
  014c3	0b		 DB	 11
  014c4	0b		 DB	 11
  014c5	0b		 DB	 11
  014c6	0b		 DB	 11
  014c7	0b		 DB	 11
  014c8	0b		 DB	 11
  014c9	0b		 DB	 11
  014ca	0b		 DB	 11
  014cb	0b		 DB	 11
  014cc	0b		 DB	 11
  014cd	0b		 DB	 11
  014ce	0b		 DB	 11
  014cf	0b		 DB	 11
  014d0	0b		 DB	 11
  014d1	0b		 DB	 11
  014d2	0b		 DB	 11
  014d3	0b		 DB	 11
  014d4	0b		 DB	 11
  014d5	0b		 DB	 11
  014d6	0b		 DB	 11
  014d7	0b		 DB	 11
  014d8	0b		 DB	 11
  014d9	0b		 DB	 11
  014da	0b		 DB	 11
  014db	0b		 DB	 11
  014dc	0b		 DB	 11
  014dd	0b		 DB	 11
  014de	0b		 DB	 11
  014df	0b		 DB	 11
  014e0	0b		 DB	 11
  014e1	0b		 DB	 11
  014e2	0b		 DB	 11
  014e3	0b		 DB	 11
  014e4	0b		 DB	 11
  014e5	0b		 DB	 11
  014e6	0b		 DB	 11
  014e7	0b		 DB	 11
  014e8	0b		 DB	 11
  014e9	0b		 DB	 11
  014ea	0b		 DB	 11
  014eb	0b		 DB	 11
  014ec	0b		 DB	 11
  014ed	0b		 DB	 11
  014ee	0b		 DB	 11
  014ef	0b		 DB	 11
  014f0	0b		 DB	 11
  014f1	0b		 DB	 11
  014f2	0b		 DB	 11
  014f3	0b		 DB	 11
  014f4	0b		 DB	 11
  014f5	0b		 DB	 11
  014f6	0b		 DB	 11
  014f7	0b		 DB	 11
  014f8	0b		 DB	 11
  014f9	0b		 DB	 11
  014fa	0b		 DB	 11
  014fb	0b		 DB	 11
  014fc	0b		 DB	 11
  014fd	0b		 DB	 11
  014fe	0b		 DB	 11
  014ff	0b		 DB	 11
  01500	0b		 DB	 11
  01501	0b		 DB	 11
  01502	0b		 DB	 11
  01503	0b		 DB	 11
  01504	0a		 DB	 10
  01505	0f 1f 00	 npad	 3
$LN148@s390_diagn:
  01508	00 00 00 00	 DD	 $LN104@s390_diagn
  0150c	00 00 00 00	 DD	 $LN107@s390_diagn
  01510	00 00 00 00	 DD	 $LN108@s390_diagn
  01514	00 00 00 00	 DD	 $LN120@s390_diagn
  01518	00 00 00 00	 DD	 $LN125@s390_diagn
  0151c	00 00 00 00	 DD	 $LN127@s390_diagn
  01520	00 00 00 00	 DD	 $LN128@s390_diagn
  01524	00 00 00 00	 DD	 $LN129@s390_diagn
  01528	00 00 00 00	 DD	 $LN131@s390_diagn
  0152c	00 00 00 00	 DD	 $LN134@s390_diagn
$LN147@s390_diagn:
  01530	00		 DB	 0
  01531	09		 DB	 9
  01532	09		 DB	 9
  01533	09		 DB	 9
  01534	01		 DB	 1
  01535	02		 DB	 2
  01536	09		 DB	 9
  01537	09		 DB	 9
  01538	03		 DB	 3
  01539	09		 DB	 9
  0153a	09		 DB	 9
  0153b	09		 DB	 9
  0153c	04		 DB	 4
  0153d	09		 DB	 9
  0153e	09		 DB	 9
  0153f	09		 DB	 9
  01540	09		 DB	 9
  01541	09		 DB	 9
  01542	09		 DB	 9
  01543	09		 DB	 9
  01544	05		 DB	 5
  01545	09		 DB	 9
  01546	09		 DB	 9
  01547	09		 DB	 9
  01548	09		 DB	 9
  01549	09		 DB	 9
  0154a	09		 DB	 9
  0154b	09		 DB	 9
  0154c	09		 DB	 9
  0154d	09		 DB	 9
  0154e	09		 DB	 9
  0154f	09		 DB	 9
  01550	09		 DB	 9
  01551	09		 DB	 9
  01552	09		 DB	 9
  01553	09		 DB	 9
  01554	09		 DB	 9
  01555	09		 DB	 9
  01556	09		 DB	 9
  01557	09		 DB	 9
  01558	09		 DB	 9
  01559	09		 DB	 9
  0155a	09		 DB	 9
  0155b	09		 DB	 9
  0155c	09		 DB	 9
  0155d	09		 DB	 9
  0155e	09		 DB	 9
  0155f	09		 DB	 9
  01560	09		 DB	 9
  01561	09		 DB	 9
  01562	09		 DB	 9
  01563	09		 DB	 9
  01564	09		 DB	 9
  01565	09		 DB	 9
  01566	09		 DB	 9
  01567	09		 DB	 9
  01568	09		 DB	 9
  01569	09		 DB	 9
  0156a	09		 DB	 9
  0156b	09		 DB	 9
  0156c	09		 DB	 9
  0156d	09		 DB	 9
  0156e	09		 DB	 9
  0156f	09		 DB	 9
  01570	09		 DB	 9
  01571	09		 DB	 9
  01572	09		 DB	 9
  01573	09		 DB	 9
  01574	09		 DB	 9
  01575	09		 DB	 9
  01576	09		 DB	 9
  01577	09		 DB	 9
  01578	09		 DB	 9
  01579	09		 DB	 9
  0157a	09		 DB	 9
  0157b	09		 DB	 9
  0157c	09		 DB	 9
  0157d	09		 DB	 9
  0157e	09		 DB	 9
  0157f	09		 DB	 9
  01580	09		 DB	 9
  01581	09		 DB	 9
  01582	09		 DB	 9
  01583	09		 DB	 9
  01584	09		 DB	 9
  01585	09		 DB	 9
  01586	09		 DB	 9
  01587	09		 DB	 9
  01588	09		 DB	 9
  01589	09		 DB	 9
  0158a	09		 DB	 9
  0158b	09		 DB	 9
  0158c	09		 DB	 9
  0158d	09		 DB	 9
  0158e	09		 DB	 9
  0158f	09		 DB	 9
  01590	09		 DB	 9
  01591	09		 DB	 9
  01592	09		 DB	 9
  01593	09		 DB	 9
  01594	09		 DB	 9
  01595	09		 DB	 9
  01596	09		 DB	 9
  01597	09		 DB	 9
  01598	09		 DB	 9
  01599	09		 DB	 9
  0159a	09		 DB	 9
  0159b	09		 DB	 9
  0159c	09		 DB	 9
  0159d	09		 DB	 9
  0159e	09		 DB	 9
  0159f	09		 DB	 9
  015a0	09		 DB	 9
  015a1	09		 DB	 9
  015a2	09		 DB	 9
  015a3	09		 DB	 9
  015a4	09		 DB	 9
  015a5	09		 DB	 9
  015a6	09		 DB	 9
  015a7	09		 DB	 9
  015a8	09		 DB	 9
  015a9	09		 DB	 9
  015aa	09		 DB	 9
  015ab	09		 DB	 9
  015ac	09		 DB	 9
  015ad	09		 DB	 9
  015ae	09		 DB	 9
  015af	09		 DB	 9
  015b0	09		 DB	 9
  015b1	09		 DB	 9
  015b2	09		 DB	 9
  015b3	09		 DB	 9
  015b4	09		 DB	 9
  015b5	09		 DB	 9
  015b6	09		 DB	 9
  015b7	09		 DB	 9
  015b8	09		 DB	 9
  015b9	09		 DB	 9
  015ba	09		 DB	 9
  015bb	09		 DB	 9
  015bc	09		 DB	 9
  015bd	09		 DB	 9
  015be	09		 DB	 9
  015bf	09		 DB	 9
  015c0	09		 DB	 9
  015c1	09		 DB	 9
  015c2	09		 DB	 9
  015c3	09		 DB	 9
  015c4	09		 DB	 9
  015c5	09		 DB	 9
  015c6	09		 DB	 9
  015c7	09		 DB	 9
  015c8	09		 DB	 9
  015c9	09		 DB	 9
  015ca	09		 DB	 9
  015cb	09		 DB	 9
  015cc	09		 DB	 9
  015cd	09		 DB	 9
  015ce	09		 DB	 9
  015cf	09		 DB	 9
  015d0	09		 DB	 9
  015d1	09		 DB	 9
  015d2	09		 DB	 9
  015d3	09		 DB	 9
  015d4	09		 DB	 9
  015d5	09		 DB	 9
  015d6	09		 DB	 9
  015d7	09		 DB	 9
  015d8	09		 DB	 9
  015d9	09		 DB	 9
  015da	09		 DB	 9
  015db	09		 DB	 9
  015dc	09		 DB	 9
  015dd	09		 DB	 9
  015de	09		 DB	 9
  015df	09		 DB	 9
  015e0	09		 DB	 9
  015e1	09		 DB	 9
  015e2	09		 DB	 9
  015e3	09		 DB	 9
  015e4	09		 DB	 9
  015e5	09		 DB	 9
  015e6	09		 DB	 9
  015e7	09		 DB	 9
  015e8	09		 DB	 9
  015e9	09		 DB	 9
  015ea	09		 DB	 9
  015eb	09		 DB	 9
  015ec	09		 DB	 9
  015ed	09		 DB	 9
  015ee	09		 DB	 9
  015ef	09		 DB	 9
  015f0	09		 DB	 9
  015f1	09		 DB	 9
  015f2	09		 DB	 9
  015f3	09		 DB	 9
  015f4	09		 DB	 9
  015f5	09		 DB	 9
  015f6	09		 DB	 9
  015f7	09		 DB	 9
  015f8	09		 DB	 9
  015f9	09		 DB	 9
  015fa	09		 DB	 9
  015fb	09		 DB	 9
  015fc	09		 DB	 9
  015fd	09		 DB	 9
  015fe	09		 DB	 9
  015ff	09		 DB	 9
  01600	09		 DB	 9
  01601	09		 DB	 9
  01602	09		 DB	 9
  01603	09		 DB	 9
  01604	09		 DB	 9
  01605	09		 DB	 9
  01606	09		 DB	 9
  01607	09		 DB	 9
  01608	09		 DB	 9
  01609	09		 DB	 9
  0160a	09		 DB	 9
  0160b	09		 DB	 9
  0160c	09		 DB	 9
  0160d	09		 DB	 9
  0160e	09		 DB	 9
  0160f	09		 DB	 9
  01610	09		 DB	 9
  01611	09		 DB	 9
  01612	09		 DB	 9
  01613	09		 DB	 9
  01614	09		 DB	 9
  01615	09		 DB	 9
  01616	09		 DB	 9
  01617	09		 DB	 9
  01618	09		 DB	 9
  01619	09		 DB	 9
  0161a	09		 DB	 9
  0161b	09		 DB	 9
  0161c	09		 DB	 9
  0161d	09		 DB	 9
  0161e	09		 DB	 9
  0161f	09		 DB	 9
  01620	09		 DB	 9
  01621	09		 DB	 9
  01622	09		 DB	 9
  01623	09		 DB	 9
  01624	06		 DB	 6
  01625	09		 DB	 9
  01626	09		 DB	 9
  01627	09		 DB	 9
  01628	07		 DB	 7
  01629	08		 DB	 8
s390_diagnose_call ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_validate_operand
_TEXT	SEGMENT
tv79 = 48
tv94 = 52
tv138 = 56
addr$ = 80
arn$ = 88
len$ = 96
acctype$ = 104
regs$ = 112
s370_validate_operand PROC				; COMDAT

; 1376 : {

$LN24:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1377 :     /* Translate address of leftmost operand byte */
; 1378 :     MADDR( addr, arn, regs, acctype, regs->psw.pkey );

  00016	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001f	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00023	8b 44 24 68	 mov	 eax, DWORD PTR acctype$[rsp]
  00027	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0002b	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  00030	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00035	ba 01 00 00 00	 mov	 edx, 1
  0003a	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0003e	e8 00 00 00 00	 call	 s370_maddr_l

; 1379 : 
; 1380 :     /* Translate next page if boundary crossed */
; 1381 :     if (CROSSPAGE( addr, len ))

  00043	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00047	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0004c	b9 ff 07 00 00	 mov	 ecx, 2047		; 000007ffH
  00051	2b 4c 24 60	 sub	 ecx, DWORD PTR len$[rsp]
  00055	3b c1		 cmp	 eax, ecx
  00057	7e 0a		 jle	 SHORT $LN11@s370_valid
  00059	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
  00061	eb 08		 jmp	 SHORT $LN12@s370_valid
$LN11@s370_valid:
  00063	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN12@s370_valid:
  0006b	83 7c 24 30 00	 cmp	 DWORD PTR tv79[rsp], 0
  00070	74 3e		 je	 SHORT $LN5@s370_valid

; 1382 :     {
; 1383 :         MADDR( (addr + len) & ADDRESS_MAXWRAP( regs ),

  00072	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  00076	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0007a	03 c8		 add	 ecx, eax
  0007c	8b c1		 mov	 eax, ecx
  0007e	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00083	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0008c	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00090	8b 4c 24 68	 mov	 ecx, DWORD PTR acctype$[rsp]
  00094	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00098	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  0009d	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  000a2	ba 01 00 00 00	 mov	 edx, 1
  000a7	8b c8		 mov	 ecx, eax
  000a9	e8 00 00 00 00	 call	 s370_maddr_l

; 1384 :                arn, regs, acctype, regs->psw.pkey );
; 1385 :     }

  000ae	eb 5a		 jmp	 SHORT $LN6@s370_valid
$LN5@s370_valid:
$LN4@s370_valid:

; 1386 : #if defined( FEATURE_INTERVAL_TIMER )
; 1387 :     else
; 1388 :         ITIMER_SYNC( addr, len, regs );

  000b0	83 7c 24 50 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  000b5	73 0a		 jae	 SHORT $LN15@s370_valid
  000b7	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
  000bf	eb 08		 jmp	 SHORT $LN16@s370_valid
$LN15@s370_valid:
  000c1	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN16@s370_valid:
  000c9	83 7c 24 34 00	 cmp	 DWORD PTR tv94[rsp], 0
  000ce	74 1b		 je	 SHORT $LN17@s370_valid
  000d0	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  000d4	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  000d8	03 c8		 add	 ecx, eax
  000da	8b c1		 mov	 eax, ecx
  000dc	83 f8 50	 cmp	 eax, 80			; 00000050H
  000df	72 0a		 jb	 SHORT $LN17@s370_valid
  000e1	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv138[rsp], 1
  000e9	eb 08		 jmp	 SHORT $LN23@s370_valid
$LN17@s370_valid:
  000eb	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv138[rsp], 0
$LN23@s370_valid:
  000f3	83 7c 24 38 00	 cmp	 DWORD PTR tv138[rsp], 0
  000f8	74 0a		 je	 SHORT $LN7@s370_valid
  000fa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	e8 00 00 00 00	 call	 s370_store_int_timer
$LN7@s370_valid:
  00104	33 c0		 xor	 eax, eax
  00106	85 c0		 test	 eax, eax
  00108	75 a6		 jne	 SHORT $LN4@s370_valid
$LN6@s370_valid:

; 1389 : #endif
; 1390 : }

  0010a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0010e	c3		 ret	 0
s370_validate_operand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
tv80 = 56
tv92 = 60
mn$1 = 64
addr$ = 96
arn$ = 104
regs$ = 112
s370_vfetch4 PROC					; COMDAT

; 695  : {

$LN26:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 696  :     if ((likely(!((VADR_L)addr & 0x03))
; 697  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3) )))

  00011	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00015	83 e0 03	 and	 eax, 3
  00018	85 c0		 test	 eax, eax
  0001a	75 0a		 jne	 SHORT $LN9@s370_vfetc
  0001c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00024	eb 08		 jmp	 SHORT $LN10@s370_vfetc
$LN9@s370_vfetc:
  00026	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN10@s370_vfetc:
  0002e	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00033	74 0a		 je	 SHORT $LN13@s370_vfetc
  00035	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0003d	eb 08		 jmp	 SHORT $LN14@s370_vfetc
$LN13@s370_vfetc:
  0003f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN14@s370_vfetc:
  00047	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  0004c	75 14		 jne	 SHORT $LN6@s370_vfetc
  0004e	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00052	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00057	3d fc 07 00 00	 cmp	 eax, 2044		; 000007fcH
  0005c	0f 87 9a 00 00
	00		 ja	 $LN5@s370_vfetc
$LN6@s370_vfetc:
$LN4@s370_vfetc:

; 698  :     {
; 699  :         BYTE *mn;
; 700  :         ITIMER_SYNC( addr, 4-1, regs );

  00062	83 7c 24 60 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  00067	73 0a		 jae	 SHORT $LN17@s370_vfetc
  00069	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  00071	eb 08		 jmp	 SHORT $LN18@s370_vfetc
$LN17@s370_vfetc:
  00073	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN18@s370_vfetc:
  0007b	83 7c 24 38 00	 cmp	 DWORD PTR tv80[rsp], 0
  00080	74 16		 je	 SHORT $LN19@s370_vfetc
  00082	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00086	83 c0 03	 add	 eax, 3
  00089	83 f8 50	 cmp	 eax, 80			; 00000050H
  0008c	72 0a		 jb	 SHORT $LN19@s370_vfetc
  0008e	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  00096	eb 08		 jmp	 SHORT $LN25@s370_vfetc
$LN19@s370_vfetc:
  00098	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN25@s370_vfetc:
  000a0	83 7c 24 3c 00	 cmp	 DWORD PTR tv92[rsp], 0
  000a5	74 0a		 je	 SHORT $LN7@s370_vfetc
  000a7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000ac	e8 00 00 00 00	 call	 s370_store_int_timer
$LN7@s370_vfetc:
  000b1	33 c0		 xor	 eax, eax
  000b3	85 c0		 test	 eax, eax
  000b5	75 ab		 jne	 SHORT $LN4@s370_vfetc

; 701  :         mn = MADDRL( addr, 4,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000b7	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000bc	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  000c0	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  000c4	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000cc	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000d1	44 8b 44 24 68	 mov	 r8d, DWORD PTR arn$[rsp]
  000d6	ba 04 00 00 00	 mov	 edx, 4
  000db	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  000df	e8 00 00 00 00	 call	 s370_maddr_l
  000e4	48 89 44 24 40	 mov	 QWORD PTR mn$1[rsp], rax

; 702  :         return fetch_fw( mn );

  000e9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mn$1[rsp]
  000ee	e8 00 00 00 00	 call	 fetch_fw_noswap
  000f3	8b c8		 mov	 ecx, eax
  000f5	e8 00 00 00 00	 call	 _byteswap_ulong
  000fa	eb 12		 jmp	 SHORT $LN1@s370_vfetc
$LN5@s370_vfetc:

; 703  :     }
; 704  :     return ARCH_DEP( vfetch4_full )( addr, arn, regs );

  000fc	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00101	8b 54 24 68	 mov	 edx, DWORD PTR arn$[rsp]
  00105	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  00109	e8 00 00 00 00	 call	 s370_vfetch4_full
$LN1@s370_vfetc:

; 705  : }

  0010e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00112	c3		 ret	 0
s370_vfetch4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstorec
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
tv131 = 56
tv145 = 60
sk$ = 64
tv81 = 72
main1$ = 80
main2$ = 88
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
s370_vstorec PROC					; COMDAT

; 489  : {

$LN24:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00025	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002d	ba ff 07 00 00	 mov	 edx, 2047		; 000007ffH
  00032	2b d1		 sub	 edx, ecx
  00034	8b ca		 mov	 ecx, edx
  00036	3b c1		 cmp	 eax, ecx
  00038	7f 0a		 jg	 SHORT $LN11@s370_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN12@s370_vstor
$LN11@s370_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN12@s370_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  00051	0f 84 d6 00 00
	00		 je	 $LN5@s370_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00057	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005f	ff c0		 inc	 eax
  00061	48 98		 cdqe
  00063	48 89 44 24 48	 mov	 QWORD PTR tv81[rsp], rax
  00068	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  00070	ff c1		 inc	 ecx
  00072	48 63 c9	 movsxd	 rcx, ecx
  00075	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0007d	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00081	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00085	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008d	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00095	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0009d	48 8b d1	 mov	 rdx, rcx
  000a0	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000a7	e8 00 00 00 00	 call	 s370_maddr_l
  000ac	48 8b f8	 mov	 rdi, rax
  000af	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b7	48 8b 44 24 48	 mov	 rax, QWORD PTR tv81[rsp]
  000bc	48 8b c8	 mov	 rcx, rax
  000bf	f3 a4		 rep movsb
$LN4@s370_vstor:

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );

  000c1	83 bc 24 90 00
	00 00 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  000c9	73 0a		 jae	 SHORT $LN15@s370_vstor
  000cb	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN16@s370_vstor
$LN15@s370_vstor:
  000d5	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN16@s370_vstor:
  000dd	83 7c 24 38 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 22		 je	 SHORT $LN17@s370_vstor
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  000ec	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000f3	03 c8		 add	 ecx, eax
  000f5	8b c1		 mov	 eax, ecx
  000f7	83 f8 50	 cmp	 eax, 80			; 00000050H
  000fa	72 0a		 jb	 SHORT $LN17@s370_vstor
  000fc	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv145[rsp], 1
  00104	eb 08		 jmp	 SHORT $LN23@s370_vstor
$LN17@s370_vstor:
  00106	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN23@s370_vstor:
  0010e	83 7c 24 3c 00	 cmp	 DWORD PTR tv145[rsp], 0
  00113	74 0d		 je	 SHORT $LN7@s370_vstor
  00115	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011d	e8 00 00 00 00	 call	 s370_fetch_int_timer
$LN7@s370_vstor:
  00122	33 c0		 xor	 eax, eax
  00124	85 c0		 test	 eax, eax
  00126	75 99		 jne	 SHORT $LN4@s370_vstor

; 499  :     }

  00128	e9 21 01 00 00	 jmp	 $LN6@s370_vstor
$LN5@s370_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  0012d	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00134	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00139	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  0013e	2b c8		 sub	 ecx, eax
  00140	8b c1		 mov	 eax, ecx
  00142	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  00146	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0014b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00153	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00157	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0015b	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00163	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0016b	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00173	48 8b d0	 mov	 rdx, rax
  00176	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0017d	e8 00 00 00 00	 call	 s370_maddr_l
  00182	48 89 44 24 50	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  00187	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018f	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00196	48 89 44 24 40	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  0019b	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001a3	ff c0		 inc	 eax
  001a5	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001a9	48 98		 cdqe
  001ab	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  001af	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  001b6	03 d1		 add	 edx, ecx
  001b8	8b ca		 mov	 ecx, edx
  001ba	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  001c0	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001c8	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  001cc	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  001d0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001d8	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001e0	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  001e8	48 8b d0	 mov	 rdx, rax
  001eb	e8 00 00 00 00	 call	 s370_maddr_l
  001f0	48 89 44 24 58	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  001f5	48 8b 44 24 40	 mov	 rax, QWORD PTR sk$[rsp]
  001fa	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001fd	83 c8 06	 or	 eax, 6
  00200	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sk$[rsp]
  00205	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  00207	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0020c	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main1$[rsp]
  00211	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  00219	48 8b c8	 mov	 rcx, rax
  0021c	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  0021e	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00226	ff c0		 inc	 eax
  00228	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0022c	48 98		 cdqe
  0022e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00233	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  0023b	48 03 d1	 add	 rdx, rcx
  0023e	48 8b ca	 mov	 rcx, rdx
  00241	48 8b 7c 24 58	 mov	 rdi, QWORD PTR main2$[rsp]
  00246	48 8b f1	 mov	 rsi, rcx
  00249	48 8b c8	 mov	 rcx, rax
  0024c	f3 a4		 rep movsb
$LN6@s370_vstor:

; 512  :     }
; 513  : }

  0024e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00252	5f		 pop	 rdi
  00253	5e		 pop	 rsi
  00254	c3		 ret	 0
s370_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch4_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 72
addr$ = 112
arn$ = 120
regs$ = 128
s370_vfetch4_full PROC					; COMDAT

; 428  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 429  : BYTE   *mn;                             /* Main storage addresses    */
; 430  : int     len;                            /* Length to end of page     */
; 431  : BYTE    temp[8];                        /* Copy destination          */
; 432  : 
; 433  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00022	8b 44 24 70	 mov	 eax, DWORD PTR addr$[rsp]
  00026	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0002b	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00030	2b c8		 sub	 ecx, eax
  00032	8b c1		 mov	 eax, ecx
  00034	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 434  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00038	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0003d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00049	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0004d	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00055	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0005d	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  00062	48 8b d0	 mov	 rdx, rax
  00065	8b 4c 24 70	 mov	 ecx, DWORD PTR addr$[rsp]
  00069	e8 00 00 00 00	 call	 s370_maddr_l
  0006e	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 435  :     memcpy( temp, mn, len);

  00073	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00078	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  0007d	48 8b f9	 mov	 rdi, rcx
  00080	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00085	48 8b c8	 mov	 rcx, rax
  00088	f3 a4		 rep movsb

; 436  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4 - len, arn, regs,

  0008a	b8 04 00 00 00	 mov	 eax, 4
  0008f	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00093	48 98		 cdqe
  00095	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  00099	8b 54 24 70	 mov	 edx, DWORD PTR addr$[rsp]
  0009d	03 d1		 add	 edx, ecx
  0009f	8b ca		 mov	 ecx, edx
  000a1	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  000a7	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000af	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000b3	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000b7	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000bf	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000c7	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  000cc	48 8b d0	 mov	 rdx, rax
  000cf	e8 00 00 00 00	 call	 s370_maddr_l
  000d4	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 437  :                   ACCTYPE_READ, regs->psw.pkey );
; 438  :     memcpy( temp+len, mn, 4 - len);

  000d9	b8 04 00 00 00	 mov	 eax, 4
  000de	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000e2	48 98		 cdqe
  000e4	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000e9	48 8d 4c 0c 40	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  000ee	48 8b f9	 mov	 rdi, rcx
  000f1	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  000f6	48 8b c8	 mov	 rcx, rax
  000f9	f3 a4		 rep movsb

; 439  :     return fetch_fw( temp );

  000fb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00100	e8 00 00 00 00	 call	 fetch_fw_noswap
  00105	8b c8		 mov	 ecx, eax
  00107	e8 00 00 00 00	 call	 _byteswap_ulong

; 440  : }

  0010c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00111	48 33 cc	 xor	 rcx, rsp
  00114	e8 00 00 00 00	 call	 __security_check_cookie
  00119	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0011d	5f		 pop	 rdi
  0011e	5e		 pop	 rsi
  0011f	c3		 ret	 0
s370_vfetch4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s370_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s370_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s370_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s370_maddr
$LN12@s370_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s370_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0b	 shr	 eax, 11
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s370_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s370_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s370_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s370_maddr
$LN4@s370_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s370_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s370_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s370_maddr
$LN6@s370_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 e0 00	 and	 eax, 14680064		; 00e00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s370_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s370_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s370_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s370_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s370_maddr:
$LN7@s370_maddr:
$LN5@s370_maddr:
$LN3@s370_maddr:
$LN2@s370_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s370_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s370_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s370_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s370_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s370__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s370__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s370__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	0f b6 44 24 60	 movzx	 eax, BYTE PTR K$[rsp]
  0001d	83 f8 04	 cmp	 eax, 4
  00020	75 57		 jne	 SHORT $LN5@s370__or_s
  00022	33 c0		 xor	 eax, eax
  00024	83 f8 01	 cmp	 eax, 1
  00027	74 50		 je	 SHORT $LN5@s370__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  0002e	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00033	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  00038	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  0003d	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00042	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  00047	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00051	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00054	0b c8		 or	 ecx, eax
  00056	8b c1		 mov	 eax, ecx
  00058	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  0005d	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  0005f	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00064	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00069	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0006c	0b c8		 or	 ecx, eax
  0006e	8b c1		 mov	 eax, ecx
  00070	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00075	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  00077	eb 2c		 jmp	 SHORT $LN6@s370__or_s
$LN5@s370__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  00079	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  0007e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00083	e8 00 00 00 00	 call	 _get_storekey_ptr
  00088	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  0008d	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00092	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00097	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0009a	0b c8		 or	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  000a3	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s370__or_s:

; 202  :     }
; 203  : }

  000a5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a9	c3		 ret	 0
s370__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370__and_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s370__and_storage_key PROC				; COMDAT

; 172  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s370__and_:

; 173  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s370__and_

; 174  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	0f b6 44 24 60	 movzx	 eax, BYTE PTR K$[rsp]
  0001d	83 f8 04	 cmp	 eax, 4
  00020	75 5b		 jne	 SHORT $LN5@s370__and_
  00022	33 c0		 xor	 eax, eax
  00024	83 f8 01	 cmp	 eax, 1
  00027	74 54		 je	 SHORT $LN5@s370__and_

; 175  :     {
; 176  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  0002e	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00033	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 177  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  00038	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  0003d	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00042	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 178  :         AND_SKEY( skey1_ptr, ~bits );

  00047	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  0004c	f7 d0		 not	 eax
  0004e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00053	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00056	23 c8		 and	 ecx, eax
  00058	8b c1		 mov	 eax, ecx
  0005a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  0005f	88 01		 mov	 BYTE PTR [rcx], al

; 179  :         AND_SKEY( skey2_ptr, ~bits );

  00061	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00066	f7 d0		 not	 eax
  00068	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006d	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00070	23 c8		 and	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00079	88 01		 mov	 BYTE PTR [rcx], al

; 180  :     }

  0007b	eb 2e		 jmp	 SHORT $LN6@s370__and_
$LN5@s370__and_:

; 181  :     else
; 182  :     {
; 183  :         BYTE* skey_ptr  = _get_storekey_ptr(  abs, K );

  0007d	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00082	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00087	e8 00 00 00 00	 call	 _get_storekey_ptr
  0008c	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 184  :         AND_SKEY( skey_ptr, ~bits );

  00091	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00096	f7 d0		 not	 eax
  00098	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0009d	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000a0	23 c8		 and	 ecx, eax
  000a2	8b c1		 mov	 eax, ecx
  000a4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  000a9	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s370__and_:

; 185  :     }
; 186  : }

  000ab	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000af	c3		 ret	 0
s370__and_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey2_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey2_ptr PROC					; COMDAT

; 60   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 61   :     ABS_CHECK( abs );
; 62   :     return &STOREKEY2( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 c8 01	 or	 rax, 1
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 63   : }

  00026	c3		 ret	 0
_get_storekey2_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey1_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey1_ptr PROC					; COMDAT

; 54   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 55   :     ABS_CHECK( abs );
; 56   :     return &STOREKEY1( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 e0 fe	 and	 rax, -2
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 57   : }

  00026	c3		 ret	 0
_get_storekey1_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey_ptr
_TEXT	SEGMENT
tv75 = 0
abs$ = 32
K$ = 40
_get_storekey_ptr PROC					; COMDAT

; 40   : {

$LN5:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 41   :     ABS_CHECK( abs );
; 42   :     return (4 == K) ? &STOREKEY1( abs, &sysblk ) // (see feature.h PROGRAMMING NOTE)

  0000d	0f b6 44 24 28	 movzx	 eax, BYTE PTR K$[rsp]
  00012	83 f8 04	 cmp	 eax, 4
  00015	75 27		 jne	 SHORT $LN3@get_storek
  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  0001c	48 c1 e8 0b	 shr	 rax, 11
  00020	48 83 e0 fe	 and	 rax, -2
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0002b	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00032	48 03 c8	 add	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
  0003c	eb 21		 jmp	 SHORT $LN4@get_storek
$LN3@get_storek:
  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  00043	48 c1 e8 0b	 shr	 rax, 11
  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004e	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00055	48 03 c8	 add	 rcx, rax
  00058	48 8b c1	 mov	 rax, rcx
  0005b	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
$LN4@get_storek:
  0005f	48 8b 04 24	 mov	 rax, QWORD PTR tv75[rsp]

; 43   :                     : &STOREKEY(  abs, &sysblk );
; 44   : }

  00063	48 83 c4 18	 add	 rsp, 24
  00067	c3		 ret	 0
_get_storekey_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\diagnose.c
_TEXT	SEGMENT
tv64 = 64
n$ = 68
opt$1 = 72
cpu$2 = 76
i$3 = 80
i$4 = 84
rc$5 = 88
rc$6 = 92
code$ = 96
bodysize$7 = 100
i$8 = 104
tv209 = 108
tv339 = 112
lopasize$9 = 116
headsize$10 = 120
tv586 = 124
usecs$11 = 128
instcount$12 = 136
stgarea$13 = 144
mask$14 = 152
mask$15 = 160
secs$16 = 168
tv686 = 176
ipb$17 = 192
__$ArrayPad$ = 400
regs$ = 432
r1$ = 440
r3$ = 448
b2$ = 456
effective_addr2$ = 464
s370_diagnose_call PROC

; 240  : {

$LN150:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 81 ec a0 01
	00 00		 sub	 rsp, 416		; 000001a0H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 241  : #ifdef FEATURE_HERCULES_DIAGCALLS
; 242  : U32   n;                                /* 32-bit operand value      */
; 243  : #endif /*FEATURE_HERCULES_DIAGCALLS*/
; 244  : U32   code;
; 245  : 
; 246  :     code = effective_addr2;

  0002d	8b 84 24 d0 01
	00 00		 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00034	89 44 24 60	 mov	 DWORD PTR code$[rsp], eax

; 247  : 
; 248  :     switch(code) {

  00038	8b 44 24 60	 mov	 eax, DWORD PTR code$[rsp]
  0003c	89 44 24 40	 mov	 DWORD PTR tv64[rsp], eax
  00040	81 7c 24 40 10
	02 00 00	 cmp	 DWORD PTR tv64[rsp], 528 ; 00000210H
  00048	77 3b		 ja	 SHORT $LN142@s370_diagn
  0004a	81 7c 24 40 10
	02 00 00	 cmp	 DWORD PTR tv64[rsp], 528 ; 00000210H
  00052	0f 84 5d 03 00
	00		 je	 $LN71@s370_diagn
  00058	81 7c 24 40 dc
	00 00 00	 cmp	 DWORD PTR tv64[rsp], 220 ; 000000dcH
  00060	0f 87 22 10 00
	00		 ja	 $LN130@s370_diagn
  00066	8b 44 24 40	 mov	 eax, DWORD PTR tv64[rsp]
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00071	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN148@s370_diagn[rcx+rax]
  00079	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN149@s370_diagn[rcx+rax*4]
  00080	48 03 c1	 add	 rax, rcx
  00083	ff e0		 jmp	 rax
$LN142@s370_diagn:
  00085	81 7c 24 40 00
	0f 00 00	 cmp	 DWORD PTR tv64[rsp], 3840 ; 00000f00H
  0008d	77 48		 ja	 SHORT $LN143@s370_diagn
  0008f	81 7c 24 40 00
	0f 00 00	 cmp	 DWORD PTR tv64[rsp], 3840 ; 00000f00H
  00097	0f 84 5a 09 00
	00		 je	 $LN97@s370_diagn
  0009d	8b 44 24 40	 mov	 eax, DWORD PTR tv64[rsp]
  000a1	2d 14 02 00 00	 sub	 eax, 532		; 00000214H
  000a6	89 44 24 40	 mov	 DWORD PTR tv64[rsp], eax
  000aa	81 7c 24 40 f4
	00 00 00	 cmp	 DWORD PTR tv64[rsp], 244 ; 000000f4H
  000b2	0f 87 d0 0f 00
	00		 ja	 $LN130@s370_diagn
  000b8	8b 44 24 40	 mov	 eax, DWORD PTR tv64[rsp]
  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000c3	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN146@s370_diagn[rcx+rax]
  000cb	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN147@s370_diagn[rcx+rax*4]
  000d2	48 03 c1	 add	 rax, rcx
  000d5	ff e0		 jmp	 rax
$LN143@s370_diagn:
  000d7	8b 44 24 40	 mov	 eax, DWORD PTR tv64[rsp]
  000db	2d 04 0f 00 00	 sub	 eax, 3844		; 00000f04H
  000e0	89 44 24 40	 mov	 DWORD PTR tv64[rsp], eax
  000e4	81 7c 24 40 f9
	00 00 00	 cmp	 DWORD PTR tv64[rsp], 249 ; 000000f9H
  000ec	0f 87 96 0f 00
	00		 ja	 $LN130@s370_diagn
  000f2	8b 44 24 40	 mov	 eax, DWORD PTR tv64[rsp]
  000f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000fd	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN144@s370_diagn[rcx+rax]
  00105	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN145@s370_diagn[rcx+rax*4]
  0010c	48 03 c1	 add	 rax, rcx
  0010f	ff e0		 jmp	 rax
$LN53@s370_diagn:

; 249  : 
; 250  : 
; 251  : #if defined(FEATURE_IO_ASSIST)
; 252  :     case 0x002:
; 253  :     /*---------------------------------------------------------------*/
; 254  :     /* Diagnose 002: Update Interrupt Interlock Control Bit in PMCW  */
; 255  :     /*---------------------------------------------------------------*/
; 256  : 
; 257  :         ARCH_DEP(diagnose_002) (regs, r1, r3);
; 258  : 
; 259  :         break;
; 260  : #endif
; 261  : 
; 262  : 
; 263  :     case 0x01F:
; 264  :     /*---------------------------------------------------------------*/
; 265  :     /* Diagnose 01F: Power Off                                       */
; 266  :     /*---------------------------------------------------------------*/
; 267  : 
; 268  :         /* If diag8opt is not enabled then we are not allowed
; 269  :          * to manipulate the real machine i.e. hercules itself
; 270  :          */
; 271  :         if(!(sysblk.diag8opt & DIAG8CMD_ENABLE))

  00111	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00118	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  0011f	83 e0 01	 and	 eax, 1
  00122	85 c0		 test	 eax, eax
  00124	75 12		 jne	 SHORT $LN54@s370_diagn

; 272  :             ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00126	ba 06 00 00 00	 mov	 edx, 6
  0012b	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00133	e8 00 00 00 00	 call	 s370_program_interrupt
$LN54@s370_diagn:

; 273  : 
; 274  :         /* The poweroff diagnose is only valid on the 9221 */
; 275  :         if (sysblk.cpumodel != 0x9221
; 276  :           /* and r1/r3 must contain C'POWEROFF' in EBCDIC */
; 277  :           || regs->GR_L(r1) != 0xD7D6E6C5
; 278  :           || regs->GR_L(r3) != 0xD9D6C6C6)

  00138	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0013f	0f b7 80 d4 00
	00 00		 movzx	 eax, WORD PTR [rax+212]
  00146	3d 21 92 00 00	 cmp	 eax, 37409		; 00009221H
  0014b	75 3a		 jne	 SHORT $LN56@s370_diagn
  0014d	48 63 84 24 b8
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00155	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0015d	81 bc c1 80 02
	00 00 c5 e6 d6
	d7		 cmp	 DWORD PTR [rcx+rax*8+640], -673782075 ; d7d6e6c5H
  00168	75 1d		 jne	 SHORT $LN56@s370_diagn
  0016a	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00172	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017a	81 bc c1 80 02
	00 00 c6 c6 d6
	d9		 cmp	 DWORD PTR [rcx+rax*8+640], -640235834 ; d9d6c6c6H
  00185	74 12		 je	 SHORT $LN55@s370_diagn
$LN56@s370_diagn:

; 279  :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00187	ba 06 00 00 00	 mov	 edx, 6
  0018c	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 s370_program_interrupt
$LN55@s370_diagn:

; 280  : 
; 281  :         regs->cpustate = CPUSTATE_STOPPING;

  00199	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a1	c6 40 60 02	 mov	 BYTE PTR [rax+96], 2
$LN6@s370_diagn:

; 282  :         ON_IC_INTERRUPT(regs);

  001a5	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ad	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  001b0	0f ba e8 1f	 bts	 eax, 31
  001b4	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001bc	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  001bf	33 c0		 xor	 eax, eax
  001c1	85 c0		 test	 eax, eax
  001c3	75 e0		 jne	 SHORT $LN6@s370_diagn

; 283  : 
; 284  :         /* Release the configuration */
; 285  :         do_shutdown();

  001c5	e8 00 00 00 00	 call	 do_shutdown

; 286  : 
; 287  :         /* Power Off: exit hercules */
; 288  :         exit(0);

  001ca	33 c9		 xor	 ecx, ecx
  001cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN57@s370_diagn:

; 289  : 
; 290  : #if defined(FEATURE_HYPERVISOR) || defined(FEATURE_EMULATE_VM)
; 291  :     case 0x044:
; 292  :     /*---------------------------------------------------------------*/
; 293  :     /* Diagnose 044: Voluntary Time Slice End                        */
; 294  :     /*---------------------------------------------------------------*/
; 295  :         ARCH_DEP(scpend_call) ();

  001d2	e8 00 00 00 00	 call	 s370_scpend_call

; 296  :         break;

  001d7	e9 27 10 00 00	 jmp	 $LN2@s370_diagn
$LN58@s370_diagn:

; 297  : #endif
; 298  : 
; 299  : 
; 300  : #ifdef FEATURE_MSSF_CALL
; 301  :     case 0x080:
; 302  :     /*---------------------------------------------------------------*/
; 303  :     /* Diagnose 080: MSSF Call                                       */
; 304  :     /*---------------------------------------------------------------*/
; 305  :         regs->psw.cc = ARCH_DEP(mssf_call) (r1, r3, regs);
; 306  :         break;
; 307  : #endif /*FEATURE_MSSF_CALL*/
; 308  : 
; 309  : 
; 310  : #if defined(FEATURE_HYPERVISOR) || defined(FEATURE_EMULATE_VM)
; 311  :     case 0x09C:
; 312  :     /*---------------------------------------------------------------*/
; 313  :     /* Diagnose 09C: Voluntary Time Slice End With Target CPU        */
; 314  :     /*---------------------------------------------------------------*/
; 315  :         ARCH_DEP(scpend_call) ();   // (treat same as DIAG X'44')

  001dc	e8 00 00 00 00	 call	 s370_scpend_call

; 316  :         break;

  001e1	e9 1d 10 00 00	 jmp	 $LN2@s370_diagn
$LN59@s370_diagn:

; 317  : #endif
; 318  : 
; 319  : 
; 320  : #if defined(FEATURE_HYPERVISOR)
; 321  :     case 0x204:
; 322  :     /*---------------------------------------------------------------*/
; 323  :     /* Diagnose 204: LPAR RMF Interface                              */
; 324  :     /*---------------------------------------------------------------*/
; 325  :         ARCH_DEP(diag204_call) (r1, r3, regs);
; 326  :         regs->psw.cc = 0;
; 327  :         break;
; 328  : 
; 329  :     case 0x224:
; 330  :     /*---------------------------------------------------------------*/
; 331  :     /* Diagnose 224: CPU Names                                       */
; 332  :     /*---------------------------------------------------------------*/
; 333  :         ARCH_DEP(diag224_call) (r1, r3, regs);
; 334  :         regs->psw.cc = 0;
; 335  :         break;
; 336  : #endif /*defined(FEATURE_HYPERVISOR)*/
; 337  : 
; 338  : #if 0
; 339  :     case 0x21C:
; 340  :     /*---------------------------------------------------------------*/
; 341  :     /* Diagnose 21C: ????                                            */
; 342  :     /*---------------------------------------------------------------*/
; 343  :         /*INCOMPLETE*/
; 344  :         regs->psw.cc = 0;
; 345  :         break;
; 346  : #endif
; 347  : 
; 348  : #if 0
; 349  :     case 0x288;:
; 350  :     /*---------------------------------------------------------------*/
; 351  :     /* Diagnose 288: Control Virtual Machine Time Bomb               */
; 352  :     /*---------------------------------------------------------------*/
; 353  :         regs->psw.cc = ARCH_DEP(vm_timebomb) (r1, r3, regs);
; 354  :         break;
; 355  : #endif
; 356  : 
; 357  : #ifdef FEATURE_EMULATE_VM
; 358  :     case 0x000:
; 359  :     /*---------------------------------------------------------------*/
; 360  :     /* Diagnose 000: Store Extended Identification Code              */
; 361  :     /*---------------------------------------------------------------*/
; 362  :         ARCH_DEP(extid_call) (r1, r3, regs);

  001e6	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001ee	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  001f5	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  001fc	e8 00 00 00 00	 call	 s370_extid_call

; 363  :         break;

  00201	e9 fd 0f 00 00	 jmp	 $LN2@s370_diagn
$LN60@s370_diagn:

; 364  : 
; 365  :     case 0x008:
; 366  :     /*---------------------------------------------------------------*/
; 367  :     /* Diagnose 008: Virtual Console Function                        */
; 368  :     /*---------------------------------------------------------------*/
; 369  :         /* If diag8opt is not enabled then we are not allowed
; 370  :          * to manipulate the real machine i.e. hercules itself
; 371  :          */
; 372  :         if(!(sysblk.diag8opt & DIAG8CMD_ENABLE))

  00206	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0020d	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  00214	83 e0 01	 and	 eax, 1
  00217	85 c0		 test	 eax, eax
  00219	75 12		 jne	 SHORT $LN61@s370_diagn

; 373  :             ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0021b	ba 06 00 00 00	 mov	 edx, 6
  00220	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00228	e8 00 00 00 00	 call	 s370_program_interrupt
$LN61@s370_diagn:

; 374  : 
; 375  :         /* Process CP command and set condition code */
; 376  :         regs->psw.cc = ARCH_DEP(cpcmd_call) (r1, r3, regs);

  0022d	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00235	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  0023c	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  00243	e8 00 00 00 00	 call	 s370_cpcmd_call
  00248	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00250	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 377  :         break;

  00253	e9 ab 0f 00 00	 jmp	 $LN2@s370_diagn
$LN62@s370_diagn:

; 378  : 
; 379  :     case 0x00C:
; 380  :     /*---------------------------------------------------------------*/
; 381  :     /* Diagnose 00C: Pseudo Timer                                    */
; 382  :     /*---------------------------------------------------------------*/
; 383  :         ARCH_DEP(pseudo_timer) (code, r1, r3, regs);

  00258	4c 8b 8c 24 b0
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00260	44 8b 84 24 c0
	01 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  00268	8b 94 24 b8 01
	00 00		 mov	 edx, DWORD PTR r1$[rsp]
  0026f	8b 4c 24 60	 mov	 ecx, DWORD PTR code$[rsp]
  00273	e8 00 00 00 00	 call	 s370_pseudo_timer

; 384  :         break;

  00278	e9 86 0f 00 00	 jmp	 $LN2@s370_diagn
$LN63@s370_diagn:

; 385  : 
; 386  :     case 0x024:
; 387  :     /*---------------------------------------------------------------*/
; 388  :     /* Diagnose 024: Device Type and Features                        */
; 389  :     /*---------------------------------------------------------------*/
; 390  :         regs->psw.cc = ARCH_DEP(diag_devtype) (r1, r3, regs);

  0027d	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00285	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  0028c	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  00293	e8 00 00 00 00	 call	 s370_diag_devtype
  00298	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a0	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 391  :         break;

  002a3	e9 5b 0f 00 00	 jmp	 $LN2@s370_diagn
$LN64@s370_diagn:

; 392  : 
; 393  :     case 0x05C:
; 394  :     /*---------------------------------------------------------------*/
; 395  :     /* Diagnose 05C: Error Message Editing                           */
; 396  :     /*---------------------------------------------------------------*/
; 397  :         /* This function is implemented as a no-operation */
; 398  :         regs->psw.cc = 0;

  002a8	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002b0	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 399  :         break;

  002b4	e9 4a 0f 00 00	 jmp	 $LN2@s370_diagn
$LN65@s370_diagn:

; 400  : 
; 401  :     case 0x060:
; 402  :     /*---------------------------------------------------------------*/
; 403  :     /* Diagnose 060: Virtual Machine Storage Size                    */
; 404  :     /*---------------------------------------------------------------*/
; 405  :         /* Load main storage size in bytes into R1 register */
; 406  :         regs->GR_L(r1) = regs->mainlim + 1;

  002b9	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c1	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  002c8	48 ff c0	 inc	 rax
  002cb	48 63 8c 24 b8
	01 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  002d3	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002db	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 407  :         break;

  002e2	e9 1c 0f 00 00	 jmp	 $LN2@s370_diagn
$LN66@s370_diagn:

; 408  : 
; 409  :     case 0x064:
; 410  :     /*---------------------------------------------------------------*/
; 411  :     /* Diagnose 064: Named Saved Segment Manipulation                */
; 412  :     /*---------------------------------------------------------------*/
; 413  :         /* Return code 44 cond code 2 means segment does not exist */
; 414  :         regs->GR_L(r3) = 44;

  002e7	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  002ef	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f7	c7 84 c1 80 02
	00 00 2c 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 44 ; 0000002cH

; 415  :         regs->psw.cc = 2;

  00302	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0030a	c6 40 7c 02	 mov	 BYTE PTR [rax+124], 2

; 416  :         break;

  0030e	e9 f0 0e 00 00	 jmp	 $LN2@s370_diagn
$LN67@s370_diagn:

; 417  : 
; 418  :     case 0x0A4:
; 419  :     /*---------------------------------------------------------------*/
; 420  :     /* Diagnose 0A4: Synchronous I/O (Standard CMS Blocksize)        */
; 421  :     /*---------------------------------------------------------------*/
; 422  :         regs->psw.cc = ARCH_DEP(syncblk_io) (r1, r3, regs);

  00313	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0031b	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  00322	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  00329	e8 00 00 00 00	 call	 s370_syncblk_io
  0032e	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00336	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 423  : //      logmsg ("Diagnose X\'0A4\': CC=%d, R15=%8.8X\n",      /*debug*/
; 424  : //              regs->psw.cc, regs->GR_L(15));                 /*debug*/
; 425  :         break;

  00339	e9 c5 0e 00 00	 jmp	 $LN2@s370_diagn
$LN68@s370_diagn:

; 426  : 
; 427  :     case 0x0A8:
; 428  :     /*---------------------------------------------------------------*/
; 429  :     /* Diagnose 0A8: Synchronous General I/O                         */
; 430  :     /*---------------------------------------------------------------*/
; 431  :         regs->psw.cc = ARCH_DEP(syncgen_io) (r1, r3, regs);

  0033e	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00346	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  0034d	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  00354	e8 00 00 00 00	 call	 s370_syncgen_io
  00359	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00361	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 432  : //      logmsg ("Diagnose X\'0A8\': CC=%d, R15=%8.8X\n",      /*debug*/
; 433  : //              regs->psw.cc, regs->GR_L(15));                 /*debug*/
; 434  :         break;

  00364	e9 9a 0e 00 00	 jmp	 $LN2@s370_diagn
$LN69@s370_diagn:

; 435  : 
; 436  :     case 0x0B0:
; 437  :     /*---------------------------------------------------------------*/
; 438  :     /* Diagnose 0B0: Access Re-IPL Data                              */
; 439  :     /*---------------------------------------------------------------*/
; 440  :         ARCH_DEP(access_reipl_data) (r1, r3, regs);

  00369	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00371	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  00378	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  0037f	e8 00 00 00 00	 call	 s370_access_reipl_data

; 441  :         break;

  00384	e9 7a 0e 00 00	 jmp	 $LN2@s370_diagn
$LN70@s370_diagn:

; 442  : 
; 443  :     case 0x0DC:
; 444  :     /*---------------------------------------------------------------*/
; 445  :     /* Diagnose 0DC: Control Application Monitor Record Collection   */
; 446  :     /*---------------------------------------------------------------*/
; 447  :         /* This function is implemented as a no-operation */
; 448  :         regs->GR_L(r3) = 0;

  00389	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00391	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00399	c7 84 c1 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 0

; 449  :         regs->psw.cc = 0;

  003a4	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003ac	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 450  :         break;

  003b0	e9 4e 0e 00 00	 jmp	 $LN2@s370_diagn
$LN71@s370_diagn:

; 451  : 
; 452  :     case 0x210:
; 453  :     /*---------------------------------------------------------------*/
; 454  :     /* Diagnose 210: Retrieve Device Information                     */
; 455  :     /*---------------------------------------------------------------*/
; 456  :         regs->psw.cc = ARCH_DEP(device_info) (r1, r3, regs);

  003b5	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003bd	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  003c4	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  003cb	e8 00 00 00 00	 call	 s370_device_info
  003d0	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d8	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 457  :         break;

  003db	e9 23 0e 00 00	 jmp	 $LN2@s370_diagn
$LN72@s370_diagn:

; 458  : 
; 459  :     case 0x214:
; 460  :     /*---------------------------------------------------------------*/
; 461  :     /* Diagnose 214: Pending Page Release                            */
; 462  :     /*---------------------------------------------------------------*/
; 463  :         regs->psw.cc = ARCH_DEP(diag_ppagerel) (r1, r3, regs);

  003e0	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003e8	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  003ef	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  003f6	e8 00 00 00 00	 call	 s370_diag_ppagerel
  003fb	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00403	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 464  :         break;

  00406	e9 f8 0d 00 00	 jmp	 $LN2@s370_diagn
$LN73@s370_diagn:

; 465  : 
; 466  : 
; 467  :     case 0x220:
; 468  :     /*---------------------------------------------------------------*/
; 469  :     /* Diagnose 220: TOD Epoch                                       */
; 470  :     /*---------------------------------------------------------------*/
; 471  :         ODD_CHECK(r3, regs);

  0040b	8b 84 24 c0 01
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00412	83 e0 01	 and	 eax, 1
  00415	85 c0		 test	 eax, eax
  00417	74 1b		 je	 SHORT $LN74@s370_diagn
  00419	ba 06 00 00 00	 mov	 edx, 6
  0041e	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00426	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0042e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN74@s370_diagn:

; 472  : 
; 473  :         switch(regs->GR_L(r1))

  00434	48 63 84 24 b8
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0043c	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00444	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0044b	89 44 24 6c	 mov	 DWORD PTR tv209[rsp], eax
  0044f	83 7c 24 6c 00	 cmp	 DWORD PTR tv209[rsp], 0
  00454	74 0c		 je	 SHORT $LN75@s370_diagn
  00456	83 7c 24 6c 01	 cmp	 DWORD PTR tv209[rsp], 1
  0045b	74 40		 je	 SHORT $LN76@s370_diagn
  0045d	e9 a5 00 00 00	 jmp	 $LN77@s370_diagn
$LN75@s370_diagn:

; 474  :         {
; 475  :             case 0:
; 476  :                 /* Obtain TOD features */
; 477  :                 regs->GR_L(r3)  =0xc0000000;

  00462	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0046a	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00472	c7 84 c1 80 02
	00 00 00 00 00
	c0		 mov	 DWORD PTR [rcx+rax*8+640], -1073741824 ; c0000000H

; 478  :                 regs->GR_L(r3+1)=0x00000000;

  0047d	8b 84 24 c0 01
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00484	ff c0		 inc	 eax
  00486	48 98		 cdqe
  00488	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00490	c7 84 c1 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 0

; 479  :                 break;

  0049b	eb 7c		 jmp	 SHORT $LN7@s370_diagn
$LN76@s370_diagn:

; 480  :             case 1:
; 481  :                 /* Obtain TOD offset to real TOD in R2, R2+1 */
; 482  :                 regs->GR_L(r3)  = (regs->tod_epoch >> 24) & 0xFFFFFFFF;

  0049d	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004a5	48 8b 80 40 07
	00 00		 mov	 rax, QWORD PTR [rax+1856]
  004ac	48 c1 f8 18	 sar	 rax, 24
  004b0	b9 ff ff ff ff	 mov	 ecx, -1
  004b5	48 23 c1	 and	 rax, rcx
  004b8	48 63 8c 24 c0
	01 00 00	 movsxd	 rcx, DWORD PTR r3$[rsp]
  004c0	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004c8	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 483  :                 regs->GR_L(r3+1)= (regs->tod_epoch << 8) & 0xFFFFFFFF;

  004cf	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004d7	48 8b 80 40 07
	00 00		 mov	 rax, QWORD PTR [rax+1856]
  004de	48 c1 e0 08	 shl	 rax, 8
  004e2	b9 ff ff ff ff	 mov	 ecx, -1
  004e7	48 23 c1	 and	 rax, rcx
  004ea	8b 8c 24 c0 01
	00 00		 mov	 ecx, DWORD PTR r3$[rsp]
  004f1	ff c1		 inc	 ecx
  004f3	48 63 c9	 movsxd	 rcx, ecx
  004f6	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004fe	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 484  :                 break;

  00505	eb 12		 jmp	 SHORT $LN7@s370_diagn
$LN77@s370_diagn:

; 485  :             default:
; 486  :                 ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00507	ba 06 00 00 00	 mov	 edx, 6
  0050c	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00514	e8 00 00 00 00	 call	 s370_program_interrupt
$LN7@s370_diagn:

; 487  :         }
; 488  :         break;

  00519	e9 e5 0c 00 00	 jmp	 $LN2@s370_diagn
$LN78@s370_diagn:

; 489  : 
; 490  : 
; 491  :     case 0x23C:
; 492  :     /*---------------------------------------------------------------*/
; 493  :     /* Diagnose 23C: Address Space Services                          */
; 494  :     /*---------------------------------------------------------------*/
; 495  :         /* This function is implemented as a no-operation */
; 496  :         regs->GR_L(r3) = 0;

  0051e	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00526	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0052e	c7 84 c1 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 0

; 497  :         break;

  00539	e9 c5 0c 00 00	 jmp	 $LN2@s370_diagn
$LN79@s370_diagn:

; 498  : 
; 499  : 
; 500  : #if defined(FEATURE_VM_BLOCKIO)
; 501  :     case 0x250:
; 502  :     /*---------------------------------------------------------------*/
; 503  :     /* Diagnose 250: Standardized Block I/O                          */
; 504  :     /*---------------------------------------------------------------*/
; 505  :         regs->psw.cc = ARCH_DEP(vm_blockio) (r1, r3, regs);

  0053e	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00546	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  0054d	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  00554	e8 00 00 00 00	 call	 s370_vm_blockio
  00559	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00561	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 506  :         break;

  00564	e9 9a 0c 00 00	 jmp	 $LN2@s370_diagn
$LN80@s370_diagn:

; 507  : #endif /*defined(FEATURE_VM_BLOCKIO)*/
; 508  : 
; 509  : 
; 510  :     case 0x260:
; 511  :     /*---------------------------------------------------------------*/
; 512  :     /* Diagnose 260: Access Certain Virtual Machine Information      */
; 513  :     /*---------------------------------------------------------------*/
; 514  :         ARCH_DEP(vm_info) (r1, r3, regs);

  00569	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00571	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  00578	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  0057f	e8 00 00 00 00	 call	 s370_vm_info

; 515  :         break;

  00584	e9 7a 0c 00 00	 jmp	 $LN2@s370_diagn
$LN81@s370_diagn:
$LN11@s370_diagn:

; 516  : 
; 517  :     case 0x264:
; 518  :     /*---------------------------------------------------------------*/
; 519  :     /* Diagnose 264: CP Communication                                */
; 520  :     /*---------------------------------------------------------------*/
; 521  :         /* This function is implemented as a no-operation */
; 522  :         PTT_ERR("*DIAG264",regs->GR_L(r1),regs->GR_L(r3),regs->psw.IA_L);

  00589	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00590	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00593	48 83 e0 10	 and	 rax, 16
  00597	48 85 c0	 test	 rax, rax
  0059a	74 6f		 je	 SHORT $LN82@s370_diagn
  0059c	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005a4	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  005aa	48 63 8c 24 c0
	01 00 00	 movsxd	 rcx, DWORD PTR r3$[rsp]
  005b2	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005ba	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  005c1	48 63 94 24 b8
	01 00 00	 movsxd	 rdx, DWORD PTR r1$[rsp]
  005c9	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  005d1	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  005d9	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  005e2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  005e7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169715
  005ee	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005f3	44 8b c9	 mov	 r9d, ecx
  005f6	44 8b c2	 mov	 r8d, edx
  005f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169716
  00600	b9 10 00 00 00	 mov	 ecx, 16
  00605	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN82@s370_diagn:
  0060b	33 c0		 xor	 eax, eax
  0060d	85 c0		 test	 eax, eax
  0060f	0f 85 74 ff ff
	ff		 jne	 $LN11@s370_diagn

; 523  :         regs->psw.cc = 0;

  00615	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0061d	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 524  :         break;

  00621	e9 dd 0b 00 00	 jmp	 $LN2@s370_diagn
$LN83@s370_diagn:

; 525  : 
; 526  :     case 0x270:
; 527  :     /*---------------------------------------------------------------*/
; 528  :     /* Diagnose 270: Pseudo Timer Extended                           */
; 529  :     /*---------------------------------------------------------------*/
; 530  :         ARCH_DEP(pseudo_timer) (code, r1, r3, regs);

  00626	4c 8b 8c 24 b0
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0062e	44 8b 84 24 c0
	01 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  00636	8b 94 24 b8 01
	00 00		 mov	 edx, DWORD PTR r1$[rsp]
  0063d	8b 4c 24 60	 mov	 ecx, DWORD PTR code$[rsp]
  00641	e8 00 00 00 00	 call	 s370_pseudo_timer

; 531  :         break;

  00646	e9 b8 0b 00 00	 jmp	 $LN2@s370_diagn
$LN84@s370_diagn:
$LN14@s370_diagn:

; 532  : 
; 533  :     case 0x274:
; 534  :     /*---------------------------------------------------------------*/
; 535  :     /* Diagnose 274: Set Timezone Interrupt Flag                     */
; 536  :     /*---------------------------------------------------------------*/
; 537  :         /* This function is implemented as a no-operation */
; 538  :         PTT_ERR("*DIAG274",regs->GR_L(r1),regs->GR_L(r3),regs->psw.IA_L);

  0064b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00652	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00655	48 83 e0 10	 and	 rax, 16
  00659	48 85 c0	 test	 rax, rax
  0065c	74 6f		 je	 SHORT $LN85@s370_diagn
  0065e	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00666	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0066c	48 63 8c 24 c0
	01 00 00	 movsxd	 rcx, DWORD PTR r3$[rsp]
  00674	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0067c	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  00683	48 63 94 24 b8
	01 00 00	 movsxd	 rdx, DWORD PTR r1$[rsp]
  0068b	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00693	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  0069b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  006a4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  006a9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169720
  006b0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006b5	44 8b c9	 mov	 r9d, ecx
  006b8	44 8b c2	 mov	 r8d, edx
  006bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169721
  006c2	b9 10 00 00 00	 mov	 ecx, 16
  006c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN85@s370_diagn:
  006cd	33 c0		 xor	 eax, eax
  006cf	85 c0		 test	 eax, eax
  006d1	0f 85 74 ff ff
	ff		 jne	 $LN14@s370_diagn

; 539  :         regs->psw.cc = 0;

  006d7	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006df	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 540  :         break;

  006e3	e9 1b 0b 00 00	 jmp	 $LN2@s370_diagn
$LN86@s370_diagn:
$LN17@s370_diagn:

; 541  : #endif /*FEATURE_EMULATE_VM*/
; 542  : 
; 543  : 
; 544  :     case 0x308:
; 545  :     /*---------------------------------------------------------------*/
; 546  :     /* Diagnose 308: IPL functions                                   */
; 547  :     /*---------------------------------------------------------------*/
; 548  :         PTT_ERR("*DIAG308",regs->GR_G(r1),regs->GR_G(r3),regs->psw.IA_L);

  006e8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  006ef	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006f2	48 83 e0 10	 and	 rax, 16
  006f6	48 85 c0	 test	 rax, rax
  006f9	74 6a		 je	 SHORT $LN87@s370_diagn
  006fb	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00703	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00709	48 63 8c 24 c0
	01 00 00	 movsxd	 rcx, DWORD PTR r3$[rsp]
  00711	48 63 94 24 b8
	01 00 00	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00719	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00722	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00727	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169724
  0072e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00733	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0073b	4c 8b 8c c8 80
	02 00 00	 mov	 r9, QWORD PTR [rax+rcx*8+640]
  00743	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0074b	4c 8b 84 d0 80
	02 00 00	 mov	 r8, QWORD PTR [rax+rdx*8+640]
  00753	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169725
  0075a	b9 10 00 00 00	 mov	 ecx, 16
  0075f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN87@s370_diagn:
  00765	33 c0		 xor	 eax, eax
  00767	85 c0		 test	 eax, eax
  00769	0f 85 79 ff ff
	ff		 jne	 $LN17@s370_diagn

; 549  : 
; 550  :         switch(regs->GR_L(r3))

  0076f	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00777	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0077f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00786	89 44 24 70	 mov	 DWORD PTR tv339[rsp], eax
  0078a	83 7c 24 70 01	 cmp	 DWORD PTR tv339[rsp], 1
  0078f	74 0c		 je	 SHORT $LN88@s370_diagn
  00791	83 7c 24 70 06	 cmp	 DWORD PTR tv339[rsp], 6
  00796	74 0a		 je	 SHORT $LN89@s370_diagn
  00798	e9 43 02 00 00	 jmp	 $LN96@s370_diagn
$LN88@s370_diagn:

; 551  :         {
; 552  : #if defined(FEATURE_PROGRAM_DIRECTED_REIPL)
; 553  :             TID   tid;                              /* Thread identifier         */
; 554  :             char *ipltype;                          /* "ipl" or "iplc"           */
; 555  :             int   rc;
; 556  : #endif /*defined(FEATURE_PROGRAM_DIRECTED_REIPL)*/
; 557  : 
; 558  :         case DIAG308_START_KERNEL:
; 559  :             /*-------------------------------------------------------*/
; 560  :             /* Linux for z uses this function code, without a        */
; 561  :             /* defined value, in a function named start_kernel (see  */
; 562  :             /* ZIPL stage3.c). The Diagnose instruction is DIAG      */
; 563  :             /* 1,1,0x308, with GPR 1 containing DIAG308_START_KERNEL */
; 564  :             /* (i.e. equal to 1). This author has no idea what       */
; 565  :             /* function start_kernel is expecting the Diagnose       */
; 566  :             /* instruction to do (other than starting the kernel!),  */
; 567  :             /* but the function does not check a return code, or     */
; 568  :             /* anything else, and is prepared for the Diagnose       */
; 569  :             /* instruction to program check. Fortunately, the        */
; 570  :             /* function code DIAG308_START_KERNEL and the return     */
; 571  :             /* code DIAG308_RC_OK both have the same value (i.e.     */
; 572  :             /* equal to 1), so we'll simply return without doing     */
; 573  :             /* anything, letting the function code become the        */
; 574  :             /* return code.                                          */
; 575  :             /*-------------------------------------------------------*/
; 576  :             break;

  0079d	e9 50 02 00 00	 jmp	 $LN18@s370_diagn
$LN89@s370_diagn:

; 577  : 
; 578  : #if defined(FEATURE_PROGRAM_DIRECTED_REIPL)
; 579  :         case DIAG308_LOAD_CLEAR:
; 580  :             ipltype = "iplc";
; 581  :             goto diag308_cthread;
; 582  :         case DIAG308_LOAD_NORMAL:
; 583  :             ipltype = "ipl";
; 584  :         diag308_cthread:
; 585  :             rc = create_thread(&tid, DETACHED, stop_cpus_and_ipl, ipltype, "Stop cpus and ipl");
; 586  :             if(rc)
; 587  :                 WRMSG(HHC00102, "E", strerror(rc));
; 588  :             regs->cpustate = CPUSTATE_STOPPING;
; 589  :             ON_IC_INTERRUPT(regs);
; 590  :             break;
; 591  :         case DIAG308_SET:
; 592  :             /* INCOMPLETE */
; 593  :             regs->GR(1) = DIAG308_RC_OK;
; 594  :             break;
; 595  : #endif /*defined(FEATURE_PROGRAM_DIRECTED_REIPL)*/
; 596  : 
; 597  :         case DIAG308_STORE:
; 598  :           {
; 599  :             /*-------------------------------------------------------*/
; 600  :             /* On entry                                              */
; 601  :             /*   Rx    Rx must be an even numbered register          */
; 602  :             /*         containing the real address of a 4K page      */
; 603  :             /*         aligned storage area into which the IPL       */
; 604  :             /*         parameter block will be copied.               */
; 605  :             /* On return                                             */
; 606  :             /*   Rx+1  Contains the return code.                     */
; 607  :             /*-------------------------------------------------------*/
; 608  :             RADR    stgarea;            /* Storage area real address */
; 609  :             U32     headsize;
; 610  :             U32     bodysize;
; 611  :             struct ipl_parameter_block  ipb;
; 612  :             int     lopasize;
; 613  : 
; 614  :             /* Program check if running problem state. */
; 615  :             PRIV_CHECK(regs);

  007a2	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007aa	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  007ae	83 e0 01	 and	 eax, 1
  007b1	85 c0		 test	 eax, eax
  007b3	74 1b		 je	 SHORT $LN90@s370_diagn
  007b5	ba 02 00 00 00	 mov	 edx, 2
  007ba	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007c2	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007ca	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN90@s370_diagn:

; 616  : 
; 617  :             /* Register Rx contains the real address of the storage area. */
; 618  :             if(regs->psw.amode64) {

  007d0	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007d8	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  007de	83 e0 01	 and	 eax, 1
  007e1	85 c0		 test	 eax, eax
  007e3	74 22		 je	 SHORT $LN91@s370_diagn

; 619  :               stgarea = regs->GR_G(r1);

  007e5	48 63 84 24 b8
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  007ed	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007f5	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  007fd	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR stgarea$13[rsp], rax

; 620  :             } else {

  00805	eb 1f		 jmp	 SHORT $LN92@s370_diagn
$LN91@s370_diagn:

; 621  :               stgarea = regs->GR_L(r1);

  00807	48 63 84 24 b8
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0080f	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00817	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0081e	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR stgarea$13[rsp], rax
$LN92@s370_diagn:

; 622  :             }
; 623  : 
; 624  :             /* Program check if Rx is not an even register number or     */
; 625  :             /* the address contained in Rx is not on a 4K page boundary. */
; 626  :             if (r1 & 1 || stgarea & 0xFFF)

  00826	8b 84 24 b8 01
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  0082d	83 e0 01	 and	 eax, 1
  00830	85 c0		 test	 eax, eax
  00832	75 13		 jne	 SHORT $LN94@s370_diagn
  00834	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR stgarea$13[rsp]
  0083c	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00842	48 85 c0	 test	 rax, rax
  00845	74 12		 je	 SHORT $LN93@s370_diagn
$LN94@s370_diagn:

; 627  :             {
; 628  :                 ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00847	ba 06 00 00 00	 mov	 edx, 6
  0084c	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00854	e8 00 00 00 00	 call	 s370_program_interrupt
$LN93@s370_diagn:

; 629  :             }
; 630  : 
; 631  :             /* Ensure that the 4K storage area is addressable. */
; 632  :             ARCH_DEP(validate_operand) (stgarea, USE_REAL_ADDR, 4095, ACCTYPE_WRITE, regs);

  00859	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00861	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00866	41 b9 02 00 00
	00		 mov	 r9d, 2
  0086c	41 b8 ff 0f 00
	00		 mov	 r8d, 4095		; 00000fffH
  00872	ba fe ff ff ff	 mov	 edx, -2
  00877	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR stgarea$13[rsp]
  0087e	e8 00 00 00 00	 call	 s370_validate_operand

; 633  : 
; 634  :             /* Prepare the IPL parameter block. */
; 635  :             memset(&ipb, 0, sizeof(ipb));

  00883	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR ipb$17[rsp]
  0088b	48 8b f8	 mov	 rdi, rax
  0088e	33 c0		 xor	 eax, eax
  00890	b9 c8 00 00 00	 mov	 ecx, 200		; 000000c8H
  00895	f3 aa		 rep stosb

; 636  :             /* Setup head and body values common to all. */
; 637  :             ipb.hdr.version = IPL_MAX_SUPPORTED_VERSION;

  00897	c6 84 24 c7 00
	00 00 00	 mov	 BYTE PTR ipb$17[rsp+7], 0

; 638  :             headsize = sizeof(ipb.hdr);

  0089f	c7 44 24 78 08
	00 00 00	 mov	 DWORD PTR headsize$10[rsp], 8

; 639  :             memset(ipb.common.loadparm, 0x40, sizeof(ipb.common.loadparm));  /* EBCDIC spaces */

  008a7	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR ipb$17[rsp+16]
  008af	48 8b f8	 mov	 rdi, rax
  008b2	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  008b7	b9 08 00 00 00	 mov	 ecx, 8
  008bc	f3 aa		 rep stosb

; 640  :             lopasize = strlen(sysblk.loadparm);

  008be	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  008c5	48 05 38 13 00
	00		 add	 rax, 4920		; 00001338H
  008cb	48 8b c8	 mov	 rcx, rax
  008ce	e8 00 00 00 00	 call	 strlen
  008d3	89 44 24 74	 mov	 DWORD PTR lopasize$9[rsp], eax

; 641  :             if (lopasize)

  008d7	83 7c 24 74 00	 cmp	 DWORD PTR lopasize$9[rsp], 0
  008dc	74 23		 je	 SHORT $LN95@s370_diagn

; 642  :             {
; 643  :                 str_host_to_guest(ipb.common.loadparm, sysblk.loadparm, lopasize);

  008de	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  008e5	48 05 38 13 00
	00		 add	 rax, 4920		; 00001338H
  008eb	44 8b 44 24 74	 mov	 r8d, DWORD PTR lopasize$9[rsp]
  008f0	48 8b d0	 mov	 rdx, rax
  008f3	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR ipb$17[rsp+16]
  008fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_str_host_to_guest
$LN95@s370_diagn:

; 644  :             }
; 645  :             /* Setup head and body values specific to CCW. */
; 646  :             bodysize = sizeof(ipb.ccw);

  00901	c7 44 24 64 c0
	00 00 00	 mov	 DWORD PTR bodysize$7[rsp], 192 ; 000000c0H

; 647  :             STORE_FW(&ipb.hdr.len, (headsize + bodysize));

  00909	8b 44 24 64	 mov	 eax, DWORD PTR bodysize$7[rsp]
  0090d	8b 4c 24 78	 mov	 ecx, DWORD PTR headsize$10[rsp]
  00911	03 c8		 add	 ecx, eax
  00913	8b c1		 mov	 eax, ecx
  00915	8b c8		 mov	 ecx, eax
  00917	e8 00 00 00 00	 call	 _byteswap_ulong
  0091c	8b d0		 mov	 edx, eax
  0091e	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR ipb$17[rsp]
  00926	e8 00 00 00 00	 call	 store_fw_noswap

; 648  :             STORE_FW(&ipb.ccw.len, bodysize);

  0092b	8b 4c 24 64	 mov	 ecx, DWORD PTR bodysize$7[rsp]
  0092f	e8 00 00 00 00	 call	 _byteswap_ulong
  00934	8b d0		 mov	 edx, eax
  00936	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR ipb$17[rsp+8]
  0093e	e8 00 00 00 00	 call	 store_fw_noswap

; 649  :             ipb.ccw.pbt = IPL_TYPE_CCW;

  00943	c6 84 24 cc 00
	00 00 02	 mov	 BYTE PTR ipb$17[rsp+12], 2

; 650  :             STORE_HW(&ipb.ccw.devno, sysblk.ipldev);

  0094b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00952	0f b7 88 f2 00
	00 00		 movzx	 ecx, WORD PTR [rax+242]
  00959	e8 00 00 00 00	 call	 _byteswap_ushort
  0095e	0f b7 d0	 movzx	 edx, ax
  00961	48 8d 8c 24 2e
	01 00 00	 lea	 rcx, QWORD PTR ipb$17[rsp+110]
  00969	e8 00 00 00 00	 call	 store_hw_noswap

; 651  :             STRLCPY(ipb.ccw.vm_parm, "Hercules");  /* just to show its us! */

  0096e	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00974	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169734
  0097b	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR ipb$17[rsp+128]
  00983	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 652  : 
; 653  :             /* Store the IPL parameter block in real storage */
; 654  :             /* Note: vstorec copies a maximum of 256 bytes.  */
; 655  :             ARCH_DEP(vstorec) (&ipb, (headsize+bodysize-1), stgarea, USE_REAL_ADDR, regs);

  00989	8b 44 24 78	 mov	 eax, DWORD PTR headsize$10[rsp]
  0098d	8b 4c 24 64	 mov	 ecx, DWORD PTR bodysize$7[rsp]
  00991	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00995	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0099d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  009a2	41 b9 fe ff ff
	ff		 mov	 r9d, -2
  009a8	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR stgarea$13[rsp]
  009b0	0f b6 d0	 movzx	 edx, al
  009b3	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR ipb$17[rsp]
  009bb	e8 00 00 00 00	 call	 s370_vstorec

; 656  : 
; 657  :             /* Successful */
; 658  :             regs->GR(r1+1) = DIAG308_RC_OK;

  009c0	8b 84 24 b8 01
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  009c7	ff c0		 inc	 eax
  009c9	48 98		 cdqe
  009cb	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009d3	c7 84 c1 80 02
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 1

; 659  :             break;

  009de	eb 12		 jmp	 SHORT $LN18@s370_diagn
$LN96@s370_diagn:

; 660  :           }
; 661  : 
; 662  :         default:
; 663  :             ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  009e0	ba 06 00 00 00	 mov	 edx, 6
  009e5	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009ed	e8 00 00 00 00	 call	 s370_program_interrupt
$LN18@s370_diagn:

; 664  :         } /* end switch(r3) */
; 665  :         break;

  009f2	e9 0c 08 00 00	 jmp	 $LN2@s370_diagn
$LN97@s370_diagn:

; 666  : 
; 667  : #ifdef FEATURE_HERCULES_DIAGCALLS
; 668  :     case 0xF00:
; 669  :     /*---------------------------------------------------------------*/
; 670  :     /* Diagnose F00: Hercules normal mode                            */
; 671  :     /*---------------------------------------------------------------*/
; 672  :         /* If diag8opt is not enabled then we are not allowed
; 673  :          * to manipulate the real machine i.e. hercules itself
; 674  :          */
; 675  :         if(!(sysblk.diag8opt & DIAG8CMD_ENABLE))

  009f7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  009fe	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  00a05	83 e0 01	 and	 eax, 1
  00a08	85 c0		 test	 eax, eax
  00a0a	75 12		 jne	 SHORT $LN98@s370_diagn

; 676  :             ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00a0c	ba 06 00 00 00	 mov	 edx, 6
  00a11	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a19	e8 00 00 00 00	 call	 s370_program_interrupt
$LN98@s370_diagn:

; 677  : 
; 678  :         sysblk.instbreak = 0;

  00a1e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a25	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00a2b	0f ba f0 0a	 btr	 eax, 10
  00a2f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00a36	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
$LN22@s370_diagn:

; 679  :         SET_IC_TRACE;

  00a3c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a43	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  00a4a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR mask$14[rsp], rax
  00a52	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$3[rsp], 0
  00a5a	eb 0a		 jmp	 SHORT $LN25@s370_diagn
$LN23@s370_diagn:
  00a5c	8b 44 24 50	 mov	 eax, DWORD PTR i$3[rsp]
  00a60	ff c0		 inc	 eax
  00a62	89 44 24 50	 mov	 DWORD PTR i$3[rsp], eax
$LN25@s370_diagn:
  00a66	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR mask$14[rsp], 0
  00a6f	74 58		 je	 SHORT $LN24@s370_diagn
  00a71	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR mask$14[rsp]
  00a79	48 83 e0 01	 and	 rax, 1
  00a7d	48 85 c0	 test	 rax, rax
  00a80	74 32		 je	 SHORT $LN99@s370_diagn
  00a82	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$3[rsp]
  00a87	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00a8e	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00a96	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00a99	0f ba e8 1f	 bts	 eax, 31
  00a9d	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$3[rsp]
  00aa2	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00aa9	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00ab1	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN99@s370_diagn:
  00ab4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR mask$14[rsp]
  00abc	48 d1 e8	 shr	 rax, 1
  00abf	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR mask$14[rsp], rax
  00ac7	eb 93		 jmp	 SHORT $LN23@s370_diagn
$LN24@s370_diagn:
  00ac9	33 c0		 xor	 eax, eax
  00acb	85 c0		 test	 eax, eax
  00acd	0f 85 69 ff ff
	ff		 jne	 $LN22@s370_diagn

; 680  :         break;

  00ad3	e9 2b 07 00 00	 jmp	 $LN2@s370_diagn
$LN100@s370_diagn:

; 681  : 
; 682  :     case 0xF04:
; 683  :     /*---------------------------------------------------------------*/
; 684  :     /* Diagnose F04: Hercules single step mode                       */
; 685  :     /*---------------------------------------------------------------*/
; 686  :         /* If diag8opt is not enabled then we are not allowed
; 687  :          * to manipulate the real machine i.e. hercules itself
; 688  :          */
; 689  :         if(!(sysblk.diag8opt & DIAG8CMD_ENABLE))

  00ad8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00adf	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  00ae6	83 e0 01	 and	 eax, 1
  00ae9	85 c0		 test	 eax, eax
  00aeb	75 12		 jne	 SHORT $LN101@s370_diagn

; 690  :             ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00aed	ba 06 00 00 00	 mov	 edx, 6
  00af2	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00afa	e8 00 00 00 00	 call	 s370_program_interrupt
$LN101@s370_diagn:

; 691  : 
; 692  :         sysblk.instbreak = 1;

  00aff	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b06	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00b0c	0f ba e8 0a	 bts	 eax, 10
  00b10	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00b17	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
$LN28@s370_diagn:

; 693  :         SET_IC_TRACE;

  00b1d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b24	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  00b2b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR mask$15[rsp], rax
  00b33	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$4[rsp], 0
  00b3b	eb 0a		 jmp	 SHORT $LN31@s370_diagn
$LN29@s370_diagn:
  00b3d	8b 44 24 54	 mov	 eax, DWORD PTR i$4[rsp]
  00b41	ff c0		 inc	 eax
  00b43	89 44 24 54	 mov	 DWORD PTR i$4[rsp], eax
$LN31@s370_diagn:
  00b47	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR mask$15[rsp], 0
  00b50	74 58		 je	 SHORT $LN30@s370_diagn
  00b52	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR mask$15[rsp]
  00b5a	48 83 e0 01	 and	 rax, 1
  00b5e	48 85 c0	 test	 rax, rax
  00b61	74 32		 je	 SHORT $LN102@s370_diagn
  00b63	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$4[rsp]
  00b68	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00b6f	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00b77	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00b7a	0f ba e8 1f	 bts	 eax, 31
  00b7e	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR i$4[rsp]
  00b83	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00b8a	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00b92	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN102@s370_diagn:
  00b95	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR mask$15[rsp]
  00b9d	48 d1 e8	 shr	 rax, 1
  00ba0	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR mask$15[rsp], rax
  00ba8	eb 93		 jmp	 SHORT $LN29@s370_diagn
$LN30@s370_diagn:
  00baa	33 c0		 xor	 eax, eax
  00bac	85 c0		 test	 eax, eax
  00bae	0f 85 69 ff ff
	ff		 jne	 $LN28@s370_diagn

; 694  :         break;

  00bb4	e9 4a 06 00 00	 jmp	 $LN2@s370_diagn
$LN103@s370_diagn:

; 695  : 
; 696  :     case 0xF08:
; 697  :     /*---------------------------------------------------------------*/
; 698  :     /* Diagnose F08: Return Hercules instruction counter (32)        */
; 699  :     /*---------------------------------------------------------------*/
; 700  :         regs->GR_L( r1 ) = (U32) INSTCOUNT( regs );

  00bb9	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bc1	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00bc8	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bd0	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00bd7	8b 89 98 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1944]
  00bdd	48 03 88 90 07
	00 00		 add	 rcx, QWORD PTR [rax+1936]
  00be4	48 8b c1	 mov	 rax, rcx
  00be7	48 63 8c 24 b8
	01 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00bef	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00bf7	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 701  :         break;

  00bfe	e9 00 06 00 00	 jmp	 $LN2@s370_diagn
$LN104@s370_diagn:

; 702  : 
; 703  :     case 0xF09:
; 704  :     /*---------------------------------------------------------------*/
; 705  :     /* Diagnose F09: Return Hercules instruction counter (64)        */
; 706  :     /*---------------------------------------------------------------*/
; 707  :     {
; 708  :         // Operand register r3 bits 32-47 specify the option code and
; 709  :         // bits 48-63 specify the CPU Address for option code 1. For
; 710  :         // option code 0, operand register r3 bits 48-63 are ignored.
; 711  :         // Bits 0-31 of operand register r3 are also always ignored.
; 712  :         // Any option code other than 0 or 1 causes a Specification
; 713  :         // Exception Program Interrupt to occur.
; 714  :         //
; 715  :         // Option 0 = instruction count for entire system (all CPUs
; 716  :         // together). Option 1 = instruction count for specific CPU
; 717  :         // identified in bits 48-63 of r3.
; 718  :         //
; 719  :         // The register and bits that the 64-bit instruction count
; 720  :         // is returned in depends on: 1) whether z/Architecture mode
; 721  :         // is active or not, and 2) whether the specified operand-1
; 722  :         // r1 register number is even or odd.
; 723  :         //
; 724  :         // If operand-1 register r1 is an even numbered register,
; 725  :         // then the high-order bits 0-31 of the 64-bit instruction
; 726  :         // count is returned in bits 32-63 of the even numbered
; 727  :         // register, the low-order bits 32-63 the 64-bit instruction
; 728  :         // count is returned in bits 32-63 of the r1+1 odd numbered
; 729  :         // register and bits 0-31 of each register remain unmodified.
; 730  :         //
; 731  :         // If operand-1 register r1 specifies an odd numbered register
; 732  :         // however, then the 64-bit instruction count is returned in
; 733  :         // bits 0-63 of register r1 in z/Architecture mode, whereas a
; 734  :         // Specification Exception Program Check Interrupt occurs in
; 735  :         // both ESA/390 and System/370 architecture modes as 64-bit
; 736  :         // registers don't exist in either of those architectures.
; 737  :         //
; 738  :         // Precluding a Specification Exception Program Interrupt,
; 739  :         // Condition Code 0 is returned for option 0, whereas for
; 740  :         // option 1, Condition Code 0 is only returned if the CPU
; 741  :         // specified in bits 48-63 of the operand-3 register r3 is
; 742  :         // currently valid and online. Otherwise if the specified
; 743  :         // CPU is offline or does not exist in the configuration,
; 744  :         // Condition Code 3 is returned and the r1 or r1 and r1+1
; 745  :         // return value register(s) is/are not modified.
; 746  : 
; 747  :         U64   instcount=0;                  // Instruction count

  00c03	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR instcount$12[rsp], 0

; 748  :         U16   opt = regs->GR_LHH( r3 );     // Option code

  00c0f	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00c17	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c1f	0f b7 84 c1 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax*8+642]
  00c27	66 89 44 24 48	 mov	 WORD PTR opt$1[rsp], ax

; 749  : 
; 750  :         if (regs->arch_mode != ARCH_900_IDX)// Not 64-bit architecture?

  00c2c	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c34	83 78 64 02	 cmp	 DWORD PTR [rax+100], 2
  00c38	74 29		 je	 SHORT $LN105@s370_diagn

; 751  :             ODD_CHECK( r1, regs );          // 64-bit regs don't exist!

  00c3a	8b 84 24 b8 01
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  00c41	83 e0 01	 and	 eax, 1
  00c44	85 c0		 test	 eax, eax
  00c46	74 1b		 je	 SHORT $LN106@s370_diagn
  00c48	ba 06 00 00 00	 mov	 edx, 6
  00c4d	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c55	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c5d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN106@s370_diagn:
$LN105@s370_diagn:

; 752  : 
; 753  :         if (opt > 1)                        // Unsupported option?

  00c63	0f b7 44 24 48	 movzx	 eax, WORD PTR opt$1[rsp]
  00c68	83 f8 01	 cmp	 eax, 1
  00c6b	7e 20		 jle	 SHORT $LN107@s370_diagn

; 754  :         {
; 755  :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  00c6d	ba 06 00 00 00	 mov	 edx, 6
  00c72	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c7a	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c82	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]

; 756  :         }

  00c88	e9 e5 00 00 00	 jmp	 $LN108@s370_diagn
$LN107@s370_diagn:

; 757  :         else if (opt == 1)                  // Count for specific CPU?

  00c8d	0f b7 44 24 48	 movzx	 eax, WORD PTR opt$1[rsp]
  00c92	83 f8 01	 cmp	 eax, 1
  00c95	0f 85 ac 00 00
	00		 jne	 $LN109@s370_diagn

; 758  :         {
; 759  :             int cpu = regs->GR_LHL( r3 );   // Get desired CPU from r3

  00c9b	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00ca3	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00cab	0f b7 84 c1 80
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax*8+640]
  00cb3	89 44 24 4c	 mov	 DWORD PTR cpu$2[rsp], eax

; 760  : 
; 761  :             if (cpu < 0 || cpu >= sysblk.maxcpu || !IS_CPU_ONLINE( cpu ))

  00cb7	83 7c 24 4c 00	 cmp	 DWORD PTR cpu$2[rsp], 0
  00cbc	7c 2a		 jl	 SHORT $LN112@s370_diagn
  00cbe	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00cc5	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00ccb	39 44 24 4c	 cmp	 DWORD PTR cpu$2[rsp], eax
  00ccf	7d 17		 jge	 SHORT $LN112@s370_diagn
  00cd1	48 63 44 24 4c	 movsxd	 rax, DWORD PTR cpu$2[rsp]
  00cd6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00cdd	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00ce6	75 11		 jne	 SHORT $LN111@s370_diagn
$LN112@s370_diagn:

; 762  :             {
; 763  :                 regs->psw.cc = 3;           // CPU is invalid/offline

  00ce8	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cf0	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 764  :                 break;                      // We are done

  00cf4	e9 0a 05 00 00	 jmp	 $LN2@s370_diagn
$LN111@s370_diagn:

; 765  :             }
; 766  : 
; 767  :             /* Retrieve the requested CPU's instruction count */
; 768  :             instcount = sysblk.regs[ cpu ]->prevcount  // (U64)

  00cf9	48 63 44 24 4c	 movsxd	 rax, DWORD PTR cpu$2[rsp]
  00cfe	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00d05	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00d0d	48 63 4c 24 4c	 movsxd	 rcx, DWORD PTR cpu$2[rsp]
  00d12	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00d19	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00d21	8b 89 98 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1944]
  00d27	48 03 88 90 07
	00 00		 add	 rcx, QWORD PTR [rax+1936]
  00d2e	48 8b c1	 mov	 rax, rcx
  00d31	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR instcount$12[rsp], rax

; 769  :                       + sysblk.regs[ cpu ]->instcount; // (U32)
; 770  :             regs->psw.cc = 0;

  00d39	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d41	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 771  :         }

  00d45	eb 2b		 jmp	 SHORT $LN110@s370_diagn
$LN109@s370_diagn:

; 772  :         else if (opt == 0)                  // Global system counter?

  00d47	0f b7 44 24 48	 movzx	 eax, WORD PTR opt$1[rsp]
  00d4c	85 c0		 test	 eax, eax
  00d4e	75 22		 jne	 SHORT $LN113@s370_diagn

; 773  :         {
; 774  :             instcount = sysblk.instcount;   // Get total for ALL CPUs

  00d50	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00d57	48 8b 80 80 14
	00 00		 mov	 rax, QWORD PTR [rax+5248]
  00d5e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR instcount$12[rsp], rax

; 775  :             regs->psw.cc = 0;

  00d66	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d6e	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN113@s370_diagn:
$LN110@s370_diagn:
$LN108@s370_diagn:

; 776  :         }
; 777  : 
; 778  :         /* Return the instruction count in the requested register(s) */
; 779  :         if (r1 & 1)

  00d72	8b 84 24 b8 01
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  00d79	83 e0 01	 and	 eax, 1
  00d7c	85 c0		 test	 eax, eax
  00d7e	74 22		 je	 SHORT $LN114@s370_diagn

; 780  :             regs->GR_G( r1 ) = instcount;   // Contiguous 64-bit count

  00d80	48 63 84 24 b8
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00d88	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d90	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR instcount$12[rsp]
  00d98	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx
  00da0	eb 59		 jmp	 SHORT $LN115@s370_diagn
$LN114@s370_diagn:

; 781  :         else
; 782  :         {
; 783  :             /* Place the high-order 32 bits of the 64-bit count into
; 784  :                bits 32-63 of the even numbered register and place the
; 785  :                low-order 32 bits of the 64-bit count into bits 32-63
; 786  :                of the r1+1 odd numbered register. For S/370 and S/390
; 787  :                mode this corresponds to bits 0-31 of the register pair
; 788  :                since registers are only 32 bits wide in 370 and 390.
; 789  :             */
; 790  :             regs->GR_L( r1    ) = (U32)((instcount >> 32) & 0xFFFFFFFF);

  00da2	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR instcount$12[rsp]
  00daa	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00dae	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00db3	48 23 c1	 and	 rax, rcx
  00db6	48 63 8c 24 b8
	01 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00dbe	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00dc6	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 791  :             regs->GR_L( r1 + 1) = (U32)((instcount      ) & 0xFFFFFFFF);

  00dcd	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00dd2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR instcount$12[rsp]
  00dda	48 23 c8	 and	 rcx, rax
  00ddd	48 8b c1	 mov	 rax, rcx
  00de0	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  00de7	ff c1		 inc	 ecx
  00de9	48 63 c9	 movsxd	 rcx, ecx
  00dec	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00df4	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN115@s370_diagn:

; 792  :         }
; 793  : 
; 794  :         break;

  00dfb	e9 03 04 00 00	 jmp	 $LN2@s370_diagn
$LN116@s370_diagn:

; 795  :     }
; 796  : 
; 797  :     case 0xF0C:
; 798  :     /*---------------------------------------------------------------*/
; 799  :     /* Diagnose F0C: Set/reset bad frame indicator                   */
; 800  :     /*---------------------------------------------------------------*/
; 801  :         /* If diag8opt is not enabled then we are not allowed
; 802  :          * to manipulate the real machine i.e. hercules itself
; 803  :          */
; 804  :         if(!(sysblk.diag8opt & DIAG8CMD_ENABLE))

  00e00	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00e07	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  00e0e	83 e0 01	 and	 eax, 1
  00e11	85 c0		 test	 eax, eax
  00e13	75 12		 jne	 SHORT $LN117@s370_diagn

; 805  :             ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00e15	ba 06 00 00 00	 mov	 edx, 6
  00e1a	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e22	e8 00 00 00 00	 call	 s370_program_interrupt
$LN117@s370_diagn:

; 806  : 
; 807  :         /* Load 4K block address from R2 register */
; 808  :         n = regs->GR_L(r3) & ADDRESS_MAXWRAP(regs);

  00e27	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00e2f	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e37	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00e3e	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00e43	89 44 24 44	 mov	 DWORD PTR n$[rsp], eax

; 809  : 
; 810  :         /* Convert real address to absolute address */
; 811  :         n = APPLY_PREFIXING (n, regs->PX);

  00e47	8b 44 24 44	 mov	 eax, DWORD PTR n$[rsp]
  00e4b	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00e51	48 85 c0	 test	 rax, rax
  00e54	74 24		 je	 SHORT $LN138@s370_diagn
  00e56	8b 44 24 44	 mov	 eax, DWORD PTR n$[rsp]
  00e5a	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00e60	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e68	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00e6b	48 3b c1	 cmp	 rax, rcx
  00e6e	74 0a		 je	 SHORT $LN138@s370_diagn
  00e70	8b 44 24 44	 mov	 eax, DWORD PTR n$[rsp]
  00e74	89 44 24 7c	 mov	 DWORD PTR tv586[rsp], eax
  00e78	eb 17		 jmp	 SHORT $LN139@s370_diagn
$LN138@s370_diagn:
  00e7a	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e82	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00e85	8b 4c 24 44	 mov	 ecx, DWORD PTR n$[rsp]
  00e89	33 c8		 xor	 ecx, eax
  00e8b	8b c1		 mov	 eax, ecx
  00e8d	89 44 24 7c	 mov	 DWORD PTR tv586[rsp], eax
$LN139@s370_diagn:
  00e91	8b 44 24 7c	 mov	 eax, DWORD PTR tv586[rsp]
  00e95	89 44 24 44	 mov	 DWORD PTR n$[rsp], eax

; 812  : 
; 813  :         /* Addressing exception if block is outside main storage */
; 814  :         if ( n > regs->mainlim )

  00e99	8b 44 24 44	 mov	 eax, DWORD PTR n$[rsp]
  00e9d	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ea5	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  00eac	76 17		 jbe	 SHORT $LN118@s370_diagn

; 815  :         {
; 816  :             ARCH_DEP(program_interrupt) (regs, PGM_ADDRESSING_EXCEPTION);

  00eae	ba 05 00 00 00	 mov	 edx, 5
  00eb3	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ebb	e8 00 00 00 00	 call	 s370_program_interrupt

; 817  :             break;

  00ec0	e9 3e 03 00 00	 jmp	 $LN2@s370_diagn
$LN118@s370_diagn:

; 818  :         }
; 819  : 
; 820  :         /* Update bad-frame bit based on low-order bit of R1 register.
; 821  :            Note: we must use the internal "_xxx_storage_key" functions
; 822  :            to directly set/clear the internal STORKEY_BADFRM bit.
; 823  :         */
; 824  :         if (regs->GR_L(r1) & STORKEY_BADFRM)

  00ec5	48 63 84 24 b8
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00ecd	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ed5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00edc	83 e0 01	 and	 eax, 1
  00edf	85 c0		 test	 eax, eax
  00ee1	74 12		 je	 SHORT $LN119@s370_diagn

; 825  :             ARCH_DEP( _or_storage_key )( n, STORKEY_BADFRM, SKEY_K );

  00ee3	8b 44 24 44	 mov	 eax, DWORD PTR n$[rsp]
  00ee7	41 b0 02	 mov	 r8b, 2
  00eea	b2 01		 mov	 dl, 1
  00eec	8b c8		 mov	 ecx, eax
  00eee	e8 00 00 00 00	 call	 s370__or_storage_key
  00ef3	eb 10		 jmp	 SHORT $LN120@s370_diagn
$LN119@s370_diagn:

; 826  :         else
; 827  :             ARCH_DEP( _and_storage_key )( n, STORKEY_BADFRM, SKEY_K );

  00ef5	8b 44 24 44	 mov	 eax, DWORD PTR n$[rsp]
  00ef9	41 b0 02	 mov	 r8b, 2
  00efc	b2 01		 mov	 dl, 1
  00efe	8b c8		 mov	 ecx, eax
  00f00	e8 00 00 00 00	 call	 s370__and_storage_key
$LN120@s370_diagn:

; 828  : 
; 829  :         break;

  00f05	e9 f9 02 00 00	 jmp	 $LN2@s370_diagn
$LN121@s370_diagn:

; 830  : 
; 831  :     case 0xF10:
; 832  :     /*---------------------------------------------------------------*/
; 833  :     /* Diagnose F10: Hercules CPU stop                               */
; 834  :     /*---------------------------------------------------------------*/
; 835  :         /* If diag8opt is not enabled then we are not allowed
; 836  :          * to manipulate the real machine i.e. hercules itself
; 837  :          */
; 838  :         if(!(sysblk.diag8opt & DIAG8CMD_ENABLE))

  00f0a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00f11	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  00f18	83 e0 01	 and	 eax, 1
  00f1b	85 c0		 test	 eax, eax
  00f1d	75 12		 jne	 SHORT $LN122@s370_diagn

; 839  :             ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00f1f	ba 06 00 00 00	 mov	 edx, 6
  00f24	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f2c	e8 00 00 00 00	 call	 s370_program_interrupt
$LN122@s370_diagn:

; 840  : 
; 841  :         regs->cpustate = CPUSTATE_STOPPING;

  00f31	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f39	c6 40 60 02	 mov	 BYTE PTR [rax+96], 2
$LN34@s370_diagn:

; 842  :         ON_IC_INTERRUPT(regs);

  00f3d	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f45	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00f48	0f ba e8 1f	 bts	 eax, 31
  00f4c	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f54	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00f57	33 c0		 xor	 eax, eax
  00f59	85 c0		 test	 eax, eax
  00f5b	75 e0		 jne	 SHORT $LN34@s370_diagn

; 843  :         break;

  00f5d	e9 a1 02 00 00	 jmp	 $LN2@s370_diagn
$LN123@s370_diagn:

; 844  : 
; 845  : #if defined(_FEATURE_HOST_RESOURCE_ACCESS_FACILITY)
; 846  :     case 0xF18:
; 847  :     /*---------------------------------------------------------------*/
; 848  :     /* Diagnose F18: Hercules Access Host Resource                   */
; 849  :     /*---------------------------------------------------------------*/
; 850  :         ARCH_DEP(diagf18_call) (r1, r3, regs);

  00f62	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00f6a	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  00f71	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  00f78	e8 00 00 00 00	 call	 s370_diagf18_call

; 851  :         break;

  00f7d	e9 81 02 00 00	 jmp	 $LN2@s370_diagn
$LN124@s370_diagn:
$LN35@s370_diagn:

; 852  : #endif /* defined(_FEATURE_HOST_RESOURCE_ACCESS_FACILITY) */
; 853  : 
; 854  :     case 0xFF8:
; 855  :     /*---------------------------------------------------------------*/
; 856  :     /* Diagnose FF8: Hercules Infinite Loop (Malfunctioning CPU)     */
; 857  :     /*---------------------------------------------------------------*/
; 858  :         while(1);   /* (loop forever)  */

  00f82	33 c0		 xor	 eax, eax
  00f84	83 f8 01	 cmp	 eax, 1
  00f87	74 02		 je	 SHORT $LN36@s370_diagn
  00f89	eb f7		 jmp	 SHORT $LN35@s370_diagn
$LN36@s370_diagn:

; 859  :         break;      /* (never reached) */

  00f8b	e9 73 02 00 00	 jmp	 $LN2@s370_diagn
$LN125@s370_diagn:
$LN39@s370_diagn:

; 860  : 
; 861  :     case 0xFFC:
; 862  :     /*---------------------------------------------------------------*/
; 863  :     /* Diagnose FFC: Hercules SLOW Instruction (Malfunctioning CPU)  */
; 864  :     /*---------------------------------------------------------------*/
; 865  :         SLEEP(300); /* (300 seconds = 5 minutes!) */

  00f90	c7 44 24 58 2c
	01 00 00	 mov	 DWORD PTR rc$5[rsp], 300 ; 0000012cH
$LN40@s370_diagn:
  00f98	83 7c 24 58 00	 cmp	 DWORD PTR rc$5[rsp], 0
  00f9d	74 1d		 je	 SHORT $LN41@s370_diagn
  00f9f	8b 4c 24 58	 mov	 ecx, DWORD PTR rc$5[rsp]
  00fa3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sleep
  00fa9	89 44 24 58	 mov	 DWORD PTR rc$5[rsp], eax
  00fad	83 7c 24 58 00	 cmp	 DWORD PTR rc$5[rsp], 0
  00fb2	74 06		 je	 SHORT $LN126@s370_diagn
  00fb4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield
$LN126@s370_diagn:
  00fba	eb dc		 jmp	 SHORT $LN40@s370_diagn
$LN41@s370_diagn:
  00fbc	33 c0		 xor	 eax, eax
  00fbe	85 c0		 test	 eax, eax
  00fc0	75 ce		 jne	 SHORT $LN39@s370_diagn

; 866  :         break;

  00fc2	e9 3c 02 00 00	 jmp	 $LN2@s370_diagn
$LN127@s370_diagn:

; 867  : 
; 868  :     case 0xFFD:
; 869  :     /*---------------------------------------------------------------*/
; 870  :     /* Diagnose FFD: Hercules Dummy "Slow(?)" Instruction            */
; 871  :     /*---------------------------------------------------------------*/
; 872  :     {
; 873  :         /* r1 = microseconds */
; 874  :         unsigned int secs  = regs->GR_L(r1) / ONE_MILLION;

  00fc7	48 63 84 24 b8
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00fcf	33 d2		 xor	 edx, edx
  00fd1	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00fd9	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00fe0	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00fe5	f7 f1		 div	 ecx
  00fe7	89 84 24 a8 00
	00 00		 mov	 DWORD PTR secs$16[rsp], eax

; 875  :         unsigned int usecs = regs->GR_L(r1) % ONE_MILLION;

  00fee	48 63 84 24 b8
	01 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00ff6	33 d2		 xor	 edx, edx
  00ff8	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01000	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  01007	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  0100c	f7 f1		 div	 ecx
  0100e	8b c2		 mov	 eax, edx
  01010	89 84 24 80 00
	00 00		 mov	 DWORD PTR usecs$11[rsp], eax

; 876  :         unsigned int i;
; 877  :         for (i=0; i < secs; ++i)

  01017	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$8[rsp], 0
  0101f	eb 0a		 jmp	 SHORT $LN44@s370_diagn
$LN42@s370_diagn:
  01021	8b 44 24 68	 mov	 eax, DWORD PTR i$8[rsp]
  01025	ff c0		 inc	 eax
  01027	89 44 24 68	 mov	 DWORD PTR i$8[rsp], eax
$LN44@s370_diagn:
  0102b	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR secs$16[rsp]
  01032	39 44 24 68	 cmp	 DWORD PTR i$8[rsp], eax
  01036	73 34		 jae	 SHORT $LN43@s370_diagn
$LN47@s370_diagn:

; 878  :             SLEEP(1);       /* (sleep one second at a time) */

  01038	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR rc$6[rsp], 1
$LN48@s370_diagn:
  01040	83 7c 24 5c 00	 cmp	 DWORD PTR rc$6[rsp], 0
  01045	74 1d		 je	 SHORT $LN49@s370_diagn
  01047	8b 4c 24 5c	 mov	 ecx, DWORD PTR rc$6[rsp]
  0104b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sleep
  01051	89 44 24 5c	 mov	 DWORD PTR rc$6[rsp], eax
  01055	83 7c 24 5c 00	 cmp	 DWORD PTR rc$6[rsp], 0
  0105a	74 06		 je	 SHORT $LN128@s370_diagn
  0105c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield
$LN128@s370_diagn:
  01062	eb dc		 jmp	 SHORT $LN48@s370_diagn
$LN49@s370_diagn:
  01064	33 c0		 xor	 eax, eax
  01066	85 c0		 test	 eax, eax
  01068	75 ce		 jne	 SHORT $LN47@s370_diagn
  0106a	eb b5		 jmp	 SHORT $LN42@s370_diagn
$LN43@s370_diagn:

; 879  :         if (usecs)

  0106c	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR usecs$11[rsp], 0
  01074	74 0d		 je	 SHORT $LN129@s370_diagn

; 880  :             usleep(usecs);  /* (remaining microseconds, if any) */

  01076	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR usecs$11[rsp]
  0107d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN129@s370_diagn:

; 881  :         break;

  01083	e9 7b 01 00 00	 jmp	 $LN2@s370_diagn
$LN130@s370_diagn:

; 882  :     }
; 883  : 
; 884  : #endif /*FEATURE_HERCULES_DIAGCALLS*/
; 885  : 
; 886  :     default:
; 887  :     /*---------------------------------------------------------------*/
; 888  :     /* Diagnose xxx: Invalid function code or Power-Off diagnose     */
; 889  :     /*---------------------------------------------------------------*/
; 890  : 
; 891  :         if( HDC4(debug_diagnose, code, r1, r3, regs) )

  01088	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_diagnose
  0108f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  01093	74 2e		 je	 SHORT $LN140@s370_diagn
  01095	4c 8b 8c 24 b0
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0109d	44 8b 84 24 c0
	01 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  010a5	8b 94 24 b8 01
	00 00		 mov	 edx, DWORD PTR r1$[rsp]
  010ac	8b 4c 24 60	 mov	 ecx, DWORD PTR code$[rsp]
  010b0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_diagnose
  010b7	ff 10		 call	 QWORD PTR [rax]
  010b9	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv686[rsp], rax
  010c1	eb 0c		 jmp	 SHORT $LN141@s370_diagn
$LN140@s370_diagn:
  010c3	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv686[rsp], 0
$LN141@s370_diagn:
  010cf	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR tv686[rsp], 0
  010d8	74 05		 je	 SHORT $LN131@s370_diagn

; 892  :             return;

  010da	e9 24 01 00 00	 jmp	 $LN1@s370_diagn
$LN131@s370_diagn:

; 893  : 
; 894  :         /* Power Off diagnose on 4361, 9371, 9373, 9375, 9377, 9221: */
; 895  :         /*                                                           */
; 896  :         /*          DS 0H                                            */
; 897  :         /*          DC X'8302',S(SHUTDATA)     MUST BE R0 AND R2     */
; 898  :         /*          ...                                              */
; 899  :         /*          DS 0H                                            */
; 900  :         /* SHUTDATA DC X'0000FFFF'             MUST BE X'0000FFFF'   */
; 901  : 
; 902  :         if (0 == r1 && 2 == r3
; 903  :              && sysblk.cpuversion != 0xFF
; 904  :              && (sysblk.cpumodel == 0x4361

  010df	83 bc 24 b8 01
	00 00 00	 cmp	 DWORD PTR r1$[rsp], 0
  010e7	0f 85 f1 00 00
	00		 jne	 $LN132@s370_diagn
  010ed	83 bc 24 c0 01
	00 00 02	 cmp	 DWORD PTR r3$[rsp], 2
  010f5	0f 85 e3 00 00
	00		 jne	 $LN132@s370_diagn
  010fb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01102	0f b6 80 d6 00
	00 00		 movzx	 eax, BYTE PTR [rax+214]
  01109	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0110e	0f 84 ca 00 00
	00		 je	 $LN132@s370_diagn
  01114	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0111b	0f b7 80 d4 00
	00 00		 movzx	 eax, WORD PTR [rax+212]
  01122	3d 61 43 00 00	 cmp	 eax, 17249		; 00004361H
  01127	74 33		 je	 SHORT $LN133@s370_diagn
  01129	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01130	0f b7 80 d4 00
	00 00		 movzx	 eax, WORD PTR [rax+212]
  01137	25 f9 ff 00 00	 and	 eax, 65529		; 0000fff9H
  0113c	3d 71 93 00 00	 cmp	 eax, 37745		; 00009371H
  01141	74 19		 je	 SHORT $LN133@s370_diagn
  01143	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0114a	0f b7 80 d4 00
	00 00		 movzx	 eax, WORD PTR [rax+212]
  01151	3d 21 92 00 00	 cmp	 eax, 37409		; 00009221H
  01156	0f 85 82 00 00
	00		 jne	 $LN132@s370_diagn
$LN133@s370_diagn:

; 905  :               || (sysblk.cpumodel & 0xFFF9) == 0x9371   /* (937X) */
; 906  :               || sysblk.cpumodel == 0x9221)
; 907  :            )
; 908  :         {
; 909  :             if (0x0000FFFF == ARCH_DEP(vfetch4)(effective_addr2, b2, regs))

  0115c	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  01164	8b 94 24 c8 01
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  0116b	8b 8c 24 d0 01
	00 00		 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  01172	e8 00 00 00 00	 call	 s370_vfetch4
  01177	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  0117c	75 60		 jne	 SHORT $LN134@s370_diagn

; 910  :             {
; 911  :                 /* If diag8opt is not enabled then we are not allowed
; 912  :                  * to manipulate the real machine i.e. hercules itself
; 913  :                  */
; 914  :                 if(!(sysblk.diag8opt & DIAG8CMD_ENABLE))

  0117e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01185	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  0118c	83 e0 01	 and	 eax, 1
  0118f	85 c0		 test	 eax, eax
  01191	75 12		 jne	 SHORT $LN135@s370_diagn

; 915  :                     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  01193	ba 06 00 00 00	 mov	 edx, 6
  01198	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  011a0	e8 00 00 00 00	 call	 s370_program_interrupt
$LN135@s370_diagn:

; 916  : 
; 917  :                 regs->cpustate = CPUSTATE_STOPPING;

  011a5	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  011ad	c6 40 60 02	 mov	 BYTE PTR [rax+96], 2
$LN52@s370_diagn:

; 918  :                 ON_IC_INTERRUPT(regs);

  011b1	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  011b9	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  011bc	0f ba e8 1f	 bts	 eax, 31
  011c0	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  011c8	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  011cb	33 c0		 xor	 eax, eax
  011cd	85 c0		 test	 eax, eax
  011cf	75 e0		 jne	 SHORT $LN52@s370_diagn

; 919  : 
; 920  :                 /* Release the configuration */
; 921  :                 do_shutdown();

  011d1	e8 00 00 00 00	 call	 do_shutdown

; 922  : 
; 923  :                 /* Power Off: exit hercules */
; 924  :                 exit(0);

  011d6	33 c9		 xor	 ecx, ecx
  011d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN134@s370_diagn:
$LN132@s370_diagn:

; 925  :             }
; 926  :         }
; 927  : 
; 928  : #if defined(FEATURE_S370_CHANNEL) && defined(OPTION_NOP_MODEL158_DIAGNOSE)
; 929  :         if (regs->cpumodel != 0x0158)

  011de	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  011e6	0f b7 40 3c	 movzx	 eax, WORD PTR [rax+60]
  011ea	3d 58 01 00 00	 cmp	 eax, 344		; 00000158H
  011ef	74 12		 je	 SHORT $LN136@s370_diagn

; 930  : #endif
; 931  :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  011f1	ba 06 00 00 00	 mov	 edx, 6
  011f6	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  011fe	e8 00 00 00 00	 call	 s370_program_interrupt
$LN136@s370_diagn:
$LN2@s370_diagn:
$LN1@s370_diagn:
$LN137@s370_diagn:

; 932  :         return;
; 933  : 
; 934  :     } /* end switch(code) */
; 935  : 
; 936  :     return;
; 937  : 
; 938  : } /* end function diagnose_call */

  01203	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0120b	48 33 cc	 xor	 rcx, rsp
  0120e	e8 00 00 00 00	 call	 __security_check_cookie
  01213	48 81 c4 a0 01
	00 00		 add	 rsp, 416		; 000001a0H
  0121a	5f		 pop	 rdi
  0121b	c3		 ret	 0
$LN149@s370_diagn:
  0121c	00 00 00 00	 DD	 $LN59@s370_diagn
  01220	00 00 00 00	 DD	 $LN60@s370_diagn
  01224	00 00 00 00	 DD	 $LN62@s370_diagn
  01228	00 00 00 00	 DD	 $LN53@s370_diagn
  0122c	00 00 00 00	 DD	 $LN63@s370_diagn
  01230	00 00 00 00	 DD	 $LN57@s370_diagn
  01234	00 00 00 00	 DD	 $LN64@s370_diagn
  01238	00 00 00 00	 DD	 $LN65@s370_diagn
  0123c	00 00 00 00	 DD	 $LN66@s370_diagn
  01240	00 00 00 00	 DD	 $LN58@s370_diagn
  01244	00 00 00 00	 DD	 $LN67@s370_diagn
  01248	00 00 00 00	 DD	 $LN68@s370_diagn
  0124c	00 00 00 00	 DD	 $LN69@s370_diagn
  01250	00 00 00 00	 DD	 $LN70@s370_diagn
  01254	00 00 00 00	 DD	 $LN130@s370_diagn
$LN148@s370_diagn:
  01258	00		 DB	 0
  01259	0e		 DB	 14
  0125a	0e		 DB	 14
  0125b	0e		 DB	 14
  0125c	0e		 DB	 14
  0125d	0e		 DB	 14
  0125e	0e		 DB	 14
  0125f	0e		 DB	 14
  01260	01		 DB	 1
  01261	0e		 DB	 14
  01262	0e		 DB	 14
  01263	0e		 DB	 14
  01264	02		 DB	 2
  01265	0e		 DB	 14
  01266	0e		 DB	 14
  01267	0e		 DB	 14
  01268	0e		 DB	 14
  01269	0e		 DB	 14
  0126a	0e		 DB	 14
  0126b	0e		 DB	 14
  0126c	0e		 DB	 14
  0126d	0e		 DB	 14
  0126e	0e		 DB	 14
  0126f	0e		 DB	 14
  01270	0e		 DB	 14
  01271	0e		 DB	 14
  01272	0e		 DB	 14
  01273	0e		 DB	 14
  01274	0e		 DB	 14
  01275	0e		 DB	 14
  01276	0e		 DB	 14
  01277	03		 DB	 3
  01278	0e		 DB	 14
  01279	0e		 DB	 14
  0127a	0e		 DB	 14
  0127b	0e		 DB	 14
  0127c	04		 DB	 4
  0127d	0e		 DB	 14
  0127e	0e		 DB	 14
  0127f	0e		 DB	 14
  01280	0e		 DB	 14
  01281	0e		 DB	 14
  01282	0e		 DB	 14
  01283	0e		 DB	 14
  01284	0e		 DB	 14
  01285	0e		 DB	 14
  01286	0e		 DB	 14
  01287	0e		 DB	 14
  01288	0e		 DB	 14
  01289	0e		 DB	 14
  0128a	0e		 DB	 14
  0128b	0e		 DB	 14
  0128c	0e		 DB	 14
  0128d	0e		 DB	 14
  0128e	0e		 DB	 14
  0128f	0e		 DB	 14
  01290	0e		 DB	 14
  01291	0e		 DB	 14
  01292	0e		 DB	 14
  01293	0e		 DB	 14
  01294	0e		 DB	 14
  01295	0e		 DB	 14
  01296	0e		 DB	 14
  01297	0e		 DB	 14
  01298	0e		 DB	 14
  01299	0e		 DB	 14
  0129a	0e		 DB	 14
  0129b	0e		 DB	 14
  0129c	05		 DB	 5
  0129d	0e		 DB	 14
  0129e	0e		 DB	 14
  0129f	0e		 DB	 14
  012a0	0e		 DB	 14
  012a1	0e		 DB	 14
  012a2	0e		 DB	 14
  012a3	0e		 DB	 14
  012a4	0e		 DB	 14
  012a5	0e		 DB	 14
  012a6	0e		 DB	 14
  012a7	0e		 DB	 14
  012a8	0e		 DB	 14
  012a9	0e		 DB	 14
  012aa	0e		 DB	 14
  012ab	0e		 DB	 14
  012ac	0e		 DB	 14
  012ad	0e		 DB	 14
  012ae	0e		 DB	 14
  012af	0e		 DB	 14
  012b0	0e		 DB	 14
  012b1	0e		 DB	 14
  012b2	0e		 DB	 14
  012b3	0e		 DB	 14
  012b4	06		 DB	 6
  012b5	0e		 DB	 14
  012b6	0e		 DB	 14
  012b7	0e		 DB	 14
  012b8	07		 DB	 7
  012b9	0e		 DB	 14
  012ba	0e		 DB	 14
  012bb	0e		 DB	 14
  012bc	08		 DB	 8
  012bd	0e		 DB	 14
  012be	0e		 DB	 14
  012bf	0e		 DB	 14
  012c0	0e		 DB	 14
  012c1	0e		 DB	 14
  012c2	0e		 DB	 14
  012c3	0e		 DB	 14
  012c4	0e		 DB	 14
  012c5	0e		 DB	 14
  012c6	0e		 DB	 14
  012c7	0e		 DB	 14
  012c8	0e		 DB	 14
  012c9	0e		 DB	 14
  012ca	0e		 DB	 14
  012cb	0e		 DB	 14
  012cc	0e		 DB	 14
  012cd	0e		 DB	 14
  012ce	0e		 DB	 14
  012cf	0e		 DB	 14
  012d0	0e		 DB	 14
  012d1	0e		 DB	 14
  012d2	0e		 DB	 14
  012d3	0e		 DB	 14
  012d4	0e		 DB	 14
  012d5	0e		 DB	 14
  012d6	0e		 DB	 14
  012d7	0e		 DB	 14
  012d8	0e		 DB	 14
  012d9	0e		 DB	 14
  012da	0e		 DB	 14
  012db	0e		 DB	 14
  012dc	0e		 DB	 14
  012dd	0e		 DB	 14
  012de	0e		 DB	 14
  012df	0e		 DB	 14
  012e0	0e		 DB	 14
  012e1	0e		 DB	 14
  012e2	0e		 DB	 14
  012e3	0e		 DB	 14
  012e4	0e		 DB	 14
  012e5	0e		 DB	 14
  012e6	0e		 DB	 14
  012e7	0e		 DB	 14
  012e8	0e		 DB	 14
  012e9	0e		 DB	 14
  012ea	0e		 DB	 14
  012eb	0e		 DB	 14
  012ec	0e		 DB	 14
  012ed	0e		 DB	 14
  012ee	0e		 DB	 14
  012ef	0e		 DB	 14
  012f0	0e		 DB	 14
  012f1	0e		 DB	 14
  012f2	0e		 DB	 14
  012f3	0e		 DB	 14
  012f4	09		 DB	 9
  012f5	0e		 DB	 14
  012f6	0e		 DB	 14
  012f7	0e		 DB	 14
  012f8	0e		 DB	 14
  012f9	0e		 DB	 14
  012fa	0e		 DB	 14
  012fb	0e		 DB	 14
  012fc	0a		 DB	 10
  012fd	0e		 DB	 14
  012fe	0e		 DB	 14
  012ff	0e		 DB	 14
  01300	0b		 DB	 11
  01301	0e		 DB	 14
  01302	0e		 DB	 14
  01303	0e		 DB	 14
  01304	0e		 DB	 14
  01305	0e		 DB	 14
  01306	0e		 DB	 14
  01307	0e		 DB	 14
  01308	0c		 DB	 12
  01309	0e		 DB	 14
  0130a	0e		 DB	 14
  0130b	0e		 DB	 14
  0130c	0e		 DB	 14
  0130d	0e		 DB	 14
  0130e	0e		 DB	 14
  0130f	0e		 DB	 14
  01310	0e		 DB	 14
  01311	0e		 DB	 14
  01312	0e		 DB	 14
  01313	0e		 DB	 14
  01314	0e		 DB	 14
  01315	0e		 DB	 14
  01316	0e		 DB	 14
  01317	0e		 DB	 14
  01318	0e		 DB	 14
  01319	0e		 DB	 14
  0131a	0e		 DB	 14
  0131b	0e		 DB	 14
  0131c	0e		 DB	 14
  0131d	0e		 DB	 14
  0131e	0e		 DB	 14
  0131f	0e		 DB	 14
  01320	0e		 DB	 14
  01321	0e		 DB	 14
  01322	0e		 DB	 14
  01323	0e		 DB	 14
  01324	0e		 DB	 14
  01325	0e		 DB	 14
  01326	0e		 DB	 14
  01327	0e		 DB	 14
  01328	0e		 DB	 14
  01329	0e		 DB	 14
  0132a	0e		 DB	 14
  0132b	0e		 DB	 14
  0132c	0e		 DB	 14
  0132d	0e		 DB	 14
  0132e	0e		 DB	 14
  0132f	0e		 DB	 14
  01330	0e		 DB	 14
  01331	0e		 DB	 14
  01332	0e		 DB	 14
  01333	0e		 DB	 14
  01334	0d		 DB	 13
  01335	0f 1f 00	 npad	 3
$LN147@s370_diagn:
  01338	00 00 00 00	 DD	 $LN72@s370_diagn
  0133c	00 00 00 00	 DD	 $LN73@s370_diagn
  01340	00 00 00 00	 DD	 $LN78@s370_diagn
  01344	00 00 00 00	 DD	 $LN79@s370_diagn
  01348	00 00 00 00	 DD	 $LN80@s370_diagn
  0134c	00 00 00 00	 DD	 $LN81@s370_diagn
  01350	00 00 00 00	 DD	 $LN83@s370_diagn
  01354	00 00 00 00	 DD	 $LN84@s370_diagn
  01358	00 00 00 00	 DD	 $LN86@s370_diagn
  0135c	00 00 00 00	 DD	 $LN130@s370_diagn
$LN146@s370_diagn:
  01360	00		 DB	 0
  01361	09		 DB	 9
  01362	09		 DB	 9
  01363	09		 DB	 9
  01364	09		 DB	 9
  01365	09		 DB	 9
  01366	09		 DB	 9
  01367	09		 DB	 9
  01368	09		 DB	 9
  01369	09		 DB	 9
  0136a	09		 DB	 9
  0136b	09		 DB	 9
  0136c	01		 DB	 1
  0136d	09		 DB	 9
  0136e	09		 DB	 9
  0136f	09		 DB	 9
  01370	09		 DB	 9
  01371	09		 DB	 9
  01372	09		 DB	 9
  01373	09		 DB	 9
  01374	09		 DB	 9
  01375	09		 DB	 9
  01376	09		 DB	 9
  01377	09		 DB	 9
  01378	09		 DB	 9
  01379	09		 DB	 9
  0137a	09		 DB	 9
  0137b	09		 DB	 9
  0137c	09		 DB	 9
  0137d	09		 DB	 9
  0137e	09		 DB	 9
  0137f	09		 DB	 9
  01380	09		 DB	 9
  01381	09		 DB	 9
  01382	09		 DB	 9
  01383	09		 DB	 9
  01384	09		 DB	 9
  01385	09		 DB	 9
  01386	09		 DB	 9
  01387	09		 DB	 9
  01388	02		 DB	 2
  01389	09		 DB	 9
  0138a	09		 DB	 9
  0138b	09		 DB	 9
  0138c	09		 DB	 9
  0138d	09		 DB	 9
  0138e	09		 DB	 9
  0138f	09		 DB	 9
  01390	09		 DB	 9
  01391	09		 DB	 9
  01392	09		 DB	 9
  01393	09		 DB	 9
  01394	09		 DB	 9
  01395	09		 DB	 9
  01396	09		 DB	 9
  01397	09		 DB	 9
  01398	09		 DB	 9
  01399	09		 DB	 9
  0139a	09		 DB	 9
  0139b	09		 DB	 9
  0139c	03		 DB	 3
  0139d	09		 DB	 9
  0139e	09		 DB	 9
  0139f	09		 DB	 9
  013a0	09		 DB	 9
  013a1	09		 DB	 9
  013a2	09		 DB	 9
  013a3	09		 DB	 9
  013a4	09		 DB	 9
  013a5	09		 DB	 9
  013a6	09		 DB	 9
  013a7	09		 DB	 9
  013a8	09		 DB	 9
  013a9	09		 DB	 9
  013aa	09		 DB	 9
  013ab	09		 DB	 9
  013ac	04		 DB	 4
  013ad	09		 DB	 9
  013ae	09		 DB	 9
  013af	09		 DB	 9
  013b0	05		 DB	 5
  013b1	09		 DB	 9
  013b2	09		 DB	 9
  013b3	09		 DB	 9
  013b4	09		 DB	 9
  013b5	09		 DB	 9
  013b6	09		 DB	 9
  013b7	09		 DB	 9
  013b8	09		 DB	 9
  013b9	09		 DB	 9
  013ba	09		 DB	 9
  013bb	09		 DB	 9
  013bc	06		 DB	 6
  013bd	09		 DB	 9
  013be	09		 DB	 9
  013bf	09		 DB	 9
  013c0	07		 DB	 7
  013c1	09		 DB	 9
  013c2	09		 DB	 9
  013c3	09		 DB	 9
  013c4	09		 DB	 9
  013c5	09		 DB	 9
  013c6	09		 DB	 9
  013c7	09		 DB	 9
  013c8	09		 DB	 9
  013c9	09		 DB	 9
  013ca	09		 DB	 9
  013cb	09		 DB	 9
  013cc	09		 DB	 9
  013cd	09		 DB	 9
  013ce	09		 DB	 9
  013cf	09		 DB	 9
  013d0	09		 DB	 9
  013d1	09		 DB	 9
  013d2	09		 DB	 9
  013d3	09		 DB	 9
  013d4	09		 DB	 9
  013d5	09		 DB	 9
  013d6	09		 DB	 9
  013d7	09		 DB	 9
  013d8	09		 DB	 9
  013d9	09		 DB	 9
  013da	09		 DB	 9
  013db	09		 DB	 9
  013dc	09		 DB	 9
  013dd	09		 DB	 9
  013de	09		 DB	 9
  013df	09		 DB	 9
  013e0	09		 DB	 9
  013e1	09		 DB	 9
  013e2	09		 DB	 9
  013e3	09		 DB	 9
  013e4	09		 DB	 9
  013e5	09		 DB	 9
  013e6	09		 DB	 9
  013e7	09		 DB	 9
  013e8	09		 DB	 9
  013e9	09		 DB	 9
  013ea	09		 DB	 9
  013eb	09		 DB	 9
  013ec	09		 DB	 9
  013ed	09		 DB	 9
  013ee	09		 DB	 9
  013ef	09		 DB	 9
  013f0	09		 DB	 9
  013f1	09		 DB	 9
  013f2	09		 DB	 9
  013f3	09		 DB	 9
  013f4	09		 DB	 9
  013f5	09		 DB	 9
  013f6	09		 DB	 9
  013f7	09		 DB	 9
  013f8	09		 DB	 9
  013f9	09		 DB	 9
  013fa	09		 DB	 9
  013fb	09		 DB	 9
  013fc	09		 DB	 9
  013fd	09		 DB	 9
  013fe	09		 DB	 9
  013ff	09		 DB	 9
  01400	09		 DB	 9
  01401	09		 DB	 9
  01402	09		 DB	 9
  01403	09		 DB	 9
  01404	09		 DB	 9
  01405	09		 DB	 9
  01406	09		 DB	 9
  01407	09		 DB	 9
  01408	09		 DB	 9
  01409	09		 DB	 9
  0140a	09		 DB	 9
  0140b	09		 DB	 9
  0140c	09		 DB	 9
  0140d	09		 DB	 9
  0140e	09		 DB	 9
  0140f	09		 DB	 9
  01410	09		 DB	 9
  01411	09		 DB	 9
  01412	09		 DB	 9
  01413	09		 DB	 9
  01414	09		 DB	 9
  01415	09		 DB	 9
  01416	09		 DB	 9
  01417	09		 DB	 9
  01418	09		 DB	 9
  01419	09		 DB	 9
  0141a	09		 DB	 9
  0141b	09		 DB	 9
  0141c	09		 DB	 9
  0141d	09		 DB	 9
  0141e	09		 DB	 9
  0141f	09		 DB	 9
  01420	09		 DB	 9
  01421	09		 DB	 9
  01422	09		 DB	 9
  01423	09		 DB	 9
  01424	09		 DB	 9
  01425	09		 DB	 9
  01426	09		 DB	 9
  01427	09		 DB	 9
  01428	09		 DB	 9
  01429	09		 DB	 9
  0142a	09		 DB	 9
  0142b	09		 DB	 9
  0142c	09		 DB	 9
  0142d	09		 DB	 9
  0142e	09		 DB	 9
  0142f	09		 DB	 9
  01430	09		 DB	 9
  01431	09		 DB	 9
  01432	09		 DB	 9
  01433	09		 DB	 9
  01434	09		 DB	 9
  01435	09		 DB	 9
  01436	09		 DB	 9
  01437	09		 DB	 9
  01438	09		 DB	 9
  01439	09		 DB	 9
  0143a	09		 DB	 9
  0143b	09		 DB	 9
  0143c	09		 DB	 9
  0143d	09		 DB	 9
  0143e	09		 DB	 9
  0143f	09		 DB	 9
  01440	09		 DB	 9
  01441	09		 DB	 9
  01442	09		 DB	 9
  01443	09		 DB	 9
  01444	09		 DB	 9
  01445	09		 DB	 9
  01446	09		 DB	 9
  01447	09		 DB	 9
  01448	09		 DB	 9
  01449	09		 DB	 9
  0144a	09		 DB	 9
  0144b	09		 DB	 9
  0144c	09		 DB	 9
  0144d	09		 DB	 9
  0144e	09		 DB	 9
  0144f	09		 DB	 9
  01450	09		 DB	 9
  01451	09		 DB	 9
  01452	09		 DB	 9
  01453	09		 DB	 9
  01454	08		 DB	 8
  01455	0f 1f 00	 npad	 3
$LN145@s370_diagn:
  01458	00 00 00 00	 DD	 $LN100@s370_diagn
  0145c	00 00 00 00	 DD	 $LN103@s370_diagn
  01460	00 00 00 00	 DD	 $LN104@s370_diagn
  01464	00 00 00 00	 DD	 $LN116@s370_diagn
  01468	00 00 00 00	 DD	 $LN121@s370_diagn
  0146c	00 00 00 00	 DD	 $LN123@s370_diagn
  01470	00 00 00 00	 DD	 $LN124@s370_diagn
  01474	00 00 00 00	 DD	 $LN125@s370_diagn
  01478	00 00 00 00	 DD	 $LN127@s370_diagn
  0147c	00 00 00 00	 DD	 $LN130@s370_diagn
$LN144@s370_diagn:
  01480	00		 DB	 0
  01481	09		 DB	 9
  01482	09		 DB	 9
  01483	09		 DB	 9
  01484	01		 DB	 1
  01485	02		 DB	 2
  01486	09		 DB	 9
  01487	09		 DB	 9
  01488	03		 DB	 3
  01489	09		 DB	 9
  0148a	09		 DB	 9
  0148b	09		 DB	 9
  0148c	04		 DB	 4
  0148d	09		 DB	 9
  0148e	09		 DB	 9
  0148f	09		 DB	 9
  01490	09		 DB	 9
  01491	09		 DB	 9
  01492	09		 DB	 9
  01493	09		 DB	 9
  01494	05		 DB	 5
  01495	09		 DB	 9
  01496	09		 DB	 9
  01497	09		 DB	 9
  01498	09		 DB	 9
  01499	09		 DB	 9
  0149a	09		 DB	 9
  0149b	09		 DB	 9
  0149c	09		 DB	 9
  0149d	09		 DB	 9
  0149e	09		 DB	 9
  0149f	09		 DB	 9
  014a0	09		 DB	 9
  014a1	09		 DB	 9
  014a2	09		 DB	 9
  014a3	09		 DB	 9
  014a4	09		 DB	 9
  014a5	09		 DB	 9
  014a6	09		 DB	 9
  014a7	09		 DB	 9
  014a8	09		 DB	 9
  014a9	09		 DB	 9
  014aa	09		 DB	 9
  014ab	09		 DB	 9
  014ac	09		 DB	 9
  014ad	09		 DB	 9
  014ae	09		 DB	 9
  014af	09		 DB	 9
  014b0	09		 DB	 9
  014b1	09		 DB	 9
  014b2	09		 DB	 9
  014b3	09		 DB	 9
  014b4	09		 DB	 9
  014b5	09		 DB	 9
  014b6	09		 DB	 9
  014b7	09		 DB	 9
  014b8	09		 DB	 9
  014b9	09		 DB	 9
  014ba	09		 DB	 9
  014bb	09		 DB	 9
  014bc	09		 DB	 9
  014bd	09		 DB	 9
  014be	09		 DB	 9
  014bf	09		 DB	 9
  014c0	09		 DB	 9
  014c1	09		 DB	 9
  014c2	09		 DB	 9
  014c3	09		 DB	 9
  014c4	09		 DB	 9
  014c5	09		 DB	 9
  014c6	09		 DB	 9
  014c7	09		 DB	 9
  014c8	09		 DB	 9
  014c9	09		 DB	 9
  014ca	09		 DB	 9
  014cb	09		 DB	 9
  014cc	09		 DB	 9
  014cd	09		 DB	 9
  014ce	09		 DB	 9
  014cf	09		 DB	 9
  014d0	09		 DB	 9
  014d1	09		 DB	 9
  014d2	09		 DB	 9
  014d3	09		 DB	 9
  014d4	09		 DB	 9
  014d5	09		 DB	 9
  014d6	09		 DB	 9
  014d7	09		 DB	 9
  014d8	09		 DB	 9
  014d9	09		 DB	 9
  014da	09		 DB	 9
  014db	09		 DB	 9
  014dc	09		 DB	 9
  014dd	09		 DB	 9
  014de	09		 DB	 9
  014df	09		 DB	 9
  014e0	09		 DB	 9
  014e1	09		 DB	 9
  014e2	09		 DB	 9
  014e3	09		 DB	 9
  014e4	09		 DB	 9
  014e5	09		 DB	 9
  014e6	09		 DB	 9
  014e7	09		 DB	 9
  014e8	09		 DB	 9
  014e9	09		 DB	 9
  014ea	09		 DB	 9
  014eb	09		 DB	 9
  014ec	09		 DB	 9
  014ed	09		 DB	 9
  014ee	09		 DB	 9
  014ef	09		 DB	 9
  014f0	09		 DB	 9
  014f1	09		 DB	 9
  014f2	09		 DB	 9
  014f3	09		 DB	 9
  014f4	09		 DB	 9
  014f5	09		 DB	 9
  014f6	09		 DB	 9
  014f7	09		 DB	 9
  014f8	09		 DB	 9
  014f9	09		 DB	 9
  014fa	09		 DB	 9
  014fb	09		 DB	 9
  014fc	09		 DB	 9
  014fd	09		 DB	 9
  014fe	09		 DB	 9
  014ff	09		 DB	 9
  01500	09		 DB	 9
  01501	09		 DB	 9
  01502	09		 DB	 9
  01503	09		 DB	 9
  01504	09		 DB	 9
  01505	09		 DB	 9
  01506	09		 DB	 9
  01507	09		 DB	 9
  01508	09		 DB	 9
  01509	09		 DB	 9
  0150a	09		 DB	 9
  0150b	09		 DB	 9
  0150c	09		 DB	 9
  0150d	09		 DB	 9
  0150e	09		 DB	 9
  0150f	09		 DB	 9
  01510	09		 DB	 9
  01511	09		 DB	 9
  01512	09		 DB	 9
  01513	09		 DB	 9
  01514	09		 DB	 9
  01515	09		 DB	 9
  01516	09		 DB	 9
  01517	09		 DB	 9
  01518	09		 DB	 9
  01519	09		 DB	 9
  0151a	09		 DB	 9
  0151b	09		 DB	 9
  0151c	09		 DB	 9
  0151d	09		 DB	 9
  0151e	09		 DB	 9
  0151f	09		 DB	 9
  01520	09		 DB	 9
  01521	09		 DB	 9
  01522	09		 DB	 9
  01523	09		 DB	 9
  01524	09		 DB	 9
  01525	09		 DB	 9
  01526	09		 DB	 9
  01527	09		 DB	 9
  01528	09		 DB	 9
  01529	09		 DB	 9
  0152a	09		 DB	 9
  0152b	09		 DB	 9
  0152c	09		 DB	 9
  0152d	09		 DB	 9
  0152e	09		 DB	 9
  0152f	09		 DB	 9
  01530	09		 DB	 9
  01531	09		 DB	 9
  01532	09		 DB	 9
  01533	09		 DB	 9
  01534	09		 DB	 9
  01535	09		 DB	 9
  01536	09		 DB	 9
  01537	09		 DB	 9
  01538	09		 DB	 9
  01539	09		 DB	 9
  0153a	09		 DB	 9
  0153b	09		 DB	 9
  0153c	09		 DB	 9
  0153d	09		 DB	 9
  0153e	09		 DB	 9
  0153f	09		 DB	 9
  01540	09		 DB	 9
  01541	09		 DB	 9
  01542	09		 DB	 9
  01543	09		 DB	 9
  01544	09		 DB	 9
  01545	09		 DB	 9
  01546	09		 DB	 9
  01547	09		 DB	 9
  01548	09		 DB	 9
  01549	09		 DB	 9
  0154a	09		 DB	 9
  0154b	09		 DB	 9
  0154c	09		 DB	 9
  0154d	09		 DB	 9
  0154e	09		 DB	 9
  0154f	09		 DB	 9
  01550	09		 DB	 9
  01551	09		 DB	 9
  01552	09		 DB	 9
  01553	09		 DB	 9
  01554	09		 DB	 9
  01555	09		 DB	 9
  01556	09		 DB	 9
  01557	09		 DB	 9
  01558	09		 DB	 9
  01559	09		 DB	 9
  0155a	09		 DB	 9
  0155b	09		 DB	 9
  0155c	09		 DB	 9
  0155d	09		 DB	 9
  0155e	09		 DB	 9
  0155f	09		 DB	 9
  01560	09		 DB	 9
  01561	09		 DB	 9
  01562	09		 DB	 9
  01563	09		 DB	 9
  01564	09		 DB	 9
  01565	09		 DB	 9
  01566	09		 DB	 9
  01567	09		 DB	 9
  01568	09		 DB	 9
  01569	09		 DB	 9
  0156a	09		 DB	 9
  0156b	09		 DB	 9
  0156c	09		 DB	 9
  0156d	09		 DB	 9
  0156e	09		 DB	 9
  0156f	09		 DB	 9
  01570	09		 DB	 9
  01571	09		 DB	 9
  01572	09		 DB	 9
  01573	09		 DB	 9
  01574	06		 DB	 6
  01575	09		 DB	 9
  01576	09		 DB	 9
  01577	09		 DB	 9
  01578	07		 DB	 7
  01579	08		 DB	 8
s370_diagnose_call ENDP
_TEXT	ENDS
END
