; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	g_hWndEvt
PUBLIC	g_hMsgWnd
_BSS	SEGMENT
g_hWndEvt DQ	01H DUP (?)
g_hMsgWnd DQ	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG169050 DB	'externalgui', 00H
$SG169051 DB	'help', 00H
	ORG $+3
$SG169052 DB	'config', 00H
	ORG $+1
$SG169053 DB	'output', 00H
	ORG $+5
$SG169054 DB	'logfile', 00H
$SG169055 DB	'rcfile', 00H
	ORG $+1
$SG169056 DB	'daemon', 00H
	ORG $+1
$SG169057 DB	'herclogo', 00H
	ORG $+7
$SG169058 DB	'verbose', 00H
$SG169059 DB	'test', 00H
	ORG $+3
$SG169060 DB	'modpath', 00H
$SG169061 DB	'ldmod', 00H
	ORG $+2
$SG169062 DB	'defsym', 00H
	ORG $+1
$SG169077 DB	'HERCULES_CNF', 00H
	ORG $+3
$SG169078 DB	'hercules.cnf', 00H
	ORG $+3
$SG169079 DB	'Configuration', 00H
	ORG $+2
$SG169080 DB	'HERCULES_RC', 00H
	ORG $+4
$SG169081 DB	'hercules.rc', 00H
	ORG $+4
$SG169082 DB	'Run Commands', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	impl
PUBLIC	registerLogCallback
PUBLIC	getCommandHandler
PUBLIC	log_do_callback
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@402ca213d82418e5
EXTRN	__imp_islower:PROC
EXTRN	__imp_isprint:PROC
EXTRN	__imp_toupper:PROC
EXTRN	__imp__errno:PROC
EXTRN	strcmp:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strncmp:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_CloseHandle:PROC
EXTRN	__imp_SetEvent:PROC
EXTRN	__imp_WaitForSingleObject:PROC
EXTRN	__imp_CreateEventA:PROC
EXTRN	__imp_GetCurrentThreadId:PROC
EXTRN	__imp_GetModuleFileNameA:PROC
EXTRN	__imp_GetModuleHandleA:PROC
EXTRN	__imp_GetMessageA:PROC
EXTRN	__imp_TranslateMessage:PROC
EXTRN	__imp_DispatchMessageA:PROC
EXTRN	__imp_DefWindowProcA:PROC
EXTRN	__imp_RegisterClassA:PROC
EXTRN	__imp_CreateWindowExA:PROC
EXTRN	__imp_SetConsoleCtrlHandler:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	atexit:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	__imp_atof:PROC
EXTRN	__imp_WSAGetLastError:PROC
EXTRN	__imp_floor:PROC
EXTRN	__imp_isatty:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fflush:PROC
EXTRN	__imp__setmaxstdio:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp__time64:PROC
EXTRN	__imp__stat64:PROC
EXTRN	__imp_getpid:PROC
EXTRN	__imp_signal:PROC
EXTRN	__imp_fthread_self:PROC
EXTRN	__imp_hthreads_internal_init:PROC
EXTRN	__imp_hthread_initialize_lock:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_initialize_condition:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_hthread_initialize_join_attr:PROC
EXTRN	__imp_hthread_initialize_detach_attr:PROC
EXTRN	__imp_hthread_create_thread:PROC
EXTRN	__imp_hthread_equal_threads:PROC
EXTRN	__imp_hthread_set_thread_prio:PROC
EXTRN	__imp_hthread_get_thread_prio:PROC
EXTRN	__imp_hthread_report_deadlocks:PROC
EXTRN	__imp_hthread_set_lock_name:PROC
EXTRN	__imp_hthread_set_thread_name:PROC
EXTRN	__imp_init_hostinfo:PROC
EXTRN	__imp_init_sysblk_version_str_arrays:PROC
EXTRN	__imp_display_version:PROC
EXTRN	__imp_display_build_options:PROC
EXTRN	__imp_display_extpkg_vers:PROC
EXTRN	__imp_get_symbol:PROC
EXTRN	__imp_set_symbol:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_strlcat:PROC
EXTRN	__imp_init_random:PROC
EXTRN	__imp_ptyp2short:PROC
EXTRN	__imp_are_elevated:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_socketpair:PROC
EXTRN	__imp_strtok_r:PROC
EXTRN	__imp_usleep:PROC
EXTRN	__imp_sleep:PROC
EXTRN	__imp_sched_yield:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_socket_init:PROC
EXTRN	__imp_socket_deinit:PROC
EXTRN	__imp_set_socket_keepalive:PROC
EXTRN	__imp_get_socket_keepalive:PROC
EXTRN	__imp_w32_socket:PROC
EXTRN	__imp_w32_close_socket:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_set_thread_name:PROC
EXTRN	__imp_w32_mlock:PROC
EXTRN	__imp_w32_basename:PROC
EXTRN	__imp_w32_dirname:PROC
EXTRN	hw_clock:PROC
EXTRN	s370_store_int_timer:PROC
EXTRN	get_cpu_timer:PROC
EXTRN	__imp_set_codepage:PROC
EXTRN	__imp_logger_init:PROC
EXTRN	__imp_log_read:PROC
EXTRN	__imp_log_sethrdcpy:PROC
EXTRN	__imp_logger_isactive:PROC
EXTRN	__imp_hdl_main:PROC
EXTRN	__imp_hdl_atexit:PROC
EXTRN	__imp_hdl_addshut:PROC
EXTRN	__imp_hdl_initpath:PROC
EXTRN	__imp_hdl_loadmod:PROC
EXTRN	init_runtime_opcode_tables:PROC
EXTRN	s370_display_inst:PROC
EXTRN	defsym_TXF_models:PROC
EXTRN	txf_model_warning:PROC
EXTRN	txf_set_timerint:PROC
EXTRN	build_config:PROC
EXTRN	release_config:PROC
EXTRN	set_panel_colors:PROC
EXTRN	quit_cmd:PROC
EXTRN	createCpuId:PROC
EXTRN	the_real_panel_display:PROC
EXTRN	the_real_panel_command:PROC
EXTRN	the_real_replace_opcode:PROC
EXTRN	str_lparname:PROC
EXTRN	do_shutdown:PROC
EXTRN	s370_virt_to_real:PROC
EXTRN	s390_virt_to_real:PROC
EXTRN	z900_virt_to_real:PROC
EXTRN	__imp_getopt_long:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	InitializeRexx:PROC
EXTRN	__imp_cckd_gc_rpt_states:PROC
EXTRN	process_script_file:PROC
EXTRN	s370_get_storage_key:PROC
EXTRN	s390_get_storage_key:PROC
EXTRN	z900_get_storage_key:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_hostinfo:BYTE
EXTRN	__imp_ckd_dasd_device_hndinfo:BYTE
EXTRN	__imp_fba_dasd_device_hndinfo:BYTE
EXTRN	__imp_sysblk:BYTE
EXTRN	__imp_extgui:DWORD
EXTRN	__imp_panel_display:QWORD
EXTRN	__imp_daemon_task:QWORD
EXTRN	__imp_panel_command:QWORD
EXTRN	__imp_debug_watchdog_signal:QWORD
EXTRN	__imp_opterr:DWORD
EXTRN	__imp_optind:DWORD
EXTRN	__imp_optopt:DWORD
EXTRN	__imp_optarg:QWORD
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
log_callback DQ	01H DUP (?)
modnames DQ	032H DUP (?)
modcount DD	01H DUP (?)
$SG169587 DB	01H DUP (?)
	ALIGN	4

$SG169679 DB	01H DUP (?)
	ALIGN	4

$SG169856 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
pdata	SEGMENT
$pdata$time DD	imagerel time
	DD	imagerel time+25
	DD	imagerel $unwind$time
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
$pdata$impl DD	imagerel $LN103
	DD	imagerel $LN103+8978
	DD	imagerel $unwind$impl
$pdata$wakeup_cpu DD imagerel wakeup_cpu
	DD	imagerel wakeup_cpu+44
	DD	imagerel $unwind$wakeup_cpu
$pdata$wakeup_cpus_mask DD imagerel wakeup_cpus_mask
	DD	imagerel wakeup_cpus_mask+106
	DD	imagerel $unwind$wakeup_cpus_mask
$pdata$Interrupt_Lock_Obtained DD imagerel Interrupt_Lock_Obtained
	DD	imagerel Interrupt_Lock_Obtained+269
	DD	imagerel $unwind$Interrupt_Lock_Obtained
$pdata$Obtain_Interrupt_Lock DD imagerel Obtain_Interrupt_Lock
	DD	imagerel Obtain_Interrupt_Lock+88
	DD	imagerel $unwind$Obtain_Interrupt_Lock
$pdata$Release_Interrupt_Lock DD imagerel Release_Interrupt_Lock
	DD	imagerel Release_Interrupt_Lock+71
	DD	imagerel $unwind$Release_Interrupt_Lock
$pdata$init_progname DD imagerel init_progname
	DD	imagerel init_progname+264
	DD	imagerel $unwind$init_progname
$pdata$process_args DD imagerel process_args
	DD	imagerel process_args+3452
	DD	imagerel $unwind$process_args
$pdata$delayed_exit DD imagerel delayed_exit
	DD	imagerel delayed_exit+166
	DD	imagerel $unwind$delayed_exit
$pdata$sigint_handler DD imagerel sigint_handler
	DD	imagerel sigint_handler+309
	DD	imagerel $unwind$sigint_handler
$pdata$sigterm_handler DD imagerel sigterm_handler
	DD	imagerel sigterm_handler+75
	DD	imagerel $unwind$sigterm_handler
$pdata$do_emergency_shutdown DD imagerel do_emergency_shutdown
	DD	imagerel do_emergency_shutdown+135
	DD	imagerel $unwind$do_emergency_shutdown
$pdata$console_ctrl_handler DD imagerel console_ctrl_handler
	DD	imagerel console_ctrl_handler+722
	DD	imagerel $unwind$console_ctrl_handler
$pdata$MainWndProc DD imagerel MainWndProc
	DD	imagerel MainWndProc+522
	DD	imagerel $unwind$MainWndProc
$pdata$WinMsgThread DD imagerel WinMsgThread
	DD	imagerel WinMsgThread+287
	DD	imagerel $unwind$WinMsgThread
$pdata$watchdog_thread DD imagerel watchdog_thread
	DD	imagerel watchdog_thread+2583
	DD	imagerel $unwind$watchdog_thread
$pdata$log_do_callback DD imagerel $LN10
	DD	imagerel $LN10+137
	DD	imagerel $unwind$log_do_callback
$pdata$process_rc_file DD imagerel process_rc_file
	DD	imagerel process_rc_file+401
	DD	imagerel $unwind$process_rc_file
$pdata$arghelp DD imagerel arghelp
	DD	imagerel arghelp+246
	DD	imagerel $unwind$arghelp
pdata	ENDS
;	COMDAT __real@402ca213d82418e5
CONST	SEGMENT
__real@402ca213d82418e5 DQ 0402ca213d82418e5r	; 14.3166
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
_DATA	SEGMENT
	ORG $+3
shortopts DB	'eh::f:o:r:db:vt::p:l:s:', 00H
longopts DQ	FLAT:$SG169050
	DD	00H
	ORG $+4
	DQ	0000000000000000H
	DD	065H
	ORG $+4
	DQ	FLAT:$SG169051
	DD	02H
	ORG $+4
	DQ	0000000000000000H
	DD	068H
	ORG $+4
	DQ	FLAT:$SG169052
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	066H
	ORG $+4
	DQ	FLAT:$SG169053
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	06fH
	ORG $+4
	DQ	FLAT:$SG169054
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	06fH
	ORG $+4
	DQ	FLAT:$SG169055
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	072H
	ORG $+4
	DQ	FLAT:$SG169056
	DD	00H
	ORG $+4
	DQ	0000000000000000H
	DD	064H
	ORG $+4
	DQ	FLAT:$SG169057
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	062H
	ORG $+4
	DQ	FLAT:$SG169058
	DD	00H
	ORG $+4
	DQ	0000000000000000H
	DD	076H
	ORG $+4
	DQ	FLAT:$SG169059
	DD	02H
	ORG $+4
	DQ	0000000000000000H
	DD	074H
	ORG $+4
	DQ	FLAT:$SG169060
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	070H
	ORG $+4
	DQ	FLAT:$SG169061
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	06cH
	ORG $+4
	DQ	FLAT:$SG169062
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	073H
	ORG $+4
	DQ	0000000000000000H
	DD	00H
	ORG $+4
	DQ	0000000000000000H
	DD	00H
	ORG $+4
cfgorrc	DQ	0000000000000000H
	DQ	FLAT:$SG169077
	DQ	FLAT:$SG169078
	DQ	FLAT:$SG169079
	DQ	0000000000000000H
	DQ	FLAT:$SG169080
	DQ	FLAT:$SG169081
	DQ	FLAT:$SG169082
$SG169166 DB	'pressing interrupt key', 00H
	ORG $+1
$SG169167 DB	'I', 00H
	ORG $+2
$SG169170 DB	'impl.c', 00H
	ORG $+1
$SG169181 DB	'I', 00H
	ORG $+2
$SG169168 DB	'HHC01400%s CTRL_BREAK_EVENT received: %s', 0aH, 00H
	ORG $+2
$SG169184 DB	'impl.c', 00H
	ORG $+1
$SG169188 DB	'I', 00H
	ORG $+2
$SG169169 DB	'console_ctrl_handler', 00H
	ORG $+3
$SG169171 DB	'impl.c:265', 00H
	ORG $+1
$SG169210 DB	'I', 00H
	ORG $+2
$SG169176 DB	'impl.c:267', 00H
	ORG $+1
$SG169218 DB	'I', 00H
	ORG $+2
$SG169177 DB	'impl.c:268', 00H
	ORG $+1
$SG169224 DB	'I', 00H
	ORG $+2
$SG169180 DB	'initiating emergency shutdown', 00H
	ORG $+2
$SG169182 DB	'HHC01401%s CTRL_C_EVENT received: %s', 0aH, 00H
	ORG $+2
$SG169183 DB	'console_ctrl_handler', 00H
	ORG $+3
$SG169187 DB	'initiating emergency shutdown', 00H
	ORG $+2
$SG169189 DB	'HHC01402%s CTRL_CLOSE_EVENT received: %s', 0aH, 00H
	ORG $+2
$SG169191 DB	'impl.c', 00H
	ORG $+1
$SG169355 DB	'S', 00H
	ORG $+2
$SG169190 DB	'console_ctrl_handler', 00H
	ORG $+3
$SG169208 DB	'allow', 00H
	ORG $+2
$SG169209 DB	'WM_QUERYENDSESSION', 00H
	ORG $+1
$SG169357 DB	'S', 00H
	ORG $+2
$SG169211 DB	'HHC01403%s %s received: %s', 0aH, 00H
$SG169369 DB	'S', 00H
	ORG $+2
$SG169212 DB	'MainWndProc', 00H
$SG169213 DB	'impl.c', 00H
	ORG $+1
$SG169375 DB	'S', 00H
	ORG $+2
$SG169216 DB	'aborted', 00H
$SG169217 DB	'WM_ENDSESSION', 00H
	ORG $+2
$SG169219 DB	'HHC01403%s %s received: %s', 0aH, 00H
$SG169381 DB	'S', 00H
	ORG $+2
$SG169220 DB	'MainWndProc', 00H
$SG169221 DB	'impl.c', 00H
	ORG $+1
$SG169385 DB	'S', 00H
	ORG $+2
$SG169222 DB	'initiating emergency shutdown', 00H
	ORG $+2
$SG169223 DB	'WM_ENDSESSION', 00H
	ORG $+2
$SG169225 DB	'HHC01403%s %s received: %s', 0aH, 00H
$SG169389 DB	'ptt', 00H
$SG169226 DB	'MainWndProc', 00H
$SG169227 DB	'impl.c', 00H
	ORG $+1
$SG169440 DB	'.', 00H
	ORG $+2
$SG169258 DB	'Hercules', 00H
	ORG $+3
$SG169360 DB	'impl.c', 00H
	ORG $+1
$SG169441 DB	'S', 00H
	ORG $+2
$SG169259 DB	'Hercules', 00H
	ORG $+3
$SG169372 DB	'impl.c', 00H
	ORG $+1
$SG169557 DB	'S', 00H
	ORG $+2
$SG169260 DB	'Hercules', 00H
	ORG $+3
$SG169378 DB	'impl.c', 00H
	ORG $+1
$SG169586 DB	'UP', 00H
	ORG $+1
$SG169348 DB	'impl.c:483', 00H
	ORG $+1
$SG169598 DB	'1', 00H
	ORG $+2
$SG169358 DB	'HHC90024%s DEADLOCK!', 0aH, 00H
	ORG $+2
$SG169359 DB	'watchdog_thread', 00H
$SG169370 DB	'HHC00822%s PROCESSOR %s%02X APPEARS TO BE HUNG!', 0aH, 00H
	ORG $+3
$SG169384 DB	'impl.c', 00H
	ORG $+1
$SG169600 DB	'0', 00H
	ORG $+2
$SG169371 DB	'watchdog_thread', 00H
$SG169388 DB	'impl.c', 00H
	ORG $+1
$SG169376 DB	'HHC00823%s You have %d seconds to attach a debugger befo'
	DB	're crash dump will be taken!', 0aH, 00H
	ORG $+2
$SG169377 DB	'watchdog_thread', 00H
$SG169382 DB	'HHC00824%s Debugger attached! NOT crashing!', 0aH, 00H
	ORG $+3
$SG169383 DB	'watchdog_thread', 00H
$SG169391 DB	'locks held sort tid', 00H
	ORG $+4
$SG169386 DB	'HHC00825%s TIME''S UP! (or debugger has been detached!) '
	DB	'- Forcing crash dump!', 0aH, 00H
	ORG $+2
$SG169387 DB	'watchdog_thread', 00H
$SG169390 DB	'ipending', 00H
	ORG $+3
$SG169444 DB	'impl.c', 00H
	ORG $+1
$SG169651 DB	'E', 00H
	ORG $+2
$SG169392 DB	'threads waiting sort tid', 00H
	ORG $+3
$SG169553 DB	'SYSBLK', 00H
	ORG $+1
$SG169655 DB	'W', 00H
	ORG $+2
$SG169430 DB	'hercules.rc', 00H
$SG169661 DB	'I', 00H
	ORG $+2
$SG169431 DB	'hercules.rc', 00H
$SG169433 DB	'None', 00H
	ORG $+7
$SG169443 DB	'arghelp', 00H
$SG169442 DB	'HHC01407%s Usage: %s [--help[=SHORT|LONG|VERSION|BUILD]]'
	DB	' -f config-filename|"none" [-o logfile-name] [-r rcfile-name]'
	DB	' [-d] [-b logo-filename] [-s sym=val] [-t [factor]] [-p dyn-l'
	DB	'oad-dir] [[-l dynmod-to-load]...] [> logfile]', 0aH, 00H
	ORG $+3
$SG169554 DB	'SYSBLK', 00H
	ORG $+1
$SG169668 DB	'I', 00H
	ORG $+2
$SG169550 DB	'impl_thread', 00H
$SG169673 DB	'S', 00H
	ORG $+2
$SG169551 DB	'impl_thread', 00H
$SG169552 DB	'END ', 00H
	ORG $+3
$SG169560 DB	'impl.c', 00H
	ORG $+1
$SG169680 DB	'I', 00H
	ORG $+2
$SG169555 DB	'SDL 4.2', 00H
$SG169558 DB	'HHC02343%s Terminating due to %d argument errors', 0aH, 00H
	ORG $+2
$SG169559 DB	'impl', 00H
	ORG $+3
$SG169565 DB	'impl.c', 00H
	ORG $+1
$SG169685 DB	'W', 00H
	ORG $+2
$SG169562 DB	'EXTERNALGUI', 00H
$SG169564 DB	'impl', 00H
	ORG $+3
$SG169568 DB	'impl', 00H
	ORG $+7
$SG169566 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169569 DB	'impl.c', 00H
	ORG $+1
$SG169570 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169572 DB	'4.6.0.10893-SDL-DEV-g5b56a850-modified', 00H
	ORG $+1
$SG169573 DB	'VERSION', 00H
$SG169574 DB	'Feb  6 2023', 00H
$SG169575 DB	'BDATE', 00H
	ORG $+2
$SG169589 DB	'HOSTOS', 00H
	ORG $+1
$SG169693 DB	'W', 00H
	ORG $+2
$SG169576 DB	'19:16:27', 00H
	ORG $+3
$SG169577 DB	'BTIME', 00H
	ORG $+2
$SG169654 DB	'impl.c', 00H
	ORG $+1
$SG169698 DB	'I', 00H
	ORG $+2
$SG169580 DB	'LP=%d, Cores=%d, CPUs=%d', 00H
	ORG $+3
$SG169583 DB	'MP=%d', 00H
	ORG $+2
$SG169658 DB	'impl.c', 00H
	ORG $+1
$SG169702 DB	'W', 00H
	ORG $+2
$SG169588 DB	'HOSTNAME', 00H
	ORG $+3
$SG169664 DB	'impl.c', 00H
	ORG $+1
$SG169709 DB	'E', 00H
	ORG $+2
$SG169590 DB	'HOSTOSREL', 00H
	ORG $+2
$SG169671 DB	'impl.c', 00H
	ORG $+1
$SG169716 DB	'E', 00H
	ORG $+2
$SG169591 DB	'HOSTOSVER', 00H
	ORG $+2
$SG169676 DB	'impl.c', 00H
	ORG $+1
$SG169721 DB	'W', 00H
	ORG $+2
$SG169592 DB	'HOSTARCH', 00H
	ORG $+3
$SG169683 DB	'impl.c', 00H
	ORG $+1
$SG169727 DB	'E', 00H
	ORG $+2
$SG169593 DB	'HOSTNUMCPUS', 00H
$SG169735 DB	'S', 00H
	ORG $+2
$SG169594 DB	'MODNAME', 00H
$SG169595 DB	'MODPATH', 00H
$SG169596 DB	'3270', 00H
	ORG $+3
$SG169597 DB	'LPARNAME', 00H
	ORG $+3
$SG169688 DB	'impl.c', 00H
	ORG $+1
$SG169742 DB	'S', 00H
	ORG $+2
$SG169599 DB	'LPARNUM', 00H
$SG169601 DB	'CPUIDFMT', 00H
	ORG $+3
$SG169602 DB	'%06X', 00H
	ORG $+3
$SG169696 DB	'impl.c', 00H
	ORG $+1
$SG169748 DB	'S', 00H
	ORG $+2
$SG169603 DB	'CPUSERIAL', 00H
	ORG $+2
$SG169604 DB	'%04X', 00H
	ORG $+3
$SG169701 DB	'impl.c', 00H
	ORG $+1
$SG169754 DB	'S', 00H
	ORG $+2
$SG169605 DB	'CPUMODEL', 00H
	ORG $+3
$SG169705 DB	'impl.c', 00H
	ORG $+1
$SG169761 DB	'S', 00H
	ORG $+2
$SG169606 DB	'impl.c:1011', 00H
$SG169768 DB	'E', 00H
	ORG $+2
$SG169607 DB	'&sysblk.tracefileLock', 00H
	ORG $+2
$SG169608 DB	'impl.c:1012', 00H
$SG169775 DB	'E', 00H
	ORG $+2
$SG169609 DB	'&sysblk.bindlock', 00H
	ORG $+3
$SG169712 DB	'impl.c', 00H
	ORG $+1
$SG169805 DB	'E', 00H
	ORG $+2
$SG169610 DB	'impl.c:1013', 00H
$SG169817 DB	'E', 00H
	ORG $+2
$SG169611 DB	'&sysblk.config', 00H
	ORG $+1
$SG169612 DB	'impl.c:1014', 00H
$SG169825 DB	'E', 00H
	ORG $+2
$SG169613 DB	'&sysblk.todlock', 00H
$SG169614 DB	'impl.c:1015', 00H
$SG169833 DB	'-', 00H
	ORG $+2
$SG169615 DB	'&sysblk.mainlock', 00H
	ORG $+3
$SG169719 DB	'impl.c', 00H
	ORG $+1
$SG169916 DB	' ', 00H
	ORG $+2
$SG169616 DB	'impl.c:1016', 00H
$SG169918 DB	'-?', 00H
	ORG $+1
$SG169617 DB	'&sysblk.intlock', 00H
$SG169618 DB	'impl.c:1017', 00H
$SG169938 DB	'all', 00H
$SG169619 DB	'&sysblk.iointqlk', 00H
	ORG $+3
$SG169724 DB	'impl.c', 00H
	ORG $+1
$SG169941 DB	'E', 00H
	ORG $+2
$SG169620 DB	'impl.c:1018', 00H
$SG169951 DB	'=', 00H
	ORG $+2
$SG169621 DB	'&sysblk.sigplock', 00H
	ORG $+3
$SG169730 DB	'impl.c', 00H
	ORG $+1
$SG169952 DB	'=', 00H
	ORG $+2
$SG169622 DB	'impl.c:1019', 00H
$SG169956 DB	'E', 00H
	ORG $+2
$SG169623 DB	'&sysblk.scrlock', 00H
$SG169624 DB	'impl.c:1020', 00H
$SG169960 DB	'E', 00H
	ORG $+2
$SG169625 DB	'&sysblk.crwlock', 00H
$SG169626 DB	'impl.c:1021', 00H
$SG169966 DB	', ', 00H
	ORG $+1
$SG169627 DB	'&sysblk.ioqlock', 00H
$SG169628 DB	'impl.c:1022', 00H
$SG169967 DB	', ', 00H
	ORG $+1
$SG169629 DB	'&sysblk.dasdcache_lock', 00H
	ORG $+1
$SG169630 DB	'impl.c:1024', 00H
$SG169970 DB	'W', 00H
	ORG $+2
$SG169631 DB	'&sysblk.rublock', 00H
$SG169632 DB	'impl.c:1027', 00H
$SG169982 DB	'S', 00H
	ORG $+2
$SG169633 DB	'impl.c:1028', 00H
$SG169991 DB	'S', 00H
	ORG $+2
$SG169634 DB	'impl.c:1031', 00H
$SG169995 DB	'S', 00H
	ORG $+2
$SG169635 DB	'&sysblk.shrdlock', 00H
	ORG $+3
$SG169734 DB	'dyngui', 00H
	ORG $+1
$SG170009 DB	'S', 00H
	ORG $+2
$SG169636 DB	'impl.c:1032', 00H
	ORG $+4
$SG169637 DB	'impl.c:1033', 00H
	ORG $+4
$SG169638 DB	'&sysblk.shrdtracelock', 00H
	ORG $+2
$SG169639 DB	'impl.c:1046', 00H
	ORG $+4
$SG169640 DB	'&sysblk.cpulock[%*d]', 00H
	ORG $+3
$SG169641 DB	'impl.c:1052', 00H
	ORG $+4
$SG169642 DB	'&sysblk.cpulock[i]', 00H
	ORG $+5
$SG169643 DB	'&sysblk.txf_lock[%*d]', 00H
	ORG $+2
$SG169644 DB	'impl.c:1057', 00H
	ORG $+4
$SG169645 DB	'&sysblk.txf_lock[i]', 00H
	ORG $+4
$SG169646 DB	'impl.c:1062', 00H
	ORG $+4
$SG169647 DB	'impl.c:1063', 00H
	ORG $+4
$SG169650 DB	'impl.c:1122', 00H
	ORG $+4
$SG169652 DB	'HHC00109%s set_thread_priority( %d ) failed: %s', 0aH, 00H
	ORG $+3
$SG169653 DB	'impl', 00H
	ORG $+7
$SG169656 DB	'HHC00110%s Defaulting all threads to priority %d', 0aH, 00H
	ORG $+2
$SG169657 DB	'impl', 00H
	ORG $+7
$SG169659 DB	'impl_thread', 00H
	ORG $+4
$SG169660 DB	'impl.c:1144', 00H
	ORG $+4
$SG169662 DB	'HHC00100%s Thread id %8.8x, prio %d, name ''%s'' started'
	DB	0aH, 00H
$SG169663 DB	'impl', 00H
	ORG $+3
$SG169665 DB	'impl.c:1147', 00H
	ORG $+4
$SG169666 DB	'logger_thread', 00H
	ORG $+2
$SG169667 DB	'impl.c:1148', 00H
	ORG $+4
$SG169669 DB	'HHC00100%s Thread id %8.8x, prio %d, name ''%s'' started'
	DB	0aH, 00H
$SG169670 DB	'impl', 00H
	ORG $+3
$SG169674 DB	'HHC02343%s Terminating due to %d argument errors', 0aH, 00H
	ORG $+2
$SG169675 DB	'impl', 00H
	ORG $+7
$SG169681 DB	'HHC00018%s Hercules is %srunning in elevated mode', 0aH, 00H
	ORG $+1
$SG169682 DB	'impl', 00H
	ORG $+3
$SG169684 DB	'NOT ', 00H
	ORG $+7
$SG169686 DB	'HHC00018%s Hercules is %srunning in elevated mode', 0aH, 00H
	ORG $+1
$SG169687 DB	'impl', 00H
	ORG $+7
$SG169689 DB	'impl.c:1201', 00H
	ORG $+4
$SG169690 DB	'&sysblk.stape_lock', 00H
	ORG $+5
$SG169691 DB	'impl.c:1202', 00H
	ORG $+4
$SG169694 DB	'HHC00019%s Hercules IS running in test mode', 0aH, 00H
	ORG $+3
$SG169695 DB	'impl', 00H
	ORG $+3
$SG169699 DB	'HHC00021%s Test timeout factor = %3.1f', 0aH, 00H
$SG169700 DB	'impl', 00H
	ORG $+3
$SG169704 DB	'impl', 00H
	ORG $+3
$SG169703 DB	'HHC02323%s This build of Hercules has only partial TCP k'
	DB	'eepalive support', 0aH, 00H
	ORG $+6
$SG169708 DB	'socket()', 00H
	ORG $+7
$SG169710 DB	'HHC02219%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169711 DB	'impl', 00H
	ORG $+3
$SG169715 DB	'set_socket_keepalive()', 00H
	ORG $+1
$SG169717 DB	'HHC02219%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169718 DB	'impl', 00H
	ORG $+3
$SG169722 DB	'HHC02320%s Not all TCP keepalive settings honored', 0aH, 00H
	ORG $+1
$SG169723 DB	'impl', 00H
	ORG $+7
$SG169726 DB	'get_socket_keepalive()', 00H
	ORG $+1
$SG169728 DB	'HHC02219%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169729 DB	'impl', 00H
	ORG $+3
$SG169736 DB	'HHC01409%s Load of dyngui.dll failed, Hercules terminate'
	DB	'd', 0aH, 00H
	ORG $+1
$SG169737 DB	'impl', 00H
	ORG $+3
$SG169738 DB	'impl.c', 00H
	ORG $+5
$SG169743 DB	'HHC01408%s Hercules terminating, see previous messages f'
	DB	'or reason', 0aH, 00H
	ORG $+1
$SG169744 DB	'impl', 00H
	ORG $+3
$SG169745 DB	'impl.c', 00H
	ORG $+1
$SG169747 DB	'SIGINT', 00H
	ORG $+5
$SG169749 DB	'HHC01410%s Cannot register %s handler: %s', 0aH, 00H
	ORG $+1
$SG169750 DB	'impl', 00H
	ORG $+3
$SG169751 DB	'impl.c', 00H
	ORG $+5
$SG169753 DB	'SIGTERM', 00H
$SG169755 DB	'HHC01410%s Cannot register %s handler: %s', 0aH, 00H
	ORG $+1
$SG169756 DB	'impl', 00H
	ORG $+3
$SG169757 DB	'impl.c', 00H
	ORG $+5
$SG169760 DB	'Console-ctrl', 00H
	ORG $+3
$SG169762 DB	'HHC01410%s Cannot register %s handler: %s', 0aH, 00H
	ORG $+1
$SG169763 DB	'impl', 00H
	ORG $+3
$SG169764 DB	'impl.c', 00H
	ORG $+5
$SG169766 DB	'impl.c:1419', 00H
	ORG $+4
$SG169767 DB	'WinMsgThread', 00H
	ORG $+3
$SG169769 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+2
$SG169770 DB	'impl', 00H
	ORG $+3
$SG169771 DB	'impl.c', 00H
	ORG $+5
$SG169773 DB	'CreateWindowEx() failed', 00H
$SG169774 DB	'WinMsgThread', 00H
	ORG $+3
$SG169776 DB	'HHC00136%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169777 DB	'impl', 00H
	ORG $+3
$SG169778 DB	'impl.c', 00H
	ORG $+1
$SG169779 DB	'impl.c:1456', 00H
	ORG $+4
$SG169780 DB	'&sysblk.cnslpipe_lock', 00H
	ORG $+2
$SG169781 DB	'impl.c:1457', 00H
	ORG $+4
$SG169782 DB	'&sysblk.sockpipe_lock', 00H
	ORG $+2
$SG169784 DB	'impl', 00H
	ORG $+3
$SG169785 DB	'impl.c', 00H
	ORG $+1
$SG169786 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169788 DB	'impl', 00H
	ORG $+3
$SG169789 DB	'impl.c', 00H
	ORG $+1
$SG169793 DB	'impl', 00H
	ORG $+3
$SG169790 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169794 DB	'impl.c', 00H
	ORG $+1
$SG169795 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169797 DB	'impl', 00H
	ORG $+3
$SG169798 DB	'impl.c', 00H
	ORG $+1
$SG169803 DB	'watchdog_thread', 00H
$SG169806 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+6
$SG169799 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169801 DB	'release_config', 00H
	ORG $+1
$SG169802 DB	'impl.c:1481', 00H
$SG169807 DB	'impl', 00H
	ORG $+3
$SG169808 DB	'impl.c', 00H
	ORG $+5
$SG169814 DB	'impl.c:1523', 00H
	ORG $+4
$SG169815 DB	'process_rc_file', 00H
$SG169818 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+2
$SG169819 DB	'impl', 00H
	ORG $+3
$SG169820 DB	'impl.c', 00H
	ORG $+5
$SG169822 DB	'impl.c:1533', 00H
	ORG $+4
$SG169823 DB	'log_do_callback', 00H
$SG169826 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+2
$SG169827 DB	'impl', 00H
	ORG $+3
$SG169828 DB	'impl.c', 00H
	ORG $+1
$SG169835 DB	'impl', 00H
	ORG $+3
$SG169836 DB	'impl.c', 00H
	ORG $+1
$SG169839 DB	'impl', 00H
	ORG $+7
$SG169837 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169840 DB	'impl.c', 00H
	ORG $+1
$SG169841 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169855 DB	'hercules', 00H
	ORG $+3
$SG169926 DB	'short', 00H
	ORG $+6
$SG169930 DB	'version', 00H
$SG169934 DB	'build', 00H
	ORG $+2
$SG169939 DB	'long', 00H
	ORG $+3
$SG169940 DB	'full', 00H
	ORG $+3
$SG169942 DB	'HHC00025%s Invalid help option argument: %s', 0aH, 00H
	ORG $+3
$SG169943 DB	'process_args', 00H
	ORG $+3
$SG169944 DB	'impl.c', 00H
	ORG $+1
$SG169957 DB	'HHC01419%s Symbol and/or Value is invalid; ignored', 0aH
	DB	00H
	ORG $+4
$SG169958 DB	'process_args', 00H
	ORG $+3
$SG169959 DB	'impl.c', 00H
	ORG $+1
$SG169961 DB	'HHC01419%s Symbol and/or Value is invalid; ignored', 0aH
	DB	00H
	ORG $+4
$SG169962 DB	'process_args', 00H
	ORG $+3
$SG169963 DB	'impl.c', 00H
	ORG $+1
$SG169973 DB	'impl.c', 00H
	ORG $+1
$SG169971 DB	'HHC01406%s Startup parm -l: maximum loadable modules %d '
	DB	'exceeded; remainder not loaded', 0aH, 00H
$SG169972 DB	'process_args', 00H
	ORG $+3
$SG169985 DB	'impl.c', 00H
	ORG $+1
$SG169983 DB	'HHC00020%s Test timeout factor %s outside of valid range'
	DB	' 1.0 to %3.1f', 0aH, 00H
	ORG $+1
$SG169984 DB	'process_args', 00H
	ORG $+3
$SG169989 DB	'''-%c''', 00H
	ORG $+2
$SG169990 DB	'(hex %2.2x)', 00H
	ORG $+4
$SG169992 DB	'HHC00023%s Invalid/unsupported option: %s', 0aH, 00H
	ORG $+5
$SG169993 DB	'process_args', 00H
	ORG $+3
$SG169994 DB	'impl.c', 00H
	ORG $+1
$SG169996 DB	'HHC00024%s Unrecognized option: %s', 0aH, 00H
	ORG $+4
$SG169997 DB	'process_args', 00H
	ORG $+3
$SG169998 DB	'impl.c', 00H
	ORG $+1
$SG170006 DB	'none', 00H
	ORG $+3
$SG170010 DB	'HHC02342%s %s file ''%s'' not found: %s', 0aH, 00H
	ORG $+1
$SG170011 DB	'process_args', 00H
	ORG $+3
$SG170012 DB	'impl.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:arghelp
	DD	011H
	DD	0deH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:process_rc_file
	DD	016H
	DD	0179H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:watchdog_thread
	DD	016H
	DD	09ffH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:process_args
	DD	01aH
	DD	0caeH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:init_progname
	DD	01aH
	DD	0f0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:impl
	DD	01bH
	DD	022f9H
voltbl	ENDS
xdata	SEGMENT
$unwind$time DD	010901H
	DD	04209H
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$impl DD	032319H
	DD	0320111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0180H
$unwind$wakeup_cpu DD 010e01H
	DD	0420eH
$unwind$wakeup_cpus_mask DD 010e01H
	DD	0620eH
$unwind$Interrupt_Lock_Obtained DD 010e01H
	DD	0420eH
$unwind$Obtain_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$Release_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$init_progname DD 022219H
	DD	0290110H
	DD	imagerel __GSHandlerCheck
	DD	0130H
$unwind$process_args DD 022219H
	DD	0290110H
	DD	imagerel __GSHandlerCheck
	DD	0138H
$unwind$delayed_exit DD 010801H
	DD	04208H
$unwind$sigint_handler DD 010801H
	DD	06208H
$unwind$sigterm_handler DD 010801H
	DD	04208H
$unwind$do_emergency_shutdown DD 010401H
	DD	04204H
$unwind$console_ctrl_handler DD 010801H
	DD	0a208H
$unwind$MainWndProc DD 011701H
	DD	0c217H
$unwind$WinMsgThread DD 030d01H
	DD	01c010dH
	DD	07006H
$unwind$watchdog_thread DD 021e19H
	DD	063010cH
	DD	imagerel __GSHandlerCheck
	DD	0300H
$unwind$log_do_callback DD 010901H
	DD	06209H
$unwind$process_rc_file DD 021e19H
	DD	031010cH
	DD	imagerel __GSHandlerCheck
	DD	0170H
$unwind$arghelp DD 021919H
	DD	02f0107H
	DD	imagerel __GSHandlerCheck
	DD	0160H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\impl.c
_TEXT	SEGMENT
strtok_str$ = 64
tv64 = 72
pgm$ = 80
__$ArrayPad$ = 352
arghelp	PROC

; 780  : {

  00000	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
  00007	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000e	48 33 c4	 xor	 rax, rsp
  00011	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 781  :     char   pgm[ MAX_PATH ];
; 782  :     char*  strtok_str = NULL;

  00019	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR strtok_str$[rsp], 0

; 783  : 
; 784  :     STRLCPY( pgm, sysblk.hercules_pgmname );

  00022	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00028	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002f	48 8b 50 30	 mov	 rdx, QWORD PTR [rax+48]
  00033	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pgm$[rsp]
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 785  : 
; 786  :     // "Usage: %s [--help[=SHORT|LONG|VERSION|BUILD]] -f config-filename|\"none\" [-o logfile-name] [-r rcfile-name] [-d] [-b logo-filename] [-s sym=val] [-t [factor]] [-p dyn-load-dir] [[-l dynmod-to-load]...] [> logfile]"
; 787  :     WRMSG( HHC01407, "S", strtok_r( pgm, ".", &strtok_str ) );

  0003e	4c 8d 44 24 40	 lea	 r8, QWORD PTR strtok_str$[rsp]
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169440
  0004a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pgm$[rsp]
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  00055	48 89 44 24 48	 mov	 QWORD PTR tv64[rsp], rax
  0005a	b9 01 00 00 00	 mov	 ecx, 1
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00065	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv64[rsp]
  0006a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169441
  00076	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169442
  00082	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00087	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00092	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169443
  00099	ba 13 03 00 00	 mov	 edx, 787		; 00000313H
  0009e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169444
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 788  : 
; 789  :     fflush( stderr );

  000ab	b9 02 00 00 00	 mov	 ecx, 2
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b6	48 8b c8	 mov	 rcx, rax
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 790  :     fflush( stdout );

  000bf	b9 01 00 00 00	 mov	 ecx, 1
  000c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 791  :     usleep( 100000 );

  000d3	b9 a0 86 01 00	 mov	 ecx, 100000		; 000186a0H
  000d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 792  : }

  000de	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000e6	48 33 cc	 xor	 rcx, rsp
  000e9	e8 00 00 00 00	 call	 __security_check_cookie
  000ee	48 81 c4 78 01
	00 00		 add	 rsp, 376		; 00000178H
  000f5	c3		 ret	 0
arghelp	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\impl.c
_TEXT	SEGMENT
st$1 = 32
pathname$ = 96
__$ArrayPad$ = 368
dummy$ = 400
process_rc_file PROC

; 733  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@process_rc:

; 734  :     char  pathname[ MAX_PATH ];
; 735  : 
; 736  :     UNREFERENCED( dummy );

  0001e	33 c0		 xor	 eax, eax
  00020	85 c0		 test	 eax, eax
  00022	75 fa		 jne	 SHORT $LN4@process_rc

; 737  : 
; 738  :     /* Obtain the name of the hercules.rc file or default */
; 739  :     if (0
; 740  :         /* Neither '-r' nor "HERCULES_RC" environment variable given */
; 741  :         || !cfgorrc[want_rc].filename
; 742  :         || !cfgorrc[want_rc].filename[0]

  00024	33 c0		 xor	 eax, eax
  00026	85 c0		 test	 eax, eax
  00028	75 3c		 jne	 SHORT $LN8@process_rc
  0002a	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  0002f	48 6b c0 01	 imul	 rax, rax, 1
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cfgorrc
  0003a	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  0003f	74 25		 je	 SHORT $LN8@process_rc
  00041	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00046	48 6b c0 01	 imul	 rax, rax, 1
  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cfgorrc
  00051	ba 01 00 00 00	 mov	 edx, 1
  00056	48 6b d2 00	 imul	 rdx, rdx, 0
  0005a	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0005e	0f be 04 10	 movsx	 eax, BYTE PTR [rax+rdx]
  00062	85 c0		 test	 eax, eax
  00064	75 31		 jne	 SHORT $LN7@process_rc
$LN8@process_rc:

; 743  :     )
; 744  :     {
; 745  :         /* Check for "hercules.rc" file in current directory */
; 746  :         struct stat st;
; 747  :         if (stat( "hercules.rc", &st ) == 0)

  00066	48 8d 54 24 20	 lea	 rdx, QWORD PTR st$1[rsp]
  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169430
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stat64
  00078	85 c0		 test	 eax, eax
  0007a	75 1b		 jne	 SHORT $LN9@process_rc

; 748  :             cfgorrc[want_rc].filename = "hercules.rc";

  0007c	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00081	48 6b c0 01	 imul	 rax, rax, 1
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cfgorrc
  0008c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169431
  00093	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
$LN9@process_rc:
$LN7@process_rc:

; 749  :     }
; 750  : 
; 751  :     /* If we have a hercules.rc file, process it */
; 752  :     if (1
; 753  :         && cfgorrc[want_rc].filename
; 754  :         && cfgorrc[want_rc].filename[0]
; 755  :         && strcasecmp( cfgorrc[want_rc].filename, "None" ) != 0

  00097	33 c0		 xor	 eax, eax
  00099	83 f8 01	 cmp	 eax, 1
  0009c	0f 84 d5 00 00
	00		 je	 $LN10@process_rc
  000a2	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  000a7	48 6b c0 01	 imul	 rax, rax, 1
  000ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cfgorrc
  000b2	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  000b7	0f 84 ba 00 00
	00		 je	 $LN10@process_rc
  000bd	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  000c2	48 6b c0 01	 imul	 rax, rax, 1
  000c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cfgorrc
  000cd	ba 01 00 00 00	 mov	 edx, 1
  000d2	48 6b d2 00	 imul	 rdx, rdx, 0
  000d6	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000da	0f be 04 10	 movsx	 eax, BYTE PTR [rax+rdx]
  000de	85 c0		 test	 eax, eax
  000e0	0f 84 91 00 00
	00		 je	 $LN10@process_rc
  000e6	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  000eb	48 6b c0 01	 imul	 rax, rax, 1
  000ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cfgorrc
  000f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169433
  000fd	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00101	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00107	85 c0		 test	 eax, eax
  00109	74 6c		 je	 SHORT $LN10@process_rc

; 756  :     )
; 757  :     {
; 758  :         hostpath( pathname, cfgorrc[want_rc].filename, sizeof( pathname ));

  0010b	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00110	48 6b c0 01	 imul	 rax, rax, 1
  00114	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cfgorrc
  0011b	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00121	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  00125	48 8d 4c 24 60	 lea	 rcx, QWORD PTR pathname$[rsp]
  0012a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 759  : 
; 760  : #if 1 // ZZ FIXME: THIS NEEDS TO GO
; 761  : 
; 762  :         /* Wait for panel thread to engage */
; 763  :         if (!sysblk.daemon_mode)

  00130	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00137	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0013d	c1 e8 02	 shr	 eax, 2
  00140	83 e0 01	 and	 eax, 1
  00143	85 c0		 test	 eax, eax
  00145	75 24		 jne	 SHORT $LN11@process_rc
$LN5@process_rc:

; 764  :             while (!sysblk.panel_init)

  00147	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0014e	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00154	c1 e8 03	 shr	 eax, 3
  00157	83 e0 01	 and	 eax, 1
  0015a	85 c0		 test	 eax, eax
  0015c	75 0d		 jne	 SHORT $LN6@process_rc

; 765  :                 usleep( 10 * 1000 );

  0015e	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00163	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
  00169	eb dc		 jmp	 SHORT $LN5@process_rc
$LN6@process_rc:
$LN11@process_rc:

; 766  : 
; 767  : #endif // ZZ FIXME: THIS NEEDS TO GO
; 768  : 
; 769  :         /* Run the script processor for this file */
; 770  :         process_script_file( pathname, true );

  0016b	b2 01		 mov	 dl, 1
  0016d	48 8d 4c 24 60	 lea	 rcx, QWORD PTR pathname$[rsp]
  00172	e8 00 00 00 00	 call	 process_script_file
$LN10@process_rc:

; 771  :     }
; 772  : 
; 773  :     return NULL;

  00177	33 c0		 xor	 eax, eax

; 774  : }

  00179	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00181	48 33 cc	 xor	 rcx, rsp
  00184	e8 00 00 00 00	 call	 __security_check_cookie
  00189	48 81 c4 88 01
	00 00		 add	 rsp, 392		; 00000188H
  00190	c3		 ret	 0
process_rc_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\impl.c
_TEXT	SEGMENT
msglen$ = 32
msgidx$ = 36
msgbuf$ = 40
dummy$ = 64
log_do_callback PROC

; 693  : {

$LN10:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 694  :     char* msgbuf;
; 695  :     int   msglen;
; 696  :     int   msgidx = -1;

  00009	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR msgidx$[rsp], -1
$LN4@log_do_cal:

; 697  : 
; 698  :     UNREFERENCED( dummy );

  00011	33 c0		 xor	 eax, eax
  00013	85 c0		 test	 eax, eax
  00015	75 fa		 jne	 SHORT $LN4@log_do_cal
$LN9@log_do_cal:
$LN5@log_do_cal:

; 699  : 
; 700  :     while (!sysblk.shutfini && logger_isactive())

  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001e	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00024	c1 e8 0c	 shr	 eax, 12
  00027	83 e0 01	 and	 eax, 1
  0002a	85 c0		 test	 eax, eax
  0002c	75 4a		 jne	 SHORT $LN6@log_do_cal
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logger_isactive
  00034	85 c0		 test	 eax, eax
  00036	74 40		 je	 SHORT $LN6@log_do_cal

; 701  :     {
; 702  :         msglen = log_read( &msgbuf, &msgidx, LOG_NOBLOCK );

  00038	45 33 c0	 xor	 r8d, r8d
  0003b	48 8d 54 24 24	 lea	 rdx, QWORD PTR msgidx$[rsp]
  00040	48 8d 4c 24 28	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_log_read
  0004b	89 44 24 20	 mov	 DWORD PTR msglen$[rsp], eax

; 703  : 
; 704  :         if (msglen)

  0004f	83 7c 24 20 00	 cmp	 DWORD PTR msglen$[rsp], 0
  00054	74 15		 je	 SHORT $LN7@log_do_cal

; 705  :         {
; 706  :             log_callback( msgbuf, msglen );

  00056	48 63 44 24 20	 movsxd	 rax, DWORD PTR msglen$[rsp]
  0005b	48 8b d0	 mov	 rdx, rax
  0005e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR msgbuf$[rsp]
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR log_callback

; 707  :             continue;

  00069	eb ac		 jmp	 SHORT $LN5@log_do_cal
$LN7@log_do_cal:

; 708  :         }
; 709  : 
; 710  :         /* wait a bit for new message(s) to arrive before retrying */
; 711  :         usleep( PANEL_REFRESH_RATE_FAST * 1000 );

  0006b	b9 50 c3 00 00	 mov	 ecx, 50000		; 0000c350H
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 712  :     }

  00076	eb 9f		 jmp	 SHORT $LN9@log_do_cal
$LN6@log_do_cal:

; 713  : 
; 714  :     /* Let them know logger thread has ended */
; 715  :     log_callback( NULL, 0 );

  00078	33 d2		 xor	 edx, edx
  0007a	33 c9		 xor	 ecx, ecx
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR log_callback

; 716  : 
; 717  :     return (NULL);

  00082	33 c0		 xor	 eax, eax

; 718  : }

  00084	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00088	c3		 ret	 0
log_do_callback ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\impl.c
_TEXT	SEGMENT
cpu$ = 80
deadlock_reported$ = 84
hung_cpu_reported$ = 85
regs$1 = 88
rc$2 = 96
slept_secs$ = 100
sleep_seconds$ = 104
rc$3 = 108
rc$4 = 112
regs$ = 120
hung_cpus_mask$ = 128
sleep_secs2nd$ = 136
i$5 = 140
tv80 = 144
tv320 = 148
tv327 = 152
tv334 = 156
tv336 = 160
tv141 = 168
tv362 = 176
tv158 = 184
tv466 = 192
tv475 = 200
tv228 = 208
tv251 = 216
tv501 = 224
ip$6 = 232
p$7 = 240
savecount$ = 256
__$ArrayPad$ = 768
arg$ = 800
watchdog_thread PROC

; 462  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 18 03
	00 00		 sub	 rsp, 792		; 00000318H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 00
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 463  :     REGS* regs;
; 464  :     S64   savecount[ MAX_CPU_ENGS ];
; 465  :     int   cpu;
; 466  :     int   sleep_seconds  = WATCHDOG_SECS;

  0001e	c7 44 24 68 14
	00 00 00	 mov	 DWORD PTR sleep_seconds$[rsp], 20

; 467  :     int   sleep_secs2nd  = 3;

  00026	c7 84 24 88 00
	00 00 03 00 00
	00		 mov	 DWORD PTR sleep_secs2nd$[rsp], 3

; 468  :     int   slept_secs;
; 469  : 
; 470  :     bool  deadlock_reported = false;

  00031	c6 44 24 54 00	 mov	 BYTE PTR deadlock_reported$[rsp], 0

; 471  :     bool  hung_cpu_reported = false;

  00036	c6 44 24 55 00	 mov	 BYTE PTR hung_cpu_reported$[rsp], 0

; 472  : 
; 473  :     CPU_BITMAP  hung_cpus_mask  = 0;

  0003b	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR hung_cpus_mask$[rsp], 0
$LN4@watchdog_t:

; 474  : 
; 475  :     UNREFERENCED( arg );

  00047	33 c0		 xor	 eax, eax
  00049	85 c0		 test	 eax, eax
  0004b	75 fa		 jne	 SHORT $LN4@watchdog_t

; 476  : 
; 477  :     for (cpu=0; cpu < sysblk.maxcpu; cpu++)

  0004d	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR cpu$[rsp], 0
  00055	eb 0a		 jmp	 SHORT $LN7@watchdog_t
$LN5@watchdog_t:
  00057	8b 44 24 50	 mov	 eax, DWORD PTR cpu$[rsp]
  0005b	ff c0		 inc	 eax
  0005d	89 44 24 50	 mov	 DWORD PTR cpu$[rsp], eax
$LN7@watchdog_t:
  00061	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00068	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0006e	39 44 24 50	 cmp	 DWORD PTR cpu$[rsp], eax
  00072	7d 13		 jge	 SHORT $LN6@watchdog_t

; 478  :         savecount[ cpu ] = -1;

  00074	48 63 44 24 50	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00079	48 c7 84 c4 00
	01 00 00 ff ff
	ff ff		 mov	 QWORD PTR savecount$[rsp+rax*8], -1
  00085	eb d0		 jmp	 SHORT $LN5@watchdog_t
$LN6@watchdog_t:

; 479  : 
; 480  :     /* Set watchdog priority LOWER than the CPU thread priority
; 481  :        such that it will not invalidly detect an inoperable CPU
; 482  :     */
; 483  :     set_thread_priority( MAX( sysblk.minprio, sysblk.cpuprio - 1 ));

  00087	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0008e	8b 80 6c 13 00
	00		 mov	 eax, DWORD PTR [rax+4972]
  00094	ff c8		 dec	 eax
  00096	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0009d	39 81 5c 13 00
	00		 cmp	 DWORD PTR [rcx+4956], eax
  000a3	7e 16		 jle	 SHORT $LN73@watchdog_t
  000a5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ac	8b 80 5c 13 00
	00		 mov	 eax, DWORD PTR [rax+4956]
  000b2	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv80[rsp], eax
  000b9	eb 16		 jmp	 SHORT $LN74@watchdog_t
$LN73@watchdog_t:
  000bb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000c2	8b 80 6c 13 00
	00		 mov	 eax, DWORD PTR [rax+4972]
  000c8	ff c8		 dec	 eax
  000ca	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv80[rsp], eax
$LN74@watchdog_t:
  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  000d7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169348
  000de	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR tv80[rsp]
  000e5	8b c8		 mov	 ecx, eax
  000e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_thread_prio
$LN10@watchdog_t:

; 484  : 
; 485  :     do
; 486  :     {
; 487  :         /* PROGRAMMING NOTE: sleeping in many small increments (rather
; 488  :            than one large sleep) prevents problems that can occur when
; 489  :            the system resumes (awakens) after having been suspended.
; 490  :            (GH Issue #458 "Hercules crash after resume from suspend")
; 491  :         */
; 492  :         for (slept_secs=0; slept_secs < sleep_seconds; ++slept_secs)

  000ed	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR slept_secs$[rsp], 0
  000f5	eb 0a		 jmp	 SHORT $LN13@watchdog_t
$LN11@watchdog_t:
  000f7	8b 44 24 64	 mov	 eax, DWORD PTR slept_secs$[rsp]
  000fb	ff c0		 inc	 eax
  000fd	89 44 24 64	 mov	 DWORD PTR slept_secs$[rsp], eax
$LN13@watchdog_t:
  00101	8b 44 24 68	 mov	 eax, DWORD PTR sleep_seconds$[rsp]
  00105	39 44 24 64	 cmp	 DWORD PTR slept_secs$[rsp], eax
  00109	0f 8d c7 00 00
	00		 jge	 $LN12@watchdog_t
$LN16@watchdog_t:

; 493  :         {
; 494  :             SLEEP( 1 );     /* (sleep one second at a time) */

  0010f	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR rc$2[rsp], 1
$LN17@watchdog_t:
  00117	83 7c 24 60 00	 cmp	 DWORD PTR rc$2[rsp], 0
  0011c	74 1d		 je	 SHORT $LN18@watchdog_t
  0011e	8b 4c 24 60	 mov	 ecx, DWORD PTR rc$2[rsp]
  00122	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sleep
  00128	89 44 24 60	 mov	 DWORD PTR rc$2[rsp], eax
  0012c	83 7c 24 60 00	 cmp	 DWORD PTR rc$2[rsp], 0
  00131	74 06		 je	 SHORT $LN47@watchdog_t
  00133	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield
$LN47@watchdog_t:
  00139	eb dc		 jmp	 SHORT $LN17@watchdog_t
$LN18@watchdog_t:
  0013b	33 c0		 xor	 eax, eax
  0013d	85 c0		 test	 eax, eax
  0013f	75 ce		 jne	 SHORT $LN16@watchdog_t

; 495  : 
; 496  : #if defined( _MSVC_ )
; 497  :             /* Start over again upon resume from suspend. This should
; 498  :                hopefully resolve GitHub Issue #489 "Hercules 4.4.1
; 499  :                crashes after OSA failure" by preventing malfunctioning
; 500  :                CPU false positives.
; 501  :             */
; 502  :             if (sysblk.sys_suspended || sysblk.sys_resumed)

  00141	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00148	0f b6 80 e4 00
	00 00		 movzx	 eax, BYTE PTR [rax+228]
  0014f	85 c0		 test	 eax, eax
  00151	75 12		 jne	 SHORT $LN49@watchdog_t
  00153	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0015a	0f b6 80 e5 00
	00 00		 movzx	 eax, BYTE PTR [rax+229]
  00161	85 c0		 test	 eax, eax
  00163	74 6c		 je	 SHORT $LN48@watchdog_t
$LN49@watchdog_t:

; 503  :             {
; 504  :                 /* We're either being suspended or resumed */
; 505  :                 sleep_seconds  = WATCHDOG_SECS;

  00165	c7 44 24 68 14
	00 00 00	 mov	 DWORD PTR sleep_seconds$[rsp], 20

; 506  :                 sleep_secs2nd  = 3;

  0016d	c7 84 24 88 00
	00 00 03 00 00
	00		 mov	 DWORD PTR sleep_secs2nd$[rsp], 3

; 507  :                 slept_secs     = 0;

  00178	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR slept_secs$[rsp], 0

; 508  :                 hung_cpus_mask = 0;

  00180	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR hung_cpus_mask$[rsp], 0

; 509  : 
; 510  :                 /* If being resumed, reset our flags to normal */
; 511  :                 if (!sysblk.sys_suspended && sysblk.sys_resumed)

  0018c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00193	0f b6 80 e4 00
	00 00		 movzx	 eax, BYTE PTR [rax+228]
  0019a	85 c0		 test	 eax, eax
  0019c	75 2e		 jne	 SHORT $LN50@watchdog_t
  0019e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001a5	0f b6 80 e5 00
	00 00		 movzx	 eax, BYTE PTR [rax+229]
  001ac	85 c0		 test	 eax, eax
  001ae	74 1c		 je	 SHORT $LN50@watchdog_t

; 512  :                 {
; 513  :                     sysblk.sys_suspended = false;

  001b0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001b7	c6 80 e4 00 00
	00 00		 mov	 BYTE PTR [rax+228], 0

; 514  :                     sysblk.sys_resumed   = false;

  001be	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001c5	c6 80 e5 00 00
	00 00		 mov	 BYTE PTR [rax+229], 0
$LN50@watchdog_t:

; 515  :                 }
; 516  : 
; 517  :                 continue;   /* (start over) */

  001cc	e9 26 ff ff ff	 jmp	 $LN11@watchdog_t
$LN48@watchdog_t:

; 518  :             }
; 519  : #endif
; 520  :         } /* (end for (slept_secs ...) */

  001d1	e9 21 ff ff ff	 jmp	 $LN11@watchdog_t
$LN12@watchdog_t:

; 521  : 
; 522  : #if defined( _MSVC_ )
; 523  :         // Disable all watchdog logic while debugger is attached
; 524  :         if (IsDebuggerPresent())

  001d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001dc	85 c0		 test	 eax, eax
  001de	74 05		 je	 SHORT $LN51@watchdog_t

; 525  :             continue;

  001e0	e9 fd 07 00 00	 jmp	 $LN8@watchdog_t
$LN51@watchdog_t:

; 526  : #endif
; 527  :         /* Check for and report any deadlocks */
; 528  :         if (hthread_report_deadlocks( deadlock_reported ? NULL : "S" ))

  001e5	0f b6 44 24 54	 movzx	 eax, BYTE PTR deadlock_reported$[rsp]
  001ea	85 c0		 test	 eax, eax
  001ec	74 0e		 je	 SHORT $LN75@watchdog_t
  001ee	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv141[rsp], 0
  001fa	eb 0f		 jmp	 SHORT $LN76@watchdog_t
$LN75@watchdog_t:
  001fc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169355
  00203	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv141[rsp], rax
$LN76@watchdog_t:
  0020b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv141[rsp]
  00213	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_report_deadlocks
  00219	85 c0		 test	 eax, eax
  0021b	0f 84 83 00 00
	00		 je	 $LN52@watchdog_t

; 529  :         {
; 530  :             /*****************************************************/
; 531  :             /*               DEADLOCK DETECTED!                  */
; 532  :             /*****************************************************/
; 533  : 
; 534  :             if (!deadlock_reported)

  00221	0f b6 44 24 54	 movzx	 eax, BYTE PTR deadlock_reported$[rsp]
  00226	85 c0		 test	 eax, eax
  00228	75 75		 jne	 SHORT $LN53@watchdog_t

; 535  :             {
; 536  :                 // "DEADLOCK!"
; 537  :                 WRMSG( HHC90024, "S" );

  0022a	b9 01 00 00 00	 mov	 ecx, 1
  0022f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00235	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169357
  0023c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00241	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169358
  00248	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0024d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00252	41 b9 03 00 00
	00		 mov	 r9d, 3
  00258	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169359
  0025f	ba 19 02 00 00	 mov	 edx, 537		; 00000219H
  00264	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169360
  0026b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 538  :                 HDC1( debug_watchdog_signal, NULL );

  00271	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_watchdog_signal
  00278	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0027c	74 15		 je	 SHORT $LN77@watchdog_t
  0027e	33 c9		 xor	 ecx, ecx
  00280	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_watchdog_signal
  00287	ff 10		 call	 QWORD PTR [rax]
  00289	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv158[rsp], rax
  00291	eb 0c		 jmp	 SHORT $LN78@watchdog_t
$LN77@watchdog_t:
  00293	48 c7 84 24 b8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv158[rsp], 0
$LN78@watchdog_t:
$LN53@watchdog_t:

; 539  :             }
; 540  :             deadlock_reported = true;

  0029f	c6 44 24 54 01	 mov	 BYTE PTR deadlock_reported$[rsp], 1
$LN52@watchdog_t:

; 541  :         }
; 542  : 
; 543  :         for (cpu=0; cpu < sysblk.maxcpu; cpu++)

  002a4	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR cpu$[rsp], 0
  002ac	eb 0a		 jmp	 SHORT $LN21@watchdog_t
$LN19@watchdog_t:
  002ae	8b 44 24 50	 mov	 eax, DWORD PTR cpu$[rsp]
  002b2	ff c0		 inc	 eax
  002b4	89 44 24 50	 mov	 DWORD PTR cpu$[rsp], eax
$LN21@watchdog_t:
  002b8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002bf	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  002c5	39 44 24 50	 cmp	 DWORD PTR cpu$[rsp], eax
  002c9	0f 8d 5e 01 00
	00		 jge	 $LN20@watchdog_t

; 544  :         {
; 545  :             /* We're only interested in ONLINE and STARTED CPUs */
; 546  :             if (0
; 547  :                 || !IS_CPU_ONLINE( cpu )
; 548  :                 || (regs = sysblk.regs[ cpu ])->cpustate != CPUSTATE_STARTED

  002cf	33 c0		 xor	 eax, eax
  002d1	85 c0		 test	 eax, eax
  002d3	75 3e		 jne	 SHORT $LN55@watchdog_t
  002d5	48 63 44 24 50	 movsxd	 rax, DWORD PTR cpu$[rsp]
  002da	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002e1	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  002ea	74 27		 je	 SHORT $LN55@watchdog_t
  002ec	48 63 44 24 50	 movsxd	 rax, DWORD PTR cpu$[rsp]
  002f1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002f8	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00300	48 89 44 24 78	 mov	 QWORD PTR regs$[rsp], rax
  00305	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0030a	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  0030e	83 f8 01	 cmp	 eax, 1
  00311	74 13		 je	 SHORT $LN54@watchdog_t
$LN55@watchdog_t:

; 549  :             )
; 550  :             {
; 551  :                 /* CPU not ONLINE or not STARTED */
; 552  :                 savecount[ cpu ] = -1;

  00313	48 63 44 24 50	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00318	48 c7 84 c4 00
	01 00 00 ff ff
	ff ff		 mov	 QWORD PTR savecount$[rsp+rax*8], -1

; 553  :                 continue;

  00324	eb 88		 jmp	 SHORT $LN19@watchdog_t
$LN54@watchdog_t:

; 554  :             }
; 555  : 
; 556  :             /* CPU is ONLINE and STARTED. Now check to see if it's
; 557  :                maybe in a WAITSTATE. If so, we're not interested.
; 558  :             */
; 559  :             if (0
; 560  :                 || WAITSTATE( &regs->psw )
; 561  : #if defined( _FEATURE_WAITSTATE_ASSIST )
; 562  :                 || (1

  00326	33 c0		 xor	 eax, eax
  00328	85 c0		 test	 eax, eax
  0032a	75 40		 jne	 SHORT $LN57@watchdog_t
  0032c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00331	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00335	83 e0 02	 and	 eax, 2
  00338	85 c0		 test	 eax, eax
  0033a	75 30		 jne	 SHORT $LN57@watchdog_t
  0033c	33 c0		 xor	 eax, eax
  0033e	83 f8 01	 cmp	 eax, 1
  00341	74 3f		 je	 SHORT $LN56@watchdog_t
  00343	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00348	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0034e	83 e0 01	 and	 eax, 1
  00351	85 c0		 test	 eax, eax
  00353	74 2d		 je	 SHORT $LN56@watchdog_t
  00355	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0035a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00361	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00365	83 e0 02	 and	 eax, 2
  00368	85 c0		 test	 eax, eax
  0036a	74 16		 je	 SHORT $LN56@watchdog_t
$LN57@watchdog_t:

; 563  :                     && regs->sie_active
; 564  :                     && WAITSTATE( &GUESTREGS->psw )
; 565  :                    )
; 566  : #endif
; 567  :             )
; 568  :             {
; 569  :                 /* CPU is in a WAITSTATE */
; 570  :                 savecount[ cpu ] = -1;

  0036c	48 63 44 24 50	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00371	48 c7 84 c4 00
	01 00 00 ff ff
	ff ff		 mov	 QWORD PTR savecount$[rsp+rax*8], -1

; 571  :                 continue;

  0037d	e9 2c ff ff ff	 jmp	 $LN19@watchdog_t
$LN56@watchdog_t:

; 572  :             }
; 573  : 
; 574  :             /* We have found a running CPU that should be executing
; 575  :                instructions. Compare its current instruction count
; 576  :                with our previously saved value. If they're different
; 577  :                then it has obviously executed SOME instructions and
; 578  :                all is well. Save its current instruction counter and
; 579  :                move on the next CPU. This one appears to be healthy.
; 580  :             */
; 581  :             if (INSTCOUNT( regs ) != (U64) savecount[ cpu ])

  00382	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00387	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0038e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00393	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  0039a	8b 89 98 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1944]
  003a0	48 03 88 90 07
	00 00		 add	 rcx, QWORD PTR [rax+1936]
  003a7	48 8b c1	 mov	 rax, rcx
  003aa	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR cpu$[rsp]
  003af	48 3b 84 cc 00
	01 00 00	 cmp	 rax, QWORD PTR savecount$[rsp+rcx*8]
  003b7	74 3a		 je	 SHORT $LN58@watchdog_t

; 582  :             {
; 583  :                 /* Save updated instruction count for next time */
; 584  :                 savecount[ cpu ] = INSTCOUNT( regs );

  003b9	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003be	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  003c5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003ca	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  003d1	8b 89 98 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1944]
  003d7	48 03 88 90 07
	00 00		 add	 rcx, QWORD PTR [rax+1936]
  003de	48 8b c1	 mov	 rax, rcx
  003e1	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR cpu$[rsp]
  003e6	48 89 84 cc 00
	01 00 00	 mov	 QWORD PTR savecount$[rsp+rcx*8], rax

; 585  :                 continue;

  003ee	e9 bb fe ff ff	 jmp	 $LN19@watchdog_t
$LN58@watchdog_t:

; 586  :             }
; 587  : 
; 588  :             /*****************************************************/
; 589  :             /*           MALFUNCTIONING CPU DETECTED!            */
; 590  :             /*****************************************************/
; 591  : 
; 592  :             hung_cpus_mask |= CPU_BIT( cpu );

  003f3	8b 44 24 50	 mov	 eax, DWORD PTR cpu$[rsp]
  003f7	b9 01 00 00 00	 mov	 ecx, 1
  003fc	48 89 8c 24 c0
	00 00 00	 mov	 QWORD PTR tv466[rsp], rcx
  00404	0f b6 c8	 movzx	 ecx, al
  00407	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv466[rsp]
  0040f	48 d3 e0	 shl	 rax, cl
  00412	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR hung_cpus_mask$[rsp]
  0041a	48 0b c8	 or	 rcx, rax
  0041d	48 8b c1	 mov	 rax, rcx
  00420	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR hung_cpus_mask$[rsp], rax

; 593  :         }

  00428	e9 81 fe ff ff	 jmp	 $LN19@watchdog_t
$LN20@watchdog_t:

; 594  : 
; 595  :         /* If any hung CPUs were detected, do a second pass in
; 596  :            case there is another CPU that also stopped executing
; 597  :            instructions a few seconds after the first one did.
; 598  :         */
; 599  :         if (hung_cpus_mask && sleep_seconds != sleep_secs2nd)

  0042d	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR hung_cpus_mask$[rsp], 0
  00436	74 1d		 je	 SHORT $LN59@watchdog_t
  00438	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR sleep_secs2nd$[rsp]
  0043f	39 44 24 68	 cmp	 DWORD PTR sleep_seconds$[rsp], eax
  00443	74 10		 je	 SHORT $LN59@watchdog_t

; 600  :         {
; 601  :             sleep_seconds = sleep_secs2nd;

  00445	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR sleep_secs2nd$[rsp]
  0044c	89 44 24 68	 mov	 DWORD PTR sleep_seconds$[rsp], eax

; 602  :             continue;

  00450	e9 8d 05 00 00	 jmp	 $LN8@watchdog_t
$LN59@watchdog_t:

; 603  :         }
; 604  : 
; 605  :         /* Report all hung CPUs all at the same time */
; 606  :         if (hung_cpus_mask && !hung_cpu_reported)

  00455	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR hung_cpus_mask$[rsp], 0
  0045e	0f 84 36 01 00
	00		 je	 $LN60@watchdog_t
  00464	0f b6 44 24 55	 movzx	 eax, BYTE PTR hung_cpu_reported$[rsp]
  00469	85 c0		 test	 eax, eax
  0046b	0f 85 29 01 00
	00		 jne	 $LN60@watchdog_t

; 607  :         {
; 608  :             for (cpu=0; cpu < sysblk.maxcpu; cpu++)

  00471	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR cpu$[rsp], 0
  00479	eb 0a		 jmp	 SHORT $LN24@watchdog_t
$LN22@watchdog_t:
  0047b	8b 44 24 50	 mov	 eax, DWORD PTR cpu$[rsp]
  0047f	ff c0		 inc	 eax
  00481	89 44 24 50	 mov	 DWORD PTR cpu$[rsp], eax
$LN24@watchdog_t:
  00485	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0048c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00492	39 44 24 50	 cmp	 DWORD PTR cpu$[rsp], eax
  00496	0f 8d f9 00 00
	00		 jge	 $LN23@watchdog_t

; 609  :             {
; 610  :                 if (hung_cpus_mask & CPU_BIT( cpu ))

  0049c	8b 44 24 50	 mov	 eax, DWORD PTR cpu$[rsp]
  004a0	b9 01 00 00 00	 mov	 ecx, 1
  004a5	48 89 8c 24 c8
	00 00 00	 mov	 QWORD PTR tv475[rsp], rcx
  004ad	0f b6 c8	 movzx	 ecx, al
  004b0	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv475[rsp]
  004b8	48 d3 e0	 shl	 rax, cl
  004bb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR hung_cpus_mask$[rsp]
  004c3	48 23 c8	 and	 rcx, rax
  004c6	48 8b c1	 mov	 rax, rcx
  004c9	48 85 c0	 test	 rax, rax
  004cc	0f 84 be 00 00
	00		 je	 $LN61@watchdog_t

; 611  :                 {
; 612  :                     // "PROCESSOR %s%02X APPEARS TO BE HUNG!"
; 613  :                     WRMSG( HHC00822, "S", PTYPSTR( cpu ), cpu );

  004d2	48 63 44 24 50	 movsxd	 rax, DWORD PTR cpu$[rsp]
  004d7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004de	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  004e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  004ec	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv228[rsp], rax
  004f4	b9 01 00 00 00	 mov	 ecx, 1
  004f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004ff	8b 4c 24 50	 mov	 ecx, DWORD PTR cpu$[rsp]
  00503	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00507	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv228[rsp]
  0050f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00514	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169369
  0051b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00520	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169370
  00527	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0052c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00531	41 b9 03 00 00
	00		 mov	 r9d, 3
  00537	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169371
  0053e	ba 65 02 00 00	 mov	 edx, 613		; 00000265H
  00543	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169372
  0054a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 614  :                     HDC1( debug_watchdog_signal, sysblk.regs[ cpu ]);

  00550	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_watchdog_signal
  00557	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0055b	74 27		 je	 SHORT $LN79@watchdog_t
  0055d	48 63 44 24 50	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00562	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00569	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  00571	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_watchdog_signal
  00578	ff 10		 call	 QWORD PTR [rax]
  0057a	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv251[rsp], rax
  00582	eb 0c		 jmp	 SHORT $LN80@watchdog_t
$LN79@watchdog_t:
  00584	48 c7 84 24 d8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv251[rsp], 0
$LN80@watchdog_t:
$LN61@watchdog_t:

; 615  :                 }
; 616  :             }

  00590	e9 e6 fe ff ff	 jmp	 $LN22@watchdog_t
$LN23@watchdog_t:

; 617  : 
; 618  :             hung_cpu_reported = true;

  00595	c6 44 24 55 01	 mov	 BYTE PTR hung_cpu_reported$[rsp], 1
$LN60@watchdog_t:

; 619  :         }
; 620  : 
; 621  :         /* Create a crash dump if any problems were detected */
; 622  :         if (deadlock_reported || hung_cpu_reported)

  0059a	0f b6 44 24 54	 movzx	 eax, BYTE PTR deadlock_reported$[rsp]
  0059f	85 c0		 test	 eax, eax
  005a1	75 0d		 jne	 SHORT $LN63@watchdog_t
  005a3	0f b6 44 24 55	 movzx	 eax, BYTE PTR hung_cpu_reported$[rsp]
  005a8	85 c0		 test	 eax, eax
  005aa	0f 84 32 04 00
	00		 je	 $LN62@watchdog_t
$LN63@watchdog_t:

; 623  :         {
; 624  : #if defined( _MSVC_ )
; 625  :             // Give developer time to attach a debugger before crashing
; 626  :             // If they do so, then prevent the crash from occurring as
; 627  :             // long as their debugger is still attached, but once they
; 628  :             // detach their debugger, then go ahead and allow the crash
; 629  : 
; 630  :             // "You have %d seconds to attach a debugger before crash dump will be taken!"
; 631  :             WRMSG( HHC00823, "S", WAIT_FOR_DEBUGGER_SECS );

  005b0	b9 01 00 00 00	 mov	 ecx, 1
  005b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005bb	c7 44 24 38 2d
	00 00 00	 mov	 DWORD PTR [rsp+56], 45	; 0000002dH
  005c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169375
  005ca	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169376
  005d6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005db	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005e0	41 b9 03 00 00
	00		 mov	 r9d, 3
  005e6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169377
  005ed	ba 77 02 00 00	 mov	 edx, 631		; 00000277H
  005f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169378
  005f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 632  :             {
; 633  :                 int i;
; 634  :                 for (i=0; !IsDebuggerPresent() && i < WAIT_FOR_DEBUGGER_SECS; ++i)

  005ff	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$5[rsp], 0
  0060a	eb 10		 jmp	 SHORT $LN27@watchdog_t
$LN25@watchdog_t:
  0060c	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR i$5[rsp]
  00613	ff c0		 inc	 eax
  00615	89 84 24 8c 00
	00 00		 mov	 DWORD PTR i$5[rsp], eax
$LN27@watchdog_t:
  0061c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00622	85 c0		 test	 eax, eax
  00624	75 3e		 jne	 SHORT $LN26@watchdog_t
  00626	83 bc 24 8c 00
	00 00 2d	 cmp	 DWORD PTR i$5[rsp], 45	; 0000002dH
  0062e	7d 34		 jge	 SHORT $LN26@watchdog_t
$LN30@watchdog_t:

; 635  :                     SLEEP( 1 );

  00630	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR rc$3[rsp], 1
$LN31@watchdog_t:
  00638	83 7c 24 6c 00	 cmp	 DWORD PTR rc$3[rsp], 0
  0063d	74 1d		 je	 SHORT $LN32@watchdog_t
  0063f	8b 4c 24 6c	 mov	 ecx, DWORD PTR rc$3[rsp]
  00643	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sleep
  00649	89 44 24 6c	 mov	 DWORD PTR rc$3[rsp], eax
  0064d	83 7c 24 6c 00	 cmp	 DWORD PTR rc$3[rsp], 0
  00652	74 06		 je	 SHORT $LN64@watchdog_t
  00654	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield
$LN64@watchdog_t:
  0065a	eb dc		 jmp	 SHORT $LN31@watchdog_t
$LN32@watchdog_t:
  0065c	33 c0		 xor	 eax, eax
  0065e	85 c0		 test	 eax, eax
  00660	75 ce		 jne	 SHORT $LN30@watchdog_t
  00662	eb a8		 jmp	 SHORT $LN25@watchdog_t
$LN26@watchdog_t:

; 636  : 
; 637  :                 // Don't crash if there is now a debugger attached
; 638  :                 if (IsDebuggerPresent())

  00664	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0066a	85 c0		 test	 eax, eax
  0066c	74 4c		 je	 SHORT $LN65@watchdog_t

; 639  :                 {
; 640  :                     // "Debugger attached! NOT crashing!"
; 641  :                     WRMSG( HHC00824, "S" );

  0066e	b9 01 00 00 00	 mov	 ecx, 1
  00673	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00679	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169381
  00680	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00685	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169382
  0068c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00691	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00696	41 b9 03 00 00
	00		 mov	 r9d, 3
  0069c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169383
  006a3	ba 81 02 00 00	 mov	 edx, 641		; 00000281H
  006a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169384
  006af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 642  :                     continue;

  006b5	e9 28 03 00 00	 jmp	 $LN8@watchdog_t
$LN65@watchdog_t:

; 643  :                 }
; 644  : 
; 645  :                 // "TIME'S UP! (or debugger has been detached!) - Forcing crash dump!"
; 646  :                 WRMSG( HHC00825, "S" );

  006ba	b9 01 00 00 00	 mov	 ecx, 1
  006bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169385
  006cc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169386
  006d8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006dd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006e2	41 b9 03 00 00
	00		 mov	 r9d, 3
  006e8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169387
  006ef	ba 86 02 00 00	 mov	 edx, 646		; 00000286H
  006f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169388
  006fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 647  :             }
; 648  : #endif
; 649  :             /* Display additional debugging information */
; 650  :             panel_command( "ptt" );

  00701	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169389
  00708	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_panel_command
  0070f	ff 10		 call	 QWORD PTR [rax]

; 651  :             panel_command( "ipending" );

  00711	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169390
  00718	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_panel_command
  0071f	ff 10		 call	 QWORD PTR [rax]

; 652  :             panel_command( "locks held sort tid" );

  00721	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169391
  00728	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_panel_command
  0072f	ff 10		 call	 QWORD PTR [rax]

; 653  :             panel_command( "threads waiting sort tid" );

  00731	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169392
  00738	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_panel_command
  0073f	ff 10		 call	 QWORD PTR [rax]

; 654  : 
; 655  :             /* Display the instruction each hung CPU was executing */
; 656  :             if (hung_cpus_mask)

  00741	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR hung_cpus_mask$[rsp], 0
  0074a	0f 84 43 02 00
	00		 je	 $LN66@watchdog_t

; 657  :             {
; 658  :                 BYTE* ip;
; 659  :                 REGS* regs;
; 660  : 
; 661  :                 for (cpu=0; cpu < sysblk.maxcpu; cpu++)

  00750	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR cpu$[rsp], 0
  00758	eb 0a		 jmp	 SHORT $LN35@watchdog_t
$LN33@watchdog_t:
  0075a	8b 44 24 50	 mov	 eax, DWORD PTR cpu$[rsp]
  0075e	ff c0		 inc	 eax
  00760	89 44 24 50	 mov	 DWORD PTR cpu$[rsp], eax
$LN35@watchdog_t:
  00764	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0076b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00771	39 44 24 50	 cmp	 DWORD PTR cpu$[rsp], eax
  00775	0f 8d 18 02 00
	00		 jge	 $LN34@watchdog_t

; 662  :                 {
; 663  :                     if (hung_cpus_mask & CPU_BIT( cpu ))

  0077b	8b 44 24 50	 mov	 eax, DWORD PTR cpu$[rsp]
  0077f	b9 01 00 00 00	 mov	 ecx, 1
  00784	48 89 8c 24 e0
	00 00 00	 mov	 QWORD PTR tv501[rsp], rcx
  0078c	0f b6 c8	 movzx	 ecx, al
  0078f	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv501[rsp]
  00797	48 d3 e0	 shl	 rax, cl
  0079a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR hung_cpus_mask$[rsp]
  007a2	48 23 c8	 and	 rcx, rax
  007a5	48 8b c1	 mov	 rax, rcx
  007a8	48 85 c0	 test	 rax, rax
  007ab	0f 84 dd 01 00
	00		 je	 $LN67@watchdog_t

; 664  :                     {
; 665  :                         /* Backup to actual instruction being executed */
; 666  :                         regs = sysblk.regs[ cpu ];

  007b1	48 63 44 24 50	 movsxd	 rax, DWORD PTR cpu$[rsp]
  007b6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  007bd	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  007c5	48 89 44 24 58	 mov	 QWORD PTR regs$1[rsp], rax
$LN38@watchdog_t:

; 667  :                         SET_PSW_IA_AND_MAYBE_IP( regs, PSW_IA_FROM_IP( regs, -REAL_ILC( regs )));

  007ca	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$1[rsp]
  007cf	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  007d5	83 e0 01	 and	 eax, 1
  007d8	85 c0		 test	 eax, eax
  007da	75 0d		 jne	 SHORT $LN81@watchdog_t
  007dc	c7 84 24 94 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv320[rsp], 1
  007e7	eb 0b		 jmp	 SHORT $LN82@watchdog_t
$LN81@watchdog_t:
  007e9	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv320[rsp], 0
$LN82@watchdog_t:
  007f4	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR tv320[rsp], 0
  007fc	74 0d		 je	 SHORT $LN85@watchdog_t
  007fe	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv327[rsp], 1
  00809	eb 0b		 jmp	 SHORT $LN86@watchdog_t
$LN85@watchdog_t:
  0080b	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv327[rsp], 0
$LN86@watchdog_t:
  00816	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR tv327[rsp], 0
  0081e	74 15		 je	 SHORT $LN89@watchdog_t
  00820	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$1[rsp]
  00825	0f b6 80 9a 00
	00 00		 movzx	 eax, BYTE PTR [rax+154]
  0082c	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv336[rsp], eax
  00833	eb 3a		 jmp	 SHORT $LN90@watchdog_t
$LN89@watchdog_t:
  00835	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$1[rsp]
  0083a	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00840	d1 e8		 shr	 eax, 1
  00842	83 e0 01	 and	 eax, 1
  00845	85 c0		 test	 eax, eax
  00847	74 0d		 je	 SHORT $LN87@watchdog_t
  00849	c7 84 24 9c 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv334[rsp], 6
  00854	eb 0b		 jmp	 SHORT $LN88@watchdog_t
$LN87@watchdog_t:
  00856	c7 84 24 9c 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv334[rsp], 4
$LN88@watchdog_t:
  00861	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR tv334[rsp]
  00868	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv336[rsp], eax
$LN90@watchdog_t:
  0086f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$1[rsp]
  00874	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0087a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$1[rsp]
  0087f	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$1[rsp]
  00884	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0088b	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0088f	48 2b ca	 sub	 rcx, rdx
  00892	48 03 c1	 add	 rax, rcx
  00895	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv336[rsp]
  0089c	f7 d9		 neg	 ecx
  0089e	48 63 c9	 movsxd	 rcx, ecx
  008a1	48 03 c1	 add	 rax, rcx
  008a4	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  008aa	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  008af	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$1[rsp]
  008b4	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  008ba	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$1[rsp]
  008bf	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  008c7	74 5c		 je	 SHORT $LN68@watchdog_t
  008c9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$1[rsp]
  008ce	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  008d4	25 01 f8 ff 7f	 and	 eax, 2147481601		; 7ffff801H
  008d9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$1[rsp]
  008de	39 81 10 02 00
	00		 cmp	 DWORD PTR [rcx+528], eax
  008e4	75 2f		 jne	 SHORT $LN69@watchdog_t
  008e6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$1[rsp]
  008eb	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  008f1	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  008f6	8b c0		 mov	 eax, eax
  008f8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$1[rsp]
  008fd	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00904	48 0b c8	 or	 rcx, rax
  00907	48 8b c1	 mov	 rax, rcx
  0090a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$1[rsp]
  0090f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00913	eb 10		 jmp	 SHORT $LN70@watchdog_t
$LN69@watchdog_t:
  00915	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$1[rsp]
  0091a	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN70@watchdog_t:
$LN68@watchdog_t:
  00925	33 c0		 xor	 eax, eax
  00927	85 c0		 test	 eax, eax
  00929	0f 85 9b fe ff
	ff		 jne	 $LN38@watchdog_t

; 668  : 
; 669  :                         /* Display instruction that appears to be hung */
; 670  :                         ip = regs->ip < regs->aip ? regs->inst : regs->ip;

  0092f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$1[rsp]
  00934	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$1[rsp]
  00939	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00940	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  00944	73 15		 jae	 SHORT $LN91@watchdog_t
  00946	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$1[rsp]
  0094b	48 05 f1 08 00
	00		 add	 rax, 2289		; 000008f1H
  00951	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv362[rsp], rax
  00959	eb 11		 jmp	 SHORT $LN92@watchdog_t
$LN91@watchdog_t:
  0095b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$1[rsp]
  00960	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00964	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv362[rsp], rax
$LN92@watchdog_t:
  0096c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv362[rsp]
  00974	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR ip$6[rsp], rax

; 671  :                         ARCH_DEP( display_inst )( regs, ip );

  0097c	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR ip$6[rsp]
  00984	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$1[rsp]
  00989	e8 00 00 00 00	 call	 s370_display_inst
$LN67@watchdog_t:

; 672  :                     }
; 673  :                 }

  0098e	e9 c7 fd ff ff	 jmp	 $LN33@watchdog_t
$LN34@watchdog_t:
$LN66@watchdog_t:
$LN41@watchdog_t:

; 674  :             }
; 675  : 
; 676  :             /* Give logger thread time to log messages */
; 677  :             SLEEP(1);

  00993	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR rc$4[rsp], 1
$LN42@watchdog_t:
  0099b	83 7c 24 70 00	 cmp	 DWORD PTR rc$4[rsp], 0
  009a0	74 1d		 je	 SHORT $LN43@watchdog_t
  009a2	8b 4c 24 70	 mov	 ecx, DWORD PTR rc$4[rsp]
  009a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sleep
  009ac	89 44 24 70	 mov	 DWORD PTR rc$4[rsp], eax
  009b0	83 7c 24 70 00	 cmp	 DWORD PTR rc$4[rsp], 0
  009b5	74 06		 je	 SHORT $LN71@watchdog_t
  009b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield
$LN71@watchdog_t:
  009bd	eb dc		 jmp	 SHORT $LN42@watchdog_t
$LN43@watchdog_t:
  009bf	33 c0		 xor	 eax, eax
  009c1	85 c0		 test	 eax, eax
  009c3	75 ce		 jne	 SHORT $LN41@watchdog_t
$LN46@watchdog_t:

; 678  : 
; 679  :             /* Create the crash dump for offline analysis */
; 680  :             CRASH();

  009c5	48 c7 84 24 f0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR p$7[rsp], 0
  009d1	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR p$7[rsp]
  009d9	c6 00 00	 mov	 BYTE PTR [rax], 0
  009dc	33 c0		 xor	 eax, eax
  009de	85 c0		 test	 eax, eax
  009e0	75 e3		 jne	 SHORT $LN46@watchdog_t
$LN62@watchdog_t:
$LN8@watchdog_t:

; 681  :         }
; 682  :     }
; 683  :     while (!sysblk.shutdown);

  009e2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  009e9	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  009ef	c1 e8 0b	 shr	 eax, 11
  009f2	83 e0 01	 and	 eax, 1
  009f5	85 c0		 test	 eax, eax
  009f7	0f 84 f0 f6 ff
	ff		 je	 $LN10@watchdog_t

; 684  : 
; 685  :     return NULL;

  009fd	33 c0		 xor	 eax, eax

; 686  : }

  009ff	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00a07	48 33 cc	 xor	 rcx, rsp
  00a0a	e8 00 00 00 00	 call	 __security_check_cookie
  00a0f	48 81 c4 18 03
	00 00		 add	 rsp, 792		; 00000318H
  00a16	c3		 ret	 0
watchdog_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\impl.c
_TEXT	SEGMENT
msg$1 = 96
wc$ = 144
arg$ = 240
WinMsgThread PROC

; 423  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H

; 424  :     WNDCLASS  wc    =  {0};

  0000d	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR wc$[rsp]
  00015	48 8b f8	 mov	 rdi, rax
  00018	33 c0		 xor	 eax, eax
  0001a	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  0001f	f3 aa		 rep stosb
$LN4@WinMsgThre:

; 425  : 
; 426  :     UNREFERENCED( arg );

  00021	33 c0		 xor	 eax, eax
  00023	85 c0		 test	 eax, eax
  00025	75 fa		 jne	 SHORT $LN4@WinMsgThre

; 427  : 
; 428  :     wc.lpfnWndProc    =  MainWndProc;

  00027	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:MainWndProc
  0002e	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR wc$[rsp+8], rax

; 429  :     wc.hInstance      =  GetModuleHandle(0);

  00036	33 c9		 xor	 ecx, ecx
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleA
  0003e	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR wc$[rsp+24], rax

; 430  :     wc.lpszClassName  =  "Hercules";

  00046	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169258
  0004d	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR wc$[rsp+64], rax

; 431  : 
; 432  :     RegisterClass( &wc );

  00055	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR wc$[rsp]
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegisterClassA

; 433  : 
; 434  :     g_hMsgWnd = CreateWindowEx( 0,

  00063	33 c9		 xor	 ecx, ecx
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleA
  0006b	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR [rsp+88], 0
  00074	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00079	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  00082	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  0008b	c7 44 24 38 00
	00 00 80	 mov	 DWORD PTR [rsp+56], -2147483648 ; ffffffff80000000H
  00093	c7 44 24 30 00
	00 00 80	 mov	 DWORD PTR [rsp+48], -2147483648 ; ffffffff80000000H
  0009b	c7 44 24 28 00
	00 00 80	 mov	 DWORD PTR [rsp+40], -2147483648 ; ffffffff80000000H
  000a3	c7 44 24 20 00
	00 00 80	 mov	 DWORD PTR [rsp+32], -2147483648 ; ffffffff80000000H
  000ab	41 b9 00 00 cf
	00		 mov	 r9d, 13565952		; 00cf0000H
  000b1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169259
  000b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169260
  000bf	33 c9		 xor	 ecx, ecx
  000c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateWindowExA
  000c7	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_hMsgWnd, rax

; 435  :         "Hercules", "Hercules",
; 436  :         WS_OVERLAPPEDWINDOW,
; 437  :         CW_USEDEFAULT, CW_USEDEFAULT,
; 438  :         CW_USEDEFAULT, CW_USEDEFAULT,
; 439  :         NULL, NULL,
; 440  :         GetModuleHandle(0), NULL );
; 441  : 
; 442  :     SetEvent( g_hWndEvt );      // (indicate create window completed)

  000ce	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR g_hWndEvt
  000d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetEvent

; 443  : 
; 444  :     if (g_hMsgWnd)  // (pump messages if window successfully created)

  000db	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR g_hMsgWnd, 0
  000e3	74 2f		 je	 SHORT $LN7@WinMsgThre
$LN5@WinMsgThre:

; 445  :     {
; 446  :         MSG msg;
; 447  :         while (GetMessage( &msg, NULL , 0 , 0 ))

  000e5	45 33 c9	 xor	 r9d, r9d
  000e8	45 33 c0	 xor	 r8d, r8d
  000eb	33 d2		 xor	 edx, edx
  000ed	48 8d 4c 24 60	 lea	 rcx, QWORD PTR msg$1[rsp]
  000f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetMessageA
  000f8	85 c0		 test	 eax, eax
  000fa	74 18		 je	 SHORT $LN6@WinMsgThre

; 448  :         {
; 449  :             TranslateMessage ( &msg );

  000fc	48 8d 4c 24 60	 lea	 rcx, QWORD PTR msg$1[rsp]
  00101	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_TranslateMessage

; 450  :             DispatchMessage  ( &msg );

  00107	48 8d 4c 24 60	 lea	 rcx, QWORD PTR msg$1[rsp]
  0010c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DispatchMessageA

; 451  :         }

  00112	eb d1		 jmp	 SHORT $LN5@WinMsgThre
$LN6@WinMsgThre:
$LN7@WinMsgThre:

; 452  :     }
; 453  :     return NULL;

  00114	33 c0		 xor	 eax, eax

; 454  : }

  00116	48 81 c4 e0 00
	00 00		 add	 rsp, 224		; 000000e0H
  0011d	5f		 pop	 rdi
  0011e	c3		 ret	 0
WinMsgThread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\impl.c
_TEXT	SEGMENT
tv64 = 80
tv131 = 88
hWnd$ = 112
msg$ = 120
wParam$ = 128
lParam$ = 136
MainWndProc PROC

; 301  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 302  :     switch (msg)

  00017	8b 44 24 78	 mov	 eax, DWORD PTR msg$[rsp]
  0001b	89 44 24 50	 mov	 DWORD PTR tv64[rsp], eax
  0001f	83 7c 24 50 11	 cmp	 DWORD PTR tv64[rsp], 17
  00024	74 1a		 je	 SHORT $LN6@MainWndPro
  00026	83 7c 24 50 16	 cmp	 DWORD PTR tv64[rsp], 22
  0002b	74 7c		 je	 SHORT $LN7@MainWndPro
  0002d	81 7c 24 50 18
	02 00 00	 cmp	 DWORD PTR tv64[rsp], 536 ; 00000218H
  00035	0f 84 4a 01 00
	00		 je	 $LN9@MainWndPro
  0003b	e9 a6 01 00 00	 jmp	 $LN14@MainWndPro
$LN6@MainWndPro:

; 303  :     {
; 304  :     ///////////////////////////////////////////////////////////////
; 305  :     //
; 306  :     //                    PROGRAMMING NOTE
; 307  :     //
; 308  :     ///////////////////////////////////////////////////////////////
; 309  :     //
; 310  :     //  "If an application returns FALSE in response to
; 311  :     //   WM_QUERYENDSESSION, it still appears in the shutdown
; 312  :     //   UI. Note that the system does not allow console
; 313  :     //   applications or applications without a visible window
; 314  :     //   to cancel shutdown. These applications are automatically
; 315  :     //   terminated if they do not respond to WM_QUERYENDSESSION
; 316  :     //   or WM_ENDSESSION within 5 seconds or if they return FALSE
; 317  :     //   in response to WM_QUERYENDSESSION."
; 318  :     //
; 319  :     ///////////////////////////////////////////////////////////////
; 320  :     //
; 321  :     //  What this all boils down to is we can NEVER prevent the
; 322  :     //  user from logging off or shutting down since not only are
; 323  :     //  we a console application but our window is created invisible
; 324  :     //  as well. Thus we only have a maximum of 5 seconds to return
; 325  :     //  TRUE from WM_QUERYENDSESSION or return 0 from WM_ENDSESSION,
; 326  :     //  and since a normal shutdown may likely take longer than 5
; 327  :     //  seconds and our goal is to try hard to shutdown Hercules as
; 328  :     //  gracfully as possible, we are left with little choice but to
; 329  :     //  perform an immediate emergency shutdown once we receive the
; 330  :     //  WM_ENDSESSION message with a WPARAM value of TRUE.
; 331  :     //
; 332  :     ///////////////////////////////////////////////////////////////
; 333  : 
; 334  :         case WM_QUERYENDSESSION:
; 335  : 
; 336  :             // "%s received: %s"
; 337  :             WRMSG( HHC01403, "I", "WM_QUERYENDSESSION", "allow" );

  00040	b9 01 00 00 00	 mov	 ecx, 1
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169208
  00052	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00057	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169209
  0005e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169210
  0006a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169211
  00076	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0007b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00080	41 b9 03 00 00
	00		 mov	 r9d, 3
  00086	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169212
  0008d	ba 51 01 00 00	 mov	 edx, 337		; 00000151H
  00092	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169213
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 338  :             return TRUE;    // Vote "YES"... (we have no choice!)

  0009f	b8 01 00 00 00	 mov	 eax, 1
  000a4	e9 5c 01 00 00	 jmp	 $LN1@MainWndPro
$LN7@MainWndPro:

; 339  : 
; 340  :         case WM_ENDSESSION:
; 341  : 
; 342  :             if (!wParam)    // FALSE? (session not really ending?)

  000a9	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR wParam$[rsp], 0
  000b2	75 66		 jne	 SHORT $LN8@MainWndPro

; 343  :             {
; 344  :                 // Some other application (or the user themselves)
; 345  :                 // has aborted the logoff or system shutdown...
; 346  : 
; 347  :                 // "%s received: %s"
; 348  :                 WRMSG( HHC01403, "I", "WM_ENDSESSION", "aborted" );

  000b4	b9 01 00 00 00	 mov	 ecx, 1
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169216
  000c6	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169217
  000d2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169218
  000de	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169219
  000ea	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ef	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f4	41 b9 03 00 00
	00		 mov	 r9d, 3
  000fa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169220
  00101	ba 5c 01 00 00	 mov	 edx, 348		; 0000015cH
  00106	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169221
  0010d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 349  :                 return 0; // (message processed)

  00113	33 c0		 xor	 eax, eax
  00115	e9 eb 00 00 00	 jmp	 $LN1@MainWndPro
$LN8@MainWndPro:

; 350  :             }
; 351  : 
; 352  :             // User is logging off or the system is being shutdown.
; 353  :             // We have a maximum of 5 seconds to shutdown Hercules.
; 354  : 
; 355  :             // "%s received: %s"
; 356  :             WRMSG( HHC01403, "I", "WM_ENDSESSION", "initiating emergency shutdown" );

  0011a	b9 01 00 00 00	 mov	 ecx, 1
  0011f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169222
  0012c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00131	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169223
  00138	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0013d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169224
  00144	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00149	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169225
  00150	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00155	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0015a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00160	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169226
  00167	ba 64 01 00 00	 mov	 edx, 356		; 00000164H
  0016c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169227
  00173	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 357  :             do_emergency_shutdown();

  00179	e8 00 00 00 00	 call	 do_emergency_shutdown

; 358  :             return 0; // (message handled)

  0017e	33 c0		 xor	 eax, eax
  00180	e9 80 00 00 00	 jmp	 $LN1@MainWndPro
$LN9@MainWndPro:

; 359  : 
; 360  :         case WM_POWERBROADCAST:
; 361  : 
; 362  :             // Notifies applications that a power-management event
; 363  :             // has occurred.
; 364  : 
; 365  :             switch (wParam)

  00185	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR wParam$[rsp]
  0018d	48 89 44 24 58	 mov	 QWORD PTR tv131[rsp], rax
  00192	48 83 7c 24 58
	04		 cmp	 QWORD PTR tv131[rsp], 4
  00198	74 12		 je	 SHORT $LN10@MainWndPro
  0019a	48 83 7c 24 58
	07		 cmp	 QWORD PTR tv131[rsp], 7
  001a0	74 28		 je	 SHORT $LN11@MainWndPro
  001a2	48 83 7c 24 58
	12		 cmp	 QWORD PTR tv131[rsp], 18
  001a8	74 20		 je	 SHORT $LN12@MainWndPro
  001aa	eb 3a		 jmp	 SHORT $LN13@MainWndPro
$LN10@MainWndPro:

; 366  :             {
; 367  :                 case PBT_APMSUSPEND:
; 368  : 
; 369  :                     // Notifies applications that the computer
; 370  :                     // is about to enter a suspended state.
; 371  : 
; 372  :                     sysblk.sys_suspended = true;

  001ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001b3	c6 80 e4 00 00
	00 01		 mov	 BYTE PTR [rax+228], 1

; 373  :                     sysblk.sys_resumed   = false;

  001ba	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001c1	c6 80 e5 00 00
	00 00		 mov	 BYTE PTR [rax+229], 0

; 374  :                     break;

  001c8	eb 1c		 jmp	 SHORT $LN4@MainWndPro
$LN11@MainWndPro:
$LN12@MainWndPro:

; 375  : 
; 376  :                 case PBT_APMRESUMESUSPEND:
; 377  : 
; 378  :                     // Notifies applications that the system has resumed
; 379  :                     // operation after being suspended.
; 380  : 
; 381  :                     /*
; 382  :                        The below special "FALLTHRU" comment lets GCC know that we are
; 383  :                        purposely falling through to the next switch case and is needed
; 384  :                        in order to suppress the warning that GCC would otherwise issue.
; 385  :                     */
; 386  :                     /* FALLTHRU */
; 387  : 
; 388  :                 case PBT_APMRESUMEAUTOMATIC:
; 389  : 
; 390  :                     // Notifies applications that the computer has woken up
; 391  :                     // automatically to handle an event.
; 392  : 
; 393  :                     sysblk.sys_suspended = false;

  001ca	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001d1	c6 80 e4 00 00
	00 00		 mov	 BYTE PTR [rax+228], 0

; 394  :                     sysblk.sys_resumed   = true;

  001d8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001df	c6 80 e5 00 00
	00 01		 mov	 BYTE PTR [rax+229], 1
$LN13@MainWndPro:
$LN4@MainWndPro:
$LN14@MainWndPro:

; 395  :                     break;
; 396  : 
; 397  :                 default:
; 398  : 
; 399  :                     break;  /* (do nothing) */
; 400  :             }
; 401  : 
; 402  :             /*
; 403  :                The below special "FALLTHRU" comment lets GCC know that we are
; 404  :                purposely falling through to the next switch case and is needed
; 405  :                in order to suppress the warning that GCC would otherwise issue.
; 406  :             */
; 407  :             /* FALLTHRU */
; 408  : 
; 409  :         default:
; 410  : 
; 411  :             return DefWindowProc( hWnd, msg, wParam, lParam );

  001e6	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR lParam$[rsp]
  001ee	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR wParam$[rsp]
  001f6	8b 54 24 78	 mov	 edx, DWORD PTR msg$[rsp]
  001fa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR hWnd$[rsp]
  001ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DefWindowProcA
$LN1@MainWndPro:

; 412  :     }
; 413  : 
; 414  :     UNREACHABLE_CODE( return 0 );
; 415  : }

  00205	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00209	c3		 ret	 0
MainWndProc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\impl.c
_TEXT	SEGMENT
i$1 = 64
tv64 = 68
mask$2 = 72
signo$ = 96
console_ctrl_handler PROC

; 212  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 213  :     switch ( signo )

  00008	8b 44 24 60	 mov	 eax, DWORD PTR signo$[rsp]
  0000c	89 44 24 44	 mov	 DWORD PTR tv64[rsp], eax
  00010	83 7c 24 44 00	 cmp	 DWORD PTR tv64[rsp], 0
  00015	0f 84 c4 01 00
	00		 je	 $LN15@console_ct
  0001b	83 7c 24 44 01	 cmp	 DWORD PTR tv64[rsp], 1
  00020	74 10		 je	 SHORT $LN10@console_ct
  00022	83 7c 24 44 02	 cmp	 DWORD PTR tv64[rsp], 2
  00027	0f 84 28 02 00
	00		 je	 $LN17@console_ct
  0002d	e9 99 02 00 00	 jmp	 $LN19@console_ct
$LN10@console_ct:

; 214  :     {
; 215  :     ///////////////////////////////////////////////////////////////
; 216  :     //
; 217  :     //                    PROGRAMMING NOTE
; 218  :     //
; 219  :     ///////////////////////////////////////////////////////////////
; 220  :     //
; 221  :     // "SetConsoleCtrlHandler function HandlerRoutine Callback
; 222  :     //  Function:"
; 223  :     //
; 224  :     //   "Return Value:"
; 225  :     //
; 226  :     //     "If the function handles the control signal, it
; 227  :     //      should return TRUE."
; 228  :     //
; 229  :     //   "CTRL_LOGOFF_EVENT:"
; 230  :     //
; 231  :     //     "Note that this signal is received only by services.
; 232  :     //      Interactive applications are terminated at logoff,
; 233  :     //      so they are not present when the system sends this
; 234  :     //      signal."
; 235  :     //
; 236  :     //   "CTRL_SHUTDOWN_EVENT:"
; 237  :     //
; 238  :     //     "Interactive applications are not present by the time
; 239  :     //      the system sends this signal, therefore it can be
; 240  :     //      received only be services in this situation."
; 241  :     //
; 242  :     //   "CTRL_CLOSE_EVENT:"
; 243  :     //
; 244  :     //      "... if the process does not respond within a certain
; 245  :     //       time-out period (5 seconds for CTRL_CLOSE_EVENT..."
; 246  :     //
; 247  :     ///////////////////////////////////////////////////////////////
; 248  :     //
; 249  :     //  What this all boils down to is we'll never receive the
; 250  :     //  logoff and shutdown signals (via this callback), and
; 251  :     //  we only have a maximum of 5 seconds to return TRUE from
; 252  :     //  the CTRL_CLOSE_EVENT signal. Thus, as normal shutdowns
; 253  :     //  may likely take longer than 5 seconds and our goal is
; 254  :     //  to try hard to shutdown Hercules as gracfully as we can,
; 255  :     //  we are left with little choice but to always perform
; 256  :     //  an immediate/emergency shutdown for CTRL_CLOSE_EVENT.
; 257  :     //
; 258  :     ///////////////////////////////////////////////////////////////
; 259  : 
; 260  :         case CTRL_BREAK_EVENT:
; 261  : 
; 262  :             // "CTRL_BREAK_EVENT received: %s"
; 263  :             WRMSG( HHC01400, "I", "pressing interrupt key" );

  00032	b9 01 00 00 00	 mov	 ecx, 1
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169166
  00044	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169167
  00050	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169168
  0005c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00061	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00066	41 b9 03 00 00
	00		 mov	 r9d, 3
  0006c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169169
  00073	ba 07 01 00 00	 mov	 edx, 263		; 00000107H
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169170
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 264  : 
; 265  :             OBTAIN_INTLOCK( NULL );

  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169171
  0008c	33 c9		 xor	 ecx, ecx
  0008e	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock
$LN6@console_ct:

; 266  :             ON_IC_INTKEY;

  00093	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0009a	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  000a0	83 e0 40	 and	 eax, 64			; 00000040H
  000a3	85 c0		 test	 eax, eax
  000a5	0f 85 f8 00 00
	00		 jne	 $LN11@console_ct
  000ab	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000b2	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  000b8	83 c8 40	 or	 eax, 64			; 00000040H
  000bb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000c2	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  000c8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000cf	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  000d6	48 89 44 24 48	 mov	 QWORD PTR mask$2[rsp], rax
  000db	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  000e3	eb 0a		 jmp	 SHORT $LN9@console_ct
$LN7@console_ct:
  000e5	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  000e9	ff c0		 inc	 eax
  000eb	89 44 24 40	 mov	 DWORD PTR i$1[rsp], eax
$LN9@console_ct:
  000ef	48 83 7c 24 48
	00		 cmp	 QWORD PTR mask$2[rsp], 0
  000f5	0f 84 a8 00 00
	00		 je	 $LN8@console_ct
  000fb	48 8b 44 24 48	 mov	 rax, QWORD PTR mask$2[rsp]
  00100	48 83 e0 01	 and	 rax, 1
  00104	48 85 c0	 test	 rax, rax
  00107	0f 84 84 00 00
	00		 je	 $LN12@console_ct
  0010d	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$1[rsp]
  00112	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00119	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00121	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00124	83 e0 40	 and	 eax, 64			; 00000040H
  00127	85 c0		 test	 eax, eax
  00129	74 35		 je	 SHORT $LN13@console_ct
  0012b	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$1[rsp]
  00130	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00137	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0013f	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00142	0d 40 00 00 80	 or	 eax, -2147483584	; 80000040H
  00147	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$1[rsp]
  0014c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00153	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  0015b	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  0015e	eb 31		 jmp	 SHORT $LN14@console_ct
$LN13@console_ct:
  00160	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$1[rsp]
  00165	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0016c	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00174	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00177	83 c8 40	 or	 eax, 64			; 00000040H
  0017a	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$1[rsp]
  0017f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00186	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  0018e	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN14@console_ct:
$LN12@console_ct:
  00191	48 8b 44 24 48	 mov	 rax, QWORD PTR mask$2[rsp]
  00196	48 d1 e8	 shr	 rax, 1
  00199	48 89 44 24 48	 mov	 QWORD PTR mask$2[rsp], rax
  0019e	e9 42 ff ff ff	 jmp	 $LN7@console_ct
$LN8@console_ct:
$LN11@console_ct:
  001a3	33 c0		 xor	 eax, eax
  001a5	85 c0		 test	 eax, eax
  001a7	0f 85 e6 fe ff
	ff		 jne	 $LN6@console_ct

; 267  :             WAKEUP_CPUS_MASK( sysblk.waiting_mask );

  001ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169176
  001b4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001bb	48 8b 88 b8 12
	00 00		 mov	 rcx, QWORD PTR [rax+4792]
  001c2	e8 00 00 00 00	 call	 wakeup_cpus_mask

; 268  :             RELEASE_INTLOCK( NULL );

  001c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169177
  001ce	33 c9		 xor	 ecx, ecx
  001d0	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 269  : 
; 270  :             return TRUE;

  001d5	b8 01 00 00 00	 mov	 eax, 1
  001da	e9 ee 00 00 00	 jmp	 $LN1@console_ct
$LN15@console_ct:

; 271  : 
; 272  :         case CTRL_C_EVENT:
; 273  : 
; 274  :             if (!sysblk.shutimmed)

  001df	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001e6	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  001ec	c1 e8 0d	 shr	 eax, 13
  001ef	83 e0 01	 and	 eax, 1
  001f2	85 c0		 test	 eax, eax
  001f4	75 53		 jne	 SHORT $LN16@console_ct

; 275  :                 // "CTRL_C_EVENT received: %s"
; 276  :                 WRMSG( HHC01401, "I", "initiating emergency shutdown" );

  001f6	b9 01 00 00 00	 mov	 ecx, 1
  001fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00201	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169180
  00208	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0020d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169181
  00214	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00219	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169182
  00220	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00225	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0022a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00230	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169183
  00237	ba 14 01 00 00	 mov	 edx, 276		; 00000114H
  0023c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169184
  00243	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN16@console_ct:

; 277  :             do_emergency_shutdown();

  00249	e8 00 00 00 00	 call	 do_emergency_shutdown

; 278  :             return TRUE;

  0024e	b8 01 00 00 00	 mov	 eax, 1
  00253	eb 78		 jmp	 SHORT $LN1@console_ct
$LN17@console_ct:

; 279  : 
; 280  : 
; 281  :         case CTRL_CLOSE_EVENT:
; 282  : 
; 283  :             if (!sysblk.shutimmed)

  00255	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0025c	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00262	c1 e8 0d	 shr	 eax, 13
  00265	83 e0 01	 and	 eax, 1
  00268	85 c0		 test	 eax, eax
  0026a	75 53		 jne	 SHORT $LN18@console_ct

; 284  :                 // "CTRL_CLOSE_EVENT received: %s"
; 285  :                 WRMSG( HHC01402, "I", "initiating emergency shutdown" );

  0026c	b9 01 00 00 00	 mov	 ecx, 1
  00271	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00277	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169187
  0027e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00283	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169188
  0028a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0028f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169189
  00296	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0029b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002a0	41 b9 03 00 00
	00		 mov	 r9d, 3
  002a6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169190
  002ad	ba 1d 01 00 00	 mov	 edx, 285		; 0000011dH
  002b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169191
  002b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN18@console_ct:

; 286  :             do_emergency_shutdown();

  002bf	e8 00 00 00 00	 call	 do_emergency_shutdown

; 287  :             return TRUE;

  002c4	b8 01 00 00 00	 mov	 eax, 1
  002c9	eb 02		 jmp	 SHORT $LN1@console_ct
$LN19@console_ct:

; 288  : 
; 289  :         default:
; 290  : 
; 291  :             return FALSE;  // (not handled; call next signal handler)

  002cb	33 c0		 xor	 eax, eax
$LN1@console_ct:

; 292  :     }
; 293  : 
; 294  :     UNREACHABLE_CODE( return FALSE );
; 295  : }

  002cd	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002d1	c3		 ret	 0
console_ctrl_handler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\impl.c
_TEXT	SEGMENT
do_emergency_shutdown PROC

; 193  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 194  :     sysblk.shutdown = TRUE;

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00011	0f ba e8 0b	 bts	 eax, 11
  00015	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0001c	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 195  : 
; 196  :     if (!sysblk.shutimmed)

  00022	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00029	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0002f	c1 e8 0d	 shr	 eax, 13
  00032	83 e0 01	 and	 eax, 1
  00035	85 c0		 test	 eax, eax
  00037	75 25		 jne	 SHORT $LN4@do_emergen

; 197  :     {
; 198  :         sysblk.shutimmed = TRUE;

  00039	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00040	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00046	0f ba e8 0d	 bts	 eax, 13
  0004a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00051	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 199  :         do_shutdown();

  00057	e8 00 00 00 00	 call	 do_shutdown

; 200  :     }

  0005c	eb 24		 jmp	 SHORT $LN5@do_emergen
$LN4@do_emergen:
$LN2@do_emergen:

; 201  :     else // (already in progress)
; 202  :     {
; 203  :         while (!sysblk.shutfini)

  0005e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00065	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0006b	c1 e8 0c	 shr	 eax, 12
  0006e	83 e0 01	 and	 eax, 1
  00071	85 c0		 test	 eax, eax
  00073	75 0d		 jne	 SHORT $LN3@do_emergen

; 204  :             usleep(100000);

  00075	b9 a0 86 01 00	 mov	 ecx, 100000		; 000186a0H
  0007a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
  00080	eb dc		 jmp	 SHORT $LN2@do_emergen
$LN3@do_emergen:
$LN5@do_emergen:

; 205  :     }
; 206  : }

  00082	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00086	c3		 ret	 0
do_emergency_shutdown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\impl.c
_TEXT	SEGMENT
signo$ = 48
sigterm_handler PROC

; 175  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@sigterm_ha:

; 176  :     UNREFERENCED( signo );

  00008	33 c0		 xor	 eax, eax
  0000a	85 c0		 test	 eax, eax
  0000c	75 fa		 jne	 SHORT $LN4@sigterm_ha

; 177  : 
; 178  :     signal( SIGTERM, sigterm_handler );

  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:sigterm_handler
  00015	b9 0f 00 00 00	 mov	 ecx, 15
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_signal

; 179  : 
; 180  :     /* Ignore signal unless presented on main program (impl) thread */
; 181  :     if (!equal_threads( thread_id(), sysblk.impltid ))

  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00026	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0002d	8b 91 d8 00 00
	00		 mov	 edx, DWORD PTR [rcx+216]
  00033	8b c8		 mov	 ecx, eax
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_equal_threads
  0003b	85 c0		 test	 eax, eax
  0003d	75 02		 jne	 SHORT $LN5@sigterm_ha

; 182  :         return;

  0003f	eb 05		 jmp	 SHORT $LN1@sigterm_ha
$LN5@sigterm_ha:

; 183  : 
; 184  :     /* Initiate system shutdown */
; 185  :     do_shutdown();

  00041	e8 00 00 00 00	 call	 do_shutdown
$LN1@sigterm_ha:

; 186  : }

  00046	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004a	c3		 ret	 0
sigterm_handler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\impl.c
_TEXT	SEGMENT
i$1 = 32
mask$2 = 40
signo$ = 64
sigint_handler PROC

; 137  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@sigint_han:

; 138  :     UNREFERENCED( signo );

  00008	33 c0		 xor	 eax, eax
  0000a	85 c0		 test	 eax, eax
  0000c	75 fa		 jne	 SHORT $LN4@sigint_han

; 139  : 
; 140  :     signal( SIGINT, sigint_handler );

  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:sigint_handler
  00015	b9 02 00 00 00	 mov	 ecx, 2
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_signal

; 141  : 
; 142  :     /* Ignore signal unless presented on console thread */
; 143  :     if (!equal_threads( thread_id(), sysblk.cnsltid ))

  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00026	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0002d	8b 91 a8 10 00
	00		 mov	 edx, DWORD PTR [rcx+4264]
  00033	8b c8		 mov	 ecx, eax
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_equal_threads
  0003b	85 c0		 test	 eax, eax
  0003d	75 05		 jne	 SHORT $LN11@sigint_han

; 144  :         return;

  0003f	e9 ec 00 00 00	 jmp	 $LN1@sigint_han
$LN11@sigint_han:

; 145  : 
; 146  :     /* Exit if previous SIGINT request was not actioned */
; 147  :     if (sysblk.sigintreq)

  00044	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0004b	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00051	c1 e8 07	 shr	 eax, 7
  00054	83 e0 01	 and	 eax, 1
  00057	85 c0		 test	 eax, eax
  00059	74 11		 je	 SHORT $LN12@sigint_han

; 148  :     {
; 149  :         /* Release the configuration */
; 150  :         release_config( NULL );

  0005b	33 c9		 xor	 ecx, ecx
  0005d	e8 00 00 00 00	 call	 release_config

; 151  :         delayed_exit(1);

  00062	b9 01 00 00 00	 mov	 ecx, 1
  00067	e8 00 00 00 00	 call	 delayed_exit
$LN12@sigint_han:

; 152  :     }
; 153  : 
; 154  :     /* Set SIGINT request pending flag */
; 155  :     sysblk.sigintreq = 1;

  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00073	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00079	0f ba e8 07	 bts	 eax, 7
  0007d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00084	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 156  : 
; 157  :     /* Activate instruction stepping */
; 158  :     sysblk.instbreak = 1;

  0008a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00091	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00097	0f ba e8 0a	 bts	 eax, 10
  0009b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a2	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
$LN7@sigint_han:

; 159  :     SET_IC_TRACE;

  000a8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000af	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  000b6	48 89 44 24 28	 mov	 QWORD PTR mask$2[rsp], rax
  000bb	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  000c3	eb 0a		 jmp	 SHORT $LN10@sigint_han
$LN8@sigint_han:
  000c5	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  000c9	ff c0		 inc	 eax
  000cb	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN10@sigint_han:
  000cf	48 83 7c 24 28
	00		 cmp	 QWORD PTR mask$2[rsp], 0
  000d5	74 4f		 je	 SHORT $LN9@sigint_han
  000d7	48 8b 44 24 28	 mov	 rax, QWORD PTR mask$2[rsp]
  000dc	48 83 e0 01	 and	 rax, 1
  000e0	48 85 c0	 test	 rax, rax
  000e3	74 32		 je	 SHORT $LN13@sigint_han
  000e5	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  000ea	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000f1	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000f9	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000fc	0f ba e8 1f	 bts	 eax, 31
  00100	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00105	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0010c	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00114	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN13@sigint_han:
  00117	48 8b 44 24 28	 mov	 rax, QWORD PTR mask$2[rsp]
  0011c	48 d1 e8	 shr	 rax, 1
  0011f	48 89 44 24 28	 mov	 QWORD PTR mask$2[rsp], rax
  00124	eb 9f		 jmp	 SHORT $LN8@sigint_han
$LN9@sigint_han:
  00126	33 c0		 xor	 eax, eax
  00128	85 c0		 test	 eax, eax
  0012a	0f 85 78 ff ff
	ff		 jne	 $LN7@sigint_han
$LN1@sigint_han:

; 160  : }

  00130	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00134	c3		 ret	 0
sigint_handler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\impl.c
_TEXT	SEGMENT
exit_code$ = 48
delayed_exit PROC

; 106  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@delayed_ex:

; 107  :     UNREFERENCED(exit_code);

  00008	33 c0		 xor	 eax, eax
  0000a	85 c0		 test	 eax, eax
  0000c	75 fa		 jne	 SHORT $LN4@delayed_ex

; 108  : 
; 109  :     /* Delay exiting is to give the system
; 110  :      * time to display the error message. */
; 111  : #if defined( _MSVC_ )
; 112  :     SetConsoleCtrlHandler( NULL, FALSE); // disable Ctrl-C intercept

  0000e	33 d2		 xor	 edx, edx
  00010	33 c9		 xor	 ecx, ecx
  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleCtrlHandler

; 113  : #endif
; 114  :     sysblk.shutimmed = TRUE;

  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001f	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00025	0f ba e8 0d	 bts	 eax, 13
  00029	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00030	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 115  : 
; 116  :     fflush(stderr);

  00036	b9 02 00 00 00	 mov	 ecx, 2
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00041	48 8b c8	 mov	 rcx, rax
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 117  :     fflush(stdout);

  0004a	b9 01 00 00 00	 mov	 ecx, 1
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00055	48 8b c8	 mov	 rcx, rax
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 118  :     usleep(100000);

  0005e	b9 a0 86 01 00	 mov	 ecx, 100000		; 000186a0H
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 119  :     do_shutdown();

  00069	e8 00 00 00 00	 call	 do_shutdown

; 120  :     fflush(stderr);

  0006e	b9 02 00 00 00	 mov	 ecx, 2
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00079	48 8b c8	 mov	 rcx, rax
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 121  :     fflush(stdout);

  00082	b9 01 00 00 00	 mov	 ecx, 1
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0008d	48 8b c8	 mov	 rcx, rax
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 122  :     usleep(100000);

  00096	b9 a0 86 01 00	 mov	 ecx, 100000		; 000186a0H
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 123  :     return;
; 124  : }

  000a1	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a5	c3		 ret	 0
delayed_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\impl.c
_TEXT	SEGMENT
i$1 = 80
arg_error$ = 84
using_default$2 = 88
i$3 = 92
j$4 = 96
tv146 = 100
c$ = 104
sym$5 = 112
len$6 = 120
max_factor$7 = 128
rv$8 = 136
value$9 = 144
dllname$10 = 152
scrfactor$11 = 160
envname$12 = 168
strtok_str$13 = 176
strtok_str$14 = 184
tv422 = 192
tv501 = 200
tv544 = 208
tv506 = 216
tv545 = 224
tv511 = 232
st$15 = 240
buf$16 = 296
__$ArrayPad$ = 312
argc$ = 336
argv$ = 344
process_args PROC

; 1614 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1615 :     int  arg_error = 0;                 /* 1=Invalid arguments       */

  00022	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR arg_error$[rsp], 0

; 1616 :     int  c = 0;                         /* Next option flag          */

  0002a	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR c$[rsp], 0

; 1617 : 
; 1618 :     // Save a copy of the command line before getopt mangles argv[]
; 1619 : 
; 1620 :     if (argc > 0)

  00032	83 bc 24 50 01
	00 00 00	 cmp	 DWORD PTR argc$[rsp], 0
  0003a	0f 8e f9 00 00
	00		 jle	 $LN24@process_ar

; 1621 :     {
; 1622 :         int i;
; 1623 :         size_t len;
; 1624 : 
; 1625 :         for (len=0, i=0; i < argc; i++ )

  00040	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR len$6[rsp], 0
  00049	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR i$3[rsp], 0
  00051	eb 0a		 jmp	 SHORT $LN4@process_ar
$LN2@process_ar:
  00053	8b 44 24 5c	 mov	 eax, DWORD PTR i$3[rsp]
  00057	ff c0		 inc	 eax
  00059	89 44 24 5c	 mov	 DWORD PTR i$3[rsp], eax
$LN4@process_ar:
  0005d	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00064	39 44 24 5c	 cmp	 DWORD PTR i$3[rsp], eax
  00068	7d 27		 jge	 SHORT $LN3@process_ar

; 1626 :             len += strlen( argv[i] ) + 1;

  0006a	48 63 44 24 5c	 movsxd	 rax, DWORD PTR i$3[rsp]
  0006f	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00077	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0007b	e8 00 00 00 00	 call	 strlen
  00080	48 8b 4c 24 78	 mov	 rcx, QWORD PTR len$6[rsp]
  00085	48 8d 44 01 01	 lea	 rax, QWORD PTR [rcx+rax+1]
  0008a	48 89 44 24 78	 mov	 QWORD PTR len$6[rsp], rax
  0008f	eb c2		 jmp	 SHORT $LN2@process_ar
$LN3@process_ar:

; 1627 : 
; 1628 :         sysblk.hercules_cmdline = malloc( len );

  00091	48 8b 4c 24 78	 mov	 rcx, QWORD PTR len$6[rsp]
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0009c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a3	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax

; 1629 :         strlcpy( sysblk.hercules_cmdline, argv[0], len );

  000a7	b8 08 00 00 00	 mov	 eax, 8
  000ac	48 6b c0 00	 imul	 rax, rax, 0
  000b0	4c 8b 44 24 78	 mov	 r8, QWORD PTR len$6[rsp]
  000b5	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000bd	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  000c1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000c8	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1630 : 
; 1631 :         for (i=1; i < argc; i++)

  000d2	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR i$3[rsp], 1
  000da	eb 0a		 jmp	 SHORT $LN7@process_ar
$LN5@process_ar:
  000dc	8b 44 24 5c	 mov	 eax, DWORD PTR i$3[rsp]
  000e0	ff c0		 inc	 eax
  000e2	89 44 24 5c	 mov	 DWORD PTR i$3[rsp], eax
$LN7@process_ar:
  000e6	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  000ed	39 44 24 5c	 cmp	 DWORD PTR i$3[rsp], eax
  000f1	7d 46		 jge	 SHORT $LN6@process_ar

; 1632 :         {
; 1633 :             strlcat( sysblk.hercules_cmdline,  " ",    len );

  000f3	4c 8b 44 24 78	 mov	 r8, QWORD PTR len$6[rsp]
  000f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169916
  000ff	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00106	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  0010a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 1634 :             strlcat( sysblk.hercules_cmdline, argv[i], len );

  00110	48 63 44 24 5c	 movsxd	 rax, DWORD PTR i$3[rsp]
  00115	4c 8b 44 24 78	 mov	 r8, QWORD PTR len$6[rsp]
  0011a	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00122	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00126	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0012d	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00131	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 1635 :         }

  00137	eb a3		 jmp	 SHORT $LN5@process_ar
$LN6@process_ar:
$LN24@process_ar:

; 1636 :     }
; 1637 : 
; 1638 :     opterr = 0; /* We'll print our own error messages thankyouverymuch */

  00139	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_opterr
  00140	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1639 : 
; 1640 :     if (2 <= argc && !strcmp(argv[1], "-?"))

  00146	83 bc 24 50 01
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  0014e	7c 34		 jl	 SHORT $LN25@process_ar
  00150	b8 08 00 00 00	 mov	 eax, 8
  00155	48 6b c0 01	 imul	 rax, rax, 1
  00159	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169918
  00160	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00168	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0016c	e8 00 00 00 00	 call	 strcmp
  00171	85 c0		 test	 eax, eax
  00173	75 0f		 jne	 SHORT $LN25@process_ar

; 1641 :     {
; 1642 :         arg_error++;

  00175	8b 44 24 54	 mov	 eax, DWORD PTR arg_error$[rsp]
  00179	ff c0		 inc	 eax
  0017b	89 44 24 54	 mov	 DWORD PTR arg_error$[rsp], eax

; 1643 :         goto error;

  0017f	e9 5e 08 00 00	 jmp	 $error$78
$LN25@process_ar:
$LN8@process_ar:

; 1644 :     }
; 1645 : 
; 1646 :     for (; EOF != c ;)

  00184	83 7c 24 68 ff	 cmp	 DWORD PTR c$[rsp], -1
  00189	0f 84 a8 07 00
	00		 je	 $LN9@process_ar

; 1647 :     {
; 1648 :         c =                       /* Work area for getopt */

  0018f	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00198	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:longopts
  0019f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:shortopts
  001a6	48 8b 94 24 58
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  001ae	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  001b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getopt_long
  001bb	89 44 24 68	 mov	 DWORD PTR c$[rsp], eax

; 1649 : 
; 1650 : #if defined( HAVE_GETOPT_LONG )
; 1651 :             getopt_long( argc, argv, shortopts, longopts, NULL );
; 1652 : #else
; 1653 :             getopt( argc, argv, shortopts );
; 1654 : #endif
; 1655 : 
; 1656 :         switch (c)

  001bf	8b 44 24 68	 mov	 eax, DWORD PTR c$[rsp]
  001c3	89 44 24 64	 mov	 DWORD PTR tv146[rsp], eax
  001c7	8b 44 24 64	 mov	 eax, DWORD PTR tv146[rsp]
  001cb	ff c0		 inc	 eax
  001cd	89 44 24 64	 mov	 DWORD PTR tv146[rsp], eax
  001d1	83 7c 24 64 77	 cmp	 DWORD PTR tv146[rsp], 119 ; 00000077H
  001d6	0f 87 9b 06 00
	00		 ja	 $LN63@process_ar
  001dc	48 63 44 24 64	 movsxd	 rax, DWORD PTR tv146[rsp]
  001e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  001e8	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN76@process_ar[rcx+rax]
  001f0	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN77@process_ar[rcx+rax*4]
  001f7	48 03 c1	 add	 rax, rcx
  001fa	ff e0		 jmp	 rax
$LN26@process_ar:

; 1657 :         {
; 1658 :             case EOF:
; 1659 : 
; 1660 :                 break;      /* (we're done) */

  001fc	e9 31 07 00 00	 jmp	 $LN11@process_ar
$LN27@process_ar:

; 1661 : 
; 1662 :             case 0:         /* getopt_long() set a variable; keep going */
; 1663 : 
; 1664 :                 break;

  00201	e9 2c 07 00 00	 jmp	 $LN11@process_ar
$LN28@process_ar:

; 1665 : 
; 1666 :             case 'h':       /* -h[=type] or --help[=type] */
; 1667 : 
; 1668 :                 if (optarg) /* help type specified? */

  00206	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  0020d	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00211	0f 84 95 01 00
	00		 je	 $LN29@process_ar

; 1669 :                 {
; 1670 :                     if (0
; 1671 :                         || strcasecmp( optarg, "short"  ) == 0

  00217	33 c0		 xor	 eax, eax
  00219	85 c0		 test	 eax, eax
  0021b	75 1b		 jne	 SHORT $LN32@process_ar
  0021d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169926
  00224	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  0022b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0022e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00234	85 c0		 test	 eax, eax
  00236	75 05		 jne	 SHORT $LN30@process_ar
$LN32@process_ar:

; 1672 :                     )
; 1673 :                     {
; 1674 :                         ;   // (do nothing)
; 1675 :                     }

  00238	e9 6f 01 00 00	 jmp	 $LN31@process_ar
$LN30@process_ar:

; 1676 :                     else if (0
; 1677 :                         || strcasecmp( optarg, "version" ) == 0

  0023d	33 c0		 xor	 eax, eax
  0023f	85 c0		 test	 eax, eax
  00241	75 1b		 jne	 SHORT $LN35@process_ar
  00243	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169930
  0024a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  00251	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00254	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0025a	85 c0		 test	 eax, eax
  0025c	75 1e		 jne	 SHORT $LN33@process_ar
$LN35@process_ar:

; 1678 :                     )
; 1679 :                     {
; 1680 :                         display_version( stdout, 0, NULL );

  0025e	b9 01 00 00 00	 mov	 ecx, 1
  00263	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00269	45 33 c0	 xor	 r8d, r8d
  0026c	33 d2		 xor	 edx, edx
  0026e	48 8b c8	 mov	 rcx, rax
  00271	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_display_version

; 1681 :                     }

  00277	e9 30 01 00 00	 jmp	 $LN34@process_ar
$LN33@process_ar:

; 1682 :                     else if (0
; 1683 :                         || strcasecmp( optarg, "build"   ) == 0

  0027c	33 c0		 xor	 eax, eax
  0027e	85 c0		 test	 eax, eax
  00280	75 1b		 jne	 SHORT $LN38@process_ar
  00282	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169934
  00289	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  00290	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00293	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00299	85 c0		 test	 eax, eax
  0029b	75 1b		 jne	 SHORT $LN36@process_ar
$LN38@process_ar:

; 1684 :                     )
; 1685 :                     {
; 1686 :                         display_build_options( stdout, 0 );

  0029d	b9 01 00 00 00	 mov	 ecx, 1
  002a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002a8	33 d2		 xor	 edx, edx
  002aa	48 8b c8	 mov	 rcx, rax
  002ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_display_build_options

; 1687 :                     }

  002b3	e9 f4 00 00 00	 jmp	 $LN37@process_ar
$LN36@process_ar:

; 1688 :                     else if (0
; 1689 :                         || strcasecmp( optarg, "all"  ) == 0
; 1690 :                         || strcasecmp( optarg, "long" ) == 0
; 1691 :                         || strcasecmp( optarg, "full" ) == 0

  002b8	33 c0		 xor	 eax, eax
  002ba	85 c0		 test	 eax, eax
  002bc	75 51		 jne	 SHORT $LN41@process_ar
  002be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169938
  002c5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  002cc	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  002cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  002d5	85 c0		 test	 eax, eax
  002d7	74 36		 je	 SHORT $LN41@process_ar
  002d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169939
  002e0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  002e7	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  002ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  002f0	85 c0		 test	 eax, eax
  002f2	74 1b		 je	 SHORT $LN41@process_ar
  002f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169940
  002fb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  00302	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00305	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0030b	85 c0		 test	 eax, eax
  0030d	75 47		 jne	 SHORT $LN39@process_ar
$LN41@process_ar:

; 1692 :                     )
; 1693 :                     {
; 1694 :                         display_version      ( stdout, 0, NULL );

  0030f	b9 01 00 00 00	 mov	 ecx, 1
  00314	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0031a	45 33 c0	 xor	 r8d, r8d
  0031d	33 d2		 xor	 edx, edx
  0031f	48 8b c8	 mov	 rcx, rax
  00322	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_display_version

; 1695 :                         display_build_options( stdout, 0 );

  00328	b9 01 00 00 00	 mov	 ecx, 1
  0032d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00333	33 d2		 xor	 edx, edx
  00335	48 8b c8	 mov	 rcx, rax
  00338	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_display_build_options

; 1696 :                         display_extpkg_vers  ( stdout, 0 );

  0033e	b9 01 00 00 00	 mov	 ecx, 1
  00343	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00349	33 d2		 xor	 edx, edx
  0034b	48 8b c8	 mov	 rcx, rax
  0034e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_display_extpkg_vers

; 1697 :                     }

  00354	eb 56		 jmp	 SHORT $LN40@process_ar
$LN39@process_ar:

; 1698 :                     else
; 1699 :                     {
; 1700 :                         // "Invalid help option argument: %s"
; 1701 :                         WRMSG( HHC00025, "E", optarg );

  00356	b9 01 00 00 00	 mov	 ecx, 1
  0035b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00361	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  00368	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0036b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00370	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169941
  00377	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0037c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169942
  00383	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00388	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0038d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00393	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169943
  0039a	ba a5 06 00 00	 mov	 edx, 1701		; 000006a5H
  0039f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169944
  003a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN40@process_ar:
$LN37@process_ar:
$LN34@process_ar:
$LN31@process_ar:
$LN29@process_ar:

; 1702 :                     }
; 1703 :                 }
; 1704 : 
; 1705 :                 arg_error++;  // (forced by help option)

  003ac	8b 44 24 54	 mov	 eax, DWORD PTR arg_error$[rsp]
  003b0	ff c0		 inc	 eax
  003b2	89 44 24 54	 mov	 DWORD PTR arg_error$[rsp], eax

; 1706 :                 break;

  003b6	e9 77 05 00 00	 jmp	 $LN11@process_ar
$LN42@process_ar:

; 1707 : 
; 1708 :             case 'f':
; 1709 : 
; 1710 :                 cfgorrc[ want_cfg ].filename = optarg;

  003bb	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  003c0	48 6b c0 00	 imul	 rax, rax, 0
  003c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cfgorrc
  003cb	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_optarg
  003d2	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  003d5	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 1711 :                 break;

  003d9	e9 54 05 00 00	 jmp	 $LN11@process_ar
$LN43@process_ar:

; 1712 : 
; 1713 :             case 'o':
; 1714 : 
; 1715 :                 log_sethrdcpy( optarg );

  003de	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  003e5	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  003e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_log_sethrdcpy

; 1716 :                 break;

  003ee	e9 3f 05 00 00	 jmp	 $LN11@process_ar
$LN44@process_ar:

; 1717 : 
; 1718 :             case 'r':
; 1719 : 
; 1720 :                 cfgorrc[ want_rc ].filename = optarg;

  003f3	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  003f8	48 6b c0 01	 imul	 rax, rax, 1
  003fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cfgorrc
  00403	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_optarg
  0040a	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0040d	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 1721 :                 break;

  00411	e9 1c 05 00 00	 jmp	 $LN11@process_ar
$LN45@process_ar:

; 1722 : 
; 1723 :             case 's':
; 1724 :             {
; 1725 :                 char* sym        = NULL;

  00416	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR sym$5[rsp], 0

; 1726 :                 char* value      = NULL;

  0041f	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR value$9[rsp], 0

; 1727 :                 char* strtok_str = NULL;

  0042b	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR strtok_str$13[rsp], 0

; 1728 : 
; 1729 :                 if (strlen( optarg ) >= 3)

  00437	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  0043e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00441	e8 00 00 00 00	 call	 strlen
  00446	48 83 f8 03	 cmp	 rax, 3
  0044a	0f 82 1b 01 00
	00		 jb	 $LN46@process_ar

; 1730 :                 {
; 1731 :                     sym   = strtok_r( optarg, "=", &strtok_str);

  00450	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR strtok_str$13[rsp]
  00458	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169951
  0045f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  00466	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00469	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  0046f	48 89 44 24 70	 mov	 QWORD PTR sym$5[rsp], rax

; 1732 :                     value = strtok_r( NULL,   "=", &strtok_str);

  00474	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR strtok_str$13[rsp]
  0047c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169952
  00483	33 c9		 xor	 ecx, ecx
  00485	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  0048b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR value$9[rsp], rax

; 1733 : 
; 1734 :                     if (sym && value)

  00493	48 83 7c 24 70
	00		 cmp	 QWORD PTR sym$5[rsp], 0
  00499	0f 84 83 00 00
	00		 je	 $LN48@process_ar
  0049f	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR value$9[rsp], 0
  004a8	74 78		 je	 SHORT $LN48@process_ar

; 1735 :                     {
; 1736 :                         int j;
; 1737 : 
; 1738 :                         for (j=0; j < (int) strlen( sym ); j++)

  004aa	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR j$4[rsp], 0
  004b2	eb 0a		 jmp	 SHORT $LN15@process_ar
$LN13@process_ar:
  004b4	8b 44 24 60	 mov	 eax, DWORD PTR j$4[rsp]
  004b8	ff c0		 inc	 eax
  004ba	89 44 24 60	 mov	 DWORD PTR j$4[rsp], eax
$LN15@process_ar:
  004be	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sym$5[rsp]
  004c3	e8 00 00 00 00	 call	 strlen
  004c8	39 44 24 60	 cmp	 DWORD PTR j$4[rsp], eax
  004cc	7d 3f		 jge	 SHORT $LN14@process_ar

; 1739 :                         {
; 1740 :                             if (islower( sym[j] ))

  004ce	48 63 44 24 60	 movsxd	 rax, DWORD PTR j$4[rsp]
  004d3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sym$5[rsp]
  004d8	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  004dc	8b c8		 mov	 ecx, eax
  004de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_islower
  004e4	85 c0		 test	 eax, eax
  004e6	74 23		 je	 SHORT $LN50@process_ar

; 1741 :                                 sym[j] = toupper( sym[j] );

  004e8	48 63 44 24 60	 movsxd	 rax, DWORD PTR j$4[rsp]
  004ed	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sym$5[rsp]
  004f2	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  004f6	8b c8		 mov	 ecx, eax
  004f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  004fe	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR j$4[rsp]
  00503	48 8b 54 24 70	 mov	 rdx, QWORD PTR sym$5[rsp]
  00508	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN50@process_ar:

; 1742 :                         }

  0050b	eb a7		 jmp	 SHORT $LN13@process_ar
$LN14@process_ar:

; 1743 : 
; 1744 :                         set_symbol( sym, value );

  0050d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR value$9[rsp]
  00515	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sym$5[rsp]
  0051a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 1745 :                     }

  00520	eb 47		 jmp	 SHORT $LN49@process_ar
$LN48@process_ar:

; 1746 :                     else
; 1747 :                         // "Symbol and/or Value is invalid; ignored"
; 1748 :                         WRMSG( HHC01419, "E" );

  00522	b9 01 00 00 00	 mov	 ecx, 1
  00527	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0052d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169956
  00534	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00539	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169957
  00540	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00545	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0054a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00550	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169958
  00557	ba d4 06 00 00	 mov	 edx, 1748		; 000006d4H
  0055c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169959
  00563	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN49@process_ar:

; 1749 :                 }

  00569	eb 47		 jmp	 SHORT $LN47@process_ar
$LN46@process_ar:

; 1750 :                 else
; 1751 :                     // "Symbol and/or Value is invalid; ignored"
; 1752 :                     WRMSG( HHC01419, "E" );

  0056b	b9 01 00 00 00	 mov	 ecx, 1
  00570	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00576	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169960
  0057d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00582	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169961
  00589	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0058e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00593	41 b9 03 00 00
	00		 mov	 r9d, 3
  00599	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169962
  005a0	ba d8 06 00 00	 mov	 edx, 1752		; 000006d8H
  005a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169963
  005ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN47@process_ar:

; 1753 :             }
; 1754 :             break;

  005b2	e9 7b 03 00 00	 jmp	 $LN11@process_ar
$LN51@process_ar:

; 1755 : 
; 1756 :             case 'p':
; 1757 : 
; 1758 :                 hdl_initpath( optarg );

  005b7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  005be	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  005c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hdl_initpath

; 1759 :                 break;

  005c7	e9 66 03 00 00	 jmp	 $LN11@process_ar
$LN52@process_ar:

; 1760 : 
; 1761 :             case 'l':
; 1762 :             {
; 1763 :                 char *dllname, *strtok_str = NULL;

  005cc	48 c7 84 24 b8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR strtok_str$14[rsp], 0

; 1764 : 
; 1765 :                 for(dllname = strtok_r(optarg,", ",&strtok_str);

  005d8	4c 8d 84 24 b8
	00 00 00	 lea	 r8, QWORD PTR strtok_str$14[rsp]
  005e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169966
  005e7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  005ee	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  005f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  005f7	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR dllname$10[rsp], rax
  005ff	eb 1f		 jmp	 SHORT $LN18@process_ar
$LN16@process_ar:

; 1767 :                     dllname = strtok_r(NULL,", ",&strtok_str))

  00601	4c 8d 84 24 b8
	00 00 00	 lea	 r8, QWORD PTR strtok_str$14[rsp]
  00609	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169967
  00610	33 c9		 xor	 ecx, ecx
  00612	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  00618	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR dllname$10[rsp], rax
$LN18@process_ar:

; 1766 :                     dllname;

  00620	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR dllname$10[rsp], 0
  00629	0f 84 8f 00 00
	00		 je	 $LN17@process_ar

; 1768 :                 {
; 1769 :                     if (modcount < MAX_MODS)

  0062f	83 3d 00 00 00
	00 32		 cmp	 DWORD PTR modcount, 50	; 00000032H
  00636	7d 30		 jge	 SHORT $LN53@process_ar

; 1770 :                         modnames[ modcount++ ] = strdup( dllname ); // (caller will free)

  00638	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dllname$10[rsp]
  00640	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00646	48 63 0d 00 00
	00 00		 movsxd	 rcx, DWORD PTR modcount
  0064d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:modnames
  00654	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax
  00658	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR modcount
  0065e	ff c0		 inc	 eax
  00660	89 05 00 00 00
	00		 mov	 DWORD PTR modcount, eax
  00666	eb 51		 jmp	 SHORT $LN54@process_ar
$LN53@process_ar:

; 1771 :                     else
; 1772 :                     {
; 1773 :                         // "Startup parm -l: maximum loadable modules %d exceeded; remainder not loaded"
; 1774 :                         WRMSG( HHC01406, "W", MAX_MODS );

  00668	b9 01 00 00 00	 mov	 ecx, 1
  0066d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00673	c7 44 24 38 32
	00 00 00	 mov	 DWORD PTR [rsp+56], 50	; 00000032H
  0067b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169970
  00682	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00687	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169971
  0068e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00693	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00698	41 b9 03 00 00
	00		 mov	 r9d, 3
  0069e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169972
  006a5	ba ee 06 00 00	 mov	 edx, 1774		; 000006eeH
  006aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169973
  006b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1775 :                         break;

  006b7	eb 05		 jmp	 SHORT $LN17@process_ar
$LN54@process_ar:

; 1776 :                     }
; 1777 :                 }

  006b9	e9 43 ff ff ff	 jmp	 $LN16@process_ar
$LN17@process_ar:

; 1778 :             }
; 1779 :             break;

  006be	e9 6f 02 00 00	 jmp	 $LN11@process_ar
$LN55@process_ar:

; 1780 : 
; 1781 :             case 'b':
; 1782 : 
; 1783 :                 sysblk.logofile = optarg;

  006c3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006ca	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  006d1	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  006d4	48 89 88 00 14
	00 00		 mov	 QWORD PTR [rax+5120], rcx

; 1784 :                 break;

  006db	e9 52 02 00 00	 jmp	 $LN11@process_ar
$LN56@process_ar:

; 1785 : 
; 1786 :             case 'v':
; 1787 : 
; 1788 :                 sysblk.msglvl |= MLVL_VERBOSE;

  006e0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006e7	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  006ed	0f ba e8 1f	 bts	 eax, 31
  006f1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006f8	89 81 80 75 01
	00		 mov	 DWORD PTR [rcx+95616], eax

; 1789 :                 break;

  006fe	e9 2f 02 00 00	 jmp	 $LN11@process_ar
$LN57@process_ar:

; 1790 : 
; 1791 :             case 'd':
; 1792 : 
; 1793 :                 sysblk.daemon_mode = 1;

  00703	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0070a	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00710	83 c8 04	 or	 eax, 4
  00713	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0071a	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 1794 :                 break;

  00720	e9 0d 02 00 00	 jmp	 $LN11@process_ar
$LN58@process_ar:

; 1795 : 
; 1796 :             case 'e':
; 1797 : 
; 1798 :                 extgui = 1;

  00725	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  0072c	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 1799 :                 break;

  00732	e9 fb 01 00 00	 jmp	 $LN11@process_ar
$LN59@process_ar:

; 1800 : 
; 1801 :             case 't':
; 1802 : 
; 1803 :                 sysblk.scrtest = 1;

  00737	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0073e	c7 80 18 11 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+4376], 1

; 1804 :                 sysblk.scrfactor = 1.0;

  00748	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0074f	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00757	f2 0f 11 80 20
	11 00 00	 movsd	 QWORD PTR [rax+4384], xmm0

; 1805 : 
; 1806 :                 if (optarg)

  0075f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  00766	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0076a	0f 84 02 01 00
	00		 je	 $LN60@process_ar

; 1807 :                 {
; 1808 :                     double scrfactor;
; 1809 :                     double max_factor = MAX_RUNTEST_FACTOR;

  00770	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@402ca213d82418e5
  00778	f2 0f 11 84 24
	80 00 00 00	 movsd	 QWORD PTR max_factor$7[rsp], xmm0

; 1810 : 
; 1811 :                     /* Round down to nearest 10th of a second */
; 1812 :                     max_factor = floor( max_factor * 10.0 ) / 10.0;

  00781	f2 0f 10 84 24
	80 00 00 00	 movsd	 xmm0, QWORD PTR max_factor$7[rsp]
  0078a	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4024000000000000
  00792	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_floor
  00798	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4024000000000000
  007a0	f2 0f 11 84 24
	80 00 00 00	 movsd	 QWORD PTR max_factor$7[rsp], xmm0

; 1813 :                     scrfactor = atof( optarg );

  007a9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  007b0	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  007b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atof
  007b9	f2 0f 11 84 24
	a0 00 00 00	 movsd	 QWORD PTR scrfactor$11[rsp], xmm0

; 1814 : 
; 1815 :                     if (scrfactor >= 1.0 && scrfactor <= max_factor)

  007c2	f2 0f 10 84 24
	a0 00 00 00	 movsd	 xmm0, QWORD PTR scrfactor$11[rsp]
  007cb	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@3ff0000000000000
  007d3	72 2e		 jb	 SHORT $LN61@process_ar
  007d5	f2 0f 10 84 24
	80 00 00 00	 movsd	 xmm0, QWORD PTR max_factor$7[rsp]
  007de	66 0f 2f 84 24
	a0 00 00 00	 comisd	 xmm0, QWORD PTR scrfactor$11[rsp]
  007e7	72 1a		 jb	 SHORT $LN61@process_ar

; 1816 :                         sysblk.scrfactor = scrfactor;

  007e9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007f0	f2 0f 10 84 24
	a0 00 00 00	 movsd	 xmm0, QWORD PTR scrfactor$11[rsp]
  007f9	f2 0f 11 80 20
	11 00 00	 movsd	 QWORD PTR [rax+4384], xmm0
  00801	eb 6f		 jmp	 SHORT $LN62@process_ar
$LN61@process_ar:

; 1817 :                     else
; 1818 :                     {
; 1819 :                         // "Test timeout factor %s outside of valid range 1.0 to %3.1f"
; 1820 :                         WRMSG( HHC00020, "S", optarg, max_factor );

  00803	b9 01 00 00 00	 mov	 ecx, 1
  00808	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0080e	f2 0f 10 84 24
	80 00 00 00	 movsd	 xmm0, QWORD PTR max_factor$7[rsp]
  00817	f2 0f 11 44 24
	40		 movsd	 QWORD PTR [rsp+64], xmm0
  0081d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  00824	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00827	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0082c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169982
  00833	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00838	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169983
  0083f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00844	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00849	41 b9 03 00 00
	00		 mov	 r9d, 3
  0084f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169984
  00856	ba 1c 07 00 00	 mov	 edx, 1820		; 0000071cH
  0085b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169985
  00862	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1821 :                         arg_error++;

  00868	8b 44 24 54	 mov	 eax, DWORD PTR arg_error$[rsp]
  0086c	ff c0		 inc	 eax
  0086e	89 44 24 54	 mov	 DWORD PTR arg_error$[rsp], eax
$LN62@process_ar:
$LN60@process_ar:

; 1822 :                     }
; 1823 :                 }
; 1824 :                 break;

  00872	e9 bb 00 00 00	 jmp	 $LN11@process_ar
$LN63@process_ar:

; 1825 : 
; 1826 :             default:
; 1827 :             {
; 1828 :                 char buf[16];
; 1829 : 
; 1830 :                 if (isprint( optopt ))

  00877	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optopt
  0087e	8b 08		 mov	 ecx, DWORD PTR [rax]
  00880	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isprint
  00886	85 c0		 test	 eax, eax
  00888	74 26		 je	 SHORT $LN64@process_ar

; 1831 :                     MSGBUF( buf, "'-%c'", optopt );

  0088a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optopt
  00891	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  00894	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169989
  0089b	ba 10 00 00 00	 mov	 edx, 16
  008a0	48 8d 8c 24 28
	01 00 00	 lea	 rcx, QWORD PTR buf$16[rsp]
  008a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  008ae	eb 24		 jmp	 SHORT $LN65@process_ar
$LN64@process_ar:

; 1832 :                 else
; 1833 :                     MSGBUF( buf, "(hex %2.2x)", optopt );

  008b0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optopt
  008b7	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  008ba	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169990
  008c1	ba 10 00 00 00	 mov	 edx, 16
  008c6	48 8d 8c 24 28
	01 00 00	 lea	 rcx, QWORD PTR buf$16[rsp]
  008ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN65@process_ar:

; 1834 : 
; 1835 :                 // "Invalid/unsupported option: %s"
; 1836 :                 WRMSG( HHC00023, "S", buf );

  008d4	b9 01 00 00 00	 mov	 ecx, 1
  008d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  008df	48 8d 8c 24 28
	01 00 00	 lea	 rcx, QWORD PTR buf$16[rsp]
  008e7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  008ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169991
  008f3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169992
  008ff	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00904	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00909	41 b9 03 00 00
	00		 mov	 r9d, 3
  0090f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169993
  00916	ba 2c 07 00 00	 mov	 edx, 1836		; 0000072cH
  0091b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169994
  00922	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1837 :                 arg_error++;

  00928	8b 44 24 54	 mov	 eax, DWORD PTR arg_error$[rsp]
  0092c	ff c0		 inc	 eax
  0092e	89 44 24 54	 mov	 DWORD PTR arg_error$[rsp], eax
$LN11@process_ar:

; 1838 :             }
; 1839 :             break;
; 1840 : 
; 1841 :         } // end switch(c)
; 1842 :     } // end while

  00932	e9 4d f8 ff ff	 jmp	 $LN8@process_ar
$LN9@process_ar:
$LN19@process_ar:

; 1843 : 
; 1844 :     while (optind < argc)

  00937	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optind
  0093e	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  00945	39 08		 cmp	 DWORD PTR [rax], ecx
  00947	0f 8d 95 00 00
	00		 jge	 $LN20@process_ar

; 1845 :     {
; 1846 :         // "Unrecognized option: %s"
; 1847 :         WRMSG( HHC00024, "S", argv[ optind++ ]);

  0094d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optind
  00954	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00957	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0095f	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00963	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv422[rsp], rax
  0096b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optind
  00972	8b 00		 mov	 eax, DWORD PTR [rax]
  00974	ff c0		 inc	 eax
  00976	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optind
  0097d	89 01		 mov	 DWORD PTR [rcx], eax
  0097f	b9 01 00 00 00	 mov	 ecx, 1
  00984	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0098a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv422[rsp]
  00992	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00997	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169995
  0099e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169996
  009aa	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  009af	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009b4	41 b9 03 00 00
	00		 mov	 r9d, 3
  009ba	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169997
  009c1	ba 37 07 00 00	 mov	 edx, 1847		; 00000737H
  009c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169998
  009cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1848 :         arg_error++;

  009d3	8b 44 24 54	 mov	 eax, DWORD PTR arg_error$[rsp]
  009d7	ff c0		 inc	 eax
  009d9	89 44 24 54	 mov	 DWORD PTR arg_error$[rsp], eax

; 1849 :     }

  009dd	e9 55 ff ff ff	 jmp	 $LN19@process_ar
$LN20@process_ar:
$error$78:

; 1850 : 
; 1851 : error:
; 1852 : 
; 1853 :     /* Terminate if invalid arguments were detected */
; 1854 :     if (arg_error)

  009e2	83 7c 24 54 00	 cmp	 DWORD PTR arg_error$[rsp], 0
  009e7	74 0a		 je	 SHORT $LN66@process_ar

; 1855 :     {
; 1856 :         /* Show them all of our command-line arguments... */
; 1857 :         arghelp();

  009e9	e8 00 00 00 00	 call	 arghelp

; 1858 :     }

  009ee	e9 8f 02 00 00	 jmp	 $LN67@process_ar
$LN66@process_ar:

; 1859 :     else /* Check for config and rc file, but don't open */
; 1860 :     {
; 1861 :         struct stat st;
; 1862 :         int i, rv;
; 1863 :         bool using_default;
; 1864 : 
; 1865 :         for (i=0; cfgorrccount > i; i++)

  009f3	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  009fb	eb 0a		 jmp	 SHORT $LN23@process_ar
$LN21@process_ar:
  009fd	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00a01	ff c0		 inc	 eax
  00a03	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN23@process_ar:
  00a07	83 7c 24 50 02	 cmp	 DWORD PTR i$1[rsp], 2
  00a0c	0f 8d 70 02 00
	00		 jge	 $LN22@process_ar

; 1866 :         {
; 1867 :             using_default = false;

  00a12	c6 44 24 58 00	 mov	 BYTE PTR using_default$2[rsp], 0

; 1868 : 
; 1869 :             /* If no value explicitly specified, try environment */
; 1870 :             if (0
; 1871 :                 || !cfgorrc[i].filename
; 1872 :                 || !cfgorrc[i].filename[0]

  00a17	33 c0		 xor	 eax, eax
  00a19	85 c0		 test	 eax, eax
  00a1b	75 40		 jne	 SHORT $LN69@process_ar
  00a1d	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  00a22	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00a26	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cfgorrc
  00a2d	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00a32	74 29		 je	 SHORT $LN69@process_ar
  00a34	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  00a39	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00a3d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cfgorrc
  00a44	ba 01 00 00 00	 mov	 edx, 1
  00a49	48 6b d2 00	 imul	 rdx, rdx, 0
  00a4d	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00a51	0f be 04 10	 movsx	 eax, BYTE PTR [rax+rdx]
  00a55	85 c0		 test	 eax, eax
  00a57	0f 85 93 00 00
	00		 jne	 $LN68@process_ar
$LN69@process_ar:

; 1873 :             )
; 1874 :             {
; 1875 :                 const char* envname = get_symbol( cfgorrc[i].envname );

  00a5d	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  00a62	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00a66	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cfgorrc
  00a6d	48 8b 4c 01 08	 mov	 rcx, QWORD PTR [rcx+rax+8]
  00a72	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_get_symbol
  00a78	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR envname$12[rsp], rax

; 1876 : 
; 1877 :                 if (envname && envname[0])

  00a80	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR envname$12[rsp], 0
  00a89	74 37		 je	 SHORT $LN70@process_ar
  00a8b	b8 01 00 00 00	 mov	 eax, 1
  00a90	48 6b c0 00	 imul	 rax, rax, 0
  00a94	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR envname$12[rsp]
  00a9c	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00aa0	85 c0		 test	 eax, eax
  00aa2	74 1e		 je	 SHORT $LN70@process_ar

; 1878 :                     cfgorrc[i].filename = envname;

  00aa4	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  00aa9	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00aad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cfgorrc
  00ab4	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR envname$12[rsp]
  00abc	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
  00ac0	eb 2e		 jmp	 SHORT $LN71@process_ar
$LN70@process_ar:

; 1879 :                 else
; 1880 :                 {
; 1881 :                     /* If no environment, use our hard coded default */
; 1882 :                     using_default = true;

  00ac2	c6 44 24 58 01	 mov	 BYTE PTR using_default$2[rsp], 1

; 1883 :                     cfgorrc[i].filename = cfgorrc[i].defaultfile;

  00ac7	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  00acc	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00ad0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cfgorrc
  00ad7	48 63 54 24 50	 movsxd	 rdx, DWORD PTR i$1[rsp]
  00adc	48 6b d2 20	 imul	 rdx, rdx, 32		; 00000020H
  00ae0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cfgorrc
  00ae7	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  00aec	49 89 04 10	 mov	 QWORD PTR [r8+rdx], rax
$LN71@process_ar:
$LN68@process_ar:

; 1884 :                 }
; 1885 :             }
; 1886 : 
; 1887 :             /* Explicit request for no file use at all? */
; 1888 :             if (strcasecmp( cfgorrc[i].filename, "none" ) == 0)

  00af0	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  00af5	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00af9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cfgorrc
  00b00	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170006
  00b07	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00b0b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00b11	85 c0		 test	 eax, eax
  00b13	75 1d		 jne	 SHORT $LN72@process_ar

; 1889 :             {
; 1890 :                cfgorrc[i].filename = NULL;  /* Suppress file */

  00b15	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  00b1a	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00b1e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cfgorrc
  00b25	48 c7 04 01 00
	00 00 00	 mov	 QWORD PTR [rcx+rax], 0

; 1891 :                continue;

  00b2d	e9 cb fe ff ff	 jmp	 $LN21@process_ar
$LN72@process_ar:

; 1892 :             }
; 1893 : 
; 1894 :             /* File specified either explicitly, by environment,
; 1895 :                or by hard coded default: verify its existence.
; 1896 :             */
; 1897 :             if ((rv = stat( cfgorrc[i].filename, &st )) != 0)

  00b32	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  00b37	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00b3b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cfgorrc
  00b42	48 8d 94 24 f0
	00 00 00	 lea	 rdx, QWORD PTR st$15[rsp]
  00b4a	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00b4e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stat64
  00b54	89 84 24 88 00
	00 00		 mov	 DWORD PTR rv$8[rsp], eax
  00b5b	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR rv$8[rsp], 0
  00b63	0f 84 14 01 00
	00		 je	 $LN73@process_ar

; 1898 :             {
; 1899 :                 /* If this is the .rc file, default to none */
; 1900 :                 if (want_rc == i && using_default)

  00b69	83 7c 24 50 01	 cmp	 DWORD PTR i$1[rsp], 1
  00b6e	75 26		 jne	 SHORT $LN74@process_ar
  00b70	0f b6 44 24 58	 movzx	 eax, BYTE PTR using_default$2[rsp]
  00b75	85 c0		 test	 eax, eax
  00b77	74 1d		 je	 SHORT $LN74@process_ar

; 1901 :                 {
; 1902 :                    cfgorrc[i].filename = NULL;  /* Suppress file */

  00b79	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  00b7e	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00b82	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cfgorrc
  00b89	48 c7 04 01 00
	00 00 00	 mov	 QWORD PTR [rcx+rax], 0

; 1903 :                    continue;

  00b91	e9 67 fe ff ff	 jmp	 $LN21@process_ar
$LN74@process_ar:

; 1904 :                 }
; 1905 : 
; 1906 :                 // "%s file '%s' not found: %s"
; 1907 :                 WRMSG( HHC02342, "S", cfgorrc[i].whatfile,

  00b96	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00b9c	8b 08		 mov	 ecx, DWORD PTR [rax]
  00b9e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00ba4	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv501[rsp], rax
  00bac	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00bb1	48 6b c9 20	 imul	 rcx, rcx, 32		; 00000020H
  00bb5	48 89 8c 24 d8
	00 00 00	 mov	 QWORD PTR tv506[rsp], rcx
  00bbd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cfgorrc
  00bc4	48 89 94 24 d0
	00 00 00	 mov	 QWORD PTR tv544[rsp], rdx
  00bcc	4c 63 44 24 50	 movsxd	 r8, DWORD PTR i$1[rsp]
  00bd1	4d 6b c0 20	 imul	 r8, r8, 32		; 00000020H
  00bd5	4c 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv511[rsp], r8
  00bdd	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:cfgorrc
  00be4	4c 89 8c 24 e0
	00 00 00	 mov	 QWORD PTR tv545[rsp], r9
  00bec	b9 01 00 00 00	 mov	 ecx, 1
  00bf1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00bf7	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv501[rsp]
  00bff	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00c04	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv544[rsp]
  00c0c	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR tv506[rsp]
  00c14	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00c18	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00c1d	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR tv545[rsp]
  00c25	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv511[rsp]
  00c2d	48 8b 4c 0a 18	 mov	 rcx, QWORD PTR [rdx+rcx+24]
  00c32	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00c37	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170009
  00c3e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c43	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170010
  00c4a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c4f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c54	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c5a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170011
  00c61	ba 74 07 00 00	 mov	 edx, 1908		; 00000774H
  00c66	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170012
  00c6d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1908 :                     cfgorrc[i].filename, strerror( errno ));
; 1909 :                 arg_error++;

  00c73	8b 44 24 54	 mov	 eax, DWORD PTR arg_error$[rsp]
  00c77	ff c0		 inc	 eax
  00c79	89 44 24 54	 mov	 DWORD PTR arg_error$[rsp], eax
$LN73@process_ar:

; 1910 :             }
; 1911 :         }

  00c7d	e9 7b fd ff ff	 jmp	 $LN21@process_ar
$LN22@process_ar:
$LN67@process_ar:

; 1912 :     }
; 1913 : 
; 1914 :     fflush( stderr );

  00c82	b9 02 00 00 00	 mov	 ecx, 2
  00c87	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c8d	48 8b c8	 mov	 rcx, rax
  00c90	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 1915 :     fflush( stdout );

  00c96	b9 01 00 00 00	 mov	 ecx, 1
  00c9b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00ca1	48 8b c8	 mov	 rcx, rax
  00ca4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 1916 : 
; 1917 :     return arg_error;

  00caa	8b 44 24 54	 mov	 eax, DWORD PTR arg_error$[rsp]

; 1918 : }

  00cae	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00cb6	48 33 cc	 xor	 rcx, rsp
  00cb9	e8 00 00 00 00	 call	 __security_check_cookie
  00cbe	48 81 c4 48 01
	00 00		 add	 rsp, 328		; 00000148H
  00cc5	c3		 ret	 0
  00cc6	66 90		 npad	 2
$LN77@process_ar:
  00cc8	00 00 00 00	 DD	 $LN26@process_ar
  00ccc	00 00 00 00	 DD	 $LN27@process_ar
  00cd0	00 00 00 00	 DD	 $LN55@process_ar
  00cd4	00 00 00 00	 DD	 $LN57@process_ar
  00cd8	00 00 00 00	 DD	 $LN58@process_ar
  00cdc	00 00 00 00	 DD	 $LN42@process_ar
  00ce0	00 00 00 00	 DD	 $LN28@process_ar
  00ce4	00 00 00 00	 DD	 $LN52@process_ar
  00ce8	00 00 00 00	 DD	 $LN43@process_ar
  00cec	00 00 00 00	 DD	 $LN51@process_ar
  00cf0	00 00 00 00	 DD	 $LN44@process_ar
  00cf4	00 00 00 00	 DD	 $LN45@process_ar
  00cf8	00 00 00 00	 DD	 $LN59@process_ar
  00cfc	00 00 00 00	 DD	 $LN56@process_ar
  00d00	00 00 00 00	 DD	 $LN63@process_ar
$LN76@process_ar:
  00d04	00		 DB	 0
  00d05	01		 DB	 1
  00d06	0e		 DB	 14
  00d07	0e		 DB	 14
  00d08	0e		 DB	 14
  00d09	0e		 DB	 14
  00d0a	0e		 DB	 14
  00d0b	0e		 DB	 14
  00d0c	0e		 DB	 14
  00d0d	0e		 DB	 14
  00d0e	0e		 DB	 14
  00d0f	0e		 DB	 14
  00d10	0e		 DB	 14
  00d11	0e		 DB	 14
  00d12	0e		 DB	 14
  00d13	0e		 DB	 14
  00d14	0e		 DB	 14
  00d15	0e		 DB	 14
  00d16	0e		 DB	 14
  00d17	0e		 DB	 14
  00d18	0e		 DB	 14
  00d19	0e		 DB	 14
  00d1a	0e		 DB	 14
  00d1b	0e		 DB	 14
  00d1c	0e		 DB	 14
  00d1d	0e		 DB	 14
  00d1e	0e		 DB	 14
  00d1f	0e		 DB	 14
  00d20	0e		 DB	 14
  00d21	0e		 DB	 14
  00d22	0e		 DB	 14
  00d23	0e		 DB	 14
  00d24	0e		 DB	 14
  00d25	0e		 DB	 14
  00d26	0e		 DB	 14
  00d27	0e		 DB	 14
  00d28	0e		 DB	 14
  00d29	0e		 DB	 14
  00d2a	0e		 DB	 14
  00d2b	0e		 DB	 14
  00d2c	0e		 DB	 14
  00d2d	0e		 DB	 14
  00d2e	0e		 DB	 14
  00d2f	0e		 DB	 14
  00d30	0e		 DB	 14
  00d31	0e		 DB	 14
  00d32	0e		 DB	 14
  00d33	0e		 DB	 14
  00d34	0e		 DB	 14
  00d35	0e		 DB	 14
  00d36	0e		 DB	 14
  00d37	0e		 DB	 14
  00d38	0e		 DB	 14
  00d39	0e		 DB	 14
  00d3a	0e		 DB	 14
  00d3b	0e		 DB	 14
  00d3c	0e		 DB	 14
  00d3d	0e		 DB	 14
  00d3e	0e		 DB	 14
  00d3f	0e		 DB	 14
  00d40	0e		 DB	 14
  00d41	0e		 DB	 14
  00d42	0e		 DB	 14
  00d43	0e		 DB	 14
  00d44	0e		 DB	 14
  00d45	0e		 DB	 14
  00d46	0e		 DB	 14
  00d47	0e		 DB	 14
  00d48	0e		 DB	 14
  00d49	0e		 DB	 14
  00d4a	0e		 DB	 14
  00d4b	0e		 DB	 14
  00d4c	0e		 DB	 14
  00d4d	0e		 DB	 14
  00d4e	0e		 DB	 14
  00d4f	0e		 DB	 14
  00d50	0e		 DB	 14
  00d51	0e		 DB	 14
  00d52	0e		 DB	 14
  00d53	0e		 DB	 14
  00d54	0e		 DB	 14
  00d55	0e		 DB	 14
  00d56	0e		 DB	 14
  00d57	0e		 DB	 14
  00d58	0e		 DB	 14
  00d59	0e		 DB	 14
  00d5a	0e		 DB	 14
  00d5b	0e		 DB	 14
  00d5c	0e		 DB	 14
  00d5d	0e		 DB	 14
  00d5e	0e		 DB	 14
  00d5f	0e		 DB	 14
  00d60	0e		 DB	 14
  00d61	0e		 DB	 14
  00d62	0e		 DB	 14
  00d63	0e		 DB	 14
  00d64	0e		 DB	 14
  00d65	0e		 DB	 14
  00d66	0e		 DB	 14
  00d67	02		 DB	 2
  00d68	0e		 DB	 14
  00d69	03		 DB	 3
  00d6a	04		 DB	 4
  00d6b	05		 DB	 5
  00d6c	0e		 DB	 14
  00d6d	06		 DB	 6
  00d6e	0e		 DB	 14
  00d6f	0e		 DB	 14
  00d70	0e		 DB	 14
  00d71	07		 DB	 7
  00d72	0e		 DB	 14
  00d73	0e		 DB	 14
  00d74	08		 DB	 8
  00d75	09		 DB	 9
  00d76	0e		 DB	 14
  00d77	0a		 DB	 10
  00d78	0b		 DB	 11
  00d79	0c		 DB	 12
  00d7a	0e		 DB	 14
  00d7b	0d		 DB	 13
process_args ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\impl.c
_TEXT	SEGMENT
path$1 = 32
__$ArrayPad$ = 304
argc$ = 336
argv$ = 344
init_progname PROC

; 1587 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1588 :     free( sysblk.hercules_pgmname );

  00022	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00029	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1589 :     free( sysblk.hercules_pgmpath );

  00033	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003a	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1590 : 
; 1591 :     if (argc < 1 || !strlen( argv[0] ))

  00044	83 bc 24 50 01
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  0004c	7c 1f		 jl	 SHORT $LN4@init_progn
  0004e	b8 08 00 00 00	 mov	 eax, 8
  00053	48 6b c0 00	 imul	 rax, rax, 0
  00057	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0005f	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00063	e8 00 00 00 00	 call	 strlen
  00068	48 85 c0	 test	 rax, rax
  0006b	75 32		 jne	 SHORT $LN2@init_progn
$LN4@init_progn:

; 1592 :     {
; 1593 :         sysblk.hercules_pgmname = strdup( "hercules" );

  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169855
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0007a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00081	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 1594 :         sysblk.hercules_pgmpath = strdup( "" );

  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169856
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00092	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00099	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 1595 :     }

  0009d	eb 51		 jmp	 SHORT $LN3@init_progn
$LN2@init_progn:

; 1596 :     else
; 1597 :     {
; 1598 :         char path[ MAX_PATH ];
; 1599 : 
; 1600 : #if defined( _MSVC_ )
; 1601 :         GetModuleFileName( NULL, path, _countof( path ));

  0009f	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  000a5	48 8d 54 24 20	 lea	 rdx, QWORD PTR path$1[rsp]
  000aa	33 c9		 xor	 ecx, ecx
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleFileNameA

; 1602 : #else
; 1603 :         STRLCPY( path, argv[0] );
; 1604 : #endif
; 1605 :         sysblk.hercules_pgmname = strdup( basename( path ));

  000b2	48 8d 4c 24 20	 lea	 rcx, QWORD PTR path$1[rsp]
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_basename
  000bd	48 8b c8	 mov	 rcx, rax
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  000c6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000cd	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 1606 :         sysblk.hercules_pgmpath = strdup( dirname( path ));

  000d1	48 8d 4c 24 20	 lea	 rcx, QWORD PTR path$1[rsp]
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_dirname
  000dc	48 8b c8	 mov	 rcx, rax
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  000e5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000ec	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
$LN3@init_progn:

; 1607 :     }
; 1608 : }

  000f0	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000f8	48 33 cc	 xor	 rcx, rsp
  000fb	e8 00 00 00 00	 call	 __security_check_cookie
  00100	48 81 c4 48 01
	00 00		 add	 rsp, 328		; 00000148H
  00107	c3		 ret	 0
init_progname ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Release_Interrupt_Lock PROC

; 403  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@Release_In:

; 404  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@Release_In

; 405  :     sysblk.intowner = LOCK_OWNER_NONE;

  00014	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00020	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 406  :     hthread_release_lock( &sysblk.intlock, location );

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00034	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 407  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
Release_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Obtain_Interrupt_Lock PROC

; 379  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 380  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	74 13		 je	 SHORT $LN2@Obtain_Int

; 381  :         HOSTREGS->intwait = true;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00022	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN2@Obtain_Int:

; 382  :     hthread_obtain_lock( &sysblk.intlock, location );

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00036	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 383  :     Interrupt_Lock_Obtained( regs, location );

  00044	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	e8 00 00 00 00	 call	 Interrupt_Lock_Obtained

; 384  : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
Obtain_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Interrupt_Lock_Obtained PROC

; 347  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 348  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	0f 84 db 00 00
	00		 je	 $LN4@Interrupt_
$LN2@Interrupt_:

; 349  :     {
; 350  :         /* Wait for any SYNCHRONIZE_CPUS to finish before proceeding */
; 351  :         while (sysblk.syncing)

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8f 00 00
	00		 je	 $LN3@Interrupt_

; 352  :         {
; 353  :             /* Indicate we have reached the sync point */
; 354  :             sysblk.sync_mask &= ~HOSTREGS->cpubit;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00035	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 f7 d0	 not	 rax
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004a	48 8b 89 80 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4992]
  00051	48 23 c8	 and	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 89 81 80 13
	00 00		 mov	 QWORD PTR [rcx+4992], rax

; 355  : 
; 356  :             /* If we're the last CPU to reach this sync point,
; 357  :                signal the CPU that requested the sync that it
; 358  :                may now safely proceed with its exclusive logic.
; 359  :             */
; 360  :             if (!sysblk.sync_mask)

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 83 b8 80 13
	00 00 00	 cmp	 QWORD PTR [rax+4992], 0
  00074	75 1b		 jne	 SHORT $LN6@Interrupt_

; 361  :                 hthread_signal_condition( &sysblk.all_synced_cond, location );

  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00083	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN6@Interrupt_:

; 362  : 
; 363  :             /* Wait for CPU that requested the sync to indicate
; 364  :                it's done and thus is now safe for us to proceed.
; 365  :             */
; 366  :             hthread_wait_condition( &sysblk.sync_done_cond, &sysblk.intlock, location );

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  000ac	4c 8b 44 24 38	 mov	 r8, QWORD PTR location$[rsp]
  000b1	48 8b d0	 mov	 rdx, rax
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 367  :         }

  000ba	e9 5b ff ff ff	 jmp	 $LN2@Interrupt_
$LN3@Interrupt_:

; 368  : 
; 369  :         HOSTREGS->intwait = false;

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cb	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0

; 370  :         sysblk.intowner = HOSTREGS->cpuad;

  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e5	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ec	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 371  :     }

  000f3	eb 13		 jmp	 SHORT $LN5@Interrupt_
$LN4@Interrupt_:

; 372  :     else
; 373  :         sysblk.intowner = LOCK_OWNER_OTHER;

  000f5	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00101	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN5@Interrupt_:

; 374  : }

  00108	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010c	c3		 ret	 0
Interrupt_Lock_Obtained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
i$ = 32
mask$ = 64
location$ = 72
wakeup_cpus_mask PROC

; 325  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 326  :     int i;
; 327  : 
; 328  :     for (i=0; mask; mask >>= 1, i++)

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00016	eb 17		 jmp	 SHORT $LN4@wakeup_cpu
$LN2@wakeup_cpu:
  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR mask$[rsp]
  0001d	48 d1 e8	 shr	 rax, 1
  00020	48 89 44 24 40	 mov	 QWORD PTR mask$[rsp], rax
  00025	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00029	ff c0		 inc	 eax
  0002b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@wakeup_cpu:
  0002f	48 83 7c 24 40
	00		 cmp	 QWORD PTR mask$[rsp], 0
  00035	74 2e		 je	 SHORT $LN3@wakeup_cpu

; 329  :     {
; 330  :         if (mask & 1)

  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR mask$[rsp]
  0003c	48 83 e0 01	 and	 rax, 1
  00040	48 85 c0	 test	 rax, rax
  00043	74 1e		 je	 SHORT $LN5@wakeup_cpu

; 331  :             wakeup_cpu( sysblk.regs[i], location );

  00045	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0004a	48 8b 54 24 48	 mov	 rdx, QWORD PTR location$[rsp]
  0004f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00056	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  0005e	e8 00 00 00 00	 call	 wakeup_cpu
$LN5@wakeup_cpu:

; 332  :     }

  00063	eb b3		 jmp	 SHORT $LN2@wakeup_cpu
$LN3@wakeup_cpu:

; 333  : }

  00065	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00069	c3		 ret	 0
wakeup_cpus_mask ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
wakeup_cpu PROC

; 268  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 269  :     hthread_signal_condition( &regs->intcond, location );

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 05 80 0c 00
	00		 add	 rax, 3200		; 00000c80H
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0001e	48 8b c8	 mov	 rcx, rax
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 270  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
wakeup_cpu ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\impl.c
_TEXT	SEGMENT
getCommandHandler PROC

; 725  :     return (panel_command);

  00000	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_panel_command
  00007	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 726  : }

  0000a	c3		 ret	 0
getCommandHandler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\impl.c
_TEXT	SEGMENT
cb$ = 8
registerLogCallback PROC

; 98   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 99   :     log_callback = cb;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR cb$[rsp]
  0000a	48 89 05 00 00
	00 00		 mov	 QWORD PTR log_callback, rax

; 100  : }

  00011	c3		 ret	 0
registerLogCallback ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\impl.c
_TEXT	SEGMENT
rc$ = 80
err$1 = 84
i$2 = 88
idle$3 = 92
intv$4 = 96
cnt$5 = 100
modnum$6 = 104
sfd$7 = 108
rc$8 = 112
fds$9 = 120
tv667 = 128
tv704 = 132
tv721 = 136
bSuccess$10 = 140
tv797 = 144
tv832 = 152
dummy$11 = 160
rctid$ = 164
logcbtid$ = 168
tv370 = 176
tv599 = 184
tv871 = 192
tv891 = 200
tv924 = 208
tv1032 = 216
tv1051 = 224
tv1072 = 232
tv1133 = 240
tv1273 = 248
tv1353 = 256
tv1375 = 264
buf$12 = 272
buf$13 = 280
num_procs$14 = 320
__$ArrayPad$ = 384
argc$ = 416
argv$ = 424
impl	PROC

; 804  : {

$LN103:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	57		 push	 rdi
  0000a	48 81 ec 90 01
	00 00		 sub	 rsp, 400		; 00000190H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@impl:

; 805  : TID     rctid;                          /* RC file thread identifier */
; 806  : TID     logcbtid;                       /* RC file thread identifier */
; 807  : int     rc;
; 808  : 
; 809  :     SET_THREAD_NAME( IMPL_THREAD_NAME );

  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169550
  00030	8b c8		 mov	 ecx, eax
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_set_thread_name
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169551
  00045	8b c8		 mov	 ecx, eax
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_thread_name
  0004d	33 c0		 xor	 eax, eax
  0004f	85 c0		 test	 eax, eax
  00051	75 d0		 jne	 SHORT $LN4@impl

; 810  : 
; 811  :     /* Seed the pseudo-random number generator */
; 812  :     init_random();

  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_init_random

; 813  : 
; 814  :     /* Clear the system configuration block */
; 815  :     memset( &sysblk, 0, sizeof( SYSBLK ) );

  00059	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  00060	33 c0		 xor	 eax, eax
  00062	b9 00 76 01 00	 mov	 ecx, 95744		; 00017600H
  00067	f3 aa		 rep stosb

; 816  : 
; 817  :     /* Lock SYSBLK into memory since it's referenced so frequently.
; 818  :        Note that the call could fail when the working set is small
; 819  :        but that's okay. We did our best. Locking it isn't critical.
; 820  :     */
; 821  :     MLOCK( &sysblk, sizeof( SYSBLK ));

  00069	ba 00 76 01 00	 mov	 edx, 95744		; 00017600H
  0006e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_mlock

; 822  : 
; 823  : #if defined (_MSVC_)
; 824  :     _setmaxstdio(2048);

  0007b	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__setmaxstdio
$LN7@impl:
$LN10@impl:

; 825  : #endif
; 826  : 
; 827  :     INIT_BLOCK_HEADER_TRAILER( (&sysblk), SYSBLK );

  00086	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0008d	48 05 90 75 01
	00		 add	 rax, 95632		; 00017590H
  00093	48 8b f8	 mov	 rdi, rax
  00096	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  0009b	b9 10 00 00 00	 mov	 ecx, 16
  000a0	f3 aa		 rep stosb
  000a2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000a9	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  000b0	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  000b5	b9 10 00 00 00	 mov	 ecx, 16
  000ba	f3 aa		 rep stosb
  000bc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000c3	48 05 90 75 01
	00		 add	 rax, 95632		; 00017590H
  000c9	41 b8 10 00 00
	00		 mov	 r8d, 16
  000cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169552
  000d6	48 8b c8	 mov	 rcx, rax
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  000df	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000e6	48 05 90 75 01
	00		 add	 rax, 95632		; 00017590H
  000ec	41 b8 10 00 00
	00		 mov	 r8d, 16
  000f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169553
  000f9	48 8b c8	 mov	 rcx, rax
  000fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
  00102	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00109	41 b8 10 00 00
	00		 mov	 r8d, 16
  0010f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169554
  00116	48 8b c8	 mov	 rcx, rax
  00119	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  0011f	33 c0		 xor	 eax, eax
  00121	85 c0		 test	 eax, eax
  00123	0f 85 5d ff ff
	ff		 jne	 $LN10@impl
  00129	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00130	48 83 c0 10	 add	 rax, 16
  00134	48 8b f8	 mov	 rdi, rax
  00137	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  0013c	b9 10 00 00 00	 mov	 ecx, 16
  00141	f3 aa		 rep stosb
  00143	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0014a	48 83 c0 10	 add	 rax, 16
  0014e	41 b8 10 00 00
	00		 mov	 r8d, 16
  00154	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169555
  0015b	48 8b c8	 mov	 rcx, rax
  0015e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  00164	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0016b	e8 00 00 00 00	 call	 _byteswap_uint64
  00170	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00177	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
  0017b	b9 00 76 01 00	 mov	 ecx, 95744		; 00017600H
  00180	e8 00 00 00 00	 call	 _byteswap_ulong
  00185	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0018c	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  0018f	33 c0		 xor	 eax, eax
  00191	85 c0		 test	 eax, eax
  00193	0f 85 ed fe ff
	ff		 jne	 $LN7@impl

; 828  : 
; 829  :     // Set some defaults
; 830  :     sysblk.msglvl = DEFAULT_MLVL;

  00199	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001a0	c7 80 80 75 01
	00 00 00 00 c0	 mov	 DWORD PTR [rax+95616], -1073741824 ; c0000000H

; 831  :     sysblk.logoptnotime = 0;

  001aa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001b1	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  001b7	0f ba f0 17	 btr	 eax, 23
  001bb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001c2	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 832  :     sysblk.logoptnodate = 1;

  001c8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001cf	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  001d5	0f ba e8 16	 bts	 eax, 22
  001d9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001e0	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 833  : 
; 834  :     /* Initialize program name and version strings arrays */
; 835  :     init_progname( argc, argv );

  001e6	48 8b 94 24 a8
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  001ee	8b 8c 24 a0 01
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  001f5	e8 00 00 00 00	 call	 init_progname

; 836  :     init_sysblk_version_str_arrays( NULL );

  001fa	33 c9		 xor	 ecx, ecx
  001fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_init_sysblk_version_str_arrays

; 837  : 
; 838  :     if (argc < 2)

  00202	83 bc 24 a0 01
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  0020a	7d 77		 jge	 SHORT $LN43@impl

; 839  :     {
; 840  :         display_version( stdout, 0, NULL );

  0020c	b9 01 00 00 00	 mov	 ecx, 1
  00211	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00217	45 33 c0	 xor	 r8d, r8d
  0021a	33 d2		 xor	 edx, edx
  0021c	48 8b c8	 mov	 rcx, rax
  0021f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_display_version

; 841  :         arghelp();

  00225	e8 00 00 00 00	 call	 arghelp

; 842  :         WRMSG( HHC02343, "S", 1 );

  0022a	b9 01 00 00 00	 mov	 ecx, 1
  0022f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00235	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR [rsp+56], 1
  0023d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169557
  00244	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00249	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169558
  00250	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00255	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0025a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00260	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169559
  00267	ba 4a 03 00 00	 mov	 edx, 842		; 0000034aH
  0026c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169560
  00273	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 843  :         return 1;

  00279	b8 01 00 00 00	 mov	 eax, 1
  0027e	e9 76 20 00 00	 jmp	 $LN1@impl
$LN43@impl:

; 844  :     }
; 845  : 
; 846  :     /* Initialize SETMODE and set user authority */
; 847  :     SETMODE( INIT );
; 848  : 
; 849  :     /* Remain compatible with older external gui versions */
; 850  :     if (argc >= 1 && strncmp( argv[argc-1], "EXTERNALGUI", 11 ) == 0)

  00283	83 bc 24 a0 01
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  0028b	7c 4b		 jl	 SHORT $LN44@impl
  0028d	8b 84 24 a0 01
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00294	ff c8		 dec	 eax
  00296	48 98		 cdqe
  00298	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0029e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169562
  002a5	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002ad	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  002b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  002b7	85 c0		 test	 eax, eax
  002b9	75 1d		 jne	 SHORT $LN44@impl

; 851  :     {
; 852  :         extgui = TRUE;

  002bb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  002c2	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 853  :         argc--;

  002c8	8b 84 24 a0 01
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  002cf	ff c8		 dec	 eax
  002d1	89 84 24 a0 01
	00 00		 mov	 DWORD PTR argc$[rsp], eax
$LN44@impl:

; 854  :     }
; 855  : 
; 856  :     /* Initialize Hercules Threading package */
; 857  :     hthreads_internal_init();

  002d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthreads_internal_init

; 858  : 
; 859  :     /* Initialize 'hostinfo' BEFORE display_version is called */
; 860  :     init_hostinfo( &hostinfo );

  002de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_hostinfo
  002e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_init_hostinfo
$LN13@impl:

; 861  : 
; 862  : #ifdef _MSVC_
; 863  :     /* Initialize sockets package */
; 864  :     VERIFY( socket_init() == 0 );

  002eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket_init
  002f1	85 c0		 test	 eax, eax
  002f3	74 5c		 je	 SHORT $LN45@impl
$LN16@impl:
  002f5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169564
  002fc	41 b8 60 03 00
	00		 mov	 r8d, 864		; 00000360H
  00302	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169565
  00309	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169566
  00310	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00316	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0031c	85 c0		 test	 eax, eax
  0031e	74 20		 je	 SHORT $LN46@impl
  00320	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169568
  00327	41 b8 60 03 00
	00		 mov	 r8d, 864		; 00000360H
  0032d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169569
  00334	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169570
  0033b	e8 00 00 00 00	 call	 DebuggerTrace
$LN46@impl:
  00340	33 c0		 xor	 eax, eax
  00342	85 c0		 test	 eax, eax
  00344	75 af		 jne	 SHORT $LN16@impl
  00346	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0034c	85 c0		 test	 eax, eax
  0034e	74 01		 je	 SHORT $LN47@impl
  00350	cc		 int	 3
$LN47@impl:
$LN45@impl:
  00351	33 c0		 xor	 eax, eax
  00353	85 c0		 test	 eax, eax
  00355	75 94		 jne	 SHORT $LN13@impl

; 865  : #endif
; 866  : 
; 867  :     /* Ensure hdl_atexit is called in case of shutdown.
; 868  :        hdl_atexit ensures entries are called only once.
; 869  :     */
; 870  :     atexit( hdl_atexit );

  00357	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_hdl_atexit
  0035e	e8 00 00 00 00	 call	 atexit

; 871  : 
; 872  :     set_symbol( "VERSION", VERSION);

  00363	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169572
  0036a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169573
  00371	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 873  :     set_symbol( "BDATE", __DATE__ );

  00377	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169574
  0037e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169575
  00385	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 874  :     set_symbol( "BTIME", __TIME__ );

  0038b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169576
  00392	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169577
  00399	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 875  : 
; 876  :     {
; 877  :         char num_procs[64];
; 878  : 
; 879  :         if ( hostinfo.num_packages     != 0 &&
; 880  :              hostinfo.num_physical_cpu != 0 &&

  0039f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  003a6	83 b8 c4 01 00
	00 00		 cmp	 DWORD PTR [rax+452], 0
  003ad	74 6f		 je	 SHORT $LN48@impl
  003af	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  003b6	83 b8 bc 01 00
	00 00		 cmp	 DWORD PTR [rax+444], 0
  003bd	74 5f		 je	 SHORT $LN48@impl
  003bf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  003c6	83 b8 c0 01 00
	00 00		 cmp	 DWORD PTR [rax+448], 0
  003cd	74 4f		 je	 SHORT $LN48@impl

; 881  :              hostinfo.num_logical_cpu  != 0 )
; 882  :         {
; 883  :             MSGBUF( num_procs, "LP=%d, Cores=%d, CPUs=%d", hostinfo.num_logical_cpu,

  003cf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  003d6	8b 80 c4 01 00
	00		 mov	 eax, DWORD PTR [rax+452]
  003dc	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  003e0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  003e7	8b 80 bc 01 00
	00		 mov	 eax, DWORD PTR [rax+444]
  003ed	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  003f1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  003f8	44 8b 88 c0 01
	00 00		 mov	 r9d, DWORD PTR [rax+448]
  003ff	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169580
  00406	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0040b	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR num_procs$14[rsp]
  00413	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 884  :                                 hostinfo.num_physical_cpu, hostinfo.num_packages );
; 885  :         }

  00419	e9 82 00 00 00	 jmp	 $LN49@impl
$LN48@impl:

; 886  :         else
; 887  :         {
; 888  :             if ( hostinfo.num_procs > 1 )

  0041e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  00425	83 b8 b8 01 00
	00 01		 cmp	 DWORD PTR [rax+440], 1
  0042c	7e 2a		 jle	 SHORT $LN50@impl

; 889  :                 MSGBUF( num_procs, "MP=%d", hostinfo.num_procs );

  0042e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  00435	44 8b 88 b8 01
	00 00		 mov	 r9d, DWORD PTR [rax+440]
  0043c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169583
  00443	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00448	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR num_procs$14[rsp]
  00450	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  00456	eb 48		 jmp	 SHORT $LN51@impl
$LN50@impl:

; 890  :             else if ( hostinfo.num_procs == 1 )

  00458	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  0045f	83 b8 b8 01 00
	00 01		 cmp	 DWORD PTR [rax+440], 1
  00466	75 1d		 jne	 SHORT $LN52@impl

; 891  :                 STRLCPY( num_procs, "UP" );

  00468	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  0046e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169586
  00475	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR num_procs$14[rsp]
  0047d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  00483	eb 1b		 jmp	 SHORT $LN53@impl
$LN52@impl:

; 892  :             else
; 893  :                 STRLCPY( num_procs, "" );

  00485	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  0048b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169587
  00492	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR num_procs$14[rsp]
  0049a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN53@impl:
$LN51@impl:
$LN49@impl:

; 894  :         }
; 895  : 
; 896  :         set_symbol( "HOSTNAME", hostinfo.nodename );

  004a0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  004a7	48 83 c0 70	 add	 rax, 112		; 00000070H
  004ab	48 8b d0	 mov	 rdx, rax
  004ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169588
  004b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 897  :         set_symbol( "HOSTOS", hostinfo.sysname );

  004bb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  004c2	48 83 c0 30	 add	 rax, 48			; 00000030H
  004c6	48 8b d0	 mov	 rdx, rax
  004c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169589
  004d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 898  :         set_symbol( "HOSTOSREL", hostinfo.release );

  004d6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  004dd	48 05 b0 00 00
	00		 add	 rax, 176		; 000000b0H
  004e3	48 8b d0	 mov	 rdx, rax
  004e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169590
  004ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 899  :         set_symbol( "HOSTOSVER", hostinfo.version );

  004f3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  004fa	48 05 f0 00 00
	00		 add	 rax, 240		; 000000f0H
  00500	48 8b d0	 mov	 rdx, rax
  00503	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169591
  0050a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 900  :         set_symbol( "HOSTARCH", hostinfo.machine );

  00510	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  00517	48 05 30 01 00
	00		 add	 rax, 304		; 00000130H
  0051d	48 8b d0	 mov	 rdx, rax
  00520	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169592
  00527	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 901  :         set_symbol( "HOSTNUMCPUS", num_procs );

  0052d	48 8d 94 24 40
	01 00 00	 lea	 rdx, QWORD PTR num_procs$14[rsp]
  00535	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169593
  0053c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 902  :     }
; 903  : 
; 904  :     set_symbol( "MODNAME", sysblk.hercules_pgmname );

  00542	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00549	48 8b 50 30	 mov	 rdx, QWORD PTR [rax+48]
  0054d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169594
  00554	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 905  :     set_symbol( "MODPATH", sysblk.hercules_pgmpath );

  0055a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00561	48 8b 50 38	 mov	 rdx, QWORD PTR [rax+56]
  00565	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169595
  0056c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 906  : 
; 907  :     sysblk.sysgroup = DEFAULT_SYSGROUP;

  00572	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00579	c6 80 2d 11 00
	00 7f		 mov	 BYTE PTR [rax+4397], 127 ; 0000007fH

; 908  : 
; 909  :     /* set default console port addresses */
; 910  :     sysblk.cnslport = strdup("3270");

  00580	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169596
  00587	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0058d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00594	48 89 81 e8 13
	00 00		 mov	 QWORD PTR [rcx+5096], rax

; 911  : 
; 912  :     /* Initialize automatic creation of missing tape file to default */
; 913  :     sysblk.auto_tape_create = DEF_AUTO_TAPE_CREATE;

  0059b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005a2	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  005a8	0f ba e8 13	 bts	 eax, 19
  005ac	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  005b3	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 914  : 
; 915  :     /* Default command separator is OFF (disabled) */
; 916  :     sysblk.cmdsep = 0;

  005b9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005c0	c6 80 2c 11 00
	00 00		 mov	 BYTE PTR [rax+4396], 0

; 917  : 
; 918  : #if defined(_FEATURE_SYSTEM_CONSOLE)
; 919  :     /* set default for scpecho to TRUE */
; 920  :     sysblk.scpecho = TRUE;

  005c7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005ce	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  005d4	83 c8 20	 or	 eax, 32			; 00000020H
  005d7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  005de	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 921  : 
; 922  :     /* set fault for scpimply to FALSE */
; 923  :     sysblk.scpimply = FALSE;

  005e4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005eb	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  005f1	83 e0 bf	 and	 eax, -65		; ffffffbfH
  005f4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  005fb	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 924  : #endif
; 925  : 
; 926  :     /* set default system state to reset */
; 927  :     sysblk.sys_reset = TRUE;

  00601	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00608	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0060e	83 c8 01	 or	 eax, 1
  00611	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00618	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 928  : 
; 929  :     /* Set default SHCMDOPT to DISABLE NODIAG8 */
; 930  :     sysblk.shcmdopt = 0;

  0061e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00625	c6 80 2f 11 00
	00 00		 mov	 BYTE PTR [rax+4399], 0

; 931  : 
; 932  :     /* Save process ID */
; 933  :     sysblk.hercules_pid = getpid();

  0062c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getpid
  00632	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00639	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 934  : 
; 935  :     /* Save thread ID of main program */
; 936  :     sysblk.impltid = thread_id();

  0063c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00642	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00649	89 81 d8 00 00
	00		 mov	 DWORD PTR [rcx+216], eax

; 937  : 
; 938  :     /* Save TOD of when we were first IMPL'ed */
; 939  :     time( &sysblk.impltime );

  0064f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00656	48 83 c0 70	 add	 rax, 112		; 00000070H
  0065a	48 8b c8	 mov	 rcx, rax
  0065d	e8 00 00 00 00	 call	 time

; 940  : 
; 941  :     /* Set to LPAR mode with LPAR 1, LPAR ID of 01, and CPUIDFMT 0   */
; 942  :     sysblk.lparmode = 1;                /* LPARNUM 1    # LPAR ID 01 */

  00662	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00669	8b 80 ec 00 00
	00		 mov	 eax, DWORD PTR [rax+236]
  0066f	83 c8 01	 or	 eax, 1
  00672	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00679	89 81 ec 00 00
	00		 mov	 DWORD PTR [rcx+236], eax

; 943  :     sysblk.lparnum  = 1;                /* ...                       */

  0067f	b8 01 00 00 00	 mov	 eax, 1
  00684	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0068b	66 89 81 f0 00
	00 00		 mov	 WORD PTR [rcx+240], ax

; 944  :     sysblk.cpuidfmt = 0;                /* CPUIDFMT 0                */

  00692	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00699	c6 80 d7 00 00
	00 00		 mov	 BYTE PTR [rax+215], 0

; 945  :     sysblk.operation_mode = om_mif;     /* Default to MIF operaitons */

  006a0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006a7	c7 80 e8 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+232], 1

; 946  : 
; 947  :     /* set default CPU identifier */
; 948  :     sysblk.cpumodel = 0x0586;

  006b1	b8 86 05 00 00	 mov	 eax, 1414		; 00000586H
  006b6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006bd	66 89 81 d4 00
	00 00		 mov	 WORD PTR [rcx+212], ax

; 949  :     sysblk.cpuversion = 0xFD;

  006c4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006cb	c6 80 d6 00 00
	00 fd		 mov	 BYTE PTR [rax+214], 253	; 000000fdH

; 950  :     sysblk.cpuserial = 0x000001;

  006d2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006d9	c7 80 d0 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+208], 1

; 951  :     sysblk.cpuid = createCpuId( sysblk.cpumodel, sysblk.cpuversion,

  006e3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006ea	8b 80 d0 00 00
	00		 mov	 eax, DWORD PTR [rax+208]
  006f0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006f7	0f b6 89 d6 00
	00 00		 movzx	 ecx, BYTE PTR [rcx+214]
  006fe	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00705	0f b7 92 d4 00
	00 00		 movzx	 edx, WORD PTR [rdx+212]
  0070c	48 89 94 24 b0
	00 00 00	 mov	 QWORD PTR tv370[rsp], rdx
  00714	45 33 c9	 xor	 r9d, r9d
  00717	44 8b c0	 mov	 r8d, eax
  0071a	8b d1		 mov	 edx, ecx
  0071c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv370[rsp]
  00724	48 8b c8	 mov	 rcx, rax
  00727	e8 00 00 00 00	 call	 createCpuId
  0072c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00733	48 89 81 c8 00
	00 00		 mov	 QWORD PTR [rcx+200], rax

; 952  :                                 sysblk.cpuserial, 0 );
; 953  : 
; 954  :     sysblk.panrate = PANEL_REFRESH_RATE_SLOW;

  0073a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00741	c7 80 30 11 00
	00 f4 01 00 00	 mov	 DWORD PTR [rax+4400], 500 ; 000001f4H

; 955  : 
; 956  :     /* set default Program Interrupt Trace */
; 957  :     sysblk.pgminttr = OS_DEFAULT;

  0074b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00752	48 b9 ff 7f de
	f7 ff ff ff 7f	 mov	 rcx, 9223372036718362623 ; 7ffffffff7de7fffH
  0075c	48 89 88 48 13
	00 00		 mov	 QWORD PTR [rax+4936], rcx

; 958  :     sysblk.ostailor = OSTAILOR_DEFAULT;

  00763	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0076a	c7 80 50 13 00
	00 00 00 00 20	 mov	 DWORD PTR [rax+4944], 536870912 ; 20000000H

; 959  : 
; 960  :     sysblk.timerint = DEF_TOD_UPDATE_USECS;

  00774	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0077b	c7 80 60 11 00
	00 32 00 00 00	 mov	 DWORD PTR [rax+4448], 50 ; 00000032H

; 961  : 
; 962  : #if defined( _FEATURE_073_TRANSACT_EXEC_FACILITY )
; 963  :     sysblk.txf_timerint = sysblk.timerint;

  00785	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0078c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00793	8b 89 60 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4448]
  00799	89 88 74 05 00
	00		 mov	 DWORD PTR [rax+1396], ecx

; 964  : #endif
; 965  : 
; 966  : #if defined( _FEATURE_ECPSVM )
; 967  :     sysblk.ecpsvm.available = 0;

  0079f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007a6	8b 80 44 13 00
	00		 mov	 eax, DWORD PTR [rax+4932]
  007ac	0f ba f0 11	 btr	 eax, 17
  007b0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  007b7	89 81 44 13 00
	00		 mov	 DWORD PTR [rcx+4932], eax

; 968  :     sysblk.ecpsvm.level = 20;

  007bd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007c4	8b 80 44 13 00
	00		 mov	 eax, DWORD PTR [rax+4932]
  007ca	25 00 00 ff ff	 and	 eax, -65536		; ffff0000H
  007cf	83 c8 14	 or	 eax, 20
  007d2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  007d9	89 81 44 13 00
	00		 mov	 DWORD PTR [rcx+4932], eax

; 969  : #endif
; 970  : 
; 971  : #if defined( OPTION_SHARED_DEVICES )
; 972  :     sysblk.shrdport = 0;

  007df	33 c0		 xor	 eax, eax
  007e1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  007e8	66 89 81 ac 13
	00 00		 mov	 WORD PTR [rcx+5036], ax

; 973  : #endif
; 974  : 
; 975  :     /* setup defaults for CONFIG symbols  */
; 976  :     {
; 977  :         char buf[8];
; 978  : 
; 979  :         set_symbol( "LPARNAME", str_lparname());

  007ef	e8 00 00 00 00	 call	 str_lparname
  007f4	48 8b d0	 mov	 rdx, rax
  007f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169597
  007fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 980  :         set_symbol( "LPARNUM",  "1" );

  00804	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169598
  0080b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169599
  00812	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 981  :         set_symbol( "CPUIDFMT", "0" );

  00818	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169600
  0081f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169601
  00826	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 982  : 
; 983  :         MSGBUF( buf, "%06X", sysblk.cpuserial );

  0082c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00833	44 8b 88 d0 00
	00 00		 mov	 r9d, DWORD PTR [rax+208]
  0083a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169602
  00841	ba 08 00 00 00	 mov	 edx, 8
  00846	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR buf$12[rsp]
  0084e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 984  :         set_symbol( "CPUSERIAL", buf );

  00854	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR buf$12[rsp]
  0085c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169603
  00863	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 985  : 
; 986  :         MSGBUF( buf, "%04X", sysblk.cpumodel );

  00869	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00870	0f b7 80 d4 00
	00 00		 movzx	 eax, WORD PTR [rax+212]
  00877	44 8b c8	 mov	 r9d, eax
  0087a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169604
  00881	ba 08 00 00 00	 mov	 edx, 8
  00886	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR buf$12[rsp]
  0088e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 987  :         set_symbol( "CPUMODEL", buf );

  00894	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR buf$12[rsp]
  0089c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169605
  008a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 988  : 
; 989  : #if defined( _FEATURE_073_TRANSACT_EXEC_FACILITY )
; 990  :         defsym_TXF_models();

  008a9	e8 00 00 00 00	 call	 defsym_TXF_models

; 991  : #endif
; 992  :     }
; 993  : 
; 994  : #if defined( _FEATURE_047_CMPSC_ENH_FACILITY )
; 995  :     sysblk.zpbits  = DEF_CMPSC_ZP_BITS;

  008ae	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  008b5	c6 80 99 0e 00
	00 08		 mov	 BYTE PTR [rax+3737], 8

; 996  : #endif
; 997  : 
; 998  :     /* Initialize Trace File helper function pointers */ 
; 999  :     sysblk.s370_gsk = &s370_get_storage_key;

  008bc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  008c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:s370_get_storage_key
  008ca	48 89 88 40 14
	00 00		 mov	 QWORD PTR [rax+5184], rcx

; 1000 :     sysblk.s390_gsk = &s390_get_storage_key;

  008d1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  008d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:s390_get_storage_key
  008df	48 89 88 48 14
	00 00		 mov	 QWORD PTR [rax+5192], rcx

; 1001 :     sysblk.z900_gsk = &z900_get_storage_key;

  008e6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  008ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:z900_get_storage_key
  008f4	48 89 88 50 14
	00 00		 mov	 QWORD PTR [rax+5200], rcx

; 1002 : 
; 1003 :     sysblk.s370_vtr = &s370_virt_to_real;

  008fb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00902	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:s370_virt_to_real
  00909	48 89 88 58 14
	00 00		 mov	 QWORD PTR [rax+5208], rcx

; 1004 :     sysblk.s390_vtr = &s390_virt_to_real;

  00910	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00917	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:s390_virt_to_real
  0091e	48 89 88 60 14
	00 00		 mov	 QWORD PTR [rax+5216], rcx

; 1005 :     sysblk.z900_vtr = &z900_virt_to_real;

  00925	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0092c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:z900_virt_to_real
  00933	48 89 88 68 14
	00 00		 mov	 QWORD PTR [rax+5224], rcx

; 1006 : 
; 1007 :     sysblk.s370_sit = &s370_store_int_timer;

  0093a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00941	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:s370_store_int_timer
  00948	48 89 88 70 14
	00 00		 mov	 QWORD PTR [rax+5232], rcx

; 1008 :     sysblk.gct      = &get_cpu_timer;

  0094f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00956	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:get_cpu_timer
  0095d	48 89 88 78 14
	00 00		 mov	 QWORD PTR [rax+5240], rcx

; 1009 : 
; 1010 :     /* Initialize locks, conditions, and attributes */
; 1011 :     initialize_lock( &sysblk.tracefileLock );

  00964	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0096b	48 05 10 14 00
	00		 add	 rax, 5136		; 00001410H
  00971	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169606
  00978	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169607
  0097f	48 8b c8	 mov	 rcx, rax
  00982	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 1012 :     initialize_lock( &sysblk.bindlock );

  00988	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0098f	48 83 c0 78	 add	 rax, 120		; 00000078H
  00993	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169608
  0099a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169609
  009a1	48 8b c8	 mov	 rcx, rax
  009a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 1013 :     initialize_lock( &sysblk.config   );

  009aa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  009b1	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  009b7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169610
  009be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169611
  009c5	48 8b c8	 mov	 rcx, rax
  009c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 1014 :     initialize_lock( &sysblk.todlock  );

  009ce	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  009d5	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  009db	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169612
  009e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169613
  009e9	48 8b c8	 mov	 rcx, rax
  009ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 1015 :     initialize_lock( &sysblk.mainlock );

  009f2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  009f9	48 05 68 10 00
	00		 add	 rax, 4200		; 00001068H
  009ff	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169614
  00a06	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169615
  00a0d	48 8b c8	 mov	 rcx, rax
  00a10	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 1016 :     initialize_lock( &sysblk.intlock  );

  00a16	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a1d	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00a23	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169616
  00a2a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169617
  00a31	48 8b c8	 mov	 rcx, rax
  00a34	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 1017 :     initialize_lock( &sysblk.iointqlk );

  00a3a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a41	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  00a47	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169618
  00a4e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169619
  00a55	48 8b c8	 mov	 rcx, rax
  00a58	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 1018 :     initialize_lock( &sysblk.sigplock );

  00a5e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a65	48 05 80 10 00
	00		 add	 rax, 4224		; 00001080H
  00a6b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169620
  00a72	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169621
  00a79	48 8b c8	 mov	 rcx, rax
  00a7c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 1019 :     initialize_lock( &sysblk.scrlock  );

  00a82	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a89	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  00a8f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169622
  00a96	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169623
  00a9d	48 8b c8	 mov	 rcx, rax
  00aa0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 1020 :     initialize_lock( &sysblk.crwlock  );

  00aa6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00aad	48 05 08 12 00
	00		 add	 rax, 4616		; 00001208H
  00ab3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169624
  00aba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169625
  00ac1	48 8b c8	 mov	 rcx, rax
  00ac4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 1021 :     initialize_lock( &sysblk.ioqlock  );

  00aca	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00ad1	48 05 38 12 00
	00		 add	 rax, 4664		; 00001238H
  00ad7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169626
  00ade	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169627
  00ae5	48 8b c8	 mov	 rcx, rax
  00ae8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 1022 :     initialize_lock( &sysblk.dasdcache_lock );

  00aee	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00af5	48 05 f8 11 00
	00		 add	 rax, 4600		; 000011f8H
  00afb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169628
  00b02	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169629
  00b09	48 8b c8	 mov	 rcx, rax
  00b0c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 1023 : #if defined( _FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1024 :     initialize_lock( &sysblk.rublock );

  00b12	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b19	48 05 68 05 00
	00		 add	 rax, 1384		; 00000568H
  00b1f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169630
  00b26	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169631
  00b2d	48 8b c8	 mov	 rcx, rax
  00b30	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 1025 : #endif
; 1026 : 
; 1027 :     initialize_condition( &sysblk.scrcond );

  00b36	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b3d	48 05 10 11 00
	00		 add	 rax, 4368		; 00001110H
  00b43	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169632
  00b4a	48 8b c8	 mov	 rcx, rax
  00b4d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 1028 :     initialize_condition( &sysblk.ioqcond );

  00b53	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b5a	48 05 40 12 00
	00		 add	 rax, 4672		; 00001240H
  00b60	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169633
  00b67	48 8b c8	 mov	 rcx, rax
  00b6a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 1029 : 
; 1030 : #if defined( OPTION_SHARED_DEVICES )
; 1031 :     initialize_lock( &sysblk.shrdlock );

  00b70	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b77	48 05 98 13 00
	00		 add	 rax, 5016		; 00001398H
  00b7d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169634
  00b84	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169635
  00b8b	48 8b c8	 mov	 rcx, rax
  00b8e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 1032 :     initialize_condition( &sysblk.shrdcond );

  00b94	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b9b	48 05 a0 13 00
	00		 add	 rax, 5024		; 000013a0H
  00ba1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169636
  00ba8	48 8b c8	 mov	 rcx, rax
  00bab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 1033 :     initialize_lock( &sysblk.shrdtracelock );

  00bb1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00bb8	48 05 b8 13 00
	00		 add	 rax, 5048		; 000013b8H
  00bbe	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169637
  00bc5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169638
  00bcc	48 8b c8	 mov	 rcx, rax
  00bcf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 1034 : #endif
; 1035 : 
; 1036 :     sysblk.mainowner = LOCK_OWNER_NONE;

  00bd5	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00bda	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00be1	66 89 81 60 10
	00 00		 mov	 WORD PTR [rcx+4192], ax

; 1037 :     sysblk.intowner  = LOCK_OWNER_NONE;

  00be8	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00bed	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00bf4	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 1038 : 
; 1039 :     /* Initialize thread creation attributes so all of hercules
; 1040 :        can use them at any time when they need to create_thread
; 1041 :     */
; 1042 :     initialize_detach_attr( DETACHED );

  00bfb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00c02	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  00c08	48 8b c8	 mov	 rcx, rax
  00c0b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_detach_attr

; 1043 :     initialize_join_attr( JOINABLE );

  00c11	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00c18	48 05 98 10 00
	00		 add	 rax, 4248		; 00001098H
  00c1e	48 8b c8	 mov	 rcx, rax
  00c21	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_join_attr

; 1044 : 
; 1045 :     /* Initialize CPU ENGINES locks and conditions */
; 1046 :     initialize_condition( &sysblk.cpucond );

  00c27	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00c2e	48 05 40 01 00
	00		 add	 rax, 320		; 00000140H
  00c34	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169639
  00c3b	48 8b c8	 mov	 rcx, rax
  00c3e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 1047 :     {
; 1048 :         int i; char buf[32];
; 1049 :         for (i=0; i < MAX_CPU_ENGS; i++)

  00c44	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  00c4c	eb 0a		 jmp	 SHORT $LN19@impl
$LN17@impl:
  00c4e	8b 44 24 58	 mov	 eax, DWORD PTR i$2[rsp]
  00c52	ff c0		 inc	 eax
  00c54	89 44 24 58	 mov	 DWORD PTR i$2[rsp], eax
$LN19@impl:
  00c58	83 7c 24 58 40	 cmp	 DWORD PTR i$2[rsp], 64	; 00000040H
  00c5d	0f 8d f5 00 00
	00		 jge	 $LN18@impl

; 1050 :         {
; 1051 :             MSGBUF( buf,    "&sysblk.cpulock[%*d]", MAX_CPU_ENGS > 99 ? 3 : 2, i );

  00c63	8b 44 24 58	 mov	 eax, DWORD PTR i$2[rsp]
  00c67	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00c6b	41 b9 02 00 00
	00		 mov	 r9d, 2
  00c71	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169640
  00c78	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00c7d	48 8d 8c 24 18
	01 00 00	 lea	 rcx, QWORD PTR buf$13[rsp]
  00c85	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1052 :             initialize_lock( &sysblk.cpulock[i] );

  00c8b	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$2[rsp]
  00c90	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00c97	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  00c9f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169641
  00ca6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169642
  00cad	48 8b c8	 mov	 rcx, rax
  00cb0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 1053 :             set_lock_name(   &sysblk.cpulock[i], buf );

  00cb6	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$2[rsp]
  00cbb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00cc2	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  00cca	48 8d 94 24 18
	01 00 00	 lea	 rdx, QWORD PTR buf$13[rsp]
  00cd2	48 8b c8	 mov	 rcx, rax
  00cd5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_lock_name

; 1054 : 
; 1055 : #if defined( _FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1056 :             MSGBUF( buf,    "&sysblk.txf_lock[%*d]", MAX_CPU_ENGS > 99 ? 3 : 2, i );

  00cdb	8b 44 24 58	 mov	 eax, DWORD PTR i$2[rsp]
  00cdf	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00ce3	41 b9 02 00 00
	00		 mov	 r9d, 2
  00ce9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169643
  00cf0	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00cf5	48 8d 8c 24 18
	01 00 00	 lea	 rcx, QWORD PTR buf$13[rsp]
  00cfd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1057 :             initialize_lock( &sysblk.txf_lock[i] );

  00d03	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$2[rsp]
  00d08	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00d0f	48 8d 84 c1 48
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+840]
  00d17	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169644
  00d1e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169645
  00d25	48 8b c8	 mov	 rcx, rax
  00d28	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 1058 :             set_lock_name(   &sysblk.txf_lock[i], buf );

  00d2e	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$2[rsp]
  00d33	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00d3a	48 8d 84 c1 48
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+840]
  00d42	48 8d 94 24 18
	01 00 00	 lea	 rdx, QWORD PTR buf$13[rsp]
  00d4a	48 8b c8	 mov	 rcx, rax
  00d4d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_lock_name

; 1059 : #endif
; 1060 :         }

  00d53	e9 f6 fe ff ff	 jmp	 $LN17@impl
$LN18@impl:

; 1061 :     }
; 1062 :     initialize_condition( &sysblk.all_synced_cond );

  00d58	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00d5f	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00d65	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169646
  00d6c	48 8b c8	 mov	 rcx, rax
  00d6f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 1063 :     initialize_condition( &sysblk.sync_done_cond );

  00d75	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00d7c	48 05 90 13 00
	00		 add	 rax, 5008		; 00001390H
  00d82	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169647
  00d89	48 8b c8	 mov	 rcx, rax
  00d8c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 1064 : 
; 1065 :     /* Copy length for regs */
; 1066 :     sysblk.regs_copy_len = (int)((uintptr_t)&sysblk.dummyregs.regs_copy_end

  00d92	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00d99	48 05 c0 c4 00
	00		 add	 rax, 50368		; 0000c4c0H
  00d9f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00da6	48 81 c1 00 15
	00 00		 add	 rcx, 5376		; 00001500H
  00dad	48 2b c1	 sub	 rax, rcx
  00db0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00db7	89 81 90 14 00
	00		 mov	 DWORD PTR [rcx+5264], eax

; 1067 :                                - (uintptr_t)&sysblk.dummyregs);
; 1068 : 
; 1069 :     /* Set the daemon_mode flag indicating whether we running in
; 1070 :        background/daemon mode or not (meaning both stdout/stderr
; 1071 :        are redirected to a non-tty device). Note that this flag
; 1072 :        needs to be set before logger_init gets called since the
; 1073 :        logger_logfile_write function relies on its setting.
; 1074 :     */
; 1075 :     if (!isatty(STDERR_FILENO) && !isatty(STDOUT_FILENO))

  00dbd	b9 02 00 00 00	 mov	 ecx, 2
  00dc2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isatty
  00dc8	85 c0		 test	 eax, eax
  00dca	75 2c		 jne	 SHORT $LN54@impl
  00dcc	b9 01 00 00 00	 mov	 ecx, 1
  00dd1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isatty
  00dd7	85 c0		 test	 eax, eax
  00dd9	75 1d		 jne	 SHORT $LN54@impl

; 1076 :         sysblk.daemon_mode = 1;       /* Leave -d intact */

  00ddb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00de2	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00de8	83 c8 04	 or	 eax, 4
  00deb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00df2	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
$LN54@impl:

; 1077 : 
; 1078 :     /* Initialize panel colors */
; 1079 :     set_panel_colors();

  00df8	e8 00 00 00 00	 call	 set_panel_colors

; 1080 : 
; 1081 :     /* Initialize the logmsg pipe and associated logger thread.
; 1082 :        This causes all subsequent logmsg's to be redirected to
; 1083 :        the logger facility for handling by virtue of stdout/stderr
; 1084 :        being redirected to the logger facility.
; 1085 : 
; 1086 :        NOTE that the logger facility must ALWAYS be initialized
; 1087 :        since other threads depend on it to be able to retrieve
; 1088 :        log messages. This is true regardless of whether or not
; 1089 :        the log messages are being redirected to a hardcopy file.
; 1090 : 
; 1091 :        The HAO thread (Hercules Automatic Operator) for example
; 1092 :        becomes essentially useless if it's unable to retrieve
; 1093 :        log messages to see whether they match any of its rules.
; 1094 :     */
; 1095 :     logger_init();

  00dfd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logger_init

; 1096 : 
; 1097 :     /* Setup the default codepage */
; 1098 :     set_codepage( NULL );

  00e03	33 c9		 xor	 ecx, ecx
  00e05	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_codepage

; 1099 : 
; 1100 :     /* Initialize default HDL modules load directory */
; 1101 :     hdl_initpath( NULL );

  00e0b	33 c9		 xor	 ecx, ecx
  00e0d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hdl_initpath

; 1102 : 
; 1103 :     /* Cap the default nice value to zero if setuid is not available */
; 1104 : #if !defined( _MSVC_ )
; 1105 :   #if !defined( NO_SETUID )
; 1106 :     if (sysblk.suid)
; 1107 :   #endif
; 1108 :     {
; 1109 :         if (sysblk.hercnice < 0)
; 1110 :             sysblk.hercnice = 0;
; 1111 :     }
; 1112 : #endif
; 1113 : 
; 1114 :     /* Initialize default thread priorities */
; 1115 :     sysblk.cpuprio  = DEFAULT_CPU_PRIO;  /* (lowest)  */

  00e13	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00e1a	c7 80 6c 13 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+4972], 2

; 1116 :     sysblk.devprio  = DEFAULT_DEV_PRIO;  /*     |     */

  00e24	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00e2b	c7 80 70 13 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+4976], 3

; 1117 :     sysblk.srvprio  = DEFAULT_SRV_PRIO;  /*     |     */

  00e35	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00e3c	c7 80 74 13 00
	00 04 00 00 00	 mov	 DWORD PTR [rax+4980], 4

; 1118 :     sysblk.hercprio = DEFAULT_HERC_PRIO  /*     V     */;

  00e46	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00e4d	c7 80 64 13 00
	00 05 00 00 00	 mov	 DWORD PTR [rax+4964], 5

; 1119 :     sysblk.todprio  = DEFAULT_TOD_PRIO;  /* (highest) */

  00e57	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00e5e	c7 80 68 13 00
	00 07 00 00 00	 mov	 DWORD PTR [rax+4968], 7

; 1120 : 
; 1121 :     /* Set the priority of the main Hercules thread */
; 1122 :     if ((rc = set_thread_priority( sysblk.hercprio )) != 0)

  00e68	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00e6e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169650
  00e75	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00e7c	8b 91 64 13 00
	00		 mov	 edx, DWORD PTR [rcx+4964]
  00e82	8b c8		 mov	 ecx, eax
  00e84	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_thread_prio
  00e8a	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  00e8e	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00e93	0f 84 51 01 00
	00		 je	 $LN55@impl

; 1123 :     {
; 1124 :         // "set_thread_priority( %d ) failed: %s"
; 1125 :         WRMSG( HHC00109, "E", sysblk.hercprio, strerror( rc ));

  00e99	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  00e9d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00ea3	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv599[rsp], rax
  00eab	b9 01 00 00 00	 mov	 ecx, 1
  00eb0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00eb6	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv599[rsp]
  00ebe	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00ec3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00eca	8b 89 64 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4964]
  00ed0	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00ed4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169651
  00edb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00ee0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169652
  00ee7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00eec	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ef1	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ef7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169653
  00efe	ba 65 04 00 00	 mov	 edx, 1125		; 00000465H
  00f03	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169654
  00f0a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1126 : 
; 1127 :         // "Defaulting all threads to priority %d"
; 1128 :         WRMSG( HHC00110, "W", sysblk.minprio );

  00f10	b9 01 00 00 00	 mov	 ecx, 1
  00f15	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00f1b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00f22	8b 89 5c 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4956]
  00f28	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00f2c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169655
  00f33	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00f38	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169656
  00f3f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00f44	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f49	41 b9 03 00 00
	00		 mov	 r9d, 3
  00f4f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169657
  00f56	ba 68 04 00 00	 mov	 edx, 1128		; 00000468H
  00f5b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169658
  00f62	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1129 : 
; 1130 :         sysblk.cpuprio  = sysblk.minprio;  /* (lowest)  */

  00f68	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00f6f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00f76	8b 89 5c 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4956]
  00f7c	89 88 6c 13 00
	00		 mov	 DWORD PTR [rax+4972], ecx

; 1131 :         sysblk.devprio  = sysblk.minprio;  /*     |     */

  00f82	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00f89	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00f90	8b 89 5c 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4956]
  00f96	89 88 70 13 00
	00		 mov	 DWORD PTR [rax+4976], ecx

; 1132 :         sysblk.srvprio  = sysblk.minprio;  /*     |     */

  00f9c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00fa3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00faa	8b 89 5c 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4956]
  00fb0	89 88 74 13 00
	00		 mov	 DWORD PTR [rax+4980], ecx

; 1133 :         sysblk.hercprio = sysblk.minprio;  /*     V     */

  00fb6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00fbd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00fc4	8b 89 5c 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4956]
  00fca	89 88 64 13 00
	00		 mov	 DWORD PTR [rax+4964], ecx

; 1134 :         sysblk.todprio  = sysblk.minprio;  /* (highest) */

  00fd0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00fd7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00fde	8b 89 5c 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4956]
  00fe4	89 88 68 13 00
	00		 mov	 DWORD PTR [rax+4968], ecx
$LN55@impl:

; 1135 :     }
; 1136 : 
; 1137 :     /* PROGRAMMING NOTE: we defer setting thread priorities until AFTER
; 1138 :        the sysblk's default thread priority fields have been properly
; 1139 :        initialized, just as we also defer logging any thread started
; 1140 :        messages until after the logger has been initialized, since it
; 1141 :        is the logger that processes all WRMSG() calls.
; 1142 :     */
; 1143 :     /* Log our own thread started message (better late than never) */
; 1144 :     LOG_THREAD_BEGIN( IMPL_THREAD_NAME  );

  00fea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00ff0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169660
  00ff7	8b c8		 mov	 ecx, eax
  00ff9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  00fff	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv667[rsp], eax
  01006	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  0100c	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv704[rsp], eax
  01013	b9 01 00 00 00	 mov	 ecx, 1
  01018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0101e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169659
  01025	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0102a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv667[rsp]
  01031	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01035	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv704[rsp]
  0103c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169661
  01047	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0104c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169662
  01053	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01058	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0105d	41 b9 03 00 00
	00		 mov	 r9d, 3
  01063	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169663
  0106a	ba 78 04 00 00	 mov	 edx, 1144		; 00000478H
  0106f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169664
  01076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1145 : 
; 1146 :     /* Set the priority of the logger thread and log its started msg */
; 1147 :     set_thread_priority_id( sysblk.loggertid, sysblk.srvprio );

  0107c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169665
  01083	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0108a	8b 90 74 13 00
	00		 mov	 edx, DWORD PTR [rax+4980]
  01090	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01097	8b 88 dc 00 00
	00		 mov	 ecx, DWORD PTR [rax+220]
  0109d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_thread_prio

; 1148 :     LOG_TID_BEGIN( sysblk.loggertid, LOGGER_THREAD_NAME );

  010a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169667
  010aa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  010b1	8b 88 dc 00 00
	00		 mov	 ecx, DWORD PTR [rax+220]
  010b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  010bd	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv721[rsp], eax
  010c4	b9 01 00 00 00	 mov	 ecx, 1
  010c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  010cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169666
  010d6	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  010db	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv721[rsp]
  010e2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  010e6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  010ed	8b 89 dc 00 00
	00		 mov	 ecx, DWORD PTR [rcx+220]
  010f3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  010f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169668
  010fe	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01103	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169669
  0110a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0110f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01114	41 b9 03 00 00
	00		 mov	 r9d, 3
  0111a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169670
  01121	ba 7c 04 00 00	 mov	 edx, 1148		; 0000047cH
  01126	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169671
  0112d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1149 : 
; 1150 :     /* Process command-line arguments. Exit if any serious errors. */
; 1151 :     if ((rc = process_args( argc, argv )) != 0)

  01133	48 8b 94 24 a8
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0113b	8b 8c 24 a0 01
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  01142	e8 00 00 00 00	 call	 process_args
  01147	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  0114b	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  01150	74 61		 je	 SHORT $LN56@impl

; 1152 :     {
; 1153 :         // "Terminating due to %d argument errors"
; 1154 :         WRMSG( HHC02343, "S", rc );

  01152	b9 01 00 00 00	 mov	 ecx, 1
  01157	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0115d	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  01161	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01165	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169673
  0116c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01171	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169674
  01178	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0117d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01182	41 b9 03 00 00
	00		 mov	 r9d, 3
  01188	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169675
  0118f	ba 82 04 00 00	 mov	 edx, 1154		; 00000482H
  01194	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169676
  0119b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1155 :         delayed_exit( rc );

  011a1	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  011a5	e8 00 00 00 00	 call	 delayed_exit

; 1156 :         return rc;

  011aa	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
  011ae	e9 46 11 00 00	 jmp	 $LN1@impl
$LN56@impl:

; 1157 :     }
; 1158 : 
; 1159 :     /* Now display the version information again after logger_init
; 1160 :        has been called so that either the panel display thread or the
; 1161 :        external gui can see the version which was previously possibly
; 1162 :        only displayed to the actual physical screen the first time we
; 1163 :        did it further above (depending on whether we're running in
; 1164 :        daemon_mode (external gui mode) or not). This is the call that
; 1165 :        the panel thread or external gui actually "sees".
; 1166 : 
; 1167 :        The first call further above wasn't seen by either since it
; 1168 :        was issued before logger_init was called and thus got written
; 1169 :        directly to the physical screen whereas this one will be inter-
; 1170 :        cepted and handled by the logger facility thereby allowing the
; 1171 :        panel thread or external gui to "see" it and thus display it.
; 1172 :     */
; 1173 :     display_version       ( stdout, 0, NULL );

  011b3	b9 01 00 00 00	 mov	 ecx, 1
  011b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  011be	45 33 c0	 xor	 r8d, r8d
  011c1	33 d2		 xor	 edx, edx
  011c3	48 8b c8	 mov	 rcx, rax
  011c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_display_version

; 1174 :     display_build_options ( stdout, 0 );

  011cc	b9 01 00 00 00	 mov	 ecx, 1
  011d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  011d7	33 d2		 xor	 edx, edx
  011d9	48 8b c8	 mov	 rcx, rax
  011dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_display_build_options

; 1175 :     display_extpkg_vers   ( stdout, 0 );

  011e2	b9 01 00 00 00	 mov	 ecx, 1
  011e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  011ed	33 d2		 xor	 edx, edx
  011ef	48 8b c8	 mov	 rcx, rax
  011f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_display_extpkg_vers

; 1176 : 
; 1177 :     /* Warn if crash dumps aren't enabled */
; 1178 : #if !defined( _MSVC_ )
; 1179 :     {
; 1180 :         struct rlimit  core_limit;
; 1181 :         if (getrlimit( RLIMIT_CORE, &core_limit ) == 0)
; 1182 :             sysblk.ulimit_unlimited = (RLIM_INFINITY == core_limit.rlim_cur);
; 1183 :         if (!sysblk.ulimit_unlimited)
; 1184 :             // "Crash dumps NOT enabled"
; 1185 :             WRMSG( HHC00017, "W" );
; 1186 :     }
; 1187 : #endif
; 1188 : 
; 1189 :     /* Report whether Hercules is running in "elevated" mode or not */
; 1190 :     // HHC00018 "Hercules is %srunning in elevated mode"
; 1191 :     if (are_elevated())

  011f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_are_elevated
  011fe	0f b6 c0	 movzx	 eax, al
  01201	85 c0		 test	 eax, eax
  01203	74 55		 je	 SHORT $LN57@impl

; 1192 :         WRMSG( HHC00018, "I", "" );

  01205	b9 01 00 00 00	 mov	 ecx, 1
  0120a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01210	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169679
  01217	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0121c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169680
  01223	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01228	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169681
  0122f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01234	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01239	41 b9 03 00 00
	00		 mov	 r9d, 3
  0123f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169682
  01246	ba a8 04 00 00	 mov	 edx, 1192		; 000004a8H
  0124b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169683
  01252	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  01258	eb 53		 jmp	 SHORT $LN58@impl
$LN57@impl:

; 1193 :     else
; 1194 :         WRMSG( HHC00018, "W", "NOT " );

  0125a	b9 01 00 00 00	 mov	 ecx, 1
  0125f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01265	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169684
  0126c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01271	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169685
  01278	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0127d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169686
  01284	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01289	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0128e	41 b9 03 00 00
	00		 mov	 r9d, 3
  01294	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169687
  0129b	ba aa 04 00 00	 mov	 edx, 1194		; 000004aaH
  012a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169688
  012a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN58@impl:

; 1195 : 
; 1196 : #if !defined(WIN32) && !defined(HAVE_STRERROR_R)
; 1197 :     strerror_r_init();
; 1198 : #endif
; 1199 : 
; 1200 : #if defined(OPTION_SCSI_TAPE)
; 1201 :     initialize_lock      ( &sysblk.stape_lock         );

  012ad	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  012b4	48 05 70 11 00
	00		 add	 rax, 4464		; 00001170H
  012ba	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169689
  012c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169690
  012c8	48 8b c8	 mov	 rcx, rax
  012cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 1202 :     initialize_condition ( &sysblk.stape_getstat_cond );

  012d1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  012d8	48 05 88 11 00
	00		 add	 rax, 4488		; 00001188H
  012de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169691
  012e5	48 8b c8	 mov	 rcx, rax
  012e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 1203 :     InitializeListHead   ( &sysblk.stape_mount_link   );

  012ee	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  012f5	48 05 a8 11 00
	00		 add	 rax, 4520		; 000011a8H
  012fb	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv797[rsp], rax
  01303	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0130a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv797[rsp]
  01312	48 89 88 b0 11
	00 00		 mov	 QWORD PTR [rax+4528], rcx
  01319	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01320	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv797[rsp]
  01328	48 89 88 a8 11
	00 00		 mov	 QWORD PTR [rax+4520], rcx

; 1204 :     InitializeListHead   ( &sysblk.stape_status_link  );

  0132f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01336	48 05 98 11 00
	00		 add	 rax, 4504		; 00001198H
  0133c	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv832[rsp], rax
  01344	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0134b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv832[rsp]
  01353	48 89 88 a0 11
	00 00		 mov	 QWORD PTR [rax+4512], rcx
  0135a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01361	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv832[rsp]
  01369	48 89 88 98 11
	00 00		 mov	 QWORD PTR [rax+4504], rcx

; 1205 : #endif /* defined(OPTION_SCSI_TAPE) */
; 1206 : 
; 1207 :     if (sysblk.scrtest)

  01370	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01377	83 b8 18 11 00
	00 00		 cmp	 DWORD PTR [rax+4376], 0
  0137e	0f 84 be 00 00
	00		 je	 $LN59@impl

; 1208 :     {
; 1209 :         // "Hercules is running in test mode."
; 1210 :         WRMSG (HHC00019, "W" );

  01384	b9 01 00 00 00	 mov	 ecx, 1
  01389	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0138f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169693
  01396	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0139b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169694
  013a2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  013a7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  013ac	41 b9 03 00 00
	00		 mov	 r9d, 3
  013b2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169695
  013b9	ba ba 04 00 00	 mov	 edx, 1210		; 000004baH
  013be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169696
  013c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1211 :         if (sysblk.scrfactor != 1.0)

  013cb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  013d2	f2 0f 10 80 20
	11 00 00	 movsd	 xmm0, QWORD PTR [rax+4384]
  013da	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@3ff0000000000000
  013e2	7a 02		 jp	 SHORT $LN102@impl
  013e4	74 5c		 je	 SHORT $LN60@impl
$LN102@impl:

; 1212 :             // "Test timeout factor = %3.1f"
; 1213 :             WRMSG( HHC00021, "I", sysblk.scrfactor );

  013e6	b9 01 00 00 00	 mov	 ecx, 1
  013eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  013f1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  013f8	f2 0f 10 81 20
	11 00 00	 movsd	 xmm0, QWORD PTR [rcx+4384]
  01400	f2 0f 11 44 24
	38		 movsd	 QWORD PTR [rsp+56], xmm0
  01406	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169698
  0140d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01412	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169699
  01419	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0141e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01423	41 b9 03 00 00
	00		 mov	 r9d, 3
  01429	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169700
  01430	ba bd 04 00 00	 mov	 edx, 1213		; 000004bdH
  01435	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169701
  0143c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN60@impl:
$LN59@impl:

; 1214 :     }
; 1215 : 
; 1216 :     /* Set default TCP keepalive values */
; 1217 : 
; 1218 : #if !defined( HAVE_BASIC_KEEPALIVE )
; 1219 : 
; 1220 :     WARNING("TCP keepalive headers not found; check configure.ac")
; 1221 :     WARNING("TCP keepalive support will NOT be generated")
; 1222 :     // "This build of Hercules does not support TCP keepalive"
; 1223 :     WRMSG( HHC02321, "E" );
; 1224 : 
; 1225 : #else // basic, partial or full: must attempt setting keepalive
; 1226 : 
; 1227 :   #if !defined( HAVE_FULL_KEEPALIVE ) && !defined( HAVE_PARTIAL_KEEPALIVE )
; 1228 : 
; 1229 :     WARNING("This build of Hercules will only have basic TCP keepalive support")
; 1230 :     // "This build of Hercules has only basic TCP keepalive support"
; 1231 :     WRMSG( HHC02322, "W" );
; 1232 : 
; 1233 :   #elif !defined( HAVE_FULL_KEEPALIVE )
; 1234 : 
; 1235 :     #if !defined( SUPPRESS_PARTIAL_KEEPALIVE_WARNING )
; 1236 :     WARNING("This build of Hercules will only have partial TCP keepalive support")
; 1237 :     #endif
; 1238 : 
; 1239 :     // "This build of Hercules has only partial TCP keepalive support"
; 1240 :     WRMSG( HHC02323, "W" );

  01442	b9 01 00 00 00	 mov	 ecx, 1
  01447	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0144d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169702
  01454	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01459	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169703
  01460	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01465	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0146a	41 b9 03 00 00
	00		 mov	 r9d, 3
  01470	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169704
  01477	ba d8 04 00 00	 mov	 edx, 1240		; 000004d8H
  0147c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169705
  01483	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1241 : 
; 1242 :   #endif // (basic or partial)
; 1243 : 
; 1244 :     /*
; 1245 :     **  Note: we need to try setting them to our desired values first
; 1246 :     **  and then retrieve the set values afterwards to detect systems
; 1247 :     **  which do not allow some values to be changed to ensure SYSBLK
; 1248 :     **  gets initialized with proper working default values.
; 1249 :     */
; 1250 :     {
; 1251 :         int rc, sfd, idle, intv, cnt;
; 1252 : 
; 1253 :         /* Need temporary socket for setting/getting */
; 1254 :         sfd = socket( AF_INET, SOCK_STREAM, 0 );

  01489	45 33 c0	 xor	 r8d, r8d
  0148c	ba 01 00 00 00	 mov	 edx, 1
  01491	b9 02 00 00 00	 mov	 ecx, 2
  01496	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_socket
  0149c	89 44 24 6c	 mov	 DWORD PTR sfd$7[rsp], eax

; 1255 :         if (sfd < 0)

  014a0	83 7c 24 6c 00	 cmp	 DWORD PTR sfd$7[rsp], 0
  014a5	0f 8d 93 00 00
	00		 jge	 $LN61@impl

; 1256 :         {
; 1257 :             WRMSG( HHC02219, "E", "socket()", strerror( HSO_errno ));

  014ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  014b1	8b c8		 mov	 ecx, eax
  014b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  014b9	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv871[rsp], rax
  014c1	b9 01 00 00 00	 mov	 ecx, 1
  014c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  014cc	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv871[rsp]
  014d4	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  014d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169708
  014e0	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  014e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169709
  014ec	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  014f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169710
  014f8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  014fd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01502	41 b9 03 00 00
	00		 mov	 r9d, 3
  01508	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169711
  0150f	ba e9 04 00 00	 mov	 edx, 1257		; 000004e9H
  01514	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169712
  0151b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1258 :             idle = 0;

  01521	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR idle$3[rsp], 0

; 1259 :             intv = 0;

  01529	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR intv$4[rsp], 0

; 1260 :             cnt  = 0;

  01531	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR cnt$5[rsp], 0

; 1261 :         }

  01539	e9 f0 01 00 00	 jmp	 $LN62@impl
$LN61@impl:

; 1262 :         else
; 1263 :         {
; 1264 :             idle = KEEPALIVE_IDLE_TIME;

  0153e	c7 44 24 5c 03
	00 00 00	 mov	 DWORD PTR idle$3[rsp], 3

; 1265 :             intv = KEEPALIVE_PROBE_INTERVAL;

  01546	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR intv$4[rsp], 1

; 1266 :             cnt  = KEEPALIVE_PROBE_COUNT;

  0154e	c7 44 24 64 0a
	00 00 00	 mov	 DWORD PTR cnt$5[rsp], 10

; 1267 : 
; 1268 :             /* First, try setting the desired values */
; 1269 :             rc = set_socket_keepalive( sfd, idle, intv, cnt );

  01556	44 8b 4c 24 64	 mov	 r9d, DWORD PTR cnt$5[rsp]
  0155b	44 8b 44 24 60	 mov	 r8d, DWORD PTR intv$4[rsp]
  01560	8b 54 24 5c	 mov	 edx, DWORD PTR idle$3[rsp]
  01564	8b 4c 24 6c	 mov	 ecx, DWORD PTR sfd$7[rsp]
  01568	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_socket_keepalive
  0156e	89 44 24 70	 mov	 DWORD PTR rc$8[rsp], eax

; 1270 : 
; 1271 :             if (rc < 0)

  01572	83 7c 24 70 00	 cmp	 DWORD PTR rc$8[rsp], 0
  01577	0f 8d 93 00 00
	00		 jge	 $LN63@impl

; 1272 :             {
; 1273 :                 WRMSG( HHC02219, "E", "set_socket_keepalive()", strerror( HSO_errno ));

  0157d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  01583	8b c8		 mov	 ecx, eax
  01585	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0158b	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv891[rsp], rax
  01593	b9 01 00 00 00	 mov	 ecx, 1
  01598	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0159e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv891[rsp]
  015a6	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  015ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169715
  015b2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  015b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169716
  015be	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  015c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169717
  015ca	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  015cf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  015d4	41 b9 03 00 00
	00		 mov	 r9d, 3
  015da	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169718
  015e1	ba f9 04 00 00	 mov	 edx, 1273		; 000004f9H
  015e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169719
  015ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1274 :                 idle = 0;

  015f3	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR idle$3[rsp], 0

; 1275 :                 intv = 0;

  015fb	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR intv$4[rsp], 0

; 1276 :                 cnt  = 0;

  01603	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR cnt$5[rsp], 0

; 1277 :             }

  0160b	e9 14 01 00 00	 jmp	 $LN64@impl
$LN63@impl:

; 1278 :             else
; 1279 :             {
; 1280 :                 /* Report partial success */
; 1281 :                 if (rc > 0)

  01610	83 7c 24 70 00	 cmp	 DWORD PTR rc$8[rsp], 0
  01615	7e 47		 jle	 SHORT $LN65@impl

; 1282 :                 {
; 1283 :                     // "Not all TCP keepalive settings honored"
; 1284 :                     WRMSG( HHC02320, "W" );

  01617	b9 01 00 00 00	 mov	 ecx, 1
  0161c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01622	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169721
  01629	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0162e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169722
  01635	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0163a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0163f	41 b9 03 00 00
	00		 mov	 r9d, 3
  01645	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169723
  0164c	ba 04 05 00 00	 mov	 edx, 1284		; 00000504H
  01651	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169724
  01658	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN65@impl:

; 1285 :                 }
; 1286 : 
; 1287 :                 sysblk.kaidle = idle;

  0165e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01665	8b 4c 24 5c	 mov	 ecx, DWORD PTR idle$3[rsp]
  01669	89 88 b0 10 00
	00		 mov	 DWORD PTR [rax+4272], ecx

; 1288 :                 sysblk.kaintv = intv;

  0166f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01676	8b 4c 24 60	 mov	 ecx, DWORD PTR intv$4[rsp]
  0167a	89 88 b4 10 00
	00		 mov	 DWORD PTR [rax+4276], ecx

; 1289 :                 sysblk.kacnt  = cnt;

  01680	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01687	8b 4c 24 64	 mov	 ecx, DWORD PTR cnt$5[rsp]
  0168b	89 88 b8 10 00
	00		 mov	 DWORD PTR [rax+4280], ecx

; 1290 : 
; 1291 :                 /* Retrieve current values from system */
; 1292 :                 if (get_socket_keepalive( sfd, &idle, &intv, &cnt ) < 0)

  01691	4c 8d 4c 24 64	 lea	 r9, QWORD PTR cnt$5[rsp]
  01696	4c 8d 44 24 60	 lea	 r8, QWORD PTR intv$4[rsp]
  0169b	48 8d 54 24 5c	 lea	 rdx, QWORD PTR idle$3[rsp]
  016a0	8b 4c 24 6c	 mov	 ecx, DWORD PTR sfd$7[rsp]
  016a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_get_socket_keepalive
  016aa	85 c0		 test	 eax, eax
  016ac	7d 76		 jge	 SHORT $LN66@impl

; 1293 :                     WRMSG( HHC02219, "E", "get_socket_keepalive()", strerror( HSO_errno ));

  016ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  016b4	8b c8		 mov	 ecx, eax
  016b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  016bc	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv924[rsp], rax
  016c4	b9 01 00 00 00	 mov	 ecx, 1
  016c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  016cf	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv924[rsp]
  016d7	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  016dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169726
  016e3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  016e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169727
  016ef	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  016f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169728
  016fb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01700	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01705	41 b9 03 00 00
	00		 mov	 r9d, 3
  0170b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169729
  01712	ba 0d 05 00 00	 mov	 edx, 1293		; 0000050dH
  01717	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169730
  0171e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN66@impl:
$LN64@impl:

; 1294 :             }
; 1295 :             close_socket( sfd );

  01724	8b 4c 24 6c	 mov	 ecx, DWORD PTR sfd$7[rsp]
  01728	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket
$LN62@impl:

; 1296 :         }
; 1297 : 
; 1298 :         /* Initialize SYSBLK with default values */
; 1299 :         sysblk.kaidle = idle;

  0172e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01735	8b 4c 24 5c	 mov	 ecx, DWORD PTR idle$3[rsp]
  01739	89 88 b0 10 00
	00		 mov	 DWORD PTR [rax+4272], ecx

; 1300 :         sysblk.kaintv = intv;

  0173f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01746	8b 4c 24 60	 mov	 ecx, DWORD PTR intv$4[rsp]
  0174a	89 88 b4 10 00
	00		 mov	 DWORD PTR [rax+4276], ecx

; 1301 :         sysblk.kacnt  = cnt;

  01750	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01757	8b 4c 24 64	 mov	 ecx, DWORD PTR cnt$5[rsp]
  0175b	89 88 b8 10 00
	00		 mov	 DWORD PTR [rax+4280], ecx

; 1302 :     }
; 1303 : 
; 1304 : #endif // (KEEPALIVE)
; 1305 : 
; 1306 :     /* Initialize runtime opcode tables */
; 1307 :     init_runtime_opcode_tables();

  01761	e8 00 00 00 00	 call	 init_runtime_opcode_tables

; 1308 : 
; 1309 :     /* Initialize the Hercules Dynamic Loader (HDL) */
; 1310 :     rc = hdl_main

  01766	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_fba_dasd_device_hndinfo
  0176d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01772	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR __imp_ckd_dasd_device_hndinfo
  01779	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:the_real_replace_opcode
  01780	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:the_real_panel_command
  01787	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:the_real_panel_display
  0178e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hdl_main
  01794	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 1311 :     (
; 1312 :         &the_real_panel_display,
; 1313 :         &the_real_panel_command,
; 1314 :         &the_real_replace_opcode,
; 1315 :         &ckd_dasd_device_hndinfo,
; 1316 :         &fba_dasd_device_hndinfo
; 1317 :     );
; 1318 : 
; 1319 :     if (rc != 0)

  01798	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  0179d	74 12		 je	 SHORT $LN67@impl

; 1320 :     {
; 1321 :         delayed_exit( rc );

  0179f	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  017a3	e8 00 00 00 00	 call	 delayed_exit

; 1322 :         return rc;

  017a8	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
  017ac	e9 48 0b 00 00	 jmp	 $LN1@impl
$LN67@impl:

; 1323 :     }
; 1324 : 
; 1325 :     /* Load DYNGUI module if needed */
; 1326 :     if (extgui)

  017b1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  017b8	83 38 00	 cmp	 DWORD PTR [rax], 0
  017bb	74 7c		 je	 SHORT $LN68@impl

; 1327 :     {
; 1328 :         if (hdl_loadmod( "dyngui", HDL_LOAD_NOUNLOAD ) != 0)

  017bd	ba 00 00 00 40	 mov	 edx, 1073741824		; 40000000H
  017c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169734
  017c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hdl_loadmod
  017cf	85 c0		 test	 eax, eax
  017d1	74 66		 je	 SHORT $LN69@impl

; 1329 :         {
; 1330 :             usleep( 10000 ); // (give logger time to show them the error message)

  017d3	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  017d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 1331 :             // "Load of dyngui.dll failed, hercules terminated"
; 1332 :             WRMSG( HHC01409, "S" );

  017de	b9 01 00 00 00	 mov	 ecx, 1
  017e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  017e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169735
  017f0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  017f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169736
  017fc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01801	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01806	41 b9 03 00 00
	00		 mov	 r9d, 3
  0180c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169737
  01813	ba 34 05 00 00	 mov	 edx, 1332		; 00000534H
  01818	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169738
  0181f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1333 :             delayed_exit( -1 );

  01825	b9 ff ff ff ff	 mov	 ecx, -1
  0182a	e8 00 00 00 00	 call	 delayed_exit

; 1334 :             return 1;

  0182f	b8 01 00 00 00	 mov	 eax, 1
  01834	e9 c0 0a 00 00	 jmp	 $LN1@impl
$LN69@impl:
$LN68@impl:

; 1335 :         }
; 1336 :     }
; 1337 : 
; 1338 :     /* Load modules specified via command-line -l/--ldmod option */
; 1339 :     if (modcount)

  01839	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR modcount, 0
  01840	0f 84 eb 00 00
	00		 je	 $LN70@impl

; 1340 :     {
; 1341 :         int modnum;
; 1342 :         bool err = false;

  01846	c6 44 24 54 00	 mov	 BYTE PTR err$1[rsp], 0

; 1343 : 
; 1344 :         for (modnum = 0; modnum < modcount; modnum++)

  0184b	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR modnum$6[rsp], 0
  01853	eb 0a		 jmp	 SHORT $LN22@impl
$LN20@impl:
  01855	8b 44 24 68	 mov	 eax, DWORD PTR modnum$6[rsp]
  01859	ff c0		 inc	 eax
  0185b	89 44 24 68	 mov	 DWORD PTR modnum$6[rsp], eax
$LN22@impl:
  0185f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR modcount
  01865	39 44 24 68	 cmp	 DWORD PTR modnum$6[rsp], eax
  01869	7d 4d		 jge	 SHORT $LN21@impl

; 1345 :         {
; 1346 :             if (hdl_loadmod( modnames[ modnum ], HDL_LOAD_DEFAULT) != 0)

  0186b	48 63 44 24 68	 movsxd	 rax, DWORD PTR modnum$6[rsp]
  01870	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:modnames
  01877	33 d2		 xor	 edx, edx
  01879	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0187d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hdl_loadmod
  01883	85 c0		 test	 eax, eax
  01885	74 05		 je	 SHORT $LN71@impl

; 1347 :                 err = true;

  01887	c6 44 24 54 01	 mov	 BYTE PTR err$1[rsp], 1
$LN71@impl:

; 1348 : 
; 1349 :             free( modnames[ modnum ]);

  0188c	48 63 44 24 68	 movsxd	 rax, DWORD PTR modnum$6[rsp]
  01891	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:modnames
  01898	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0189c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1350 :             modnames[ modnum ] = NULL;

  018a2	48 63 44 24 68	 movsxd	 rax, DWORD PTR modnum$6[rsp]
  018a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:modnames
  018ae	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0

; 1351 :         }

  018b6	eb 9d		 jmp	 SHORT $LN20@impl
$LN21@impl:

; 1352 : 
; 1353 :         modcount = 0;  // (reset to zero now that they're all loaded)

  018b8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR modcount, 0

; 1354 : 
; 1355 :         if (err)

  018c2	0f b6 44 24 54	 movzx	 eax, BYTE PTR err$1[rsp]
  018c7	85 c0		 test	 eax, eax
  018c9	74 66		 je	 SHORT $LN72@impl

; 1356 :         {
; 1357 :             usleep( 10000 ); // (give logger time to display message)

  018cb	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  018d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 1358 :             // "Hercules terminating, see previous messages for reason"
; 1359 :             WRMSG( HHC01408, "S");

  018d6	b9 01 00 00 00	 mov	 ecx, 1
  018db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  018e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169742
  018e8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  018ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169743
  018f4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  018f9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  018fe	41 b9 03 00 00
	00		 mov	 r9d, 3
  01904	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169744
  0190b	ba 4f 05 00 00	 mov	 edx, 1359		; 0000054fH
  01910	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169745
  01917	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1360 :             delayed_exit( -1 );

  0191d	b9 ff ff ff ff	 mov	 ecx, -1
  01922	e8 00 00 00 00	 call	 delayed_exit

; 1361 :             return 1;

  01927	b8 01 00 00 00	 mov	 eax, 1
  0192c	e9 c8 09 00 00	 jmp	 $LN1@impl
$LN72@impl:
$LN70@impl:

; 1362 :         }
; 1363 :     }
; 1364 : 
; 1365 :     /* The SIGINT signal is sent to a process by its controlling
; 1366 :        terminal when a user wishes to interrupt the process. This
; 1367 :        is typically initiated by pressing Ctrl+C, but on some
; 1368 :        systems, the "delete" character or "break" key can be used.
; 1369 : 
; 1370 :        The SIGTERM signal is sent to a process to request its
; 1371 :        termination. Unlike the SIGKILL signal, it can be caught
; 1372 :        and interpreted or ignored by the process. This allows
; 1373 :        the process to perform nice termination releasing resources
; 1374 :        and saving state if appropriate. SIGINT is nearly identical
; 1375 :        to SIGTERM.
; 1376 :     */
; 1377 : 
; 1378 :     /* Register the SIGINT handler */
; 1379 :     if (signal( SIGINT, sigint_handler ) == SIG_ERR)

  01931	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:sigint_handler
  01938	b9 02 00 00 00	 mov	 ecx, 2
  0193d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_signal
  01943	48 83 f8 ff	 cmp	 rax, -1
  01947	0f 85 8a 00 00
	00		 jne	 $LN73@impl

; 1380 :     {
; 1381 :         // "Cannot register %s handler: %s"
; 1382 :         WRMSG( HHC01410, "S", "SIGINT", strerror( errno ));

  0194d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01953	8b 08		 mov	 ecx, DWORD PTR [rax]
  01955	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0195b	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv1032[rsp], rax
  01963	b9 01 00 00 00	 mov	 ecx, 1
  01968	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0196e	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv1032[rsp]
  01976	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0197b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169747
  01982	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01987	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169748
  0198e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01993	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169749
  0199a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0199f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  019a4	41 b9 03 00 00
	00		 mov	 r9d, 3
  019aa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169750
  019b1	ba 66 05 00 00	 mov	 edx, 1382		; 00000566H
  019b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169751
  019bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1383 :         delayed_exit( -1 );

  019c3	b9 ff ff ff ff	 mov	 ecx, -1
  019c8	e8 00 00 00 00	 call	 delayed_exit

; 1384 :         return 1;

  019cd	b8 01 00 00 00	 mov	 eax, 1
  019d2	e9 22 09 00 00	 jmp	 $LN1@impl
$LN73@impl:

; 1385 :     }
; 1386 : 
; 1387 :     /* Register the SIGTERM handler */
; 1388 :     if (signal( SIGTERM, sigterm_handler ) == SIG_ERR)

  019d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:sigterm_handler
  019de	b9 0f 00 00 00	 mov	 ecx, 15
  019e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_signal
  019e9	48 83 f8 ff	 cmp	 rax, -1
  019ed	0f 85 8a 00 00
	00		 jne	 $LN74@impl

; 1389 :     {
; 1390 :         // "Cannot register %s handler: %s"
; 1391 :         WRMSG( HHC01410, "S", "SIGTERM", strerror( errno ));

  019f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  019f9	8b 08		 mov	 ecx, DWORD PTR [rax]
  019fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01a01	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv1051[rsp], rax
  01a09	b9 01 00 00 00	 mov	 ecx, 1
  01a0e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01a14	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv1051[rsp]
  01a1c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01a21	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169753
  01a28	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01a2d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169754
  01a34	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01a39	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169755
  01a40	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01a45	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01a4a	41 b9 03 00 00
	00		 mov	 r9d, 3
  01a50	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169756
  01a57	ba 6f 05 00 00	 mov	 edx, 1391		; 0000056fH
  01a5c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169757
  01a63	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1392 :         delayed_exit( -1 );

  01a69	b9 ff ff ff ff	 mov	 ecx, -1
  01a6e	e8 00 00 00 00	 call	 delayed_exit

; 1393 :         return 1;

  01a73	b8 01 00 00 00	 mov	 eax, 1
  01a78	e9 7c 08 00 00	 jmp	 $LN1@impl
$LN74@impl:

; 1394 :     }
; 1395 : 
; 1396 : #if defined( _MSVC_ )
; 1397 :     /* Register the Window console ctrl handlers */
; 1398 :     if (!IsDebuggerPresent())

  01a7d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  01a83	85 c0		 test	 eax, eax
  01a85	0f 85 40 02 00
	00		 jne	 $LN75@impl

; 1399 :     {
; 1400 :         TID dummy;
; 1401 :         BOOL bSuccess = FALSE;

  01a8b	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR bSuccess$10[rsp], 0

; 1402 : 
; 1403 :         /* The Windows the console_ctrl_handler function
; 1404 :            accomplishes the same thing as what a SIGINT or
; 1405 :            SIGTERM signal handler does on Unix systems: it
; 1406 :            handles Ctrl+C and Close events.
; 1407 :         */
; 1408 :         if (!SetConsoleCtrlHandler( console_ctrl_handler, TRUE ))

  01a96	ba 01 00 00 00	 mov	 edx, 1
  01a9b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:console_ctrl_handler
  01aa2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleCtrlHandler
  01aa8	85 c0		 test	 eax, eax
  01aaa	0f 85 8a 00 00
	00		 jne	 $LN76@impl

; 1409 :         {
; 1410 :             // "Cannot register %s handler: %s"
; 1411 :             WRMSG( HHC01410, "S", "Console-ctrl", strerror( errno ));

  01ab0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01ab6	8b 08		 mov	 ecx, DWORD PTR [rax]
  01ab8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01abe	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv1072[rsp], rax
  01ac6	b9 01 00 00 00	 mov	 ecx, 1
  01acb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01ad1	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv1072[rsp]
  01ad9	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01ade	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169760
  01ae5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01aea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169761
  01af1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01af6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169762
  01afd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01b02	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01b07	41 b9 03 00 00
	00		 mov	 r9d, 3
  01b0d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169763
  01b14	ba 83 05 00 00	 mov	 edx, 1411		; 00000583H
  01b19	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169764
  01b20	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1412 :             delayed_exit(-1);

  01b26	b9 ff ff ff ff	 mov	 ecx, -1
  01b2b	e8 00 00 00 00	 call	 delayed_exit

; 1413 :             return 1;

  01b30	b8 01 00 00 00	 mov	 eax, 1
  01b35	e9 bf 07 00 00	 jmp	 $LN1@impl
$LN76@impl:

; 1414 :         }
; 1415 : 
; 1416 :         g_hWndEvt = CreateEvent( NULL, TRUE, FALSE, NULL );

  01b3a	45 33 c9	 xor	 r9d, r9d
  01b3d	45 33 c0	 xor	 r8d, r8d
  01b40	ba 01 00 00 00	 mov	 edx, 1
  01b45	33 c9		 xor	 ecx, ecx
  01b47	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateEventA
  01b4d	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_hWndEvt, rax

; 1417 : 
; 1418 :         if ((rc = create_thread( &dummy, DETACHED,
; 1419 :             WinMsgThread, (void*) &bSuccess, "WinMsgThread" )) != 0)

  01b54	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01b5b	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  01b61	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169766
  01b68	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01b6d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169767
  01b74	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01b79	4c 8d 8c 24 8c
	00 00 00	 lea	 r9, QWORD PTR bSuccess$10[rsp]
  01b81	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:WinMsgThread
  01b88	48 8b d0	 mov	 rdx, rax
  01b8b	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR dummy$11[rsp]
  01b93	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  01b99	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  01b9d	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  01ba2	0f 84 87 00 00
	00		 je	 $LN77@impl

; 1420 :         {
; 1421 :             // "Error in function create_thread(): %s"
; 1422 :             WRMSG( HHC00102, "E", strerror( rc ));

  01ba8	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  01bac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01bb2	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv1133[rsp], rax
  01bba	b9 01 00 00 00	 mov	 ecx, 1
  01bbf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01bc5	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv1133[rsp]
  01bcd	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01bd2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169768
  01bd9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01bde	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169769
  01be5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01bea	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01bef	41 b9 03 00 00
	00		 mov	 r9d, 3
  01bf5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169770
  01bfc	ba 8e 05 00 00	 mov	 edx, 1422		; 0000058eH
  01c01	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169771
  01c08	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1423 :             CloseHandle( g_hWndEvt );

  01c0e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR g_hWndEvt
  01c15	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 1424 :             delayed_exit(-1);

  01c1b	b9 ff ff ff ff	 mov	 ecx, -1
  01c20	e8 00 00 00 00	 call	 delayed_exit

; 1425 :             return 1;

  01c25	b8 01 00 00 00	 mov	 eax, 1
  01c2a	e9 ca 06 00 00	 jmp	 $LN1@impl
$LN77@impl:

; 1426 :         }
; 1427 : 
; 1428 :         // (wait for thread to create window)
; 1429 :         WaitForSingleObject( g_hWndEvt, INFINITE );

  01c2f	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  01c34	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR g_hWndEvt
  01c3b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject

; 1430 :         CloseHandle( g_hWndEvt );

  01c41	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR g_hWndEvt
  01c48	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 1431 : 
; 1432 :         // Was message window successfully created?
; 1433 : 
; 1434 :         if (!g_hMsgWnd)

  01c4e	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR g_hMsgWnd, 0
  01c56	75 73		 jne	 SHORT $LN78@impl

; 1435 :         {
; 1436 :             // "Error in function %s: %s"
; 1437 :             WRMSG( HHC00136, "E", "WinMsgThread", "CreateWindowEx() failed");

  01c58	b9 01 00 00 00	 mov	 ecx, 1
  01c5d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01c63	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169773
  01c6a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01c6f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169774
  01c76	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01c7b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169775
  01c82	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01c87	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169776
  01c8e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01c93	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01c98	41 b9 03 00 00
	00		 mov	 r9d, 3
  01c9e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169777
  01ca5	ba 9d 05 00 00	 mov	 edx, 1437		; 0000059dH
  01caa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169778
  01cb1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1438 :             delayed_exit(-1);

  01cb7	b9 ff ff ff ff	 mov	 ecx, -1
  01cbc	e8 00 00 00 00	 call	 delayed_exit

; 1439 :             return 1;

  01cc1	b8 01 00 00 00	 mov	 eax, 1
  01cc6	e9 2e 06 00 00	 jmp	 $LN1@impl
$LN78@impl:
$LN75@impl:

; 1440 :         }
; 1441 :     }
; 1442 : #endif
; 1443 : 
; 1444 : #if defined( HAVE_DECL_SIGPIPE ) && HAVE_DECL_SIGPIPE
; 1445 :     /* Ignore the SIGPIPE signal, otherwise Hercules may terminate with
; 1446 :        Broken Pipe error if the printer driver writes to a closed pipe */
; 1447 :     if (signal( SIGPIPE, SIG_IGN ) == SIG_ERR)
; 1448 :     {
; 1449 :         // "Cannot suppress SIGPIPE signal: %s"
; 1450 :         WRMSG( HHC01411, "E", strerror( errno ));
; 1451 :     }
; 1452 : #endif
; 1453 : 
; 1454 :     {
; 1455 :         int fds[2];
; 1456 :         initialize_lock(&sysblk.cnslpipe_lock);

  01ccb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01cd2	48 05 c0 10 00
	00		 add	 rax, 4288		; 000010c0H
  01cd8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169779
  01cdf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169780
  01ce6	48 8b c8	 mov	 rcx, rax
  01ce9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 1457 :         initialize_lock(&sysblk.sockpipe_lock);

  01cef	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01cf6	48 05 d8 10 00
	00		 add	 rax, 4312		; 000010d8H
  01cfc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169781
  01d03	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169782
  01d0a	48 8b c8	 mov	 rcx, rax
  01d0d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 1458 :         sysblk.cnslpipe_flag=0;

  01d13	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01d1a	c7 80 c8 10 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4296], 0

; 1459 :         sysblk.sockpipe_flag=0;

  01d24	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01d2b	c7 80 e0 10 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4320], 0
$LN25@impl:

; 1460 :         VERIFY( create_pipe(fds) >= 0 );

  01d35	4c 8d 4c 24 78	 lea	 r9, QWORD PTR fds$9[rsp]
  01d3a	45 33 c0	 xor	 r8d, r8d
  01d3d	ba 01 00 00 00	 mov	 edx, 1
  01d42	b9 02 00 00 00	 mov	 ecx, 2
  01d47	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socketpair
  01d4d	85 c0		 test	 eax, eax
  01d4f	7d 5c		 jge	 SHORT $LN79@impl
$LN28@impl:
  01d51	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169784
  01d58	41 b8 b4 05 00
	00		 mov	 r8d, 1460		; 000005b4H
  01d5e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169785
  01d65	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169786
  01d6c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  01d72	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  01d78	85 c0		 test	 eax, eax
  01d7a	74 20		 je	 SHORT $LN80@impl
  01d7c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169788
  01d83	41 b8 b4 05 00
	00		 mov	 r8d, 1460		; 000005b4H
  01d89	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169789
  01d90	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169790
  01d97	e8 00 00 00 00	 call	 DebuggerTrace
$LN80@impl:
  01d9c	33 c0		 xor	 eax, eax
  01d9e	85 c0		 test	 eax, eax
  01da0	75 af		 jne	 SHORT $LN28@impl
  01da2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  01da8	85 c0		 test	 eax, eax
  01daa	74 01		 je	 SHORT $LN81@impl
  01dac	cc		 int	 3
$LN81@impl:
$LN79@impl:
  01dad	33 c0		 xor	 eax, eax
  01daf	85 c0		 test	 eax, eax
  01db1	75 82		 jne	 SHORT $LN25@impl

; 1461 :         sysblk.cnslwpipe=fds[1];

  01db3	b8 04 00 00 00	 mov	 eax, 4
  01db8	48 6b c0 01	 imul	 rax, rax, 1
  01dbc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01dc3	8b 44 04 78	 mov	 eax, DWORD PTR fds$9[rsp+rax]
  01dc7	89 81 cc 10 00
	00		 mov	 DWORD PTR [rcx+4300], eax

; 1462 :         sysblk.cnslrpipe=fds[0];

  01dcd	b8 04 00 00 00	 mov	 eax, 4
  01dd2	48 6b c0 00	 imul	 rax, rax, 0
  01dd6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01ddd	8b 44 04 78	 mov	 eax, DWORD PTR fds$9[rsp+rax]
  01de1	89 81 d0 10 00
	00		 mov	 DWORD PTR [rcx+4304], eax
$LN31@impl:

; 1463 :         VERIFY( create_pipe(fds) >= 0 );

  01de7	4c 8d 4c 24 78	 lea	 r9, QWORD PTR fds$9[rsp]
  01dec	45 33 c0	 xor	 r8d, r8d
  01def	ba 01 00 00 00	 mov	 edx, 1
  01df4	b9 02 00 00 00	 mov	 ecx, 2
  01df9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socketpair
  01dff	85 c0		 test	 eax, eax
  01e01	7d 5c		 jge	 SHORT $LN82@impl
$LN34@impl:
  01e03	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169793
  01e0a	41 b8 b7 05 00
	00		 mov	 r8d, 1463		; 000005b7H
  01e10	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169794
  01e17	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169795
  01e1e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  01e24	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  01e2a	85 c0		 test	 eax, eax
  01e2c	74 20		 je	 SHORT $LN83@impl
  01e2e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169797
  01e35	41 b8 b7 05 00
	00		 mov	 r8d, 1463		; 000005b7H
  01e3b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169798
  01e42	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169799
  01e49	e8 00 00 00 00	 call	 DebuggerTrace
$LN83@impl:
  01e4e	33 c0		 xor	 eax, eax
  01e50	85 c0		 test	 eax, eax
  01e52	75 af		 jne	 SHORT $LN34@impl
  01e54	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  01e5a	85 c0		 test	 eax, eax
  01e5c	74 01		 je	 SHORT $LN84@impl
  01e5e	cc		 int	 3
$LN84@impl:
$LN82@impl:
  01e5f	33 c0		 xor	 eax, eax
  01e61	85 c0		 test	 eax, eax
  01e63	75 82		 jne	 SHORT $LN31@impl

; 1464 :         sysblk.sockwpipe=fds[1];

  01e65	b8 04 00 00 00	 mov	 eax, 4
  01e6a	48 6b c0 01	 imul	 rax, rax, 1
  01e6e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01e75	8b 44 04 78	 mov	 eax, DWORD PTR fds$9[rsp+rax]
  01e79	89 81 e4 10 00
	00		 mov	 DWORD PTR [rcx+4324], eax

; 1465 :         sysblk.sockrpipe=fds[0];

  01e7f	b8 04 00 00 00	 mov	 eax, 4
  01e84	48 6b c0 00	 imul	 rax, rax, 0
  01e88	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01e8f	8b 44 04 78	 mov	 eax, DWORD PTR fds$9[rsp+rax]
  01e93	89 81 e8 10 00
	00		 mov	 DWORD PTR [rcx+4328], eax

; 1466 :     }
; 1467 : 
; 1468 : #ifdef HAVE_REXX
; 1469 :     /* Initialize Rexx */
; 1470 :     InitializeRexx();

  01e99	e8 00 00 00 00	 call	 InitializeRexx

; 1471 : #endif
; 1472 : 
; 1473 :     /* System initialisation time */
; 1474 :     sysblk.todstart = hw_clock() << 8;

  01e9e	e8 00 00 00 00	 call	 hw_clock
  01ea3	48 c1 e0 08	 shl	 rax, 8
  01ea7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01eae	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax

; 1475 : 
; 1476 :     hdl_addshut( "release_config", release_config, NULL );

  01eb5	45 33 c0	 xor	 r8d, r8d
  01eb8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:release_config
  01ebf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169801
  01ec6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hdl_addshut

; 1477 : 
; 1478 : #if defined( OPTION_WATCHDOG )
; 1479 :     /* Start the watchdog thread */
; 1480 :     rc = create_thread( &sysblk.wdtid, DETACHED,

  01ecc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01ed3	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  01ed9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01ee0	48 81 c1 e0 00
	00 00		 add	 rcx, 224		; 000000e0H
  01ee7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169802
  01eee	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  01ef3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169803
  01efa	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  01eff	45 33 c9	 xor	 r9d, r9d
  01f02	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:watchdog_thread
  01f09	48 8b d0	 mov	 rdx, rax
  01f0c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  01f12	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 1481 :         watchdog_thread, NULL, WATCHDOG_THREAD_NAME );
; 1482 :     if (rc)

  01f16	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  01f1b	74 7a		 je	 SHORT $LN85@impl

; 1483 :     {
; 1484 :         // "Error in function create_thread(): %s"
; 1485 :         WRMSG( HHC00102, "E", strerror( rc ));

  01f1d	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  01f21	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01f27	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv1273[rsp], rax
  01f2f	b9 01 00 00 00	 mov	 ecx, 1
  01f34	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01f3a	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv1273[rsp]
  01f42	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01f47	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169805
  01f4e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01f53	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169806
  01f5a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01f5f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01f64	41 b9 03 00 00
	00		 mov	 r9d, 3
  01f6a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169807
  01f71	ba cd 05 00 00	 mov	 edx, 1485		; 000005cdH
  01f76	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169808
  01f7d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1486 :         delayed_exit( -1 );

  01f83	b9 ff ff ff ff	 mov	 ecx, -1
  01f88	e8 00 00 00 00	 call	 delayed_exit

; 1487 :         return 1;

  01f8d	b8 01 00 00 00	 mov	 eax, 1
  01f92	e9 62 03 00 00	 jmp	 $LN1@impl
$LN85@impl:

; 1488 :     }
; 1489 : #endif /* defined( OPTION_WATCHDOG ) */
; 1490 : 
; 1491 :     /* Build system configuration */
; 1492 :     if ( build_config (cfgorrc[want_cfg].filename) )

  01f97	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  01f9c	48 6b c0 00	 imul	 rax, rax, 0
  01fa0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cfgorrc
  01fa7	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  01fab	e8 00 00 00 00	 call	 build_config
  01fb0	85 c0		 test	 eax, eax
  01fb2	74 14		 je	 SHORT $LN86@impl

; 1493 :     {
; 1494 :         delayed_exit(-1);

  01fb4	b9 ff ff ff ff	 mov	 ecx, -1
  01fb9	e8 00 00 00 00	 call	 delayed_exit

; 1495 :         return 1;

  01fbe	b8 01 00 00 00	 mov	 eax, 1
  01fc3	e9 31 03 00 00	 jmp	 $LN1@impl
$LN86@impl:

; 1496 :     }
; 1497 : 
; 1498 :     sysblk.config_processed = true;

  01fc8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01fcf	c7 80 98 12 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+4760], 1

; 1499 :     sysblk.cfg_timerint = sysblk.timerint;

  01fd9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01fe0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01fe7	8b 89 60 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4448]
  01fed	89 88 64 11 00
	00		 mov	 DWORD PTR [rax+4452], ecx

; 1500 : 
; 1501 :     /* Report CCKD dasd image garbage states at startup */
; 1502 :     cckd_gc_rpt_states();

  01ff3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_cckd_gc_rpt_states

; 1503 : 
; 1504 : #if defined( _FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1505 : 
; 1506 :     if (FACILITY_ENABLED_ARCH( 073_TRANSACT_EXEC, ARCH_900_IDX ))

  01ff9	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  01ffe	48 6b c0 02	 imul	 rax, rax, 2
  02002	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  02009	48 8d 84 01 a0
	0d 00 00	 lea	 rax, QWORD PTR [rcx+rax+3488]
  02011	b9 01 00 00 00	 mov	 ecx, 1
  02016	48 6b c9 09	 imul	 rcx, rcx, 9
  0201a	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0201e	83 e0 40	 and	 eax, 64			; 00000040H
  02021	85 c0		 test	 eax, eax
  02023	74 10		 je	 SHORT $LN87@impl

; 1507 :     {
; 1508 :         txf_model_warning( true );

  02025	b1 01		 mov	 cl, 1
  02027	e8 00 00 00 00	 call	 txf_model_warning

; 1509 :         txf_set_timerint( true );

  0202c	b1 01		 mov	 cl, 1
  0202e	e8 00 00 00 00	 call	 txf_set_timerint

; 1510 :     }

  02033	eb 07		 jmp	 SHORT $LN88@impl
$LN87@impl:

; 1511 :     else
; 1512 :         txf_set_timerint( false );

  02035	33 c9		 xor	 ecx, ecx
  02037	e8 00 00 00 00	 call	 txf_set_timerint
$LN88@impl:

; 1513 : 
; 1514 : #endif /* defined( _FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 1515 : 
; 1516 :     /* Process the .rc file synchronously when in daemon mode. */
; 1517 :     /* Otherwise Start up the RC file processing thread.       */
; 1518 :     if (sysblk.daemon_mode)

  0203c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  02043	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  02049	c1 e8 02	 shr	 eax, 2
  0204c	83 e0 01	 and	 eax, 1
  0204f	85 c0		 test	 eax, eax
  02051	74 0c		 je	 SHORT $LN89@impl

; 1519 :         process_rc_file( NULL );

  02053	33 c9		 xor	 ecx, ecx
  02055	e8 00 00 00 00	 call	 process_rc_file
  0205a	e9 b1 00 00 00	 jmp	 $LN90@impl
$LN89@impl:

; 1520 :     else
; 1521 :     {
; 1522 :         rc = create_thread( &rctid, DETACHED,

  0205f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  02066	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  0206c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169814
  02073	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169815
  0207f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  02084	45 33 c9	 xor	 r9d, r9d
  02087	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:process_rc_file
  0208e	48 8b d0	 mov	 rdx, rax
  02091	48 8d 8c 24 a4
	00 00 00	 lea	 rcx, QWORD PTR rctid$[rsp]
  02099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  0209f	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 1523 :             process_rc_file, NULL, "process_rc_file" );
; 1524 :         if (rc)

  020a3	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  020a8	74 66		 je	 SHORT $LN91@impl

; 1525 :             WRMSG( HHC00102, "E", strerror( rc ));

  020aa	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  020ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  020b4	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv1353[rsp], rax
  020bc	b9 01 00 00 00	 mov	 ecx, 1
  020c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  020c7	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv1353[rsp]
  020cf	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  020d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169817
  020db	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  020e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169818
  020e7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  020ec	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  020f1	41 b9 03 00 00
	00		 mov	 r9d, 3
  020f7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169819
  020fe	ba f5 05 00 00	 mov	 edx, 1525		; 000005f5H
  02103	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169820
  0210a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN91@impl:
$LN90@impl:

; 1526 :     }
; 1527 : 
; 1528 :     if (log_callback)

  02110	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR log_callback, 0
  02118	0f 84 ba 00 00
	00		 je	 $LN92@impl

; 1529 :     {
; 1530 :         // 'herclin' called us. IT iS in charge. Create its requested
; 1531 :         // logmsg intercept callback function and return back to it.
; 1532 :         rc = create_thread( &logcbtid, DETACHED,

  0211e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  02125	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  0212b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169822
  02132	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02137	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169823
  0213e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  02143	45 33 c9	 xor	 r9d, r9d
  02146	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:log_do_callback
  0214d	48 8b d0	 mov	 rdx, rax
  02150	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR logcbtid$[rsp]
  02158	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  0215e	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 1533 :                       log_do_callback, NULL, "log_do_callback" );
; 1534 :         if (rc)

  02162	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  02167	74 66		 je	 SHORT $LN93@impl

; 1535 :             // "Error in function create_thread(): %s"
; 1536 :             WRMSG( HHC00102, "E", strerror( rc ));

  02169	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  0216d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  02173	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv1375[rsp], rax
  0217b	b9 01 00 00 00	 mov	 ecx, 1
  02180	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02186	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tv1375[rsp]
  0218e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  02193	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169825
  0219a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0219f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169826
  021a6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  021ab	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  021b0	41 b9 03 00 00
	00		 mov	 r9d, 3
  021b6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169827
  021bd	ba 00 06 00 00	 mov	 edx, 1536		; 00000600H
  021c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169828
  021c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN93@impl:

; 1537 : 
; 1538 :         return (rc);

  021cf	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
  021d3	e9 21 01 00 00	 jmp	 $LN1@impl
$LN92@impl:

; 1539 :     }
; 1540 : 
; 1541 :     /* Activate the control panel */
; 1542 :     if (!sysblk.daemon_mode)

  021d8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  021df	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  021e5	c1 e8 02	 shr	 eax, 2
  021e8	83 e0 01	 and	 eax, 1
  021eb	85 c0		 test	 eax, eax
  021ed	75 0b		 jne	 SHORT $LN94@impl

; 1543 :         panel_display();  /* Returns only AFTER Hercules is shutdown */

  021ef	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_panel_display
  021f6	ff 10		 call	 QWORD PTR [rax]
  021f8	eb 50		 jmp	 SHORT $LN95@impl
$LN94@impl:

; 1544 :     else
; 1545 :     {
; 1546 :         /* We're in daemon mode... */
; 1547 :         if (daemon_task)

  021fa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_daemon_task
  02201	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  02205	74 0b		 je	 SHORT $LN96@impl

; 1548 :             daemon_task();/* Returns only AFTER Hercules is shutdown */

  02207	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_daemon_task
  0220e	ff 10		 call	 QWORD PTR [rax]
  02210	eb 38		 jmp	 SHORT $LN97@impl
$LN96@impl:

; 1549 :         else
; 1550 :         {
; 1551 :             /* daemon mode without any daemon_task */
; 1552 :             process_script_file( "-", true );

  02212	b2 01		 mov	 dl, 1
  02214	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169833
  0221b	e8 00 00 00 00	 call	 process_script_file
$LN35@impl:

; 1553 : 
; 1554 :             /* We come here only if the user did ctl-d on a tty,
; 1555 :                or we reached EOF on stdin.  No quit command has
; 1556 :                been issued (yet) since that (via do_shutdown())
; 1557 :                would not return.  So we issue the quit here once
; 1558 :                all CPUs have quiesced since without any CPUs and
; 1559 :                stdin at EOF, there's nothing more for us to do!
; 1560 :             */
; 1561 :             while (sysblk.started_mask) /* All CPUs quiesced?        */

  02220	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  02227	48 83 b8 b0 12
	00 00 00	 cmp	 QWORD PTR [rax+4784], 0
  0222f	74 0d		 je	 SHORT $LN36@impl

; 1562 :                 usleep( 10 * 1000 );    /* Wait for CPUs to stop.    */

  02231	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  02236	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
  0223c	eb e2		 jmp	 SHORT $LN35@impl
$LN36@impl:

; 1563 :             quit_cmd( 0, NULL, NULL );  /* Then pull the plug.       */

  0223e	45 33 c0	 xor	 r8d, r8d
  02241	33 d2		 xor	 edx, edx
  02243	33 c9		 xor	 ecx, ecx
  02245	e8 00 00 00 00	 call	 quit_cmd
$LN97@impl:
$LN95@impl:
$LN39@impl:

; 1564 :         }
; 1565 :     }
; 1566 : 
; 1567 :     /*
; 1568 :     **  PROGRAMMING NOTE: the following code is only ever reached
; 1569 :     **  if Hercules is run in normal panel mode -OR- when it is run
; 1570 :     **  under the control of an external GUI (i.e. daemon_task).
; 1571 :     */
; 1572 :     ASSERT( sysblk.shutdown );  // (why else would we be here?!)

  0224a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  02251	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  02257	c1 e8 0b	 shr	 eax, 11
  0225a	83 e0 01	 and	 eax, 1
  0225d	85 c0		 test	 eax, eax
  0225f	75 5c		 jne	 SHORT $LN98@impl
$LN42@impl:
  02261	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169835
  02268	41 b8 24 06 00
	00		 mov	 r8d, 1572		; 00000624H
  0226e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169836
  02275	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169837
  0227c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  02282	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  02288	85 c0		 test	 eax, eax
  0228a	74 20		 je	 SHORT $LN99@impl
  0228c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169839
  02293	41 b8 24 06 00
	00		 mov	 r8d, 1572		; 00000624H
  02299	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169840
  022a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169841
  022a7	e8 00 00 00 00	 call	 DebuggerTrace
$LN99@impl:
  022ac	33 c0		 xor	 eax, eax
  022ae	85 c0		 test	 eax, eax
  022b0	75 af		 jne	 SHORT $LN42@impl
  022b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  022b8	85 c0		 test	 eax, eax
  022ba	74 01		 je	 SHORT $LN100@impl
  022bc	cc		 int	 3
$LN100@impl:
$LN98@impl:
  022bd	33 c0		 xor	 eax, eax
  022bf	85 c0		 test	 eax, eax
  022c1	75 87		 jne	 SHORT $LN39@impl

; 1573 : 
; 1574 : #ifdef _MSVC_
; 1575 :     SetConsoleCtrlHandler( console_ctrl_handler, FALSE );

  022c3	33 d2		 xor	 edx, edx
  022c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:console_ctrl_handler
  022cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleCtrlHandler

; 1576 :     socket_deinit();

  022d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket_deinit

; 1577 : #endif
; 1578 :     fflush( stdout );

  022d8	b9 01 00 00 00	 mov	 ecx, 1
  022dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  022e3	48 8b c8	 mov	 rcx, rax
  022e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 1579 :     usleep( 10000 );

  022ec	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  022f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 1580 :     return 0; /* return back to bootstrap.c */

  022f7	33 c0		 xor	 eax, eax
$LN1@impl:

; 1581 : } /* end function impl */

  022f9	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  02301	48 33 cc	 xor	 rcx, rsp
  02304	e8 00 00 00 00	 call	 __security_check_cookie
  02309	48 81 c4 90 01
	00 00		 add	 rsp, 400		; 00000190H
  02310	5f		 pop	 rdi
  02311	c3		 ret	 0
impl	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
time	PROC

; 521  :         {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 522  :             return _time64(_Time);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Time$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__time64

; 523  :         }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
