; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
?unitck@?1??is_ch9oflow@@9@9 DB 0eH			; `is_ch9oflow'::`2'::unitck
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	s370_startio
PUBLIC	s370_execute_ccw_chain
PUBLIC	s390_execute_ccw_chain
PUBLIC	z900_execute_ccw_chain
PUBLIC	stchan_id
PUBLIC	testch
PUBLIC	testio
PUBLIC	test_subchan
PUBLIC	cancel_subchan
PUBLIC	clear_subchan
PUBLIC	halt_subchan
PUBLIC	haltio
PUBLIC	resume_subchan
PUBLIC	s370_present_io_interrupt
PUBLIC	s370_present_zone_io_interrupt
PUBLIC	io_reset
PUBLIC	chp_reset
PUBLIC	channelset_reset
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	fetch_dw_noswap
PUBLIC	shared_iowait
PUBLIC	device_attention
PUBLIC	s370_device_attention
PUBLIC	default_sns
PUBLIC	Queue_IO_Interrupt
PUBLIC	Queue_IO_Interrupt_QLocked
PUBLIC	Dequeue_IO_Interrupt
PUBLIC	Dequeue_IO_Interrupt_QLocked
PUBLIC	Update_IC_IOPENDING
PUBLIC	Update_IC_IOPENDING_QLocked
PUBLIC	_get_dev_storekey_ptr
PUBLIC	_get_dev_storekey1_ptr
PUBLIC	_get_dev_storekey2_ptr
PUBLIC	s370__get_dev_storage_key
PUBLIC	s370__or_dev_storage_key
PUBLIC	s370_get_dev_2K_storage_key
PUBLIC	s370_or_dev_2K_storage_key
PUBLIC	s370_get_dev_storage_key
PUBLIC	s370_or_dev_storage_key
PUBLIC	call_execute_ccw_chain
PUBLIC	device_thread
PUBLIC	test_subchan_locked
PUBLIC	perform_clear_subchan
PUBLIC	perform_halt_and_release_lock
PUBLIC	perform_halt
PUBLIC	s390_startio
PUBLIC	s390_present_io_interrupt
PUBLIC	s390_present_zone_io_interrupt
PUBLIC	s390__get_dev_storage_key
PUBLIC	s390__or_dev_storage_key
PUBLIC	s390_get_dev_4K_storage_key
PUBLIC	s390_or_dev_4K_storage_key
PUBLIC	s390_get_dev_storage_key
PUBLIC	s390_or_dev_storage_key
PUBLIC	s390_device_attention
PUBLIC	z900_startio
PUBLIC	z900_present_io_interrupt
PUBLIC	z900_present_zone_io_interrupt
PUBLIC	z900__get_dev_storage_key
PUBLIC	z900__or_dev_storage_key
PUBLIC	z900_get_dev_4K_storage_key
PUBLIC	z900_or_dev_4K_storage_key
PUBLIC	z900_get_dev_storage_key
PUBLIC	z900_or_dev_storage_key
PUBLIC	z900_device_attention
EXTRN	__report_rangecheckfailure:PROC
EXTRN	strcmp:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_GetCurrentThreadId:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp__aligned_free:PROC
EXTRN	__imp__aligned_malloc:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	longjmp:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp_fthread_self:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_hthread_create_thread:PROC
EXTRN	__imp_hthread_set_thread_prio:PROC
EXTRN	__imp_hthread_get_thread_prio:PROC
EXTRN	__imp_hthread_set_thread_name:PROC
EXTRN	__imp_timed_wait_condition_relative_usecs_impl:PROC
EXTRN	__imp_FormatORB:PROC
EXTRN	__imp_tf_1300:PROC
EXTRN	__imp_tf_1301:PROC
EXTRN	__imp_tf_1304:PROC
EXTRN	__imp_tf_1305:PROC
EXTRN	__imp_tf_1306:PROC
EXTRN	__imp_tf_1307:PROC
EXTRN	__imp_tf_1308:PROC
EXTRN	__imp_tf_1309:PROC
EXTRN	__imp_tf_1310:PROC
EXTRN	__imp_tf_1311:PROC
EXTRN	__imp_tf_1312:PROC
EXTRN	__imp_tf_1313:PROC
EXTRN	__imp_tf_1315:PROC
EXTRN	__imp_tf_1316:PROC
EXTRN	__imp_tf_1317:PROC
EXTRN	__imp_tf_1318:PROC
EXTRN	__imp_tf_1320:PROC
EXTRN	__imp_tf_1321:PROC
EXTRN	__imp_tf_1329:PROC
EXTRN	__imp_tf_1330:PROC
EXTRN	__imp_tf_1331:PROC
EXTRN	__imp_tf_1332:PROC
EXTRN	__imp_tf_1333:PROC
EXTRN	__imp_tf_1334:PROC
EXTRN	__imp_tf_1336:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_usleep:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_set_thread_name:PROC
EXTRN	__imp_prt_guest_to_host:PROC
EXTRN	build_chp_reset_chrpt:PROC
EXTRN	sclp_reset:PROC
EXTRN	insttrace_all:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
$SG170240 DB	01H DUP (?)
$SG170242 DB	01H DUP (?)
$SG170244 DB	01H DUP (?)
$SG170246 DB	01H DUP (?)
$SG170248 DB	01H DUP (?)
$SG170250 DB	01H DUP (?)
$SG170252 DB	01H DUP (?)
$SG170254 DB	01H DUP (?)
$SG170256 DB	01H DUP (?)
$SG170258 DB	01H DUP (?)
$SG170260 DB	01H DUP (?)
$SG170262 DB	01H DUP (?)
$SG170264 DB	01H DUP (?)
$SG170266 DB	01H DUP (?)
$SG170268 DB	01H DUP (?)
$SG170270 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
$pdata$s370_startio DD imagerel $LN31
	DD	imagerel $LN31+1931
	DD	imagerel $unwind$s370_startio
$pdata$s370_execute_ccw_chain DD imagerel $LN294
	DD	imagerel $LN294+12806
	DD	imagerel $unwind$s370_execute_ccw_chain
$pdata$s390_execute_ccw_chain DD imagerel $LN323
	DD	imagerel $LN323+14183
	DD	imagerel $unwind$s390_execute_ccw_chain
$pdata$z900_execute_ccw_chain DD imagerel $LN328
	DD	imagerel $LN328+14361
	DD	imagerel $unwind$z900_execute_ccw_chain
$pdata$stchan_id DD imagerel $LN18
	DD	imagerel $LN18+377
	DD	imagerel $unwind$stchan_id
$pdata$testch DD imagerel $LN13
	DD	imagerel $LN13+331
	DD	imagerel $unwind$testch
$pdata$testio DD imagerel $LN22
	DD	imagerel $LN22+782
	DD	imagerel $unwind$testio
$pdata$test_subchan DD imagerel $LN15
	DD	imagerel $LN15+848
	DD	imagerel $unwind$test_subchan
$pdata$cancel_subchan DD imagerel $LN23
	DD	imagerel $LN23+745
	DD	imagerel $unwind$cancel_subchan
$pdata$clear_subchan DD imagerel $LN21
	DD	imagerel $LN21+777
	DD	imagerel $unwind$clear_subchan
$pdata$halt_subchan DD imagerel $LN54
	DD	imagerel $LN54+2730
	DD	imagerel $unwind$halt_subchan
$pdata$haltio DD imagerel $LN30
	DD	imagerel $LN30+1508
	DD	imagerel $unwind$haltio
$pdata$resume_subchan DD imagerel $LN22
	DD	imagerel $LN22+692
	DD	imagerel $unwind$resume_subchan
$pdata$s370_present_io_interrupt DD imagerel $LN68
	DD	imagerel $LN68+1718
	DD	imagerel $unwind$s370_present_io_interrupt
$pdata$s370_present_zone_io_interrupt DD imagerel $LN34
	DD	imagerel $LN34+1130
	DD	imagerel $unwind$s370_present_zone_io_interrupt
$pdata$io_reset DD imagerel $LN22
	DD	imagerel $LN22+561
	DD	imagerel $unwind$io_reset
$pdata$chp_reset DD imagerel $LN12
	DD	imagerel $LN12+292
	DD	imagerel $unwind$chp_reset
$pdata$channelset_reset DD imagerel $LN9
	DD	imagerel $LN9+147
	DD	imagerel $unwind$channelset_reset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_dw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_dw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$shared_iowait DD imagerel $LN7
	DD	imagerel $LN7+174
	DD	imagerel $unwind$shared_iowait
$pdata$device_attention DD imagerel $LN14
	DD	imagerel $LN14+182
	DD	imagerel $unwind$device_attention
$pdata$s370_device_attention DD imagerel $LN22
	DD	imagerel $LN22+1214
	DD	imagerel $unwind$s370_device_attention
$pdata$default_sns DD imagerel $LN35
	DD	imagerel $LN35+1032
	DD	imagerel $unwind$default_sns
$pdata$Queue_IO_Interrupt DD imagerel $LN3
	DD	imagerel $LN3+101
	DD	imagerel $unwind$Queue_IO_Interrupt
$pdata$Queue_IO_Interrupt_QLocked DD imagerel $LN16
	DD	imagerel $LN16+452
	DD	imagerel $unwind$Queue_IO_Interrupt_QLocked
$pdata$Dequeue_IO_Interrupt DD imagerel $LN3
	DD	imagerel $LN3+100
	DD	imagerel $unwind$Dequeue_IO_Interrupt
$pdata$Dequeue_IO_Interrupt_QLocked DD imagerel $LN15
	DD	imagerel $LN15+288
	DD	imagerel $unwind$Dequeue_IO_Interrupt_QLocked
$pdata$Update_IC_IOPENDING DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$Update_IC_IOPENDING
$pdata$Update_IC_IOPENDING_QLocked DD imagerel $LN23
	DD	imagerel $LN23+513
	DD	imagerel $unwind$Update_IC_IOPENDING_QLocked
$pdata$__clear_page DD imagerel __clear_page
	DD	imagerel __clear_page+159
	DD	imagerel $unwind$__clear_page
$pdata$__clear_io_buffer DD imagerel __clear_io_buffer
	DD	imagerel __clear_io_buffer+236
	DD	imagerel $unwind$__clear_io_buffer
$pdata$store_scsw_as_csw DD imagerel store_scsw_as_csw
	DD	imagerel store_scsw_as_csw+125
	DD	imagerel $unwind$store_scsw_as_csw
$pdata$wakeup_cpu DD imagerel wakeup_cpu
	DD	imagerel wakeup_cpu+44
	DD	imagerel $unwind$wakeup_cpu
$pdata$wakeup_cpu_mask DD imagerel wakeup_cpu_mask
	DD	imagerel wakeup_cpu_mask+251
	DD	imagerel $unwind$wakeup_cpu_mask
$pdata$Interrupt_Lock_Obtained DD imagerel Interrupt_Lock_Obtained
	DD	imagerel Interrupt_Lock_Obtained+269
	DD	imagerel $unwind$Interrupt_Lock_Obtained
$pdata$Obtain_Interrupt_Lock DD imagerel Obtain_Interrupt_Lock
	DD	imagerel Obtain_Interrupt_Lock+88
	DD	imagerel $unwind$Obtain_Interrupt_Lock
$pdata$Release_Interrupt_Lock DD imagerel Release_Interrupt_Lock
	DD	imagerel Release_Interrupt_Lock+71
	DD	imagerel $unwind$Release_Interrupt_Lock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_get_dev_storekey_ptr DD imagerel $LN5
	DD	imagerel $LN5+106
	DD	imagerel $unwind$_get_dev_storekey_ptr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370__get_dev_storage_key DD imagerel $LN8
	DD	imagerel $LN8+140
	DD	imagerel $unwind$s370__get_dev_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370__or_dev_storage_key DD imagerel $LN8
	DD	imagerel $LN8+192
	DD	imagerel $unwind$s370__or_dev_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_get_dev_2K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$s370_get_dev_2K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_or_dev_2K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$s370_or_dev_2K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_get_dev_storage_key DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$s370_get_dev_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_or_dev_storage_key DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$s370_or_dev_storage_key
pdata	ENDS
pdata	SEGMENT
$pdata$is_ch9oflow DD imagerel is_ch9oflow
	DD	imagerel is_ch9oflow+203
	DD	imagerel $unwind$is_ch9oflow
$pdata$call_execute_ccw_chain DD imagerel $LN12
	DD	imagerel $LN12+108
	DD	imagerel $unwind$call_execute_ccw_chain
$pdata$device_thread DD imagerel $LN32
	DD	imagerel $LN32+1267
	DD	imagerel $unwind$device_thread
$pdata$schedule_ioq DD imagerel schedule_ioq
	DD	imagerel schedule_ioq+217
	DD	imagerel $unwind$schedule_ioq
$pdata$subchannel_interrupt_queue_cleanup DD imagerel subchannel_interrupt_queue_cleanup
	DD	imagerel subchannel_interrupt_queue_cleanup+242
	DD	imagerel $unwind$subchannel_interrupt_queue_cleanup
$pdata$test_subchan_locked DD imagerel $LN23
	DD	imagerel $LN23+668
	DD	imagerel $unwind$test_subchan_locked
$pdata$IS_CCW_IMMEDIATE DD imagerel IS_CCW_IMMEDIATE
	DD	imagerel IS_CCW_IMMEDIATE+154
	DD	imagerel $unwind$IS_CCW_IMMEDIATE
$pdata$set_device_busy DD imagerel set_device_busy
	DD	imagerel set_device_busy+50
	DD	imagerel $unwind$set_device_busy
$pdata$clear_subchannel_busy DD imagerel clear_subchannel_busy
	DD	imagerel clear_subchannel_busy+85
	DD	imagerel $unwind$clear_subchannel_busy
$pdata$clear_device_busy DD imagerel clear_device_busy
	DD	imagerel clear_device_busy+33
	DD	imagerel $unwind$clear_device_busy
$pdata$iobuf_create DD imagerel iobuf_create
	DD	imagerel iobuf_create+122
	DD	imagerel $unwind$iobuf_create
$pdata$iobuf_validate DD imagerel iobuf_validate
	DD	imagerel iobuf_validate+107
	DD	imagerel $unwind$iobuf_validate
$pdata$iobuf_destroy DD imagerel iobuf_destroy
	DD	imagerel iobuf_destroy+85
	DD	imagerel $unwind$iobuf_destroy
$pdata$iobuf_reallocate DD imagerel iobuf_reallocate
	DD	imagerel iobuf_reallocate+189
	DD	imagerel $unwind$iobuf_reallocate
$pdata$BytesToEndOfStorage DD imagerel BytesToEndOfStorage
	DD	imagerel BytesToEndOfStorage+152
	DD	imagerel $unwind$BytesToEndOfStorage
$pdata$scsw_clear_fc_Nc DD imagerel scsw_clear_fc_Nc
	DD	imagerel scsw_clear_fc_Nc+56
	DD	imagerel $unwind$scsw_clear_fc_Nc
$pdata$scsw_clear_ac_Nr DD imagerel scsw_clear_ac_Nr
	DD	imagerel scsw_clear_ac_Nr+104
	DD	imagerel $unwind$scsw_clear_ac_Nr
$pdata$AIPSX DD	imagerel AIPSX
	DD	imagerel AIPSX+97
	DD	imagerel $unwind$AIPSX
$pdata$queue_io_interrupt_and_update_status_locked DD imagerel queue_io_interrupt_and_update_status_locked
	DD	imagerel queue_io_interrupt_and_update_status_locked+267
	DD	imagerel $unwind$queue_io_interrupt_and_update_status_locked
$pdata$queue_io_interrupt_and_update_status DD imagerel queue_io_interrupt_and_update_status
	DD	imagerel queue_io_interrupt_and_update_status+307
	DD	imagerel $unwind$queue_io_interrupt_and_update_status
$pdata$_format_data DD imagerel _format_data
	DD	imagerel _format_data+947
	DD	imagerel $unwind$_format_data
$pdata$format_iobuf_data DD imagerel format_iobuf_data
	DD	imagerel format_iobuf_data+380
	DD	imagerel $unwind$format_iobuf_data
$pdata$_display_ccw DD imagerel _display_ccw
	DD	imagerel _display_ccw+1116
	DD	imagerel $unwind$_display_ccw
$pdata$_display_sense DD imagerel _display_sense
	DD	imagerel _display_sense+366
	DD	imagerel $unwind$_display_sense
$pdata$_display_idaw DD imagerel _display_idaw
	DD	imagerel _display_idaw+1268
	DD	imagerel $unwind$_display_idaw
$pdata$_display_csw DD imagerel _display_csw
	DD	imagerel _display_csw+593
	DD	imagerel $unwind$_display_csw
$pdata$_display_scsw DD imagerel _display_scsw
	DD	imagerel _display_scsw+828
	DD	imagerel $unwind$_display_scsw
$pdata$test_subchan_clear DD imagerel test_subchan_clear
	DD	imagerel test_subchan_clear+392
	DD	imagerel $unwind$test_subchan_clear
$pdata$perform_clear_subchan DD imagerel $LN12
	DD	imagerel $LN12+901
	DD	imagerel $unwind$perform_clear_subchan
$pdata$perform_halt_and_release_lock DD imagerel $LN25
	DD	imagerel $LN25+748
	DD	imagerel $unwind$perform_halt_and_release_lock
$pdata$perform_halt DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$perform_halt
$pdata$device_reset DD imagerel device_reset
	DD	imagerel device_reset+1417
	DD	imagerel $unwind$device_reset
$pdata$create_device_thread DD imagerel create_device_thread
	DD	imagerel create_device_thread+517
	DD	imagerel $unwind$create_device_thread
$pdata$ScheduleIORequest DD imagerel ScheduleIORequest
	DD	imagerel ScheduleIORequest+481
	DD	imagerel $unwind$ScheduleIORequest
$pdata$s370_raise_pci DD imagerel s370_raise_pci
	DD	imagerel s370_raise_pci+449
	DD	imagerel $unwind$s370_raise_pci
$pdata$s370_fetch_ccw DD imagerel s370_fetch_ccw
	DD	imagerel s370_fetch_ccw+612
	DD	imagerel $unwind$s370_fetch_ccw
$pdata$s370_fetch_idaw DD imagerel s370_fetch_idaw
	DD	imagerel s370_fetch_idaw+779
	DD	imagerel $unwind$s370_fetch_idaw
$pdata$s370_copy_iobuf DD imagerel s370_copy_iobuf
	DD	imagerel s370_copy_iobuf+4480
	DD	imagerel $unwind$s370_copy_iobuf
$pdata$execute_ccw_chain_fast_return DD imagerel execute_ccw_chain_fast_return
	DD	imagerel execute_ccw_chain_fast_return+51
	DD	imagerel $unwind$execute_ccw_chain_fast_return
$pdata$s370_interrupt_enabled DD imagerel s370_interrupt_enabled
	DD	imagerel s370_interrupt_enabled+428
	DD	imagerel $unwind$s370_interrupt_enabled
$pdata$s390_startio DD imagerel $LN31
	DD	imagerel $LN31+1931
	DD	imagerel $unwind$s390_startio
$pdata$s390_present_io_interrupt DD imagerel $LN68
	DD	imagerel $LN68+1718
	DD	imagerel $unwind$s390_present_io_interrupt
$pdata$s390_present_zone_io_interrupt DD imagerel $LN34
	DD	imagerel $LN34+1130
	DD	imagerel $unwind$s390_present_zone_io_interrupt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390__get_dev_storage_key DD imagerel $LN8
	DD	imagerel $LN8+129
	DD	imagerel $unwind$s390__get_dev_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390__or_dev_storage_key DD imagerel $LN8
	DD	imagerel $LN8+181
	DD	imagerel $unwind$s390__or_dev_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_get_dev_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$s390_get_dev_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_dev_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$s390_or_dev_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_get_dev_storage_key DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$s390_get_dev_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_dev_storage_key DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$s390_or_dev_storage_key
pdata	ENDS
pdata	SEGMENT
$pdata$s390_raise_pci DD imagerel s390_raise_pci
	DD	imagerel s390_raise_pci+443
	DD	imagerel $unwind$s390_raise_pci
$pdata$s390_fetch_ccw DD imagerel s390_fetch_ccw
	DD	imagerel s390_fetch_ccw+709
	DD	imagerel $unwind$s390_fetch_ccw
$pdata$s390_fetch_idaw DD imagerel s390_fetch_idaw
	DD	imagerel s390_fetch_idaw+989
	DD	imagerel $unwind$s390_fetch_idaw
$pdata$s390_copy_iobuf DD imagerel s390_copy_iobuf
	DD	imagerel s390_copy_iobuf+4538
	DD	imagerel $unwind$s390_copy_iobuf
$pdata$s390_device_attention DD imagerel $LN24
	DD	imagerel $LN24+1318
	DD	imagerel $unwind$s390_device_attention
$pdata$s390_interrupt_enabled DD imagerel s390_interrupt_enabled
	DD	imagerel s390_interrupt_enabled+340
	DD	imagerel $unwind$s390_interrupt_enabled
$pdata$z900_startio DD imagerel $LN31
	DD	imagerel $LN31+1931
	DD	imagerel $unwind$z900_startio
$pdata$z900_present_io_interrupt DD imagerel $LN87
	DD	imagerel $LN87+2329
	DD	imagerel $unwind$z900_present_io_interrupt
$pdata$z900_present_zone_io_interrupt DD imagerel $LN34
	DD	imagerel $LN34+1130
	DD	imagerel $unwind$z900_present_zone_io_interrupt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900__get_dev_storage_key DD imagerel $LN8
	DD	imagerel $LN8+129
	DD	imagerel $unwind$z900__get_dev_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900__or_dev_storage_key DD imagerel $LN8
	DD	imagerel $LN8+181
	DD	imagerel $unwind$z900__or_dev_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_get_dev_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$z900_get_dev_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_dev_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$z900_or_dev_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_get_dev_storage_key DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$z900_get_dev_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_dev_storage_key DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$z900_or_dev_storage_key
pdata	ENDS
pdata	SEGMENT
$pdata$z900_raise_pci DD imagerel z900_raise_pci
	DD	imagerel z900_raise_pci+443
	DD	imagerel $unwind$z900_raise_pci
$pdata$z900_fetch_ccw DD imagerel z900_fetch_ccw
	DD	imagerel z900_fetch_ccw+709
	DD	imagerel $unwind$z900_fetch_ccw
$pdata$z900_fetch_idaw DD imagerel z900_fetch_idaw
	DD	imagerel z900_fetch_idaw+962
	DD	imagerel $unwind$z900_fetch_idaw
$pdata$z900_fetch_midaw DD imagerel z900_fetch_midaw
	DD	imagerel z900_fetch_midaw+836
	DD	imagerel $unwind$z900_fetch_midaw
$pdata$z900_copy_iobuf DD imagerel z900_copy_iobuf
	DD	imagerel z900_copy_iobuf+6580
	DD	imagerel $unwind$z900_copy_iobuf
$pdata$z900_device_attention DD imagerel $LN24
	DD	imagerel $LN24+1318
	DD	imagerel $unwind$z900_device_attention
$pdata$z900_interrupt_enabled DD imagerel z900_interrupt_enabled
	DD	imagerel z900_interrupt_enabled+340
	DD	imagerel $unwind$z900_interrupt_enabled
pdata	ENDS
_DATA	SEGMENT
$SG169899 DB	'PRT', 00H
$SG170191 DB	'=>', 00H
	ORG $+1
$SG170098 DB	'channel.c:504', 00H
	ORG $+2
$SG170101 DB	'channel.c:508', 00H
	ORG $+2
$SG170102 DB	'channel.c:510', 00H
	ORG $+2
$SG170103 DB	'channel.c:519', 00H
	ORG $+2
$SG170106 DB	'channel.c:528', 00H
	ORG $+2
$SG170117 DB	'channel.c:551', 00H
	ORG $+2
$SG170118 DB	'channel.c:552', 00H
	ORG $+2
$SG170119 DB	'channel.c:556', 00H
	ORG $+2
$SG170120 DB	'channel.c:557', 00H
	ORG $+2
$SG170122 DB	'channel.c:566', 00H
	ORG $+2
$SG170124 DB	'channel.c:569', 00H
	ORG $+2
$SG170125 DB	'channel.c:570', 00H
	ORG $+2
$SG170239 DB	'IE ', 00H
	ORG $+4
$SG170156 DB	'%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2'
	DB	'X%2.2X %2.2X%2.2X%2.2X%2.2X', 00H
$SG170228 DB	'I', 00H
	ORG $+2
$SG170241 DB	'WRI ', 00H
	ORG $+3
$SG170229 DB	'HHC01315%s %1d:%04X CHAN: ccw %2.2X%2.2X%2.2X%2.2X %2.2X'
	DB	'%2.2X%2.2X%2.2X%s', 0aH, 00H
	ORG $+1
$SG170243 DB	'FP ', 00H
$SG170245 DB	'NRF ', 00H
	ORG $+3
$SG170247 DB	'MSG ', 00H
	ORG $+3
$SG170249 DB	'EOC ', 00H
	ORG $+3
$SG170251 DB	'ITF ', 00H
	ORG $+3
$SG170253 DB	'PERM ', 00H
	ORG $+2
$SG170255 DB	'OPRCK ', 00H
	ORG $+1
$SG170257 DB	'CTLCK ', 00H
	ORG $+1
$SG170259 DB	'OVRUN ', 00H
	ORG $+1
$SG170261 DB	'DATCK ', 00H
	ORG $+1
$SG170263 DB	'EQPCK ', 00H
	ORG $+1
$SG170265 DB	'BUSCK ', 00H
	ORG $+1
$SG170267 DB	'INTREQ ', 00H
$SG170269 DB	'CMDREJ ', 00H
$SG170271 DB	'%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s', 00H
	ORG $+3
$SG170285 DB	'I', 00H
	ORG $+2
$SG170286 DB	'HHC01314%s %1d:%04X CHAN: sense %s', 0aH, 00H
$SG170325 DB	'I', 00H
	ORG $+2
$SG170326 DB	'HHC01302%s %1d:%04X CHAN: idaw %8.8X, len %3.3hX%s', 0aH
	DB	00H
$SG170328 DB	'I', 00H
	ORG $+2
$SG170329 DB	'HHC01303%s %1d:%04X CHAN: idaw %16.16llX, len %4.4hX%s', 0aH
	DB	00H
$SG170331 DB	'I', 00H
	ORG $+2
$SG170347 DB	'I', 00H
	ORG $+2
$SG170332 DB	'HHC01301%s %1d:%04X CHAN: midaw %2.2X %4.4hX %16.16llX%s'
	DB	0aH, 00H
	ORG $+6
$SG170348 DB	'HHC01316%s %1d:%04X CHAN: csw %2.2X, stat %2.2X%2.2X, co'
	DB	'unt %2.2X%2.2X, ccw %2.2X%2.2X%2.2X', 0aH, 00H
	ORG $+3
$SG170365 DB	'I', 00H
	ORG $+6
$SG170429 DB	'channel.c:1249', 00H
	ORG $+1
$SG170448 DB	'testio', 00H
	ORG $+1
$SG170366 DB	'HHC01317%s %1d:%04X CHAN: scsw %2.2X%2.2X%2.2X%2.2X, sta'
	DB	't %2.2X%2.2X, count %2.2X%2.2X, ccw %2.2X%2.2X%2.2X%2.2X', 0aH
	DB	00H
	ORG $+2
$SG170446 DB	'I', 00H
	ORG $+2
$SG170430 DB	'channel.c:1250', 00H
	ORG $+1
$SG170440 DB	'channel.c:1274', 00H
	ORG $+1
$SG170441 DB	'channel.c:1277', 00H
	ORG $+1
$SG170442 DB	'channel.c:1287', 00H
	ORG $+1
$SG170447 DB	'HHC01318%s %1d:%04X CHAN: test I/O: cc=%d', 0aH, 00H
	ORG $+1
$SG170478 DB	'I', 00H
	ORG $+2
$SG170449 DB	'channel.c', 00H
	ORG $+2
$SG170480 DB	'haltio', 00H
	ORG $+1
$SG170504 DB	'I', 00H
	ORG $+2
$SG170450 DB	'channel.c:1303', 00H
	ORG $+1
$SG170451 DB	'channel.c:1304', 00H
	ORG $+1
$SG170479 DB	'HHC01329%s %1d:%04X CHAN: halt I/O', 0aH, 00H
$SG170624 DB	'I', 00H
	ORG $+2
$SG170481 DB	'channel.c', 00H
	ORG $+2
$SG170495 DB	'haltio', 00H
	ORG $+1
$SG170653 DB	'I', 00H
	ORG $+2
$SG170482 DB	'channel.c:1331', 00H
	ORG $+1
$SG170483 DB	'channel.c:1332', 00H
	ORG $+1
$SG170489 DB	'channel.c:1362', 00H
	ORG $+1
$SG170490 DB	'channel.c:1363', 00H
	ORG $+1
$SG170491 DB	'channel.c:1364', 00H
	ORG $+1
$SG170496 DB	'channel.c', 00H
	ORG $+2
$SG170502 DB	'haltio', 00H
	ORG $+1
$SG170677 DB	'I', 00H
	ORG $+2
$SG170503 DB	'channel.c', 00H
	ORG $+2
$SG170506 DB	'haltio', 00H
	ORG $+1
$SG170721 DB	'I', 00H
	ORG $+2
$SG170505 DB	'HHC01330%s %1d:%04X CHAN: HIO modification executed: cc='
	DB	'1', 0aH, 00H
	ORG $+1
$SG170751 DB	'I', 00H
	ORG $+2
$SG170507 DB	'channel.c', 00H
	ORG $+2
$SG170508 DB	'haltio', 00H
	ORG $+1
$SG170766 DB	'I', 00H
	ORG $+2
$SG170509 DB	'channel.c', 00H
	ORG $+2
$SG170776 DB	'I', 00H
	ORG $+2
$SG170510 DB	'channel.c:1433', 00H
	ORG $+1
$SG170511 DB	'channel.c:1434', 00H
	ORG $+1
$SG170528 DB	'channel.c:1461', 00H
	ORG $+1
$SG170531 DB	'channel.c:1468', 00H
	ORG $+1
$SG170535 DB	'channel.c:1481', 00H
	ORG $+1
$SG170540 DB	'channel.c:1509', 00H
	ORG $+1
$SG170544 DB	'channel.c:1536', 00H
	ORG $+1
$SG170592 DB	'channel.c:1693', 00H
	ORG $+1
$SG170594 DB	'test_subchan_locked', 00H
$SG170909 DB	'E', 00H
	ORG $+2
$SG170595 DB	'channel.c', 00H
	ORG $+2
$SG171021 DB	'I', 00H
	ORG $+2
$SG170608 DB	'channel.c:1753', 00H
	ORG $+1
$SG170609 DB	'channel.c:1754', 00H
	ORG $+1
$SG170613 DB	'channel.c:1762', 00H
	ORG $+1
$SG170614 DB	'channel.c:1763', 00H
	ORG $+1
$SG170617 DB	'channel.c:1774', 00H
	ORG $+1
$SG170618 DB	'channel.c:1775', 00H
	ORG $+1
$SG170619 DB	'channel.c:1782', 00H
	ORG $+1
$SG170620 DB	'channel.c:1788', 00H
	ORG $+1
$SG170625 DB	'HHC01318%s %1d:%04X CHAN: test I/O: cc=%d', 0aH, 00H
	ORG $+1
$SG171344 DB	'I', 00H
	ORG $+2
$SG170626 DB	'test_subchan', 00H
	ORG $+3
$SG170627 DB	'channel.c', 00H
	ORG $+2
$SG171353 DB	'I', 00H
	ORG $+2
$SG170628 DB	'channel.c:1801', 00H
	ORG $+1
$SG170629 DB	'channel.c:1802', 00H
	ORG $+1
$SG170644 DB	'channel.c:1828', 00H
	ORG $+1
$SG170645 DB	'channel.c:1829', 00H
	ORG $+1
$SG170646 DB	'channel.c:1834', 00H
	ORG $+1
$SG170647 DB	'channel.c:1838', 00H
	ORG $+1
$SG170648 DB	'channel.c:1865', 00H
	ORG $+1
$SG170649 DB	'channel.c:1868', 00H
	ORG $+1
$SG170654 DB	'HHC01308%s %1d:%04X CHAN: clear completed', 0aH, 00H
	ORG $+1
$SG171388 DB	'I', 00H
	ORG $+2
$SG170655 DB	'perform_clear_subchan', 00H
	ORG $+2
$SG170656 DB	'channel.c', 00H
	ORG $+2
$SG171397 DB	'I', 00H
	ORG $+2
$SG170659 DB	'channel.c:1885', 00H
	ORG $+1
$SG170678 DB	'HHC01331%s %1d:%04X CHAN: clear subchannel', 0aH, 00H
$SG171546 DB	'I', 00H
	ORG $+2
$SG170679 DB	'clear_subchan', 00H
	ORG $+2
$SG170680 DB	'channel.c', 00H
	ORG $+2
$SG171552 DB	'I', 00H
	ORG $+2
$SG170683 DB	'channel.c:1924', 00H
	ORG $+1
$SG170684 DB	'channel.c:1925', 00H
	ORG $+1
$SG170691 DB	'channel.c:1957', 00H
	ORG $+1
$SG170692 DB	'channel.c:1958', 00H
	ORG $+1
$SG170693 DB	'channel.c:1960', 00H
	ORG $+1
$SG170694 DB	'channel.c:1965', 00H
	ORG $+1
$SG170695 DB	'channel.c:1968', 00H
	ORG $+1
$SG170696 DB	'channel.c:1969', 00H
	ORG $+1
$SG170697 DB	'channel.c:1976', 00H
	ORG $+1
$SG170698 DB	'channel.c:1977', 00H
	ORG $+1
$SG170722 DB	'HHC01300%s %1d:%04X CHAN: halt subchannel: cc=%d', 0aH, 00H
	ORG $+2
$SG171577 DB	'I', 00H
	ORG $+2
$SG170723 DB	'perform_halt_and_release_lock', 00H
	ORG $+2
$SG170724 DB	'channel.c', 00H
	ORG $+2
$SG171588 DB	'I', 00H
	ORG $+2
$SG170725 DB	'channel.c:2066', 00H
	ORG $+1
$SG170732 DB	'channel.c:2087', 00H
	ORG $+1
$SG170733 DB	'channel.c:2088', 00H
	ORG $+1
$SG170734 DB	'channel.c:2090', 00H
	ORG $+1
$SG170752 DB	'HHC01332%s %1d:%04X CHAN: halt subchannel', 0aH, 00H
	ORG $+1
$SG171641 DB	'I', 00H
	ORG $+2
$SG170753 DB	'halt_subchan', 00H
	ORG $+3
$SG170754 DB	'channel.c', 00H
	ORG $+2
$SG171666 DB	'I', 00H
	ORG $+2
$SG170755 DB	'channel.c:2118', 00H
	ORG $+1
$SG170756 DB	'channel.c:2119', 00H
	ORG $+1
$SG170759 DB	'channel.c:2130', 00H
	ORG $+1
$SG170760 DB	'channel.c:2131', 00H
	ORG $+1
$SG170767 DB	'HHC01300%s %1d:%04X CHAN: halt subchannel: cc=%d', 0aH, 00H
	ORG $+2
$SG171679 DB	'I', 00H
	ORG $+2
$SG170768 DB	'halt_subchan', 00H
	ORG $+3
$SG170769 DB	'channel.c', 00H
	ORG $+2
$SG171753 DB	'I', 00H
	ORG $+2
$SG170770 DB	'channel.c:2155', 00H
	ORG $+1
$SG170771 DB	'channel.c:2156', 00H
	ORG $+1
$SG170777 DB	'HHC01300%s %1d:%04X CHAN: halt subchannel: cc=%d', 0aH, 00H
	ORG $+2
$SG171760 DB	'I', 00H
	ORG $+2
$SG170778 DB	'halt_subchan', 00H
	ORG $+3
$SG170779 DB	'channel.c', 00H
	ORG $+2
$SG182370 DB	'I', 00H
	ORG $+2
$SG170780 DB	'channel.c:2173', 00H
	ORG $+1
$SG170781 DB	'channel.c:2174', 00H
	ORG $+1
$SG170794 DB	'channel.c:2266', 00H
	ORG $+1
$SG170800 DB	'channel.c:2292', 00H
	ORG $+1
$SG170801 DB	'channel.c:2299', 00H
	ORG $+1
$SG170818 DB	'channel.c:2320', 00H
	ORG $+1
$SG170821 DB	'channel.c:2328', 00H
	ORG $+1
$SG170822 DB	'channel.c:2333', 00H
	ORG $+1
$SG170823 DB	'channel.c:2334', 00H
	ORG $+1
$SG170824 DB	'channel.c:2335', 00H
	ORG $+1
$SG170825 DB	'channel.c:2336', 00H
	ORG $+1
$SG170826 DB	'channel.c:2337', 00H
	ORG $+1
$SG170829 DB	'channel.c:2353', 00H
	ORG $+1
$SG170832 DB	'channel.c:2408', 00H
	ORG $+1
$SG170888 DB	'channel.c:2516', 00H
	ORG $+1
$SG170889 DB	'channel.c:2519', 00H
	ORG $+1
$SG170906 DB	'channel.c:2563', 00H
	ORG $+1
$SG170907 DB	'idle device thread', 00H
	ORG $+1
$SG182379 DB	'I', 00H
	ORG $+2
$SG170910 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+2
$SG182414 DB	'I', 00H
	ORG $+2
$SG170911 DB	'create_device_thread', 00H
	ORG $+3
$SG170912 DB	'channel.c', 00H
	ORG $+2
$SG182423 DB	'I', 00H
	ORG $+2
$SG170914 DB	'channel.c:2578', 00H
	ORG $+1
$SG170938 DB	'channel.c:2598', 00H
	ORG $+1
$SG170940 DB	'channel.c:2601', 00H
	ORG $+1
$SG170941 DB	'channel.c:2605', 00H
	ORG $+1
$SG170942 DB	'dev %4.4X thrd', 00H
	ORG $+1
$SG170943 DB	'channel.c:2637', 00H
	ORG $+1
$SG170945 DB	'channel.c:2643', 00H
	ORG $+1
$SG170947 DB	'channel.c:2653', 00H
	ORG $+1
$SG170948 DB	'channel.c:2659', 00H
	ORG $+1
$SG170953 DB	'idle dev thrd', 00H
	ORG $+2
$SG170954 DB	'idle dev thrd', 00H
	ORG $+2
$SG170955 DB	'channel.c:2682', 00H
	ORG $+1
$SG170957 DB	'channel.c:2692', 00H
	ORG $+1
$SG170958 DB	'channel.c:2701', 00H
	ORG $+1
$SG170977 DB	'channel.c:2740', 00H
	ORG $+1
$SG170987 DB	'channel.c:2811', 00H
	ORG $+1
$SG170996 DB	'channel.c:2858', 00H
	ORG $+1
$SG170999 DB	'channel.c:2864', 00H
	ORG $+1
$SG171000 DB	'channel.c:2866', 00H
	ORG $+1
$SG171008 DB	'channel.c:2892', 00H
	ORG $+1
$SG171011 DB	'channel.c:2899', 00H
	ORG $+1
$SG171022 DB	'HHC01333%s %1d:%04X CHAN: resume subchannel: cc=%d', 0aH
	DB	00H
$SG182545 DB	'I', 00H
	ORG $+2
$SG171023 DB	'resume_subchan', 00H
	ORG $+1
$SG171024 DB	'channel.c', 00H
	ORG $+2
$SG182551 DB	'I', 00H
	ORG $+2
$SG171025 DB	'channel.c:2956', 00H
	ORG $+1
$SG171031 DB	'channel.c:2974', 00H
	ORG $+1
$SG171055 DB	'channel.c:3013', 00H
	ORG $+1
$SG171056 DB	'channel.c:3014', 00H
	ORG $+1
$SG171057 DB	'channel.c:3030', 00H
	ORG $+1
$SG171058 DB	'channel.c:3031', 00H
	ORG $+1
$SG171059 DB	'channel.c:3036', 00H
	ORG $+1
$SG171060 DB	'channel.c:3037', 00H
	ORG $+1
$SG171061 DB	'channel.c:3038', 00H
	ORG $+1
$SG171285 DB	's370_copy_iobuf', 00H
$SG171286 DB	'channel.c', 00H
	ORG $+2
$SG182583 DB	'I', 00H
	ORG $+2
$SG171287 DB	's370_copy_iobuf', 00H
$SG171288 DB	'channel.c', 00H
	ORG $+2
$SG182594 DB	'I', 00H
	ORG $+2
$SG171334 DB	'channel.c:4067', 00H
	ORG $+1
$SG171335 DB	'channel.c:4068', 00H
	ORG $+1
$SG171345 DB	'HHC01304%s %1d:%04X CHAN: attention signaled', 0aH, 00H
	ORG $+2
$SG171346 DB	's370_device_attention', 00H
	ORG $+2
$SG171347 DB	'channel.c', 00H
	ORG $+2
$SG182647 DB	'I', 00H
	ORG $+2
$SG171348 DB	'channel.c:4122', 00H
	ORG $+1
$SG171349 DB	'channel.c:4123', 00H
	ORG $+1
$SG171354 DB	'HHC01305%s %1d:%04X CHAN: attention', 0aH, 00H
	ORG $+3
$SG171355 DB	's370_device_attention', 00H
	ORG $+2
$SG171356 DB	'channel.c', 00H
	ORG $+2
$SG182686 DB	'I', 00H
	ORG $+2
$SG171357 DB	'channel.c:4138', 00H
	ORG $+1
$SG171358 DB	'channel.c:4166', 00H
	ORG $+1
$SG171359 DB	'channel.c:4173', 00H
	ORG $+1
$SG171360 DB	'channel.c:4174', 00H
	ORG $+1
$SG171361 DB	'channel.c:4175', 00H
	ORG $+1
$SG171377 DB	'channel.c:4202', 00H
	ORG $+1
$SG171380 DB	'channel.c:4209', 00H
	ORG $+1
$SG171382 DB	'channel.c:4220', 00H
	ORG $+1
$SG171384 DB	'channel.c:4233', 00H
	ORG $+1
$SG171398 DB	'HHC01334%s %1d:%04X CHAN: ORB: %s', 0aH, 00H
	ORG $+5
$SG171389 DB	'HHC01336%s %1d:%04X CHAN: startio cc=2 (busy=%d startpen'
	DB	'ding=%d)', 0aH, 00H
	ORG $+2
$SG182699 DB	'I', 00H
	ORG $+2
$SG171390 DB	's370_startio', 00H
	ORG $+3
$SG171391 DB	'channel.c', 00H
	ORG $+2
$SG182773 DB	'I', 00H
	ORG $+2
$SG171399 DB	's370_startio', 00H
	ORG $+3
$SG171400 DB	'channel.c', 00H
	ORG $+2
$SG182780 DB	'I', 00H
	ORG $+2
$SG171401 DB	'channel.c:4323', 00H
	ORG $+1
$SG171533 DB	'channel.c:4431', 00H
	ORG $+1
$SG171536 DB	'channel.c:4455', 00H
	ORG $+1
$SG171548 DB	's370_execute_ccw_chain', 00H
	ORG $+1
$SG171547 DB	'HHC01321%s %1d:%04X CHAN: start I/O S/370 conversion to '
	DB	'asynchronous operation successful', 0aH, 00H
	ORG $+1
$SG196377 DB	'I', 00H
	ORG $+2
$SG171549 DB	'channel.c', 00H
	ORG $+2
$SG196386 DB	'I', 00H
	ORG $+2
$SG171553 DB	'HHC01311%s %1d:%04X CHAN: resumed', 0aH, 00H
	ORG $+1
$SG196421 DB	'I', 00H
	ORG $+2
$SG171554 DB	's370_execute_ccw_chain', 00H
	ORG $+1
$SG171555 DB	'channel.c', 00H
	ORG $+2
$SG196430 DB	'I', 00H
	ORG $+2
$SG171559 DB	'channel.c:4541', 00H
	ORG $+1
$SG171560 DB	'channel.c:4543', 00H
	ORG $+1
$SG171563 DB	'channel.c:4611', 00H
	ORG $+1
$SG171567 DB	'channel.c:4629', 00H
	ORG $+1
$SG171568 DB	'channel.c:4630', 00H
	ORG $+1
$SG171569 DB	'channel.c:4636', 00H
	ORG $+1
$SG171570 DB	'channel.c:4637', 00H
	ORG $+1
$SG171578 DB	'HHC01309%s %1d:%04X CHAN: halt completed', 0aH, 00H
	ORG $+2
$SG196552 DB	'I', 00H
	ORG $+2
$SG171579 DB	's370_execute_ccw_chain', 00H
	ORG $+1
$SG171580 DB	'channel.c', 00H
	ORG $+2
$SG196558 DB	'I', 00H
	ORG $+2
$SG171589 DB	'HHC01307%s %1d:%04X CHAN: attention completed', 0aH, 00H
	ORG $+1
$SG171590 DB	's370_execute_ccw_chain', 00H
	ORG $+1
$SG171591 DB	'channel.c', 00H
	ORG $+2
$SG196590 DB	'I', 00H
	ORG $+2
$SG171600 DB	's370_execute_ccw_chain', 00H
	ORG $+1
$SG171601 DB	'channel.c', 00H
	ORG $+2
$SG196601 DB	'I', 00H
	ORG $+2
$SG171632 DB	'channel.c:4990', 00H
	ORG $+1
$SG171633 DB	'channel.c:4991', 00H
	ORG $+1
$SG171642 DB	'HHC01310%s %1d:%04X CHAN: suspended', 0aH, 00H
	ORG $+3
$SG171643 DB	's370_execute_ccw_chain', 00H
	ORG $+1
$SG171644 DB	'channel.c', 00H
	ORG $+2
$SG196655 DB	'I', 00H
	ORG $+2
$SG171646 DB	'channel.c:5067', 00H
	ORG $+1
$SG171647 DB	'channel.c:5068', 00H
	ORG $+1
$SG171650 DB	'channel.c:5080', 00H
	ORG $+1
$SG171651 DB	'channel.c:5081', 00H
	ORG $+1
$SG171661 DB	'channel.c:5163', 00H
	ORG $+1
$SG171668 DB	's370_execute_ccw_chain', 00H
	ORG $+1
$SG171667 DB	'HHC01320%s %1d:%04X CHAN: start I/O S/370 conversion to '
	DB	'asynchronous operation started', 0aH, 00H
$SG171669 DB	'channel.c', 00H
	ORG $+2
$SG196698 DB	'I', 00H
	ORG $+2
$SG171670 DB	'channel.c:5193', 00H
	ORG $+1
$SG171673 DB	'channel.c:5217', 00H
	ORG $+1
$SG171674 DB	'channel.c:5229', 00H
	ORG $+1
$SG171680 DB	'HHC01306%s %1d:%04X CHAN: initial status interrupt', 0aH
	DB	00H
$SG196711 DB	'I', 00H
	ORG $+2
$SG171681 DB	's370_execute_ccw_chain', 00H
	ORG $+1
$SG171682 DB	'channel.c', 00H
	ORG $+2
$SG196785 DB	'I', 00H
	ORG $+2
$SG171734 DB	's370_execute_ccw_chain', 00H
	ORG $+1
$SG171735 DB	'channel.c', 00H
	ORG $+2
$SG196792 DB	'I', 00H
	ORG $+2
$SG171742 DB	's370_execute_ccw_chain', 00H
	ORG $+1
$SG171743 DB	'channel.c', 00H
	ORG $+6
$SG171745 DB	's370_execute_ccw_chain', 00H
	ORG $+1
$SG171746 DB	'channel.c', 00H
	ORG $+6
$SG171749 DB	's370_execute_ccw_chain', 00H
	ORG $+1
$SG171750 DB	'channel.c', 00H
	ORG $+6
$SG171754 DB	'HHC01312%s %1d:%04X CHAN: stat %2.2X%2.2X, count %4.4X', 0aH
	DB	00H
$SG171755 DB	's370_execute_ccw_chain', 00H
	ORG $+1
$SG171756 DB	'channel.c', 00H
	ORG $+14
$SG171761 DB	'HHC01313%s %1d:%04X CHAN: sense %2.2X%2.2X%2.2X%2.2X %2.'
	DB	'2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X %'
	DB	'2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X'
	DB	' %2.2X%2.2X%2.2X%2.2X', 0aH, 00H
	ORG $+7
$SG171762 DB	's370_execute_ccw_chain', 00H
	ORG $+1
$SG171763 DB	'channel.c', 00H
	ORG $+6
$SG171766 DB	's370_execute_ccw_chain', 00H
	ORG $+1
$SG171767 DB	'channel.c', 00H
	ORG $+6
$SG171778 DB	'channel.c:5809', 00H
	ORG $+1
$SG171779 DB	'channel.c:5810', 00H
	ORG $+1
$SG171790 DB	'channel.c:5876', 00H
	ORG $+1
$SG171791 DB	'channel.c:5877', 00H
	ORG $+1
$SG171793 DB	'channel.c:5885', 00H
	ORG $+1
$SG171794 DB	'channel.c:5886', 00H
	ORG $+1
$SG171895 DB	'channel.c:6075', 00H
	ORG $+1
$SG171901 DB	'channel.c:6128', 00H
	ORG $+1
$SG171904 DB	's370_present_io_interrupt', 00H
	ORG $+6
$SG171905 DB	'channel.c', 00H
	ORG $+6
$SG171906 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG171908 DB	's370_present_io_interrupt', 00H
	ORG $+6
$SG171909 DB	'channel.c', 00H
	ORG $+14
$SG171910 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG171916 DB	'channel.c:6171', 00H
	ORG $+1
$SG171917 DB	'channel.c:6175', 00H
	ORG $+1
$SG171918 DB	'channel.c:6178', 00H
	ORG $+1
$SG171919 DB	'channel.c:6186', 00H
	ORG $+1
$SG171922 DB	'channel.c:6193', 00H
	ORG $+1
$SG171923 DB	'channel.c:6194', 00H
	ORG $+1
$SG171928 DB	'channel.c:6283', 00H
	ORG $+1
$SG171933 DB	'channel.c:6316', 00H
	ORG $+1
$SG171934 DB	'channel.c:6341', 00H
	ORG $+1
$SG171988 DB	'channel.c:6377', 00H
	ORG $+1
$SG171992 DB	'channel.c:6407', 00H
	ORG $+1
$SG171994 DB	'channel.c:6417', 00H
	ORG $+1
$SG172000 DB	's370_present_zone_io_interrupt', 00H
	ORG $+1
$SG172001 DB	'channel.c', 00H
	ORG $+14
$SG172002 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG172004 DB	's370_present_zone_io_interrupt', 00H
	ORG $+1
$SG172005 DB	'channel.c', 00H
	ORG $+14
$SG172006 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG172008 DB	'channel.c:6448', 00H
	ORG $+1
$SG182065 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:3013', 00H
	ORG $+2
$SG182066 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:3014', 00H
	ORG $+2
$SG182067 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:3030', 00H
	ORG $+2
$SG182068 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:3031', 00H
	ORG $+2
$SG182069 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:3036', 00H
	ORG $+2
$SG182070 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:3037', 00H
	ORG $+2
$SG182071 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:3038', 00H
	ORG $+2
$SG182304 DB	's390_copy_iobuf', 00H
$SG182305 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG182306 DB	's390_copy_iobuf', 00H
$SG182307 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG182356 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4067', 00H
	ORG $+2
$SG182357 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4068', 00H
	ORG $+2
$SG182361 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4080', 00H
	ORG $+2
$SG182362 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4081', 00H
	ORG $+2
$SG182371 DB	'HHC01304%s %1d:%04X CHAN: attention signaled', 0aH, 00H
	ORG $+2
$SG182372 DB	's390_device_attention', 00H
	ORG $+2
$SG182373 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG182374 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4122', 00H
	ORG $+2
$SG182375 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4123', 00H
	ORG $+2
$SG182380 DB	'HHC01305%s %1d:%04X CHAN: attention', 0aH, 00H
	ORG $+3
$SG182381 DB	's390_device_attention', 00H
	ORG $+2
$SG182382 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG182383 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4138', 00H
	ORG $+2
$SG182384 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4166', 00H
	ORG $+2
$SG182385 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4173', 00H
	ORG $+2
$SG182386 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4174', 00H
	ORG $+2
$SG182387 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4175', 00H
	ORG $+2
$SG182403 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4202', 00H
	ORG $+2
$SG182406 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4209', 00H
	ORG $+2
$SG182408 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4220', 00H
	ORG $+2
$SG182410 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4233', 00H
	ORG $+2
$SG182415 DB	'HHC01336%s %1d:%04X CHAN: startio cc=2 (busy=%d startpen'
	DB	'ding=%d)', 0aH, 00H
	ORG $+6
$SG182416 DB	's390_startio', 00H
	ORG $+3
$SG182417 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG182424 DB	'HHC01334%s %1d:%04X CHAN: ORB: %s', 0aH, 00H
	ORG $+5
$SG182425 DB	's390_startio', 00H
	ORG $+3
$SG182426 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG182427 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4323', 00H
	ORG $+2
$SG182532 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4431', 00H
	ORG $+2
$SG182535 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4455', 00H
	ORG $+2
$SG182546 DB	'HHC01321%s %1d:%04X CHAN: start I/O S/370 conversion to '
	DB	'asynchronous operation successful', 0aH, 00H
	ORG $+5
$SG182547 DB	's390_execute_ccw_chain', 00H
	ORG $+1
$SG182548 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG182552 DB	'HHC01311%s %1d:%04X CHAN: resumed', 0aH, 00H
	ORG $+5
$SG182553 DB	's390_execute_ccw_chain', 00H
	ORG $+1
$SG182554 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG182558 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4541', 00H
	ORG $+2
$SG182559 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4543', 00H
	ORG $+2
$SG182569 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4611', 00H
	ORG $+2
$SG182573 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4629', 00H
	ORG $+2
$SG182574 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4630', 00H
	ORG $+2
$SG182575 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4636', 00H
	ORG $+2
$SG182576 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4637', 00H
	ORG $+2
$SG182584 DB	'HHC01309%s %1d:%04X CHAN: halt completed', 0aH, 00H
	ORG $+6
$SG182585 DB	's390_execute_ccw_chain', 00H
	ORG $+1
$SG182586 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG182595 DB	'HHC01307%s %1d:%04X CHAN: attention completed', 0aH, 00H
	ORG $+1
$SG182596 DB	's390_execute_ccw_chain', 00H
	ORG $+1
$SG182597 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG182606 DB	's390_execute_ccw_chain', 00H
	ORG $+1
$SG182607 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG182638 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4990', 00H
	ORG $+2
$SG182639 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4991', 00H
	ORG $+2
$SG182648 DB	'HHC01310%s %1d:%04X CHAN: suspended', 0aH, 00H
	ORG $+3
$SG182649 DB	's390_execute_ccw_chain', 00H
	ORG $+1
$SG182650 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG182652 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5067', 00H
	ORG $+2
$SG182653 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5068', 00H
	ORG $+2
$SG182656 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5080', 00H
	ORG $+2
$SG182657 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5081', 00H
	ORG $+2
$SG182681 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5163', 00H
	ORG $+2
$SG182687 DB	'HHC01320%s %1d:%04X CHAN: start I/O S/370 conversion to '
	DB	'asynchronous operation started', 0aH, 00H
$SG182688 DB	's390_execute_ccw_chain', 00H
	ORG $+1
$SG182689 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG182690 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5193', 00H
	ORG $+2
$SG182693 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5217', 00H
	ORG $+2
$SG182694 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5229', 00H
	ORG $+2
$SG182700 DB	'HHC01306%s %1d:%04X CHAN: initial status interrupt', 0aH
	DB	00H
	ORG $+4
$SG182701 DB	's390_execute_ccw_chain', 00H
	ORG $+1
$SG182702 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG182754 DB	's390_execute_ccw_chain', 00H
	ORG $+1
$SG182755 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG182762 DB	's390_execute_ccw_chain', 00H
	ORG $+1
$SG182763 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG182765 DB	's390_execute_ccw_chain', 00H
	ORG $+1
$SG182766 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG182769 DB	's390_execute_ccw_chain', 00H
	ORG $+1
$SG182770 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG182774 DB	'HHC01312%s %1d:%04X CHAN: stat %2.2X%2.2X, count %4.4X', 0aH
	DB	00H
$SG182775 DB	's390_execute_ccw_chain', 00H
	ORG $+1
$SG182776 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG182781 DB	'HHC01313%s %1d:%04X CHAN: sense %2.2X%2.2X%2.2X%2.2X %2.'
	DB	'2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X %'
	DB	'2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X'
	DB	' %2.2X%2.2X%2.2X%2.2X', 0aH, 00H
	ORG $+7
$SG182782 DB	's390_execute_ccw_chain', 00H
	ORG $+1
$SG182783 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG182786 DB	's390_execute_ccw_chain', 00H
	ORG $+1
$SG182787 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG182798 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5809', 00H
	ORG $+2
$SG182799 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5810', 00H
	ORG $+2
$SG182810 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5876', 00H
	ORG $+2
$SG182811 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5877', 00H
	ORG $+2
$SG182813 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5885', 00H
	ORG $+2
$SG182814 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5886', 00H
	ORG $+2
$SG182908 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6075', 00H
	ORG $+2
$SG182914 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6128', 00H
	ORG $+2
$SG182917 DB	's390_present_io_interrupt', 00H
	ORG $+6
$SG182918 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG182919 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG182921 DB	's390_present_io_interrupt', 00H
	ORG $+6
$SG182922 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG182929 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6171', 00H
	ORG $+10
$SG182923 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG182930 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6175', 00H
	ORG $+2
$SG182931 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6178', 00H
	ORG $+2
$SG182932 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6186', 00H
	ORG $+2
$SG182935 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6193', 00H
	ORG $+2
$SG182936 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6194', 00H
	ORG $+2
$SG182941 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6283', 00H
	ORG $+2
$SG182946 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6316', 00H
	ORG $+2
$SG182947 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6341', 00H
	ORG $+2
$SG183001 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6377', 00H
	ORG $+2
$SG183005 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6407', 00H
	ORG $+2
$SG183007 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6417', 00H
	ORG $+2
$SG183013 DB	's390_present_zone_io_interrupt', 00H
	ORG $+1
$SG183014 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG183017 DB	's390_present_zone_io_interrupt', 00H
	ORG $+9
$SG183015 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG183018 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG183021 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6448', 00H
	ORG $+10
$SG183019 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG195955 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:3013', 00H
	ORG $+2
$SG195956 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:3014', 00H
	ORG $+2
$SG195957 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:3030', 00H
	ORG $+2
$SG195958 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:3031', 00H
	ORG $+2
$SG195959 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:3036', 00H
	ORG $+2
$SG195960 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:3037', 00H
	ORG $+2
$SG195961 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:3038', 00H
	ORG $+2
$SG196256 DB	'z900_copy_iobuf', 00H
$SG196257 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG196258 DB	'z900_copy_iobuf', 00H
$SG196259 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG196311 DB	'z900_copy_iobuf', 00H
$SG196312 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG196313 DB	'z900_copy_iobuf', 00H
$SG196314 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG196363 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4067', 00H
	ORG $+2
$SG196364 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4068', 00H
	ORG $+2
$SG196368 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4080', 00H
	ORG $+2
$SG196369 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4081', 00H
	ORG $+2
$SG196378 DB	'HHC01304%s %1d:%04X CHAN: attention signaled', 0aH, 00H
	ORG $+2
$SG196379 DB	'z900_device_attention', 00H
	ORG $+2
$SG196380 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG196381 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4122', 00H
	ORG $+2
$SG196382 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4123', 00H
	ORG $+2
$SG196387 DB	'HHC01305%s %1d:%04X CHAN: attention', 0aH, 00H
	ORG $+3
$SG196388 DB	'z900_device_attention', 00H
	ORG $+2
$SG196389 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG196390 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4138', 00H
	ORG $+2
$SG196391 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4166', 00H
	ORG $+2
$SG196392 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4173', 00H
	ORG $+2
$SG196393 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4174', 00H
	ORG $+2
$SG196394 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4175', 00H
	ORG $+2
$SG196410 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4202', 00H
	ORG $+2
$SG196413 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4209', 00H
	ORG $+2
$SG196415 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4220', 00H
	ORG $+2
$SG196417 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4233', 00H
	ORG $+2
$SG196422 DB	'HHC01336%s %1d:%04X CHAN: startio cc=2 (busy=%d startpen'
	DB	'ding=%d)', 0aH, 00H
	ORG $+6
$SG196423 DB	'z900_startio', 00H
	ORG $+3
$SG196424 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG196431 DB	'HHC01334%s %1d:%04X CHAN: ORB: %s', 0aH, 00H
	ORG $+5
$SG196432 DB	'z900_startio', 00H
	ORG $+3
$SG196433 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG196434 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4323', 00H
	ORG $+2
$SG196539 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4431', 00H
	ORG $+2
$SG196542 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4455', 00H
	ORG $+2
$SG196553 DB	'HHC01321%s %1d:%04X CHAN: start I/O S/370 conversion to '
	DB	'asynchronous operation successful', 0aH, 00H
	ORG $+5
$SG196554 DB	'z900_execute_ccw_chain', 00H
	ORG $+1
$SG196555 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG196559 DB	'HHC01311%s %1d:%04X CHAN: resumed', 0aH, 00H
	ORG $+5
$SG196560 DB	'z900_execute_ccw_chain', 00H
	ORG $+1
$SG196561 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG196565 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4541', 00H
	ORG $+2
$SG196566 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4543', 00H
	ORG $+2
$SG196576 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4611', 00H
	ORG $+2
$SG196580 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4629', 00H
	ORG $+2
$SG196581 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4630', 00H
	ORG $+2
$SG196582 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4636', 00H
	ORG $+2
$SG196583 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4637', 00H
	ORG $+2
$SG196591 DB	'HHC01309%s %1d:%04X CHAN: halt completed', 0aH, 00H
	ORG $+6
$SG196592 DB	'z900_execute_ccw_chain', 00H
	ORG $+1
$SG196593 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG196602 DB	'HHC01307%s %1d:%04X CHAN: attention completed', 0aH, 00H
	ORG $+1
$SG196603 DB	'z900_execute_ccw_chain', 00H
	ORG $+1
$SG196604 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG196613 DB	'z900_execute_ccw_chain', 00H
	ORG $+1
$SG196614 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG196646 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4990', 00H
	ORG $+2
$SG196647 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:4991', 00H
	ORG $+2
$SG196656 DB	'HHC01310%s %1d:%04X CHAN: suspended', 0aH, 00H
	ORG $+3
$SG196657 DB	'z900_execute_ccw_chain', 00H
	ORG $+1
$SG196658 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG196660 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5067', 00H
	ORG $+2
$SG196661 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5068', 00H
	ORG $+2
$SG196664 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5080', 00H
	ORG $+2
$SG196665 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5081', 00H
	ORG $+2
$SG196693 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5163', 00H
	ORG $+2
$SG196699 DB	'HHC01320%s %1d:%04X CHAN: start I/O S/370 conversion to '
	DB	'asynchronous operation started', 0aH, 00H
$SG196700 DB	'z900_execute_ccw_chain', 00H
	ORG $+1
$SG196701 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG196702 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5193', 00H
	ORG $+2
$SG196705 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5217', 00H
	ORG $+2
$SG196706 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5229', 00H
	ORG $+2
$SG196712 DB	'HHC01306%s %1d:%04X CHAN: initial status interrupt', 0aH
	DB	00H
	ORG $+4
$SG196713 DB	'z900_execute_ccw_chain', 00H
	ORG $+1
$SG196714 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG196766 DB	'z900_execute_ccw_chain', 00H
	ORG $+1
$SG196767 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG196774 DB	'z900_execute_ccw_chain', 00H
	ORG $+1
$SG196775 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG196777 DB	'z900_execute_ccw_chain', 00H
	ORG $+1
$SG196778 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG196781 DB	'z900_execute_ccw_chain', 00H
	ORG $+1
$SG196782 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG196786 DB	'HHC01312%s %1d:%04X CHAN: stat %2.2X%2.2X, count %4.4X', 0aH
	DB	00H
$SG196787 DB	'z900_execute_ccw_chain', 00H
	ORG $+1
$SG196788 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG196793 DB	'HHC01313%s %1d:%04X CHAN: sense %2.2X%2.2X%2.2X%2.2X %2.'
	DB	'2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X %'
	DB	'2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X'
	DB	' %2.2X%2.2X%2.2X%2.2X', 0aH, 00H
	ORG $+7
$SG196794 DB	'z900_execute_ccw_chain', 00H
	ORG $+1
$SG196795 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG196798 DB	'z900_execute_ccw_chain', 00H
	ORG $+1
$SG196799 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG196810 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5809', 00H
	ORG $+2
$SG196811 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5810', 00H
	ORG $+2
$SG196822 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5876', 00H
	ORG $+2
$SG196823 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5877', 00H
	ORG $+2
$SG196825 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5885', 00H
	ORG $+2
$SG196826 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:5886', 00H
	ORG $+2
$SG196948 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6075', 00H
	ORG $+2
$SG196954 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6128', 00H
	ORG $+2
$SG196957 DB	'z900_present_io_interrupt', 00H
	ORG $+6
$SG196958 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG196959 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG196961 DB	'z900_present_io_interrupt', 00H
	ORG $+6
$SG196962 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG196969 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6171', 00H
	ORG $+10
$SG196963 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG196970 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6175', 00H
	ORG $+2
$SG196971 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6178', 00H
	ORG $+2
$SG196972 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6186', 00H
	ORG $+2
$SG196975 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6193', 00H
	ORG $+2
$SG196976 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6194', 00H
	ORG $+2
$SG196981 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6234', 00H
	ORG $+2
$SG196989 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6283', 00H
	ORG $+2
$SG196994 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6316', 00H
	ORG $+2
$SG196995 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6341', 00H
	ORG $+2
$SG197049 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6377', 00H
	ORG $+2
$SG197053 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6407', 00H
	ORG $+2
$SG197055 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6417', 00H
	ORG $+2
$SG197061 DB	'z900_present_zone_io_interrupt', 00H
	ORG $+1
$SG197062 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG197065 DB	'z900_present_zone_io_interrupt', 00H
	ORG $+9
$SG197063 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG197066 DB	'C:\papa\MyGit\hyperion-zvector\channel.c', 00H
	ORG $+7
$SG197069 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6448', 00H
	ORG $+10
$SG197067 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG197115 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6545', 00H
	ORG $+2
$SG197116 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6547', 00H
	ORG $+2
$SG197146 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6608', 00H
	ORG $+2
$SG197147 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6610', 00H
	ORG $+2
$SG197170 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6664', 00H
	ORG $+2
$SG197171 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6666', 00H
	ORG $+2
$SG197208 DB	'C:\papa\MyGit\hyperion-zvector\channel.c:6677', 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_dev_storage_key DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_get_dev_storage_key DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_dev_4K_storage_key DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_get_dev_4K_storage_key DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900__or_dev_storage_key DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900__get_dev_storage_key DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_dev_storage_key DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_get_dev_storage_key DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_dev_4K_storage_key DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_get_dev_4K_storage_key DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390__or_dev_storage_key DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390__get_dev_storage_key DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_or_dev_storage_key DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_get_dev_storage_key DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_or_dev_2K_storage_key DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_get_dev_2K_storage_key DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370__or_dev_storage_key DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370__get_dev_storage_key DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_get_dev_storekey_ptr DD 011301H
	DD	02213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_dw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:__clear_page
	DD	095H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_present_io_interrupt
	DD	025H
	DD	0901H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_startio
	DD	022H
	DD	0771H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_present_io_interrupt
	DD	025H
	DD	069eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_startio
	DD	022H
	DD	0771H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:_display_scsw
	DD	02bH
	DD	031eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:_display_idaw
	DD	024H
	DD	04dcH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:_display_sense
	DD	025H
	DD	0156H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:_display_ccw
	DD	027H
	DD	0442H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:format_iobuf_data
	DD	024H
	DD	0168H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:device_thread
	DD	013H
	DD	04e1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_present_io_interrupt
	DD	025H
	DD	069eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:testio
	DD	020H
	DD	02f6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_execute_ccw_chain
	DD	037H
	DD	037f6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_execute_ccw_chain
	DD	037H
	DD	03744H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_execute_ccw_chain
	DD	037H
	DD	031e3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_startio
	DD	022H
	DD	0771H
voltbl	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$s370_startio DD 042a19H
	DD	0250118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$s370_execute_ccw_chain DD 0a3e19H
	DD	02835011eH
	DD	0e00ff011H
	DD	0c00bd00dH
	DD	060087009H
	DD	050063007H
	DD	imagerel __GSHandlerCheck
	DD	013044H
	DD	01150H
	DD	01000H
$unwind$s390_execute_ccw_chain DD 0a3e19H
	DD	02835011eH
	DD	0e00ff011H
	DD	0c00bd00dH
	DD	060087009H
	DD	050063007H
	DD	imagerel __GSHandlerCheck
	DD	013044H
	DD	01150H
	DD	01000H
$unwind$z900_execute_ccw_chain DD 0a3e19H
	DD	02835011eH
	DD	0e00ff011H
	DD	0c00bd00dH
	DD	060087009H
	DD	050063007H
	DD	imagerel __GSHandlerCheck
	DD	013044H
	DD	01150H
	DD	01000H
$unwind$stchan_id DD 010e01H
	DD	0820eH
$unwind$testch DD 010e01H
	DD	0220eH
$unwind$testio DD 022819H
	DD	0190116H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$test_subchan DD 011301H
	DD	0e213H
$unwind$cancel_subchan DD 010e01H
	DD	0620eH
$unwind$clear_subchan DD 010e01H
	DD	0c20eH
$unwind$halt_subchan DD 021101H
	DD	0110111H
$unwind$haltio DD 011301H
	DD	0e213H
$unwind$resume_subchan DD 010e01H
	DD	0c20eH
$unwind$s370_present_io_interrupt DD 022d19H
	DD	01f011bH
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$s370_present_zone_io_interrupt DD 011801H
	DD	0a218H
$unwind$io_reset DD 010401H
	DD	08204H
$unwind$chp_reset DD 010c01H
	DD	0620cH
$unwind$channelset_reset DD 010901H
	DD	06209H
$unwind$shared_iowait DD 010901H
	DD	06209H
$unwind$device_attention DD 010d01H
	DD	0620dH
$unwind$s370_device_attention DD 010d01H
	DD	0e20dH
$unwind$default_sns DD 021b01H
	DD	025011bH
$unwind$Queue_IO_Interrupt DD 011201H
	DD	04212H
$unwind$Queue_IO_Interrupt_QLocked DD 011201H
	DD	02212H
$unwind$Dequeue_IO_Interrupt DD 010e01H
	DD	0620eH
$unwind$Dequeue_IO_Interrupt_QLocked DD 010e01H
	DD	0220eH
$unwind$Update_IC_IOPENDING DD 010401H
	DD	04204H
$unwind$Update_IC_IOPENDING_QLocked DD 010401H
	DD	0a204H
$unwind$__clear_page DD 010e01H
	DD	0420eH
$unwind$__clear_io_buffer DD 020f01H
	DD	0700b720fH
$unwind$store_scsw_as_csw DD 010e01H
	DD	0820eH
$unwind$wakeup_cpu DD 010e01H
	DD	0420eH
$unwind$wakeup_cpu_mask DD 010e01H
	DD	0a20eH
$unwind$Interrupt_Lock_Obtained DD 010e01H
	DD	0420eH
$unwind$Obtain_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$Release_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$is_ch9oflow DD 011201H
	DD	06212H
$unwind$call_execute_ccw_chain DD 010d01H
	DD	0620dH
$unwind$device_thread DD 011819H
	DD	0e209H
	DD	imagerel __GSHandlerCheck
	DD	068H
$unwind$schedule_ioq DD 010e01H
	DD	0620eH
$unwind$subchannel_interrupt_queue_cleanup DD 010901H
	DD	02209H
$unwind$test_subchan_locked DD 031a01H
	DD	07016c21aH
	DD	06015H
$unwind$IS_CCW_IMMEDIATE DD 010d01H
	DD	0220dH
$unwind$set_device_busy DD 010901H
	DD	04209H
$unwind$clear_subchannel_busy DD 010901H
	DD	04209H
$unwind$clear_device_busy DD 010901H
	DD	04209H
$unwind$iobuf_create DD 010801H
	DD	06208H
$unwind$iobuf_validate DD 010901H
	DD	02209H
$unwind$iobuf_destroy DD 010901H
	DD	06209H
$unwind$iobuf_reallocate DD 030f01H
	DD	0700b820fH
	DD	0600aH
$unwind$BytesToEndOfStorage DD 010e01H
	DD	0220eH
$unwind$scsw_clear_fc_Nc DD 010901H
	DD	04209H
$unwind$scsw_clear_ac_Nr DD 010901H
	DD	04209H
$unwind$AIPSX DD 010901H
	DD	02209H
$unwind$queue_io_interrupt_and_update_status_locked DD 010d01H
	DD	0420dH
$unwind$queue_io_interrupt_and_update_status DD 010d01H
	DD	0620dH
$unwind$_format_data DD 0a2601H
	DD	0190126H
	DD	0e01df01fH
	DD	0c019d01bH
	DD	060167017H
	DD	030145015H
$unwind$format_iobuf_data DD 032919H
	DD	07016e21aH
	DD	06015H
	DD	imagerel __GSHandlerCheck
	DD	068H
$unwind$_display_ccw DD 042f19H
	DD	027011dH
	DD	030157016H
	DD	imagerel __GSHandlerCheck
	DD	0120H
$unwind$_display_sense DD 022d19H
	DD	01f011bH
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$_display_idaw DD 022c19H
	DD	025011aH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$_display_csw DD 041d01H
	DD	017011dH
	DD	030157016H
$unwind$_display_scsw DD 073319H
	DD	0200121H
	DD	07018e01aH
	DD	050166017H
	DD	03015H
	DD	imagerel __GSHandlerCheck
	DD	0f8H
$unwind$test_subchan_clear DD 010e01H
	DD	0620eH
$unwind$perform_clear_subchan DD 010901H
	DD	0c209H
$unwind$perform_halt_and_release_lock DD 010901H
	DD	0c209H
$unwind$perform_halt DD 010901H
	DD	04209H
$unwind$device_reset DD 020a01H
	DD	07006520aH
$unwind$create_device_thread DD 010401H
	DD	0c204H
$unwind$ScheduleIORequest DD 010901H
	DD	0a209H
$unwind$s370_raise_pci DD 011701H
	DD	06217H
$unwind$s370_fetch_ccw DD 011701H
	DD	06217H
$unwind$s370_fetch_idaw DD 011701H
	DD	0a217H
$unwind$s370_copy_iobuf DD 041d01H
	DD	01f011dH
	DD	060157016H
$unwind$execute_ccw_chain_fast_return DD 011301H
	DD	04213H
$unwind$s370_interrupt_enabled DD 010e01H
	DD	0220eH
$unwind$s390_startio DD 042a19H
	DD	0250118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$s390_present_io_interrupt DD 022d19H
	DD	01f011bH
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$s390_present_zone_io_interrupt DD 011801H
	DD	0a218H
$unwind$s390_raise_pci DD 011701H
	DD	06217H
$unwind$s390_fetch_ccw DD 011701H
	DD	06217H
$unwind$s390_fetch_idaw DD 011701H
	DD	0a217H
$unwind$s390_copy_iobuf DD 041d01H
	DD	01f011dH
	DD	060157016H
$unwind$s390_device_attention DD 010d01H
	DD	0e20dH
$unwind$s390_interrupt_enabled DD 010e01H
	DD	0220eH
$unwind$z900_startio DD 042a19H
	DD	0250118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$z900_present_io_interrupt DD 022d19H
	DD	023011bH
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$z900_present_zone_io_interrupt DD 011801H
	DD	0a218H
$unwind$z900_raise_pci DD 011701H
	DD	06217H
$unwind$z900_fetch_ccw DD 011701H
	DD	06217H
$unwind$z900_fetch_idaw DD 011701H
	DD	0a217H
$unwind$z900_fetch_midaw DD 011701H
	DD	0a217H
$unwind$z900_copy_iobuf DD 041d01H
	DD	023011dH
	DD	060157016H
$unwind$z900_device_attention DD 010d01H
	DD	0e20dH
$unwind$z900_interrupt_enabled DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv133 = 0
tv145 = 4
i$ = 8
regs$ = 32
dev$ = 40
z900_interrupt_enabled PROC

; 5914 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 5915 : int     i;                              /* Interruption subclass     */
; 5916 : 
; 5917 :     /* Ignore this device if subchannel not valid */
; 5918 :     if (!(dev->pmcw.flag5 & PMCW5_V))

  0000e	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00013	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0001a	83 e0 01	 and	 eax, 1
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN2@z900_inter

; 5919 :         return 0;

  00021	33 c0		 xor	 eax, eax
  00023	e9 27 01 00 00	 jmp	 $LN1@z900_inter
$LN2@z900_inter:

; 5920 : 
; 5921 : #if defined(_FEATURE_IO_ASSIST)
; 5922 :     /* For I/O Assist the zone must match the guest zone */
; 5923 :     if(SIE_MODE(regs) && regs->siebk->zone != dev->pmcw.zone)

  00028	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  0002d	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00033	d1 e8		 shr	 eax, 1
  00035	83 e0 01	 and	 eax, 1
  00038	85 c0		 test	 eax, eax
  0003a	74 27		 je	 SHORT $LN3@z900_inter
  0003c	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00041	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00048	0f b6 40 74	 movzx	 eax, BYTE PTR [rax+116]
  0004c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dev$[rsp]
  00051	0f b6 89 04 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+772]
  00058	3b c1		 cmp	 eax, ecx
  0005a	74 07		 je	 SHORT $LN3@z900_inter

; 5924 :         return 0;

  0005c	33 c0		 xor	 eax, eax
  0005e	e9 ec 00 00 00	 jmp	 $LN1@z900_inter
$LN3@z900_inter:

; 5925 : #endif
; 5926 : 
; 5927 : #if defined(_FEATURE_IO_ASSIST)
; 5928 :     /* The interrupt interlock control bit must be on
; 5929 :        if not we must intercept */
; 5930 :     if(SIE_MODE(regs) && !(dev->pmcw.flag27 & PMCW27_I))

  00063	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00068	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0006e	d1 e8		 shr	 eax, 1
  00070	83 e0 01	 and	 eax, 1
  00073	85 c0		 test	 eax, eax
  00075	74 1f		 je	 SHORT $LN4@z900_inter
  00077	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0007c	0f b6 80 07 03
	00 00		 movzx	 eax, BYTE PTR [rax+775]
  00083	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00088	85 c0		 test	 eax, eax
  0008a	75 0a		 jne	 SHORT $LN4@z900_inter

; 5931 :         return SIE_INTERCEPT_IOINT;

  0008c	b8 f1 ff ff ff	 mov	 eax, -15
  00091	e9 b9 00 00 00	 jmp	 $LN1@z900_inter
$LN4@z900_inter:

; 5932 : #endif
; 5933 : 
; 5934 : #ifdef FEATURE_S370_CHANNEL
; 5935 : 
; 5936 : #if defined(FEATURE_CHANNEL_SWITCHING)
; 5937 :     /* Is this device on a channel connected to this CPU? */
; 5938 :     if(
; 5939 : #if defined(_FEATURE_IO_ASSIST)
; 5940 :        !SIE_MODE(regs) &&
; 5941 : #endif
; 5942 :        regs->chanset != dev->chanset)
; 5943 :         return 0;
; 5944 : #endif /*defined(FEATURE_CHANNEL_SWITCHING)*/
; 5945 : 
; 5946 :     /* Isolate the channel number */
; 5947 :     i = dev->devnum >> 8;
; 5948 :     if (!ECMODE(&regs->psw) && i < 6)
; 5949 :     {
; 5950 : #if defined(_FEATURE_IO_ASSIST)
; 5951 :         /* We must always intercept in BC mode */
; 5952 :         if(SIE_MODE(regs))
; 5953 :             return SIE_INTERCEPT_IOINT;
; 5954 : #endif
; 5955 :         /* For BC mode channels 0-5, test system mask bits 0-5 */
; 5956 :         if ((regs->psw.sysmask & (0x80 >> i)) == 0)
; 5957 :             return 0;
; 5958 :     }
; 5959 :     else
; 5960 :     {
; 5961 :         /* For EC mode and channels 6-31, test system mask bit 6 */
; 5962 :         if ((regs->psw.sysmask & PSW_IOMASK) == 0)
; 5963 :             return 0;
; 5964 : 
; 5965 :         /* If I/O mask is enabled, test channel masks in CR2 */
; 5966 :         if (i > 31) i = 31;
; 5967 :         if ((CHANNEL_MASKS(regs) & (0x80000000 >> i)) == 0)
; 5968 :             return
; 5969 : #if defined(_FEATURE_IO_ASSIST)
; 5970 :                    SIE_MODE(regs) ? SIE_INTERCEPT_IOINTP :
; 5971 : #endif
; 5972 :                                                            0;
; 5973 :     }
; 5974 : #endif /*FEATURE_S370_CHANNEL*/
; 5975 : 
; 5976 : #ifdef FEATURE_CHANNEL_SUBSYSTEM
; 5977 :     /* Ignore this device if subchannel not enabled */
; 5978 :     if (!(dev->pmcw.flag5 & PMCW5_E))

  00096	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0009b	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  000a2	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000a7	85 c0		 test	 eax, eax
  000a9	75 07		 jne	 SHORT $LN5@z900_inter

; 5979 :         return 0;

  000ab	33 c0		 xor	 eax, eax
  000ad	e9 9d 00 00 00	 jmp	 $LN1@z900_inter
$LN5@z900_inter:

; 5980 : 
; 5981 :     /* Isolate the interruption subclass */
; 5982 :     i =

  000b2	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  000b7	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000bd	d1 e8		 shr	 eax, 1
  000bf	83 e0 01	 and	 eax, 1
  000c2	85 c0		 test	 eax, eax
  000c4	74 14		 je	 SHORT $LN8@z900_inter
  000c6	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  000cb	0f b6 80 05 03
	00 00		 movzx	 eax, BYTE PTR [rax+773]
  000d2	83 e0 07	 and	 eax, 7
  000d5	89 04 24	 mov	 DWORD PTR tv133[rsp], eax
  000d8	eb 15		 jmp	 SHORT $LN9@z900_inter
$LN8@z900_inter:
  000da	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  000df	0f b6 80 f0 02
	00 00		 movzx	 eax, BYTE PTR [rax+752]
  000e6	83 e0 38	 and	 eax, 56			; 00000038H
  000e9	c1 f8 03	 sar	 eax, 3
  000ec	89 04 24	 mov	 DWORD PTR tv133[rsp], eax
$LN9@z900_inter:
  000ef	8b 04 24	 mov	 eax, DWORD PTR tv133[rsp]
  000f2	89 44 24 08	 mov	 DWORD PTR i$[rsp], eax

; 5983 : #if defined(_FEATURE_IO_ASSIST)
; 5984 :         /* For I/O Assisted devices use the guest (V)ISC */
; 5985 :         SIE_MODE(regs) ? (dev->pmcw.flag25 & PMCW25_VISC) :
; 5986 : #endif
; 5987 :         ((dev->pmcw.flag4 & PMCW4_ISC) >> 3);
; 5988 : 
; 5989 :     /* Test interruption subclass mask bit in CR6 */
; 5990 :     if ((regs->CR_L(6) & (0x80000000 >> i)) == 0)

  000f6	b8 08 00 00 00	 mov	 eax, 8
  000fb	48 6b c0 07	 imul	 rax, rax, 7
  000ff	8b 4c 24 08	 mov	 ecx, DWORD PTR i$[rsp]
  00103	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  00108	d3 ea		 shr	 edx, cl
  0010a	8b ca		 mov	 ecx, edx
  0010c	48 8b 54 24 20	 mov	 rdx, QWORD PTR regs$[rsp]
  00111	8b 84 02 00 06
	00 00		 mov	 eax, DWORD PTR [rdx+rax+1536]
  00118	23 c1		 and	 eax, ecx
  0011a	85 c0		 test	 eax, eax
  0011c	75 2c		 jne	 SHORT $LN6@z900_inter

; 5991 :         return

  0011e	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00123	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00129	d1 e8		 shr	 eax, 1
  0012b	83 e0 01	 and	 eax, 1
  0012e	85 c0		 test	 eax, eax
  00130	74 0a		 je	 SHORT $LN10@z900_inter
  00132	c7 44 24 04 f0
	ff ff ff	 mov	 DWORD PTR tv145[rsp], -16
  0013a	eb 08		 jmp	 SHORT $LN11@z900_inter
$LN10@z900_inter:
  0013c	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN11@z900_inter:
  00144	8b 44 24 04	 mov	 eax, DWORD PTR tv145[rsp]
  00148	eb 05		 jmp	 SHORT $LN1@z900_inter
$LN6@z900_inter:

; 5992 : #if defined(_FEATURE_IO_ASSIST)
; 5993 :                    SIE_MODE(regs) ? SIE_INTERCEPT_IOINTP :
; 5994 : #endif
; 5995 :                                                            0;
; 5996 : #endif /*FEATURE_CHANNEL_SUBSYSTEM*/
; 5997 : 
; 5998 :     /* Interrupts are enabled for this device */
; 5999 :     return SIE_NO_INTERCEPT;

  0014a	b8 ff ff ff ff	 mov	 eax, -1
$LN1@z900_inter:

; 6000 : } /* end function interrupt_enabled */

  0014f	48 83 c4 18	 add	 rsp, 24
  00153	c3		 ret	 0
z900_interrupt_enabled ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv181 = 80
tv187 = 84
rc$1 = 88
tv213 = 92
tv219 = 96
dev$ = 128
unitstat$ = 136
z900_device_attention PROC

; 4066 : {

$LN24:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 4067 :     OBTAIN_INTLOCK(NULL);

  0000d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196363
  00014	33 c9		 xor	 ecx, ecx
  00016	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 4068 :     obtain_lock( &dev->lock );

  0001b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00023	48 83 c0 38	 add	 rax, 56			; 00000038H
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196364
  0002e	48 8b c8	 mov	 rcx, rax
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4069 : 
; 4070 :     if (dev->hnd->attention)

  00037	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003f	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00046	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  0004b	74 1a		 je	 SHORT $LN2@z900_devic

; 4071 :         dev->hnd->attention( dev );

  0004d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00055	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0005c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00064	ff 50 78	 call	 QWORD PTR [rax+120]
$LN2@z900_devic:

; 4072 : 
; 4073 : #ifdef FEATURE_CHANNEL_SUBSYSTEM
; 4074 :     /* If subchannel not valid and enabled, do not present interrupt */
; 4075 :     if (0
; 4076 :         || (dev->pmcw.flag5 & PMCW5_V) == 0
; 4077 :         || (dev->pmcw.flag5 & PMCW5_E) == 0

  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 2e		 jne	 SHORT $LN4@z900_devic
  0006d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00075	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0007c	83 e0 01	 and	 eax, 1
  0007f	85 c0		 test	 eax, eax
  00081	74 18		 je	 SHORT $LN4@z900_devic
  00083	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0008b	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00092	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00097	85 c0		 test	 eax, eax
  00099	75 34		 jne	 SHORT $LN3@z900_devic
$LN4@z900_devic:

; 4078 :     )
; 4079 :     {
; 4080 :         release_lock( &dev->lock );

  0009b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a3	48 83 c0 38	 add	 rax, 56			; 00000038H
  000a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196368
  000ae	48 8b c8	 mov	 rcx, rax
  000b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4081 :         RELEASE_INTLOCK(NULL);

  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196369
  000be	33 c9		 xor	 ecx, ecx
  000c0	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 4082 :         return 3;

  000c5	b8 03 00 00 00	 mov	 eax, 3
  000ca	e9 52 04 00 00	 jmp	 $LN1@z900_devic
$LN3@z900_devic:

; 4083 :     }
; 4084 : #endif /*FEATURE_CHANNEL_SUBSYSTEM*/
; 4085 : 
; 4086 : 
; 4087 :     /* If device is already busy or interrupt pending */
; 4088 :     if (0
; 4089 :         || dev->busy
; 4090 :         || IOPENDING( dev )
; 4091 :         || (dev->scsw.flag3 & SCSW3_SC_PEND)

  000cf	33 c0		 xor	 eax, eax
  000d1	85 c0		 test	 eax, eax
  000d3	0f 85 92 00 00
	00		 jne	 $LN6@z900_devic
  000d9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000e1	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000e7	c1 e8 13	 shr	 eax, 19
  000ea	83 e0 01	 and	 eax, 1
  000ed	85 c0		 test	 eax, eax
  000ef	75 7a		 jne	 SHORT $LN6@z900_devic
  000f1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000f9	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000ff	c1 e8 16	 shr	 eax, 22
  00102	83 e0 01	 and	 eax, 1
  00105	85 c0		 test	 eax, eax
  00107	75 62		 jne	 SHORT $LN6@z900_devic
  00109	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00111	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00117	c1 e8 17	 shr	 eax, 23
  0011a	83 e0 01	 and	 eax, 1
  0011d	85 c0		 test	 eax, eax
  0011f	75 4a		 jne	 SHORT $LN6@z900_devic
  00121	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00129	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0012f	c1 e8 18	 shr	 eax, 24
  00132	83 e0 01	 and	 eax, 1
  00135	85 c0		 test	 eax, eax
  00137	75 32		 jne	 SHORT $LN6@z900_devic
  00139	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00141	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00147	c1 e8 1b	 shr	 eax, 27
  0014a	83 e0 01	 and	 eax, 1
  0014d	85 c0		 test	 eax, eax
  0014f	75 1a		 jne	 SHORT $LN6@z900_devic
  00151	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00159	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00160	83 e0 01	 and	 eax, 1
  00163	85 c0		 test	 eax, eax
  00165	0f 84 cd 01 00
	00		 je	 $LN5@z900_devic
$LN6@z900_devic:

; 4092 :     )
; 4093 :     {
; 4094 :         int rc;                         /* Return code               */
; 4095 : 
; 4096 :         /* Resume the suspended device with attention set            */
; 4097 :         /* SA22-7204-00:                                             */
; 4098 :         /*  p. 4-1, Attention                                        */
; 4099 :         if(dev->scsw.flag3 & SCSW3_AC_SUSP)

  0016b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00173	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  0017a	83 e0 20	 and	 eax, 32			; 00000020H
  0017d	85 c0		 test	 eax, eax
  0017f	0f 84 78 01 00
	00		 je	 $LN7@z900_devic

; 4100 :         {
; 4101 :             unitstat |= CSW_ATTN;

  00185	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR unitstat$[rsp]
  0018d	0f ba e8 07	 bts	 eax, 7
  00191	88 84 24 88 00
	00 00		 mov	 BYTE PTR unitstat$[rsp], al

; 4102 : 
; 4103 :             dev->scsw.unitstat |= unitstat;

  00198	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR unitstat$[rsp]
  001a0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001a8	0f b6 89 10 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+784]
  001af	0b c8		 or	 ecx, eax
  001b1	8b c1		 mov	 eax, ecx
  001b3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001bb	88 81 10 03 00
	00		 mov	 BYTE PTR [rcx+784], al

; 4104 :             dev->scsw.flag2    |= SCSW2_AC_RESUM;

  001c1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001c9	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  001d0	83 c8 08	 or	 eax, 8
  001d3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001db	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 4105 :             dev->scsw.flag3    |= SCSW3_SC_ALERT | SCSW3_SC_PEND;

  001e1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001e9	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  001f0	83 c8 11	 or	 eax, 17
  001f3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001fb	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 4106 : 
; 4107 :             schedule_ioq( NULL, dev );

  00201	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00209	33 c9		 xor	 ecx, ecx
  0020b	e8 00 00 00 00	 call	 schedule_ioq

; 4108 : 
; 4109 :             if (dev->ccwtrace)

  00210	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00218	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0021e	c1 e8 0f	 shr	 eax, 15
  00221	83 e0 01	 and	 eax, 1
  00224	85 c0		 test	 eax, eax
  00226	0f 84 c7 00 00
	00		 je	 $LN9@z900_devic

; 4110 :             {
; 4111 :                 if (sysblk.traceFILE)

  0022c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00233	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  0023b	74 13		 je	 SHORT $LN10@z900_devic

; 4112 :                     tf_1304( dev );

  0023d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00245	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1304
  0024b	e9 a3 00 00 00	 jmp	 $LN11@z900_devic
$LN10@z900_devic:

; 4113 :                 else
; 4114 :                     // "%1d:%04X CHAN: attention signaled"
; 4115 :                     WRMSG( HHC01304, "I", LCSS_DEVNUM );

  00250	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00259	74 12		 je	 SHORT $LN16@z900_devic
  0025b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00263	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00267	89 44 24 50	 mov	 DWORD PTR tv181[rsp], eax
  0026b	eb 08		 jmp	 SHORT $LN17@z900_devic
$LN16@z900_devic:
  0026d	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv181[rsp], 0
$LN17@z900_devic:
  00275	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0027e	74 14		 je	 SHORT $LN18@z900_devic
  00280	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00288	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0028c	d1 f8		 sar	 eax, 1
  0028e	89 44 24 54	 mov	 DWORD PTR tv187[rsp], eax
  00292	eb 08		 jmp	 SHORT $LN19@z900_devic
$LN18@z900_devic:
  00294	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv187[rsp], 0
$LN19@z900_devic:
  0029c	b9 01 00 00 00	 mov	 ecx, 1
  002a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002a7	8b 4c 24 50	 mov	 ecx, DWORD PTR tv181[rsp]
  002ab	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002af	8b 4c 24 54	 mov	 ecx, DWORD PTR tv187[rsp]
  002b3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196377
  002be	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196378
  002ca	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002cf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002d4	41 b9 03 00 00
	00		 mov	 r9d, 3
  002da	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196379
  002e1	ba 13 10 00 00	 mov	 edx, 4115		; 00001013H
  002e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196380
  002ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN11@z900_devic:
$LN9@z900_devic:

; 4116 :             }
; 4117 :             rc = 0;

  002f3	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR rc$1[rsp], 0

; 4118 :         }

  002fb	eb 08		 jmp	 SHORT $LN8@z900_devic
$LN7@z900_devic:

; 4119 :         else
; 4120 :             rc = 1;

  002fd	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR rc$1[rsp], 1
$LN8@z900_devic:

; 4121 : 
; 4122 :         release_lock( &dev->lock );

  00305	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0030d	48 83 c0 38	 add	 rax, 56			; 00000038H
  00311	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196381
  00318	48 8b c8	 mov	 rcx, rax
  0031b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4123 :         RELEASE_INTLOCK(NULL);

  00321	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196382
  00328	33 c9		 xor	 ecx, ecx
  0032a	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 4124 :         return rc;

  0032f	8b 44 24 58	 mov	 eax, DWORD PTR rc$1[rsp]
  00333	e9 e9 01 00 00	 jmp	 $LN1@z900_devic
$LN5@z900_devic:

; 4125 :     }
; 4126 : 
; 4127 :     if (dev->ccwtrace)

  00338	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00340	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00346	c1 e8 0f	 shr	 eax, 15
  00349	83 e0 01	 and	 eax, 1
  0034c	85 c0		 test	 eax, eax
  0034e	0f 84 c7 00 00
	00		 je	 $LN12@z900_devic

; 4128 :     {
; 4129 :         if (sysblk.traceFILE)

  00354	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0035b	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00363	74 13		 je	 SHORT $LN13@z900_devic

; 4130 :             tf_1305( dev );

  00365	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0036d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1305
  00373	e9 a3 00 00 00	 jmp	 $LN14@z900_devic
$LN13@z900_devic:

; 4131 :         else
; 4132 :             // "%1d:%04X CHAN: attention"
; 4133 :             WRMSG( HHC01305, "I", LCSS_DEVNUM );

  00378	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00381	74 12		 je	 SHORT $LN20@z900_devic
  00383	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0038b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0038f	89 44 24 5c	 mov	 DWORD PTR tv213[rsp], eax
  00393	eb 08		 jmp	 SHORT $LN21@z900_devic
$LN20@z900_devic:
  00395	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv213[rsp], 0
$LN21@z900_devic:
  0039d	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003a6	74 14		 je	 SHORT $LN22@z900_devic
  003a8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003b0	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  003b4	d1 f8		 sar	 eax, 1
  003b6	89 44 24 60	 mov	 DWORD PTR tv219[rsp], eax
  003ba	eb 08		 jmp	 SHORT $LN23@z900_devic
$LN22@z900_devic:
  003bc	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv219[rsp], 0
$LN23@z900_devic:
  003c4	b9 01 00 00 00	 mov	 ecx, 1
  003c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003cf	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv213[rsp]
  003d3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  003d7	8b 4c 24 60	 mov	 ecx, DWORD PTR tv219[rsp]
  003db	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  003df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196386
  003e6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196387
  003f2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003f7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003fc	41 b9 03 00 00
	00		 mov	 r9d, 3
  00402	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196388
  00409	ba 25 10 00 00	 mov	 edx, 4133		; 00001025H
  0040e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196389
  00415	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN14@z900_devic:
$LN12@z900_devic:

; 4134 :     }
; 4135 : 
; 4136 :     /* We already have INTLOCK and dev->lock held, so now
; 4137 :        we only need to acquire the interrupt queue lock. */
; 4138 :     obtain_lock(&sysblk.iointqlk);

  0041b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00422	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  00428	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196390
  0042f	48 8b c8	 mov	 rcx, rax
  00432	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4139 : 
; 4140 :     /* Set SCSW for attention interrupt                              */
; 4141 :     /* SA22-7201-05:                                                 */
; 4142 :     /*  p. 16-3, Unsolicited Interuption Condition                   */
; 4143 :     /*           Solicited Interuption Condition                     */
; 4144 :     /*           Figure 16-1, Interruption Condition for Status-     */
; 4145 :     /*                        Control-Bit Combinations               */
; 4146 :     /*  p. 16-4, Alert Interruption Condition                        */
; 4147 :     /*  p. 16-16 -- 16-17, Alert Status (Bit 27)                     */
; 4148 :     /*  p. 16-18, Status-Pending (Bit 31)                            */
; 4149 :     /*                                                               */
; 4150 :     /*  Hercules maintains for tracking purposes regardless of       */
; 4151 :     /*  architecture.                                                */
; 4152 :     /*                                                               */
; 4153 :     /* Set CSW for attention interrupt when in S/360 or S/370 mode,  */
; 4154 :     /* CSW will be derived from the SCSW when interrupt is issued    */
; 4155 :     /* SA22-7204-00:                                                 */
; 4156 :     /*  p. 4-1, Attention                                            */
; 4157 :     /* GA22-6974-09:                                                 */
; 4158 :     /*  pp. 2-13 -- 2-14, Attention                                  */
; 4159 :     dev->attnscsw.flag3 = SCSW3_SC_ALERT | SCSW3_SC_PEND;

  00438	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00440	c6 80 23 03 00
	00 11		 mov	 BYTE PTR [rax+803], 17

; 4160 :     store_fw (dev->attnscsw.ccwaddr, 0);

  00447	33 c9		 xor	 ecx, ecx
  00449	e8 00 00 00 00	 call	 _byteswap_ulong
  0044e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00456	48 81 c1 24 03
	00 00		 add	 rcx, 804		; 00000324H
  0045d	8b d0		 mov	 edx, eax
  0045f	e8 00 00 00 00	 call	 store_fw_noswap

; 4161 :     dev->attnscsw.unitstat = unitstat;

  00464	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0046c	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR unitstat$[rsp]
  00474	88 88 28 03 00
	00		 mov	 BYTE PTR [rax+808], cl

; 4162 :     dev->attnscsw.chanstat = 0;

  0047a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00482	c6 80 29 03 00
	00 00		 mov	 BYTE PTR [rax+809], 0

; 4163 :     store_hw (dev->attnscsw.count, 0);

  00489	33 c9		 xor	 ecx, ecx
  0048b	e8 00 00 00 00	 call	 _byteswap_ushort
  00490	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00498	48 81 c1 2a 03
	00 00		 add	 rcx, 810		; 0000032aH
  0049f	0f b7 d0	 movzx	 edx, ax
  004a2	e8 00 00 00 00	 call	 store_hw_noswap

; 4164 : 
; 4165 :     /* Queue the attention interrupt */
; 4166 :     QUEUE_IO_INTERRUPT_QLOCKED(&dev->attnioint,FALSE);

  004a7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004af	48 05 58 02 00
	00		 add	 rax, 600		; 00000258H
  004b5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196391
  004bc	33 d2		 xor	 edx, edx
  004be	48 8b c8	 mov	 rcx, rax
  004c1	e8 00 00 00 00	 call	 Queue_IO_Interrupt_QLocked

; 4167 : 
; 4168 :     /* Update interrupt status */
; 4169 :     subchannel_interrupt_queue_cleanup(dev);

  004c6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004ce	e8 00 00 00 00	 call	 subchannel_interrupt_queue_cleanup

; 4170 :     UPDATE_IC_IOPENDING_QLOCKED();

  004d3	e8 00 00 00 00	 call	 Update_IC_IOPENDING_QLocked

; 4171 : 
; 4172 :     /* Release locks and return to caller */
; 4173 :     release_lock(&sysblk.iointqlk);

  004d8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004df	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  004e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196392
  004ec	48 8b c8	 mov	 rcx, rax
  004ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4174 :     release_lock(&dev->lock);

  004f5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004fd	48 83 c0 38	 add	 rax, 56			; 00000038H
  00501	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196393
  00508	48 8b c8	 mov	 rcx, rax
  0050b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4175 :     RELEASE_INTLOCK(NULL);

  00511	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196394
  00518	33 c9		 xor	 ecx, ecx
  0051a	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 4176 : 
; 4177 :     return 0;

  0051f	33 c0		 xor	 eax, eax
$LN1@z900_devic:

; 4178 : } /* end function device_attention */

  00521	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00525	c3		 ret	 0
z900_device_attention ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
ps$ = 80
idalen$ = 84
to_memory$ = 88
readbackwards$ = 89
midawlen$ = 92
storkey$ = 96
midawflg$ = 97
to_iobuf$ = 98
idacount$ = 100
midawrem$ = 104
page$ = 112
idawaddr$ = 120
midawdat$ = 128
idadata$ = 136
midawptr$ = 144
iobufptr$ = 152
midawseq$ = 160
idaseq$ = 164
tv128 = 168
tv405 = 172
idasize$ = 176
iobufptr$1 = 184
tv788 = 192
tv796 = 200
tv810 = 208
tv860 = 216
tv868 = 224
tv871 = 232
startpage$ = 240
endpage$ = 248
tv673 = 256
dev$ = 304
ccw$ = 312
code$ = 320
flags$ = 328
addr$ = 336
count$ = 344
ccwkey$ = 352
idawfmt$ = 360
idapmask$ = 368
iobuf$ = 376
iobufstart$ = 384
iobufend$ = 392
chanstat$ = 400
residual$ = 408
prefetch$ = 416
z900_copy_iobuf PROC

; 3372 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H

; 3373 : BYTE    *iobufptr = 0;                  /* Working I/O buffer addr   */

  0001d	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR iobufptr$[rsp], 0

; 3374 : u_int   ps = 0;                         /* Prefetch entry            */

  00029	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR ps$[rsp], 0

; 3375 : U32     idawaddr;                       /* Main storage addr of IDAW */
; 3376 : U16     idacount;                       /* IDA bytes remaining       */
; 3377 : int     idaseq;                         /* IDA sequence number       */
; 3378 : RADR    idadata;                        /* IDA data address          */
; 3379 : U16     idalen;                         /* IDA data length           */
; 3380 : int     idasize;                        /* IDAW Size                 */
; 3381 : BYTE    storkey;                        /* Storage key               */
; 3382 : RADR    page,startpage,endpage;         /* Storage key pages         */
; 3383 : BYTE    to_iobuf;                       /* 1=READ, SENSE, or RDBACK  */
; 3384 : BYTE    to_memory;                      /* 1=READ, SENSE, or RDBACK  */
; 3385 : BYTE    readbackwards;                  /* 1=RDBACK                  */
; 3386 : #if defined(FEATURE_MIDAW_FACILITY)
; 3387 : int     midawseq;                       /* MIDAW counter (0=1st)     */
; 3388 : U32     midawptr;                       /* Real addr of MIDAW        */
; 3389 : U16     midawrem;                       /* CCW bytes remaining       */
; 3390 : U16     midawlen=0;                     /* MIDAW data length         */

  00031	33 c0		 xor	 eax, eax
  00033	66 89 44 24 5c	 mov	 WORD PTR midawlen$[rsp], ax

; 3391 : RADR    midawdat=0;                     /* MIDAW data area addr      */

  00038	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR midawdat$[rsp], 0

; 3392 : BYTE    midawflg;                       /* MIDAW flags               */
; 3393 : #endif /*defined(FEATURE_MIDAW_FACILITY)*/
; 3394 : 
; 3395 : #if !defined(set_chanstat)
; 3396 : #define set_chanstat(_status)                                          \
; 3397 : do {                                                                   \
; 3398 :     if (prefetch->seq)                                                 \
; 3399 :         prefetch->chanstat[ps] = (_status);                            \
; 3400 :     else                                                               \
; 3401 :         *chanstat = (_status);                                         \
; 3402 : } while(0)
; 3403 : #endif
; 3404 : 
; 3405 : #if !defined(get_new_prefetch_entry)
; 3406 : #define get_new_prefetch_entry(_idawtype,_idawaddr)                    \
; 3407 : do {                                                                   \
; 3408 :     if (prefetch->seq)                                                 \
; 3409 :     {                                                                  \
; 3410 :         ps = prefetch->seq++;                                          \
; 3411 :         if (prefetch->seq > PF_SIZE)                                   \
; 3412 :         {                                                              \
; 3413 :             *chanstat = CSW_CDC;                                       \
; 3414 :             break;                                                     \
; 3415 :         }                                                              \
; 3416 :         prefetch->ccwaddr[ps] = prefetch->ccwaddr[ps-1];               \
; 3417 :         if ((_idawtype) != PF_NO_IDAW)                                 \
; 3418 :         {                                                              \
; 3419 :             prefetch->idawtype[ps] = (_idawtype);                      \
; 3420 :             prefetch->idawaddr[ps] = (_idawaddr);                      \
; 3421 :         }                                                              \
; 3422 :     }                                                                  \
; 3423 :     *chanstat = 0;                                                     \
; 3424 : } while(0)
; 3425 : #endif
; 3426 : 
; 3427 :     /* Set current prefetch sequence */
; 3428 :     if (prefetch->seq)

  00044	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  0004c	83 38 00	 cmp	 DWORD PTR [rax], 0
  0004f	74 10		 je	 SHORT $LN56@z900_copy_

; 3429 :         ps = prefetch->seq - 1;

  00051	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00059	8b 00		 mov	 eax, DWORD PTR [rax]
  0005b	ff c8		 dec	 eax
  0005d	89 44 24 50	 mov	 DWORD PTR ps$[rsp], eax
$LN56@z900_copy_:

; 3430 : 
; 3431 :     /* Channel Data Check if invalid I/O buffer */
; 3432 :     if ((size_t)iobufend < 131072   ||  /* Low host OS storage reference */
; 3433 :         iobuf < iobufstart          ||

  00061	48 81 bc 24 88
	01 00 00 00 00
	02 00		 cmp	 QWORD PTR iobufend$[rsp], 131072 ; 00020000H
  0006d	72 24		 jb	 SHORT $LN58@z900_copy_
  0006f	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR iobufstart$[rsp]
  00077	48 39 84 24 78
	01 00 00	 cmp	 QWORD PTR iobuf$[rsp], rax
  0007f	72 12		 jb	 SHORT $LN58@z900_copy_
  00081	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR iobufend$[rsp]
  00089	48 39 84 24 78
	01 00 00	 cmp	 QWORD PTR iobuf$[rsp], rax
  00091	76 36		 jbe	 SHORT $LN57@z900_copy_
$LN58@z900_copy_:
$LN4@z900_copy_:

; 3434 :         iobuf > iobufend)
; 3435 :     {
; 3436 :         set_chanstat(CSW_CDC);

  00093	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  0009b	83 38 00	 cmp	 DWORD PTR [rax], 0
  0009e	74 13		 je	 SHORT $LN59@z900_copy_
  000a0	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  000a4	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  000ac	c6 44 01 10 08	 mov	 BYTE PTR [rcx+rax+16], 8
  000b1	eb 0b		 jmp	 SHORT $LN60@z900_copy_
$LN59@z900_copy_:
  000b3	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  000bb	c6 00 08	 mov	 BYTE PTR [rax], 8
$LN60@z900_copy_:
  000be	33 c0		 xor	 eax, eax
  000c0	85 c0		 test	 eax, eax
  000c2	75 cf		 jne	 SHORT $LN4@z900_copy_

; 3437 :         return;

  000c4	e9 e1 18 00 00	 jmp	 $LN1@z900_copy_
$LN57@z900_copy_:

; 3438 :     }
; 3439 : 
; 3440 :     /* Exit if no bytes are to be copied */
; 3441 :     if (count == 0 || dev->is_immed)

  000c9	83 bc 24 58 01
	00 00 00	 cmp	 DWORD PTR count$[rsp], 0
  000d1	74 11		 je	 SHORT $LN62@z900_copy_
  000d3	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000db	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  000e2	74 36		 je	 SHORT $LN61@z900_copy_
$LN62@z900_copy_:
$LN7@z900_copy_:

; 3442 :     {
; 3443 :         set_chanstat(0);

  000e4	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  000ec	83 38 00	 cmp	 DWORD PTR [rax], 0
  000ef	74 13		 je	 SHORT $LN63@z900_copy_
  000f1	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  000f5	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  000fd	c6 44 01 10 00	 mov	 BYTE PTR [rcx+rax+16], 0
  00102	eb 0b		 jmp	 SHORT $LN64@z900_copy_
$LN63@z900_copy_:
  00104	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  0010c	c6 00 00	 mov	 BYTE PTR [rax], 0
$LN64@z900_copy_:
  0010f	33 c0		 xor	 eax, eax
  00111	85 c0		 test	 eax, eax
  00113	75 cf		 jne	 SHORT $LN7@z900_copy_

; 3444 :         return;

  00115	e9 90 18 00 00	 jmp	 $LN1@z900_copy_
$LN61@z900_copy_:

; 3445 :     }
; 3446 : 
; 3447 :     /* Set flags indicating direction of data movement */
; 3448 :     if (IS_CCW_RDBACK(code))

  0011a	0f b6 84 24 40
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  00122	83 e0 0f	 and	 eax, 15
  00125	83 f8 0c	 cmp	 eax, 12
  00128	75 15		 jne	 SHORT $LN65@z900_copy_

; 3449 :     {
; 3450 :         readbackwards = to_memory = 1;

  0012a	c6 44 24 58 01	 mov	 BYTE PTR to_memory$[rsp], 1
  0012f	0f b6 44 24 58	 movzx	 eax, BYTE PTR to_memory$[rsp]
  00134	88 44 24 59	 mov	 BYTE PTR readbackwards$[rsp], al

; 3451 :         to_iobuf = 0;

  00138	c6 44 24 62 00	 mov	 BYTE PTR to_iobuf$[rsp], 0

; 3452 :     }

  0013d	eb 41		 jmp	 SHORT $LN66@z900_copy_
$LN65@z900_copy_:

; 3453 :     else
; 3454 :     {
; 3455 :         readbackwards = 0;

  0013f	c6 44 24 59 00	 mov	 BYTE PTR readbackwards$[rsp], 0

; 3456 :         to_iobuf = code & 0x01;

  00144	0f b6 84 24 40
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0014c	83 e0 01	 and	 eax, 1
  0014f	88 44 24 62	 mov	 BYTE PTR to_iobuf$[rsp], al

; 3457 :         to_memory = !to_iobuf;

  00153	0f b6 44 24 62	 movzx	 eax, BYTE PTR to_iobuf$[rsp]
  00158	85 c0		 test	 eax, eax
  0015a	75 0d		 jne	 SHORT $LN191@z900_copy_
  0015c	c7 84 24 a8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv128[rsp], 1
  00167	eb 0b		 jmp	 SHORT $LN192@z900_copy_
$LN191@z900_copy_:
  00169	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv128[rsp], 0
$LN192@z900_copy_:
  00174	0f b6 84 24 a8
	00 00 00	 movzx	 eax, BYTE PTR tv128[rsp]
  0017c	88 44 24 58	 mov	 BYTE PTR to_memory$[rsp], al
$LN66@z900_copy_:

; 3458 :     }
; 3459 : 
; 3460 : 
; 3461 : #if defined(FEATURE_MIDAW_FACILITY)
; 3462 :     /* Move data when modified indirect data addressing is used */
; 3463 :     if (flags & CCW_FLAGS_MIDAW)

  00180	0f b6 84 24 48
	01 00 00	 movzx	 eax, BYTE PTR flags$[rsp]
  00188	83 e0 01	 and	 eax, 1
  0018b	85 c0		 test	 eax, eax
  0018d	0f 84 9d 07 00
	00		 je	 $LN67@z900_copy_

; 3464 :     {
; 3465 :         if (prefetch->seq)

  00193	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  0019b	83 38 00	 cmp	 DWORD PTR [rax], 0
  0019e	74 17		 je	 SHORT $LN69@z900_copy_

; 3466 :             prefetch->datalen[ps] = 0;

  001a0	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  001a4	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  001ac	c7 84 81 10 05
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+1296], 0
$LN69@z900_copy_:

; 3467 : 
; 3468 :         midawptr = addr;

  001b7	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  001be	89 84 24 90 00
	00 00		 mov	 DWORD PTR midawptr$[rsp], eax

; 3469 :         midawrem = count;

  001c5	0f b7 84 24 58
	01 00 00	 movzx	 eax, WORD PTR count$[rsp]
  001cd	66 89 44 24 68	 mov	 WORD PTR midawrem$[rsp], ax

; 3470 :         midawflg = 0;

  001d2	c6 44 24 61 00	 mov	 BYTE PTR midawflg$[rsp], 0

; 3471 : 
; 3472 :         for (midawseq = 0;

  001d7	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR midawseq$[rsp], 0
  001e2	eb 10		 jmp	 SHORT $LN10@z900_copy_
$LN8@z900_copy_:

; 3476 :                 !(prefetch->seq &&
; 3477 :                     (prefetch->chanstat[ps] ||
; 3478 :                         ((ps+1) < prefetch->seq &&
; 3479 :                             prefetch->chanstat[ps+1])));
; 3480 :              midawseq++)

  001e4	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR midawseq$[rsp]
  001eb	ff c0		 inc	 eax
  001ed	89 84 24 a0 00
	00 00		 mov	 DWORD PTR midawseq$[rsp], eax
$LN10@z900_copy_:

; 3473 :              midawrem > 0 &&
; 3474 :                 (midawflg & MIDAW_LAST) == 0 &&
; 3475 :                 chanstat != 0 &&

  001f4	0f b7 44 24 68	 movzx	 eax, WORD PTR midawrem$[rsp]
  001f9	85 c0		 test	 eax, eax
  001fb	0f 8e b8 06 00
	00		 jle	 $LN9@z900_copy_
  00201	0f b6 44 24 61	 movzx	 eax, BYTE PTR midawflg$[rsp]
  00206	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0020b	85 c0		 test	 eax, eax
  0020d	0f 85 a6 06 00
	00		 jne	 $LN9@z900_copy_
  00213	48 83 bc 24 90
	01 00 00 00	 cmp	 QWORD PTR chanstat$[rsp], 0
  0021c	0f 84 97 06 00
	00		 je	 $LN9@z900_copy_
  00222	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  0022a	83 38 00	 cmp	 DWORD PTR [rax], 0
  0022d	74 48		 je	 SHORT $LN70@z900_copy_
  0022f	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  00233	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  0023b	0f b6 44 01 10	 movzx	 eax, BYTE PTR [rcx+rax+16]
  00240	85 c0		 test	 eax, eax
  00242	0f 85 71 06 00
	00		 jne	 $LN9@z900_copy_
  00248	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  0024c	ff c0		 inc	 eax
  0024e	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00256	3b 01		 cmp	 eax, DWORD PTR [rcx]
  00258	73 1d		 jae	 SHORT $LN71@z900_copy_
  0025a	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  0025e	ff c0		 inc	 eax
  00260	8b c0		 mov	 eax, eax
  00262	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  0026a	0f b6 44 01 10	 movzx	 eax, BYTE PTR [rcx+rax+16]
  0026f	85 c0		 test	 eax, eax
  00271	0f 85 42 06 00
	00		 jne	 $LN9@z900_copy_
$LN71@z900_copy_:
$LN70@z900_copy_:
$LN13@z900_copy_:

; 3481 :         {
; 3482 :             /* Get new prefetch entry */
; 3483 :             get_new_prefetch_entry(PF_MIDAW, midawptr);

  00277	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  0027f	83 38 00	 cmp	 DWORD PTR [rax], 0
  00282	0f 84 a1 00 00
	00		 je	 $LN72@z900_copy_
  00288	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00290	8b 00		 mov	 eax, DWORD PTR [rax]
  00292	89 44 24 50	 mov	 DWORD PTR ps$[rsp], eax
  00296	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  0029e	8b 00		 mov	 eax, DWORD PTR [rax]
  002a0	ff c0		 inc	 eax
  002a2	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  002aa	89 01		 mov	 DWORD PTR [rcx], eax
  002ac	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  002b4	81 38 00 01 00
	00		 cmp	 DWORD PTR [rax], 256	; 00000100H
  002ba	76 0d		 jbe	 SHORT $LN73@z900_copy_
  002bc	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  002c4	c6 00 08	 mov	 BYTE PTR [rax], 8
  002c7	eb 75		 jmp	 SHORT $LN12@z900_copy_
$LN73@z900_copy_:
  002c9	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  002cd	ff c8		 dec	 eax
  002cf	8b c0		 mov	 eax, eax
  002d1	8b 4c 24 50	 mov	 ecx, DWORD PTR ps$[rsp]
  002d5	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR prefetch$[rsp]
  002dd	4c 8b 84 24 a0
	01 00 00	 mov	 r8, QWORD PTR prefetch$[rsp]
  002e5	41 8b 84 80 10
	01 00 00	 mov	 eax, DWORD PTR [r8+rax*4+272]
  002ed	89 84 8a 10 01
	00 00		 mov	 DWORD PTR [rdx+rcx*4+272], eax
  002f4	33 c0		 xor	 eax, eax
  002f6	83 f8 01	 cmp	 eax, 1
  002f9	74 2e		 je	 SHORT $LN74@z900_copy_
  002fb	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  002ff	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00307	c6 84 01 10 18
	00 00 03	 mov	 BYTE PTR [rcx+rax+6160], 3
  0030f	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  00313	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  0031b	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR midawptr$[rsp]
  00322	89 94 81 10 14
	00 00		 mov	 DWORD PTR [rcx+rax*4+5136], edx
$LN74@z900_copy_:
$LN72@z900_copy_:
  00329	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00331	c6 00 00	 mov	 BYTE PTR [rax], 0
  00334	33 c0		 xor	 eax, eax
  00336	85 c0		 test	 eax, eax
  00338	0f 85 39 ff ff
	ff		 jne	 $LN13@z900_copy_
$LN12@z900_copy_:

; 3484 :             if (*chanstat != 0)

  0033e	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00346	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00349	85 c0		 test	 eax, eax
  0034b	74 05		 je	 SHORT $LN75@z900_copy_

; 3485 :                 break;

  0034d	e9 67 05 00 00	 jmp	 $LN9@z900_copy_
$LN75@z900_copy_:

; 3486 : 
; 3487 :             /* Fetch MIDAW and set data address, length, flags */
; 3488 :             ARCH_DEP(fetch_midaw) (dev, code, ccwkey,

  00352	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  0035a	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0035f	48 8d 44 24 61	 lea	 rax, QWORD PTR midawflg$[rsp]
  00364	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00369	48 8d 44 24 5c	 lea	 rax, QWORD PTR midawlen$[rsp]
  0036e	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00373	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR midawdat$[rsp]
  0037b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00380	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR midawptr$[rsp]
  00387	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0038b	44 8b 8c 24 a0
	00 00 00	 mov	 r9d, DWORD PTR midawseq$[rsp]
  00393	44 0f b6 84 24
	60 01 00 00	 movzx	 r8d, BYTE PTR ccwkey$[rsp]
  0039c	0f b6 94 24 40
	01 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  003a4	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003ac	e8 00 00 00 00	 call	 z900_fetch_midaw

; 3489 :                     midawseq, midawptr,
; 3490 :                     &midawdat, &midawlen, &midawflg, chanstat);
; 3491 : 
; 3492 :             /* Exit if fetch_midaw detected channel program check */
; 3493 :             if (prefetch->seq)

  003b1	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  003b9	83 38 00	 cmp	 DWORD PTR [rax], 0
  003bc	0f 84 88 00 00
	00		 je	 $LN76@z900_copy_

; 3494 :             {
; 3495 :                 prefetch->idawflag[ps] = midawflg;

  003c2	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  003c6	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  003ce	0f b6 54 24 61	 movzx	 edx, BYTE PTR midawflg$[rsp]
  003d3	88 94 01 10 19
	00 00		 mov	 BYTE PTR [rcx+rax+6416], dl

; 3496 :                 prefetch->dataaddr[ps] = midawdat;

  003da	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  003de	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  003e6	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR midawdat$[rsp]
  003ee	48 89 94 c1 10
	09 00 00	 mov	 QWORD PTR [rcx+rax*8+2320], rdx

; 3497 :                 prefetch->datalen[ps] = midawlen;

  003f6	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  003fa	0f b7 4c 24 5c	 movzx	 ecx, WORD PTR midawlen$[rsp]
  003ff	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR prefetch$[rsp]
  00407	89 8c 82 10 05
	00 00		 mov	 DWORD PTR [rdx+rax*4+1296], ecx

; 3498 :                 if (*chanstat != 0)

  0040e	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00416	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00419	85 c0		 test	 eax, eax
  0041b	74 2b		 je	 SHORT $LN78@z900_copy_

; 3499 :                 {
; 3500 :                     prefetch->chanstat[ps] = *chanstat;

  0041d	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  00421	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00429	48 8b 94 24 90
	01 00 00	 mov	 rdx, QWORD PTR chanstat$[rsp]
  00431	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  00434	88 54 01 10	 mov	 BYTE PTR [rcx+rax+16], dl

; 3501 :                     *chanstat = 0;

  00438	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00440	c6 00 00	 mov	 BYTE PTR [rax], 0

; 3502 :                     break;

  00443	e9 71 04 00 00	 jmp	 $LN9@z900_copy_
$LN78@z900_copy_:

; 3503 :                 }
; 3504 :             }

  00448	eb 14		 jmp	 SHORT $LN77@z900_copy_
$LN76@z900_copy_:

; 3505 :             else if (*chanstat != 0)

  0044a	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00452	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00455	85 c0		 test	 eax, eax
  00457	74 05		 je	 SHORT $LN79@z900_copy_

; 3506 :                 break;

  00459	e9 5b 04 00 00	 jmp	 $LN9@z900_copy_
$LN79@z900_copy_:
$LN77@z900_copy_:

; 3507 : 
; 3508 :             /* Channel program check if MIDAW length
; 3509 :                exceeds the remaining CCW count */
; 3510 :             if (midawlen > midawrem)

  0045e	0f b7 44 24 5c	 movzx	 eax, WORD PTR midawlen$[rsp]
  00463	0f b7 4c 24 68	 movzx	 ecx, WORD PTR midawrem$[rsp]
  00468	3b c1		 cmp	 eax, ecx
  0046a	7e 36		 jle	 SHORT $LN80@z900_copy_
$LN16@z900_copy_:

; 3511 :             {
; 3512 :                 set_chanstat(CSW_PROGC);

  0046c	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00474	83 38 00	 cmp	 DWORD PTR [rax], 0
  00477	74 13		 je	 SHORT $LN81@z900_copy_
  00479	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  0047d	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00485	c6 44 01 10 20	 mov	 BYTE PTR [rcx+rax+16], 32 ; 00000020H
  0048a	eb 0b		 jmp	 SHORT $LN82@z900_copy_
$LN81@z900_copy_:
  0048c	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00494	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H
$LN82@z900_copy_:
  00497	33 c0		 xor	 eax, eax
  00499	85 c0		 test	 eax, eax
  0049b	75 cf		 jne	 SHORT $LN16@z900_copy_

; 3513 :                 return;

  0049d	e9 08 15 00 00	 jmp	 $LN1@z900_copy_
$LN80@z900_copy_:

; 3514 :             }
; 3515 : 
; 3516 :             /* MIDAW length may be zero during prefetch operations */
; 3517 :             if (!prefetch->seq || (prefetch->seq && midawlen))

  004a2	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  004aa	83 38 00	 cmp	 DWORD PTR [rax], 0
  004ad	74 1e		 je	 SHORT $LN84@z900_copy_
  004af	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  004b7	83 38 00	 cmp	 DWORD PTR [rax], 0
  004ba	0f 84 e3 03 00
	00		 je	 $LN83@z900_copy_
  004c0	0f b7 44 24 5c	 movzx	 eax, WORD PTR midawlen$[rsp]
  004c5	85 c0		 test	 eax, eax
  004c7	0f 84 d6 03 00
	00		 je	 $LN83@z900_copy_
$LN84@z900_copy_:

; 3518 :             {
; 3519 : 
; 3520 :                 /* Perform data movement unless SKIP flag is set in
; 3521 :                    MIDAW */
; 3522 :                 if ((midawflg & MIDAW_SKIP) ==0)

  004cd	0f b6 44 24 61	 movzx	 eax, BYTE PTR midawflg$[rsp]
  004d2	83 e0 40	 and	 eax, 64			; 00000040H
  004d5	85 c0		 test	 eax, eax
  004d7	0f 85 e5 02 00
	00		 jne	 $LN85@z900_copy_

; 3523 :                 {
; 3524 :                     /* Note: MIDAW data area cannot cross a page
; 3525 :                        boundary. The fetch_midaw function enforces this
; 3526 :                        restriction */
; 3527 : 
; 3528 :                     /* Channel protection check if MIDAW data location
; 3529 :                        is fetch protected, or if location is store
; 3530 :                        protected and command is READ, READ BACKWARD, or
; 3531 :                        SENSE */
; 3532 :                     storkey = ARCH_DEP( get_dev_storage_key )( dev, midawdat );

  004dd	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR midawdat$[rsp]
  004e5	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004ed	e8 00 00 00 00	 call	 z900_get_dev_storage_key
  004f2	88 44 24 60	 mov	 BYTE PTR storkey$[rsp], al

; 3533 :                     if (ccwkey != 0
; 3534 :                         && (storkey & STORKEY_KEY) != ccwkey
; 3535 :                         && ((storkey & STORKEY_FETCH) || to_memory))

  004f6	0f b6 84 24 60
	01 00 00	 movzx	 eax, BYTE PTR ccwkey$[rsp]
  004fe	85 c0		 test	 eax, eax
  00500	74 61		 je	 SHORT $LN86@z900_copy_
  00502	0f b6 44 24 60	 movzx	 eax, BYTE PTR storkey$[rsp]
  00507	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  0050c	0f b6 8c 24 60
	01 00 00	 movzx	 ecx, BYTE PTR ccwkey$[rsp]
  00514	3b c1		 cmp	 eax, ecx
  00516	74 4b		 je	 SHORT $LN86@z900_copy_
  00518	0f b6 44 24 60	 movzx	 eax, BYTE PTR storkey$[rsp]
  0051d	83 e0 08	 and	 eax, 8
  00520	85 c0		 test	 eax, eax
  00522	75 09		 jne	 SHORT $LN87@z900_copy_
  00524	0f b6 44 24 58	 movzx	 eax, BYTE PTR to_memory$[rsp]
  00529	85 c0		 test	 eax, eax
  0052b	74 36		 je	 SHORT $LN86@z900_copy_
$LN87@z900_copy_:
$LN19@z900_copy_:

; 3536 :                     {
; 3537 :                         set_chanstat(CSW_PROTC);

  0052d	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00535	83 38 00	 cmp	 DWORD PTR [rax], 0
  00538	74 13		 je	 SHORT $LN88@z900_copy_
  0053a	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  0053e	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00546	c6 44 01 10 10	 mov	 BYTE PTR [rcx+rax+16], 16
  0054b	eb 0b		 jmp	 SHORT $LN89@z900_copy_
$LN88@z900_copy_:
  0054d	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00555	c6 00 10	 mov	 BYTE PTR [rax], 16
$LN89@z900_copy_:
  00558	33 c0		 xor	 eax, eax
  0055a	85 c0		 test	 eax, eax
  0055c	75 cf		 jne	 SHORT $LN19@z900_copy_

; 3538 :                         return;

  0055e	e9 47 14 00 00	 jmp	 $LN1@z900_copy_
$LN86@z900_copy_:

; 3539 :                     }
; 3540 : 
; 3541 :                     /* Ensure memcpy will stay within buffer         */
; 3542 :                     /* Channel data check if outside buffer          */
; 3543 :                     /* SA22-7201-05:                                 */
; 3544 :                     /*  p. 16-27, Channel-Data Check                 */
; 3545 :                     if (readbackwards)

  00563	0f b6 44 24 59	 movzx	 eax, BYTE PTR readbackwards$[rsp]
  00568	85 c0		 test	 eax, eax
  0056a	74 7e		 je	 SHORT $LN90@z900_copy_

; 3546 :                     {
; 3547 :                         iobufptr = iobuf + dev->curblkrem + midawrem -

  0056c	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00574	8b 80 18 10 00
	00		 mov	 eax, DWORD PTR [rax+4120]
  0057a	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00582	48 03 c8	 add	 rcx, rax
  00585	48 8b c1	 mov	 rax, rcx
  00588	0f b7 4c 24 68	 movzx	 ecx, WORD PTR midawrem$[rsp]
  0058d	48 03 c1	 add	 rax, rcx
  00590	0f b7 4c 24 5c	 movzx	 ecx, WORD PTR midawlen$[rsp]
  00595	48 2b c1	 sub	 rax, rcx
  00598	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR iobufptr$[rsp], rax

; 3548 :                                    midawlen;
; 3549 :                         if (!midawlen                        ||
; 3550 :                             (iobufptr + midawlen) > iobufend ||

  005a0	0f b7 44 24 5c	 movzx	 eax, WORD PTR midawlen$[rsp]
  005a5	85 c0		 test	 eax, eax
  005a7	74 2f		 je	 SHORT $LN93@z900_copy_
  005a9	0f b7 44 24 5c	 movzx	 eax, WORD PTR midawlen$[rsp]
  005ae	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR iobufptr$[rsp]
  005b6	48 03 c8	 add	 rcx, rax
  005b9	48 8b c1	 mov	 rax, rcx
  005bc	48 3b 84 24 88
	01 00 00	 cmp	 rax, QWORD PTR iobufend$[rsp]
  005c4	77 12		 ja	 SHORT $LN93@z900_copy_
  005c6	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR iobufstart$[rsp]
  005ce	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR iobufptr$[rsp], rax
  005d6	73 10		 jae	 SHORT $LN92@z900_copy_
$LN93@z900_copy_:

; 3551 :                             iobufptr < iobufstart)
; 3552 :                         {
; 3553 :                             *chanstat = CSW_CDC;

  005d8	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  005e0	c6 00 08	 mov	 BYTE PTR [rax], 8

; 3554 :                             return;

  005e3	e9 c2 13 00 00	 jmp	 $LN1@z900_copy_
$LN92@z900_copy_:

; 3555 :                         }
; 3556 :                     }

  005e8	eb 6e		 jmp	 SHORT $LN91@z900_copy_
$LN90@z900_copy_:

; 3557 :                     else if (!midawlen                     ||
; 3558 :                              (iobuf + midawlen) > iobufend ||

  005ea	0f b7 44 24 5c	 movzx	 eax, WORD PTR midawlen$[rsp]
  005ef	85 c0		 test	 eax, eax
  005f1	74 2f		 je	 SHORT $LN95@z900_copy_
  005f3	0f b7 44 24 5c	 movzx	 eax, WORD PTR midawlen$[rsp]
  005f8	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00600	48 03 c8	 add	 rcx, rax
  00603	48 8b c1	 mov	 rax, rcx
  00606	48 3b 84 24 88
	01 00 00	 cmp	 rax, QWORD PTR iobufend$[rsp]
  0060e	77 12		 ja	 SHORT $LN95@z900_copy_
  00610	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR iobufstart$[rsp]
  00618	48 39 84 24 78
	01 00 00	 cmp	 QWORD PTR iobuf$[rsp], rax
  00620	73 36		 jae	 SHORT $LN94@z900_copy_
$LN95@z900_copy_:
$LN22@z900_copy_:

; 3559 :                              iobuf < iobufstart)
; 3560 :                     {
; 3561 :                             set_chanstat(CSW_CDC);

  00622	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  0062a	83 38 00	 cmp	 DWORD PTR [rax], 0
  0062d	74 13		 je	 SHORT $LN96@z900_copy_
  0062f	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  00633	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  0063b	c6 44 01 10 08	 mov	 BYTE PTR [rcx+rax+16], 8
  00640	eb 0b		 jmp	 SHORT $LN97@z900_copy_
$LN96@z900_copy_:
  00642	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  0064a	c6 00 08	 mov	 BYTE PTR [rax], 8
$LN97@z900_copy_:
  0064d	33 c0		 xor	 eax, eax
  0064f	85 c0		 test	 eax, eax
  00651	75 cf		 jne	 SHORT $LN22@z900_copy_

; 3562 :                             return;

  00653	e9 52 13 00 00	 jmp	 $LN1@z900_copy_
$LN94@z900_copy_:
$LN91@z900_copy_:

; 3563 :                     }
; 3564 : 
; 3565 :                     /* Set the main storage reference and change
; 3566 :                        bits */
; 3567 :                     if (to_memory)

  00658	0f b6 44 24 58	 movzx	 eax, BYTE PTR to_memory$[rsp]
  0065d	85 c0		 test	 eax, eax
  0065f	74 1a		 je	 SHORT $LN98@z900_copy_

; 3568 :                         ARCH_DEP( or_dev_storage_key )( dev, midawdat, (STORKEY_REF | STORKEY_CHANGE) );

  00661	41 b0 06	 mov	 r8b, 6
  00664	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR midawdat$[rsp]
  0066c	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00674	e8 00 00 00 00	 call	 z900_or_dev_storage_key
  00679	eb 18		 jmp	 SHORT $LN99@z900_copy_
$LN98@z900_copy_:

; 3569 :                     else
; 3570 :                         ARCH_DEP( or_dev_storage_key )( dev, midawdat, STORKEY_REF );

  0067b	41 b0 04	 mov	 r8b, 4
  0067e	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR midawdat$[rsp]
  00686	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0068e	e8 00 00 00 00	 call	 z900_or_dev_storage_key
$LN99@z900_copy_:

; 3571 : 
; 3572 :                     /* Copy data between main storage and channel
; 3573 :                        buffer */
; 3574 :                     if (readbackwards)

  00693	0f b6 44 24 59	 movzx	 eax, BYTE PTR readbackwards$[rsp]
  00698	85 c0		 test	 eax, eax
  0069a	74 6a		 je	 SHORT $LN100@z900_copy_

; 3575 :                     {
; 3576 :                         midawdat = (midawdat - midawlen) + 1;

  0069c	0f b7 44 24 5c	 movzx	 eax, WORD PTR midawlen$[rsp]
  006a1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR midawdat$[rsp]
  006a9	48 2b c8	 sub	 rcx, rax
  006ac	48 8b c1	 mov	 rax, rcx
  006af	48 ff c0	 inc	 rax
  006b2	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR midawdat$[rsp], rax

; 3577 :                         memcpy_backwards (dev->mainstor + midawdat,

  006ba	0f b7 44 24 5c	 movzx	 eax, WORD PTR midawlen$[rsp]
  006bf	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006c7	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  006ce	48 03 8c 24 80
	00 00 00	 add	 rcx, QWORD PTR midawdat$[rsp]
  006d6	44 8b c0	 mov	 r8d, eax
  006d9	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR iobufptr$[rsp]
  006e1	e8 00 00 00 00	 call	 memcpy_backwards

; 3578 :                                           iobufptr,
; 3579 :                                           midawlen);
; 3580 : 
; 3581 :                         /* Decrement buffer pointer */
; 3582 :                         iobuf -= midawlen;

  006e6	0f b7 44 24 5c	 movzx	 eax, WORD PTR midawlen$[rsp]
  006eb	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  006f3	48 2b c8	 sub	 rcx, rax
  006f6	48 8b c1	 mov	 rax, rcx
  006f9	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR iobuf$[rsp], rax

; 3583 :                     }

  00701	e9 bc 00 00 00	 jmp	 $LN101@z900_copy_
$LN100@z900_copy_:

; 3584 :                     else
; 3585 :                     {
; 3586 :                         if (to_iobuf)

  00706	0f b6 44 24 62	 movzx	 eax, BYTE PTR to_iobuf$[rsp]
  0070b	85 c0		 test	 eax, eax
  0070d	74 6d		 je	 SHORT $LN102@z900_copy_

; 3587 :                         {
; 3588 :                             memcpy (iobuf,

  0070f	0f b7 44 24 5c	 movzx	 eax, WORD PTR midawlen$[rsp]
  00714	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0071c	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00723	48 03 8c 24 80
	00 00 00	 add	 rcx, QWORD PTR midawdat$[rsp]
  0072b	48 8b bc 24 78
	01 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  00733	48 8b f1	 mov	 rsi, rcx
  00736	8b c8		 mov	 ecx, eax
  00738	f3 a4		 rep movsb

; 3589 :                                     dev->mainstor + midawdat,
; 3590 :                                     midawlen);
; 3591 :                             prefetch->pos += midawlen;

  0073a	0f b7 44 24 5c	 movzx	 eax, WORD PTR midawlen$[rsp]
  0073f	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00747	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  0074a	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00752	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 3592 :                             if (prefetch->seq)

  00755	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  0075d	83 38 00	 cmp	 DWORD PTR [rax], 0
  00760	74 18		 je	 SHORT $LN104@z900_copy_

; 3593 :                                 prefetch->datalen[ps] = midawlen;

  00762	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  00766	0f b7 4c 24 5c	 movzx	 ecx, WORD PTR midawlen$[rsp]
  0076b	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR prefetch$[rsp]
  00773	89 8c 82 10 05
	00 00		 mov	 DWORD PTR [rdx+rax*4+1296], ecx
$LN104@z900_copy_:

; 3594 :                         }

  0077a	eb 2b		 jmp	 SHORT $LN103@z900_copy_
$LN102@z900_copy_:

; 3595 :                         else
; 3596 :                         {
; 3597 :                             memcpy (dev->mainstor + midawdat,

  0077c	0f b7 44 24 5c	 movzx	 eax, WORD PTR midawlen$[rsp]
  00781	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00789	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00790	48 03 8c 24 80
	00 00 00	 add	 rcx, QWORD PTR midawdat$[rsp]
  00798	48 8b f9	 mov	 rdi, rcx
  0079b	48 8b b4 24 78
	01 00 00	 mov	 rsi, QWORD PTR iobuf$[rsp]
  007a3	8b c8		 mov	 ecx, eax
  007a5	f3 a4		 rep movsb
$LN103@z900_copy_:

; 3598 :                                     iobuf,
; 3599 :                                     midawlen);
; 3600 :                         }
; 3601 : 
; 3602 :                         /* Increment buffer pointer */
; 3603 :                         iobuf += midawlen;

  007a7	0f b7 44 24 5c	 movzx	 eax, WORD PTR midawlen$[rsp]
  007ac	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  007b4	48 03 c8	 add	 rcx, rax
  007b7	48 8b c1	 mov	 rax, rcx
  007ba	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR iobuf$[rsp], rax
$LN101@z900_copy_:
$LN85@z900_copy_:

; 3604 :                     }
; 3605 : 
; 3606 :                 } /* end if(!MIDAW_FLAG_SKIP) */
; 3607 : 
; 3608 :                 /* Display the MIDAW if CCW tracing is on */
; 3609 :                 if (!prefetch->seq && dev->ccwtrace)

  007c2	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  007ca	83 38 00	 cmp	 DWORD PTR [rax], 0
  007cd	0f 85 bd 00 00
	00		 jne	 $LN105@z900_copy_
  007d3	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007db	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  007e1	c1 e8 0f	 shr	 eax, 15
  007e4	83 e0 01	 and	 eax, 1
  007e7	85 c0		 test	 eax, eax
  007e9	0f 84 a1 00 00
	00		 je	 $LN105@z900_copy_

; 3610 :                 {
; 3611 :                     /* Trace the CCW first, then the MIDAW, but only
; 3612 :                        if this is a read type CCW as determined by
; 3613 :                        the direction of the copying. (For write type
; 3614 :                        CCws, channel code properly traces CCWs before
; 3615 :                        we're even called.)
; 3616 :                     */
; 3617 :                     if (to_memory)

  007ef	0f b6 44 24 58	 movzx	 eax, BYTE PTR to_memory$[rsp]
  007f4	85 c0		 test	 eax, eax
  007f6	74 51		 je	 SHORT $LN106@z900_copy_

; 3618 :                         DISPLAY_CCW( dev, ccw, addr, count, flags );

  007f8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196256
  007ff	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00804	c7 44 24 30 22
	0e 00 00	 mov	 DWORD PTR [rsp+48], 3618 ; 00000e22H
  0080c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196257
  00813	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00818	0f b6 84 24 48
	01 00 00	 movzx	 eax, BYTE PTR flags$[rsp]
  00820	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00824	44 8b 8c 24 58
	01 00 00	 mov	 r9d, DWORD PTR count$[rsp]
  0082c	44 8b 84 24 50
	01 00 00	 mov	 r8d, DWORD PTR addr$[rsp]
  00834	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR ccw$[rsp]
  0083c	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00844	e8 00 00 00 00	 call	 _display_ccw
$LN106@z900_copy_:

; 3619 :                     DISPLAY_IDAW( dev, PF_MIDAW, midawflg, midawdat, midawlen );

  00849	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196258
  00850	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00855	c7 44 24 30 23
	0e 00 00	 mov	 DWORD PTR [rsp+48], 3619 ; 00000e23H
  0085d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196259
  00864	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00869	0f b7 44 24 5c	 movzx	 eax, WORD PTR midawlen$[rsp]
  0086e	66 89 44 24 20	 mov	 WORD PTR [rsp+32], ax
  00873	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR midawdat$[rsp]
  0087b	44 0f b6 44 24
	61		 movzx	 r8d, BYTE PTR midawflg$[rsp]
  00881	b2 03		 mov	 dl, 3
  00883	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0088b	e8 00 00 00 00	 call	 _display_idaw
$LN105@z900_copy_:

; 3620 :                 }
; 3621 : #if DEBUG_DUMP
; 3622 :                 if (dev->ccwtrace)
; 3623 :                 {
; 3624 :                     if (to_memory)
; 3625 :                         DUMP("iobuf:", iobuf, midawlen);
; 3626 :                     DUMP_STORAGE("Storage:", midawdat, midawlen);
; 3627 :                     if (to_iobuf)
; 3628 :                         DUMP("iobuf:", iobuf, midawlen);
; 3629 :                 }
; 3630 : #endif
; 3631 :                 /* Decrement remaining count */
; 3632 :                 midawrem -= midawlen;

  00890	0f b7 44 24 5c	 movzx	 eax, WORD PTR midawlen$[rsp]
  00895	0f b7 4c 24 68	 movzx	 ecx, WORD PTR midawrem$[rsp]
  0089a	2b c8		 sub	 ecx, eax
  0089c	8b c1		 mov	 eax, ecx
  0089e	66 89 44 24 68	 mov	 WORD PTR midawrem$[rsp], ax
$LN83@z900_copy_:

; 3633 : 
; 3634 :             }
; 3635 : 
; 3636 :             /* Increment to next MIDAW address */
; 3637 :             midawptr += 16;

  008a3	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR midawptr$[rsp]
  008aa	83 c0 10	 add	 eax, 16
  008ad	89 84 24 90 00
	00 00		 mov	 DWORD PTR midawptr$[rsp], eax

; 3638 : 
; 3639 :         } /* end for(midawseq) */

  008b4	e9 2b f9 ff ff	 jmp	 $LN8@z900_copy_
$LN9@z900_copy_:

; 3640 : 
; 3641 :         /* Channel program check if sum of MIDAW lengths
; 3642 :            did not exhaust the CCW count and no pending status */
; 3643 :         if (1
; 3644 :             && midawrem > 0
; 3645 :             && *chanstat != 0
; 3646 :             && !(prefetch->seq && prefetch->chanstat[ps])

  008b9	33 c0		 xor	 eax, eax
  008bb	83 f8 01	 cmp	 eax, 1
  008be	74 6b		 je	 SHORT $LN107@z900_copy_
  008c0	0f b7 44 24 68	 movzx	 eax, WORD PTR midawrem$[rsp]
  008c5	85 c0		 test	 eax, eax
  008c7	7e 62		 jle	 SHORT $LN107@z900_copy_
  008c9	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  008d1	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  008d4	85 c0		 test	 eax, eax
  008d6	74 53		 je	 SHORT $LN107@z900_copy_
  008d8	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  008e0	83 38 00	 cmp	 DWORD PTR [rax], 0
  008e3	74 15		 je	 SHORT $LN108@z900_copy_
  008e5	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  008e9	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  008f1	0f b6 44 01 10	 movzx	 eax, BYTE PTR [rcx+rax+16]
  008f6	85 c0		 test	 eax, eax
  008f8	75 31		 jne	 SHORT $LN107@z900_copy_
$LN108@z900_copy_:
$LN25@z900_copy_:

; 3647 :         )
; 3648 :             set_chanstat( CSW_PROGC );

  008fa	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00902	83 38 00	 cmp	 DWORD PTR [rax], 0
  00905	74 13		 je	 SHORT $LN109@z900_copy_
  00907	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  0090b	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00913	c6 44 01 10 20	 mov	 BYTE PTR [rcx+rax+16], 32 ; 00000020H
  00918	eb 0b		 jmp	 SHORT $LN110@z900_copy_
$LN109@z900_copy_:
  0091a	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00922	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H
$LN110@z900_copy_:
  00925	33 c0		 xor	 eax, eax
  00927	85 c0		 test	 eax, eax
  00929	75 cf		 jne	 SHORT $LN25@z900_copy_
$LN107@z900_copy_:

; 3649 : 
; 3650 :     } /* end if(CCW_FLAGS_MIDAW) */

  0092b	e9 7a 10 00 00	 jmp	 $LN68@z900_copy_
$LN67@z900_copy_:

; 3651 :     else
; 3652 : #endif /*defined(FEATURE_MIDAW_FACILITY)*/
; 3653 :     /* Move data when indirect data addressing is used */
; 3654 :     if (flags & CCW_FLAGS_IDA)

  00930	0f b6 84 24 48
	01 00 00	 movzx	 eax, BYTE PTR flags$[rsp]
  00938	83 e0 04	 and	 eax, 4
  0093b	85 c0		 test	 eax, eax
  0093d	0f 84 4e 09 00
	00		 je	 $LN111@z900_copy_

; 3655 :     {
; 3656 :         if (prefetch->seq)

  00943	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  0094b	83 38 00	 cmp	 DWORD PTR [rax], 0
  0094e	74 17		 je	 SHORT $LN113@z900_copy_

; 3657 :             prefetch->datalen[ps] = 0;

  00950	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  00954	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  0095c	c7 84 81 10 05
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+1296], 0
$LN113@z900_copy_:

; 3658 : 
; 3659 :         idawaddr = addr;

  00967	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  0096e	89 44 24 78	 mov	 DWORD PTR idawaddr$[rsp], eax

; 3660 :         idacount = count;

  00972	0f b7 84 24 58
	01 00 00	 movzx	 eax, WORD PTR count$[rsp]
  0097a	66 89 44 24 64	 mov	 WORD PTR idacount$[rsp], ax

; 3661 :         idasize = (idawfmt == PF_IDAW1) ? 4 : 8;

  0097f	0f b6 84 24 68
	01 00 00	 movzx	 eax, BYTE PTR idawfmt$[rsp]
  00987	83 f8 01	 cmp	 eax, 1
  0098a	75 0d		 jne	 SHORT $LN193@z900_copy_
  0098c	c7 84 24 ac 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv405[rsp], 4
  00997	eb 0b		 jmp	 SHORT $LN194@z900_copy_
$LN193@z900_copy_:
  00999	c7 84 24 ac 00
	00 00 08 00 00
	00		 mov	 DWORD PTR tv405[rsp], 8
$LN194@z900_copy_:
  009a4	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR tv405[rsp]
  009ab	89 84 24 b0 00
	00 00		 mov	 DWORD PTR idasize$[rsp], eax

; 3662 : 
; 3663 :         for (idaseq = 0;

  009b2	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR idaseq$[rsp], 0
  009bd	eb 10		 jmp	 SHORT $LN28@z900_copy_
$LN26@z900_copy_:

; 3666 :                 !(prefetch->seq &&
; 3667 :                     (prefetch->chanstat[ps] ||
; 3668 :                         ((ps+1) < prefetch->seq &&
; 3669 :                             prefetch->chanstat[ps+1])));
; 3670 :              idaseq++)

  009bf	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR idaseq$[rsp]
  009c6	ff c0		 inc	 eax
  009c8	89 84 24 a4 00
	00 00		 mov	 DWORD PTR idaseq$[rsp], eax
$LN28@z900_copy_:

; 3664 :              idacount > 0 &&
; 3665 :                 chanstat != 0 &&

  009cf	0f b7 44 24 64	 movzx	 eax, WORD PTR idacount$[rsp]
  009d4	85 c0		 test	 eax, eax
  009d6	0f 8e b0 08 00
	00		 jle	 $LN27@z900_copy_
  009dc	48 83 bc 24 90
	01 00 00 00	 cmp	 QWORD PTR chanstat$[rsp], 0
  009e5	0f 84 a1 08 00
	00		 je	 $LN27@z900_copy_
  009eb	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  009f3	83 38 00	 cmp	 DWORD PTR [rax], 0
  009f6	74 48		 je	 SHORT $LN114@z900_copy_
  009f8	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  009fc	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00a04	0f b6 44 01 10	 movzx	 eax, BYTE PTR [rcx+rax+16]
  00a09	85 c0		 test	 eax, eax
  00a0b	0f 85 7b 08 00
	00		 jne	 $LN27@z900_copy_
  00a11	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  00a15	ff c0		 inc	 eax
  00a17	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00a1f	3b 01		 cmp	 eax, DWORD PTR [rcx]
  00a21	73 1d		 jae	 SHORT $LN115@z900_copy_
  00a23	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  00a27	ff c0		 inc	 eax
  00a29	8b c0		 mov	 eax, eax
  00a2b	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00a33	0f b6 44 01 10	 movzx	 eax, BYTE PTR [rcx+rax+16]
  00a38	85 c0		 test	 eax, eax
  00a3a	0f 85 4c 08 00
	00		 jne	 $LN27@z900_copy_
$LN115@z900_copy_:
$LN114@z900_copy_:
$LN31@z900_copy_:

; 3671 :         {
; 3672 :             /* Get new prefetch entry */
; 3673 :             get_new_prefetch_entry( idawfmt, idawaddr );

  00a40	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00a48	83 38 00	 cmp	 DWORD PTR [rax], 0
  00a4b	0f 84 a9 00 00
	00		 je	 $LN116@z900_copy_
  00a51	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00a59	8b 00		 mov	 eax, DWORD PTR [rax]
  00a5b	89 44 24 50	 mov	 DWORD PTR ps$[rsp], eax
  00a5f	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00a67	8b 00		 mov	 eax, DWORD PTR [rax]
  00a69	ff c0		 inc	 eax
  00a6b	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00a73	89 01		 mov	 DWORD PTR [rcx], eax
  00a75	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00a7d	81 38 00 01 00
	00		 cmp	 DWORD PTR [rax], 256	; 00000100H
  00a83	76 0d		 jbe	 SHORT $LN117@z900_copy_
  00a85	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00a8d	c6 00 08	 mov	 BYTE PTR [rax], 8
  00a90	eb 7d		 jmp	 SHORT $LN30@z900_copy_
$LN117@z900_copy_:
  00a92	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  00a96	ff c8		 dec	 eax
  00a98	8b c0		 mov	 eax, eax
  00a9a	8b 4c 24 50	 mov	 ecx, DWORD PTR ps$[rsp]
  00a9e	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR prefetch$[rsp]
  00aa6	48 8b bc 24 a0
	01 00 00	 mov	 rdi, QWORD PTR prefetch$[rsp]
  00aae	8b 84 87 10 01
	00 00		 mov	 eax, DWORD PTR [rdi+rax*4+272]
  00ab5	89 84 8a 10 01
	00 00		 mov	 DWORD PTR [rdx+rcx*4+272], eax
  00abc	0f b6 84 24 68
	01 00 00	 movzx	 eax, BYTE PTR idawfmt$[rsp]
  00ac4	85 c0		 test	 eax, eax
  00ac6	74 32		 je	 SHORT $LN118@z900_copy_
  00ac8	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  00acc	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00ad4	0f b6 94 24 68
	01 00 00	 movzx	 edx, BYTE PTR idawfmt$[rsp]
  00adc	88 94 01 10 18
	00 00		 mov	 BYTE PTR [rcx+rax+6160], dl
  00ae3	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  00ae7	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00aef	8b 54 24 78	 mov	 edx, DWORD PTR idawaddr$[rsp]
  00af3	89 94 81 10 14
	00 00		 mov	 DWORD PTR [rcx+rax*4+5136], edx
$LN118@z900_copy_:
$LN116@z900_copy_:
  00afa	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00b02	c6 00 00	 mov	 BYTE PTR [rax], 0
  00b05	33 c0		 xor	 eax, eax
  00b07	85 c0		 test	 eax, eax
  00b09	0f 85 31 ff ff
	ff		 jne	 $LN31@z900_copy_
$LN30@z900_copy_:

; 3674 : 
; 3675 :             if (*chanstat != 0)

  00b0f	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00b17	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00b1a	85 c0		 test	 eax, eax
  00b1c	74 05		 je	 SHORT $LN119@z900_copy_

; 3676 :                 break;

  00b1e	e9 69 07 00 00	 jmp	 $LN27@z900_copy_
$LN119@z900_copy_:

; 3677 : 
; 3678 :             /* Fetch the IDAW and set IDA pointer and length */
; 3679 :             ARCH_DEP( fetch_idaw )( dev, code, ccwkey, idawfmt,

  00b23	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00b2b	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00b30	48 8d 44 24 54	 lea	 rax, QWORD PTR idalen$[rsp]
  00b35	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00b3a	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR idadata$[rsp]
  00b42	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00b47	8b 44 24 78	 mov	 eax, DWORD PTR idawaddr$[rsp]
  00b4b	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00b4f	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR idaseq$[rsp]
  00b56	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00b5a	0f b7 84 24 70
	01 00 00	 movzx	 eax, WORD PTR idapmask$[rsp]
  00b62	66 89 44 24 20	 mov	 WORD PTR [rsp+32], ax
  00b67	44 0f b6 8c 24
	68 01 00 00	 movzx	 r9d, BYTE PTR idawfmt$[rsp]
  00b70	44 0f b6 84 24
	60 01 00 00	 movzx	 r8d, BYTE PTR ccwkey$[rsp]
  00b79	0f b6 94 24 40
	01 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  00b81	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00b89	e8 00 00 00 00	 call	 z900_fetch_idaw

; 3680 :                         idapmask, idaseq, idawaddr,
; 3681 :                         &idadata, &idalen, chanstat );
; 3682 : 
; 3683 :             /* Exit if fetch_idaw detected channel program check */
; 3684 :             if (prefetch->seq)

  00b8e	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00b96	83 38 00	 cmp	 DWORD PTR [rax], 0
  00b99	74 70		 je	 SHORT $LN120@z900_copy_

; 3685 :             {
; 3686 :                 prefetch->dataaddr[ps] = idadata;

  00b9b	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  00b9f	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00ba7	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR idadata$[rsp]
  00baf	48 89 94 c1 10
	09 00 00	 mov	 QWORD PTR [rcx+rax*8+2320], rdx

; 3687 :                 prefetch->datalen[ps]  = idalen;

  00bb7	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  00bbb	0f b7 4c 24 54	 movzx	 ecx, WORD PTR idalen$[rsp]
  00bc0	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR prefetch$[rsp]
  00bc8	89 8c 82 10 05
	00 00		 mov	 DWORD PTR [rdx+rax*4+1296], ecx

; 3688 : 
; 3689 :                 if (*chanstat != 0)

  00bcf	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00bd7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00bda	85 c0		 test	 eax, eax
  00bdc	74 2b		 je	 SHORT $LN122@z900_copy_

; 3690 :                 {
; 3691 :                     prefetch->chanstat[ps] = *chanstat;

  00bde	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  00be2	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00bea	48 8b 94 24 90
	01 00 00	 mov	 rdx, QWORD PTR chanstat$[rsp]
  00bf2	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  00bf5	88 54 01 10	 mov	 BYTE PTR [rcx+rax+16], dl

; 3692 :                     *chanstat = 0;

  00bf9	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00c01	c6 00 00	 mov	 BYTE PTR [rax], 0

; 3693 :                     break;

  00c04	e9 83 06 00 00	 jmp	 $LN27@z900_copy_
$LN122@z900_copy_:

; 3694 :                 }
; 3695 :             }

  00c09	eb 14		 jmp	 SHORT $LN121@z900_copy_
$LN120@z900_copy_:

; 3696 :             else if (*chanstat != 0)

  00c0b	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00c13	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00c16	85 c0		 test	 eax, eax
  00c18	74 05		 je	 SHORT $LN123@z900_copy_

; 3697 :                 break;

  00c1a	e9 6d 06 00 00	 jmp	 $LN27@z900_copy_
$LN123@z900_copy_:
$LN121@z900_copy_:

; 3698 : 
; 3699 :             /* Channel protection check if IDAW data location is
; 3700 :                fetch protected, or if location is store protected
; 3701 :                and command is READ, READ BACKWARD, or SENSE */
; 3702 :             storkey = ARCH_DEP( get_dev_storage_key )( dev, idadata );

  00c1f	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR idadata$[rsp]
  00c27	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00c2f	e8 00 00 00 00	 call	 z900_get_dev_storage_key
  00c34	88 44 24 60	 mov	 BYTE PTR storkey$[rsp], al

; 3703 : 
; 3704 :             if (1
; 3705 :                 && ccwkey != 0
; 3706 :                 && (storkey & STORKEY_KEY) != ccwkey
; 3707 :                 && ((storkey & STORKEY_FETCH) || to_memory)

  00c38	33 c0		 xor	 eax, eax
  00c3a	83 f8 01	 cmp	 eax, 1
  00c3d	74 6d		 je	 SHORT $LN124@z900_copy_
  00c3f	0f b6 84 24 60
	01 00 00	 movzx	 eax, BYTE PTR ccwkey$[rsp]
  00c47	85 c0		 test	 eax, eax
  00c49	74 61		 je	 SHORT $LN124@z900_copy_
  00c4b	0f b6 44 24 60	 movzx	 eax, BYTE PTR storkey$[rsp]
  00c50	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00c55	0f b6 8c 24 60
	01 00 00	 movzx	 ecx, BYTE PTR ccwkey$[rsp]
  00c5d	3b c1		 cmp	 eax, ecx
  00c5f	74 4b		 je	 SHORT $LN124@z900_copy_
  00c61	0f b6 44 24 60	 movzx	 eax, BYTE PTR storkey$[rsp]
  00c66	83 e0 08	 and	 eax, 8
  00c69	85 c0		 test	 eax, eax
  00c6b	75 09		 jne	 SHORT $LN125@z900_copy_
  00c6d	0f b6 44 24 58	 movzx	 eax, BYTE PTR to_memory$[rsp]
  00c72	85 c0		 test	 eax, eax
  00c74	74 36		 je	 SHORT $LN124@z900_copy_
$LN125@z900_copy_:
$LN34@z900_copy_:

; 3708 :             )
; 3709 :             {
; 3710 :                 set_chanstat(CSW_PROTC);

  00c76	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00c7e	83 38 00	 cmp	 DWORD PTR [rax], 0
  00c81	74 13		 je	 SHORT $LN126@z900_copy_
  00c83	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  00c87	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00c8f	c6 44 01 10 10	 mov	 BYTE PTR [rcx+rax+16], 16
  00c94	eb 0b		 jmp	 SHORT $LN127@z900_copy_
$LN126@z900_copy_:
  00c96	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00c9e	c6 00 10	 mov	 BYTE PTR [rax], 16
$LN127@z900_copy_:
  00ca1	33 c0		 xor	 eax, eax
  00ca3	85 c0		 test	 eax, eax
  00ca5	75 cf		 jne	 SHORT $LN34@z900_copy_

; 3711 :                 break;

  00ca7	e9 e0 05 00 00	 jmp	 $LN27@z900_copy_
$LN124@z900_copy_:

; 3712 :             }
; 3713 : 
; 3714 :             /* Reduce length if less than one page remaining */
; 3715 :             if (idalen > idacount)

  00cac	0f b7 44 24 54	 movzx	 eax, WORD PTR idalen$[rsp]
  00cb1	0f b7 4c 24 64	 movzx	 ecx, WORD PTR idacount$[rsp]
  00cb6	3b c1		 cmp	 eax, ecx
  00cb8	7e 2f		 jle	 SHORT $LN128@z900_copy_

; 3716 :             {
; 3717 :                 idalen = idacount;

  00cba	0f b7 44 24 64	 movzx	 eax, WORD PTR idacount$[rsp]
  00cbf	66 89 44 24 54	 mov	 WORD PTR idalen$[rsp], ax

; 3718 : 
; 3719 :                 if (prefetch->seq)

  00cc4	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00ccc	83 38 00	 cmp	 DWORD PTR [rax], 0
  00ccf	74 18		 je	 SHORT $LN129@z900_copy_

; 3720 :                    prefetch->datalen[ps] = idacount;

  00cd1	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  00cd5	0f b7 4c 24 64	 movzx	 ecx, WORD PTR idacount$[rsp]
  00cda	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR prefetch$[rsp]
  00ce2	89 8c 82 10 05
	00 00		 mov	 DWORD PTR [rdx+rax*4+1296], ecx
$LN129@z900_copy_:
$LN128@z900_copy_:

; 3721 :             }
; 3722 : 
; 3723 :             /* Ensure memcpy will stay within buffer         */
; 3724 :             /* Channel data check if outside buffer          */
; 3725 :             /* SA22-7201-05:                                 */
; 3726 :             /*  p. 16-27, Channel-Data Check                 */
; 3727 :             if (readbackwards)

  00ce9	0f b6 44 24 59	 movzx	 eax, BYTE PTR readbackwards$[rsp]
  00cee	85 c0		 test	 eax, eax
  00cf0	0f 84 c6 00 00
	00		 je	 $LN130@z900_copy_

; 3728 :             {
; 3729 :                 iobufptr = iobuf + dev->curblkrem + idacount - idalen;

  00cf6	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00cfe	8b 80 18 10 00
	00		 mov	 eax, DWORD PTR [rax+4120]
  00d04	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00d0c	48 03 c8	 add	 rcx, rax
  00d0f	48 8b c1	 mov	 rax, rcx
  00d12	0f b7 4c 24 64	 movzx	 ecx, WORD PTR idacount$[rsp]
  00d17	48 03 c1	 add	 rax, rcx
  00d1a	0f b7 4c 24 54	 movzx	 ecx, WORD PTR idalen$[rsp]
  00d1f	48 2b c1	 sub	 rax, rcx
  00d22	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR iobufptr$[rsp], rax

; 3730 : 
; 3731 :                 if ((iobufptr + idalen) > (iobufend + 1) ||

  00d2a	0f b7 44 24 54	 movzx	 eax, WORD PTR idalen$[rsp]
  00d2f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR iobufptr$[rsp]
  00d37	48 03 c8	 add	 rcx, rax
  00d3a	48 8b c1	 mov	 rax, rcx
  00d3d	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR iobufend$[rsp]
  00d45	48 ff c1	 inc	 rcx
  00d48	48 3b c1	 cmp	 rax, rcx
  00d4b	77 1d		 ja	 SHORT $LN133@z900_copy_
  00d4d	0f b7 44 24 54	 movzx	 eax, WORD PTR idalen$[rsp]
  00d52	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR iobufptr$[rsp]
  00d5a	48 03 c8	 add	 rcx, rax
  00d5d	48 8b c1	 mov	 rax, rcx
  00d60	48 3b 84 24 80
	01 00 00	 cmp	 rax, QWORD PTR iobufstart$[rsp]
  00d68	77 10		 ja	 SHORT $LN132@z900_copy_
$LN133@z900_copy_:

; 3732 :                     (iobufptr + idalen) <= iobufstart)
; 3733 :                 {
; 3734 :                     *chanstat = CSW_CDC;

  00d6a	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00d72	c6 00 08	 mov	 BYTE PTR [rax], 8

; 3735 :                     return;

  00d75	e9 30 0c 00 00	 jmp	 $LN1@z900_copy_
$LN132@z900_copy_:

; 3736 :                 }
; 3737 : 
; 3738 :                 if (iobufptr < iobufstart)

  00d7a	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR iobufstart$[rsp]
  00d82	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR iobufptr$[rsp], rax
  00d8a	73 2b		 jae	 SHORT $LN134@z900_copy_

; 3739 :                 {
; 3740 :                     *chanstat = CSW_CDC;

  00d8c	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00d94	c6 00 08	 mov	 BYTE PTR [rax], 8

; 3741 : 
; 3742 :                     /* Reset length to copy to buffer */
; 3743 :                     idalen = iobufptr + idalen - iobufstart;

  00d97	0f b7 44 24 54	 movzx	 eax, WORD PTR idalen$[rsp]
  00d9c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR iobufptr$[rsp]
  00da4	48 03 c8	 add	 rcx, rax
  00da7	48 8b c1	 mov	 rax, rcx
  00daa	48 2b 84 24 80
	01 00 00	 sub	 rax, QWORD PTR iobufstart$[rsp]
  00db2	66 89 44 24 54	 mov	 WORD PTR idalen$[rsp], ax
$LN134@z900_copy_:

; 3744 :                 }
; 3745 :             }

  00db7	e9 47 02 00 00	 jmp	 $LN131@z900_copy_
$LN130@z900_copy_:

; 3746 :             else if (iobuf < iobufstart || iobuf > iobufend)

  00dbc	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR iobufstart$[rsp]
  00dc4	48 39 84 24 78
	01 00 00	 cmp	 QWORD PTR iobuf$[rsp], rax
  00dcc	72 12		 jb	 SHORT $LN137@z900_copy_
  00dce	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR iobufend$[rsp]
  00dd6	48 39 84 24 78
	01 00 00	 cmp	 QWORD PTR iobuf$[rsp], rax
  00dde	76 3b		 jbe	 SHORT $LN135@z900_copy_
$LN137@z900_copy_:
$LN37@z900_copy_:

; 3747 :             {
; 3748 :                 set_chanstat( CSW_CDC );

  00de0	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00de8	83 38 00	 cmp	 DWORD PTR [rax], 0
  00deb	74 13		 je	 SHORT $LN138@z900_copy_
  00ded	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  00df1	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00df9	c6 44 01 10 08	 mov	 BYTE PTR [rcx+rax+16], 8
  00dfe	eb 0b		 jmp	 SHORT $LN139@z900_copy_
$LN138@z900_copy_:
  00e00	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00e08	c6 00 08	 mov	 BYTE PTR [rax], 8
$LN139@z900_copy_:
  00e0b	33 c0		 xor	 eax, eax
  00e0d	85 c0		 test	 eax, eax
  00e0f	75 cf		 jne	 SHORT $LN37@z900_copy_

; 3749 :                 break;

  00e11	e9 76 04 00 00	 jmp	 $LN27@z900_copy_

; 3750 :             }

  00e16	e9 e8 01 00 00	 jmp	 $LN136@z900_copy_
$LN135@z900_copy_:

; 3751 :             else if ((iobuf + idalen) > (iobufend + 1))

  00e1b	0f b7 44 24 54	 movzx	 eax, WORD PTR idalen$[rsp]
  00e20	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00e28	48 03 c8	 add	 rcx, rax
  00e2b	48 8b c1	 mov	 rax, rcx
  00e2e	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR iobufend$[rsp]
  00e36	48 ff c1	 inc	 rcx
  00e39	48 3b c1	 cmp	 rax, rcx
  00e3c	0f 86 c1 01 00
	00		 jbe	 $LN140@z900_copy_

; 3752 :             {
; 3753 :                 /* Reset length to copy to buffer */
; 3754 :                 idalen = iobufend - iobuf + 1;

  00e42	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  00e4a	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR iobufend$[rsp]
  00e52	48 2b c8	 sub	 rcx, rax
  00e55	48 8b c1	 mov	 rax, rcx
  00e58	48 ff c0	 inc	 rax
  00e5b	66 89 44 24 54	 mov	 WORD PTR idalen$[rsp], ax

; 3755 : 
; 3756 :                 if (prefetch->seq)

  00e60	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00e68	83 38 00	 cmp	 DWORD PTR [rax], 0
  00e6b	0f 84 61 01 00
	00		 je	 $LN141@z900_copy_

; 3757 :                 {
; 3758 :                     prefetch->datalen[ps] = idalen;

  00e71	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  00e75	0f b7 4c 24 54	 movzx	 ecx, WORD PTR idalen$[rsp]
  00e7a	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR prefetch$[rsp]
  00e82	89 8c 82 10 05
	00 00		 mov	 DWORD PTR [rdx+rax*4+1296], ecx
$LN40@z900_copy_:

; 3759 : 
; 3760 :                     /* Get new prefetch entry for channel data
; 3761 :                        check */
; 3762 :                     get_new_prefetch_entry( idawfmt, idawaddr );

  00e89	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00e91	83 38 00	 cmp	 DWORD PTR [rax], 0
  00e94	0f 84 a9 00 00
	00		 je	 $LN143@z900_copy_
  00e9a	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00ea2	8b 00		 mov	 eax, DWORD PTR [rax]
  00ea4	89 44 24 50	 mov	 DWORD PTR ps$[rsp], eax
  00ea8	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00eb0	8b 00		 mov	 eax, DWORD PTR [rax]
  00eb2	ff c0		 inc	 eax
  00eb4	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00ebc	89 01		 mov	 DWORD PTR [rcx], eax
  00ebe	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00ec6	81 38 00 01 00
	00		 cmp	 DWORD PTR [rax], 256	; 00000100H
  00ecc	76 0d		 jbe	 SHORT $LN144@z900_copy_
  00ece	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00ed6	c6 00 08	 mov	 BYTE PTR [rax], 8
  00ed9	eb 7d		 jmp	 SHORT $LN39@z900_copy_
$LN144@z900_copy_:
  00edb	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  00edf	ff c8		 dec	 eax
  00ee1	8b c0		 mov	 eax, eax
  00ee3	8b 4c 24 50	 mov	 ecx, DWORD PTR ps$[rsp]
  00ee7	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR prefetch$[rsp]
  00eef	48 8b bc 24 a0
	01 00 00	 mov	 rdi, QWORD PTR prefetch$[rsp]
  00ef7	8b 84 87 10 01
	00 00		 mov	 eax, DWORD PTR [rdi+rax*4+272]
  00efe	89 84 8a 10 01
	00 00		 mov	 DWORD PTR [rdx+rcx*4+272], eax
  00f05	0f b6 84 24 68
	01 00 00	 movzx	 eax, BYTE PTR idawfmt$[rsp]
  00f0d	85 c0		 test	 eax, eax
  00f0f	74 32		 je	 SHORT $LN145@z900_copy_
  00f11	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  00f15	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00f1d	0f b6 94 24 68
	01 00 00	 movzx	 edx, BYTE PTR idawfmt$[rsp]
  00f25	88 94 01 10 18
	00 00		 mov	 BYTE PTR [rcx+rax+6160], dl
  00f2c	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  00f30	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00f38	8b 54 24 78	 mov	 edx, DWORD PTR idawaddr$[rsp]
  00f3c	89 94 81 10 14
	00 00		 mov	 DWORD PTR [rcx+rax*4+5136], edx
$LN145@z900_copy_:
$LN143@z900_copy_:
  00f43	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00f4b	c6 00 00	 mov	 BYTE PTR [rax], 0
  00f4e	33 c0		 xor	 eax, eax
  00f50	85 c0		 test	 eax, eax
  00f52	0f 85 31 ff ff
	ff		 jne	 $LN40@z900_copy_
$LN39@z900_copy_:

; 3763 : 
; 3764 :                     if (*chanstat != 0)

  00f58	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00f60	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00f63	85 c0		 test	 eax, eax
  00f65	74 05		 je	 SHORT $LN146@z900_copy_

; 3765 :                         break;

  00f67	e9 20 03 00 00	 jmp	 $LN27@z900_copy_
$LN146@z900_copy_:

; 3766 : 
; 3767 :                     prefetch->dataaddr[ps] = idadata + idalen;

  00f6c	0f b7 44 24 54	 movzx	 eax, WORD PTR idalen$[rsp]
  00f71	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR idadata$[rsp]
  00f79	48 03 c8	 add	 rcx, rax
  00f7c	48 8b c1	 mov	 rax, rcx
  00f7f	8b 4c 24 50	 mov	 ecx, DWORD PTR ps$[rsp]
  00f83	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR prefetch$[rsp]
  00f8b	48 89 84 ca 10
	09 00 00	 mov	 QWORD PTR [rdx+rcx*8+2320], rax

; 3768 :                     prefetch->datalen[ps]  = 1;

  00f93	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  00f97	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00f9f	c7 84 81 10 05
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+1296], 1

; 3769 :                     prefetch->chanstat[ps] = *chanstat = CSW_CDC;

  00faa	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00fb2	c6 00 08	 mov	 BYTE PTR [rax], 8
  00fb5	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  00fb9	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00fc1	c6 44 01 10 08	 mov	 BYTE PTR [rcx+rax+16], 8

; 3770 : 
; 3771 :                     ps -= 1;

  00fc6	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  00fca	ff c8		 dec	 eax
  00fcc	89 44 24 50	 mov	 DWORD PTR ps$[rsp], eax

; 3772 :                 }

  00fd0	eb 31		 jmp	 SHORT $LN142@z900_copy_
$LN141@z900_copy_:
$LN43@z900_copy_:

; 3773 : 
; 3774 :                 /* Set channel data check and permit copy to/from
; 3775 :                    end-of-buffer */
; 3776 :                 else
; 3777 :                     set_chanstat( CSW_CDC );

  00fd2	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00fda	83 38 00	 cmp	 DWORD PTR [rax], 0
  00fdd	74 13		 je	 SHORT $LN147@z900_copy_
  00fdf	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  00fe3	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00feb	c6 44 01 10 08	 mov	 BYTE PTR [rcx+rax+16], 8
  00ff0	eb 0b		 jmp	 SHORT $LN148@z900_copy_
$LN147@z900_copy_:
  00ff2	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00ffa	c6 00 08	 mov	 BYTE PTR [rax], 8
$LN148@z900_copy_:
  00ffd	33 c0		 xor	 eax, eax
  00fff	85 c0		 test	 eax, eax
  01001	75 cf		 jne	 SHORT $LN43@z900_copy_
$LN142@z900_copy_:
$LN140@z900_copy_:
$LN136@z900_copy_:
$LN131@z900_copy_:

; 3778 :             }
; 3779 : 
; 3780 :             /* Copy to I/O buffer */
; 3781 :             if (idalen)

  01003	0f b7 44 24 54	 movzx	 eax, WORD PTR idalen$[rsp]
  01008	85 c0		 test	 eax, eax
  0100a	0f 84 80 01 00
	00		 je	 $LN149@z900_copy_

; 3782 :             {
; 3783 :                 /* Set the main storage reference and change bits */
; 3784 :                 if (to_memory)

  01010	0f b6 44 24 58	 movzx	 eax, BYTE PTR to_memory$[rsp]
  01015	85 c0		 test	 eax, eax
  01017	74 1a		 je	 SHORT $LN150@z900_copy_

; 3785 :                     ARCH_DEP( or_dev_storage_key )( dev, idadata, (STORKEY_REF | STORKEY_CHANGE) );

  01019	41 b0 06	 mov	 r8b, 6
  0101c	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR idadata$[rsp]
  01024	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0102c	e8 00 00 00 00	 call	 z900_or_dev_storage_key
  01031	eb 18		 jmp	 SHORT $LN151@z900_copy_
$LN150@z900_copy_:

; 3786 :                 else
; 3787 :                     ARCH_DEP( or_dev_storage_key )( dev, idadata, STORKEY_REF );

  01033	41 b0 04	 mov	 r8b, 4
  01036	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR idadata$[rsp]
  0103e	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01046	e8 00 00 00 00	 call	 z900_or_dev_storage_key
$LN151@z900_copy_:

; 3788 : 
; 3789 :                 /* Copy data between main storage and channel buffer */
; 3790 :                 if (readbackwards)

  0104b	0f b6 44 24 59	 movzx	 eax, BYTE PTR readbackwards$[rsp]
  01050	85 c0		 test	 eax, eax
  01052	0f 84 a1 00 00
	00		 je	 $LN152@z900_copy_

; 3791 :                 {
; 3792 :                     idadata = (idadata - idalen) + 1;

  01058	0f b7 44 24 54	 movzx	 eax, WORD PTR idalen$[rsp]
  0105d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR idadata$[rsp]
  01065	48 2b c8	 sub	 rcx, rax
  01068	48 8b c1	 mov	 rax, rcx
  0106b	48 ff c0	 inc	 rax
  0106e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR idadata$[rsp], rax

; 3793 :                     memcpy_backwards( dev->mainstor + idadata,

  01076	0f b7 44 24 54	 movzx	 eax, WORD PTR idalen$[rsp]
  0107b	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01083	8b 89 18 10 00
	00		 mov	 ecx, DWORD PTR [rcx+4120]
  01089	48 8b 94 24 78
	01 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  01091	48 03 d1	 add	 rdx, rcx
  01094	48 8b ca	 mov	 rcx, rdx
  01097	0f b7 54 24 64	 movzx	 edx, WORD PTR idacount$[rsp]
  0109c	48 03 ca	 add	 rcx, rdx
  0109f	0f b7 54 24 54	 movzx	 edx, WORD PTR idalen$[rsp]
  010a4	48 2b ca	 sub	 rcx, rdx
  010a7	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  010af	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  010b6	48 03 94 24 88
	00 00 00	 add	 rdx, QWORD PTR idadata$[rsp]
  010be	48 89 94 24 00
	01 00 00	 mov	 QWORD PTR tv673[rsp], rdx
  010c6	44 8b c0	 mov	 r8d, eax
  010c9	48 8b d1	 mov	 rdx, rcx
  010cc	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR tv673[rsp]
  010d4	48 8b c8	 mov	 rcx, rax
  010d7	e8 00 00 00 00	 call	 memcpy_backwards

; 3794 :                                       iobuf + dev->curblkrem + idacount - idalen,
; 3795 :                                       idalen );
; 3796 : 
; 3797 :                     /* Decrement buffer pointer for next IDAW*/
; 3798 :                     iobuf -= idalen;

  010dc	0f b7 44 24 54	 movzx	 eax, WORD PTR idalen$[rsp]
  010e1	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  010e9	48 2b c8	 sub	 rcx, rax
  010ec	48 8b c1	 mov	 rax, rcx
  010ef	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR iobuf$[rsp], rax

; 3799 :                 }

  010f7	eb 7c		 jmp	 SHORT $LN153@z900_copy_
$LN152@z900_copy_:

; 3800 :                 else
; 3801 :                 {
; 3802 :                     if (to_iobuf)

  010f9	0f b6 44 24 62	 movzx	 eax, BYTE PTR to_iobuf$[rsp]
  010fe	85 c0		 test	 eax, eax
  01100	74 2d		 je	 SHORT $LN154@z900_copy_

; 3803 :                     {
; 3804 :                         memcpy( iobuf, dev->mainstor + idadata, idalen );

  01102	0f b7 44 24 54	 movzx	 eax, WORD PTR idalen$[rsp]
  01107	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0110f	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  01116	48 03 8c 24 88
	00 00 00	 add	 rcx, QWORD PTR idadata$[rsp]
  0111e	48 8b bc 24 78
	01 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  01126	48 8b f1	 mov	 rsi, rcx
  01129	8b c8		 mov	 ecx, eax
  0112b	f3 a4		 rep movsb

; 3805 :                     }

  0112d	eb 2b		 jmp	 SHORT $LN155@z900_copy_
$LN154@z900_copy_:

; 3806 :                     else
; 3807 :                     {
; 3808 :                         memcpy( dev->mainstor + idadata, iobuf, idalen );

  0112f	0f b7 44 24 54	 movzx	 eax, WORD PTR idalen$[rsp]
  01134	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0113c	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  01143	48 03 8c 24 88
	00 00 00	 add	 rcx, QWORD PTR idadata$[rsp]
  0114b	48 8b f9	 mov	 rdi, rcx
  0114e	48 8b b4 24 78
	01 00 00	 mov	 rsi, QWORD PTR iobuf$[rsp]
  01156	8b c8		 mov	 ecx, eax
  01158	f3 a4		 rep movsb
$LN155@z900_copy_:

; 3809 :                     }
; 3810 : 
; 3811 :                     /* Increment buffer pointer for next IDAW*/
; 3812 :                     iobuf += idalen;

  0115a	0f b7 44 24 54	 movzx	 eax, WORD PTR idalen$[rsp]
  0115f	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  01167	48 03 c8	 add	 rcx, rax
  0116a	48 8b c1	 mov	 rax, rcx
  0116d	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR iobuf$[rsp], rax
$LN153@z900_copy_:

; 3813 :                 }
; 3814 : 
; 3815 :                 /* Update prefetch completed bytes */
; 3816 :                 prefetch->pos += idalen;

  01175	0f b7 44 24 54	 movzx	 eax, WORD PTR idalen$[rsp]
  0117a	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  01182	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  01185	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  0118d	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN149@z900_copy_:

; 3817 :             }
; 3818 : 
; 3819 :             /* If not prefetch, display the IDAW if CCW tracing */
; 3820 :             if (!prefetch->seq && dev->ccwtrace)

  01190	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  01198	83 38 00	 cmp	 DWORD PTR [rax], 0
  0119b	0f 85 c0 00 00
	00		 jne	 $LN156@z900_copy_
  011a1	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  011a9	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  011af	c1 e8 0f	 shr	 eax, 15
  011b2	83 e0 01	 and	 eax, 1
  011b5	85 c0		 test	 eax, eax
  011b7	0f 84 a4 00 00
	00		 je	 $LN156@z900_copy_

; 3821 :             {
; 3822 :                 /* Trace the CCW first, then the IDAW, but only
; 3823 :                    if this is a read type CCW as determined by
; 3824 :                    the direction of the copying. (For write type
; 3825 :                    CCws, channel code properly traces CCWs before
; 3826 :                    we're even called.)
; 3827 :                 */
; 3828 :                 if (to_memory)

  011bd	0f b6 44 24 58	 movzx	 eax, BYTE PTR to_memory$[rsp]
  011c2	85 c0		 test	 eax, eax
  011c4	74 51		 je	 SHORT $LN157@z900_copy_

; 3829 :                     DISPLAY_CCW( dev, ccw, addr, count, flags );

  011c6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196311
  011cd	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  011d2	c7 44 24 30 f5
	0e 00 00	 mov	 DWORD PTR [rsp+48], 3829 ; 00000ef5H
  011da	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196312
  011e1	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  011e6	0f b6 84 24 48
	01 00 00	 movzx	 eax, BYTE PTR flags$[rsp]
  011ee	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  011f2	44 8b 8c 24 58
	01 00 00	 mov	 r9d, DWORD PTR count$[rsp]
  011fa	44 8b 84 24 50
	01 00 00	 mov	 r8d, DWORD PTR addr$[rsp]
  01202	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR ccw$[rsp]
  0120a	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01212	e8 00 00 00 00	 call	 _display_ccw
$LN157@z900_copy_:

; 3830 :                 DISPLAY_IDAW( dev, idawfmt, 0, idadata, idalen );

  01217	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196313
  0121e	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  01223	c7 44 24 30 f6
	0e 00 00	 mov	 DWORD PTR [rsp+48], 3830 ; 00000ef6H
  0122b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196314
  01232	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  01237	0f b7 44 24 54	 movzx	 eax, WORD PTR idalen$[rsp]
  0123c	66 89 44 24 20	 mov	 WORD PTR [rsp+32], ax
  01241	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR idadata$[rsp]
  01249	45 33 c0	 xor	 r8d, r8d
  0124c	0f b6 94 24 68
	01 00 00	 movzx	 edx, BYTE PTR idawfmt$[rsp]
  01254	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0125c	e8 00 00 00 00	 call	 _display_idaw
$LN156@z900_copy_:

; 3831 :             }
; 3832 : 
; 3833 : #if DEBUG_DUMP
; 3834 :             if (dev->ccwtrace)
; 3835 :             {
; 3836 :                 if (to_memory)
; 3837 :                     DUMP( "iobuf:", iobuf-idalen, idalen );
; 3838 :                 DUMP_STORAGE( "Storage:", idadata, idalen );
; 3839 :                 if (to_iobuf)
; 3840 :                     DUMP( "iobuf:", iobuf-idalen, idalen );
; 3841 :             }
; 3842 : #endif
; 3843 :             /* Decrement remaining count, increment buffer pointer */
; 3844 :             idacount -= idalen;

  01261	0f b7 44 24 54	 movzx	 eax, WORD PTR idalen$[rsp]
  01266	0f b7 4c 24 64	 movzx	 ecx, WORD PTR idacount$[rsp]
  0126b	2b c8		 sub	 ecx, eax
  0126d	8b c1		 mov	 eax, ecx
  0126f	66 89 44 24 64	 mov	 WORD PTR idacount$[rsp], ax

; 3845 : 
; 3846 :             /* Increment to next IDAW address */
; 3847 :             idawaddr += idasize;

  01274	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR idasize$[rsp]
  0127b	8b 4c 24 78	 mov	 ecx, DWORD PTR idawaddr$[rsp]
  0127f	03 c8		 add	 ecx, eax
  01281	8b c1		 mov	 eax, ecx
  01283	89 44 24 78	 mov	 DWORD PTR idawaddr$[rsp], eax

; 3848 : 
; 3849 :         } /* end for(idaseq) */

  01287	e9 33 f7 ff ff	 jmp	 $LN26@z900_copy_
$LN27@z900_copy_:

; 3850 :     }

  0128c	e9 19 07 00 00	 jmp	 $LN112@z900_copy_
$LN111@z900_copy_:

; 3851 :     else                              /* Non-IDA data addressing */
; 3852 :     {
; 3853 :         /* Point to start of data for read backward command */
; 3854 :         if (readbackwards)

  01291	0f b6 44 24 59	 movzx	 eax, BYTE PTR readbackwards$[rsp]
  01296	85 c0		 test	 eax, eax
  01298	74 1b		 je	 SHORT $LN158@z900_copy_

; 3855 :             addr = addr - (count - 1);

  0129a	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  012a1	ff c8		 dec	 eax
  012a3	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  012aa	2b c8		 sub	 ecx, eax
  012ac	8b c1		 mov	 eax, ecx
  012ae	89 84 24 50 01
	00 00		 mov	 DWORD PTR addr$[rsp], eax
$LN158@z900_copy_:

; 3856 : 
; 3857 :         /* Channel protection check if any data is fetch protected,
; 3858 :            or if location is store protected and command is READ,
; 3859 :            READ BACKWARD, or SENSE.
; 3860 :         */
; 3861 :         startpage = addr;

  012b5	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  012bc	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR startpage$[rsp], rax

; 3862 :         endpage = addr + (count - 1);

  012c4	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  012cb	8b 8c 24 58 01
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  012d2	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  012d6	8b c0		 mov	 eax, eax
  012d8	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR endpage$[rsp], rax

; 3863 : 
; 3864 :         for (page = startpage & STORAGE_KEY_PAGEMASK;

  012e0	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR startpage$[rsp]
  012e8	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  012ee	48 89 44 24 70	 mov	 QWORD PTR page$[rsp], rax
  012f3	eb 10		 jmp	 SHORT $LN46@z900_copy_
$LN44@z900_copy_:

; 3866 :              page += STORAGE_KEY_PAGESIZE)

  012f5	48 8b 44 24 70	 mov	 rax, QWORD PTR page$[rsp]
  012fa	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  01300	48 89 44 24 70	 mov	 QWORD PTR page$[rsp], rax
$LN46@z900_copy_:

; 3865 :              page <= (endpage | STORAGE_KEY_BYTEMASK);

  01305	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR endpage$[rsp]
  0130d	48 0d ff 0f 00
	00		 or	 rax, 4095		; 00000fffH
  01313	48 39 44 24 70	 cmp	 QWORD PTR page$[rsp], rax
  01318	0f 87 88 03 00
	00		 ja	 $LN45@z900_copy_

; 3867 :         {
; 3868 :             /* Channel program check if data is outside main storage */
; 3869 :             if (CHADDRCHK( page, dev ))

  0131e	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01326	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0132d	48 39 44 24 70	 cmp	 QWORD PTR page$[rsp], rax
  01332	77 70		 ja	 SHORT $LN160@z900_copy_
  01334	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0133c	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  01343	83 e0 10	 and	 eax, 16
  01346	85 c0		 test	 eax, eax
  01348	0f 84 97 00 00
	00		 je	 $LN159@z900_copy_
  0134e	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01356	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0135d	83 e0 20	 and	 eax, 32			; 00000020H
  01360	85 c0		 test	 eax, eax
  01362	74 15		 je	 SHORT $LN162@z900_copy_
  01364	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0136b	48 8b 80 60 12
	00 00		 mov	 rax, QWORD PTR [rax+4704]
  01372	48 39 44 24 70	 cmp	 QWORD PTR page$[rsp], rax
  01377	72 2b		 jb	 SHORT $LN161@z900_copy_
$LN162@z900_copy_:
  01379	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01381	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  01388	83 e0 40	 and	 eax, 64			; 00000040H
  0138b	85 c0		 test	 eax, eax
  0138d	74 56		 je	 SHORT $LN159@z900_copy_
  0138f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01396	48 8b 80 60 12
	00 00		 mov	 rax, QWORD PTR [rax+4704]
  0139d	48 39 44 24 70	 cmp	 QWORD PTR page$[rsp], rax
  013a2	72 41		 jb	 SHORT $LN159@z900_copy_
$LN161@z900_copy_:
$LN160@z900_copy_:

; 3870 :             {
; 3871 :                 if (prefetch->seq)

  013a4	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  013ac	83 38 00	 cmp	 DWORD PTR [rax], 0
  013af	74 16		 je	 SHORT $LN163@z900_copy_

; 3872 :                 {
; 3873 :                     prefetch->chanstat[ps] = CSW_PROGC;

  013b1	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  013b5	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  013bd	c6 44 01 10 20	 mov	 BYTE PTR [rcx+rax+16], 32 ; 00000020H

; 3874 :                     break;

  013c2	e9 df 02 00 00	 jmp	 $LN45@z900_copy_
$LN163@z900_copy_:

; 3875 :                 }
; 3876 : 
; 3877 :                 *chanstat = CSW_PROGC;

  013c7	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  013cf	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3878 : 
; 3879 :                 if (readbackwards)

  013d2	0f b6 44 24 59	 movzx	 eax, BYTE PTR readbackwards$[rsp]
  013d7	85 c0		 test	 eax, eax
  013d9	74 05		 je	 SHORT $LN164@z900_copy_

; 3880 :                     return;

  013db	e9 ca 05 00 00	 jmp	 $LN1@z900_copy_
$LN164@z900_copy_:

; 3881 : 
; 3882 :                 break;

  013e0	e9 c1 02 00 00	 jmp	 $LN45@z900_copy_
$LN159@z900_copy_:

; 3883 :             }
; 3884 : 
; 3885 :             storkey = ARCH_DEP( get_dev_storage_key )( dev, page );

  013e5	48 8b 54 24 70	 mov	 rdx, QWORD PTR page$[rsp]
  013ea	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  013f2	e8 00 00 00 00	 call	 z900_get_dev_storage_key
  013f7	88 44 24 60	 mov	 BYTE PTR storkey$[rsp], al

; 3886 : 
; 3887 :             if (1
; 3888 :                 && ccwkey != 0
; 3889 :                 && (storkey & STORKEY_KEY) != ccwkey
; 3890 :                 && ((storkey & STORKEY_FETCH) || to_memory)

  013fb	33 c0		 xor	 eax, eax
  013fd	83 f8 01	 cmp	 eax, 1
  01400	0f 84 9b 02 00
	00		 je	 $LN165@z900_copy_
  01406	0f b6 84 24 60
	01 00 00	 movzx	 eax, BYTE PTR ccwkey$[rsp]
  0140e	85 c0		 test	 eax, eax
  01410	0f 84 8b 02 00
	00		 je	 $LN165@z900_copy_
  01416	0f b6 44 24 60	 movzx	 eax, BYTE PTR storkey$[rsp]
  0141b	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  01420	0f b6 8c 24 60
	01 00 00	 movzx	 ecx, BYTE PTR ccwkey$[rsp]
  01428	3b c1		 cmp	 eax, ecx
  0142a	0f 84 71 02 00
	00		 je	 $LN165@z900_copy_
  01430	0f b6 44 24 60	 movzx	 eax, BYTE PTR storkey$[rsp]
  01435	83 e0 08	 and	 eax, 8
  01438	85 c0		 test	 eax, eax
  0143a	75 0d		 jne	 SHORT $LN166@z900_copy_
  0143c	0f b6 44 24 58	 movzx	 eax, BYTE PTR to_memory$[rsp]
  01441	85 c0		 test	 eax, eax
  01443	0f 84 58 02 00
	00		 je	 $LN165@z900_copy_
$LN166@z900_copy_:

; 3891 :             )
; 3892 :             {
; 3893 :                 if (readbackwards)

  01449	0f b6 44 24 59	 movzx	 eax, BYTE PTR readbackwards$[rsp]
  0144e	85 c0		 test	 eax, eax
  01450	74 5b		 je	 SHORT $LN167@z900_copy_

; 3894 :                 {
; 3895 :                     *residual = MAX( page, addr ) - addr;

  01452	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  01459	48 39 44 24 70	 cmp	 QWORD PTR page$[rsp], rax
  0145e	76 0f		 jbe	 SHORT $LN195@z900_copy_
  01460	48 8b 44 24 70	 mov	 rax, QWORD PTR page$[rsp]
  01465	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv788[rsp], rax
  0146d	eb 0f		 jmp	 SHORT $LN196@z900_copy_
$LN195@z900_copy_:
  0146f	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  01476	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv788[rsp], rax
$LN196@z900_copy_:
  0147e	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  01485	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv788[rsp]
  0148d	48 2b c8	 sub	 rcx, rax
  01490	48 8b c1	 mov	 rax, rcx
  01493	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  0149b	89 01		 mov	 DWORD PTR [rcx], eax

; 3896 :                     *chanstat = CSW_PROTC;

  0149d	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  014a5	c6 00 10	 mov	 BYTE PTR [rax], 16

; 3897 :                     break;

  014a8	e9 f9 01 00 00	 jmp	 $LN45@z900_copy_
$LN167@z900_copy_:

; 3898 :                 }
; 3899 : 
; 3900 :                 /* Calculate residual */
; 3901 :                 *residual = count - (MAX( page, addr ) - addr);

  014ad	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  014b4	48 39 44 24 70	 cmp	 QWORD PTR page$[rsp], rax
  014b9	76 0f		 jbe	 SHORT $LN197@z900_copy_
  014bb	48 8b 44 24 70	 mov	 rax, QWORD PTR page$[rsp]
  014c0	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv796[rsp], rax
  014c8	eb 0f		 jmp	 SHORT $LN198@z900_copy_
$LN197@z900_copy_:
  014ca	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  014d1	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv796[rsp], rax
$LN198@z900_copy_:
  014d9	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  014e0	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  014e7	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR tv796[rsp]
  014ef	48 2b d1	 sub	 rdx, rcx
  014f2	48 8b ca	 mov	 rcx, rdx
  014f5	48 2b c1	 sub	 rax, rcx
  014f8	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  01500	89 01		 mov	 DWORD PTR [rcx], eax

; 3902 : 
; 3903 :                 /* Handle prefetch */
; 3904 :                 if (prefetch->seq)

  01502	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  0150a	83 38 00	 cmp	 DWORD PTR [rax], 0
  0150d	0f 84 81 01 00
	00		 je	 $LN168@z900_copy_

; 3905 :                 {
; 3906 :                     prefetch->datalen[ps] = MAX( page, addr ) - addr;

  01513	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  0151a	48 39 44 24 70	 cmp	 QWORD PTR page$[rsp], rax
  0151f	76 0f		 jbe	 SHORT $LN199@z900_copy_
  01521	48 8b 44 24 70	 mov	 rax, QWORD PTR page$[rsp]
  01526	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv810[rsp], rax
  0152e	eb 0f		 jmp	 SHORT $LN200@z900_copy_
$LN199@z900_copy_:
  01530	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  01537	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv810[rsp], rax
$LN200@z900_copy_:
  0153f	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  01546	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv810[rsp]
  0154e	48 2b c8	 sub	 rcx, rax
  01551	48 8b c1	 mov	 rax, rcx
  01554	8b 4c 24 50	 mov	 ecx, DWORD PTR ps$[rsp]
  01558	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR prefetch$[rsp]
  01560	89 84 8a 10 05
	00 00		 mov	 DWORD PTR [rdx+rcx*4+1296], eax

; 3907 : 
; 3908 :                     if (*residual)

  01567	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  0156f	83 38 00	 cmp	 DWORD PTR [rax], 0
  01572	0f 84 09 01 00
	00		 je	 $LN169@z900_copy_
$LN49@z900_copy_:

; 3909 :                     {
; 3910 :                         /* Split entry */
; 3911 :                         get_new_prefetch_entry( PF_NO_IDAW, page );

  01578	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  01580	83 38 00	 cmp	 DWORD PTR [rax], 0
  01583	0f 84 9c 00 00
	00		 je	 $LN170@z900_copy_
  01589	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  01591	8b 00		 mov	 eax, DWORD PTR [rax]
  01593	89 44 24 50	 mov	 DWORD PTR ps$[rsp], eax
  01597	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  0159f	8b 00		 mov	 eax, DWORD PTR [rax]
  015a1	ff c0		 inc	 eax
  015a3	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  015ab	89 01		 mov	 DWORD PTR [rcx], eax
  015ad	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  015b5	81 38 00 01 00
	00		 cmp	 DWORD PTR [rax], 256	; 00000100H
  015bb	76 0d		 jbe	 SHORT $LN171@z900_copy_
  015bd	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  015c5	c6 00 08	 mov	 BYTE PTR [rax], 8
  015c8	eb 70		 jmp	 SHORT $LN48@z900_copy_
$LN171@z900_copy_:
  015ca	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  015ce	ff c8		 dec	 eax
  015d0	8b c0		 mov	 eax, eax
  015d2	8b 4c 24 50	 mov	 ecx, DWORD PTR ps$[rsp]
  015d6	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR prefetch$[rsp]
  015de	48 8b bc 24 a0
	01 00 00	 mov	 rdi, QWORD PTR prefetch$[rsp]
  015e6	8b 84 87 10 01
	00 00		 mov	 eax, DWORD PTR [rdi+rax*4+272]
  015ed	89 84 8a 10 01
	00 00		 mov	 DWORD PTR [rdx+rcx*4+272], eax
  015f4	33 c0		 xor	 eax, eax
  015f6	85 c0		 test	 eax, eax
  015f8	74 2b		 je	 SHORT $LN172@z900_copy_
  015fa	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  015fe	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  01606	c6 84 01 10 18
	00 00 00	 mov	 BYTE PTR [rcx+rax+6160], 0
  0160e	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  01612	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  0161a	8b 54 24 70	 mov	 edx, DWORD PTR page$[rsp]
  0161e	89 94 81 10 14
	00 00		 mov	 DWORD PTR [rcx+rax*4+5136], edx
$LN172@z900_copy_:
$LN170@z900_copy_:
  01625	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  0162d	c6 00 00	 mov	 BYTE PTR [rax], 0
  01630	33 c0		 xor	 eax, eax
  01632	85 c0		 test	 eax, eax
  01634	0f 85 3e ff ff
	ff		 jne	 $LN49@z900_copy_
$LN48@z900_copy_:

; 3912 : 
; 3913 :                         if (*chanstat != 0)

  0163a	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  01642	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01645	85 c0		 test	 eax, eax
  01647	74 02		 je	 SHORT $LN173@z900_copy_

; 3914 :                             break;

  01649	eb 5b		 jmp	 SHORT $LN45@z900_copy_
$LN173@z900_copy_:

; 3915 : 
; 3916 :                         prefetch->dataaddr[ps] = page;

  0164b	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  0164f	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  01657	48 8b 54 24 70	 mov	 rdx, QWORD PTR page$[rsp]
  0165c	48 89 94 c1 10
	09 00 00	 mov	 QWORD PTR [rcx+rax*8+2320], rdx

; 3917 :                         prefetch->datalen[ps] = *residual;

  01664	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  01668	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  01670	48 8b 94 24 98
	01 00 00	 mov	 rdx, QWORD PTR residual$[rsp]
  01678	8b 12		 mov	 edx, DWORD PTR [rdx]
  0167a	89 94 81 10 05
	00 00		 mov	 DWORD PTR [rcx+rax*4+1296], edx
$LN169@z900_copy_:

; 3918 :                     }
; 3919 : 
; 3920 :                     prefetch->chanstat[ps] = CSW_PROTC;

  01681	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  01685	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  0168d	c6 44 01 10 10	 mov	 BYTE PTR [rcx+rax+16], 16

; 3921 :                     break;

  01692	eb 12		 jmp	 SHORT $LN45@z900_copy_
$LN168@z900_copy_:

; 3922 :                 }
; 3923 : 
; 3924 :                 *chanstat = CSW_PROTC;

  01694	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  0169c	c6 00 10	 mov	 BYTE PTR [rax], 16

; 3925 :                 break;

  0169f	eb 05		 jmp	 SHORT $LN45@z900_copy_
$LN165@z900_copy_:

; 3926 :             }
; 3927 : 
; 3928 :         } /* end for(page) */

  016a1	e9 4f fc ff ff	 jmp	 $LN44@z900_copy_
$LN45@z900_copy_:

; 3929 : 
; 3930 :         /* Adjust local count for copy to main storage */
; 3931 :         count = MIN( count, MAX( page, addr ) - addr );

  016a6	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  016ad	48 39 44 24 70	 cmp	 QWORD PTR page$[rsp], rax
  016b2	76 0f		 jbe	 SHORT $LN201@z900_copy_
  016b4	48 8b 44 24 70	 mov	 rax, QWORD PTR page$[rsp]
  016b9	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv860[rsp], rax
  016c1	eb 0f		 jmp	 SHORT $LN202@z900_copy_
$LN201@z900_copy_:
  016c3	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  016ca	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv860[rsp], rax
$LN202@z900_copy_:
  016d2	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  016d9	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  016e0	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR tv860[rsp]
  016e8	48 2b d1	 sub	 rdx, rcx
  016eb	48 8b ca	 mov	 rcx, rdx
  016ee	48 3b c1	 cmp	 rax, rcx
  016f1	73 11		 jae	 SHORT $LN205@z900_copy_
  016f3	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  016fa	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv871[rsp], rax
  01702	eb 49		 jmp	 SHORT $LN206@z900_copy_
$LN205@z900_copy_:
  01704	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  0170b	48 39 44 24 70	 cmp	 QWORD PTR page$[rsp], rax
  01710	76 0f		 jbe	 SHORT $LN203@z900_copy_
  01712	48 8b 44 24 70	 mov	 rax, QWORD PTR page$[rsp]
  01717	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv868[rsp], rax
  0171f	eb 0f		 jmp	 SHORT $LN204@z900_copy_
$LN203@z900_copy_:
  01721	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  01728	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv868[rsp], rax
$LN204@z900_copy_:
  01730	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  01737	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv868[rsp]
  0173f	48 2b c8	 sub	 rcx, rax
  01742	48 8b c1	 mov	 rax, rcx
  01745	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv871[rsp], rax
$LN206@z900_copy_:
  0174d	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR tv871[rsp]
  01754	89 84 24 58 01
	00 00		 mov	 DWORD PTR count$[rsp], eax

; 3932 : 
; 3933 :         /* Count may be zero during prefetch operations */
; 3934 :         if (count)

  0175b	83 bc 24 58 01
	00 00 00	 cmp	 DWORD PTR count$[rsp], 0
  01763	0f 84 41 02 00
	00		 je	 $LN174@z900_copy_

; 3935 :         {
; 3936 :             /* Set the main storage reference and change bits */
; 3937 :             for (page = startpage & STORAGE_KEY_PAGEMASK;

  01769	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR startpage$[rsp]
  01771	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  01777	48 89 44 24 70	 mov	 QWORD PTR page$[rsp], rax
  0177c	eb 10		 jmp	 SHORT $LN52@z900_copy_
$LN50@z900_copy_:

; 3939 :                  page += STORAGE_KEY_PAGESIZE)

  0177e	48 8b 44 24 70	 mov	 rax, QWORD PTR page$[rsp]
  01783	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  01789	48 89 44 24 70	 mov	 QWORD PTR page$[rsp], rax
$LN52@z900_copy_:

; 3938 :                  page <= (endpage | STORAGE_KEY_BYTEMASK);

  0178e	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR endpage$[rsp]
  01796	48 0d ff 0f 00
	00		 or	 rax, 4095		; 00000fffH
  0179c	48 39 44 24 70	 cmp	 QWORD PTR page$[rsp], rax
  017a1	77 37		 ja	 SHORT $LN51@z900_copy_

; 3940 :             {
; 3941 :                 if (to_memory)

  017a3	0f b6 44 24 58	 movzx	 eax, BYTE PTR to_memory$[rsp]
  017a8	85 c0		 test	 eax, eax
  017aa	74 17		 je	 SHORT $LN175@z900_copy_

; 3942 :                     ARCH_DEP( or_dev_storage_key )( dev, page, (STORKEY_REF | STORKEY_CHANGE) );

  017ac	41 b0 06	 mov	 r8b, 6
  017af	48 8b 54 24 70	 mov	 rdx, QWORD PTR page$[rsp]
  017b4	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  017bc	e8 00 00 00 00	 call	 z900_or_dev_storage_key
  017c1	eb 15		 jmp	 SHORT $LN176@z900_copy_
$LN175@z900_copy_:

; 3943 :                 else
; 3944 :                     ARCH_DEP( or_dev_storage_key )( dev, page, STORKEY_REF );

  017c3	41 b0 04	 mov	 r8b, 4
  017c6	48 8b 54 24 70	 mov	 rdx, QWORD PTR page$[rsp]
  017cb	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  017d3	e8 00 00 00 00	 call	 z900_or_dev_storage_key
$LN176@z900_copy_:

; 3945 :             } /* end for(page) */

  017d8	eb a4		 jmp	 SHORT $LN50@z900_copy_
$LN51@z900_copy_:

; 3946 : 
; 3947 : #if DEBUG_PREFETCH
; 3948 :             if (dev->ccwtrace)
; 3949 :             {
; 3950 :                 char msgbuf[133];
; 3951 : 
; 3952 :                 MSGBUF( msgbuf,
; 3953 :                     "CCW %2.2X %2.2X %4.4X %8.8X to_memory=%d to_iobuf=%d readbackwards=%d",
; 3954 :                     (U8)code, (U8)flags, (U16)count, (U32)addr, to_memory, to_iobuf, readbackwards );
; 3955 :                 WRMSG( HHC01392, "D", msgbuf );
; 3956 :             }
; 3957 : #endif
; 3958 :             /* Copy data between main storage and channel buffer */
; 3959 :             if (readbackwards)

  017da	0f b6 44 24 59	 movzx	 eax, BYTE PTR readbackwards$[rsp]
  017df	85 c0		 test	 eax, eax
  017e1	0f 84 a5 00 00
	00		 je	 $LN177@z900_copy_

; 3960 :             {
; 3961 :                 BYTE *iobufptr = iobuf + dev->curblkrem;

  017e7	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  017ef	8b 80 18 10 00
	00		 mov	 eax, DWORD PTR [rax+4120]
  017f5	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  017fd	48 03 c8	 add	 rcx, rax
  01800	48 8b c1	 mov	 rax, rcx
  01803	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR iobufptr$1[rsp], rax

; 3962 : 
; 3963 :                 /* Channel check if outside buffer                   */
; 3964 :                 /* SA22-7201-05:                                     */
; 3965 :                 /*  p. 16-27, Channel-Data Check                     */
; 3966 :                 if (!count                              ||
; 3967 :                     (iobufptr + count) > (iobufend + 1) ||

  0180b	83 bc 24 58 01
	00 00 00	 cmp	 DWORD PTR count$[rsp], 0
  01813	74 37		 je	 SHORT $LN181@z900_copy_
  01815	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  0181c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR iobufptr$1[rsp]
  01824	48 03 c8	 add	 rcx, rax
  01827	48 8b c1	 mov	 rax, rcx
  0182a	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR iobufend$[rsp]
  01832	48 ff c1	 inc	 rcx
  01835	48 3b c1	 cmp	 rax, rcx
  01838	77 12		 ja	 SHORT $LN181@z900_copy_
  0183a	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR iobufstart$[rsp]
  01842	48 39 84 24 b8
	00 00 00	 cmp	 QWORD PTR iobufptr$1[rsp], rax
  0184a	73 0d		 jae	 SHORT $LN179@z900_copy_
$LN181@z900_copy_:

; 3968 :                     iobufptr < iobufstart)
; 3969 :                     *chanstat = CSW_CDC;

  0184c	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  01854	c6 00 08	 mov	 BYTE PTR [rax], 8
  01857	eb 2e		 jmp	 SHORT $LN180@z900_copy_
$LN179@z900_copy_:

; 3970 :                 else
; 3971 :                 {
; 3972 :                     /* read backward  - use END of buffer */
; 3973 :                     memcpy_backwards( dev->mainstor + addr,

  01859	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  01860	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01868	48 03 81 80 00
	00 00		 add	 rax, QWORD PTR [rcx+128]
  0186f	44 8b 84 24 58
	01 00 00	 mov	 r8d, DWORD PTR count$[rsp]
  01877	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR iobufptr$1[rsp]
  0187f	48 8b c8	 mov	 rcx, rax
  01882	e8 00 00 00 00	 call	 memcpy_backwards
$LN180@z900_copy_:

; 3974 :                         iobufptr, count );
; 3975 :                 }
; 3976 :             }

  01887	e9 1e 01 00 00	 jmp	 $LN178@z900_copy_
$LN177@z900_copy_:

; 3977 : 
; 3978 :             /* Channel check if outside buffer                       */
; 3979 :             /* SA22-7201-05:                                         */
; 3980 :             /*  p. 16-27, Channel-Data Check                         */
; 3981 :             else if (!count                           ||
; 3982 :                      (iobuf + count) > (iobufend + 1) ||

  0188c	83 bc 24 58 01
	00 00 00	 cmp	 DWORD PTR count$[rsp], 0
  01894	74 37		 je	 SHORT $LN184@z900_copy_
  01896	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  0189d	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  018a5	48 03 c8	 add	 rcx, rax
  018a8	48 8b c1	 mov	 rax, rcx
  018ab	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR iobufend$[rsp]
  018b3	48 ff c1	 inc	 rcx
  018b6	48 3b c1	 cmp	 rax, rcx
  018b9	77 12		 ja	 SHORT $LN184@z900_copy_
  018bb	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR iobufstart$[rsp]
  018c3	48 39 84 24 78
	01 00 00	 cmp	 QWORD PTR iobuf$[rsp], rax
  018cb	73 36		 jae	 SHORT $LN182@z900_copy_
$LN184@z900_copy_:
$LN55@z900_copy_:

; 3983 :                      iobuf < iobufstart)
; 3984 :                 set_chanstat( CSW_CDC );

  018cd	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  018d5	83 38 00	 cmp	 DWORD PTR [rax], 0
  018d8	74 13		 je	 SHORT $LN185@z900_copy_
  018da	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  018de	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  018e6	c6 44 01 10 08	 mov	 BYTE PTR [rcx+rax+16], 8
  018eb	eb 0b		 jmp	 SHORT $LN186@z900_copy_
$LN185@z900_copy_:
  018ed	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  018f5	c6 00 08	 mov	 BYTE PTR [rax], 8
$LN186@z900_copy_:
  018f8	33 c0		 xor	 eax, eax
  018fa	85 c0		 test	 eax, eax
  018fc	75 cf		 jne	 SHORT $LN55@z900_copy_
  018fe	e9 a7 00 00 00	 jmp	 $LN183@z900_copy_
$LN182@z900_copy_:

; 3985 : 
; 3986 :             /* Handle Write and Control transfer to I/O buffer */
; 3987 :             else if (to_iobuf)

  01903	0f b6 44 24 62	 movzx	 eax, BYTE PTR to_iobuf$[rsp]
  01908	85 c0		 test	 eax, eax
  0190a	74 72		 je	 SHORT $LN187@z900_copy_

; 3988 :             {
; 3989 :                 memcpy( iobuf, dev->mainstor + addr, count );

  0190c	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  01913	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0191a	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01922	48 03 8a 80 00
	00 00		 add	 rcx, QWORD PTR [rdx+128]
  01929	48 8b bc 24 78
	01 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  01931	48 8b f1	 mov	 rsi, rcx
  01934	8b c8		 mov	 ecx, eax
  01936	f3 a4		 rep movsb

; 3990 : 
; 3991 :                 prefetch->pos += count;

  01938	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  01940	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  01943	03 84 24 58 01
	00 00		 add	 eax, DWORD PTR count$[rsp]
  0194a	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  01952	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 3992 : 
; 3993 :                 if (prefetch->seq)

  01955	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  0195d	83 38 00	 cmp	 DWORD PTR [rax], 0
  01960	74 1a		 je	 SHORT $LN189@z900_copy_

; 3994 :                     prefetch->datalen[ps] = count;

  01962	8b 44 24 50	 mov	 eax, DWORD PTR ps$[rsp]
  01966	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  0196e	8b 94 24 58 01
	00 00		 mov	 edx, DWORD PTR count$[rsp]
  01975	89 94 81 10 05
	00 00		 mov	 DWORD PTR [rcx+rax*4+1296], edx
$LN189@z900_copy_:

; 3995 : 
; 3996 :             }

  0197c	eb 2c		 jmp	 SHORT $LN188@z900_copy_
$LN187@z900_copy_:

; 3997 : 
; 3998 :             /* Handle Read transfer from I/O buffer */
; 3999 :             else
; 4000 :             {
; 4001 :                 memcpy( dev->mainstor + addr, iobuf, count );

  0197e	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  01985	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0198c	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01994	48 03 8a 80 00
	00 00		 add	 rcx, QWORD PTR [rdx+128]
  0199b	48 8b f9	 mov	 rdi, rcx
  0199e	48 8b b4 24 78
	01 00 00	 mov	 rsi, QWORD PTR iobuf$[rsp]
  019a6	8b c8		 mov	 ecx, eax
  019a8	f3 a4		 rep movsb
$LN188@z900_copy_:
$LN183@z900_copy_:
$LN178@z900_copy_:
$LN174@z900_copy_:
$LN112@z900_copy_:
$LN68@z900_copy_:
$LN1@z900_copy_:

; 4002 :             }
; 4003 : 
; 4004 : #ifdef FEATURE_S370_CHANNEL
; 4005 :             if (dev->devtype == 0x2703)
; 4006 :                 if (dev->commadpt->lnctl == COMMADPT_LNCTL_ASYNC)
; 4007 :                     usleep(5000);
; 4008 : #endif
; 4009 : 
; 4010 : #if DEBUG_DUMP
; 4011 :             if (dev->ccwtrace)
; 4012 :             {
; 4013 :                 char msgbuf[133];
; 4014 : 
; 4015 :                 MSGBUF( msgbuf, "iobuf->%8.8X.%4.4X", addr, count );
; 4016 :                 WRMSG( HHC01390, "D", msgbuf );
; 4017 : 
; 4018 :                 MSGBUF( msgbuf, "addr=%8.8X count=%d residual=%d copy=%d",
; 4019 :                     addr, count, *residual, count );
; 4020 :                 WRMSG( HHC01390, "D", msgbuf );
; 4021 : 
; 4022 :                 if (to_memory)
; 4023 :                     DUMP( "iobuf:", iobuf, count );
; 4024 :                 DUMP_STORAGE( "Storage:", addr, count );
; 4025 :                 if (to_iobuf)
; 4026 :                     DUMP( "iobuf:", iobuf, count );
; 4027 :             }
; 4028 : #endif
; 4029 :         }
; 4030 : 
; 4031 :     } /* end if(!IDA) */
; 4032 : 
; 4033 : #undef get_new_prefetch_entry
; 4034 : #undef set_chanstat
; 4035 : 
; 4036 : } /* end function copy_iobuf */

  019aa	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  019b1	5f		 pop	 rdi
  019b2	5e		 pop	 rsi
  019b3	c3		 ret	 0
z900_copy_iobuf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
mflags$ = 32
storkey$ = 33
mcount$ = 36
maxlen$ = 40
mdaddr$ = 48
mword1$ = 56
tv193 = 64
mword2$ = 72
dev$ = 96
code$ = 104
ccwkey$ = 112
midawseq$ = 120
midawadr$ = 128
addr$ = 136
len$ = 144
flags$ = 152
chanstat$ = 160
z900_fetch_midaw PROC

; 3255 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@z900_fetch:

; 3256 : U64     mword1, mword2;                 /* MIDAW high and low words  */
; 3257 : RADR    mdaddr;                         /* Data address from MIDAW   */
; 3258 : U16     mcount;                         /* Count field from MIDAW    */
; 3259 : BYTE    mflags;                         /* Flags byte from MIDAW     */
; 3260 : BYTE    storkey;                        /* Storage key               */
; 3261 : U16     maxlen;                         /* Maximum allowable length  */
; 3262 : 
; 3263 :     UNREFERENCED_370(dev);

  00017	33 c0		 xor	 eax, eax
  00019	85 c0		 test	 eax, eax
  0001b	75 fa		 jne	 SHORT $LN4@z900_fetch

; 3264 : 
; 3265 :     /* Channel program check if MIDAW is not on quadword
; 3266 :        boundary or is outside limit of main storage */
; 3267 :     if ((midawadr & 0x0F)
; 3268 :         || CHADDRCHK(midawadr, dev) )

  0001d	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR midawadr$[rsp]
  00024	83 e0 0f	 and	 eax, 15
  00027	85 c0		 test	 eax, eax
  00029	75 7c		 jne	 SHORT $LN6@z900_fetch
  0002b	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR midawadr$[rsp]
  00032	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00037	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  0003e	77 67		 ja	 SHORT $LN7@z900_fetch
  00040	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00045	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  0004c	83 e0 10	 and	 eax, 16
  0004f	85 c0		 test	 eax, eax
  00051	74 64		 je	 SHORT $LN5@z900_fetch
  00053	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00058	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0005f	83 e0 20	 and	 eax, 32			; 00000020H
  00062	85 c0		 test	 eax, eax
  00064	74 17		 je	 SHORT $LN9@z900_fetch
  00066	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR midawadr$[rsp]
  0006d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00074	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  0007b	72 2a		 jb	 SHORT $LN8@z900_fetch
$LN9@z900_fetch:
  0007d	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00082	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00089	83 e0 40	 and	 eax, 64			; 00000040H
  0008c	85 c0		 test	 eax, eax
  0008e	74 27		 je	 SHORT $LN5@z900_fetch
  00090	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR midawadr$[rsp]
  00097	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0009e	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  000a5	72 10		 jb	 SHORT $LN5@z900_fetch
$LN8@z900_fetch:
$LN7@z900_fetch:
$LN6@z900_fetch:

; 3269 :     {
; 3270 :         *chanstat = CSW_PROGC;

  000a7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  000af	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3271 :         return;

  000b2	e9 88 02 00 00	 jmp	 $LN1@z900_fetch
$LN5@z900_fetch:

; 3272 :     }
; 3273 : 
; 3274 :     /* Channel program check if MIDAW list crosses a page boundary */
; 3275 :     if (midawseq > 0 && (midawadr & PAGEFRAME_BYTEMASK) == 0)

  000b7	83 7c 24 78 00	 cmp	 DWORD PTR midawseq$[rsp], 0
  000bc	7e 20		 jle	 SHORT $LN10@z900_fetch
  000be	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR midawadr$[rsp]
  000c5	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  000ca	85 c0		 test	 eax, eax
  000cc	75 10		 jne	 SHORT $LN10@z900_fetch

; 3276 :     {
; 3277 :         *chanstat = CSW_PROGC;

  000ce	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  000d6	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3278 :         return;

  000d9	e9 61 02 00 00	 jmp	 $LN1@z900_fetch
$LN10@z900_fetch:

; 3279 :     }
; 3280 : 
; 3281 :     /* Channel protection check if MIDAW is fetch protected */
; 3282 :     storkey = ARCH_DEP( get_dev_storage_key )( dev, midawadr );

  000de	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR midawadr$[rsp]
  000e5	8b d0		 mov	 edx, eax
  000e7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000ec	e8 00 00 00 00	 call	 z900_get_dev_storage_key
  000f1	88 44 24 21	 mov	 BYTE PTR storkey$[rsp], al

; 3283 :     if (ccwkey != 0 && (storkey & STORKEY_FETCH)
; 3284 :         && (storkey & STORKEY_KEY) != ccwkey)

  000f5	0f b6 44 24 70	 movzx	 eax, BYTE PTR ccwkey$[rsp]
  000fa	85 c0		 test	 eax, eax
  000fc	74 2f		 je	 SHORT $LN11@z900_fetch
  000fe	0f b6 44 24 21	 movzx	 eax, BYTE PTR storkey$[rsp]
  00103	83 e0 08	 and	 eax, 8
  00106	85 c0		 test	 eax, eax
  00108	74 23		 je	 SHORT $LN11@z900_fetch
  0010a	0f b6 44 24 21	 movzx	 eax, BYTE PTR storkey$[rsp]
  0010f	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00114	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR ccwkey$[rsp]
  00119	3b c1		 cmp	 eax, ecx
  0011b	74 10		 je	 SHORT $LN11@z900_fetch

; 3285 :     {
; 3286 :         *chanstat = CSW_PROTC;

  0011d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00125	c6 00 10	 mov	 BYTE PTR [rax], 16

; 3287 :         return;

  00128	e9 12 02 00 00	 jmp	 $LN1@z900_fetch
$LN11@z900_fetch:

; 3288 :     }
; 3289 : 
; 3290 :     /* Set the main storage reference bit for the MIDAW location */
; 3291 :     ARCH_DEP( or_dev_storage_key )( dev, midawadr, STORKEY_REF );

  0012d	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR midawadr$[rsp]
  00134	41 b0 04	 mov	 r8b, 4
  00137	8b d0		 mov	 edx, eax
  00139	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0013e	e8 00 00 00 00	 call	 z900_or_dev_storage_key

; 3292 : 
; 3293 :     /* Fetch MIDAW from main storage (MIDAW is quadword
; 3294 :        aligned and so cannot cross a page boundary) */
; 3295 :     FETCH_DW(mword1, dev->mainstor + midawadr);

  00143	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR midawadr$[rsp]
  0014a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0014f	48 03 81 80 00
	00 00		 add	 rax, QWORD PTR [rcx+128]
  00156	48 8b c8	 mov	 rcx, rax
  00159	e8 00 00 00 00	 call	 fetch_dw_noswap
  0015e	48 8b c8	 mov	 rcx, rax
  00161	e8 00 00 00 00	 call	 _byteswap_uint64
  00166	48 89 44 24 38	 mov	 QWORD PTR mword1$[rsp], rax

; 3296 :     FETCH_DW(mword2, dev->mainstor + midawadr + 8);

  0016b	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR midawadr$[rsp]
  00172	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00177	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  0017e	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  00183	48 8b c8	 mov	 rcx, rax
  00186	e8 00 00 00 00	 call	 fetch_dw_noswap
  0018b	48 8b c8	 mov	 rcx, rax
  0018e	e8 00 00 00 00	 call	 _byteswap_uint64
  00193	48 89 44 24 48	 mov	 QWORD PTR mword2$[rsp], rax

; 3297 : 
; 3298 :     /* Channel program check in reserved bits are non-zero */
; 3299 :     if (mword1 & 0xFFFFFFFFFF000000ULL)

  00198	48 8b 44 24 38	 mov	 rax, QWORD PTR mword1$[rsp]
  0019d	48 25 00 00 00
	ff		 and	 rax, -16777216		; ffffffffff000000H
  001a3	48 85 c0	 test	 rax, rax
  001a6	74 10		 je	 SHORT $LN12@z900_fetch

; 3300 :     {
; 3301 :         *chanstat = CSW_PROGC;

  001a8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  001b0	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3302 :         return;

  001b3	e9 87 01 00 00	 jmp	 $LN1@z900_fetch
$LN12@z900_fetch:

; 3303 :     }
; 3304 : 
; 3305 :     /* Extract fields from MIDAW */
; 3306 :     mflags = mword1 >> 16;

  001b8	48 8b 44 24 38	 mov	 rax, QWORD PTR mword1$[rsp]
  001bd	48 c1 e8 10	 shr	 rax, 16
  001c1	88 44 24 20	 mov	 BYTE PTR mflags$[rsp], al

; 3307 :     mcount = mword1 & 0xFFFF;

  001c5	48 8b 44 24 38	 mov	 rax, QWORD PTR mword1$[rsp]
  001ca	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  001d0	66 89 44 24 24	 mov	 WORD PTR mcount$[rsp], ax

; 3308 :     mdaddr = (RADR)mword2;

  001d5	48 8b 44 24 48	 mov	 rax, QWORD PTR mword2$[rsp]
  001da	48 89 44 24 30	 mov	 QWORD PTR mdaddr$[rsp], rax

; 3309 : 
; 3310 :     /* Channel program check if data transfer interrupt flag is set */
; 3311 :     if (mflags & MIDAW_DTI)

  001df	0f b6 44 24 20	 movzx	 eax, BYTE PTR mflags$[rsp]
  001e4	83 e0 20	 and	 eax, 32			; 00000020H
  001e7	85 c0		 test	 eax, eax
  001e9	74 10		 je	 SHORT $LN13@z900_fetch

; 3312 :     {
; 3313 :         *chanstat = CSW_PROGC;

  001eb	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  001f3	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3314 :         return;

  001f6	e9 44 01 00 00	 jmp	 $LN1@z900_fetch
$LN13@z900_fetch:

; 3315 :     }
; 3316 : 
; 3317 :     /* Channel program check if MIDAW count is zero */
; 3318 :     if (mcount == 0)

  001fb	0f b7 44 24 24	 movzx	 eax, WORD PTR mcount$[rsp]
  00200	85 c0		 test	 eax, eax
  00202	75 10		 jne	 SHORT $LN14@z900_fetch

; 3319 :     {
; 3320 :         *chanstat = CSW_PROGC;

  00204	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  0020c	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3321 :         return;

  0020f	e9 2b 01 00 00	 jmp	 $LN1@z900_fetch
$LN14@z900_fetch:

; 3322 :     }
; 3323 : 
; 3324 :     /* Channel program check if MIDAW data
; 3325 :        location is outside main storage */
; 3326 :     if ( CHADDRCHK(mdaddr, dev) )

  00214	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00219	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00220	48 39 44 24 30	 cmp	 QWORD PTR mdaddr$[rsp], rax
  00225	77 63		 ja	 SHORT $LN16@z900_fetch
  00227	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0022c	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  00233	83 e0 10	 and	 eax, 16
  00236	85 c0		 test	 eax, eax
  00238	74 60		 je	 SHORT $LN15@z900_fetch
  0023a	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0023f	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00246	83 e0 20	 and	 eax, 32			; 00000020H
  00249	85 c0		 test	 eax, eax
  0024b	74 15		 je	 SHORT $LN18@z900_fetch
  0024d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00254	48 8b 80 60 12
	00 00		 mov	 rax, QWORD PTR [rax+4704]
  0025b	48 39 44 24 30	 cmp	 QWORD PTR mdaddr$[rsp], rax
  00260	72 28		 jb	 SHORT $LN17@z900_fetch
$LN18@z900_fetch:
  00262	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00267	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0026e	83 e0 40	 and	 eax, 64			; 00000040H
  00271	85 c0		 test	 eax, eax
  00273	74 25		 je	 SHORT $LN15@z900_fetch
  00275	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0027c	48 8b 80 60 12
	00 00		 mov	 rax, QWORD PTR [rax+4704]
  00283	48 39 44 24 30	 cmp	 QWORD PTR mdaddr$[rsp], rax
  00288	72 10		 jb	 SHORT $LN15@z900_fetch
$LN17@z900_fetch:
$LN16@z900_fetch:

; 3327 :     {
; 3328 :         *chanstat = CSW_PROGC;

  0028a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00292	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3329 :         return;

  00295	e9 a5 00 00 00	 jmp	 $LN1@z900_fetch
$LN15@z900_fetch:

; 3330 :     }
; 3331 : 
; 3332 :     /* Channel program check if skipping not in effect
; 3333 :        and the MIDAW data area crosses a page boundary */
; 3334 :     maxlen = (IS_CCW_RDBACK(code)) ?

  0029a	0f b6 44 24 68	 movzx	 eax, BYTE PTR code$[rsp]
  0029f	83 e0 0f	 and	 eax, 15
  002a2	83 f8 0c	 cmp	 eax, 12
  002a5	75 20		 jne	 SHORT $LN21@z900_fetch
  002a7	48 8b 44 24 30	 mov	 rax, QWORD PTR mdaddr$[rsp]
  002ac	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  002b2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mdaddr$[rsp]
  002b7	48 2b c8	 sub	 rcx, rax
  002ba	48 8b c1	 mov	 rax, rcx
  002bd	48 ff c0	 inc	 rax
  002c0	48 89 44 24 40	 mov	 QWORD PTR tv193[rsp], rax
  002c5	eb 18		 jmp	 SHORT $LN22@z900_fetch
$LN21@z900_fetch:
  002c7	48 8b 44 24 30	 mov	 rax, QWORD PTR mdaddr$[rsp]
  002cc	48 0d ff 0f 00
	00		 or	 rax, 4095		; 00000fffH
  002d2	48 2b 44 24 30	 sub	 rax, QWORD PTR mdaddr$[rsp]
  002d7	48 ff c0	 inc	 rax
  002da	48 89 44 24 40	 mov	 QWORD PTR tv193[rsp], rax
$LN22@z900_fetch:
  002df	0f b7 44 24 40	 movzx	 eax, WORD PTR tv193[rsp]
  002e4	66 89 44 24 28	 mov	 WORD PTR maxlen$[rsp], ax

; 3335 :                 mdaddr - (mdaddr & PAGEFRAME_PAGEMASK) + 1 :
; 3336 :                 (mdaddr | PAGEFRAME_BYTEMASK) - mdaddr + 1 ;
; 3337 : 
; 3338 :     if ((mflags & MIDAW_SKIP) == 0 && mcount > maxlen)

  002e9	0f b6 44 24 20	 movzx	 eax, BYTE PTR mflags$[rsp]
  002ee	83 e0 40	 and	 eax, 64			; 00000040H
  002f1	85 c0		 test	 eax, eax
  002f3	75 1b		 jne	 SHORT $LN19@z900_fetch
  002f5	0f b7 44 24 24	 movzx	 eax, WORD PTR mcount$[rsp]
  002fa	0f b7 4c 24 28	 movzx	 ecx, WORD PTR maxlen$[rsp]
  002ff	3b c1		 cmp	 eax, ecx
  00301	7e 0d		 jle	 SHORT $LN19@z900_fetch

; 3339 :     {
; 3340 :         *chanstat = CSW_PROGC;

  00303	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  0030b	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3341 :         return;

  0030e	eb 2f		 jmp	 SHORT $LN1@z900_fetch
$LN19@z900_fetch:

; 3342 :     }
; 3343 : 
; 3344 :     /* Return the data address, length, flags for this MIDAW */
; 3345 :     *addr = mdaddr;

  00310	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00318	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mdaddr$[rsp]
  0031d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 3346 :     *len = mcount;

  00320	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  00328	0f b7 4c 24 24	 movzx	 ecx, WORD PTR mcount$[rsp]
  0032d	66 89 08	 mov	 WORD PTR [rax], cx

; 3347 :     *flags = mflags;

  00330	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR flags$[rsp]
  00338	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR mflags$[rsp]
  0033d	88 08		 mov	 BYTE PTR [rax], cl
$LN1@z900_fetch:

; 3348 : 
; 3349 : } /* end function fetch_midaw */

  0033f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00343	c3		 ret	 0
z900_fetch_midaw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
storkey$ = 32
idalen$ = 36
tv67 = 40
idaw1$ = 44
idaw$ = 48
idapage$ = 56
idaw2$ = 64
dev$ = 96
code$ = 104
ccwkey$ = 112
idawfmt$ = 120
idapmask$ = 128
idaseq$ = 136
idawaddr$ = 144
addr$ = 152
len$ = 160
chanstat$ = 168
z900_fetch_idaw PROC

; 3123 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@z900_fetch:

; 3124 : RADR    idaw;                           /* Contents of IDAW          */
; 3125 : U32     idaw1;                          /* Format-1 IDAW             */
; 3126 : U64     idaw2;                          /* Format-2 IDAW             */
; 3127 : RADR    idapage;                        /* Addr of next IDA page     */
; 3128 : U16     idalen;                         /* #of bytes until next page */
; 3129 : BYTE    storkey;                        /* Storage key               */
; 3130 : 
; 3131 :     UNREFERENCED_370(dev);

  00017	33 c0		 xor	 eax, eax
  00019	85 c0		 test	 eax, eax
  0001b	75 fa		 jne	 SHORT $LN4@z900_fetch

; 3132 :     *addr = 0;

  0001d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00025	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 3133 :     *len = 0;

  0002c	33 c0		 xor	 eax, eax
  0002e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  00036	66 89 01	 mov	 WORD PTR [rcx], ax

; 3134 : 
; 3135 :     /* Channel program check if IDAW is not on correct
; 3136 :        boundary or is outside limit of main storage */
; 3137 :     if ((idawaddr & ((idawfmt == PF_IDAW2) ? 0x07 : 0x03))
; 3138 :         || CHADDRCHK(idawaddr, dev)
; 3139 :         /* Program check if Format-0 CCW and IDAW address > 16M      */
; 3140 :         /* SA22-7201-05:                                             */
; 3141 :         /*  p. 16-25, Invalid IDAW Address                           */
; 3142 :         || (!(dev->orb.flag5 & ORB5_F) && (idawaddr & 0xFF000000)))

  00039	0f b6 44 24 78	 movzx	 eax, BYTE PTR idawfmt$[rsp]
  0003e	83 f8 02	 cmp	 eax, 2
  00041	75 0a		 jne	 SHORT $LN23@z900_fetch
  00043	c7 44 24 28 07
	00 00 00	 mov	 DWORD PTR tv67[rsp], 7
  0004b	eb 08		 jmp	 SHORT $LN24@z900_fetch
$LN23@z900_fetch:
  0004d	c7 44 24 28 03
	00 00 00	 mov	 DWORD PTR tv67[rsp], 3
$LN24@z900_fetch:
  00055	8b 44 24 28	 mov	 eax, DWORD PTR tv67[rsp]
  00059	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR idawaddr$[rsp]
  00060	23 c8		 and	 ecx, eax
  00062	8b c1		 mov	 eax, ecx
  00064	85 c0		 test	 eax, eax
  00066	0f 85 a5 00 00
	00		 jne	 $LN6@z900_fetch
  0006c	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idawaddr$[rsp]
  00073	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00078	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  0007f	0f 87 8c 00 00
	00		 ja	 $LN6@z900_fetch
  00085	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0008a	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  00091	83 e0 10	 and	 eax, 16
  00094	85 c0		 test	 eax, eax
  00096	74 54		 je	 SHORT $LN7@z900_fetch
  00098	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0009d	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  000a4	83 e0 20	 and	 eax, 32			; 00000020H
  000a7	85 c0		 test	 eax, eax
  000a9	74 17		 je	 SHORT $LN8@z900_fetch
  000ab	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idawaddr$[rsp]
  000b2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000b9	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  000c0	72 4f		 jb	 SHORT $LN6@z900_fetch
$LN8@z900_fetch:
  000c2	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000c7	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  000ce	83 e0 40	 and	 eax, 64			; 00000040H
  000d1	85 c0		 test	 eax, eax
  000d3	74 17		 je	 SHORT $LN9@z900_fetch
  000d5	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idawaddr$[rsp]
  000dc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e3	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  000ea	73 25		 jae	 SHORT $LN6@z900_fetch
$LN9@z900_fetch:
$LN7@z900_fetch:
  000ec	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000f1	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  000f8	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000fd	85 c0		 test	 eax, eax
  000ff	75 20		 jne	 SHORT $LN5@z900_fetch
  00101	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idawaddr$[rsp]
  00108	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  0010d	85 c0		 test	 eax, eax
  0010f	74 10		 je	 SHORT $LN5@z900_fetch
$LN6@z900_fetch:

; 3143 :     {
; 3144 :         *chanstat = CSW_PROGC;

  00111	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00119	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3145 :         return;

  0011c	e9 9c 02 00 00	 jmp	 $LN1@z900_fetch
$LN5@z900_fetch:

; 3146 :     }
; 3147 : 
; 3148 :     /* Channel protection check if IDAW is fetch protected */
; 3149 :     storkey = ARCH_DEP( get_dev_storage_key )( dev, idawaddr );

  00121	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idawaddr$[rsp]
  00128	8b d0		 mov	 edx, eax
  0012a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0012f	e8 00 00 00 00	 call	 z900_get_dev_storage_key
  00134	88 44 24 20	 mov	 BYTE PTR storkey$[rsp], al

; 3150 :     if (ccwkey != 0 && (storkey & STORKEY_FETCH)
; 3151 :         && (storkey & STORKEY_KEY) != ccwkey)

  00138	0f b6 44 24 70	 movzx	 eax, BYTE PTR ccwkey$[rsp]
  0013d	85 c0		 test	 eax, eax
  0013f	74 2f		 je	 SHORT $LN10@z900_fetch
  00141	0f b6 44 24 20	 movzx	 eax, BYTE PTR storkey$[rsp]
  00146	83 e0 08	 and	 eax, 8
  00149	85 c0		 test	 eax, eax
  0014b	74 23		 je	 SHORT $LN10@z900_fetch
  0014d	0f b6 44 24 20	 movzx	 eax, BYTE PTR storkey$[rsp]
  00152	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00157	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR ccwkey$[rsp]
  0015c	3b c1		 cmp	 eax, ecx
  0015e	74 10		 je	 SHORT $LN10@z900_fetch

; 3152 :     {
; 3153 :         *chanstat = CSW_PROTC;

  00160	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00168	c6 00 10	 mov	 BYTE PTR [rax], 16

; 3154 :         return;

  0016b	e9 4d 02 00 00	 jmp	 $LN1@z900_fetch
$LN10@z900_fetch:

; 3155 :     }
; 3156 : 
; 3157 :     /* Set the main storage reference bit for the IDAW location */
; 3158 :     ARCH_DEP( or_dev_storage_key )( dev, idawaddr, STORKEY_REF );

  00170	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idawaddr$[rsp]
  00177	41 b0 04	 mov	 r8b, 4
  0017a	8b d0		 mov	 edx, eax
  0017c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00181	e8 00 00 00 00	 call	 z900_or_dev_storage_key

; 3159 : 
; 3160 :     /* Fetch IDAW from main storage */
; 3161 :     if (idawfmt == PF_IDAW2)

  00186	0f b6 44 24 78	 movzx	 eax, BYTE PTR idawfmt$[rsp]
  0018b	83 f8 02	 cmp	 eax, 2
  0018e	75 34		 jne	 SHORT $LN11@z900_fetch

; 3162 :     {
; 3163 :         /* Fetch format-2 IDAW */
; 3164 :         FETCH_DW(idaw2, dev->mainstor + idawaddr);

  00190	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idawaddr$[rsp]
  00197	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0019c	48 03 81 80 00
	00 00		 add	 rax, QWORD PTR [rcx+128]
  001a3	48 8b c8	 mov	 rcx, rax
  001a6	e8 00 00 00 00	 call	 fetch_dw_noswap
  001ab	48 8b c8	 mov	 rcx, rax
  001ae	e8 00 00 00 00	 call	 _byteswap_uint64
  001b3	48 89 44 24 40	 mov	 QWORD PTR idaw2$[rsp], rax

; 3165 : 
; 3166 : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 3167 :         /* Channel program check in ESA/390 mode
; 3168 :            if the format-2 IDAW exceeds 2GB-1 */
; 3169 :         if (idaw2 > 0x7FFFFFFF)
; 3170 :         {
; 3171 :             *chanstat = CSW_PROGC;
; 3172 :             return;
; 3173 :         }
; 3174 : #endif
; 3175 :         /* Save contents of format-2 IDAW */
; 3176 :         idaw = idaw2;

  001b8	48 8b 44 24 40	 mov	 rax, QWORD PTR idaw2$[rsp]
  001bd	48 89 44 24 30	 mov	 QWORD PTR idaw$[rsp], rax

; 3177 :     }

  001c2	eb 4c		 jmp	 SHORT $LN12@z900_fetch
$LN11@z900_fetch:

; 3178 :     else
; 3179 :     {
; 3180 :         /* Fetch format-1 IDAW */
; 3181 :         FETCH_FW(idaw1, dev->mainstor + idawaddr);

  001c4	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idawaddr$[rsp]
  001cb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  001d0	48 03 81 80 00
	00 00		 add	 rax, QWORD PTR [rcx+128]
  001d7	48 8b c8	 mov	 rcx, rax
  001da	e8 00 00 00 00	 call	 fetch_fw_noswap
  001df	8b c8		 mov	 ecx, eax
  001e1	e8 00 00 00 00	 call	 _byteswap_ulong
  001e6	89 44 24 2c	 mov	 DWORD PTR idaw1$[rsp], eax

; 3182 : 
; 3183 :         /* Channel program check if bit 0 of
; 3184 :            the format-1 IDAW is not zero */
; 3185 :         if (idaw1 & 0x80000000)

  001ea	8b 44 24 2c	 mov	 eax, DWORD PTR idaw1$[rsp]
  001ee	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001f3	85 c0		 test	 eax, eax
  001f5	74 10		 je	 SHORT $LN13@z900_fetch

; 3186 :         {
; 3187 :             *chanstat = CSW_PROGC;

  001f7	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  001ff	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3188 :             return;

  00202	e9 b6 01 00 00	 jmp	 $LN1@z900_fetch
$LN13@z900_fetch:

; 3189 :         }
; 3190 : 
; 3191 :         /* Save contents of format-1 IDAW */
; 3192 :         idaw = idaw1;

  00207	8b 44 24 2c	 mov	 eax, DWORD PTR idaw1$[rsp]
  0020b	48 89 44 24 30	 mov	 QWORD PTR idaw$[rsp], rax
$LN12@z900_fetch:

; 3193 :     }
; 3194 : 
; 3195 :     /* Channel program check if IDAW data
; 3196 :        location is outside main storage */
; 3197 :     if ( CHADDRCHK(idaw, dev) )

  00210	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00215	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0021c	48 39 44 24 30	 cmp	 QWORD PTR idaw$[rsp], rax
  00221	77 63		 ja	 SHORT $LN15@z900_fetch
  00223	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00228	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  0022f	83 e0 10	 and	 eax, 16
  00232	85 c0		 test	 eax, eax
  00234	74 60		 je	 SHORT $LN14@z900_fetch
  00236	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0023b	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00242	83 e0 20	 and	 eax, 32			; 00000020H
  00245	85 c0		 test	 eax, eax
  00247	74 15		 je	 SHORT $LN17@z900_fetch
  00249	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00250	48 8b 80 60 12
	00 00		 mov	 rax, QWORD PTR [rax+4704]
  00257	48 39 44 24 30	 cmp	 QWORD PTR idaw$[rsp], rax
  0025c	72 28		 jb	 SHORT $LN16@z900_fetch
$LN17@z900_fetch:
  0025e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00263	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0026a	83 e0 40	 and	 eax, 64			; 00000040H
  0026d	85 c0		 test	 eax, eax
  0026f	74 25		 je	 SHORT $LN14@z900_fetch
  00271	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00278	48 8b 80 60 12
	00 00		 mov	 rax, QWORD PTR [rax+4704]
  0027f	48 39 44 24 30	 cmp	 QWORD PTR idaw$[rsp], rax
  00284	72 10		 jb	 SHORT $LN14@z900_fetch
$LN16@z900_fetch:
$LN15@z900_fetch:

; 3198 :     {
; 3199 :         *chanstat = CSW_PROGC;

  00286	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  0028e	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3200 :         return;

  00291	e9 27 01 00 00	 jmp	 $LN1@z900_fetch
$LN14@z900_fetch:

; 3201 :     }
; 3202 : 
; 3203 :     /* Channel program check if IDAW data location is not
; 3204 :        on a page boundary, except for the first IDAW */
; 3205 :     if (IS_CCW_RDBACK (code))

  00296	0f b6 44 24 68	 movzx	 eax, BYTE PTR code$[rsp]
  0029b	83 e0 0f	 and	 eax, 15
  0029e	83 f8 0c	 cmp	 eax, 12
  002a1	0f 85 8b 00 00
	00		 jne	 $LN18@z900_fetch

; 3206 :     {
; 3207 :         if (idaseq > 0 && ((idaw+1) & idapmask) != 0)

  002a7	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR idaseq$[rsp], 0
  002af	7e 28		 jle	 SHORT $LN20@z900_fetch
  002b1	48 8b 44 24 30	 mov	 rax, QWORD PTR idaw$[rsp]
  002b6	48 ff c0	 inc	 rax
  002b9	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR idapmask$[rsp]
  002c1	48 23 c1	 and	 rax, rcx
  002c4	48 85 c0	 test	 rax, rax
  002c7	74 10		 je	 SHORT $LN20@z900_fetch

; 3208 :         {
; 3209 :             *chanstat = CSW_PROGC;

  002c9	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  002d1	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3210 :             return;

  002d4	e9 e4 00 00 00	 jmp	 $LN1@z900_fetch
$LN20@z900_fetch:

; 3211 :         }
; 3212 : 
; 3213 :         /* Calculate address of next page boundary */
; 3214 :         idapage = (idaw & ~idapmask);

  002d9	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR idapmask$[rsp]
  002e1	f7 d0		 not	 eax
  002e3	48 98		 cdqe
  002e5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR idaw$[rsp]
  002ea	48 23 c8	 and	 rcx, rax
  002ed	48 8b c1	 mov	 rax, rcx
  002f0	48 89 44 24 38	 mov	 QWORD PTR idapage$[rsp], rax

; 3215 :         idalen = (idaw - idapage) + 1;

  002f5	48 8b 44 24 38	 mov	 rax, QWORD PTR idapage$[rsp]
  002fa	48 8b 4c 24 30	 mov	 rcx, QWORD PTR idaw$[rsp]
  002ff	48 2b c8	 sub	 rcx, rax
  00302	48 8b c1	 mov	 rax, rcx
  00305	48 ff c0	 inc	 rax
  00308	66 89 44 24 24	 mov	 WORD PTR idalen$[rsp], ax

; 3216 : 
; 3217 :         /* Return the address and length for this IDAW */
; 3218 :         *addr = idaw;

  0030d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00315	48 8b 4c 24 30	 mov	 rcx, QWORD PTR idaw$[rsp]
  0031a	48 89 08	 mov	 QWORD PTR [rax], rcx

; 3219 :         *len = idalen;

  0031d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  00325	0f b7 4c 24 24	 movzx	 ecx, WORD PTR idalen$[rsp]
  0032a	66 89 08	 mov	 WORD PTR [rax], cx

; 3220 :     }

  0032d	e9 8b 00 00 00	 jmp	 $LN19@z900_fetch
$LN18@z900_fetch:

; 3221 :     else
; 3222 :     {
; 3223 :         if (idaseq > 0 && (idaw & idapmask) != 0)

  00332	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR idaseq$[rsp], 0
  0033a	7e 25		 jle	 SHORT $LN21@z900_fetch
  0033c	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR idapmask$[rsp]
  00344	48 8b 4c 24 30	 mov	 rcx, QWORD PTR idaw$[rsp]
  00349	48 23 c8	 and	 rcx, rax
  0034c	48 8b c1	 mov	 rax, rcx
  0034f	48 85 c0	 test	 rax, rax
  00352	74 0d		 je	 SHORT $LN21@z900_fetch

; 3224 :         {
; 3225 :             *chanstat = CSW_PROGC;

  00354	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  0035c	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3226 :             return;

  0035f	eb 5c		 jmp	 SHORT $LN1@z900_fetch
$LN21@z900_fetch:

; 3227 :         }
; 3228 : 
; 3229 :         /* Calculate address of next page boundary */
; 3230 :         idapage = (idaw + idapmask + 1) & ~idapmask;

  00361	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR idapmask$[rsp]
  00369	48 8b 4c 24 30	 mov	 rcx, QWORD PTR idaw$[rsp]
  0036e	48 8d 44 01 01	 lea	 rax, QWORD PTR [rcx+rax+1]
  00373	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR idapmask$[rsp]
  0037b	f7 d1		 not	 ecx
  0037d	48 63 c9	 movsxd	 rcx, ecx
  00380	48 23 c1	 and	 rax, rcx
  00383	48 89 44 24 38	 mov	 QWORD PTR idapage$[rsp], rax

; 3231 :         idalen = idapage - idaw;

  00388	48 8b 44 24 30	 mov	 rax, QWORD PTR idaw$[rsp]
  0038d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR idapage$[rsp]
  00392	48 2b c8	 sub	 rcx, rax
  00395	48 8b c1	 mov	 rax, rcx
  00398	66 89 44 24 24	 mov	 WORD PTR idalen$[rsp], ax

; 3232 : 
; 3233 :         /* Return the address and length for this IDAW */
; 3234 :         *addr = idaw;

  0039d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  003a5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR idaw$[rsp]
  003aa	48 89 08	 mov	 QWORD PTR [rax], rcx

; 3235 :         *len = idalen;

  003ad	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  003b5	0f b7 4c 24 24	 movzx	 ecx, WORD PTR idalen$[rsp]
  003ba	66 89 08	 mov	 WORD PTR [rax], cx
$LN19@z900_fetch:
$LN1@z900_fetch:

; 3236 :     }
; 3237 : 
; 3238 : } /* end function fetch_idaw */

  003bd	48 83 c4 58	 add	 rsp, 88			; 00000058H
  003c1	c3		 ret	 0
z900_fetch_idaw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
storkey$ = 32
ccw$ = 40
dev$ = 64
ccwkey$ = 72
ccwfmt$ = 80
ccwaddr$ = 88
code$ = 96
addr$ = 104
flags$ = 112
count$ = 120
chanstat$ = 128
z900_fetch_ccw PROC

; 3056 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@z900_fetch:

; 3057 : BYTE    storkey;                        /* Storage key               */
; 3058 : BYTE   *ccw;                            /* CCW pointer               */
; 3059 : 
; 3060 :     UNREFERENCED_370(dev);

  00017	33 c0		 xor	 eax, eax
  00019	85 c0		 test	 eax, eax
  0001b	75 fa		 jne	 SHORT $LN4@z900_fetch

; 3061 :     *code=0;

  0001d	48 8b 44 24 60	 mov	 rax, QWORD PTR code$[rsp]
  00022	c6 00 00	 mov	 BYTE PTR [rax], 0

; 3062 :     *count=0;

  00025	48 8b 44 24 78	 mov	 rax, QWORD PTR count$[rsp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 3063 :     *flags=0;

  00030	48 8b 44 24 70	 mov	 rax, QWORD PTR flags$[rsp]
  00035	c6 00 00	 mov	 BYTE PTR [rax], 0

; 3064 :     *addr=0;

  00038	48 8b 44 24 68	 mov	 rax, QWORD PTR addr$[rsp]
  0003d	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 3065 : 
; 3066 :     /* Channel program check if CCW is not on a doubleword
; 3067 :        boundary or is outside limit of main storage */
; 3068 :     if ( (ccwaddr & 0x00000007) || CHADDRCHK(ccwaddr, dev) )

  00043	8b 44 24 58	 mov	 eax, DWORD PTR ccwaddr$[rsp]
  00047	83 e0 07	 and	 eax, 7
  0004a	85 c0		 test	 eax, eax
  0004c	75 73		 jne	 SHORT $LN6@z900_fetch
  0004e	8b 44 24 58	 mov	 eax, DWORD PTR ccwaddr$[rsp]
  00052	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00057	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  0005e	77 61		 ja	 SHORT $LN7@z900_fetch
  00060	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00065	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  0006c	83 e0 10	 and	 eax, 16
  0006f	85 c0		 test	 eax, eax
  00071	74 5e		 je	 SHORT $LN5@z900_fetch
  00073	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00078	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0007f	83 e0 20	 and	 eax, 32			; 00000020H
  00082	85 c0		 test	 eax, eax
  00084	74 14		 je	 SHORT $LN9@z900_fetch
  00086	8b 44 24 58	 mov	 eax, DWORD PTR ccwaddr$[rsp]
  0008a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00091	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  00098	72 27		 jb	 SHORT $LN8@z900_fetch
$LN9@z900_fetch:
  0009a	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0009f	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  000a6	83 e0 40	 and	 eax, 64			; 00000040H
  000a9	85 c0		 test	 eax, eax
  000ab	74 24		 je	 SHORT $LN5@z900_fetch
  000ad	8b 44 24 58	 mov	 eax, DWORD PTR ccwaddr$[rsp]
  000b1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000b8	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  000bf	72 10		 jb	 SHORT $LN5@z900_fetch
$LN8@z900_fetch:
$LN7@z900_fetch:
$LN6@z900_fetch:

; 3069 :     {
; 3070 :         *chanstat = CSW_PROGC;

  000c1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  000c9	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3071 :         return;

  000cc	e9 ef 01 00 00	 jmp	 $LN1@z900_fetch
$LN5@z900_fetch:

; 3072 :     }
; 3073 : 
; 3074 :     /* Channel protection check if CCW is fetch protected */
; 3075 :     storkey = ARCH_DEP( get_dev_storage_key )( dev, ccwaddr );

  000d1	8b 44 24 58	 mov	 eax, DWORD PTR ccwaddr$[rsp]
  000d5	8b d0		 mov	 edx, eax
  000d7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000dc	e8 00 00 00 00	 call	 z900_get_dev_storage_key
  000e1	88 44 24 20	 mov	 BYTE PTR storkey$[rsp], al

; 3076 :     if (ccwkey != 0 && (storkey & STORKEY_FETCH)
; 3077 :         && (storkey & STORKEY_KEY) != ccwkey)

  000e5	0f b6 44 24 48	 movzx	 eax, BYTE PTR ccwkey$[rsp]
  000ea	85 c0		 test	 eax, eax
  000ec	74 2f		 je	 SHORT $LN10@z900_fetch
  000ee	0f b6 44 24 20	 movzx	 eax, BYTE PTR storkey$[rsp]
  000f3	83 e0 08	 and	 eax, 8
  000f6	85 c0		 test	 eax, eax
  000f8	74 23		 je	 SHORT $LN10@z900_fetch
  000fa	0f b6 44 24 20	 movzx	 eax, BYTE PTR storkey$[rsp]
  000ff	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00104	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR ccwkey$[rsp]
  00109	3b c1		 cmp	 eax, ecx
  0010b	74 10		 je	 SHORT $LN10@z900_fetch

; 3078 :     {
; 3079 :         *chanstat = CSW_PROTC;

  0010d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00115	c6 00 10	 mov	 BYTE PTR [rax], 16

; 3080 :         return;

  00118	e9 a3 01 00 00	 jmp	 $LN1@z900_fetch
$LN10@z900_fetch:

; 3081 :     }
; 3082 : 
; 3083 :     /* Set the main storage reference bit for the CCW location */
; 3084 :     ARCH_DEP( or_dev_storage_key )( dev, ccwaddr, STORKEY_REF );

  0011d	8b 44 24 58	 mov	 eax, DWORD PTR ccwaddr$[rsp]
  00121	41 b0 04	 mov	 r8b, 4
  00124	8b d0		 mov	 edx, eax
  00126	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0012b	e8 00 00 00 00	 call	 z900_or_dev_storage_key

; 3085 : 
; 3086 :     /* Point to the CCW in main storage */
; 3087 :     ccw = dev->mainstor + ccwaddr;

  00130	8b 44 24 58	 mov	 eax, DWORD PTR ccwaddr$[rsp]
  00134	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00139	48 03 81 80 00
	00 00		 add	 rax, QWORD PTR [rcx+128]
  00140	48 89 44 24 28	 mov	 QWORD PTR ccw$[rsp], rax

; 3088 : 
; 3089 :     /* Extract CCW opcode, flags, byte count, and data address */
; 3090 :     if (ccwfmt == 0)

  00145	0f b6 44 24 50	 movzx	 eax, BYTE PTR ccwfmt$[rsp]
  0014a	85 c0		 test	 eax, eax
  0014c	0f 85 ae 00 00
	00		 jne	 $LN11@z900_fetch

; 3091 :     {
; 3092 :         *code = ccw[0];

  00152	b8 01 00 00 00	 mov	 eax, 1
  00157	48 6b c0 00	 imul	 rax, rax, 0
  0015b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR code$[rsp]
  00160	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  00165	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00169	88 01		 mov	 BYTE PTR [rcx], al

; 3093 :         *addr = ((U32)(ccw[1]) << 16) | ((U32)(ccw[2]) << 8)

  0016b	b8 01 00 00 00	 mov	 eax, 1
  00170	48 6b c0 01	 imul	 rax, rax, 1
  00174	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ccw$[rsp]
  00179	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0017d	c1 e0 10	 shl	 eax, 16
  00180	b9 01 00 00 00	 mov	 ecx, 1
  00185	48 6b c9 02	 imul	 rcx, rcx, 2
  00189	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  0018e	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00192	c1 e1 08	 shl	 ecx, 8
  00195	0b c1		 or	 eax, ecx
  00197	b9 01 00 00 00	 mov	 ecx, 1
  0019c	48 6b c9 03	 imul	 rcx, rcx, 3
  001a0	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  001a5	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  001a9	0b c1		 or	 eax, ecx
  001ab	48 8b 4c 24 68	 mov	 rcx, QWORD PTR addr$[rsp]
  001b0	89 01		 mov	 DWORD PTR [rcx], eax

; 3094 :                     | ccw[3];
; 3095 :         *flags = ccw[4];

  001b2	b8 01 00 00 00	 mov	 eax, 1
  001b7	48 6b c0 04	 imul	 rax, rax, 4
  001bb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR flags$[rsp]
  001c0	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  001c5	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  001c9	88 01		 mov	 BYTE PTR [rcx], al

; 3096 :         *count = ((U16)(ccw[6]) << 8) | ccw[7];

  001cb	b8 01 00 00 00	 mov	 eax, 1
  001d0	48 6b c0 06	 imul	 rax, rax, 6
  001d4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ccw$[rsp]
  001d9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001dd	c1 e0 08	 shl	 eax, 8
  001e0	b9 01 00 00 00	 mov	 ecx, 1
  001e5	48 6b c9 07	 imul	 rcx, rcx, 7
  001e9	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  001ee	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  001f2	0b c1		 or	 eax, ecx
  001f4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR count$[rsp]
  001f9	89 01		 mov	 DWORD PTR [rcx], eax

; 3097 :     }

  001fb	e9 c0 00 00 00	 jmp	 $LN12@z900_fetch
$LN11@z900_fetch:

; 3098 :     else
; 3099 :     {
; 3100 :         *code = ccw[0];

  00200	b8 01 00 00 00	 mov	 eax, 1
  00205	48 6b c0 00	 imul	 rax, rax, 0
  00209	48 8b 4c 24 60	 mov	 rcx, QWORD PTR code$[rsp]
  0020e	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  00213	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00217	88 01		 mov	 BYTE PTR [rcx], al

; 3101 :         *flags = ccw[1];

  00219	b8 01 00 00 00	 mov	 eax, 1
  0021e	48 6b c0 01	 imul	 rax, rax, 1
  00222	48 8b 4c 24 70	 mov	 rcx, QWORD PTR flags$[rsp]
  00227	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  0022c	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00230	88 01		 mov	 BYTE PTR [rcx], al

; 3102 :         *count = ((U16)(ccw[2]) << 8) | ccw[3];

  00232	b8 01 00 00 00	 mov	 eax, 1
  00237	48 6b c0 02	 imul	 rax, rax, 2
  0023b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ccw$[rsp]
  00240	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00244	c1 e0 08	 shl	 eax, 8
  00247	b9 01 00 00 00	 mov	 ecx, 1
  0024c	48 6b c9 03	 imul	 rcx, rcx, 3
  00250	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  00255	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00259	0b c1		 or	 eax, ecx
  0025b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR count$[rsp]
  00260	89 01		 mov	 DWORD PTR [rcx], eax

; 3103 :         *addr = ((U32)(ccw[4]) << 24) | ((U32)(ccw[5]) << 16)

  00262	b8 01 00 00 00	 mov	 eax, 1
  00267	48 6b c0 04	 imul	 rax, rax, 4
  0026b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ccw$[rsp]
  00270	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00274	c1 e0 18	 shl	 eax, 24
  00277	b9 01 00 00 00	 mov	 ecx, 1
  0027c	48 6b c9 05	 imul	 rcx, rcx, 5
  00280	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  00285	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00289	c1 e1 10	 shl	 ecx, 16
  0028c	0b c1		 or	 eax, ecx
  0028e	b9 01 00 00 00	 mov	 ecx, 1
  00293	48 6b c9 06	 imul	 rcx, rcx, 6
  00297	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  0029c	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  002a0	c1 e1 08	 shl	 ecx, 8
  002a3	0b c1		 or	 eax, ecx
  002a5	b9 01 00 00 00	 mov	 ecx, 1
  002aa	48 6b c9 07	 imul	 rcx, rcx, 7
  002ae	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  002b3	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  002b7	0b c1		 or	 eax, ecx
  002b9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR addr$[rsp]
  002be	89 01		 mov	 DWORD PTR [rcx], eax
$LN12@z900_fetch:
$LN1@z900_fetch:

; 3104 :                     | ((U32)(ccw[6]) << 8) | ccw[7];
; 3105 :     }
; 3106 : } /* end function fetch_ccw */

  002c0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  002c4	c3		 ret	 0
z900_fetch_ccw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv86 = 32
dev$ = 64
ccwkey$ = 72
ccwfmt$ = 80
ccwaddr$ = 88
z900_raise_pci PROC

; 3006 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@z900_raise:

; 3007 : #if !defined(FEATURE_CHANNEL_SUBSYSTEM)
; 3008 :     UNREFERENCED(ccwfmt);
; 3009 : #endif
; 3010 : 
; 3011 :     IODELAY(dev);

  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001e	83 b8 e0 13 00
	00 00		 cmp	 DWORD PTR [rax+5088], 0
  00025	7e 2e		 jle	 SHORT $LN5@z900_raise
  00027	b8 01 00 00 00	 mov	 eax, 1
  0002c	48 6b c0 0a	 imul	 rax, rax, 10
  00030	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00035	0f b6 84 01 6c
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1388]
  0003d	83 f8 20	 cmp	 eax, 32			; 00000020H
  00040	75 13		 jne	 SHORT $LN5@z900_raise
  00042	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00049	8b 88 e0 13 00
	00		 mov	 ecx, DWORD PTR [rax+5088]
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN5@z900_raise:
  00055	33 c0		 xor	 eax, eax
  00057	85 c0		 test	 eax, eax
  00059	75 bc		 jne	 SHORT $LN4@z900_raise

; 3012 : 
; 3013 :     OBTAIN_INTLOCK(NULL);

  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195955
  00062	33 c9		 xor	 ecx, ecx
  00064	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 3014 :     obtain_lock (&dev->lock);

  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0006e	48 83 c0 38	 add	 rax, 56			; 00000038H
  00072	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195956
  00079	48 8b c8	 mov	 rcx, rax
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3015 : 
; 3016 :     /* Save the PCI SCSW replacing any previous pending PCI; always
; 3017 :      * track the channel in channel subsystem mode
; 3018 :      */
; 3019 :     dev->pciscsw.flag0 = ccwkey & SCSW0_KEY;

  00082	0f b6 44 24 48	 movzx	 eax, BYTE PTR ccwkey$[rsp]
  00087	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  0008c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00091	88 81 14 03 00
	00		 mov	 BYTE PTR [rcx+788], al

; 3020 :     dev->pciscsw.flag1 = (ccwfmt == 1 ? SCSW1_F : 0);

  00097	0f b6 44 24 50	 movzx	 eax, BYTE PTR ccwfmt$[rsp]
  0009c	83 f8 01	 cmp	 eax, 1
  0009f	75 0a		 jne	 SHORT $LN7@z900_raise
  000a1	c7 44 24 20 80
	00 00 00	 mov	 DWORD PTR tv86[rsp], 128 ; 00000080H
  000a9	eb 08		 jmp	 SHORT $LN8@z900_raise
$LN7@z900_raise:
  000ab	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
$LN8@z900_raise:
  000b3	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000b8	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR tv86[rsp]
  000bd	88 88 15 03 00
	00		 mov	 BYTE PTR [rax+789], cl

; 3021 :     dev->pciscsw.flag2 = SCSW2_FC_START;

  000c3	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000c8	c6 80 16 03 00
	00 40		 mov	 BYTE PTR [rax+790], 64	; 00000040H

; 3022 :     dev->pciscsw.flag3 = SCSW3_AC_SCHAC | SCSW3_AC_DEVAC

  000cf	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000d4	c6 80 17 03 00
	00 c9		 mov	 BYTE PTR [rax+791], 201	; 000000c9H

; 3023 :                        | SCSW3_SC_INTER | SCSW3_SC_PEND;
; 3024 :     STORE_FW(dev->pciscsw.ccwaddr,ccwaddr);

  000db	8b 4c 24 58	 mov	 ecx, DWORD PTR ccwaddr$[rsp]
  000df	e8 00 00 00 00	 call	 _byteswap_ulong
  000e4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000e9	48 81 c1 18 03
	00 00		 add	 rcx, 792		; 00000318H
  000f0	8b d0		 mov	 edx, eax
  000f2	e8 00 00 00 00	 call	 store_fw_noswap

; 3025 :     dev->pciscsw.unitstat = 0;

  000f7	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000fc	c6 80 1c 03 00
	00 00		 mov	 BYTE PTR [rax+796], 0

; 3026 :     dev->pciscsw.chanstat = CSW_PCI;

  00103	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00108	c6 80 1d 03 00
	00 80		 mov	 BYTE PTR [rax+797], 128	; 00000080H

; 3027 :     store_hw (dev->pciscsw.count, 0);

  0010f	33 c9		 xor	 ecx, ecx
  00111	e8 00 00 00 00	 call	 _byteswap_ushort
  00116	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0011b	48 81 c1 1e 03
	00 00		 add	 rcx, 798		; 0000031eH
  00122	0f b7 d0	 movzx	 edx, ax
  00125	e8 00 00 00 00	 call	 store_hw_noswap

; 3028 : 
; 3029 :     /* Queue the PCI pending interrupt */
; 3030 :     obtain_lock(&sysblk.iointqlk);

  0012a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00131	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  00137	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195957
  0013e	48 8b c8	 mov	 rcx, rax
  00141	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3031 :     QUEUE_IO_INTERRUPT_QLOCKED(&dev->pciioint,FALSE);

  00147	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0014c	48 05 40 02 00
	00		 add	 rax, 576		; 00000240H
  00152	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195958
  00159	33 d2		 xor	 edx, edx
  0015b	48 8b c8	 mov	 rcx, rax
  0015e	e8 00 00 00 00	 call	 Queue_IO_Interrupt_QLocked

; 3032 : 
; 3033 :     /* Update interrupt status */
; 3034 :     subchannel_interrupt_queue_cleanup(dev);

  00163	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00168	e8 00 00 00 00	 call	 subchannel_interrupt_queue_cleanup

; 3035 :     UPDATE_IC_IOPENDING_QLOCKED();

  0016d	e8 00 00 00 00	 call	 Update_IC_IOPENDING_QLocked

; 3036 :     release_lock(&sysblk.iointqlk);

  00172	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00179	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  0017f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195959
  00186	48 8b c8	 mov	 rcx, rax
  00189	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3037 :     release_lock(&dev->lock);

  0018f	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00194	48 83 c0 38	 add	 rax, 56			; 00000038H
  00198	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195960
  0019f	48 8b c8	 mov	 rcx, rax
  001a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3038 :     RELEASE_INTLOCK(NULL);

  001a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195961
  001af	33 c9		 xor	 ecx, ecx
  001b1	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 3039 : 
; 3040 : } /* end function raise_pci */

  001b6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001ba	c3		 ret	 0
z900_raise_pci ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_dev_storage_key
_TEXT	SEGMENT
dev$ = 48
abs$ = 56
bits$ = 64
z900_or_dev_storage_key PROC				; COMDAT

; 299  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 300  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 301  :     ARCH_DEP( or_dev_2K_storage_key )( dev, abs, bits );
; 302  : #else
; 303  :     ARCH_DEP( or_dev_4K_storage_key )( dev, abs, bits );

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR bits$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR abs$[rsp]
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00023	e8 00 00 00 00	 call	 z900_or_dev_4K_storage_key

; 304  : #endif
; 305  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
z900_or_dev_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_get_dev_storage_key
_TEXT	SEGMENT
dev$ = 48
abs$ = 56
z900_get_dev_storage_key PROC				; COMDAT

; 263  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 264  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 265  :     return ARCH_DEP( get_dev_2K_storage_key )( dev, abs );
; 266  : #else
; 267  :     return ARCH_DEP( get_dev_4K_storage_key )( dev, abs );

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR abs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00018	e8 00 00 00 00	 call	 z900_get_dev_4K_storage_key

; 268  : #endif
; 269  : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
z900_get_dev_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_dev_4K_storage_key
_TEXT	SEGMENT
dev$ = 48
abs$ = 56
bits$ = 64
z900_or_dev_4K_storage_key PROC				; COMDAT

; 246  :   inline void  ARCH_DEP( or_dev_4K_storage_key )  ( DEVBLK* dev, U64 abs, BYTE bits ) {        ARCH_DEP( _or_dev_storage_key  )( dev, abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00013	0f b6 44 24 40	 movzx	 eax, BYTE PTR bits$[rsp]
  00018	83 e0 fe	 and	 eax, -2
  0001b	41 b1 04	 mov	 r9b, 4
  0001e	44 0f b6 c0	 movzx	 r8d, al
  00022	48 8b 54 24 38	 mov	 rdx, QWORD PTR abs$[rsp]
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0002c	e8 00 00 00 00	 call	 z900__or_dev_storage_key
  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
z900_or_dev_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_get_dev_4K_storage_key
_TEXT	SEGMENT
dev$ = 48
abs$ = 56
z900_get_dev_4K_storage_key PROC			; COMDAT

; 244  :   inline BYTE  ARCH_DEP( get_dev_4K_storage_key ) ( DEVBLK* dev, U64 abs            ) { return ARCH_DEP( _get_dev_storage_key )( dev, abs, 4 )  & ~STORKEY_BADFRM;      }

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	41 b0 04	 mov	 r8b, 4
  00011	48 8b 54 24 38	 mov	 rdx, QWORD PTR abs$[rsp]
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0001b	e8 00 00 00 00	 call	 z900__get_dev_storage_key
  00020	0f b6 c0	 movzx	 eax, al
  00023	83 e0 fe	 and	 eax, -2
  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
z900_get_dev_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900__or_dev_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
dev$ = 80
abs$ = 88
bits$ = 96
K$ = 104
z900__or_dev_storage_key PROC				; COMDAT

; 206  : {

$LN8:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@z900__or_d:

; 207  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	75 fa		 jne	 SHORT $LN4@z900__or_d

; 208  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  0001e	33 c0		 xor	 eax, eax
  00020	85 c0		 test	 eax, eax
  00022	74 5a		 je	 SHORT $LN5@z900__or_d

; 209  :     {
; 210  :         BYTE* skey1_ptr = _get_dev_storekey1_ptr( dev, abs );

  00024	48 8b 54 24 58	 mov	 rdx, QWORD PTR abs$[rsp]
  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0002e	e8 00 00 00 00	 call	 _get_dev_storekey1_ptr
  00033	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 211  :         BYTE* skey2_ptr = _get_dev_storekey2_ptr( dev, abs );

  00038	48 8b 54 24 58	 mov	 rdx, QWORD PTR abs$[rsp]
  0003d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00042	e8 00 00 00 00	 call	 _get_dev_storekey2_ptr
  00047	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 212  :         OR_SKEY( skey1_ptr, bits );

  0004c	0f b6 44 24 60	 movzx	 eax, BYTE PTR bits$[rsp]
  00051	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00056	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00059	0b c8		 or	 ecx, eax
  0005b	8b c1		 mov	 eax, ecx
  0005d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00062	88 01		 mov	 BYTE PTR [rcx], al

; 213  :         OR_SKEY( skey2_ptr, bits );

  00064	0f b6 44 24 60	 movzx	 eax, BYTE PTR bits$[rsp]
  00069	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00071	0b c8		 or	 ecx, eax
  00073	8b c1		 mov	 eax, ecx
  00075	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0007a	88 01		 mov	 BYTE PTR [rcx], al

; 214  :     }

  0007c	eb 32		 jmp	 SHORT $LN6@z900__or_d
$LN5@z900__or_d:

; 215  :     else
; 216  :     {
; 217  :         BYTE* skey_ptr  = _get_dev_storekey_ptr(  dev, abs, K );

  0007e	44 0f b6 44 24
	68		 movzx	 r8d, BYTE PTR K$[rsp]
  00084	48 8b 54 24 58	 mov	 rdx, QWORD PTR abs$[rsp]
  00089	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0008e	e8 00 00 00 00	 call	 _get_dev_storekey_ptr
  00093	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 218  :         OR_SKEY( skey_ptr, bits );

  00098	0f b6 44 24 60	 movzx	 eax, BYTE PTR bits$[rsp]
  0009d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  000a2	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000a5	0b c8		 or	 ecx, eax
  000a7	8b c1		 mov	 eax, ecx
  000a9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  000ae	88 01		 mov	 BYTE PTR [rcx], al
$LN6@z900__or_d:

; 219  :     }
; 220  : }

  000b0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b4	c3		 ret	 0
z900__or_dev_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900__get_dev_storage_key
_TEXT	SEGMENT
skey$ = 32
dev$ = 64
abs$ = 72
K$ = 80
z900__get_dev_storage_key PROC				; COMDAT

; 144  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@z900__get_:

; 145  :     BYTE skey;
; 146  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	75 fa		 jne	 SHORT $LN4@z900__get_

; 147  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00019	33 c0		 xor	 eax, eax
  0001b	85 c0		 test	 eax, eax
  0001d	74 3c		 je	 SHORT $LN5@z900__get_

; 148  :     {
; 149  :         skey  = *_get_dev_storekey1_ptr( dev, abs );

  0001f	48 8b 54 24 48	 mov	 rdx, QWORD PTR abs$[rsp]
  00024	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00029	e8 00 00 00 00	 call	 _get_dev_storekey1_ptr
  0002e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00031	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 150  :         skey |= *_get_dev_storekey2_ptr( dev, abs ) & ~(STORKEY_KEY);

  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR abs$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0003f	e8 00 00 00 00	 call	 _get_dev_storekey2_ptr
  00044	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00047	25 0f ff ff ff	 and	 eax, -241		; ffffffffffffff0fH
  0004c	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR skey$[rsp]
  00051	0b c8		 or	 ecx, eax
  00053	8b c1		 mov	 eax, ecx
  00055	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 151  :     }

  00059	eb 1c		 jmp	 SHORT $LN6@z900__get_
$LN5@z900__get_:

; 152  :     else
; 153  :         skey  = *_get_dev_storekey_ptr(  dev, abs, K );

  0005b	44 0f b6 44 24
	50		 movzx	 r8d, BYTE PTR K$[rsp]
  00061	48 8b 54 24 48	 mov	 rdx, QWORD PTR abs$[rsp]
  00066	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0006b	e8 00 00 00 00	 call	 _get_dev_storekey_ptr
  00070	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00073	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al
$LN6@z900__get_:

; 154  :     return skey;

  00077	0f b6 44 24 20	 movzx	 eax, BYTE PTR skey$[rsp]

; 155  : }

  0007c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00080	c3		 ret	 0
z900__get_dev_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv305 = 32
tv314 = 36
pDEVLIST$ = 40
dev$ = 48
pZoneDevs$ = 56
pPrevDEVLIST$ = 64
io$ = 72
ioid$ = 96
ioparm$ = 104
iointid$ = 112
zone$ = 120
z900_present_zone_io_interrupt PROC

; 6356 : {

$LN34:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 6357 : IOINT  *io;                             /* -> I/O interrupt entry    */
; 6358 : DEVBLK *dev;                            /* -> Device control block   */
; 6359 : typedef struct _DEVLIST {               /* list of device block ptrs */
; 6360 :     struct _DEVLIST *next;              /* next list entry or NULL   */
; 6361 :     DEVBLK          *dev;               /* DEVBLK in requested zone  */
; 6362 :     U16              ssid;              /* Subsystem ID incl. lcssid */
; 6363 :     U16              subchan;           /* Subchannel number         */
; 6364 :     FWORD            intparm;           /* Interruption parameter    */
; 6365 :     int              visc;              /* Guest Interrupt Subclass  */
; 6366 : } DEVLIST;
; 6367 : DEVLIST *pDEVLIST, *pPrevDEVLIST = NULL;/* (work)                    */

  00018	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR pPrevDEVLIST$[rsp], 0

; 6368 : DEVLIST *pZoneDevs = NULL;              /* devices in requested zone */

  00021	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR pZoneDevs$[rsp], 0

; 6369 : 
; 6370 :     /* Gather devices within our zone with pending interrupt flagged */
; 6371 :     for (dev = sysblk.firstdev; dev; dev = dev->nextdev)

  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00031	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  00038	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax
  0003d	eb 0e		 jmp	 SHORT $LN4@z900_prese
$LN2@z900_prese:
  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00044	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00048	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax
$LN4@z900_prese:
  0004d	48 83 7c 24 30
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00053	0f 84 7a 01 00
	00		 je	 $LN3@z900_prese

; 6372 :     {
; 6373 :         /* Skip "devices" that don't actually exist */
; 6374 :         if (!IS_DEV(dev))

  00059	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0005e	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  00062	74 28		 je	 SHORT $LN20@z900_prese
  00064	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00069	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00070	83 e0 01	 and	 eax, 1
  00073	85 c0		 test	 eax, eax
  00075	75 17		 jne	 SHORT $LN19@z900_prese
  00077	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007e	48 8b 80 c8 11
	00 00		 mov	 rax, QWORD PTR [rax+4552]
  00085	48 39 44 24 30	 cmp	 QWORD PTR dev$[rsp], rax
  0008a	74 02		 je	 SHORT $LN19@z900_prese
$LN20@z900_prese:

; 6375 :             continue;

  0008c	eb b1		 jmp	 SHORT $LN2@z900_prese
$LN19@z900_prese:

; 6376 : 
; 6377 :         obtain_lock (&dev->lock);

  0008e	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00093	48 83 c0 38	 add	 rax, 56			; 00000038H
  00097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG197049
  0009e	48 8b c8	 mov	 rcx, rax
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 6378 : 
; 6379 :         if (1
; 6380 :             /* Subchannel valid and enabled */
; 6381 :             && ((dev->pmcw.flag5 & (PMCW5_E | PMCW5_V)) == (PMCW5_E | PMCW5_V))
; 6382 :             /* Within requested zone */
; 6383 :             && (dev->pmcw.zone == zone)
; 6384 :             /* Pending interrupt flagged */
; 6385 :             && ((dev->scsw.flag3 | dev->pciscsw.flag3) & SCSW3_SC_PEND)

  000a7	33 c0		 xor	 eax, eax
  000a9	83 f8 01	 cmp	 eax, 1
  000ac	0f 84 03 01 00
	00		 je	 $LN21@z900_prese
  000b2	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  000b7	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  000be	25 81 00 00 00	 and	 eax, 129		; 00000081H
  000c3	3d 81 00 00 00	 cmp	 eax, 129		; 00000081H
  000c8	0f 85 e7 00 00
	00		 jne	 $LN21@z900_prese
  000ce	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  000d3	0f b6 80 04 03
	00 00		 movzx	 eax, BYTE PTR [rax+772]
  000da	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR zone$[rsp]
  000df	3b c1		 cmp	 eax, ecx
  000e1	0f 85 ce 00 00
	00		 jne	 $LN21@z900_prese
  000e7	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  000ec	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  000f3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  000f8	0f b6 89 17 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+791]
  000ff	0b c1		 or	 eax, ecx
  00101	83 e0 01	 and	 eax, 1
  00104	85 c0		 test	 eax, eax
  00106	0f 84 a9 00 00
	00		 je	 $LN21@z900_prese

; 6386 :         )
; 6387 :         {
; 6388 :             /* (save this device for further scrutiny) */
; 6389 :             pDEVLIST          = (DEVLIST *)malloc( sizeof(DEVLIST) );

  0010c	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00117	48 89 44 24 28	 mov	 QWORD PTR pDEVLIST$[rsp], rax

; 6390 :             pDEVLIST->next    = NULL;

  0011c	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  00121	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 6391 :             pDEVLIST->dev     = dev;

  00128	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  0012d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00132	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 6392 :             pDEVLIST->ssid    = dev->ssid;

  00136	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  0013b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00140	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00144	66 89 48 10	 mov	 WORD PTR [rax+16], cx

; 6393 :             pDEVLIST->subchan = dev->subchan;

  00148	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  0014d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00152	0f b7 49 46	 movzx	 ecx, WORD PTR [rcx+70]
  00156	66 89 48 12	 mov	 WORD PTR [rax+18], cx

; 6394 : //          pDEVLIST->intparm = dev->pmcw.intparm;
; 6395 :             memcpy( pDEVLIST->intparm, dev->pmcw.intparm, sizeof(pDEVLIST->intparm) );

  0015a	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  0015f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00164	8b 89 ec 02 00
	00		 mov	 ecx, DWORD PTR [rcx+748]
  0016a	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 6396 :             pDEVLIST->visc    = (dev->pmcw.flag25 & PMCW25_VISC);

  0016d	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00172	0f b6 80 05 03
	00 00		 movzx	 eax, BYTE PTR [rax+773]
  00179	83 e0 07	 and	 eax, 7
  0017c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pDEVLIST$[rsp]
  00181	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 6397 : 
; 6398 :             if (!pZoneDevs)

  00184	48 83 7c 24 38
	00		 cmp	 QWORD PTR pZoneDevs$[rsp], 0
  0018a	75 0a		 jne	 SHORT $LN22@z900_prese

; 6399 :                 pZoneDevs = pDEVLIST;

  0018c	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  00191	48 89 44 24 38	 mov	 QWORD PTR pZoneDevs$[rsp], rax
$LN22@z900_prese:

; 6400 : 
; 6401 :             if (pPrevDEVLIST)

  00196	48 83 7c 24 40
	00		 cmp	 QWORD PTR pPrevDEVLIST$[rsp], 0
  0019c	74 0d		 je	 SHORT $LN23@z900_prese

; 6402 :                 pPrevDEVLIST->next = pDEVLIST;

  0019e	48 8b 44 24 40	 mov	 rax, QWORD PTR pPrevDEVLIST$[rsp]
  001a3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pDEVLIST$[rsp]
  001a8	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN23@z900_prese:

; 6403 : 
; 6404 :             pPrevDEVLIST = pDEVLIST;

  001ab	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  001b0	48 89 44 24 40	 mov	 QWORD PTR pPrevDEVLIST$[rsp], rax
$LN21@z900_prese:

; 6405 :         }
; 6406 : 
; 6407 :         release_lock (&dev->lock);

  001b5	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  001ba	48 83 c0 38	 add	 rax, 56			; 00000038H
  001be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG197053
  001c5	48 8b c8	 mov	 rcx, rax
  001c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6408 :     }

  001ce	e9 6c fe ff ff	 jmp	 $LN2@z900_prese
$LN3@z900_prese:

; 6409 : 
; 6410 :     /* Exit with condition code 0 if no devices
; 6411 :        within our zone with a pending interrupt */
; 6412 :     if (!pZoneDevs)

  001d3	48 83 7c 24 38
	00		 cmp	 QWORD PTR pZoneDevs$[rsp], 0
  001d9	75 07		 jne	 SHORT $LN24@z900_prese

; 6413 :         return 0;

  001db	33 c0		 xor	 eax, eax
  001dd	e9 83 02 00 00	 jmp	 $LN1@z900_prese
$LN24@z900_prese:

; 6414 : 
; 6415 :     /* Remove from our list those devices
; 6416 :        without a pending interrupt queued */
; 6417 :     obtain_lock(&sysblk.iointqlk);

  001e2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001e9	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  001ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG197055
  001f6	48 8b c8	 mov	 rcx, rax
  001f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 6418 :     for (pDEVLIST = pZoneDevs, pPrevDEVLIST = NULL; pDEVLIST;)

  001ff	48 8b 44 24 38	 mov	 rax, QWORD PTR pZoneDevs$[rsp]
  00204	48 89 44 24 28	 mov	 QWORD PTR pDEVLIST$[rsp], rax
  00209	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR pPrevDEVLIST$[rsp], 0
$LN5@z900_prese:
  00212	48 83 7c 24 28
	00		 cmp	 QWORD PTR pDEVLIST$[rsp], 0
  00218	0f 84 30 01 00
	00		 je	 $LN6@z900_prese

; 6419 :     {
; 6420 :         /* Search interrupt queue for this device */
; 6421 :         for (io = sysblk.iointq; io != NULL && io->dev != pDEVLIST->dev; io = io->next);

  0021e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00225	48 8b 80 28 12
	00 00		 mov	 rax, QWORD PTR [rax+4648]
  0022c	48 89 44 24 48	 mov	 QWORD PTR io$[rsp], rax
  00231	eb 0d		 jmp	 SHORT $LN10@z900_prese
$LN8@z900_prese:
  00233	48 8b 44 24 48	 mov	 rax, QWORD PTR io$[rsp]
  00238	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0023b	48 89 44 24 48	 mov	 QWORD PTR io$[rsp], rax
$LN10@z900_prese:
  00240	48 83 7c 24 48
	00		 cmp	 QWORD PTR io$[rsp], 0
  00246	74 16		 je	 SHORT $LN9@z900_prese
  00248	48 8b 44 24 48	 mov	 rax, QWORD PTR io$[rsp]
  0024d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pDEVLIST$[rsp]
  00252	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00256	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  0025a	74 02		 je	 SHORT $LN9@z900_prese
  0025c	eb d5		 jmp	 SHORT $LN8@z900_prese
$LN9@z900_prese:

; 6422 : 
; 6423 :         /* Is interrupt queued for this device? */
; 6424 :         if (io == NULL)

  0025e	48 83 7c 24 48
	00		 cmp	 QWORD PTR io$[rsp], 0
  00264	0f 85 c8 00 00
	00		 jne	 $LN25@z900_prese

; 6425 :         {
; 6426 :             /* No, remove it from our list */
; 6427 :             if (!pPrevDEVLIST)

  0026a	48 83 7c 24 40
	00		 cmp	 QWORD PTR pPrevDEVLIST$[rsp], 0
  00270	0f 85 92 00 00
	00		 jne	 $LN27@z900_prese
$LN13@z900_prese:

; 6428 :             {
; 6429 :                 ASSERT(pDEVLIST == pZoneDevs);

  00276	48 8b 44 24 38	 mov	 rax, QWORD PTR pZoneDevs$[rsp]
  0027b	48 39 44 24 28	 cmp	 QWORD PTR pDEVLIST$[rsp], rax
  00280	74 5c		 je	 SHORT $LN29@z900_prese
$LN16@z900_prese:
  00282	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197061
  00289	41 b8 1d 19 00
	00		 mov	 r8d, 6429		; 0000191dH
  0028f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG197062
  00296	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG197063
  0029d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  002a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  002a9	85 c0		 test	 eax, eax
  002ab	74 20		 je	 SHORT $LN30@z900_prese
  002ad	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197065
  002b4	41 b8 1d 19 00
	00		 mov	 r8d, 6429		; 0000191dH
  002ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG197066
  002c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG197067
  002c8	e8 00 00 00 00	 call	 DebuggerTrace
$LN30@z900_prese:
  002cd	33 c0		 xor	 eax, eax
  002cf	85 c0		 test	 eax, eax
  002d1	75 af		 jne	 SHORT $LN16@z900_prese
  002d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  002d9	85 c0		 test	 eax, eax
  002db	74 01		 je	 SHORT $LN31@z900_prese
  002dd	cc		 int	 3
$LN31@z900_prese:
$LN29@z900_prese:
  002de	33 c0		 xor	 eax, eax
  002e0	85 c0		 test	 eax, eax
  002e2	75 92		 jne	 SHORT $LN13@z900_prese

; 6430 :                 pZoneDevs = pDEVLIST->next;

  002e4	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  002e9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002ec	48 89 44 24 38	 mov	 QWORD PTR pZoneDevs$[rsp], rax

; 6431 :                 free(pDEVLIST);

  002f1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pDEVLIST$[rsp]
  002f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6432 :                 pDEVLIST = pZoneDevs;

  002fc	48 8b 44 24 38	 mov	 rax, QWORD PTR pZoneDevs$[rsp]
  00301	48 89 44 24 28	 mov	 QWORD PTR pDEVLIST$[rsp], rax

; 6433 :             }

  00306	eb 28		 jmp	 SHORT $LN28@z900_prese
$LN27@z900_prese:

; 6434 :             else
; 6435 :             {
; 6436 :                 pPrevDEVLIST->next = pDEVLIST->next;

  00308	48 8b 44 24 40	 mov	 rax, QWORD PTR pPrevDEVLIST$[rsp]
  0030d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pDEVLIST$[rsp]
  00312	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00315	48 89 08	 mov	 QWORD PTR [rax], rcx

; 6437 :                 free(pDEVLIST);

  00318	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pDEVLIST$[rsp]
  0031d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6438 :                 pDEVLIST = pPrevDEVLIST->next;

  00323	48 8b 44 24 40	 mov	 rax, QWORD PTR pPrevDEVLIST$[rsp]
  00328	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0032b	48 89 44 24 28	 mov	 QWORD PTR pDEVLIST$[rsp], rax
$LN28@z900_prese:

; 6439 :             }
; 6440 :         }

  00330	eb 17		 jmp	 SHORT $LN26@z900_prese
$LN25@z900_prese:

; 6441 :         else
; 6442 :         {
; 6443 :             /* Yes, go on to next list entry */
; 6444 :             pPrevDEVLIST = pDEVLIST;

  00332	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  00337	48 89 44 24 40	 mov	 QWORD PTR pPrevDEVLIST$[rsp], rax

; 6445 :             pDEVLIST = pDEVLIST->next;

  0033c	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  00341	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00344	48 89 44 24 28	 mov	 QWORD PTR pDEVLIST$[rsp], rax
$LN26@z900_prese:

; 6446 :         }
; 6447 :     }

  00349	e9 c4 fe ff ff	 jmp	 $LN5@z900_prese
$LN6@z900_prese:

; 6448 :     release_lock(&sysblk.iointqlk);

  0034e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00355	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  0035b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG197069
  00362	48 8b c8	 mov	 rcx, rax
  00365	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6449 : 
; 6450 :     /* If no devices remain, exit with condition code 0 */
; 6451 :     if (!pZoneDevs)

  0036b	48 83 7c 24 38
	00		 cmp	 QWORD PTR pZoneDevs$[rsp], 0
  00371	75 07		 jne	 SHORT $LN32@z900_prese

; 6452 :         return 0;

  00373	33 c0		 xor	 eax, eax
  00375	e9 eb 00 00 00	 jmp	 $LN1@z900_prese
$LN32@z900_prese:

; 6453 : 
; 6454 :     /* Extract the I/O address and interrupt parameter
; 6455 :        for the first pending subchannel */
; 6456 :     dev = pZoneDevs->dev;

  0037a	48 8b 44 24 38	 mov	 rax, QWORD PTR pZoneDevs$[rsp]
  0037f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00383	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax

; 6457 :     *ioid = (pZoneDevs->ssid << 16) | pZoneDevs->subchan;

  00388	48 8b 44 24 38	 mov	 rax, QWORD PTR pZoneDevs$[rsp]
  0038d	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  00391	c1 e0 10	 shl	 eax, 16
  00394	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pZoneDevs$[rsp]
  00399	0f b7 49 12	 movzx	 ecx, WORD PTR [rcx+18]
  0039d	0b c1		 or	 eax, ecx
  0039f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ioid$[rsp]
  003a4	89 01		 mov	 DWORD PTR [rcx], eax

; 6458 :     FETCH_FW(*ioparm,pZoneDevs->intparm);

  003a6	48 8b 44 24 38	 mov	 rax, QWORD PTR pZoneDevs$[rsp]
  003ab	48 83 c0 14	 add	 rax, 20
  003af	48 8b c8	 mov	 rcx, rax
  003b2	e8 00 00 00 00	 call	 fetch_fw_noswap
  003b7	8b c8		 mov	 ecx, eax
  003b9	e8 00 00 00 00	 call	 _byteswap_ulong
  003be	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ioparm$[rsp]
  003c3	89 01		 mov	 DWORD PTR [rcx], eax

; 6459 :     *iointid = (0x80000000 >> pZoneDevs->visc) | (zone << 16);

  003c5	48 8b 44 24 38	 mov	 rax, QWORD PTR pZoneDevs$[rsp]
  003ca	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  003cd	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  003d2	89 4c 24 20	 mov	 DWORD PTR tv305[rsp], ecx
  003d6	0f b6 c8	 movzx	 ecx, al
  003d9	8b 44 24 20	 mov	 eax, DWORD PTR tv305[rsp]
  003dd	d3 e8		 shr	 eax, cl
  003df	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR zone$[rsp]
  003e4	c1 e1 10	 shl	 ecx, 16
  003e7	0b c1		 or	 eax, ecx
  003e9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR iointid$[rsp]
  003ee	89 01		 mov	 DWORD PTR [rcx], eax

; 6460 :     pDEVLIST = pZoneDevs->next;

  003f0	48 8b 44 24 38	 mov	 rax, QWORD PTR pZoneDevs$[rsp]
  003f5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003f8	48 89 44 24 28	 mov	 QWORD PTR pDEVLIST$[rsp], rax

; 6461 :     free (pZoneDevs);

  003fd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pZoneDevs$[rsp]
  00402	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN17@z900_prese:

; 6462 : 
; 6463 :     /* Find all other pending subclasses */
; 6464 :     while (pDEVLIST)

  00408	48 83 7c 24 28
	00		 cmp	 QWORD PTR pDEVLIST$[rsp], 0
  0040e	74 50		 je	 SHORT $LN18@z900_prese

; 6465 :     {
; 6466 :         *iointid |= (0x80000000 >> pDEVLIST->visc);

  00410	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  00415	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00418	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  0041d	89 4c 24 24	 mov	 DWORD PTR tv314[rsp], ecx
  00421	0f b6 c8	 movzx	 ecx, al
  00424	8b 44 24 24	 mov	 eax, DWORD PTR tv314[rsp]
  00428	d3 e8		 shr	 eax, cl
  0042a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR iointid$[rsp]
  0042f	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00431	0b c8		 or	 ecx, eax
  00433	8b c1		 mov	 eax, ecx
  00435	48 8b 4c 24 70	 mov	 rcx, QWORD PTR iointid$[rsp]
  0043a	89 01		 mov	 DWORD PTR [rcx], eax

; 6467 :         pPrevDEVLIST = pDEVLIST;

  0043c	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  00441	48 89 44 24 40	 mov	 QWORD PTR pPrevDEVLIST$[rsp], rax

; 6468 :         pDEVLIST = pDEVLIST->next;

  00446	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  0044b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0044e	48 89 44 24 28	 mov	 QWORD PTR pDEVLIST$[rsp], rax

; 6469 :         free (pPrevDEVLIST);

  00453	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pPrevDEVLIST$[rsp]
  00458	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6470 :     }

  0045e	eb a8		 jmp	 SHORT $LN17@z900_prese
$LN18@z900_prese:

; 6471 : 
; 6472 :     /* Exit with condition code indicating interrupt pending */
; 6473 :     return 1;

  00460	b8 01 00 00 00	 mov	 eax, 1
$LN1@z900_prese:

; 6474 : 
; 6475 : } /* end function present_zone_io_interrupt */

  00465	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00469	c3		 ret	 0
z900_present_zone_io_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
PCI_dequeued$ = 48
dotsch$ = 49
dev$ = 56
saved_dotsch$ = 64
icode$ = 68
io$ = 72
i$1 = 80
tv375 = 84
mask$2 = 88
tv235 = 96
tv258 = 100
tv278 = 104
tv290 = 108
tv292 = 112
tv329 = 116
tv349 = 120
io2$ = 128
wake$3 = 136
regs$4 = 144
cc$5 = 152
scsw$6 = 160
p$7 = 168
ioint$8 = 176
irb$9 = 192
__$ArrayPad$ = 256
regs$ = 288
ioid$ = 296
ioparm$ = 304
iointid$ = 312
csw$ = 320
pdev$ = 328
z900_present_io_interrupt PROC

; 6042 : {

$LN87:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 6043 : IOINT  *io, *io2;                       /* -> I/O interrupt entry    */
; 6044 : DEVBLK *dev;                            /* -> Device control block   */
; 6045 : int     icode = 0;                      /* Intercept code            */

  0002d	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR icode$[rsp], 0

; 6046 : bool    dotsch = true;                  /* perform TSCH after int    */

  00035	c6 44 24 31 01	 mov	 BYTE PTR dotsch$[rsp], 1

; 6047 :                                         /* except for THININT        */
; 6048 : 
; 6049 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY) || defined(_FEATURE_IO_ASSIST)
; 6050 : #if defined(FEATURE_QDIO_THININT)
; 6051 : /* The 2 following variables are only used for QDIO Thin Interrupt Processing */
; 6052 : bool    saved_dotsch  = dotsch;

  0003a	0f b6 44 24 31	 movzx	 eax, BYTE PTR dotsch$[rsp]
  0003f	88 44 24 40	 mov	 BYTE PTR saved_dotsch$[rsp], al

; 6053 : bool    PCI_dequeued  = false;

  00043	c6 44 24 30 00	 mov	 BYTE PTR PCI_dequeued$[rsp], 0
$LN4@z900_prese:

; 6054 : #endif
; 6055 : #endif
; 6056 : 
; 6057 :     UNREFERENCED_370(ioparm);

  00048	33 c0		 xor	 eax, eax
  0004a	85 c0		 test	 eax, eax
  0004c	75 fa		 jne	 SHORT $LN4@z900_prese
$LN7@z900_prese:

; 6058 :     UNREFERENCED_370(iointid);

  0004e	33 c0		 xor	 eax, eax
  00050	85 c0		 test	 eax, eax
  00052	75 fa		 jne	 SHORT $LN7@z900_prese
$LN10@z900_prese:

; 6059 : #if defined(_FEATURE_IO_ASSIST)
; 6060 :     UNREFERENCED_390(iointid);

  00054	33 c0		 xor	 eax, eax
  00056	85 c0		 test	 eax, eax
  00058	75 fa		 jne	 SHORT $LN10@z900_prese
$LN13@z900_prese:

; 6061 : #endif
; 6062 :     UNREFERENCED_390(csw);

  0005a	33 c0		 xor	 eax, eax
  0005c	85 c0		 test	 eax, eax
  0005e	75 fa		 jne	 SHORT $LN13@z900_prese
$LN16@z900_prese:

; 6063 :     UNREFERENCED_900(csw);

  00060	33 c0		 xor	 eax, eax
  00062	85 c0		 test	 eax, eax
  00064	75 fa		 jne	 SHORT $LN16@z900_prese
$retry$88:

; 6064 : 
; 6065 : retry:
; 6066 : 
; 6067 :     /* Find a device with pending interrupt...
; 6068 : 
; 6069 :        Please remember that the device lock CANNOT be acquired
; 6070 :        while iointqlk is held. The iointqlk MUST be acquired AFTER
; 6071 :        the device lock is first acquired. Thus the retry logic.
; 6072 :     */
; 6073 :     dev = NULL;

  00066	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR dev$[rsp], 0

; 6074 : 
; 6075 :     obtain_lock( &sysblk.iointqlk );

  0006f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00076	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  0007c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196948
  00083	48 8b c8	 mov	 rcx, rax
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 6076 :     {
; 6077 :         for (io = sysblk.iointq; io != NULL; io = io->next)

  0008c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00093	48 8b 80 28 12
	00 00		 mov	 rax, QWORD PTR [rax+4648]
  0009a	48 89 44 24 48	 mov	 QWORD PTR io$[rsp], rax
  0009f	eb 0d		 jmp	 SHORT $LN19@z900_prese
$LN17@z900_prese:
  000a1	48 8b 44 24 48	 mov	 rax, QWORD PTR io$[rsp]
  000a6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a9	48 89 44 24 48	 mov	 QWORD PTR io$[rsp], rax
$LN19@z900_prese:
  000ae	48 83 7c 24 48
	00		 cmp	 QWORD PTR io$[rsp], 0
  000b4	0f 84 2f 01 00
	00		 je	 $LN18@z900_prese

; 6078 :         {
; 6079 :             /* Can't present interrupt while TEST SUBCHANNEL required
; 6080 :              * (interrupt already presented for this device)
; 6081 :              */
; 6082 :             if (io->dev->tschpending)

  000ba	48 8b 44 24 48	 mov	 rax, QWORD PTR io$[rsp]
  000bf	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000c3	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000c9	c1 e8 1b	 shr	 eax, 27
  000cc	83 e0 01	 and	 eax, 1
  000cf	85 c0		 test	 eax, eax
  000d1	74 02		 je	 SHORT $LN40@z900_prese

; 6083 :                 continue;

  000d3	eb cc		 jmp	 SHORT $LN17@z900_prese
$LN40@z900_prese:

; 6084 : 
; 6085 :             /* Exit loop if enabled for interrupts from this device */
; 6086 :             if ((icode = ARCH_DEP( interrupt_enabled )( regs, io->dev ))
; 6087 : 
; 6088 : #if defined( _FEATURE_IO_ASSIST )
; 6089 :               && icode != SIE_INTERCEPT_IOINTP

  000d5	48 8b 44 24 48	 mov	 rax, QWORD PTR io$[rsp]
  000da	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000de	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e6	e8 00 00 00 00	 call	 z900_interrupt_enabled
  000eb	89 44 24 44	 mov	 DWORD PTR icode$[rsp], eax
  000ef	83 7c 24 44 00	 cmp	 DWORD PTR icode$[rsp], 0
  000f4	74 1a		 je	 SHORT $LN41@z900_prese
  000f6	83 7c 24 44 f0	 cmp	 DWORD PTR icode$[rsp], -16
  000fb	74 13		 je	 SHORT $LN41@z900_prese

; 6090 : #endif
; 6091 :             )
; 6092 :             {
; 6093 :                 dev = io->dev;

  000fd	48 8b 44 24 48	 mov	 rax, QWORD PTR io$[rsp]
  00102	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00106	48 89 44 24 38	 mov	 QWORD PTR dev$[rsp], rax

; 6094 :                 break;

  0010b	e9 d9 00 00 00	 jmp	 $LN18@z900_prese
$LN41@z900_prese:

; 6095 :             }
; 6096 : 
; 6097 :             /* See if another CPU can take this interrupt */
; 6098 :             {
; 6099 :                 REGS *regs;
; 6100 :                 CPU_BITMAP mask = sysblk.waiting_mask;

  00110	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00117	48 8b 80 b8 12
	00 00		 mov	 rax, QWORD PTR [rax+4792]
  0011e	48 89 44 24 58	 mov	 QWORD PTR mask$2[rsp], rax

; 6101 :                 CPU_BITMAP wake;
; 6102 :                 int i;
; 6103 : 
; 6104 :                 /* If any CPUs are waiting, isolate to subgroup enabled for
; 6105 :                  * I/O interrupts.
; 6106 :                  */
; 6107 :                 if (mask)

  00123	48 83 7c 24 58
	00		 cmp	 QWORD PTR mask$2[rsp], 0
  00129	0f 84 b5 00 00
	00		 je	 $LN42@z900_prese

; 6108 :                 {
; 6109 :                     wake = mask;

  0012f	48 8b 44 24 58	 mov	 rax, QWORD PTR mask$2[rsp]
  00134	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR wake$3[rsp], rax

; 6110 : 
; 6111 :                     /* Turn off wake mask bits for waiting CPUs that aren't
; 6112 :                      * enabled for I/O interrupts for the device.
; 6113 :                      */
; 6114 :                     for (i=0; mask; mask >>= 1, ++i)

  0013c	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00144	eb 17		 jmp	 SHORT $LN22@z900_prese
$LN20@z900_prese:
  00146	48 8b 44 24 58	 mov	 rax, QWORD PTR mask$2[rsp]
  0014b	48 d1 e8	 shr	 rax, 1
  0014e	48 89 44 24 58	 mov	 QWORD PTR mask$2[rsp], rax
  00153	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00157	ff c0		 inc	 eax
  00159	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN22@z900_prese:
  0015d	48 83 7c 24 58
	00		 cmp	 QWORD PTR mask$2[rsp], 0
  00163	74 6b		 je	 SHORT $LN21@z900_prese

; 6115 :                     {
; 6116 :                         if (mask & 1)

  00165	48 8b 44 24 58	 mov	 rax, QWORD PTR mask$2[rsp]
  0016a	48 83 e0 01	 and	 rax, 1
  0016e	48 85 c0	 test	 rax, rax
  00171	74 58		 je	 SHORT $LN43@z900_prese

; 6117 :                         {
; 6118 :                             regs = sysblk.regs[i];

  00173	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  00178	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0017f	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00187	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR regs$4[rsp], rax

; 6119 : 
; 6120 :                             if (!ARCH_DEP( interrupt_enabled )( regs, io->dev ))

  0018f	48 8b 44 24 48	 mov	 rax, QWORD PTR io$[rsp]
  00194	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00198	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$4[rsp]
  001a0	e8 00 00 00 00	 call	 z900_interrupt_enabled
  001a5	85 c0		 test	 eax, eax
  001a7	75 22		 jne	 SHORT $LN44@z900_prese

; 6121 :                                 wake ^= regs->cpubit;

  001a9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$4[rsp]
  001b1	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  001b5	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR wake$3[rsp]
  001bd	48 33 c8	 xor	 rcx, rax
  001c0	48 8b c1	 mov	 rax, rcx
  001c3	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR wake$3[rsp], rax
$LN44@z900_prese:
$LN43@z900_prese:

; 6122 :                         }
; 6123 :                     }

  001cb	e9 76 ff ff ff	 jmp	 $LN20@z900_prese
$LN21@z900_prese:

; 6124 : 
; 6125 :                     /* Wakeup the LRU waiting CPU enabled for I/O
; 6126 :                      * interrupts.
; 6127 :                      */
; 6128 :                     WAKEUP_CPU_MASK( wake );

  001d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196954
  001d7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR wake$3[rsp]
  001df	e8 00 00 00 00	 call	 wakeup_cpu_mask
$LN42@z900_prese:

; 6129 :                 }
; 6130 :             }
; 6131 : 
; 6132 :         } /* end for(io) */

  001e4	e9 b8 fe ff ff	 jmp	 $LN17@z900_prese
$LN18@z900_prese:

; 6133 : 
; 6134 : #if defined( _FEATURE_IO_ASSIST )
; 6135 :         /* In the case of I/O assist, do a rescan, to see
; 6136 :            if there are any devices with pending subclasses
; 6137 :            for which we are not enabled, if so cause an
; 6138 :            interception.
; 6139 :         */
; 6140 :         if (io == NULL && SIE_MODE( regs ))

  001e9	48 83 7c 24 48
	00		 cmp	 QWORD PTR io$[rsp], 0
  001ef	0f 85 db 00 00
	00		 jne	 $LN45@z900_prese
  001f5	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fd	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00203	d1 e8		 shr	 eax, 1
  00205	83 e0 01	 and	 eax, 1
  00208	85 c0		 test	 eax, eax
  0020a	0f 84 c0 00 00
	00		 je	 $LN45@z900_prese
$LN25@z900_prese:

; 6141 :         {
; 6142 :             /* Find a device with a pending interrupt, regardless
; 6143 :                of the interrupt subclass mask
; 6144 :             */
; 6145 :             ASSERT( dev == NULL );

  00210	48 83 7c 24 38
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00216	74 5c		 je	 SHORT $LN46@z900_prese
$LN28@z900_prese:
  00218	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196957
  0021f	41 b8 01 18 00
	00		 mov	 r8d, 6145		; 00001801H
  00225	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196958
  0022c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196959
  00233	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00239	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0023f	85 c0		 test	 eax, eax
  00241	74 20		 je	 SHORT $LN47@z900_prese
  00243	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196961
  0024a	41 b8 01 18 00
	00		 mov	 r8d, 6145		; 00001801H
  00250	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196962
  00257	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196963
  0025e	e8 00 00 00 00	 call	 DebuggerTrace
$LN47@z900_prese:
  00263	33 c0		 xor	 eax, eax
  00265	85 c0		 test	 eax, eax
  00267	75 af		 jne	 SHORT $LN28@z900_prese
  00269	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0026f	85 c0		 test	 eax, eax
  00271	74 01		 je	 SHORT $LN48@z900_prese
  00273	cc		 int	 3
$LN48@z900_prese:
$LN46@z900_prese:
  00274	33 c0		 xor	 eax, eax
  00276	85 c0		 test	 eax, eax
  00278	75 96		 jne	 SHORT $LN25@z900_prese

; 6146 : 
; 6147 :             for (io = sysblk.iointq; io != NULL; io = io->next)

  0027a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00281	48 8b 80 28 12
	00 00		 mov	 rax, QWORD PTR [rax+4648]
  00288	48 89 44 24 48	 mov	 QWORD PTR io$[rsp], rax
  0028d	eb 0d		 jmp	 SHORT $LN31@z900_prese
$LN29@z900_prese:
  0028f	48 8b 44 24 48	 mov	 rax, QWORD PTR io$[rsp]
  00294	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00297	48 89 44 24 48	 mov	 QWORD PTR io$[rsp], rax
$LN31@z900_prese:
  0029c	48 83 7c 24 48
	00		 cmp	 QWORD PTR io$[rsp], 0
  002a2	74 2c		 je	 SHORT $LN30@z900_prese

; 6148 :             {
; 6149 :                 /* Exit loop if pending interrupts from this device */
; 6150 :                 if (ARCH_DEP( interrupt_enabled )( regs, io->dev ))

  002a4	48 8b 44 24 48	 mov	 rax, QWORD PTR io$[rsp]
  002a9	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  002ad	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b5	e8 00 00 00 00	 call	 z900_interrupt_enabled
  002ba	85 c0		 test	 eax, eax
  002bc	74 10		 je	 SHORT $LN49@z900_prese

; 6151 :                 {
; 6152 :                     dev = io->dev;

  002be	48 8b 44 24 48	 mov	 rax, QWORD PTR io$[rsp]
  002c3	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  002c7	48 89 44 24 38	 mov	 QWORD PTR dev$[rsp], rax

; 6153 :                     break;

  002cc	eb 02		 jmp	 SHORT $LN30@z900_prese
$LN49@z900_prese:

; 6154 :                 }
; 6155 :             } /* end for(io) */

  002ce	eb bf		 jmp	 SHORT $LN29@z900_prese
$LN30@z900_prese:
$LN45@z900_prese:

; 6156 :         }
; 6157 : #endif
; 6158 :         /* If no interrupt pending, or no device, exit with
; 6159 :          * condition code 0
; 6160 :          */
; 6161 :         if (io == NULL || dev == NULL)

  002d0	48 83 7c 24 48
	00		 cmp	 QWORD PTR io$[rsp], 0
  002d6	74 08		 je	 SHORT $LN51@z900_prese
  002d8	48 83 7c 24 38
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002de	75 4b		 jne	 SHORT $LN50@z900_prese
$LN51@z900_prese:

; 6162 :         {
; 6163 :             /* Pass back pointer to device block for device with interrupt */
; 6164 :             *pdev = dev;

  002e0	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR pdev$[rsp]
  002e8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  002ed	48 89 08	 mov	 QWORD PTR [rax], rcx

; 6165 : 
; 6166 :             if (dev != NULL)

  002f0	48 83 7c 24 38
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002f6	74 0a		 je	 SHORT $LN52@z900_prese

; 6167 :                 subchannel_interrupt_queue_cleanup( dev );

  002f8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  002fd	e8 00 00 00 00	 call	 subchannel_interrupt_queue_cleanup
$LN52@z900_prese:

; 6168 : 
; 6169 :             UPDATE_IC_IOPENDING_QLOCKED();

  00302	e8 00 00 00 00	 call	 Update_IC_IOPENDING_QLocked

; 6170 : 
; 6171 :             release_lock( &sysblk.iointqlk );

  00307	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0030e	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  00314	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196969
  0031b	48 8b c8	 mov	 rcx, rax
  0031e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6172 :             return 0;

  00324	33 c0		 xor	 eax, eax
  00326	e9 d6 05 00 00	 jmp	 $LN1@z900_prese
$LN50@z900_prese:

; 6173 :         }
; 6174 :     }
; 6175 :     release_lock( &sysblk.iointqlk );

  0032b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00332	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  00338	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196970
  0033f	48 8b c8	 mov	 rcx, rax
  00342	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6176 : 
; 6177 :     /* Obtain device lock for device with interrupt */
; 6178 :     obtain_lock( &dev->lock );

  00348	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0034d	48 83 c0 38	 add	 rax, 56			; 00000038H
  00351	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196971
  00358	48 8b c8	 mov	 rcx, rax
  0035b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 6179 :     {
; 6180 :         /* Pass back pointer to device block for device with interrupt */
; 6181 :         *pdev = dev;

  00361	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR pdev$[rsp]
  00369	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  0036e	48 89 08	 mov	 QWORD PTR [rax], rcx

; 6182 : 
; 6183 :         /* Verify that the interrupt for this device still exists and that
; 6184 :            TEST SUBCHANNEL has to be issued to clear an existing interrupt.
; 6185 :          */
; 6186 :         obtain_lock( &sysblk.iointqlk );

  00371	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00378	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  0037e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196972
  00385	48 8b c8	 mov	 rcx, rax
  00388	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 6187 :         {
; 6188 :             for (io2 = sysblk.iointq; io2 != NULL && io2 != io; io2 = io2->next);

  0038e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00395	48 8b 80 28 12
	00 00		 mov	 rax, QWORD PTR [rax+4648]
  0039c	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR io2$[rsp], rax
  003a4	eb 13		 jmp	 SHORT $LN34@z900_prese
$LN32@z900_prese:
  003a6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR io2$[rsp]
  003ae	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003b1	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR io2$[rsp], rax
$LN34@z900_prese:
  003b9	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR io2$[rsp], 0
  003c2	74 11		 je	 SHORT $LN33@z900_prese
  003c4	48 8b 44 24 48	 mov	 rax, QWORD PTR io$[rsp]
  003c9	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR io2$[rsp], rax
  003d1	74 02		 je	 SHORT $LN33@z900_prese
  003d3	eb d1		 jmp	 SHORT $LN32@z900_prese
$LN33@z900_prese:

; 6189 : 
; 6190 :             if (io2 == NULL || dev->tschpending)

  003d5	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR io2$[rsp], 0
  003de	74 15		 je	 SHORT $LN54@z900_prese
  003e0	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  003e5	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  003eb	c1 e8 1b	 shr	 eax, 27
  003ee	83 e0 01	 and	 eax, 1
  003f1	85 c0		 test	 eax, eax
  003f3	74 3b		 je	 SHORT $LN53@z900_prese
$LN54@z900_prese:

; 6191 :             {
; 6192 :                 /* Our interrupt was dequeued; retry */
; 6193 :                 release_lock( &sysblk.iointqlk );

  003f5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003fc	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  00402	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196975
  00409	48 8b c8	 mov	 rcx, rax
  0040c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6194 :                 release_lock( &dev->lock );

  00412	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00417	48 83 c0 38	 add	 rax, 56			; 00000038H
  0041b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196976
  00422	48 8b c8	 mov	 rcx, rax
  00425	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6195 :                 goto retry;

  0042b	e9 36 fc ff ff	 jmp	 $retry$88
$LN53@z900_prese:

; 6196 :             }
; 6197 : 
; 6198 :             /* Extract the I/O address and interrupt parameter */
; 6199 :             *ioid = (dev->ssid << 16) | dev->subchan;

  00430	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00435	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00439	c1 e0 10	 shl	 eax, 16
  0043c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  00441	0f b7 49 46	 movzx	 ecx, WORD PTR [rcx+70]
  00445	0b c1		 or	 eax, ecx
  00447	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR ioid$[rsp]
  0044f	89 01		 mov	 DWORD PTR [rcx], eax

; 6200 :             FETCH_FW( *ioparm,dev->pmcw.intparm );

  00451	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00456	48 05 ec 02 00
	00		 add	 rax, 748		; 000002ecH
  0045c	48 8b c8	 mov	 rcx, rax
  0045f	e8 00 00 00 00	 call	 fetch_fw_noswap
  00464	8b c8		 mov	 ecx, eax
  00466	e8 00 00 00 00	 call	 _byteswap_ulong
  0046b	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR ioparm$[rsp]
  00473	89 01		 mov	 DWORD PTR [rcx], eax

; 6201 : 
; 6202 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) || defined( _FEATURE_IO_ASSIST )
; 6203 : #if defined( FEATURE_QDIO_THININT )
; 6204 :             if (unlikely( FACILITY_ENABLED( HERC_QDIO_THININT, regs )

  00475	b8 01 00 00 00	 mov	 eax, 1
  0047a	48 6b c0 21	 imul	 rax, rax, 33		; 00000021H
  0047e	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00486	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  0048e	83 e0 10	 and	 eax, 16
  00491	85 c0		 test	 eax, eax
  00493	74 2d		 je	 SHORT $LN71@z900_prese
  00495	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0049a	0f b6 80 16 03
	00 00		 movzx	 eax, BYTE PTR [rax+790]
  004a1	25 80 00 00 00	 and	 eax, 128		; 00000080H
  004a6	85 c0		 test	 eax, eax
  004a8	74 18		 je	 SHORT $LN71@z900_prese
  004aa	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  004af	83 b8 38 13 00
	00 00		 cmp	 DWORD PTR [rax+4920], 0
  004b6	74 0a		 je	 SHORT $LN71@z900_prese
  004b8	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv235[rsp], 1
  004c0	eb 08		 jmp	 SHORT $LN74@z900_prese
$LN71@z900_prese:
  004c2	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv235[rsp], 0
$LN74@z900_prese:
  004ca	83 7c 24 60 00	 cmp	 DWORD PTR tv235[rsp], 0
  004cf	0f 84 bb 01 00
	00		 je	 $LN55@z900_prese

; 6205 :                 && (dev->pciscsw.flag2 & SCSW2_Q) && dev->qdio.thinint ))
; 6206 :             {
; 6207 :                 saved_dotsch = dotsch;

  004d5	0f b6 44 24 31	 movzx	 eax, BYTE PTR dotsch$[rsp]
  004da	88 44 24 40	 mov	 BYTE PTR saved_dotsch$[rsp], al

; 6208 :                 PCI_dequeued = false;

  004de	c6 44 24 30 00	 mov	 BYTE PTR PCI_dequeued$[rsp], 0

; 6209 : 
; 6210 :                 dotsch = false;  /* Do not require TSCH after INT */

  004e3	c6 44 24 31 00	 mov	 BYTE PTR dotsch$[rsp], 0

; 6211 : 
; 6212 :                 *iointid = 0x80000000

  004e8	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004f0	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  004f6	d1 e8		 shr	 eax, 1
  004f8	83 e0 01	 and	 eax, 1
  004fb	85 c0		 test	 eax, eax
  004fd	74 67		 je	 SHORT $LN77@z900_prese
  004ff	83 7c 24 44 ff	 cmp	 DWORD PTR icode$[rsp], -1
  00504	75 18		 jne	 SHORT $LN75@z900_prese
  00506	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0050b	0f b6 80 05 03
	00 00		 movzx	 eax, BYTE PTR [rax+773]
  00512	83 e0 07	 and	 eax, 7
  00515	c1 e0 1b	 shl	 eax, 27
  00518	89 44 24 64	 mov	 DWORD PTR tv258[rsp], eax
  0051c	eb 3e		 jmp	 SHORT $LN76@z900_prese
$LN75@z900_prese:
  0051e	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00523	0f b6 80 05 03
	00 00		 movzx	 eax, BYTE PTR [rax+773]
  0052a	83 e0 07	 and	 eax, 7
  0052d	c1 e0 1b	 shl	 eax, 27
  00530	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  00535	0f b6 89 04 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+772]
  0053c	c1 e1 10	 shl	 ecx, 16
  0053f	0b c1		 or	 eax, ecx
  00541	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  00546	0f b6 89 07 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+775]
  0054d	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00553	c1 e1 08	 shl	 ecx, 8
  00556	0b c1		 or	 eax, ecx
  00558	89 44 24 64	 mov	 DWORD PTR tv258[rsp], eax
$LN76@z900_prese:
  0055c	8b 44 24 64	 mov	 eax, DWORD PTR tv258[rsp]
  00560	89 44 24 68	 mov	 DWORD PTR tv278[rsp], eax
  00564	eb 55		 jmp	 SHORT $LN78@z900_prese
$LN77@z900_prese:
  00566	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0056b	0f b6 80 f0 02
	00 00		 movzx	 eax, BYTE PTR [rax+752]
  00572	83 e0 38	 and	 eax, 56			; 00000038H
  00575	c1 e0 18	 shl	 eax, 24
  00578	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  0057d	0f b6 89 05 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+773]
  00584	81 e1 e0 00 00
	00		 and	 ecx, 224		; 000000e0H
  0058a	c1 e1 07	 shl	 ecx, 7
  0058d	0b c1		 or	 eax, ecx
  0058f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  00594	0f b6 89 04 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+772]
  0059b	c1 e1 10	 shl	 ecx, 16
  0059e	0b c1		 or	 eax, ecx
  005a0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  005a5	0f b6 89 07 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+775]
  005ac	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  005b2	c1 e1 08	 shl	 ecx, 8
  005b5	0b c1		 or	 eax, ecx
  005b7	89 44 24 68	 mov	 DWORD PTR tv278[rsp], eax
$LN78@z900_prese:
  005bb	8b 44 24 68	 mov	 eax, DWORD PTR tv278[rsp]
  005bf	0f ba e8 1f	 bts	 eax, 31
  005c3	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR iointid$[rsp]
  005cb	89 01		 mov	 DWORD PTR [rcx], eax

; 6213 :                      | (
; 6214 : #if defined( _FEATURE_IO_ASSIST )
; 6215 :                         /* For I/O Assisted devices use (V)ISC */
; 6216 :                         (SIE_MODE(regs)) ?
; 6217 :                           (icode == SIE_NO_INTERCEPT) ?
; 6218 :                             ((dev->pmcw.flag25 & PMCW25_VISC) << 27) :
; 6219 :                             ((dev->pmcw.flag25 & PMCW25_VISC) << 27)
; 6220 :                               | (dev->pmcw.zone << 16)
; 6221 :                               | ((dev->pmcw.flag27 & PMCW27_I) << 8) :
; 6222 : #endif
; 6223 :                         ((dev->pmcw.flag4 & PMCW4_ISC) << 24)
; 6224 :                           | ((dev->pmcw.flag25 & PMCW25_TYPE) << 7)
; 6225 : #if defined( _FEATURE_IO_ASSIST )
; 6226 :                           | (dev->pmcw.zone << 16)
; 6227 :                           | ((dev->pmcw.flag27 & PMCW27_I) << 8)
; 6228 : #endif
; 6229 :                 ); // *iointid =
; 6230 : 
; 6231 :                 if (!SIE_MODE(regs) || icode != SIE_INTERCEPT_IOINTP)

  005cd	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005d5	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  005db	d1 e8		 shr	 eax, 1
  005dd	83 e0 01	 and	 eax, 1
  005e0	85 c0		 test	 eax, eax
  005e2	74 0b		 je	 SHORT $LN58@z900_prese
  005e4	83 7c 24 44 f0	 cmp	 DWORD PTR icode$[rsp], -16
  005e9	0f 84 9c 00 00
	00		 je	 $LN56@z900_prese
$LN58@z900_prese:

; 6232 :                 {
; 6233 :                     /* Dequeue the interrupt */
; 6234 :                     PCI_dequeued = DEQUEUE_IO_INTERRUPT_QLOCKED( &dev->pciioint ) == 0 ? true : false;

  005ef	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  005f4	48 05 40 02 00
	00		 add	 rax, 576		; 00000240H
  005fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196981
  00601	48 8b c8	 mov	 rcx, rax
  00604	e8 00 00 00 00	 call	 Dequeue_IO_Interrupt_QLocked
  00609	85 c0		 test	 eax, eax
  0060b	75 0a		 jne	 SHORT $LN79@z900_prese
  0060d	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv290[rsp], 1
  00615	eb 08		 jmp	 SHORT $LN80@z900_prese
$LN79@z900_prese:
  00617	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv290[rsp], 0
$LN80@z900_prese:
  0061f	83 7c 24 6c 00	 cmp	 DWORD PTR tv290[rsp], 0
  00624	75 0a		 jne	 SHORT $LN81@z900_prese
  00626	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv292[rsp], 0
  0062e	eb 08		 jmp	 SHORT $LN82@z900_prese
$LN81@z900_prese:
  00630	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv292[rsp], 1
$LN82@z900_prese:
  00638	0f b6 44 24 70	 movzx	 eax, BYTE PTR tv292[rsp]
  0063d	88 44 24 30	 mov	 BYTE PTR PCI_dequeued$[rsp], al

; 6235 : 
; 6236 :                     if (!PCI_dequeued)

  00641	0f b6 44 24 30	 movzx	 eax, BYTE PTR PCI_dequeued$[rsp]
  00646	85 c0		 test	 eax, eax
  00648	75 0b		 jne	 SHORT $LN59@z900_prese

; 6237 :                         dotsch = saved_dotsch; // (restore)

  0064a	0f b6 44 24 40	 movzx	 eax, BYTE PTR saved_dotsch$[rsp]
  0064f	88 44 24 31	 mov	 BYTE PTR dotsch$[rsp], al
  00653	eb 34		 jmp	 SHORT $LN60@z900_prese
$LN59@z900_prese:

; 6238 :                     else
; 6239 :                     {
; 6240 :                         /* Clear the pending PCI status */
; 6241 :                         dev->pciscsw.flag2 &= ~(SCSW2_FC | SCSW2_AC);

  00655	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0065a	0f b6 80 16 03
	00 00		 movzx	 eax, BYTE PTR [rax+790]
  00661	83 e0 80	 and	 eax, -128		; ffffffffffffff80H
  00664	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  00669	88 81 16 03 00
	00		 mov	 BYTE PTR [rcx+790], al

; 6242 :                         dev->pciscsw.flag3 &= ~(SCSW3_SC);

  0066f	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00674	0f b6 80 17 03
	00 00		 movzx	 eax, BYTE PTR [rax+791]
  0067b	83 e0 e0	 and	 eax, -32		; ffffffffffffffe0H
  0067e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  00683	88 81 17 03 00
	00		 mov	 BYTE PTR [rcx+791], al
$LN60@z900_prese:

; 6243 :                     }
; 6244 :                 }

  00689	eb 05		 jmp	 SHORT $LN57@z900_prese
$LN56@z900_prese:

; 6245 :                 else
; 6246 :                     PCI_dequeued = true; // (keep same logic as before!)

  0068b	c6 44 24 30 01	 mov	 BYTE PTR PCI_dequeued$[rsp], 1
$LN57@z900_prese:
$LN55@z900_prese:

; 6247 :             }
; 6248 : 
; 6249 :             /* If no PCI interrupt dequeued, then dequeue a normal interrupt */
; 6250 :             if (!PCI_dequeued)

  00690	0f b6 44 24 30	 movzx	 eax, BYTE PTR PCI_dequeued$[rsp]
  00695	85 c0		 test	 eax, eax
  00697	0f 85 e1 00 00
	00		 jne	 $LN61@z900_prese

; 6251 : #endif /*defined( FEATURE_QDIO_THININT )*/
; 6252 : 
; 6253 :                 *iointid = (

  0069d	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006a5	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  006ab	d1 e8		 shr	 eax, 1
  006ad	83 e0 01	 and	 eax, 1
  006b0	85 c0		 test	 eax, eax
  006b2	74 67		 je	 SHORT $LN85@z900_prese
  006b4	83 7c 24 44 ff	 cmp	 DWORD PTR icode$[rsp], -1
  006b9	75 18		 jne	 SHORT $LN83@z900_prese
  006bb	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  006c0	0f b6 80 05 03
	00 00		 movzx	 eax, BYTE PTR [rax+773]
  006c7	83 e0 07	 and	 eax, 7
  006ca	c1 e0 1b	 shl	 eax, 27
  006cd	89 44 24 74	 mov	 DWORD PTR tv329[rsp], eax
  006d1	eb 3e		 jmp	 SHORT $LN84@z900_prese
$LN83@z900_prese:
  006d3	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  006d8	0f b6 80 05 03
	00 00		 movzx	 eax, BYTE PTR [rax+773]
  006df	83 e0 07	 and	 eax, 7
  006e2	c1 e0 1b	 shl	 eax, 27
  006e5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  006ea	0f b6 89 04 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+772]
  006f1	c1 e1 10	 shl	 ecx, 16
  006f4	0b c1		 or	 eax, ecx
  006f6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  006fb	0f b6 89 07 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+775]
  00702	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00708	c1 e1 08	 shl	 ecx, 8
  0070b	0b c1		 or	 eax, ecx
  0070d	89 44 24 74	 mov	 DWORD PTR tv329[rsp], eax
$LN84@z900_prese:
  00711	8b 44 24 74	 mov	 eax, DWORD PTR tv329[rsp]
  00715	89 44 24 78	 mov	 DWORD PTR tv349[rsp], eax
  00719	eb 55		 jmp	 SHORT $LN86@z900_prese
$LN85@z900_prese:
  0071b	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00720	0f b6 80 f0 02
	00 00		 movzx	 eax, BYTE PTR [rax+752]
  00727	83 e0 38	 and	 eax, 56			; 00000038H
  0072a	c1 e0 18	 shl	 eax, 24
  0072d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  00732	0f b6 89 05 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+773]
  00739	81 e1 e0 00 00
	00		 and	 ecx, 224		; 000000e0H
  0073f	c1 e1 07	 shl	 ecx, 7
  00742	0b c1		 or	 eax, ecx
  00744	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  00749	0f b6 89 04 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+772]
  00750	c1 e1 10	 shl	 ecx, 16
  00753	0b c1		 or	 eax, ecx
  00755	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  0075a	0f b6 89 07 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+775]
  00761	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00767	c1 e1 08	 shl	 ecx, 8
  0076a	0b c1		 or	 eax, ecx
  0076c	89 44 24 78	 mov	 DWORD PTR tv349[rsp], eax
$LN86@z900_prese:
  00770	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR iointid$[rsp]
  00778	8b 4c 24 78	 mov	 ecx, DWORD PTR tv349[rsp]
  0077c	89 08		 mov	 DWORD PTR [rax], ecx
$LN61@z900_prese:

; 6254 : #if defined(_FEATURE_IO_ASSIST)
; 6255 :                             /* For I/O Assisted devices use (V)ISC */
; 6256 :                             (SIE_MODE(regs)) ?
; 6257 :                               (icode == SIE_NO_INTERCEPT) ?
; 6258 :                                 ((dev->pmcw.flag25 & PMCW25_VISC) << 27) :
; 6259 :                                 ((dev->pmcw.flag25 & PMCW25_VISC) << 27)
; 6260 :                                   | (dev->pmcw.zone << 16)
; 6261 :                                   | ((dev->pmcw.flag27 & PMCW27_I) << 8) :
; 6262 : #endif
; 6263 :                              ((dev->pmcw.flag4 & PMCW4_ISC) << 24)
; 6264 :                                | ((dev->pmcw.flag25 & PMCW25_TYPE) << 7)
; 6265 : #if defined(_FEATURE_IO_ASSIST)
; 6266 :                                | (dev->pmcw.zone << 16)
; 6267 :                                | ((dev->pmcw.flag27 & PMCW27_I) << 8)
; 6268 : #endif
; 6269 :                 ); // *iointid =
; 6270 : #endif /*defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) || defined( _FEATURE_IO_ASSIST ) */
; 6271 : 
; 6272 : #if defined( _FEATURE_IO_ASSIST )
; 6273 :             /* Do not drain pending interrupts
; 6274 :                on intercept due to zero ISC mask
; 6275 :              */
; 6276 :             if(!SIE_MODE(regs) || icode != SIE_INTERCEPT_IOINTP)

  0077e	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00786	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0078c	d1 e8		 shr	 eax, 1
  0078e	83 e0 01	 and	 eax, 1
  00791	85 c0		 test	 eax, eax
  00793	74 07		 je	 SHORT $LN63@z900_prese
  00795	83 7c 24 44 f0	 cmp	 DWORD PTR icode$[rsp], -16
  0079a	74 4a		 je	 SHORT $LN62@z900_prese
$LN63@z900_prese:

; 6277 : #endif
; 6278 :             {
; 6279 :                 if (!SIE_MODE(regs) || icode != SIE_NO_INTERCEPT)

  0079c	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007a4	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  007aa	d1 e8		 shr	 eax, 1
  007ac	83 e0 01	 and	 eax, 1
  007af	85 c0		 test	 eax, eax
  007b1	74 07		 je	 SHORT $LN65@z900_prese
  007b3	83 7c 24 44 ff	 cmp	 DWORD PTR icode$[rsp], -1
  007b8	74 1b		 je	 SHORT $LN64@z900_prese
$LN65@z900_prese:

; 6280 :                     dev->pmcw.flag27 &= ~PMCW27_I;

  007ba	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  007bf	0f b6 80 07 03
	00 00		 movzx	 eax, BYTE PTR [rax+775]
  007c6	0f ba f0 07	 btr	 eax, 7
  007ca	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  007cf	88 81 07 03 00
	00		 mov	 BYTE PTR [rcx+775], al
$LN64@z900_prese:

; 6281 : 
; 6282 :                 /* Dequeue the interrupt */
; 6283 :                 DEQUEUE_IO_INTERRUPT_QLOCKED( io );

  007d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196989
  007dc	48 8b 4c 24 48	 mov	 rcx, QWORD PTR io$[rsp]
  007e1	e8 00 00 00 00	 call	 Dequeue_IO_Interrupt_QLocked
$LN62@z900_prese:

; 6284 :             }
; 6285 : 
; 6286 :             /* TEST SUBCHANNEL is now required to clear the interrupt */
; 6287 :             dev->tschpending = dotsch;

  007e6	0f b6 44 24 31	 movzx	 eax, BYTE PTR dotsch$[rsp]
  007eb	83 e0 01	 and	 eax, 1
  007ee	c1 e0 1b	 shl	 eax, 27
  007f1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  007f6	8b 89 f8 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1528]
  007fc	0f ba f1 1b	 btr	 ecx, 27
  00800	0b c8		 or	 ecx, eax
  00802	8b c1		 mov	 eax, ecx
  00804	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  00809	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 6288 : 
; 6289 :             /* Perform additional architecture post processing and cleanup */
; 6290 :             switch (sysblk.arch_mode)

  0080f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00816	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0081c	89 44 24 54	 mov	 DWORD PTR tv375[rsp], eax
  00820	83 7c 24 54 00	 cmp	 DWORD PTR tv375[rsp], 0
  00825	74 10		 je	 SHORT $LN66@z900_prese
  00827	83 7c 24 54 01	 cmp	 DWORD PTR tv375[rsp], 1
  0082c	74 69		 je	 SHORT $LN67@z900_prese
  0082e	83 7c 24 54 02	 cmp	 DWORD PTR tv375[rsp], 2
  00833	74 64		 je	 SHORT $LN68@z900_prese
  00835	eb 64		 jmp	 SHORT $LN69@z900_prese
$LN66@z900_prese:

; 6291 :             {
; 6292 :                 case ARCH_370_IDX:
; 6293 :                 {
; 6294 :                     IOINT*  ioint;              /* -> I/O interrupt          */
; 6295 :                     IRB     irb;                /* -> IRB                    */
; 6296 :                     SCSW*   scsw;               /* -> SCSW                   */
; 6297 :                     int     cc;                 /* Condition code ignored    */
; 6298 : 
; 6299 :                     /* Extract the I/O address and CSW */
; 6300 :                     *ioid = dev->devnum;

  00837	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0083c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00840	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR ioid$[rsp]
  00848	89 01		 mov	 DWORD PTR [rcx], eax

; 6301 : 
; 6302 :                     /* Perform core of TEST SUBCHANNEL work and store CSW */
; 6303 :                     cc = test_subchan_locked( regs, dev, &irb, &ioint, &scsw );

  0084a	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR scsw$6[rsp]
  00852	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00857	4c 8d 8c 24 b0
	00 00 00	 lea	 r9, QWORD PTR ioint$8[rsp]
  0085f	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR irb$9[rsp]
  00867	48 8b 54 24 38	 mov	 rdx, QWORD PTR dev$[rsp]
  0086c	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00874	e8 00 00 00 00	 call	 test_subchan_locked
  00879	89 84 24 98 00
	00 00		 mov	 DWORD PTR cc$5[rsp], eax

; 6304 :                     store_scsw_as_csw( regs, scsw );

  00880	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR scsw$6[rsp]
  00888	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00890	e8 00 00 00 00	 call	 store_scsw_as_csw

; 6305 :                     break;

  00895	eb 21		 jmp	 SHORT $LN35@z900_prese
$LN67@z900_prese:

; 6306 :                 }
; 6307 : 
; 6308 :                 case ARCH_390_IDX: break;

  00897	eb 1f		 jmp	 SHORT $LN35@z900_prese
$LN68@z900_prese:

; 6309 :                 case ARCH_900_IDX: break;

  00899	eb 1d		 jmp	 SHORT $LN35@z900_prese
$LN69@z900_prese:
$LN39@z900_prese:

; 6310 :                 default: CRASH();

  0089b	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR p$7[rsp], 0
  008a7	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR p$7[rsp]
  008af	c6 00 00	 mov	 BYTE PTR [rax], 0
  008b2	33 c0		 xor	 eax, eax
  008b4	85 c0		 test	 eax, eax
  008b6	75 e3		 jne	 SHORT $LN39@z900_prese
$LN35@z900_prese:

; 6311 :             }
; 6312 : 
; 6313 :             subchannel_interrupt_queue_cleanup( dev );

  008b8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  008bd	e8 00 00 00 00	 call	 subchannel_interrupt_queue_cleanup

; 6314 :             UPDATE_IC_IOPENDING_QLOCKED();

  008c2	e8 00 00 00 00	 call	 Update_IC_IOPENDING_QLocked

; 6315 :         }
; 6316 :         release_lock( &sysblk.iointqlk );

  008c7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  008ce	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  008d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196994
  008db	48 8b c8	 mov	 rcx, rax
  008de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6317 : 
; 6318 : #if DEBUG_SCSW
; 6319 :         if (unlikely(dev->ccwtrace))
; 6320 :         {
; 6321 :             SCSW* scsw;   /* (selected SCSW) */
; 6322 : 
; 6323 :                  if (dev->pciscsw.flag3  & SCSW3_SC_PEND) scsw = &dev->pciscsw;
; 6324 :             else if (dev->scsw.flag3     & SCSW3_SC_PEND) scsw = &dev->scsw;
; 6325 :          /* else if (dev->attnscsw.flag3 & SCSW3_SC_PEND) scsw = &dev->attnscsw; */
; 6326 :             else scsw = NULL;
; 6327 : 
; 6328 :             /* Check interrupt validity */
; 6329 :             if (1
; 6330 :                 && scsw != NULL
; 6331 :                 && !(scsw->flag2 & (SCSW2_FC | SCSW2_AC))
; 6332 :                 && !(scsw->flag3 & SCSW3_AC)
; 6333 :             )
; 6334 :             {
; 6335 :                 WRMSG( HHC01393, "E", "  CHAN: Invalid SCSW presentation" );
; 6336 :                 DISPLAY_SCSW( dev, *scsw );
; 6337 :             }
; 6338 :         }
; 6339 : #endif /*DEBUG_SCSW*/
; 6340 :     }
; 6341 :     release_lock( &dev->lock );

  008e4	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  008e9	48 83 c0 38	 add	 rax, 56			; 00000038H
  008ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196995
  008f4	48 8b c8	 mov	 rcx, rax
  008f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6342 : 
; 6343 :     /* Exit with condition code indicating queued interrupt cleared */
; 6344 :     return icode;

  008fd	8b 44 24 44	 mov	 eax, DWORD PTR icode$[rsp]
$LN1@z900_prese:

; 6345 : 
; 6346 : } /* end function present_io_interrupt */

  00901	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00909	48 33 cc	 xor	 rcx, rsp
  0090c	e8 00 00 00 00	 call	 __security_check_cookie
  00911	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00918	c3		 ret	 0
z900_present_io_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv156 = 96
tv182 = 100
tv338 = 104
tv344 = 108
tv196 = 112
tv200 = 116
tv203 = 120
tv207 = 124
rc$ = 128
tv375 = 136
msgbuf$1 = 144
__$ArrayPad$ = 272
regs$ = 320
dev$ = 328
orb$ = 336
z900_startio PROC

; 4199 : {

$LN31:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4200 : int     rc;                             /* Return code               */
; 4201 : 
; 4202 :     obtain_lock (&dev->lock);

  0002a	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00032	48 83 c0 38	 add	 rax, 56			; 00000038H
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196410
  0003d	48 8b c8	 mov	 rcx, rax
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4203 : 
; 4204 : #if defined(_FEATURE_IO_ASSIST)
; 4205 :     if(SIE_MODE(regs)
; 4206 :       && (regs->siebk->zone != dev->pmcw.zone

  00046	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00054	d1 e8		 shr	 eax, 1
  00056	83 e0 01	 and	 eax, 1
  00059	85 c0		 test	 eax, eax
  0005b	74 75		 je	 SHORT $LN2@z900_start
  0005d	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0006c	0f b6 40 74	 movzx	 eax, BYTE PTR [rax+116]
  00070	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00078	0f b6 89 04 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+772]
  0007f	3b c1		 cmp	 eax, ecx
  00081	75 18		 jne	 SHORT $LN3@z900_start
  00083	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0008b	0f b6 80 07 03
	00 00		 movzx	 eax, BYTE PTR [rax+775]
  00092	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00097	85 c0		 test	 eax, eax
  00099	75 37		 jne	 SHORT $LN2@z900_start
$LN3@z900_start:

; 4207 :         || !(dev->pmcw.flag27 & PMCW27_I)))
; 4208 :     {
; 4209 :         release_lock (&dev->lock);

  0009b	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a3	48 83 c0 38	 add	 rax, 56			; 00000038H
  000a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196413
  000ae	48 8b c8	 mov	 rcx, rax
  000b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4210 :         longjmp(regs->progjmp,SIE_INTERCEPT_INST);

  000b7	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bf	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000c5	ba fc ff ff ff	 mov	 edx, -4
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 longjmp
$LN2@z900_start:

; 4211 :     }
; 4212 : #endif
; 4213 : 
; 4214 :     /* Return condition code 1 if status pending */
; 4215 :     if (unlikely((dev->scsw.flag3     & SCSW3_SC_PEND)  ||

  000d2	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000da	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  000e1	83 e0 01	 and	 eax, 1
  000e4	85 c0		 test	 eax, eax
  000e6	75 4e		 jne	 SHORT $LN15@z900_start
  000e8	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000f0	0f b6 80 17 03
	00 00		 movzx	 eax, BYTE PTR [rax+791]
  000f7	83 e0 01	 and	 eax, 1
  000fa	85 c0		 test	 eax, eax
  000fc	75 38		 jne	 SHORT $LN15@z900_start
  000fe	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00106	0f b6 80 23 03
	00 00		 movzx	 eax, BYTE PTR [rax+803]
  0010d	83 e0 01	 and	 eax, 1
  00110	85 c0		 test	 eax, eax
  00112	75 22		 jne	 SHORT $LN15@z900_start
  00114	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0011c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00122	c1 e8 1b	 shr	 eax, 27
  00125	83 e0 01	 and	 eax, 1
  00128	85 c0		 test	 eax, eax
  0012a	75 0a		 jne	 SHORT $LN15@z900_start
  0012c	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv156[rsp], 0
  00134	eb 08		 jmp	 SHORT $LN18@z900_start
$LN15@z900_start:
  00136	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv156[rsp], 1
$LN18@z900_start:
  0013e	83 7c 24 60 00	 cmp	 DWORD PTR tv156[rsp], 0
  00143	74 26		 je	 SHORT $LN4@z900_start

; 4216 :                  (dev->pciscsw.flag3  & SCSW3_SC_PEND)  ||
; 4217 :                  (dev->attnscsw.flag3 & SCSW3_SC_PEND)  ||
; 4218 :                  dev->tschpending))
; 4219 :     {
; 4220 :         release_lock (&dev->lock);

  00145	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0014d	48 83 c0 38	 add	 rax, 56			; 00000038H
  00151	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196415
  00158	48 8b c8	 mov	 rcx, rax
  0015b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4221 :         return 1;

  00161	b8 01 00 00 00	 mov	 eax, 1
  00166	e9 06 06 00 00	 jmp	 $LN1@z900_start
$LN4@z900_start:

; 4222 :     }
; 4223 : 
; 4224 :     /* Return condition code 2 if device is busy */
; 4225 : #if defined( OPTION_SHARED_DEVICES )
; 4226 :     if (unlikely((dev->busy && dev->shioactive == DEV_SYS_LOCAL)

  0016b	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00173	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00179	c1 e8 13	 shr	 eax, 19
  0017c	83 e0 01	 and	 eax, 1
  0017f	85 c0		 test	 eax, eax
  00181	74 14		 je	 SHORT $LN19@z900_start
  00183	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0018b	81 b8 e4 05 00
	00 ff ff 00 00	 cmp	 DWORD PTR [rax+1508], 65535 ; 0000ffffH
  00195	74 22		 je	 SHORT $LN20@z900_start
$LN19@z900_start:
  00197	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0019f	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001a5	c1 e8 19	 shr	 eax, 25
  001a8	83 e0 01	 and	 eax, 1
  001ab	85 c0		 test	 eax, eax
  001ad	75 0a		 jne	 SHORT $LN20@z900_start
  001af	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv182[rsp], 0
  001b7	eb 08		 jmp	 SHORT $LN24@z900_start
$LN20@z900_start:
  001b9	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv182[rsp], 1
$LN24@z900_start:
  001c1	83 7c 24 64 00	 cmp	 DWORD PTR tv182[rsp], 0
  001c6	0f 84 22 01 00
	00		 je	 $LN5@z900_start

; 4227 :         || dev->startpending))
; 4228 : #else // !defined( OPTION_SHARED_DEVICES )
; 4229 :     if (unlikely((dev->busy)
; 4230 :         || dev->startpending))
; 4231 : #endif // defined( OPTION_SHARED_DEVICES )
; 4232 :     {
; 4233 :         release_lock (&dev->lock);

  001cc	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001d4	48 83 c0 38	 add	 rax, 56			; 00000038H
  001d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196417
  001df	48 8b c8	 mov	 rcx, rax
  001e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4234 : 
; 4235 :         /*************************************************************/
; 4236 :         /* VM system abends IQM00 were found to be caused by startio */
; 4237 :         /* SSCH resulting in cc=2 thanks to this additional log msg. */
; 4238 :         /*                        Peter J. Jansen, 21-Jun-2016       */
; 4239 :         /*************************************************************/
; 4240 :         if (dev->ccwtrace)

  001e8	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001f0	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001f6	c1 e8 0f	 shr	 eax, 15
  001f9	83 e0 01	 and	 eax, 1
  001fc	85 c0		 test	 eax, eax
  001fe	0f 84 e0 00 00
	00		 je	 $LN6@z900_start

; 4241 :         {
; 4242 :             if (sysblk.traceFILE)

  00204	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0020b	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00213	74 13		 je	 SHORT $LN7@z900_start

; 4243 :                 tf_1336( dev );

  00215	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0021d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1336
  00223	e9 bc 00 00 00	 jmp	 $LN8@z900_start
$LN7@z900_start:

; 4244 :             else
; 4245 :                 // "%1d:%04X CHAN: startio cc=2 (busy=%d startpending=%d)"
; 4246 :                 WRMSG( HHC01336, "I", SSID_TO_LCSS(dev->ssid),

  00228	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00230	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00236	c1 e8 19	 shr	 eax, 25
  00239	83 e0 01	 and	 eax, 1
  0023c	89 44 24 70	 mov	 DWORD PTR tv196[rsp], eax
  00240	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00248	8b 89 f8 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1528]
  0024e	c1 e9 13	 shr	 ecx, 19
  00251	83 e1 01	 and	 ecx, 1
  00254	89 4c 24 74	 mov	 DWORD PTR tv200[rsp], ecx
  00258	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00260	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00264	89 54 24 78	 mov	 DWORD PTR tv203[rsp], edx
  00268	4c 8b 84 24 48
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00270	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  00275	41 d1 f8	 sar	 r8d, 1
  00278	44 89 44 24 7c	 mov	 DWORD PTR tv207[rsp], r8d
  0027d	b9 01 00 00 00	 mov	 ecx, 1
  00282	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00288	8b 4c 24 70	 mov	 ecx, DWORD PTR tv196[rsp]
  0028c	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00290	8b 4c 24 74	 mov	 ecx, DWORD PTR tv200[rsp]
  00294	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00298	8b 4c 24 78	 mov	 ecx, DWORD PTR tv203[rsp]
  0029c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002a0	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv207[rsp]
  002a4	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196421
  002af	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196422
  002bb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002c0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c5	41 b9 03 00 00
	00		 mov	 r9d, 3
  002cb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196423
  002d2	ba 97 10 00 00	 mov	 edx, 4247		; 00001097H
  002d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196424
  002de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN8@z900_start:
$LN6@z900_start:

; 4247 :                        dev->devnum, dev->busy, dev->startpending );
; 4248 :         }
; 4249 : 
; 4250 :         return 2;

  002e4	b8 02 00 00 00	 mov	 eax, 2
  002e9	e9 83 04 00 00	 jmp	 $LN1@z900_start
$LN5@z900_start:

; 4251 :     }
; 4252 : 
; 4253 :     /* Ensure clean status flag bits */
; 4254 :     dev->suspended          = 0;

  002ee	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002f6	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  002fc	0f ba f0 15	 btr	 eax, 21
  00300	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00308	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4255 :     dev->pending            = 0;

  0030e	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00316	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0031c	0f ba f0 16	 btr	 eax, 22
  00320	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00328	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4256 :     dev->pcipending         = 0;

  0032e	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00336	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0033c	0f ba f0 17	 btr	 eax, 23
  00340	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00348	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4257 :     dev->attnpending        = 0;

  0034e	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00356	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0035c	0f ba f0 18	 btr	 eax, 24
  00360	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00368	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4258 :     dev->startpending       = 0;

  0036e	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00376	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0037c	0f ba f0 19	 btr	 eax, 25
  00380	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00388	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4259 :     dev->resumesuspended    = 0;

  0038e	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00396	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0039c	0f ba f0 1a	 btr	 eax, 26
  003a0	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003a8	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4260 :     dev->tschpending        = 0;

  003ae	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003b6	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  003bc	0f ba f0 1b	 btr	 eax, 27
  003c0	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003c8	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4261 : 
; 4262 :     /* Initialize the subchannel status word */
; 4263 :     memset (&dev->scsw,     0, sizeof(SCSW));

  003ce	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003d6	48 05 08 03 00
	00		 add	 rax, 776		; 00000308H
  003dc	48 8b f8	 mov	 rdi, rax
  003df	33 c0		 xor	 eax, eax
  003e1	b9 0c 00 00 00	 mov	 ecx, 12
  003e6	f3 aa		 rep stosb

; 4264 :     dev->scsw.flag0 = (orb->flag4 & (SCSW0_KEY |

  003e8	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR orb$[rsp]
  003f0	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  003f4	25 f8 00 00 00	 and	 eax, 248		; 000000f8H
  003f9	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00401	88 81 08 03 00
	00		 mov	 BYTE PTR [rcx+776], al

; 4265 :                                      SCSW0_S));
; 4266 :     dev->scsw.flag1 = (orb->flag5 & (SCSW1_F   |

  00407	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR orb$[rsp]
  0040f	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00413	25 f8 00 00 00	 and	 eax, 248		; 000000f8H
  00418	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00420	88 81 09 03 00
	00		 mov	 BYTE PTR [rcx+777], al

; 4267 :                                      SCSW1_P   |
; 4268 :                                      SCSW1_I   |
; 4269 :                                      SCSW1_A   |
; 4270 :                                      SCSW1_U));
; 4271 : 
; 4272 :     /* Set the device busy indicator */
; 4273 :     set_subchannel_busy(dev);

  00426	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0042e	e8 00 00 00 00	 call	 set_subchannel_busy

; 4274 : 
; 4275 :     /* Initialize shadow SCSWs */
; 4276 :     memcpy(&dev->pciscsw,  &dev->scsw, sizeof(SCSW));

  00433	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0043b	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00443	48 8d b8 14 03
	00 00		 lea	 rdi, QWORD PTR [rax+788]
  0044a	48 8d b1 08 03
	00 00		 lea	 rsi, QWORD PTR [rcx+776]
  00451	b9 0c 00 00 00	 mov	 ecx, 12
  00456	f3 a4		 rep movsb

; 4277 :     memcpy(&dev->attnscsw, &dev->scsw, sizeof(SCSW));

  00458	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00460	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00468	48 8d b8 20 03
	00 00		 lea	 rdi, QWORD PTR [rax+800]
  0046f	48 8d b1 08 03
	00 00		 lea	 rsi, QWORD PTR [rcx+776]
  00476	b9 0c 00 00 00	 mov	 ecx, 12
  0047b	f3 a4		 rep movsb

; 4278 : 
; 4279 :     /* Make the subchannel start-pending */
; 4280 :     dev->scsw.flag2 |= SCSW2_FC_START | SCSW2_AC_START;

  0047d	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00485	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  0048c	83 c8 44	 or	 eax, 68			; 00000044H
  0048f	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00497	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 4281 :     dev->startpending = 1;

  0049d	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004a5	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  004ab	0f ba e8 19	 bts	 eax, 25
  004af	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004b7	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4282 : 
; 4283 :     /* Copy the I/O parameter to the path management control word */
; 4284 :     memcpy (dev->pmcw.intparm, orb->intparm,

  004bd	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004c5	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR orb$[rsp]
  004cd	8b 09		 mov	 ecx, DWORD PTR [rcx]
  004cf	89 88 ec 02 00
	00		 mov	 DWORD PTR [rax+748], ecx

; 4285 :                         sizeof(dev->pmcw.intparm));
; 4286 : 
; 4287 :     /* Store the start I/O parameters in the device block */
; 4288 :     if (orb->flag7 & ORB7_X)

  004d5	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR orb$[rsp]
  004dd	0f b6 40 07	 movzx	 eax, BYTE PTR [rax+7]
  004e1	83 e0 01	 and	 eax, 1
  004e4	85 c0		 test	 eax, eax
  004e6	74 20		 je	 SHORT $LN9@z900_start

; 4289 :     {
; 4290 :         /* Extended ORB */
; 4291 :         memcpy(&dev->orb, orb, sizeof(ORB));

  004e8	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004f0	48 8d b8 cc 02
	00 00		 lea	 rdi, QWORD PTR [rax+716]
  004f7	48 8b b4 24 50
	01 00 00	 mov	 rsi, QWORD PTR orb$[rsp]
  004ff	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00504	f3 a4		 rep movsb

; 4292 :     }

  00506	eb 38		 jmp	 SHORT $LN10@z900_start
$LN9@z900_start:

; 4293 :     else
; 4294 :     {
; 4295 :         /* Original ORB size */
; 4296 :         memcpy(&dev->orb, orb, 12);

  00508	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00510	48 8d b8 cc 02
	00 00		 lea	 rdi, QWORD PTR [rax+716]
  00517	48 8b b4 24 50
	01 00 00	 mov	 rsi, QWORD PTR orb$[rsp]
  0051f	b9 0c 00 00 00	 mov	 ecx, 12
  00524	f3 a4		 rep movsb

; 4297 :         memset(&dev->orb.csspriority, 0, sizeof(ORB) - 12);

  00526	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0052e	48 05 d8 02 00
	00		 add	 rax, 728		; 000002d8H
  00534	48 8b f8	 mov	 rdi, rax
  00537	33 c0		 xor	 eax, eax
  00539	b9 14 00 00 00	 mov	 ecx, 20
  0053e	f3 aa		 rep stosb
$LN10@z900_start:

; 4298 :     }
; 4299 : 
; 4300 :     if (dev->orbtrace)

  00540	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00548	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0054e	c1 e8 0e	 shr	 eax, 14
  00551	83 e0 01	 and	 eax, 1
  00554	85 c0		 test	 eax, eax
  00556	0f 84 24 01 00
	00		 je	 $LN11@z900_start

; 4301 :     {
; 4302 :         if (dev->ccwtrace && sysblk.traceFILE)

  0055c	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00564	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0056a	c1 e8 0f	 shr	 eax, 15
  0056d	83 e0 01	 and	 eax, 1
  00570	85 c0		 test	 eax, eax
  00572	74 2c		 je	 SHORT $LN12@z900_start
  00574	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0057b	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00583	74 1b		 je	 SHORT $LN12@z900_start

; 4303 :             tf_1334( dev, orb );

  00585	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR orb$[rsp]
  0058d	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00595	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1334
  0059b	e9 e0 00 00 00	 jmp	 $LN13@z900_start
$LN12@z900_start:

; 4304 :         else
; 4305 :         {
; 4306 :             char msgbuf[128] = {0};

  005a0	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR msgbuf$1[rsp]
  005a8	48 8b f8	 mov	 rdi, rax
  005ab	33 c0		 xor	 eax, eax
  005ad	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  005b2	f3 aa		 rep stosb

; 4307 :             FormatORB( orb, msgbuf, sizeof( msgbuf ));

  005b4	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  005ba	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR msgbuf$1[rsp]
  005c2	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR orb$[rsp]
  005ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FormatORB

; 4308 :             // "%1d:%04X CHAN: ORB: %s"
; 4309 :             WRMSG( HHC01334, "I", LCSS_DEVNUM, msgbuf );

  005d0	48 83 bc 24 48
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  005d9	74 12		 je	 SHORT $LN25@z900_start
  005db	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005e3	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  005e7	89 44 24 68	 mov	 DWORD PTR tv338[rsp], eax
  005eb	eb 08		 jmp	 SHORT $LN26@z900_start
$LN25@z900_start:
  005ed	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv338[rsp], 0
$LN26@z900_start:
  005f5	48 83 bc 24 48
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  005fe	74 14		 je	 SHORT $LN27@z900_start
  00600	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00608	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0060c	d1 f8		 sar	 eax, 1
  0060e	89 44 24 6c	 mov	 DWORD PTR tv344[rsp], eax
  00612	eb 08		 jmp	 SHORT $LN28@z900_start
$LN27@z900_start:
  00614	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv344[rsp], 0
$LN28@z900_start:
  0061c	b9 01 00 00 00	 mov	 ecx, 1
  00621	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00627	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR msgbuf$1[rsp]
  0062f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00634	8b 4c 24 68	 mov	 ecx, DWORD PTR tv338[rsp]
  00638	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0063c	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv344[rsp]
  00640	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00644	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196430
  0064b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00650	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196431
  00657	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0065c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00661	41 b9 03 00 00
	00		 mov	 r9d, 3
  00667	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196432
  0066e	ba d5 10 00 00	 mov	 edx, 4309		; 000010d5H
  00673	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196433
  0067a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN13@z900_start:
$LN11@z900_start:

; 4310 :         }
; 4311 :     }
; 4312 : 
; 4313 :     /* Set I/O priority */
; 4314 :     dev->priority &= 0x00FF0000ULL;

  00680	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00688	48 63 80 18 02
	00 00		 movsxd	 rax, DWORD PTR [rax+536]
  0068f	48 25 00 00 ff
	00		 and	 rax, 16711680		; 00ff0000H
  00695	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0069d	89 81 18 02 00
	00		 mov	 DWORD PTR [rcx+536], eax

; 4315 :     dev->priority |= dev->orb.csspriority << 8;

  006a3	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006ab	0f b6 80 d8 02
	00 00		 movzx	 eax, BYTE PTR [rax+728]
  006b2	c1 e0 08	 shl	 eax, 8
  006b5	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006bd	8b 89 18 02 00
	00		 mov	 ecx, DWORD PTR [rcx+536]
  006c3	0b c8		 or	 ecx, eax
  006c5	8b c1		 mov	 eax, ecx
  006c7	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006cf	89 81 18 02 00
	00		 mov	 DWORD PTR [rcx+536], eax

; 4316 :     dev->priority |= dev->orb.cupriority;

  006d5	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006dd	0f b6 80 da 02
	00 00		 movzx	 eax, BYTE PTR [rax+730]
  006e4	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006ec	8b 89 18 02 00
	00		 mov	 ecx, DWORD PTR [rcx+536]
  006f2	0b c8		 or	 ecx, eax
  006f4	8b c1		 mov	 eax, ecx
  006f6	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006fe	89 81 18 02 00
	00		 mov	 DWORD PTR [rcx+536], eax

; 4317 : 
; 4318 :     /* Schedule the I/O for execution */
; 4319 :     rc = schedule_ioq((sysblk.arch_mode == ARCH_370_IDX) ? regs : NULL,

  00704	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0070b	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [rax+136], 0
  00712	75 12		 jne	 SHORT $LN29@z900_start
  00714	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0071c	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv375[rsp], rax
  00724	eb 0c		 jmp	 SHORT $LN30@z900_start
$LN29@z900_start:
  00726	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv375[rsp], 0
$LN30@z900_start:
  00732	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0073a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv375[rsp]
  00742	e8 00 00 00 00	 call	 schedule_ioq
  00747	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 4320 :                       dev);
; 4321 : 
; 4322 :     /* Done; release locks and return */
; 4323 :     release_lock (&dev->lock);

  0074e	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00756	48 83 c0 38	 add	 rax, 56			; 00000038H
  0075a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196434
  00761	48 8b c8	 mov	 rcx, rax
  00764	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4324 :     return (rc);

  0076a	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR rc$[rsp]
$LN1@z900_start:
$LN14@z900_start:

; 4325 : 
; 4326 : } /* end function startio */

  00771	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00779	48 33 cc	 xor	 rcx, rsp
  0077c	e8 00 00 00 00	 call	 __security_check_cookie
  00781	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  00788	5f		 pop	 rdi
  00789	5e		 pop	 rsi
  0078a	c3		 ret	 0
z900_startio ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv133 = 0
tv145 = 4
i$ = 8
regs$ = 32
dev$ = 40
s390_interrupt_enabled PROC

; 5914 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 5915 : int     i;                              /* Interruption subclass     */
; 5916 : 
; 5917 :     /* Ignore this device if subchannel not valid */
; 5918 :     if (!(dev->pmcw.flag5 & PMCW5_V))

  0000e	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00013	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0001a	83 e0 01	 and	 eax, 1
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN2@s390_inter

; 5919 :         return 0;

  00021	33 c0		 xor	 eax, eax
  00023	e9 27 01 00 00	 jmp	 $LN1@s390_inter
$LN2@s390_inter:

; 5920 : 
; 5921 : #if defined(_FEATURE_IO_ASSIST)
; 5922 :     /* For I/O Assist the zone must match the guest zone */
; 5923 :     if(SIE_MODE(regs) && regs->siebk->zone != dev->pmcw.zone)

  00028	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  0002d	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00033	d1 e8		 shr	 eax, 1
  00035	83 e0 01	 and	 eax, 1
  00038	85 c0		 test	 eax, eax
  0003a	74 27		 je	 SHORT $LN3@s390_inter
  0003c	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00041	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00048	0f b6 40 74	 movzx	 eax, BYTE PTR [rax+116]
  0004c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dev$[rsp]
  00051	0f b6 89 04 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+772]
  00058	3b c1		 cmp	 eax, ecx
  0005a	74 07		 je	 SHORT $LN3@s390_inter

; 5924 :         return 0;

  0005c	33 c0		 xor	 eax, eax
  0005e	e9 ec 00 00 00	 jmp	 $LN1@s390_inter
$LN3@s390_inter:

; 5925 : #endif
; 5926 : 
; 5927 : #if defined(_FEATURE_IO_ASSIST)
; 5928 :     /* The interrupt interlock control bit must be on
; 5929 :        if not we must intercept */
; 5930 :     if(SIE_MODE(regs) && !(dev->pmcw.flag27 & PMCW27_I))

  00063	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00068	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0006e	d1 e8		 shr	 eax, 1
  00070	83 e0 01	 and	 eax, 1
  00073	85 c0		 test	 eax, eax
  00075	74 1f		 je	 SHORT $LN4@s390_inter
  00077	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0007c	0f b6 80 07 03
	00 00		 movzx	 eax, BYTE PTR [rax+775]
  00083	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00088	85 c0		 test	 eax, eax
  0008a	75 0a		 jne	 SHORT $LN4@s390_inter

; 5931 :         return SIE_INTERCEPT_IOINT;

  0008c	b8 f1 ff ff ff	 mov	 eax, -15
  00091	e9 b9 00 00 00	 jmp	 $LN1@s390_inter
$LN4@s390_inter:

; 5932 : #endif
; 5933 : 
; 5934 : #ifdef FEATURE_S370_CHANNEL
; 5935 : 
; 5936 : #if defined(FEATURE_CHANNEL_SWITCHING)
; 5937 :     /* Is this device on a channel connected to this CPU? */
; 5938 :     if(
; 5939 : #if defined(_FEATURE_IO_ASSIST)
; 5940 :        !SIE_MODE(regs) &&
; 5941 : #endif
; 5942 :        regs->chanset != dev->chanset)
; 5943 :         return 0;
; 5944 : #endif /*defined(FEATURE_CHANNEL_SWITCHING)*/
; 5945 : 
; 5946 :     /* Isolate the channel number */
; 5947 :     i = dev->devnum >> 8;
; 5948 :     if (!ECMODE(&regs->psw) && i < 6)
; 5949 :     {
; 5950 : #if defined(_FEATURE_IO_ASSIST)
; 5951 :         /* We must always intercept in BC mode */
; 5952 :         if(SIE_MODE(regs))
; 5953 :             return SIE_INTERCEPT_IOINT;
; 5954 : #endif
; 5955 :         /* For BC mode channels 0-5, test system mask bits 0-5 */
; 5956 :         if ((regs->psw.sysmask & (0x80 >> i)) == 0)
; 5957 :             return 0;
; 5958 :     }
; 5959 :     else
; 5960 :     {
; 5961 :         /* For EC mode and channels 6-31, test system mask bit 6 */
; 5962 :         if ((regs->psw.sysmask & PSW_IOMASK) == 0)
; 5963 :             return 0;
; 5964 : 
; 5965 :         /* If I/O mask is enabled, test channel masks in CR2 */
; 5966 :         if (i > 31) i = 31;
; 5967 :         if ((CHANNEL_MASKS(regs) & (0x80000000 >> i)) == 0)
; 5968 :             return
; 5969 : #if defined(_FEATURE_IO_ASSIST)
; 5970 :                    SIE_MODE(regs) ? SIE_INTERCEPT_IOINTP :
; 5971 : #endif
; 5972 :                                                            0;
; 5973 :     }
; 5974 : #endif /*FEATURE_S370_CHANNEL*/
; 5975 : 
; 5976 : #ifdef FEATURE_CHANNEL_SUBSYSTEM
; 5977 :     /* Ignore this device if subchannel not enabled */
; 5978 :     if (!(dev->pmcw.flag5 & PMCW5_E))

  00096	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0009b	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  000a2	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000a7	85 c0		 test	 eax, eax
  000a9	75 07		 jne	 SHORT $LN5@s390_inter

; 5979 :         return 0;

  000ab	33 c0		 xor	 eax, eax
  000ad	e9 9d 00 00 00	 jmp	 $LN1@s390_inter
$LN5@s390_inter:

; 5980 : 
; 5981 :     /* Isolate the interruption subclass */
; 5982 :     i =

  000b2	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  000b7	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000bd	d1 e8		 shr	 eax, 1
  000bf	83 e0 01	 and	 eax, 1
  000c2	85 c0		 test	 eax, eax
  000c4	74 14		 je	 SHORT $LN8@s390_inter
  000c6	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  000cb	0f b6 80 05 03
	00 00		 movzx	 eax, BYTE PTR [rax+773]
  000d2	83 e0 07	 and	 eax, 7
  000d5	89 04 24	 mov	 DWORD PTR tv133[rsp], eax
  000d8	eb 15		 jmp	 SHORT $LN9@s390_inter
$LN8@s390_inter:
  000da	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  000df	0f b6 80 f0 02
	00 00		 movzx	 eax, BYTE PTR [rax+752]
  000e6	83 e0 38	 and	 eax, 56			; 00000038H
  000e9	c1 f8 03	 sar	 eax, 3
  000ec	89 04 24	 mov	 DWORD PTR tv133[rsp], eax
$LN9@s390_inter:
  000ef	8b 04 24	 mov	 eax, DWORD PTR tv133[rsp]
  000f2	89 44 24 08	 mov	 DWORD PTR i$[rsp], eax

; 5983 : #if defined(_FEATURE_IO_ASSIST)
; 5984 :         /* For I/O Assisted devices use the guest (V)ISC */
; 5985 :         SIE_MODE(regs) ? (dev->pmcw.flag25 & PMCW25_VISC) :
; 5986 : #endif
; 5987 :         ((dev->pmcw.flag4 & PMCW4_ISC) >> 3);
; 5988 : 
; 5989 :     /* Test interruption subclass mask bit in CR6 */
; 5990 :     if ((regs->CR_L(6) & (0x80000000 >> i)) == 0)

  000f6	b8 08 00 00 00	 mov	 eax, 8
  000fb	48 6b c0 07	 imul	 rax, rax, 7
  000ff	8b 4c 24 08	 mov	 ecx, DWORD PTR i$[rsp]
  00103	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  00108	d3 ea		 shr	 edx, cl
  0010a	8b ca		 mov	 ecx, edx
  0010c	48 8b 54 24 20	 mov	 rdx, QWORD PTR regs$[rsp]
  00111	8b 84 02 00 06
	00 00		 mov	 eax, DWORD PTR [rdx+rax+1536]
  00118	23 c1		 and	 eax, ecx
  0011a	85 c0		 test	 eax, eax
  0011c	75 2c		 jne	 SHORT $LN6@s390_inter

; 5991 :         return

  0011e	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00123	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00129	d1 e8		 shr	 eax, 1
  0012b	83 e0 01	 and	 eax, 1
  0012e	85 c0		 test	 eax, eax
  00130	74 0a		 je	 SHORT $LN10@s390_inter
  00132	c7 44 24 04 f0
	ff ff ff	 mov	 DWORD PTR tv145[rsp], -16
  0013a	eb 08		 jmp	 SHORT $LN11@s390_inter
$LN10@s390_inter:
  0013c	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN11@s390_inter:
  00144	8b 44 24 04	 mov	 eax, DWORD PTR tv145[rsp]
  00148	eb 05		 jmp	 SHORT $LN1@s390_inter
$LN6@s390_inter:

; 5992 : #if defined(_FEATURE_IO_ASSIST)
; 5993 :                    SIE_MODE(regs) ? SIE_INTERCEPT_IOINTP :
; 5994 : #endif
; 5995 :                                                            0;
; 5996 : #endif /*FEATURE_CHANNEL_SUBSYSTEM*/
; 5997 : 
; 5998 :     /* Interrupts are enabled for this device */
; 5999 :     return SIE_NO_INTERCEPT;

  0014a	b8 ff ff ff ff	 mov	 eax, -1
$LN1@s390_inter:

; 6000 : } /* end function interrupt_enabled */

  0014f	48 83 c4 18	 add	 rsp, 24
  00153	c3		 ret	 0
s390_interrupt_enabled ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv181 = 80
tv187 = 84
rc$1 = 88
tv213 = 92
tv219 = 96
dev$ = 128
unitstat$ = 136
s390_device_attention PROC

; 4066 : {

$LN24:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 4067 :     OBTAIN_INTLOCK(NULL);

  0000d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182356
  00014	33 c9		 xor	 ecx, ecx
  00016	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 4068 :     obtain_lock( &dev->lock );

  0001b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00023	48 83 c0 38	 add	 rax, 56			; 00000038H
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182357
  0002e	48 8b c8	 mov	 rcx, rax
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4069 : 
; 4070 :     if (dev->hnd->attention)

  00037	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003f	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00046	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  0004b	74 1a		 je	 SHORT $LN2@s390_devic

; 4071 :         dev->hnd->attention( dev );

  0004d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00055	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0005c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00064	ff 50 78	 call	 QWORD PTR [rax+120]
$LN2@s390_devic:

; 4072 : 
; 4073 : #ifdef FEATURE_CHANNEL_SUBSYSTEM
; 4074 :     /* If subchannel not valid and enabled, do not present interrupt */
; 4075 :     if (0
; 4076 :         || (dev->pmcw.flag5 & PMCW5_V) == 0
; 4077 :         || (dev->pmcw.flag5 & PMCW5_E) == 0

  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 2e		 jne	 SHORT $LN4@s390_devic
  0006d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00075	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0007c	83 e0 01	 and	 eax, 1
  0007f	85 c0		 test	 eax, eax
  00081	74 18		 je	 SHORT $LN4@s390_devic
  00083	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0008b	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00092	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00097	85 c0		 test	 eax, eax
  00099	75 34		 jne	 SHORT $LN3@s390_devic
$LN4@s390_devic:

; 4078 :     )
; 4079 :     {
; 4080 :         release_lock( &dev->lock );

  0009b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a3	48 83 c0 38	 add	 rax, 56			; 00000038H
  000a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182361
  000ae	48 8b c8	 mov	 rcx, rax
  000b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4081 :         RELEASE_INTLOCK(NULL);

  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182362
  000be	33 c9		 xor	 ecx, ecx
  000c0	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 4082 :         return 3;

  000c5	b8 03 00 00 00	 mov	 eax, 3
  000ca	e9 52 04 00 00	 jmp	 $LN1@s390_devic
$LN3@s390_devic:

; 4083 :     }
; 4084 : #endif /*FEATURE_CHANNEL_SUBSYSTEM*/
; 4085 : 
; 4086 : 
; 4087 :     /* If device is already busy or interrupt pending */
; 4088 :     if (0
; 4089 :         || dev->busy
; 4090 :         || IOPENDING( dev )
; 4091 :         || (dev->scsw.flag3 & SCSW3_SC_PEND)

  000cf	33 c0		 xor	 eax, eax
  000d1	85 c0		 test	 eax, eax
  000d3	0f 85 92 00 00
	00		 jne	 $LN6@s390_devic
  000d9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000e1	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000e7	c1 e8 13	 shr	 eax, 19
  000ea	83 e0 01	 and	 eax, 1
  000ed	85 c0		 test	 eax, eax
  000ef	75 7a		 jne	 SHORT $LN6@s390_devic
  000f1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000f9	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000ff	c1 e8 16	 shr	 eax, 22
  00102	83 e0 01	 and	 eax, 1
  00105	85 c0		 test	 eax, eax
  00107	75 62		 jne	 SHORT $LN6@s390_devic
  00109	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00111	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00117	c1 e8 17	 shr	 eax, 23
  0011a	83 e0 01	 and	 eax, 1
  0011d	85 c0		 test	 eax, eax
  0011f	75 4a		 jne	 SHORT $LN6@s390_devic
  00121	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00129	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0012f	c1 e8 18	 shr	 eax, 24
  00132	83 e0 01	 and	 eax, 1
  00135	85 c0		 test	 eax, eax
  00137	75 32		 jne	 SHORT $LN6@s390_devic
  00139	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00141	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00147	c1 e8 1b	 shr	 eax, 27
  0014a	83 e0 01	 and	 eax, 1
  0014d	85 c0		 test	 eax, eax
  0014f	75 1a		 jne	 SHORT $LN6@s390_devic
  00151	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00159	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00160	83 e0 01	 and	 eax, 1
  00163	85 c0		 test	 eax, eax
  00165	0f 84 cd 01 00
	00		 je	 $LN5@s390_devic
$LN6@s390_devic:

; 4092 :     )
; 4093 :     {
; 4094 :         int rc;                         /* Return code               */
; 4095 : 
; 4096 :         /* Resume the suspended device with attention set            */
; 4097 :         /* SA22-7204-00:                                             */
; 4098 :         /*  p. 4-1, Attention                                        */
; 4099 :         if(dev->scsw.flag3 & SCSW3_AC_SUSP)

  0016b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00173	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  0017a	83 e0 20	 and	 eax, 32			; 00000020H
  0017d	85 c0		 test	 eax, eax
  0017f	0f 84 78 01 00
	00		 je	 $LN7@s390_devic

; 4100 :         {
; 4101 :             unitstat |= CSW_ATTN;

  00185	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR unitstat$[rsp]
  0018d	0f ba e8 07	 bts	 eax, 7
  00191	88 84 24 88 00
	00 00		 mov	 BYTE PTR unitstat$[rsp], al

; 4102 : 
; 4103 :             dev->scsw.unitstat |= unitstat;

  00198	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR unitstat$[rsp]
  001a0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001a8	0f b6 89 10 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+784]
  001af	0b c8		 or	 ecx, eax
  001b1	8b c1		 mov	 eax, ecx
  001b3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001bb	88 81 10 03 00
	00		 mov	 BYTE PTR [rcx+784], al

; 4104 :             dev->scsw.flag2    |= SCSW2_AC_RESUM;

  001c1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001c9	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  001d0	83 c8 08	 or	 eax, 8
  001d3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001db	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 4105 :             dev->scsw.flag3    |= SCSW3_SC_ALERT | SCSW3_SC_PEND;

  001e1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001e9	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  001f0	83 c8 11	 or	 eax, 17
  001f3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001fb	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 4106 : 
; 4107 :             schedule_ioq( NULL, dev );

  00201	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00209	33 c9		 xor	 ecx, ecx
  0020b	e8 00 00 00 00	 call	 schedule_ioq

; 4108 : 
; 4109 :             if (dev->ccwtrace)

  00210	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00218	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0021e	c1 e8 0f	 shr	 eax, 15
  00221	83 e0 01	 and	 eax, 1
  00224	85 c0		 test	 eax, eax
  00226	0f 84 c7 00 00
	00		 je	 $LN9@s390_devic

; 4110 :             {
; 4111 :                 if (sysblk.traceFILE)

  0022c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00233	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  0023b	74 13		 je	 SHORT $LN10@s390_devic

; 4112 :                     tf_1304( dev );

  0023d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00245	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1304
  0024b	e9 a3 00 00 00	 jmp	 $LN11@s390_devic
$LN10@s390_devic:

; 4113 :                 else
; 4114 :                     // "%1d:%04X CHAN: attention signaled"
; 4115 :                     WRMSG( HHC01304, "I", LCSS_DEVNUM );

  00250	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00259	74 12		 je	 SHORT $LN16@s390_devic
  0025b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00263	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00267	89 44 24 50	 mov	 DWORD PTR tv181[rsp], eax
  0026b	eb 08		 jmp	 SHORT $LN17@s390_devic
$LN16@s390_devic:
  0026d	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv181[rsp], 0
$LN17@s390_devic:
  00275	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0027e	74 14		 je	 SHORT $LN18@s390_devic
  00280	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00288	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0028c	d1 f8		 sar	 eax, 1
  0028e	89 44 24 54	 mov	 DWORD PTR tv187[rsp], eax
  00292	eb 08		 jmp	 SHORT $LN19@s390_devic
$LN18@s390_devic:
  00294	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv187[rsp], 0
$LN19@s390_devic:
  0029c	b9 01 00 00 00	 mov	 ecx, 1
  002a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002a7	8b 4c 24 50	 mov	 ecx, DWORD PTR tv181[rsp]
  002ab	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002af	8b 4c 24 54	 mov	 ecx, DWORD PTR tv187[rsp]
  002b3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182370
  002be	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182371
  002ca	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002cf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002d4	41 b9 03 00 00
	00		 mov	 r9d, 3
  002da	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG182372
  002e1	ba 13 10 00 00	 mov	 edx, 4115		; 00001013H
  002e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182373
  002ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN11@s390_devic:
$LN9@s390_devic:

; 4116 :             }
; 4117 :             rc = 0;

  002f3	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR rc$1[rsp], 0

; 4118 :         }

  002fb	eb 08		 jmp	 SHORT $LN8@s390_devic
$LN7@s390_devic:

; 4119 :         else
; 4120 :             rc = 1;

  002fd	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR rc$1[rsp], 1
$LN8@s390_devic:

; 4121 : 
; 4122 :         release_lock( &dev->lock );

  00305	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0030d	48 83 c0 38	 add	 rax, 56			; 00000038H
  00311	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182374
  00318	48 8b c8	 mov	 rcx, rax
  0031b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4123 :         RELEASE_INTLOCK(NULL);

  00321	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182375
  00328	33 c9		 xor	 ecx, ecx
  0032a	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 4124 :         return rc;

  0032f	8b 44 24 58	 mov	 eax, DWORD PTR rc$1[rsp]
  00333	e9 e9 01 00 00	 jmp	 $LN1@s390_devic
$LN5@s390_devic:

; 4125 :     }
; 4126 : 
; 4127 :     if (dev->ccwtrace)

  00338	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00340	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00346	c1 e8 0f	 shr	 eax, 15
  00349	83 e0 01	 and	 eax, 1
  0034c	85 c0		 test	 eax, eax
  0034e	0f 84 c7 00 00
	00		 je	 $LN12@s390_devic

; 4128 :     {
; 4129 :         if (sysblk.traceFILE)

  00354	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0035b	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00363	74 13		 je	 SHORT $LN13@s390_devic

; 4130 :             tf_1305( dev );

  00365	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0036d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1305
  00373	e9 a3 00 00 00	 jmp	 $LN14@s390_devic
$LN13@s390_devic:

; 4131 :         else
; 4132 :             // "%1d:%04X CHAN: attention"
; 4133 :             WRMSG( HHC01305, "I", LCSS_DEVNUM );

  00378	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00381	74 12		 je	 SHORT $LN20@s390_devic
  00383	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0038b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0038f	89 44 24 5c	 mov	 DWORD PTR tv213[rsp], eax
  00393	eb 08		 jmp	 SHORT $LN21@s390_devic
$LN20@s390_devic:
  00395	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv213[rsp], 0
$LN21@s390_devic:
  0039d	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003a6	74 14		 je	 SHORT $LN22@s390_devic
  003a8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003b0	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  003b4	d1 f8		 sar	 eax, 1
  003b6	89 44 24 60	 mov	 DWORD PTR tv219[rsp], eax
  003ba	eb 08		 jmp	 SHORT $LN23@s390_devic
$LN22@s390_devic:
  003bc	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv219[rsp], 0
$LN23@s390_devic:
  003c4	b9 01 00 00 00	 mov	 ecx, 1
  003c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003cf	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv213[rsp]
  003d3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  003d7	8b 4c 24 60	 mov	 ecx, DWORD PTR tv219[rsp]
  003db	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  003df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182379
  003e6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182380
  003f2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003f7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003fc	41 b9 03 00 00
	00		 mov	 r9d, 3
  00402	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG182381
  00409	ba 25 10 00 00	 mov	 edx, 4133		; 00001025H
  0040e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182382
  00415	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN14@s390_devic:
$LN12@s390_devic:

; 4134 :     }
; 4135 : 
; 4136 :     /* We already have INTLOCK and dev->lock held, so now
; 4137 :        we only need to acquire the interrupt queue lock. */
; 4138 :     obtain_lock(&sysblk.iointqlk);

  0041b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00422	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  00428	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182383
  0042f	48 8b c8	 mov	 rcx, rax
  00432	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4139 : 
; 4140 :     /* Set SCSW for attention interrupt                              */
; 4141 :     /* SA22-7201-05:                                                 */
; 4142 :     /*  p. 16-3, Unsolicited Interuption Condition                   */
; 4143 :     /*           Solicited Interuption Condition                     */
; 4144 :     /*           Figure 16-1, Interruption Condition for Status-     */
; 4145 :     /*                        Control-Bit Combinations               */
; 4146 :     /*  p. 16-4, Alert Interruption Condition                        */
; 4147 :     /*  p. 16-16 -- 16-17, Alert Status (Bit 27)                     */
; 4148 :     /*  p. 16-18, Status-Pending (Bit 31)                            */
; 4149 :     /*                                                               */
; 4150 :     /*  Hercules maintains for tracking purposes regardless of       */
; 4151 :     /*  architecture.                                                */
; 4152 :     /*                                                               */
; 4153 :     /* Set CSW for attention interrupt when in S/360 or S/370 mode,  */
; 4154 :     /* CSW will be derived from the SCSW when interrupt is issued    */
; 4155 :     /* SA22-7204-00:                                                 */
; 4156 :     /*  p. 4-1, Attention                                            */
; 4157 :     /* GA22-6974-09:                                                 */
; 4158 :     /*  pp. 2-13 -- 2-14, Attention                                  */
; 4159 :     dev->attnscsw.flag3 = SCSW3_SC_ALERT | SCSW3_SC_PEND;

  00438	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00440	c6 80 23 03 00
	00 11		 mov	 BYTE PTR [rax+803], 17

; 4160 :     store_fw (dev->attnscsw.ccwaddr, 0);

  00447	33 c9		 xor	 ecx, ecx
  00449	e8 00 00 00 00	 call	 _byteswap_ulong
  0044e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00456	48 81 c1 24 03
	00 00		 add	 rcx, 804		; 00000324H
  0045d	8b d0		 mov	 edx, eax
  0045f	e8 00 00 00 00	 call	 store_fw_noswap

; 4161 :     dev->attnscsw.unitstat = unitstat;

  00464	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0046c	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR unitstat$[rsp]
  00474	88 88 28 03 00
	00		 mov	 BYTE PTR [rax+808], cl

; 4162 :     dev->attnscsw.chanstat = 0;

  0047a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00482	c6 80 29 03 00
	00 00		 mov	 BYTE PTR [rax+809], 0

; 4163 :     store_hw (dev->attnscsw.count, 0);

  00489	33 c9		 xor	 ecx, ecx
  0048b	e8 00 00 00 00	 call	 _byteswap_ushort
  00490	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00498	48 81 c1 2a 03
	00 00		 add	 rcx, 810		; 0000032aH
  0049f	0f b7 d0	 movzx	 edx, ax
  004a2	e8 00 00 00 00	 call	 store_hw_noswap

; 4164 : 
; 4165 :     /* Queue the attention interrupt */
; 4166 :     QUEUE_IO_INTERRUPT_QLOCKED(&dev->attnioint,FALSE);

  004a7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004af	48 05 58 02 00
	00		 add	 rax, 600		; 00000258H
  004b5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG182384
  004bc	33 d2		 xor	 edx, edx
  004be	48 8b c8	 mov	 rcx, rax
  004c1	e8 00 00 00 00	 call	 Queue_IO_Interrupt_QLocked

; 4167 : 
; 4168 :     /* Update interrupt status */
; 4169 :     subchannel_interrupt_queue_cleanup(dev);

  004c6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004ce	e8 00 00 00 00	 call	 subchannel_interrupt_queue_cleanup

; 4170 :     UPDATE_IC_IOPENDING_QLOCKED();

  004d3	e8 00 00 00 00	 call	 Update_IC_IOPENDING_QLocked

; 4171 : 
; 4172 :     /* Release locks and return to caller */
; 4173 :     release_lock(&sysblk.iointqlk);

  004d8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004df	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  004e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182385
  004ec	48 8b c8	 mov	 rcx, rax
  004ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4174 :     release_lock(&dev->lock);

  004f5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004fd	48 83 c0 38	 add	 rax, 56			; 00000038H
  00501	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182386
  00508	48 8b c8	 mov	 rcx, rax
  0050b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4175 :     RELEASE_INTLOCK(NULL);

  00511	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182387
  00518	33 c9		 xor	 ecx, ecx
  0051a	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 4176 : 
; 4177 :     return 0;

  0051f	33 c0		 xor	 eax, eax
$LN1@s390_devic:

; 4178 : } /* end function device_attention */

  00521	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00525	c3		 ret	 0
s390_device_attention ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
idalen$ = 80
ps$ = 84
to_memory$ = 88
readbackwards$ = 89
storkey$ = 90
to_iobuf$ = 91
idacount$ = 92
page$ = 96
idawaddr$ = 104
idadata$ = 112
idaseq$ = 120
tv128 = 124
tv141 = 128
iobufptr$ = 136
idasize$ = 144
iobufptr$1 = 152
tv492 = 160
tv500 = 168
tv514 = 176
tv564 = 184
tv572 = 192
tv575 = 200
startpage$ = 208
endpage$ = 216
tv377 = 224
dev$ = 272
ccw$ = 280
code$ = 288
flags$ = 296
addr$ = 304
count$ = 312
ccwkey$ = 320
idawfmt$ = 328
idapmask$ = 336
iobuf$ = 344
iobufstart$ = 352
iobufend$ = 360
chanstat$ = 368
residual$ = 376
prefetch$ = 384
s390_copy_iobuf PROC

; 3372 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H

; 3373 : BYTE    *iobufptr = 0;                  /* Working I/O buffer addr   */

  0001d	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR iobufptr$[rsp], 0

; 3374 : u_int   ps = 0;                         /* Prefetch entry            */

  00029	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR ps$[rsp], 0

; 3375 : U32     idawaddr;                       /* Main storage addr of IDAW */
; 3376 : U16     idacount;                       /* IDA bytes remaining       */
; 3377 : int     idaseq;                         /* IDA sequence number       */
; 3378 : RADR    idadata;                        /* IDA data address          */
; 3379 : U16     idalen;                         /* IDA data length           */
; 3380 : int     idasize;                        /* IDAW Size                 */
; 3381 : BYTE    storkey;                        /* Storage key               */
; 3382 : RADR    page,startpage,endpage;         /* Storage key pages         */
; 3383 : BYTE    to_iobuf;                       /* 1=READ, SENSE, or RDBACK  */
; 3384 : BYTE    to_memory;                      /* 1=READ, SENSE, or RDBACK  */
; 3385 : BYTE    readbackwards;                  /* 1=RDBACK                  */
; 3386 : #if defined(FEATURE_MIDAW_FACILITY)
; 3387 : int     midawseq;                       /* MIDAW counter (0=1st)     */
; 3388 : U32     midawptr;                       /* Real addr of MIDAW        */
; 3389 : U16     midawrem;                       /* CCW bytes remaining       */
; 3390 : U16     midawlen=0;                     /* MIDAW data length         */
; 3391 : RADR    midawdat=0;                     /* MIDAW data area addr      */
; 3392 : BYTE    midawflg;                       /* MIDAW flags               */
; 3393 : #endif /*defined(FEATURE_MIDAW_FACILITY)*/
; 3394 : 
; 3395 : #if !defined(set_chanstat)
; 3396 : #define set_chanstat(_status)                                          \
; 3397 : do {                                                                   \
; 3398 :     if (prefetch->seq)                                                 \
; 3399 :         prefetch->chanstat[ps] = (_status);                            \
; 3400 :     else                                                               \
; 3401 :         *chanstat = (_status);                                         \
; 3402 : } while(0)
; 3403 : #endif
; 3404 : 
; 3405 : #if !defined(get_new_prefetch_entry)
; 3406 : #define get_new_prefetch_entry(_idawtype,_idawaddr)                    \
; 3407 : do {                                                                   \
; 3408 :     if (prefetch->seq)                                                 \
; 3409 :     {                                                                  \
; 3410 :         ps = prefetch->seq++;                                          \
; 3411 :         if (prefetch->seq > PF_SIZE)                                   \
; 3412 :         {                                                              \
; 3413 :             *chanstat = CSW_CDC;                                       \
; 3414 :             break;                                                     \
; 3415 :         }                                                              \
; 3416 :         prefetch->ccwaddr[ps] = prefetch->ccwaddr[ps-1];               \
; 3417 :         if ((_idawtype) != PF_NO_IDAW)                                 \
; 3418 :         {                                                              \
; 3419 :             prefetch->idawtype[ps] = (_idawtype);                      \
; 3420 :             prefetch->idawaddr[ps] = (_idawaddr);                      \
; 3421 :         }                                                              \
; 3422 :     }                                                                  \
; 3423 :     *chanstat = 0;                                                     \
; 3424 : } while(0)
; 3425 : #endif
; 3426 : 
; 3427 :     /* Set current prefetch sequence */
; 3428 :     if (prefetch->seq)

  00031	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00039	83 38 00	 cmp	 DWORD PTR [rax], 0
  0003c	74 10		 je	 SHORT $LN38@s390_copy_

; 3429 :         ps = prefetch->seq - 1;

  0003e	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00046	8b 00		 mov	 eax, DWORD PTR [rax]
  00048	ff c8		 dec	 eax
  0004a	89 44 24 54	 mov	 DWORD PTR ps$[rsp], eax
$LN38@s390_copy_:

; 3430 : 
; 3431 :     /* Channel Data Check if invalid I/O buffer */
; 3432 :     if ((size_t)iobufend < 131072   ||  /* Low host OS storage reference */
; 3433 :         iobuf < iobufstart          ||

  0004e	48 81 bc 24 68
	01 00 00 00 00
	02 00		 cmp	 QWORD PTR iobufend$[rsp], 131072 ; 00020000H
  0005a	72 24		 jb	 SHORT $LN40@s390_copy_
  0005c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR iobufstart$[rsp]
  00064	48 39 84 24 58
	01 00 00	 cmp	 QWORD PTR iobuf$[rsp], rax
  0006c	72 12		 jb	 SHORT $LN40@s390_copy_
  0006e	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR iobufend$[rsp]
  00076	48 39 84 24 58
	01 00 00	 cmp	 QWORD PTR iobuf$[rsp], rax
  0007e	76 36		 jbe	 SHORT $LN39@s390_copy_
$LN40@s390_copy_:
$LN4@s390_copy_:

; 3434 :         iobuf > iobufend)
; 3435 :     {
; 3436 :         set_chanstat(CSW_CDC);

  00080	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00088	83 38 00	 cmp	 DWORD PTR [rax], 0
  0008b	74 13		 je	 SHORT $LN41@s390_copy_
  0008d	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00091	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00099	c6 44 01 10 08	 mov	 BYTE PTR [rcx+rax+16], 8
  0009e	eb 0b		 jmp	 SHORT $LN42@s390_copy_
$LN41@s390_copy_:
  000a0	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  000a8	c6 00 08	 mov	 BYTE PTR [rax], 8
$LN42@s390_copy_:
  000ab	33 c0		 xor	 eax, eax
  000ad	85 c0		 test	 eax, eax
  000af	75 cf		 jne	 SHORT $LN4@s390_copy_

; 3437 :         return;

  000b1	e9 fa 10 00 00	 jmp	 $LN1@s390_copy_
$LN39@s390_copy_:

; 3438 :     }
; 3439 : 
; 3440 :     /* Exit if no bytes are to be copied */
; 3441 :     if (count == 0 || dev->is_immed)

  000b6	83 bc 24 38 01
	00 00 00	 cmp	 DWORD PTR count$[rsp], 0
  000be	74 11		 je	 SHORT $LN44@s390_copy_
  000c0	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000c8	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  000cf	74 36		 je	 SHORT $LN43@s390_copy_
$LN44@s390_copy_:
$LN7@s390_copy_:

; 3442 :     {
; 3443 :         set_chanstat(0);

  000d1	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  000d9	83 38 00	 cmp	 DWORD PTR [rax], 0
  000dc	74 13		 je	 SHORT $LN45@s390_copy_
  000de	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  000e2	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  000ea	c6 44 01 10 00	 mov	 BYTE PTR [rcx+rax+16], 0
  000ef	eb 0b		 jmp	 SHORT $LN46@s390_copy_
$LN45@s390_copy_:
  000f1	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  000f9	c6 00 00	 mov	 BYTE PTR [rax], 0
$LN46@s390_copy_:
  000fc	33 c0		 xor	 eax, eax
  000fe	85 c0		 test	 eax, eax
  00100	75 cf		 jne	 SHORT $LN7@s390_copy_

; 3444 :         return;

  00102	e9 a9 10 00 00	 jmp	 $LN1@s390_copy_
$LN43@s390_copy_:

; 3445 :     }
; 3446 : 
; 3447 :     /* Set flags indicating direction of data movement */
; 3448 :     if (IS_CCW_RDBACK(code))

  00107	0f b6 84 24 20
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0010f	83 e0 0f	 and	 eax, 15
  00112	83 f8 0c	 cmp	 eax, 12
  00115	75 15		 jne	 SHORT $LN47@s390_copy_

; 3449 :     {
; 3450 :         readbackwards = to_memory = 1;

  00117	c6 44 24 58 01	 mov	 BYTE PTR to_memory$[rsp], 1
  0011c	0f b6 44 24 58	 movzx	 eax, BYTE PTR to_memory$[rsp]
  00121	88 44 24 59	 mov	 BYTE PTR readbackwards$[rsp], al

; 3451 :         to_iobuf = 0;

  00125	c6 44 24 5b 00	 mov	 BYTE PTR to_iobuf$[rsp], 0

; 3452 :     }

  0012a	eb 38		 jmp	 SHORT $LN48@s390_copy_
$LN47@s390_copy_:

; 3453 :     else
; 3454 :     {
; 3455 :         readbackwards = 0;

  0012c	c6 44 24 59 00	 mov	 BYTE PTR readbackwards$[rsp], 0

; 3456 :         to_iobuf = code & 0x01;

  00131	0f b6 84 24 20
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  00139	83 e0 01	 and	 eax, 1
  0013c	88 44 24 5b	 mov	 BYTE PTR to_iobuf$[rsp], al

; 3457 :         to_memory = !to_iobuf;

  00140	0f b6 44 24 5b	 movzx	 eax, BYTE PTR to_iobuf$[rsp]
  00145	85 c0		 test	 eax, eax
  00147	75 0a		 jne	 SHORT $LN129@s390_copy_
  00149	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR tv128[rsp], 1
  00151	eb 08		 jmp	 SHORT $LN130@s390_copy_
$LN129@s390_copy_:
  00153	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
$LN130@s390_copy_:
  0015b	0f b6 44 24 7c	 movzx	 eax, BYTE PTR tv128[rsp]
  00160	88 44 24 58	 mov	 BYTE PTR to_memory$[rsp], al
$LN48@s390_copy_:

; 3458 :     }
; 3459 : 
; 3460 : 
; 3461 : #if defined(FEATURE_MIDAW_FACILITY)
; 3462 :     /* Move data when modified indirect data addressing is used */
; 3463 :     if (flags & CCW_FLAGS_MIDAW)
; 3464 :     {
; 3465 :         if (prefetch->seq)
; 3466 :             prefetch->datalen[ps] = 0;
; 3467 : 
; 3468 :         midawptr = addr;
; 3469 :         midawrem = count;
; 3470 :         midawflg = 0;
; 3471 : 
; 3472 :         for (midawseq = 0;
; 3473 :              midawrem > 0 &&
; 3474 :                 (midawflg & MIDAW_LAST) == 0 &&
; 3475 :                 chanstat != 0 &&
; 3476 :                 !(prefetch->seq &&
; 3477 :                     (prefetch->chanstat[ps] ||
; 3478 :                         ((ps+1) < prefetch->seq &&
; 3479 :                             prefetch->chanstat[ps+1])));
; 3480 :              midawseq++)
; 3481 :         {
; 3482 :             /* Get new prefetch entry */
; 3483 :             get_new_prefetch_entry(PF_MIDAW, midawptr);
; 3484 :             if (*chanstat != 0)
; 3485 :                 break;
; 3486 : 
; 3487 :             /* Fetch MIDAW and set data address, length, flags */
; 3488 :             ARCH_DEP(fetch_midaw) (dev, code, ccwkey,
; 3489 :                     midawseq, midawptr,
; 3490 :                     &midawdat, &midawlen, &midawflg, chanstat);
; 3491 : 
; 3492 :             /* Exit if fetch_midaw detected channel program check */
; 3493 :             if (prefetch->seq)
; 3494 :             {
; 3495 :                 prefetch->idawflag[ps] = midawflg;
; 3496 :                 prefetch->dataaddr[ps] = midawdat;
; 3497 :                 prefetch->datalen[ps] = midawlen;
; 3498 :                 if (*chanstat != 0)
; 3499 :                 {
; 3500 :                     prefetch->chanstat[ps] = *chanstat;
; 3501 :                     *chanstat = 0;
; 3502 :                     break;
; 3503 :                 }
; 3504 :             }
; 3505 :             else if (*chanstat != 0)
; 3506 :                 break;
; 3507 : 
; 3508 :             /* Channel program check if MIDAW length
; 3509 :                exceeds the remaining CCW count */
; 3510 :             if (midawlen > midawrem)
; 3511 :             {
; 3512 :                 set_chanstat(CSW_PROGC);
; 3513 :                 return;
; 3514 :             }
; 3515 : 
; 3516 :             /* MIDAW length may be zero during prefetch operations */
; 3517 :             if (!prefetch->seq || (prefetch->seq && midawlen))
; 3518 :             {
; 3519 : 
; 3520 :                 /* Perform data movement unless SKIP flag is set in
; 3521 :                    MIDAW */
; 3522 :                 if ((midawflg & MIDAW_SKIP) ==0)
; 3523 :                 {
; 3524 :                     /* Note: MIDAW data area cannot cross a page
; 3525 :                        boundary. The fetch_midaw function enforces this
; 3526 :                        restriction */
; 3527 : 
; 3528 :                     /* Channel protection check if MIDAW data location
; 3529 :                        is fetch protected, or if location is store
; 3530 :                        protected and command is READ, READ BACKWARD, or
; 3531 :                        SENSE */
; 3532 :                     storkey = ARCH_DEP( get_dev_storage_key )( dev, midawdat );
; 3533 :                     if (ccwkey != 0
; 3534 :                         && (storkey & STORKEY_KEY) != ccwkey
; 3535 :                         && ((storkey & STORKEY_FETCH) || to_memory))
; 3536 :                     {
; 3537 :                         set_chanstat(CSW_PROTC);
; 3538 :                         return;
; 3539 :                     }
; 3540 : 
; 3541 :                     /* Ensure memcpy will stay within buffer         */
; 3542 :                     /* Channel data check if outside buffer          */
; 3543 :                     /* SA22-7201-05:                                 */
; 3544 :                     /*  p. 16-27, Channel-Data Check                 */
; 3545 :                     if (readbackwards)
; 3546 :                     {
; 3547 :                         iobufptr = iobuf + dev->curblkrem + midawrem -
; 3548 :                                    midawlen;
; 3549 :                         if (!midawlen                        ||
; 3550 :                             (iobufptr + midawlen) > iobufend ||
; 3551 :                             iobufptr < iobufstart)
; 3552 :                         {
; 3553 :                             *chanstat = CSW_CDC;
; 3554 :                             return;
; 3555 :                         }
; 3556 :                     }
; 3557 :                     else if (!midawlen                     ||
; 3558 :                              (iobuf + midawlen) > iobufend ||
; 3559 :                              iobuf < iobufstart)
; 3560 :                     {
; 3561 :                             set_chanstat(CSW_CDC);
; 3562 :                             return;
; 3563 :                     }
; 3564 : 
; 3565 :                     /* Set the main storage reference and change
; 3566 :                        bits */
; 3567 :                     if (to_memory)
; 3568 :                         ARCH_DEP( or_dev_storage_key )( dev, midawdat, (STORKEY_REF | STORKEY_CHANGE) );
; 3569 :                     else
; 3570 :                         ARCH_DEP( or_dev_storage_key )( dev, midawdat, STORKEY_REF );
; 3571 : 
; 3572 :                     /* Copy data between main storage and channel
; 3573 :                        buffer */
; 3574 :                     if (readbackwards)
; 3575 :                     {
; 3576 :                         midawdat = (midawdat - midawlen) + 1;
; 3577 :                         memcpy_backwards (dev->mainstor + midawdat,
; 3578 :                                           iobufptr,
; 3579 :                                           midawlen);
; 3580 : 
; 3581 :                         /* Decrement buffer pointer */
; 3582 :                         iobuf -= midawlen;
; 3583 :                     }
; 3584 :                     else
; 3585 :                     {
; 3586 :                         if (to_iobuf)
; 3587 :                         {
; 3588 :                             memcpy (iobuf,
; 3589 :                                     dev->mainstor + midawdat,
; 3590 :                                     midawlen);
; 3591 :                             prefetch->pos += midawlen;
; 3592 :                             if (prefetch->seq)
; 3593 :                                 prefetch->datalen[ps] = midawlen;
; 3594 :                         }
; 3595 :                         else
; 3596 :                         {
; 3597 :                             memcpy (dev->mainstor + midawdat,
; 3598 :                                     iobuf,
; 3599 :                                     midawlen);
; 3600 :                         }
; 3601 : 
; 3602 :                         /* Increment buffer pointer */
; 3603 :                         iobuf += midawlen;
; 3604 :                     }
; 3605 : 
; 3606 :                 } /* end if(!MIDAW_FLAG_SKIP) */
; 3607 : 
; 3608 :                 /* Display the MIDAW if CCW tracing is on */
; 3609 :                 if (!prefetch->seq && dev->ccwtrace)
; 3610 :                 {
; 3611 :                     /* Trace the CCW first, then the MIDAW, but only
; 3612 :                        if this is a read type CCW as determined by
; 3613 :                        the direction of the copying. (For write type
; 3614 :                        CCws, channel code properly traces CCWs before
; 3615 :                        we're even called.)
; 3616 :                     */
; 3617 :                     if (to_memory)
; 3618 :                         DISPLAY_CCW( dev, ccw, addr, count, flags );
; 3619 :                     DISPLAY_IDAW( dev, PF_MIDAW, midawflg, midawdat, midawlen );
; 3620 :                 }
; 3621 : #if DEBUG_DUMP
; 3622 :                 if (dev->ccwtrace)
; 3623 :                 {
; 3624 :                     if (to_memory)
; 3625 :                         DUMP("iobuf:", iobuf, midawlen);
; 3626 :                     DUMP_STORAGE("Storage:", midawdat, midawlen);
; 3627 :                     if (to_iobuf)
; 3628 :                         DUMP("iobuf:", iobuf, midawlen);
; 3629 :                 }
; 3630 : #endif
; 3631 :                 /* Decrement remaining count */
; 3632 :                 midawrem -= midawlen;
; 3633 : 
; 3634 :             }
; 3635 : 
; 3636 :             /* Increment to next MIDAW address */
; 3637 :             midawptr += 16;
; 3638 : 
; 3639 :         } /* end for(midawseq) */
; 3640 : 
; 3641 :         /* Channel program check if sum of MIDAW lengths
; 3642 :            did not exhaust the CCW count and no pending status */
; 3643 :         if (1
; 3644 :             && midawrem > 0
; 3645 :             && *chanstat != 0
; 3646 :             && !(prefetch->seq && prefetch->chanstat[ps])
; 3647 :         )
; 3648 :             set_chanstat( CSW_PROGC );
; 3649 : 
; 3650 :     } /* end if(CCW_FLAGS_MIDAW) */
; 3651 :     else
; 3652 : #endif /*defined(FEATURE_MIDAW_FACILITY)*/
; 3653 :     /* Move data when indirect data addressing is used */
; 3654 :     if (flags & CCW_FLAGS_IDA)

  00164	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR flags$[rsp]
  0016c	83 e0 04	 and	 eax, 4
  0016f	85 c0		 test	 eax, eax
  00171	0f 84 20 09 00
	00		 je	 $LN49@s390_copy_

; 3655 :     {
; 3656 :         if (prefetch->seq)

  00177	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  0017f	83 38 00	 cmp	 DWORD PTR [rax], 0
  00182	74 17		 je	 SHORT $LN51@s390_copy_

; 3657 :             prefetch->datalen[ps] = 0;

  00184	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00188	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00190	c7 84 81 10 05
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+1296], 0
$LN51@s390_copy_:

; 3658 : 
; 3659 :         idawaddr = addr;

  0019b	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  001a2	89 44 24 68	 mov	 DWORD PTR idawaddr$[rsp], eax

; 3660 :         idacount = count;

  001a6	0f b7 84 24 38
	01 00 00	 movzx	 eax, WORD PTR count$[rsp]
  001ae	66 89 44 24 5c	 mov	 WORD PTR idacount$[rsp], ax

; 3661 :         idasize = (idawfmt == PF_IDAW1) ? 4 : 8;

  001b3	0f b6 84 24 48
	01 00 00	 movzx	 eax, BYTE PTR idawfmt$[rsp]
  001bb	83 f8 01	 cmp	 eax, 1
  001be	75 0d		 jne	 SHORT $LN131@s390_copy_
  001c0	c7 84 24 80 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv141[rsp], 4
  001cb	eb 0b		 jmp	 SHORT $LN132@s390_copy_
$LN131@s390_copy_:
  001cd	c7 84 24 80 00
	00 00 08 00 00
	00		 mov	 DWORD PTR tv141[rsp], 8
$LN132@s390_copy_:
  001d8	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv141[rsp]
  001df	89 84 24 90 00
	00 00		 mov	 DWORD PTR idasize$[rsp], eax

; 3662 : 
; 3663 :         for (idaseq = 0;

  001e6	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR idaseq$[rsp], 0
  001ee	eb 0a		 jmp	 SHORT $LN10@s390_copy_
$LN8@s390_copy_:

; 3666 :                 !(prefetch->seq &&
; 3667 :                     (prefetch->chanstat[ps] ||
; 3668 :                         ((ps+1) < prefetch->seq &&
; 3669 :                             prefetch->chanstat[ps+1])));
; 3670 :              idaseq++)

  001f0	8b 44 24 78	 mov	 eax, DWORD PTR idaseq$[rsp]
  001f4	ff c0		 inc	 eax
  001f6	89 44 24 78	 mov	 DWORD PTR idaseq$[rsp], eax
$LN10@s390_copy_:

; 3664 :              idacount > 0 &&
; 3665 :                 chanstat != 0 &&

  001fa	0f b7 44 24 5c	 movzx	 eax, WORD PTR idacount$[rsp]
  001ff	85 c0		 test	 eax, eax
  00201	0f 8e 8b 08 00
	00		 jle	 $LN9@s390_copy_
  00207	48 83 bc 24 70
	01 00 00 00	 cmp	 QWORD PTR chanstat$[rsp], 0
  00210	0f 84 7c 08 00
	00		 je	 $LN9@s390_copy_
  00216	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  0021e	83 38 00	 cmp	 DWORD PTR [rax], 0
  00221	74 48		 je	 SHORT $LN52@s390_copy_
  00223	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00227	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  0022f	0f b6 44 01 10	 movzx	 eax, BYTE PTR [rcx+rax+16]
  00234	85 c0		 test	 eax, eax
  00236	0f 85 56 08 00
	00		 jne	 $LN9@s390_copy_
  0023c	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00240	ff c0		 inc	 eax
  00242	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  0024a	3b 01		 cmp	 eax, DWORD PTR [rcx]
  0024c	73 1d		 jae	 SHORT $LN53@s390_copy_
  0024e	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00252	ff c0		 inc	 eax
  00254	8b c0		 mov	 eax, eax
  00256	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  0025e	0f b6 44 01 10	 movzx	 eax, BYTE PTR [rcx+rax+16]
  00263	85 c0		 test	 eax, eax
  00265	0f 85 27 08 00
	00		 jne	 $LN9@s390_copy_
$LN53@s390_copy_:
$LN52@s390_copy_:
$LN13@s390_copy_:

; 3671 :         {
; 3672 :             /* Get new prefetch entry */
; 3673 :             get_new_prefetch_entry( idawfmt, idawaddr );

  0026b	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00273	83 38 00	 cmp	 DWORD PTR [rax], 0
  00276	0f 84 aa 00 00
	00		 je	 $LN54@s390_copy_
  0027c	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00284	8b 00		 mov	 eax, DWORD PTR [rax]
  00286	89 44 24 54	 mov	 DWORD PTR ps$[rsp], eax
  0028a	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00292	8b 00		 mov	 eax, DWORD PTR [rax]
  00294	ff c0		 inc	 eax
  00296	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  0029e	89 01		 mov	 DWORD PTR [rcx], eax
  002a0	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  002a8	81 38 00 01 00
	00		 cmp	 DWORD PTR [rax], 256	; 00000100H
  002ae	76 0d		 jbe	 SHORT $LN55@s390_copy_
  002b0	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  002b8	c6 00 08	 mov	 BYTE PTR [rax], 8
  002bb	eb 7e		 jmp	 SHORT $LN12@s390_copy_
$LN55@s390_copy_:
  002bd	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  002c1	ff c8		 dec	 eax
  002c3	8b c0		 mov	 eax, eax
  002c5	8b 4c 24 54	 mov	 ecx, DWORD PTR ps$[rsp]
  002c9	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR prefetch$[rsp]
  002d1	4c 8b 84 24 80
	01 00 00	 mov	 r8, QWORD PTR prefetch$[rsp]
  002d9	41 8b 84 80 10
	01 00 00	 mov	 eax, DWORD PTR [r8+rax*4+272]
  002e1	89 84 8a 10 01
	00 00		 mov	 DWORD PTR [rdx+rcx*4+272], eax
  002e8	0f b6 84 24 48
	01 00 00	 movzx	 eax, BYTE PTR idawfmt$[rsp]
  002f0	85 c0		 test	 eax, eax
  002f2	74 32		 je	 SHORT $LN56@s390_copy_
  002f4	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  002f8	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00300	0f b6 94 24 48
	01 00 00	 movzx	 edx, BYTE PTR idawfmt$[rsp]
  00308	88 94 01 10 18
	00 00		 mov	 BYTE PTR [rcx+rax+6160], dl
  0030f	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00313	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  0031b	8b 54 24 68	 mov	 edx, DWORD PTR idawaddr$[rsp]
  0031f	89 94 81 10 14
	00 00		 mov	 DWORD PTR [rcx+rax*4+5136], edx
$LN56@s390_copy_:
$LN54@s390_copy_:
  00326	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  0032e	c6 00 00	 mov	 BYTE PTR [rax], 0
  00331	33 c0		 xor	 eax, eax
  00333	85 c0		 test	 eax, eax
  00335	0f 85 30 ff ff
	ff		 jne	 $LN13@s390_copy_
$LN12@s390_copy_:

; 3674 : 
; 3675 :             if (*chanstat != 0)

  0033b	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00343	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00346	85 c0		 test	 eax, eax
  00348	74 05		 je	 SHORT $LN57@s390_copy_

; 3676 :                 break;

  0034a	e9 43 07 00 00	 jmp	 $LN9@s390_copy_
$LN57@s390_copy_:

; 3677 : 
; 3678 :             /* Fetch the IDAW and set IDA pointer and length */
; 3679 :             ARCH_DEP( fetch_idaw )( dev, code, ccwkey, idawfmt,

  0034f	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00357	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0035c	48 8d 44 24 50	 lea	 rax, QWORD PTR idalen$[rsp]
  00361	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00366	48 8d 44 24 70	 lea	 rax, QWORD PTR idadata$[rsp]
  0036b	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00370	8b 44 24 68	 mov	 eax, DWORD PTR idawaddr$[rsp]
  00374	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00378	8b 44 24 78	 mov	 eax, DWORD PTR idaseq$[rsp]
  0037c	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00380	0f b7 84 24 50
	01 00 00	 movzx	 eax, WORD PTR idapmask$[rsp]
  00388	66 89 44 24 20	 mov	 WORD PTR [rsp+32], ax
  0038d	44 0f b6 8c 24
	48 01 00 00	 movzx	 r9d, BYTE PTR idawfmt$[rsp]
  00396	44 0f b6 84 24
	40 01 00 00	 movzx	 r8d, BYTE PTR ccwkey$[rsp]
  0039f	0f b6 94 24 20
	01 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  003a7	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003af	e8 00 00 00 00	 call	 s390_fetch_idaw

; 3680 :                         idapmask, idaseq, idawaddr,
; 3681 :                         &idadata, &idalen, chanstat );
; 3682 : 
; 3683 :             /* Exit if fetch_idaw detected channel program check */
; 3684 :             if (prefetch->seq)

  003b4	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  003bc	83 38 00	 cmp	 DWORD PTR [rax], 0
  003bf	74 6d		 je	 SHORT $LN58@s390_copy_

; 3685 :             {
; 3686 :                 prefetch->dataaddr[ps] = idadata;

  003c1	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  003c5	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  003cd	48 8b 54 24 70	 mov	 rdx, QWORD PTR idadata$[rsp]
  003d2	48 89 94 c1 10
	09 00 00	 mov	 QWORD PTR [rcx+rax*8+2320], rdx

; 3687 :                 prefetch->datalen[ps]  = idalen;

  003da	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  003de	0f b7 4c 24 50	 movzx	 ecx, WORD PTR idalen$[rsp]
  003e3	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR prefetch$[rsp]
  003eb	89 8c 82 10 05
	00 00		 mov	 DWORD PTR [rdx+rax*4+1296], ecx

; 3688 : 
; 3689 :                 if (*chanstat != 0)

  003f2	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  003fa	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003fd	85 c0		 test	 eax, eax
  003ff	74 2b		 je	 SHORT $LN60@s390_copy_

; 3690 :                 {
; 3691 :                     prefetch->chanstat[ps] = *chanstat;

  00401	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00405	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  0040d	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR chanstat$[rsp]
  00415	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  00418	88 54 01 10	 mov	 BYTE PTR [rcx+rax+16], dl

; 3692 :                     *chanstat = 0;

  0041c	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00424	c6 00 00	 mov	 BYTE PTR [rax], 0

; 3693 :                     break;

  00427	e9 66 06 00 00	 jmp	 $LN9@s390_copy_
$LN60@s390_copy_:

; 3694 :                 }
; 3695 :             }

  0042c	eb 14		 jmp	 SHORT $LN59@s390_copy_
$LN58@s390_copy_:

; 3696 :             else if (*chanstat != 0)

  0042e	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00436	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00439	85 c0		 test	 eax, eax
  0043b	74 05		 je	 SHORT $LN61@s390_copy_

; 3697 :                 break;

  0043d	e9 50 06 00 00	 jmp	 $LN9@s390_copy_
$LN61@s390_copy_:
$LN59@s390_copy_:

; 3698 : 
; 3699 :             /* Channel protection check if IDAW data location is
; 3700 :                fetch protected, or if location is store protected
; 3701 :                and command is READ, READ BACKWARD, or SENSE */
; 3702 :             storkey = ARCH_DEP( get_dev_storage_key )( dev, idadata );

  00442	48 8b 54 24 70	 mov	 rdx, QWORD PTR idadata$[rsp]
  00447	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0044f	e8 00 00 00 00	 call	 s390_get_dev_storage_key
  00454	88 44 24 5a	 mov	 BYTE PTR storkey$[rsp], al

; 3703 : 
; 3704 :             if (1
; 3705 :                 && ccwkey != 0
; 3706 :                 && (storkey & STORKEY_KEY) != ccwkey
; 3707 :                 && ((storkey & STORKEY_FETCH) || to_memory)

  00458	33 c0		 xor	 eax, eax
  0045a	83 f8 01	 cmp	 eax, 1
  0045d	74 6d		 je	 SHORT $LN62@s390_copy_
  0045f	0f b6 84 24 40
	01 00 00	 movzx	 eax, BYTE PTR ccwkey$[rsp]
  00467	85 c0		 test	 eax, eax
  00469	74 61		 je	 SHORT $LN62@s390_copy_
  0046b	0f b6 44 24 5a	 movzx	 eax, BYTE PTR storkey$[rsp]
  00470	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00475	0f b6 8c 24 40
	01 00 00	 movzx	 ecx, BYTE PTR ccwkey$[rsp]
  0047d	3b c1		 cmp	 eax, ecx
  0047f	74 4b		 je	 SHORT $LN62@s390_copy_
  00481	0f b6 44 24 5a	 movzx	 eax, BYTE PTR storkey$[rsp]
  00486	83 e0 08	 and	 eax, 8
  00489	85 c0		 test	 eax, eax
  0048b	75 09		 jne	 SHORT $LN63@s390_copy_
  0048d	0f b6 44 24 58	 movzx	 eax, BYTE PTR to_memory$[rsp]
  00492	85 c0		 test	 eax, eax
  00494	74 36		 je	 SHORT $LN62@s390_copy_
$LN63@s390_copy_:
$LN16@s390_copy_:

; 3708 :             )
; 3709 :             {
; 3710 :                 set_chanstat(CSW_PROTC);

  00496	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  0049e	83 38 00	 cmp	 DWORD PTR [rax], 0
  004a1	74 13		 je	 SHORT $LN64@s390_copy_
  004a3	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  004a7	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  004af	c6 44 01 10 10	 mov	 BYTE PTR [rcx+rax+16], 16
  004b4	eb 0b		 jmp	 SHORT $LN65@s390_copy_
$LN64@s390_copy_:
  004b6	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  004be	c6 00 10	 mov	 BYTE PTR [rax], 16
$LN65@s390_copy_:
  004c1	33 c0		 xor	 eax, eax
  004c3	85 c0		 test	 eax, eax
  004c5	75 cf		 jne	 SHORT $LN16@s390_copy_

; 3711 :                 break;

  004c7	e9 c6 05 00 00	 jmp	 $LN9@s390_copy_
$LN62@s390_copy_:

; 3712 :             }
; 3713 : 
; 3714 :             /* Reduce length if less than one page remaining */
; 3715 :             if (idalen > idacount)

  004cc	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  004d1	0f b7 4c 24 5c	 movzx	 ecx, WORD PTR idacount$[rsp]
  004d6	3b c1		 cmp	 eax, ecx
  004d8	7e 2f		 jle	 SHORT $LN66@s390_copy_

; 3716 :             {
; 3717 :                 idalen = idacount;

  004da	0f b7 44 24 5c	 movzx	 eax, WORD PTR idacount$[rsp]
  004df	66 89 44 24 50	 mov	 WORD PTR idalen$[rsp], ax

; 3718 : 
; 3719 :                 if (prefetch->seq)

  004e4	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  004ec	83 38 00	 cmp	 DWORD PTR [rax], 0
  004ef	74 18		 je	 SHORT $LN67@s390_copy_

; 3720 :                    prefetch->datalen[ps] = idacount;

  004f1	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  004f5	0f b7 4c 24 5c	 movzx	 ecx, WORD PTR idacount$[rsp]
  004fa	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR prefetch$[rsp]
  00502	89 8c 82 10 05
	00 00		 mov	 DWORD PTR [rdx+rax*4+1296], ecx
$LN67@s390_copy_:
$LN66@s390_copy_:

; 3721 :             }
; 3722 : 
; 3723 :             /* Ensure memcpy will stay within buffer         */
; 3724 :             /* Channel data check if outside buffer          */
; 3725 :             /* SA22-7201-05:                                 */
; 3726 :             /*  p. 16-27, Channel-Data Check                 */
; 3727 :             if (readbackwards)

  00509	0f b6 44 24 59	 movzx	 eax, BYTE PTR readbackwards$[rsp]
  0050e	85 c0		 test	 eax, eax
  00510	0f 84 c6 00 00
	00		 je	 $LN68@s390_copy_

; 3728 :             {
; 3729 :                 iobufptr = iobuf + dev->curblkrem + idacount - idalen;

  00516	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0051e	8b 80 18 10 00
	00		 mov	 eax, DWORD PTR [rax+4120]
  00524	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0052c	48 03 c8	 add	 rcx, rax
  0052f	48 8b c1	 mov	 rax, rcx
  00532	0f b7 4c 24 5c	 movzx	 ecx, WORD PTR idacount$[rsp]
  00537	48 03 c1	 add	 rax, rcx
  0053a	0f b7 4c 24 50	 movzx	 ecx, WORD PTR idalen$[rsp]
  0053f	48 2b c1	 sub	 rax, rcx
  00542	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR iobufptr$[rsp], rax

; 3730 : 
; 3731 :                 if ((iobufptr + idalen) > (iobufend + 1) ||

  0054a	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  0054f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR iobufptr$[rsp]
  00557	48 03 c8	 add	 rcx, rax
  0055a	48 8b c1	 mov	 rax, rcx
  0055d	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR iobufend$[rsp]
  00565	48 ff c1	 inc	 rcx
  00568	48 3b c1	 cmp	 rax, rcx
  0056b	77 1d		 ja	 SHORT $LN71@s390_copy_
  0056d	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  00572	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR iobufptr$[rsp]
  0057a	48 03 c8	 add	 rcx, rax
  0057d	48 8b c1	 mov	 rax, rcx
  00580	48 3b 84 24 60
	01 00 00	 cmp	 rax, QWORD PTR iobufstart$[rsp]
  00588	77 10		 ja	 SHORT $LN70@s390_copy_
$LN71@s390_copy_:

; 3732 :                     (iobufptr + idalen) <= iobufstart)
; 3733 :                 {
; 3734 :                     *chanstat = CSW_CDC;

  0058a	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00592	c6 00 08	 mov	 BYTE PTR [rax], 8

; 3735 :                     return;

  00595	e9 16 0c 00 00	 jmp	 $LN1@s390_copy_
$LN70@s390_copy_:

; 3736 :                 }
; 3737 : 
; 3738 :                 if (iobufptr < iobufstart)

  0059a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR iobufstart$[rsp]
  005a2	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR iobufptr$[rsp], rax
  005aa	73 2b		 jae	 SHORT $LN72@s390_copy_

; 3739 :                 {
; 3740 :                     *chanstat = CSW_CDC;

  005ac	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  005b4	c6 00 08	 mov	 BYTE PTR [rax], 8

; 3741 : 
; 3742 :                     /* Reset length to copy to buffer */
; 3743 :                     idalen = iobufptr + idalen - iobufstart;

  005b7	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  005bc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR iobufptr$[rsp]
  005c4	48 03 c8	 add	 rcx, rax
  005c7	48 8b c1	 mov	 rax, rcx
  005ca	48 2b 84 24 60
	01 00 00	 sub	 rax, QWORD PTR iobufstart$[rsp]
  005d2	66 89 44 24 50	 mov	 WORD PTR idalen$[rsp], ax
$LN72@s390_copy_:

; 3744 :                 }
; 3745 :             }

  005d7	e9 45 02 00 00	 jmp	 $LN69@s390_copy_
$LN68@s390_copy_:

; 3746 :             else if (iobuf < iobufstart || iobuf > iobufend)

  005dc	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR iobufstart$[rsp]
  005e4	48 39 84 24 58
	01 00 00	 cmp	 QWORD PTR iobuf$[rsp], rax
  005ec	72 12		 jb	 SHORT $LN75@s390_copy_
  005ee	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR iobufend$[rsp]
  005f6	48 39 84 24 58
	01 00 00	 cmp	 QWORD PTR iobuf$[rsp], rax
  005fe	76 3b		 jbe	 SHORT $LN73@s390_copy_
$LN75@s390_copy_:
$LN19@s390_copy_:

; 3747 :             {
; 3748 :                 set_chanstat( CSW_CDC );

  00600	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00608	83 38 00	 cmp	 DWORD PTR [rax], 0
  0060b	74 13		 je	 SHORT $LN76@s390_copy_
  0060d	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00611	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00619	c6 44 01 10 08	 mov	 BYTE PTR [rcx+rax+16], 8
  0061e	eb 0b		 jmp	 SHORT $LN77@s390_copy_
$LN76@s390_copy_:
  00620	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00628	c6 00 08	 mov	 BYTE PTR [rax], 8
$LN77@s390_copy_:
  0062b	33 c0		 xor	 eax, eax
  0062d	85 c0		 test	 eax, eax
  0062f	75 cf		 jne	 SHORT $LN19@s390_copy_

; 3749 :                 break;

  00631	e9 5c 04 00 00	 jmp	 $LN9@s390_copy_

; 3750 :             }

  00636	e9 e6 01 00 00	 jmp	 $LN74@s390_copy_
$LN73@s390_copy_:

; 3751 :             else if ((iobuf + idalen) > (iobufend + 1))

  0063b	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  00640	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00648	48 03 c8	 add	 rcx, rax
  0064b	48 8b c1	 mov	 rax, rcx
  0064e	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR iobufend$[rsp]
  00656	48 ff c1	 inc	 rcx
  00659	48 3b c1	 cmp	 rax, rcx
  0065c	0f 86 bf 01 00
	00		 jbe	 $LN78@s390_copy_

; 3752 :             {
; 3753 :                 /* Reset length to copy to buffer */
; 3754 :                 idalen = iobufend - iobuf + 1;

  00662	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  0066a	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR iobufend$[rsp]
  00672	48 2b c8	 sub	 rcx, rax
  00675	48 8b c1	 mov	 rax, rcx
  00678	48 ff c0	 inc	 rax
  0067b	66 89 44 24 50	 mov	 WORD PTR idalen$[rsp], ax

; 3755 : 
; 3756 :                 if (prefetch->seq)

  00680	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00688	83 38 00	 cmp	 DWORD PTR [rax], 0
  0068b	0f 84 5f 01 00
	00		 je	 $LN79@s390_copy_

; 3757 :                 {
; 3758 :                     prefetch->datalen[ps] = idalen;

  00691	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00695	0f b7 4c 24 50	 movzx	 ecx, WORD PTR idalen$[rsp]
  0069a	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR prefetch$[rsp]
  006a2	89 8c 82 10 05
	00 00		 mov	 DWORD PTR [rdx+rax*4+1296], ecx
$LN22@s390_copy_:

; 3759 : 
; 3760 :                     /* Get new prefetch entry for channel data
; 3761 :                        check */
; 3762 :                     get_new_prefetch_entry( idawfmt, idawaddr );

  006a9	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  006b1	83 38 00	 cmp	 DWORD PTR [rax], 0
  006b4	0f 84 aa 00 00
	00		 je	 $LN81@s390_copy_
  006ba	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  006c2	8b 00		 mov	 eax, DWORD PTR [rax]
  006c4	89 44 24 54	 mov	 DWORD PTR ps$[rsp], eax
  006c8	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  006d0	8b 00		 mov	 eax, DWORD PTR [rax]
  006d2	ff c0		 inc	 eax
  006d4	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  006dc	89 01		 mov	 DWORD PTR [rcx], eax
  006de	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  006e6	81 38 00 01 00
	00		 cmp	 DWORD PTR [rax], 256	; 00000100H
  006ec	76 0d		 jbe	 SHORT $LN82@s390_copy_
  006ee	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  006f6	c6 00 08	 mov	 BYTE PTR [rax], 8
  006f9	eb 7e		 jmp	 SHORT $LN21@s390_copy_
$LN82@s390_copy_:
  006fb	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  006ff	ff c8		 dec	 eax
  00701	8b c0		 mov	 eax, eax
  00703	8b 4c 24 54	 mov	 ecx, DWORD PTR ps$[rsp]
  00707	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR prefetch$[rsp]
  0070f	4c 8b 84 24 80
	01 00 00	 mov	 r8, QWORD PTR prefetch$[rsp]
  00717	41 8b 84 80 10
	01 00 00	 mov	 eax, DWORD PTR [r8+rax*4+272]
  0071f	89 84 8a 10 01
	00 00		 mov	 DWORD PTR [rdx+rcx*4+272], eax
  00726	0f b6 84 24 48
	01 00 00	 movzx	 eax, BYTE PTR idawfmt$[rsp]
  0072e	85 c0		 test	 eax, eax
  00730	74 32		 je	 SHORT $LN83@s390_copy_
  00732	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00736	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  0073e	0f b6 94 24 48
	01 00 00	 movzx	 edx, BYTE PTR idawfmt$[rsp]
  00746	88 94 01 10 18
	00 00		 mov	 BYTE PTR [rcx+rax+6160], dl
  0074d	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00751	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00759	8b 54 24 68	 mov	 edx, DWORD PTR idawaddr$[rsp]
  0075d	89 94 81 10 14
	00 00		 mov	 DWORD PTR [rcx+rax*4+5136], edx
$LN83@s390_copy_:
$LN81@s390_copy_:
  00764	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  0076c	c6 00 00	 mov	 BYTE PTR [rax], 0
  0076f	33 c0		 xor	 eax, eax
  00771	85 c0		 test	 eax, eax
  00773	0f 85 30 ff ff
	ff		 jne	 $LN22@s390_copy_
$LN21@s390_copy_:

; 3763 : 
; 3764 :                     if (*chanstat != 0)

  00779	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00781	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00784	85 c0		 test	 eax, eax
  00786	74 05		 je	 SHORT $LN84@s390_copy_

; 3765 :                         break;

  00788	e9 05 03 00 00	 jmp	 $LN9@s390_copy_
$LN84@s390_copy_:

; 3766 : 
; 3767 :                     prefetch->dataaddr[ps] = idadata + idalen;

  0078d	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  00792	48 8b 4c 24 70	 mov	 rcx, QWORD PTR idadata$[rsp]
  00797	48 03 c8	 add	 rcx, rax
  0079a	48 8b c1	 mov	 rax, rcx
  0079d	8b 4c 24 54	 mov	 ecx, DWORD PTR ps$[rsp]
  007a1	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR prefetch$[rsp]
  007a9	48 89 84 ca 10
	09 00 00	 mov	 QWORD PTR [rdx+rcx*8+2320], rax

; 3768 :                     prefetch->datalen[ps]  = 1;

  007b1	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  007b5	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  007bd	c7 84 81 10 05
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+1296], 1

; 3769 :                     prefetch->chanstat[ps] = *chanstat = CSW_CDC;

  007c8	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  007d0	c6 00 08	 mov	 BYTE PTR [rax], 8
  007d3	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  007d7	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  007df	c6 44 01 10 08	 mov	 BYTE PTR [rcx+rax+16], 8

; 3770 : 
; 3771 :                     ps -= 1;

  007e4	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  007e8	ff c8		 dec	 eax
  007ea	89 44 24 54	 mov	 DWORD PTR ps$[rsp], eax

; 3772 :                 }

  007ee	eb 31		 jmp	 SHORT $LN80@s390_copy_
$LN79@s390_copy_:
$LN25@s390_copy_:

; 3773 : 
; 3774 :                 /* Set channel data check and permit copy to/from
; 3775 :                    end-of-buffer */
; 3776 :                 else
; 3777 :                     set_chanstat( CSW_CDC );

  007f0	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  007f8	83 38 00	 cmp	 DWORD PTR [rax], 0
  007fb	74 13		 je	 SHORT $LN85@s390_copy_
  007fd	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00801	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00809	c6 44 01 10 08	 mov	 BYTE PTR [rcx+rax+16], 8
  0080e	eb 0b		 jmp	 SHORT $LN86@s390_copy_
$LN85@s390_copy_:
  00810	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00818	c6 00 08	 mov	 BYTE PTR [rax], 8
$LN86@s390_copy_:
  0081b	33 c0		 xor	 eax, eax
  0081d	85 c0		 test	 eax, eax
  0081f	75 cf		 jne	 SHORT $LN25@s390_copy_
$LN80@s390_copy_:
$LN78@s390_copy_:
$LN74@s390_copy_:
$LN69@s390_copy_:

; 3778 :             }
; 3779 : 
; 3780 :             /* Copy to I/O buffer */
; 3781 :             if (idalen)

  00821	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  00826	85 c0		 test	 eax, eax
  00828	0f 84 6b 01 00
	00		 je	 $LN87@s390_copy_

; 3782 :             {
; 3783 :                 /* Set the main storage reference and change bits */
; 3784 :                 if (to_memory)

  0082e	0f b6 44 24 58	 movzx	 eax, BYTE PTR to_memory$[rsp]
  00833	85 c0		 test	 eax, eax
  00835	74 17		 je	 SHORT $LN88@s390_copy_

; 3785 :                     ARCH_DEP( or_dev_storage_key )( dev, idadata, (STORKEY_REF | STORKEY_CHANGE) );

  00837	41 b0 06	 mov	 r8b, 6
  0083a	48 8b 54 24 70	 mov	 rdx, QWORD PTR idadata$[rsp]
  0083f	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00847	e8 00 00 00 00	 call	 s390_or_dev_storage_key
  0084c	eb 15		 jmp	 SHORT $LN89@s390_copy_
$LN88@s390_copy_:

; 3786 :                 else
; 3787 :                     ARCH_DEP( or_dev_storage_key )( dev, idadata, STORKEY_REF );

  0084e	41 b0 04	 mov	 r8b, 4
  00851	48 8b 54 24 70	 mov	 rdx, QWORD PTR idadata$[rsp]
  00856	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0085e	e8 00 00 00 00	 call	 s390_or_dev_storage_key
$LN89@s390_copy_:

; 3788 : 
; 3789 :                 /* Copy data between main storage and channel buffer */
; 3790 :                 if (readbackwards)

  00863	0f b6 44 24 59	 movzx	 eax, BYTE PTR readbackwards$[rsp]
  00868	85 c0		 test	 eax, eax
  0086a	0f 84 98 00 00
	00		 je	 $LN90@s390_copy_

; 3791 :                 {
; 3792 :                     idadata = (idadata - idalen) + 1;

  00870	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  00875	48 8b 4c 24 70	 mov	 rcx, QWORD PTR idadata$[rsp]
  0087a	48 2b c8	 sub	 rcx, rax
  0087d	48 8b c1	 mov	 rax, rcx
  00880	48 ff c0	 inc	 rax
  00883	48 89 44 24 70	 mov	 QWORD PTR idadata$[rsp], rax

; 3793 :                     memcpy_backwards( dev->mainstor + idadata,

  00888	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  0088d	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00895	8b 89 18 10 00
	00		 mov	 ecx, DWORD PTR [rcx+4120]
  0089b	48 8b 94 24 58
	01 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  008a3	48 03 d1	 add	 rdx, rcx
  008a6	48 8b ca	 mov	 rcx, rdx
  008a9	0f b7 54 24 5c	 movzx	 edx, WORD PTR idacount$[rsp]
  008ae	48 03 ca	 add	 rcx, rdx
  008b1	0f b7 54 24 50	 movzx	 edx, WORD PTR idalen$[rsp]
  008b6	48 2b ca	 sub	 rcx, rdx
  008b9	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  008c1	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  008c8	48 03 54 24 70	 add	 rdx, QWORD PTR idadata$[rsp]
  008cd	48 89 94 24 e0
	00 00 00	 mov	 QWORD PTR tv377[rsp], rdx
  008d5	44 8b c0	 mov	 r8d, eax
  008d8	48 8b d1	 mov	 rdx, rcx
  008db	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv377[rsp]
  008e3	48 8b c8	 mov	 rcx, rax
  008e6	e8 00 00 00 00	 call	 memcpy_backwards

; 3794 :                                       iobuf + dev->curblkrem + idacount - idalen,
; 3795 :                                       idalen );
; 3796 : 
; 3797 :                     /* Decrement buffer pointer for next IDAW*/
; 3798 :                     iobuf -= idalen;

  008eb	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  008f0	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  008f8	48 2b c8	 sub	 rcx, rax
  008fb	48 8b c1	 mov	 rax, rcx
  008fe	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR iobuf$[rsp], rax

; 3799 :                 }

  00906	eb 76		 jmp	 SHORT $LN91@s390_copy_
$LN90@s390_copy_:

; 3800 :                 else
; 3801 :                 {
; 3802 :                     if (to_iobuf)

  00908	0f b6 44 24 5b	 movzx	 eax, BYTE PTR to_iobuf$[rsp]
  0090d	85 c0		 test	 eax, eax
  0090f	74 2a		 je	 SHORT $LN92@s390_copy_

; 3803 :                     {
; 3804 :                         memcpy( iobuf, dev->mainstor + idadata, idalen );

  00911	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  00916	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0091e	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00925	48 03 4c 24 70	 add	 rcx, QWORD PTR idadata$[rsp]
  0092a	48 8b bc 24 58
	01 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  00932	48 8b f1	 mov	 rsi, rcx
  00935	8b c8		 mov	 ecx, eax
  00937	f3 a4		 rep movsb

; 3805 :                     }

  00939	eb 28		 jmp	 SHORT $LN93@s390_copy_
$LN92@s390_copy_:

; 3806 :                     else
; 3807 :                     {
; 3808 :                         memcpy( dev->mainstor + idadata, iobuf, idalen );

  0093b	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  00940	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00948	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  0094f	48 03 4c 24 70	 add	 rcx, QWORD PTR idadata$[rsp]
  00954	48 8b f9	 mov	 rdi, rcx
  00957	48 8b b4 24 58
	01 00 00	 mov	 rsi, QWORD PTR iobuf$[rsp]
  0095f	8b c8		 mov	 ecx, eax
  00961	f3 a4		 rep movsb
$LN93@s390_copy_:

; 3809 :                     }
; 3810 : 
; 3811 :                     /* Increment buffer pointer for next IDAW*/
; 3812 :                     iobuf += idalen;

  00963	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  00968	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00970	48 03 c8	 add	 rcx, rax
  00973	48 8b c1	 mov	 rax, rcx
  00976	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR iobuf$[rsp], rax
$LN91@s390_copy_:

; 3813 :                 }
; 3814 : 
; 3815 :                 /* Update prefetch completed bytes */
; 3816 :                 prefetch->pos += idalen;

  0097e	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  00983	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  0098b	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  0098e	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00996	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN87@s390_copy_:

; 3817 :             }
; 3818 : 
; 3819 :             /* If not prefetch, display the IDAW if CCW tracing */
; 3820 :             if (!prefetch->seq && dev->ccwtrace)

  00999	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  009a1	83 38 00	 cmp	 DWORD PTR [rax], 0
  009a4	0f 85 bd 00 00
	00		 jne	 $LN94@s390_copy_
  009aa	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  009b2	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  009b8	c1 e8 0f	 shr	 eax, 15
  009bb	83 e0 01	 and	 eax, 1
  009be	85 c0		 test	 eax, eax
  009c0	0f 84 a1 00 00
	00		 je	 $LN94@s390_copy_

; 3821 :             {
; 3822 :                 /* Trace the CCW first, then the IDAW, but only
; 3823 :                    if this is a read type CCW as determined by
; 3824 :                    the direction of the copying. (For write type
; 3825 :                    CCws, channel code properly traces CCWs before
; 3826 :                    we're even called.)
; 3827 :                 */
; 3828 :                 if (to_memory)

  009c6	0f b6 44 24 58	 movzx	 eax, BYTE PTR to_memory$[rsp]
  009cb	85 c0		 test	 eax, eax
  009cd	74 51		 je	 SHORT $LN95@s390_copy_

; 3829 :                     DISPLAY_CCW( dev, ccw, addr, count, flags );

  009cf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG182304
  009d6	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  009db	c7 44 24 30 f5
	0e 00 00	 mov	 DWORD PTR [rsp+48], 3829 ; 00000ef5H
  009e3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG182305
  009ea	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  009ef	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR flags$[rsp]
  009f7	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  009fb	44 8b 8c 24 38
	01 00 00	 mov	 r9d, DWORD PTR count$[rsp]
  00a03	44 8b 84 24 30
	01 00 00	 mov	 r8d, DWORD PTR addr$[rsp]
  00a0b	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR ccw$[rsp]
  00a13	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a1b	e8 00 00 00 00	 call	 _display_ccw
$LN95@s390_copy_:

; 3830 :                 DISPLAY_IDAW( dev, idawfmt, 0, idadata, idalen );

  00a20	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG182306
  00a27	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00a2c	c7 44 24 30 f6
	0e 00 00	 mov	 DWORD PTR [rsp+48], 3830 ; 00000ef6H
  00a34	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG182307
  00a3b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00a40	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  00a45	66 89 44 24 20	 mov	 WORD PTR [rsp+32], ax
  00a4a	4c 8b 4c 24 70	 mov	 r9, QWORD PTR idadata$[rsp]
  00a4f	45 33 c0	 xor	 r8d, r8d
  00a52	0f b6 94 24 48
	01 00 00	 movzx	 edx, BYTE PTR idawfmt$[rsp]
  00a5a	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a62	e8 00 00 00 00	 call	 _display_idaw
$LN94@s390_copy_:

; 3831 :             }
; 3832 : 
; 3833 : #if DEBUG_DUMP
; 3834 :             if (dev->ccwtrace)
; 3835 :             {
; 3836 :                 if (to_memory)
; 3837 :                     DUMP( "iobuf:", iobuf-idalen, idalen );
; 3838 :                 DUMP_STORAGE( "Storage:", idadata, idalen );
; 3839 :                 if (to_iobuf)
; 3840 :                     DUMP( "iobuf:", iobuf-idalen, idalen );
; 3841 :             }
; 3842 : #endif
; 3843 :             /* Decrement remaining count, increment buffer pointer */
; 3844 :             idacount -= idalen;

  00a67	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  00a6c	0f b7 4c 24 5c	 movzx	 ecx, WORD PTR idacount$[rsp]
  00a71	2b c8		 sub	 ecx, eax
  00a73	8b c1		 mov	 eax, ecx
  00a75	66 89 44 24 5c	 mov	 WORD PTR idacount$[rsp], ax

; 3845 : 
; 3846 :             /* Increment to next IDAW address */
; 3847 :             idawaddr += idasize;

  00a7a	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idasize$[rsp]
  00a81	8b 4c 24 68	 mov	 ecx, DWORD PTR idawaddr$[rsp]
  00a85	03 c8		 add	 ecx, eax
  00a87	8b c1		 mov	 eax, ecx
  00a89	89 44 24 68	 mov	 DWORD PTR idawaddr$[rsp], eax

; 3848 : 
; 3849 :         } /* end for(idaseq) */

  00a8d	e9 5e f7 ff ff	 jmp	 $LN8@s390_copy_
$LN9@s390_copy_:

; 3850 :     }

  00a92	e9 19 07 00 00	 jmp	 $LN50@s390_copy_
$LN49@s390_copy_:

; 3851 :     else                              /* Non-IDA data addressing */
; 3852 :     {
; 3853 :         /* Point to start of data for read backward command */
; 3854 :         if (readbackwards)

  00a97	0f b6 44 24 59	 movzx	 eax, BYTE PTR readbackwards$[rsp]
  00a9c	85 c0		 test	 eax, eax
  00a9e	74 1b		 je	 SHORT $LN96@s390_copy_

; 3855 :             addr = addr - (count - 1);

  00aa0	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00aa7	ff c8		 dec	 eax
  00aa9	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00ab0	2b c8		 sub	 ecx, eax
  00ab2	8b c1		 mov	 eax, ecx
  00ab4	89 84 24 30 01
	00 00		 mov	 DWORD PTR addr$[rsp], eax
$LN96@s390_copy_:

; 3856 : 
; 3857 :         /* Channel protection check if any data is fetch protected,
; 3858 :            or if location is store protected and command is READ,
; 3859 :            READ BACKWARD, or SENSE.
; 3860 :         */
; 3861 :         startpage = addr;

  00abb	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00ac2	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR startpage$[rsp], rax

; 3862 :         endpage = addr + (count - 1);

  00aca	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00ad1	8b 8c 24 38 01
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  00ad8	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00adc	8b c0		 mov	 eax, eax
  00ade	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR endpage$[rsp], rax

; 3863 : 
; 3864 :         for (page = startpage & STORAGE_KEY_PAGEMASK;

  00ae6	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR startpage$[rsp]
  00aee	48 25 00 f0 ff
	7f		 and	 rax, 2147479552		; 7ffff000H
  00af4	48 89 44 24 60	 mov	 QWORD PTR page$[rsp], rax
  00af9	eb 10		 jmp	 SHORT $LN28@s390_copy_
$LN26@s390_copy_:

; 3866 :              page += STORAGE_KEY_PAGESIZE)

  00afb	48 8b 44 24 60	 mov	 rax, QWORD PTR page$[rsp]
  00b00	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00b06	48 89 44 24 60	 mov	 QWORD PTR page$[rsp], rax
$LN28@s390_copy_:

; 3865 :              page <= (endpage | STORAGE_KEY_BYTEMASK);

  00b0b	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR endpage$[rsp]
  00b13	48 0d ff 0f 00
	00		 or	 rax, 4095		; 00000fffH
  00b19	48 39 44 24 60	 cmp	 QWORD PTR page$[rsp], rax
  00b1e	0f 87 88 03 00
	00		 ja	 $LN27@s390_copy_

; 3867 :         {
; 3868 :             /* Channel program check if data is outside main storage */
; 3869 :             if (CHADDRCHK( page, dev ))

  00b24	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b2c	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00b33	48 39 44 24 60	 cmp	 QWORD PTR page$[rsp], rax
  00b38	77 70		 ja	 SHORT $LN98@s390_copy_
  00b3a	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b42	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  00b49	83 e0 10	 and	 eax, 16
  00b4c	85 c0		 test	 eax, eax
  00b4e	0f 84 97 00 00
	00		 je	 $LN97@s390_copy_
  00b54	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b5c	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00b63	83 e0 20	 and	 eax, 32			; 00000020H
  00b66	85 c0		 test	 eax, eax
  00b68	74 15		 je	 SHORT $LN100@s390_copy_
  00b6a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b71	48 8b 80 60 12
	00 00		 mov	 rax, QWORD PTR [rax+4704]
  00b78	48 39 44 24 60	 cmp	 QWORD PTR page$[rsp], rax
  00b7d	72 2b		 jb	 SHORT $LN99@s390_copy_
$LN100@s390_copy_:
  00b7f	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b87	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00b8e	83 e0 40	 and	 eax, 64			; 00000040H
  00b91	85 c0		 test	 eax, eax
  00b93	74 56		 je	 SHORT $LN97@s390_copy_
  00b95	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b9c	48 8b 80 60 12
	00 00		 mov	 rax, QWORD PTR [rax+4704]
  00ba3	48 39 44 24 60	 cmp	 QWORD PTR page$[rsp], rax
  00ba8	72 41		 jb	 SHORT $LN97@s390_copy_
$LN99@s390_copy_:
$LN98@s390_copy_:

; 3870 :             {
; 3871 :                 if (prefetch->seq)

  00baa	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00bb2	83 38 00	 cmp	 DWORD PTR [rax], 0
  00bb5	74 16		 je	 SHORT $LN101@s390_copy_

; 3872 :                 {
; 3873 :                     prefetch->chanstat[ps] = CSW_PROGC;

  00bb7	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00bbb	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00bc3	c6 44 01 10 20	 mov	 BYTE PTR [rcx+rax+16], 32 ; 00000020H

; 3874 :                     break;

  00bc8	e9 df 02 00 00	 jmp	 $LN27@s390_copy_
$LN101@s390_copy_:

; 3875 :                 }
; 3876 : 
; 3877 :                 *chanstat = CSW_PROGC;

  00bcd	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00bd5	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3878 : 
; 3879 :                 if (readbackwards)

  00bd8	0f b6 44 24 59	 movzx	 eax, BYTE PTR readbackwards$[rsp]
  00bdd	85 c0		 test	 eax, eax
  00bdf	74 05		 je	 SHORT $LN102@s390_copy_

; 3880 :                     return;

  00be1	e9 ca 05 00 00	 jmp	 $LN1@s390_copy_
$LN102@s390_copy_:

; 3881 : 
; 3882 :                 break;

  00be6	e9 c1 02 00 00	 jmp	 $LN27@s390_copy_
$LN97@s390_copy_:

; 3883 :             }
; 3884 : 
; 3885 :             storkey = ARCH_DEP( get_dev_storage_key )( dev, page );

  00beb	48 8b 54 24 60	 mov	 rdx, QWORD PTR page$[rsp]
  00bf0	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00bf8	e8 00 00 00 00	 call	 s390_get_dev_storage_key
  00bfd	88 44 24 5a	 mov	 BYTE PTR storkey$[rsp], al

; 3886 : 
; 3887 :             if (1
; 3888 :                 && ccwkey != 0
; 3889 :                 && (storkey & STORKEY_KEY) != ccwkey
; 3890 :                 && ((storkey & STORKEY_FETCH) || to_memory)

  00c01	33 c0		 xor	 eax, eax
  00c03	83 f8 01	 cmp	 eax, 1
  00c06	0f 84 9b 02 00
	00		 je	 $LN103@s390_copy_
  00c0c	0f b6 84 24 40
	01 00 00	 movzx	 eax, BYTE PTR ccwkey$[rsp]
  00c14	85 c0		 test	 eax, eax
  00c16	0f 84 8b 02 00
	00		 je	 $LN103@s390_copy_
  00c1c	0f b6 44 24 5a	 movzx	 eax, BYTE PTR storkey$[rsp]
  00c21	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00c26	0f b6 8c 24 40
	01 00 00	 movzx	 ecx, BYTE PTR ccwkey$[rsp]
  00c2e	3b c1		 cmp	 eax, ecx
  00c30	0f 84 71 02 00
	00		 je	 $LN103@s390_copy_
  00c36	0f b6 44 24 5a	 movzx	 eax, BYTE PTR storkey$[rsp]
  00c3b	83 e0 08	 and	 eax, 8
  00c3e	85 c0		 test	 eax, eax
  00c40	75 0d		 jne	 SHORT $LN104@s390_copy_
  00c42	0f b6 44 24 58	 movzx	 eax, BYTE PTR to_memory$[rsp]
  00c47	85 c0		 test	 eax, eax
  00c49	0f 84 58 02 00
	00		 je	 $LN103@s390_copy_
$LN104@s390_copy_:

; 3891 :             )
; 3892 :             {
; 3893 :                 if (readbackwards)

  00c4f	0f b6 44 24 59	 movzx	 eax, BYTE PTR readbackwards$[rsp]
  00c54	85 c0		 test	 eax, eax
  00c56	74 5b		 je	 SHORT $LN105@s390_copy_

; 3894 :                 {
; 3895 :                     *residual = MAX( page, addr ) - addr;

  00c58	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00c5f	48 39 44 24 60	 cmp	 QWORD PTR page$[rsp], rax
  00c64	76 0f		 jbe	 SHORT $LN133@s390_copy_
  00c66	48 8b 44 24 60	 mov	 rax, QWORD PTR page$[rsp]
  00c6b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv492[rsp], rax
  00c73	eb 0f		 jmp	 SHORT $LN134@s390_copy_
$LN133@s390_copy_:
  00c75	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00c7c	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv492[rsp], rax
$LN134@s390_copy_:
  00c84	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00c8b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv492[rsp]
  00c93	48 2b c8	 sub	 rcx, rax
  00c96	48 8b c1	 mov	 rax, rcx
  00c99	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00ca1	89 01		 mov	 DWORD PTR [rcx], eax

; 3896 :                     *chanstat = CSW_PROTC;

  00ca3	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00cab	c6 00 10	 mov	 BYTE PTR [rax], 16

; 3897 :                     break;

  00cae	e9 f9 01 00 00	 jmp	 $LN27@s390_copy_
$LN105@s390_copy_:

; 3898 :                 }
; 3899 : 
; 3900 :                 /* Calculate residual */
; 3901 :                 *residual = count - (MAX( page, addr ) - addr);

  00cb3	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00cba	48 39 44 24 60	 cmp	 QWORD PTR page$[rsp], rax
  00cbf	76 0f		 jbe	 SHORT $LN135@s390_copy_
  00cc1	48 8b 44 24 60	 mov	 rax, QWORD PTR page$[rsp]
  00cc6	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv500[rsp], rax
  00cce	eb 0f		 jmp	 SHORT $LN136@s390_copy_
$LN135@s390_copy_:
  00cd0	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00cd7	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv500[rsp], rax
$LN136@s390_copy_:
  00cdf	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00ce6	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00ced	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR tv500[rsp]
  00cf5	48 2b d1	 sub	 rdx, rcx
  00cf8	48 8b ca	 mov	 rcx, rdx
  00cfb	48 2b c1	 sub	 rax, rcx
  00cfe	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00d06	89 01		 mov	 DWORD PTR [rcx], eax

; 3902 : 
; 3903 :                 /* Handle prefetch */
; 3904 :                 if (prefetch->seq)

  00d08	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00d10	83 38 00	 cmp	 DWORD PTR [rax], 0
  00d13	0f 84 81 01 00
	00		 je	 $LN106@s390_copy_

; 3905 :                 {
; 3906 :                     prefetch->datalen[ps] = MAX( page, addr ) - addr;

  00d19	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00d20	48 39 44 24 60	 cmp	 QWORD PTR page$[rsp], rax
  00d25	76 0f		 jbe	 SHORT $LN137@s390_copy_
  00d27	48 8b 44 24 60	 mov	 rax, QWORD PTR page$[rsp]
  00d2c	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv514[rsp], rax
  00d34	eb 0f		 jmp	 SHORT $LN138@s390_copy_
$LN137@s390_copy_:
  00d36	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00d3d	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv514[rsp], rax
$LN138@s390_copy_:
  00d45	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00d4c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv514[rsp]
  00d54	48 2b c8	 sub	 rcx, rax
  00d57	48 8b c1	 mov	 rax, rcx
  00d5a	8b 4c 24 54	 mov	 ecx, DWORD PTR ps$[rsp]
  00d5e	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR prefetch$[rsp]
  00d66	89 84 8a 10 05
	00 00		 mov	 DWORD PTR [rdx+rcx*4+1296], eax

; 3907 : 
; 3908 :                     if (*residual)

  00d6d	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  00d75	83 38 00	 cmp	 DWORD PTR [rax], 0
  00d78	0f 84 09 01 00
	00		 je	 $LN107@s390_copy_
$LN31@s390_copy_:

; 3909 :                     {
; 3910 :                         /* Split entry */
; 3911 :                         get_new_prefetch_entry( PF_NO_IDAW, page );

  00d7e	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00d86	83 38 00	 cmp	 DWORD PTR [rax], 0
  00d89	0f 84 9c 00 00
	00		 je	 $LN108@s390_copy_
  00d8f	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00d97	8b 00		 mov	 eax, DWORD PTR [rax]
  00d99	89 44 24 54	 mov	 DWORD PTR ps$[rsp], eax
  00d9d	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00da5	8b 00		 mov	 eax, DWORD PTR [rax]
  00da7	ff c0		 inc	 eax
  00da9	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00db1	89 01		 mov	 DWORD PTR [rcx], eax
  00db3	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00dbb	81 38 00 01 00
	00		 cmp	 DWORD PTR [rax], 256	; 00000100H
  00dc1	76 0d		 jbe	 SHORT $LN109@s390_copy_
  00dc3	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00dcb	c6 00 08	 mov	 BYTE PTR [rax], 8
  00dce	eb 70		 jmp	 SHORT $LN30@s390_copy_
$LN109@s390_copy_:
  00dd0	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00dd4	ff c8		 dec	 eax
  00dd6	8b c0		 mov	 eax, eax
  00dd8	8b 4c 24 54	 mov	 ecx, DWORD PTR ps$[rsp]
  00ddc	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR prefetch$[rsp]
  00de4	48 8b bc 24 80
	01 00 00	 mov	 rdi, QWORD PTR prefetch$[rsp]
  00dec	8b 84 87 10 01
	00 00		 mov	 eax, DWORD PTR [rdi+rax*4+272]
  00df3	89 84 8a 10 01
	00 00		 mov	 DWORD PTR [rdx+rcx*4+272], eax
  00dfa	33 c0		 xor	 eax, eax
  00dfc	85 c0		 test	 eax, eax
  00dfe	74 2b		 je	 SHORT $LN110@s390_copy_
  00e00	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00e04	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00e0c	c6 84 01 10 18
	00 00 00	 mov	 BYTE PTR [rcx+rax+6160], 0
  00e14	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00e18	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00e20	8b 54 24 60	 mov	 edx, DWORD PTR page$[rsp]
  00e24	89 94 81 10 14
	00 00		 mov	 DWORD PTR [rcx+rax*4+5136], edx
$LN110@s390_copy_:
$LN108@s390_copy_:
  00e2b	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00e33	c6 00 00	 mov	 BYTE PTR [rax], 0
  00e36	33 c0		 xor	 eax, eax
  00e38	85 c0		 test	 eax, eax
  00e3a	0f 85 3e ff ff
	ff		 jne	 $LN31@s390_copy_
$LN30@s390_copy_:

; 3912 : 
; 3913 :                         if (*chanstat != 0)

  00e40	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00e48	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00e4b	85 c0		 test	 eax, eax
  00e4d	74 02		 je	 SHORT $LN111@s390_copy_

; 3914 :                             break;

  00e4f	eb 5b		 jmp	 SHORT $LN27@s390_copy_
$LN111@s390_copy_:

; 3915 : 
; 3916 :                         prefetch->dataaddr[ps] = page;

  00e51	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00e55	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00e5d	48 8b 54 24 60	 mov	 rdx, QWORD PTR page$[rsp]
  00e62	48 89 94 c1 10
	09 00 00	 mov	 QWORD PTR [rcx+rax*8+2320], rdx

; 3917 :                         prefetch->datalen[ps] = *residual;

  00e6a	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00e6e	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00e76	48 8b 94 24 78
	01 00 00	 mov	 rdx, QWORD PTR residual$[rsp]
  00e7e	8b 12		 mov	 edx, DWORD PTR [rdx]
  00e80	89 94 81 10 05
	00 00		 mov	 DWORD PTR [rcx+rax*4+1296], edx
$LN107@s390_copy_:

; 3918 :                     }
; 3919 : 
; 3920 :                     prefetch->chanstat[ps] = CSW_PROTC;

  00e87	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00e8b	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00e93	c6 44 01 10 10	 mov	 BYTE PTR [rcx+rax+16], 16

; 3921 :                     break;

  00e98	eb 12		 jmp	 SHORT $LN27@s390_copy_
$LN106@s390_copy_:

; 3922 :                 }
; 3923 : 
; 3924 :                 *chanstat = CSW_PROTC;

  00e9a	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00ea2	c6 00 10	 mov	 BYTE PTR [rax], 16

; 3925 :                 break;

  00ea5	eb 05		 jmp	 SHORT $LN27@s390_copy_
$LN103@s390_copy_:

; 3926 :             }
; 3927 : 
; 3928 :         } /* end for(page) */

  00ea7	e9 4f fc ff ff	 jmp	 $LN26@s390_copy_
$LN27@s390_copy_:

; 3929 : 
; 3930 :         /* Adjust local count for copy to main storage */
; 3931 :         count = MIN( count, MAX( page, addr ) - addr );

  00eac	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00eb3	48 39 44 24 60	 cmp	 QWORD PTR page$[rsp], rax
  00eb8	76 0f		 jbe	 SHORT $LN139@s390_copy_
  00eba	48 8b 44 24 60	 mov	 rax, QWORD PTR page$[rsp]
  00ebf	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv564[rsp], rax
  00ec7	eb 0f		 jmp	 SHORT $LN140@s390_copy_
$LN139@s390_copy_:
  00ec9	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00ed0	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv564[rsp], rax
$LN140@s390_copy_:
  00ed8	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00edf	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00ee6	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR tv564[rsp]
  00eee	48 2b d1	 sub	 rdx, rcx
  00ef1	48 8b ca	 mov	 rcx, rdx
  00ef4	48 3b c1	 cmp	 rax, rcx
  00ef7	73 11		 jae	 SHORT $LN143@s390_copy_
  00ef9	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00f00	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv575[rsp], rax
  00f08	eb 49		 jmp	 SHORT $LN144@s390_copy_
$LN143@s390_copy_:
  00f0a	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00f11	48 39 44 24 60	 cmp	 QWORD PTR page$[rsp], rax
  00f16	76 0f		 jbe	 SHORT $LN141@s390_copy_
  00f18	48 8b 44 24 60	 mov	 rax, QWORD PTR page$[rsp]
  00f1d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv572[rsp], rax
  00f25	eb 0f		 jmp	 SHORT $LN142@s390_copy_
$LN141@s390_copy_:
  00f27	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00f2e	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv572[rsp], rax
$LN142@s390_copy_:
  00f36	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00f3d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv572[rsp]
  00f45	48 2b c8	 sub	 rcx, rax
  00f48	48 8b c1	 mov	 rax, rcx
  00f4b	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv575[rsp], rax
$LN144@s390_copy_:
  00f53	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR tv575[rsp]
  00f5a	89 84 24 38 01
	00 00		 mov	 DWORD PTR count$[rsp], eax

; 3932 : 
; 3933 :         /* Count may be zero during prefetch operations */
; 3934 :         if (count)

  00f61	83 bc 24 38 01
	00 00 00	 cmp	 DWORD PTR count$[rsp], 0
  00f69	0f 84 41 02 00
	00		 je	 $LN112@s390_copy_

; 3935 :         {
; 3936 :             /* Set the main storage reference and change bits */
; 3937 :             for (page = startpage & STORAGE_KEY_PAGEMASK;

  00f6f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR startpage$[rsp]
  00f77	48 25 00 f0 ff
	7f		 and	 rax, 2147479552		; 7ffff000H
  00f7d	48 89 44 24 60	 mov	 QWORD PTR page$[rsp], rax
  00f82	eb 10		 jmp	 SHORT $LN34@s390_copy_
$LN32@s390_copy_:

; 3939 :                  page += STORAGE_KEY_PAGESIZE)

  00f84	48 8b 44 24 60	 mov	 rax, QWORD PTR page$[rsp]
  00f89	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00f8f	48 89 44 24 60	 mov	 QWORD PTR page$[rsp], rax
$LN34@s390_copy_:

; 3938 :                  page <= (endpage | STORAGE_KEY_BYTEMASK);

  00f94	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR endpage$[rsp]
  00f9c	48 0d ff 0f 00
	00		 or	 rax, 4095		; 00000fffH
  00fa2	48 39 44 24 60	 cmp	 QWORD PTR page$[rsp], rax
  00fa7	77 37		 ja	 SHORT $LN33@s390_copy_

; 3940 :             {
; 3941 :                 if (to_memory)

  00fa9	0f b6 44 24 58	 movzx	 eax, BYTE PTR to_memory$[rsp]
  00fae	85 c0		 test	 eax, eax
  00fb0	74 17		 je	 SHORT $LN113@s390_copy_

; 3942 :                     ARCH_DEP( or_dev_storage_key )( dev, page, (STORKEY_REF | STORKEY_CHANGE) );

  00fb2	41 b0 06	 mov	 r8b, 6
  00fb5	48 8b 54 24 60	 mov	 rdx, QWORD PTR page$[rsp]
  00fba	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00fc2	e8 00 00 00 00	 call	 s390_or_dev_storage_key
  00fc7	eb 15		 jmp	 SHORT $LN114@s390_copy_
$LN113@s390_copy_:

; 3943 :                 else
; 3944 :                     ARCH_DEP( or_dev_storage_key )( dev, page, STORKEY_REF );

  00fc9	41 b0 04	 mov	 r8b, 4
  00fcc	48 8b 54 24 60	 mov	 rdx, QWORD PTR page$[rsp]
  00fd1	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00fd9	e8 00 00 00 00	 call	 s390_or_dev_storage_key
$LN114@s390_copy_:

; 3945 :             } /* end for(page) */

  00fde	eb a4		 jmp	 SHORT $LN32@s390_copy_
$LN33@s390_copy_:

; 3946 : 
; 3947 : #if DEBUG_PREFETCH
; 3948 :             if (dev->ccwtrace)
; 3949 :             {
; 3950 :                 char msgbuf[133];
; 3951 : 
; 3952 :                 MSGBUF( msgbuf,
; 3953 :                     "CCW %2.2X %2.2X %4.4X %8.8X to_memory=%d to_iobuf=%d readbackwards=%d",
; 3954 :                     (U8)code, (U8)flags, (U16)count, (U32)addr, to_memory, to_iobuf, readbackwards );
; 3955 :                 WRMSG( HHC01392, "D", msgbuf );
; 3956 :             }
; 3957 : #endif
; 3958 :             /* Copy data between main storage and channel buffer */
; 3959 :             if (readbackwards)

  00fe0	0f b6 44 24 59	 movzx	 eax, BYTE PTR readbackwards$[rsp]
  00fe5	85 c0		 test	 eax, eax
  00fe7	0f 84 a5 00 00
	00		 je	 $LN115@s390_copy_

; 3960 :             {
; 3961 :                 BYTE *iobufptr = iobuf + dev->curblkrem;

  00fed	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ff5	8b 80 18 10 00
	00		 mov	 eax, DWORD PTR [rax+4120]
  00ffb	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  01003	48 03 c8	 add	 rcx, rax
  01006	48 8b c1	 mov	 rax, rcx
  01009	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR iobufptr$1[rsp], rax

; 3962 : 
; 3963 :                 /* Channel check if outside buffer                   */
; 3964 :                 /* SA22-7201-05:                                     */
; 3965 :                 /*  p. 16-27, Channel-Data Check                     */
; 3966 :                 if (!count                              ||
; 3967 :                     (iobufptr + count) > (iobufend + 1) ||

  01011	83 bc 24 38 01
	00 00 00	 cmp	 DWORD PTR count$[rsp], 0
  01019	74 37		 je	 SHORT $LN119@s390_copy_
  0101b	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  01022	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR iobufptr$1[rsp]
  0102a	48 03 c8	 add	 rcx, rax
  0102d	48 8b c1	 mov	 rax, rcx
  01030	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR iobufend$[rsp]
  01038	48 ff c1	 inc	 rcx
  0103b	48 3b c1	 cmp	 rax, rcx
  0103e	77 12		 ja	 SHORT $LN119@s390_copy_
  01040	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR iobufstart$[rsp]
  01048	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR iobufptr$1[rsp], rax
  01050	73 0d		 jae	 SHORT $LN117@s390_copy_
$LN119@s390_copy_:

; 3968 :                     iobufptr < iobufstart)
; 3969 :                     *chanstat = CSW_CDC;

  01052	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  0105a	c6 00 08	 mov	 BYTE PTR [rax], 8
  0105d	eb 2e		 jmp	 SHORT $LN118@s390_copy_
$LN117@s390_copy_:

; 3970 :                 else
; 3971 :                 {
; 3972 :                     /* read backward  - use END of buffer */
; 3973 :                     memcpy_backwards( dev->mainstor + addr,

  0105f	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  01066	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0106e	48 03 81 80 00
	00 00		 add	 rax, QWORD PTR [rcx+128]
  01075	44 8b 84 24 38
	01 00 00	 mov	 r8d, DWORD PTR count$[rsp]
  0107d	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR iobufptr$1[rsp]
  01085	48 8b c8	 mov	 rcx, rax
  01088	e8 00 00 00 00	 call	 memcpy_backwards
$LN118@s390_copy_:

; 3974 :                         iobufptr, count );
; 3975 :                 }
; 3976 :             }

  0108d	e9 1e 01 00 00	 jmp	 $LN116@s390_copy_
$LN115@s390_copy_:

; 3977 : 
; 3978 :             /* Channel check if outside buffer                       */
; 3979 :             /* SA22-7201-05:                                         */
; 3980 :             /*  p. 16-27, Channel-Data Check                         */
; 3981 :             else if (!count                           ||
; 3982 :                      (iobuf + count) > (iobufend + 1) ||

  01092	83 bc 24 38 01
	00 00 00	 cmp	 DWORD PTR count$[rsp], 0
  0109a	74 37		 je	 SHORT $LN122@s390_copy_
  0109c	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  010a3	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  010ab	48 03 c8	 add	 rcx, rax
  010ae	48 8b c1	 mov	 rax, rcx
  010b1	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR iobufend$[rsp]
  010b9	48 ff c1	 inc	 rcx
  010bc	48 3b c1	 cmp	 rax, rcx
  010bf	77 12		 ja	 SHORT $LN122@s390_copy_
  010c1	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR iobufstart$[rsp]
  010c9	48 39 84 24 58
	01 00 00	 cmp	 QWORD PTR iobuf$[rsp], rax
  010d1	73 36		 jae	 SHORT $LN120@s390_copy_
$LN122@s390_copy_:
$LN37@s390_copy_:

; 3983 :                      iobuf < iobufstart)
; 3984 :                 set_chanstat( CSW_CDC );

  010d3	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  010db	83 38 00	 cmp	 DWORD PTR [rax], 0
  010de	74 13		 je	 SHORT $LN123@s390_copy_
  010e0	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  010e4	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  010ec	c6 44 01 10 08	 mov	 BYTE PTR [rcx+rax+16], 8
  010f1	eb 0b		 jmp	 SHORT $LN124@s390_copy_
$LN123@s390_copy_:
  010f3	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  010fb	c6 00 08	 mov	 BYTE PTR [rax], 8
$LN124@s390_copy_:
  010fe	33 c0		 xor	 eax, eax
  01100	85 c0		 test	 eax, eax
  01102	75 cf		 jne	 SHORT $LN37@s390_copy_
  01104	e9 a7 00 00 00	 jmp	 $LN121@s390_copy_
$LN120@s390_copy_:

; 3985 : 
; 3986 :             /* Handle Write and Control transfer to I/O buffer */
; 3987 :             else if (to_iobuf)

  01109	0f b6 44 24 5b	 movzx	 eax, BYTE PTR to_iobuf$[rsp]
  0110e	85 c0		 test	 eax, eax
  01110	74 72		 je	 SHORT $LN125@s390_copy_

; 3988 :             {
; 3989 :                 memcpy( iobuf, dev->mainstor + addr, count );

  01112	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  01119	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  01120	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01128	48 03 8a 80 00
	00 00		 add	 rcx, QWORD PTR [rdx+128]
  0112f	48 8b bc 24 58
	01 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  01137	48 8b f1	 mov	 rsi, rcx
  0113a	8b c8		 mov	 ecx, eax
  0113c	f3 a4		 rep movsb

; 3990 : 
; 3991 :                 prefetch->pos += count;

  0113e	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  01146	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  01149	03 84 24 38 01
	00 00		 add	 eax, DWORD PTR count$[rsp]
  01150	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  01158	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 3992 : 
; 3993 :                 if (prefetch->seq)

  0115b	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  01163	83 38 00	 cmp	 DWORD PTR [rax], 0
  01166	74 1a		 je	 SHORT $LN127@s390_copy_

; 3994 :                     prefetch->datalen[ps] = count;

  01168	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  0116c	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  01174	8b 94 24 38 01
	00 00		 mov	 edx, DWORD PTR count$[rsp]
  0117b	89 94 81 10 05
	00 00		 mov	 DWORD PTR [rcx+rax*4+1296], edx
$LN127@s390_copy_:

; 3995 : 
; 3996 :             }

  01182	eb 2c		 jmp	 SHORT $LN126@s390_copy_
$LN125@s390_copy_:

; 3997 : 
; 3998 :             /* Handle Read transfer from I/O buffer */
; 3999 :             else
; 4000 :             {
; 4001 :                 memcpy( dev->mainstor + addr, iobuf, count );

  01184	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  0118b	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  01192	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0119a	48 03 8a 80 00
	00 00		 add	 rcx, QWORD PTR [rdx+128]
  011a1	48 8b f9	 mov	 rdi, rcx
  011a4	48 8b b4 24 58
	01 00 00	 mov	 rsi, QWORD PTR iobuf$[rsp]
  011ac	8b c8		 mov	 ecx, eax
  011ae	f3 a4		 rep movsb
$LN126@s390_copy_:
$LN121@s390_copy_:
$LN116@s390_copy_:
$LN112@s390_copy_:
$LN50@s390_copy_:
$LN1@s390_copy_:

; 4002 :             }
; 4003 : 
; 4004 : #ifdef FEATURE_S370_CHANNEL
; 4005 :             if (dev->devtype == 0x2703)
; 4006 :                 if (dev->commadpt->lnctl == COMMADPT_LNCTL_ASYNC)
; 4007 :                     usleep(5000);
; 4008 : #endif
; 4009 : 
; 4010 : #if DEBUG_DUMP
; 4011 :             if (dev->ccwtrace)
; 4012 :             {
; 4013 :                 char msgbuf[133];
; 4014 : 
; 4015 :                 MSGBUF( msgbuf, "iobuf->%8.8X.%4.4X", addr, count );
; 4016 :                 WRMSG( HHC01390, "D", msgbuf );
; 4017 : 
; 4018 :                 MSGBUF( msgbuf, "addr=%8.8X count=%d residual=%d copy=%d",
; 4019 :                     addr, count, *residual, count );
; 4020 :                 WRMSG( HHC01390, "D", msgbuf );
; 4021 : 
; 4022 :                 if (to_memory)
; 4023 :                     DUMP( "iobuf:", iobuf, count );
; 4024 :                 DUMP_STORAGE( "Storage:", addr, count );
; 4025 :                 if (to_iobuf)
; 4026 :                     DUMP( "iobuf:", iobuf, count );
; 4027 :             }
; 4028 : #endif
; 4029 :         }
; 4030 : 
; 4031 :     } /* end if(!IDA) */
; 4032 : 
; 4033 : #undef get_new_prefetch_entry
; 4034 : #undef set_chanstat
; 4035 : 
; 4036 : } /* end function copy_iobuf */

  011b0	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  011b7	5f		 pop	 rdi
  011b8	5e		 pop	 rsi
  011b9	c3		 ret	 0
s390_copy_iobuf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
storkey$ = 32
idalen$ = 36
tv67 = 40
idaw1$ = 44
idaw$ = 48
idapage$ = 56
idaw2$ = 64
dev$ = 96
code$ = 104
ccwkey$ = 112
idawfmt$ = 120
idapmask$ = 128
idaseq$ = 136
idawaddr$ = 144
addr$ = 152
len$ = 160
chanstat$ = 168
s390_fetch_idaw PROC

; 3123 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@s390_fetch:

; 3124 : RADR    idaw;                           /* Contents of IDAW          */
; 3125 : U32     idaw1;                          /* Format-1 IDAW             */
; 3126 : U64     idaw2;                          /* Format-2 IDAW             */
; 3127 : RADR    idapage;                        /* Addr of next IDA page     */
; 3128 : U16     idalen;                         /* #of bytes until next page */
; 3129 : BYTE    storkey;                        /* Storage key               */
; 3130 : 
; 3131 :     UNREFERENCED_370(dev);

  00017	33 c0		 xor	 eax, eax
  00019	85 c0		 test	 eax, eax
  0001b	75 fa		 jne	 SHORT $LN4@s390_fetch

; 3132 :     *addr = 0;

  0001d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00025	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 3133 :     *len = 0;

  0002c	33 c0		 xor	 eax, eax
  0002e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  00036	66 89 01	 mov	 WORD PTR [rcx], ax

; 3134 : 
; 3135 :     /* Channel program check if IDAW is not on correct
; 3136 :        boundary or is outside limit of main storage */
; 3137 :     if ((idawaddr & ((idawfmt == PF_IDAW2) ? 0x07 : 0x03))
; 3138 :         || CHADDRCHK(idawaddr, dev)
; 3139 :         /* Program check if Format-0 CCW and IDAW address > 16M      */
; 3140 :         /* SA22-7201-05:                                             */
; 3141 :         /*  p. 16-25, Invalid IDAW Address                           */
; 3142 :         || (!(dev->orb.flag5 & ORB5_F) && (idawaddr & 0xFF000000)))

  00039	0f b6 44 24 78	 movzx	 eax, BYTE PTR idawfmt$[rsp]
  0003e	83 f8 02	 cmp	 eax, 2
  00041	75 0a		 jne	 SHORT $LN24@s390_fetch
  00043	c7 44 24 28 07
	00 00 00	 mov	 DWORD PTR tv67[rsp], 7
  0004b	eb 08		 jmp	 SHORT $LN25@s390_fetch
$LN24@s390_fetch:
  0004d	c7 44 24 28 03
	00 00 00	 mov	 DWORD PTR tv67[rsp], 3
$LN25@s390_fetch:
  00055	8b 44 24 28	 mov	 eax, DWORD PTR tv67[rsp]
  00059	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR idawaddr$[rsp]
  00060	23 c8		 and	 ecx, eax
  00062	8b c1		 mov	 eax, ecx
  00064	85 c0		 test	 eax, eax
  00066	0f 85 a5 00 00
	00		 jne	 $LN6@s390_fetch
  0006c	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idawaddr$[rsp]
  00073	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00078	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  0007f	0f 87 8c 00 00
	00		 ja	 $LN6@s390_fetch
  00085	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0008a	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  00091	83 e0 10	 and	 eax, 16
  00094	85 c0		 test	 eax, eax
  00096	74 54		 je	 SHORT $LN7@s390_fetch
  00098	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0009d	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  000a4	83 e0 20	 and	 eax, 32			; 00000020H
  000a7	85 c0		 test	 eax, eax
  000a9	74 17		 je	 SHORT $LN8@s390_fetch
  000ab	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idawaddr$[rsp]
  000b2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000b9	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  000c0	72 4f		 jb	 SHORT $LN6@s390_fetch
$LN8@s390_fetch:
  000c2	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000c7	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  000ce	83 e0 40	 and	 eax, 64			; 00000040H
  000d1	85 c0		 test	 eax, eax
  000d3	74 17		 je	 SHORT $LN9@s390_fetch
  000d5	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idawaddr$[rsp]
  000dc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e3	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  000ea	73 25		 jae	 SHORT $LN6@s390_fetch
$LN9@s390_fetch:
$LN7@s390_fetch:
  000ec	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000f1	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  000f8	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000fd	85 c0		 test	 eax, eax
  000ff	75 20		 jne	 SHORT $LN5@s390_fetch
  00101	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idawaddr$[rsp]
  00108	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  0010d	85 c0		 test	 eax, eax
  0010f	74 10		 je	 SHORT $LN5@s390_fetch
$LN6@s390_fetch:

; 3143 :     {
; 3144 :         *chanstat = CSW_PROGC;

  00111	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00119	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3145 :         return;

  0011c	e9 b7 02 00 00	 jmp	 $LN1@s390_fetch
$LN5@s390_fetch:

; 3146 :     }
; 3147 : 
; 3148 :     /* Channel protection check if IDAW is fetch protected */
; 3149 :     storkey = ARCH_DEP( get_dev_storage_key )( dev, idawaddr );

  00121	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idawaddr$[rsp]
  00128	8b d0		 mov	 edx, eax
  0012a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0012f	e8 00 00 00 00	 call	 s390_get_dev_storage_key
  00134	88 44 24 20	 mov	 BYTE PTR storkey$[rsp], al

; 3150 :     if (ccwkey != 0 && (storkey & STORKEY_FETCH)
; 3151 :         && (storkey & STORKEY_KEY) != ccwkey)

  00138	0f b6 44 24 70	 movzx	 eax, BYTE PTR ccwkey$[rsp]
  0013d	85 c0		 test	 eax, eax
  0013f	74 2f		 je	 SHORT $LN10@s390_fetch
  00141	0f b6 44 24 20	 movzx	 eax, BYTE PTR storkey$[rsp]
  00146	83 e0 08	 and	 eax, 8
  00149	85 c0		 test	 eax, eax
  0014b	74 23		 je	 SHORT $LN10@s390_fetch
  0014d	0f b6 44 24 20	 movzx	 eax, BYTE PTR storkey$[rsp]
  00152	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00157	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR ccwkey$[rsp]
  0015c	3b c1		 cmp	 eax, ecx
  0015e	74 10		 je	 SHORT $LN10@s390_fetch

; 3152 :     {
; 3153 :         *chanstat = CSW_PROTC;

  00160	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00168	c6 00 10	 mov	 BYTE PTR [rax], 16

; 3154 :         return;

  0016b	e9 68 02 00 00	 jmp	 $LN1@s390_fetch
$LN10@s390_fetch:

; 3155 :     }
; 3156 : 
; 3157 :     /* Set the main storage reference bit for the IDAW location */
; 3158 :     ARCH_DEP( or_dev_storage_key )( dev, idawaddr, STORKEY_REF );

  00170	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idawaddr$[rsp]
  00177	41 b0 04	 mov	 r8b, 4
  0017a	8b d0		 mov	 edx, eax
  0017c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00181	e8 00 00 00 00	 call	 s390_or_dev_storage_key

; 3159 : 
; 3160 :     /* Fetch IDAW from main storage */
; 3161 :     if (idawfmt == PF_IDAW2)

  00186	0f b6 44 24 78	 movzx	 eax, BYTE PTR idawfmt$[rsp]
  0018b	83 f8 02	 cmp	 eax, 2
  0018e	75 4f		 jne	 SHORT $LN11@s390_fetch

; 3162 :     {
; 3163 :         /* Fetch format-2 IDAW */
; 3164 :         FETCH_DW(idaw2, dev->mainstor + idawaddr);

  00190	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idawaddr$[rsp]
  00197	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0019c	48 03 81 80 00
	00 00		 add	 rax, QWORD PTR [rcx+128]
  001a3	48 8b c8	 mov	 rcx, rax
  001a6	e8 00 00 00 00	 call	 fetch_dw_noswap
  001ab	48 8b c8	 mov	 rcx, rax
  001ae	e8 00 00 00 00	 call	 _byteswap_uint64
  001b3	48 89 44 24 40	 mov	 QWORD PTR idaw2$[rsp], rax

; 3165 : 
; 3166 : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 3167 :         /* Channel program check in ESA/390 mode
; 3168 :            if the format-2 IDAW exceeds 2GB-1 */
; 3169 :         if (idaw2 > 0x7FFFFFFF)

  001b8	48 81 7c 24 40
	ff ff ff 7f	 cmp	 QWORD PTR idaw2$[rsp], 2147483647 ; 7fffffffH
  001c1	76 10		 jbe	 SHORT $LN13@s390_fetch

; 3170 :         {
; 3171 :             *chanstat = CSW_PROGC;

  001c3	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  001cb	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3172 :             return;

  001ce	e9 05 02 00 00	 jmp	 $LN1@s390_fetch
$LN13@s390_fetch:

; 3173 :         }
; 3174 : #endif
; 3175 :         /* Save contents of format-2 IDAW */
; 3176 :         idaw = idaw2;

  001d3	48 8b 44 24 40	 mov	 rax, QWORD PTR idaw2$[rsp]
  001d8	48 89 44 24 30	 mov	 QWORD PTR idaw$[rsp], rax

; 3177 :     }

  001dd	eb 4c		 jmp	 SHORT $LN12@s390_fetch
$LN11@s390_fetch:

; 3178 :     else
; 3179 :     {
; 3180 :         /* Fetch format-1 IDAW */
; 3181 :         FETCH_FW(idaw1, dev->mainstor + idawaddr);

  001df	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idawaddr$[rsp]
  001e6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  001eb	48 03 81 80 00
	00 00		 add	 rax, QWORD PTR [rcx+128]
  001f2	48 8b c8	 mov	 rcx, rax
  001f5	e8 00 00 00 00	 call	 fetch_fw_noswap
  001fa	8b c8		 mov	 ecx, eax
  001fc	e8 00 00 00 00	 call	 _byteswap_ulong
  00201	89 44 24 2c	 mov	 DWORD PTR idaw1$[rsp], eax

; 3182 : 
; 3183 :         /* Channel program check if bit 0 of
; 3184 :            the format-1 IDAW is not zero */
; 3185 :         if (idaw1 & 0x80000000)

  00205	8b 44 24 2c	 mov	 eax, DWORD PTR idaw1$[rsp]
  00209	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0020e	85 c0		 test	 eax, eax
  00210	74 10		 je	 SHORT $LN14@s390_fetch

; 3186 :         {
; 3187 :             *chanstat = CSW_PROGC;

  00212	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  0021a	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3188 :             return;

  0021d	e9 b6 01 00 00	 jmp	 $LN1@s390_fetch
$LN14@s390_fetch:

; 3189 :         }
; 3190 : 
; 3191 :         /* Save contents of format-1 IDAW */
; 3192 :         idaw = idaw1;

  00222	8b 44 24 2c	 mov	 eax, DWORD PTR idaw1$[rsp]
  00226	48 89 44 24 30	 mov	 QWORD PTR idaw$[rsp], rax
$LN12@s390_fetch:

; 3193 :     }
; 3194 : 
; 3195 :     /* Channel program check if IDAW data
; 3196 :        location is outside main storage */
; 3197 :     if ( CHADDRCHK(idaw, dev) )

  0022b	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00230	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00237	48 39 44 24 30	 cmp	 QWORD PTR idaw$[rsp], rax
  0023c	77 63		 ja	 SHORT $LN16@s390_fetch
  0023e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00243	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  0024a	83 e0 10	 and	 eax, 16
  0024d	85 c0		 test	 eax, eax
  0024f	74 60		 je	 SHORT $LN15@s390_fetch
  00251	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00256	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0025d	83 e0 20	 and	 eax, 32			; 00000020H
  00260	85 c0		 test	 eax, eax
  00262	74 15		 je	 SHORT $LN18@s390_fetch
  00264	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0026b	48 8b 80 60 12
	00 00		 mov	 rax, QWORD PTR [rax+4704]
  00272	48 39 44 24 30	 cmp	 QWORD PTR idaw$[rsp], rax
  00277	72 28		 jb	 SHORT $LN17@s390_fetch
$LN18@s390_fetch:
  00279	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0027e	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00285	83 e0 40	 and	 eax, 64			; 00000040H
  00288	85 c0		 test	 eax, eax
  0028a	74 25		 je	 SHORT $LN15@s390_fetch
  0028c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00293	48 8b 80 60 12
	00 00		 mov	 rax, QWORD PTR [rax+4704]
  0029a	48 39 44 24 30	 cmp	 QWORD PTR idaw$[rsp], rax
  0029f	72 10		 jb	 SHORT $LN15@s390_fetch
$LN17@s390_fetch:
$LN16@s390_fetch:

; 3198 :     {
; 3199 :         *chanstat = CSW_PROGC;

  002a1	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  002a9	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3200 :         return;

  002ac	e9 27 01 00 00	 jmp	 $LN1@s390_fetch
$LN15@s390_fetch:

; 3201 :     }
; 3202 : 
; 3203 :     /* Channel program check if IDAW data location is not
; 3204 :        on a page boundary, except for the first IDAW */
; 3205 :     if (IS_CCW_RDBACK (code))

  002b1	0f b6 44 24 68	 movzx	 eax, BYTE PTR code$[rsp]
  002b6	83 e0 0f	 and	 eax, 15
  002b9	83 f8 0c	 cmp	 eax, 12
  002bc	0f 85 8b 00 00
	00		 jne	 $LN19@s390_fetch

; 3206 :     {
; 3207 :         if (idaseq > 0 && ((idaw+1) & idapmask) != 0)

  002c2	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR idaseq$[rsp], 0
  002ca	7e 28		 jle	 SHORT $LN21@s390_fetch
  002cc	48 8b 44 24 30	 mov	 rax, QWORD PTR idaw$[rsp]
  002d1	48 ff c0	 inc	 rax
  002d4	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR idapmask$[rsp]
  002dc	48 23 c1	 and	 rax, rcx
  002df	48 85 c0	 test	 rax, rax
  002e2	74 10		 je	 SHORT $LN21@s390_fetch

; 3208 :         {
; 3209 :             *chanstat = CSW_PROGC;

  002e4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  002ec	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3210 :             return;

  002ef	e9 e4 00 00 00	 jmp	 $LN1@s390_fetch
$LN21@s390_fetch:

; 3211 :         }
; 3212 : 
; 3213 :         /* Calculate address of next page boundary */
; 3214 :         idapage = (idaw & ~idapmask);

  002f4	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR idapmask$[rsp]
  002fc	f7 d0		 not	 eax
  002fe	48 98		 cdqe
  00300	48 8b 4c 24 30	 mov	 rcx, QWORD PTR idaw$[rsp]
  00305	48 23 c8	 and	 rcx, rax
  00308	48 8b c1	 mov	 rax, rcx
  0030b	48 89 44 24 38	 mov	 QWORD PTR idapage$[rsp], rax

; 3215 :         idalen = (idaw - idapage) + 1;

  00310	48 8b 44 24 38	 mov	 rax, QWORD PTR idapage$[rsp]
  00315	48 8b 4c 24 30	 mov	 rcx, QWORD PTR idaw$[rsp]
  0031a	48 2b c8	 sub	 rcx, rax
  0031d	48 8b c1	 mov	 rax, rcx
  00320	48 ff c0	 inc	 rax
  00323	66 89 44 24 24	 mov	 WORD PTR idalen$[rsp], ax

; 3216 : 
; 3217 :         /* Return the address and length for this IDAW */
; 3218 :         *addr = idaw;

  00328	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00330	48 8b 4c 24 30	 mov	 rcx, QWORD PTR idaw$[rsp]
  00335	48 89 08	 mov	 QWORD PTR [rax], rcx

; 3219 :         *len = idalen;

  00338	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  00340	0f b7 4c 24 24	 movzx	 ecx, WORD PTR idalen$[rsp]
  00345	66 89 08	 mov	 WORD PTR [rax], cx

; 3220 :     }

  00348	e9 8b 00 00 00	 jmp	 $LN20@s390_fetch
$LN19@s390_fetch:

; 3221 :     else
; 3222 :     {
; 3223 :         if (idaseq > 0 && (idaw & idapmask) != 0)

  0034d	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR idaseq$[rsp], 0
  00355	7e 25		 jle	 SHORT $LN22@s390_fetch
  00357	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR idapmask$[rsp]
  0035f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR idaw$[rsp]
  00364	48 23 c8	 and	 rcx, rax
  00367	48 8b c1	 mov	 rax, rcx
  0036a	48 85 c0	 test	 rax, rax
  0036d	74 0d		 je	 SHORT $LN22@s390_fetch

; 3224 :         {
; 3225 :             *chanstat = CSW_PROGC;

  0036f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00377	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3226 :             return;

  0037a	eb 5c		 jmp	 SHORT $LN1@s390_fetch
$LN22@s390_fetch:

; 3227 :         }
; 3228 : 
; 3229 :         /* Calculate address of next page boundary */
; 3230 :         idapage = (idaw + idapmask + 1) & ~idapmask;

  0037c	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR idapmask$[rsp]
  00384	48 8b 4c 24 30	 mov	 rcx, QWORD PTR idaw$[rsp]
  00389	48 8d 44 01 01	 lea	 rax, QWORD PTR [rcx+rax+1]
  0038e	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR idapmask$[rsp]
  00396	f7 d1		 not	 ecx
  00398	48 63 c9	 movsxd	 rcx, ecx
  0039b	48 23 c1	 and	 rax, rcx
  0039e	48 89 44 24 38	 mov	 QWORD PTR idapage$[rsp], rax

; 3231 :         idalen = idapage - idaw;

  003a3	48 8b 44 24 30	 mov	 rax, QWORD PTR idaw$[rsp]
  003a8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR idapage$[rsp]
  003ad	48 2b c8	 sub	 rcx, rax
  003b0	48 8b c1	 mov	 rax, rcx
  003b3	66 89 44 24 24	 mov	 WORD PTR idalen$[rsp], ax

; 3232 : 
; 3233 :         /* Return the address and length for this IDAW */
; 3234 :         *addr = idaw;

  003b8	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  003c0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR idaw$[rsp]
  003c5	48 89 08	 mov	 QWORD PTR [rax], rcx

; 3235 :         *len = idalen;

  003c8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  003d0	0f b7 4c 24 24	 movzx	 ecx, WORD PTR idalen$[rsp]
  003d5	66 89 08	 mov	 WORD PTR [rax], cx
$LN20@s390_fetch:
$LN1@s390_fetch:

; 3236 :     }
; 3237 : 
; 3238 : } /* end function fetch_idaw */

  003d8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  003dc	c3		 ret	 0
s390_fetch_idaw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
storkey$ = 32
ccw$ = 40
dev$ = 64
ccwkey$ = 72
ccwfmt$ = 80
ccwaddr$ = 88
code$ = 96
addr$ = 104
flags$ = 112
count$ = 120
chanstat$ = 128
s390_fetch_ccw PROC

; 3056 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@s390_fetch:

; 3057 : BYTE    storkey;                        /* Storage key               */
; 3058 : BYTE   *ccw;                            /* CCW pointer               */
; 3059 : 
; 3060 :     UNREFERENCED_370(dev);

  00017	33 c0		 xor	 eax, eax
  00019	85 c0		 test	 eax, eax
  0001b	75 fa		 jne	 SHORT $LN4@s390_fetch

; 3061 :     *code=0;

  0001d	48 8b 44 24 60	 mov	 rax, QWORD PTR code$[rsp]
  00022	c6 00 00	 mov	 BYTE PTR [rax], 0

; 3062 :     *count=0;

  00025	48 8b 44 24 78	 mov	 rax, QWORD PTR count$[rsp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 3063 :     *flags=0;

  00030	48 8b 44 24 70	 mov	 rax, QWORD PTR flags$[rsp]
  00035	c6 00 00	 mov	 BYTE PTR [rax], 0

; 3064 :     *addr=0;

  00038	48 8b 44 24 68	 mov	 rax, QWORD PTR addr$[rsp]
  0003d	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 3065 : 
; 3066 :     /* Channel program check if CCW is not on a doubleword
; 3067 :        boundary or is outside limit of main storage */
; 3068 :     if ( (ccwaddr & 0x00000007) || CHADDRCHK(ccwaddr, dev) )

  00043	8b 44 24 58	 mov	 eax, DWORD PTR ccwaddr$[rsp]
  00047	83 e0 07	 and	 eax, 7
  0004a	85 c0		 test	 eax, eax
  0004c	75 73		 jne	 SHORT $LN6@s390_fetch
  0004e	8b 44 24 58	 mov	 eax, DWORD PTR ccwaddr$[rsp]
  00052	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00057	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  0005e	77 61		 ja	 SHORT $LN7@s390_fetch
  00060	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00065	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  0006c	83 e0 10	 and	 eax, 16
  0006f	85 c0		 test	 eax, eax
  00071	74 5e		 je	 SHORT $LN5@s390_fetch
  00073	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00078	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0007f	83 e0 20	 and	 eax, 32			; 00000020H
  00082	85 c0		 test	 eax, eax
  00084	74 14		 je	 SHORT $LN9@s390_fetch
  00086	8b 44 24 58	 mov	 eax, DWORD PTR ccwaddr$[rsp]
  0008a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00091	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  00098	72 27		 jb	 SHORT $LN8@s390_fetch
$LN9@s390_fetch:
  0009a	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0009f	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  000a6	83 e0 40	 and	 eax, 64			; 00000040H
  000a9	85 c0		 test	 eax, eax
  000ab	74 24		 je	 SHORT $LN5@s390_fetch
  000ad	8b 44 24 58	 mov	 eax, DWORD PTR ccwaddr$[rsp]
  000b1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000b8	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  000bf	72 10		 jb	 SHORT $LN5@s390_fetch
$LN8@s390_fetch:
$LN7@s390_fetch:
$LN6@s390_fetch:

; 3069 :     {
; 3070 :         *chanstat = CSW_PROGC;

  000c1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  000c9	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3071 :         return;

  000cc	e9 ef 01 00 00	 jmp	 $LN1@s390_fetch
$LN5@s390_fetch:

; 3072 :     }
; 3073 : 
; 3074 :     /* Channel protection check if CCW is fetch protected */
; 3075 :     storkey = ARCH_DEP( get_dev_storage_key )( dev, ccwaddr );

  000d1	8b 44 24 58	 mov	 eax, DWORD PTR ccwaddr$[rsp]
  000d5	8b d0		 mov	 edx, eax
  000d7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000dc	e8 00 00 00 00	 call	 s390_get_dev_storage_key
  000e1	88 44 24 20	 mov	 BYTE PTR storkey$[rsp], al

; 3076 :     if (ccwkey != 0 && (storkey & STORKEY_FETCH)
; 3077 :         && (storkey & STORKEY_KEY) != ccwkey)

  000e5	0f b6 44 24 48	 movzx	 eax, BYTE PTR ccwkey$[rsp]
  000ea	85 c0		 test	 eax, eax
  000ec	74 2f		 je	 SHORT $LN10@s390_fetch
  000ee	0f b6 44 24 20	 movzx	 eax, BYTE PTR storkey$[rsp]
  000f3	83 e0 08	 and	 eax, 8
  000f6	85 c0		 test	 eax, eax
  000f8	74 23		 je	 SHORT $LN10@s390_fetch
  000fa	0f b6 44 24 20	 movzx	 eax, BYTE PTR storkey$[rsp]
  000ff	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00104	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR ccwkey$[rsp]
  00109	3b c1		 cmp	 eax, ecx
  0010b	74 10		 je	 SHORT $LN10@s390_fetch

; 3078 :     {
; 3079 :         *chanstat = CSW_PROTC;

  0010d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00115	c6 00 10	 mov	 BYTE PTR [rax], 16

; 3080 :         return;

  00118	e9 a3 01 00 00	 jmp	 $LN1@s390_fetch
$LN10@s390_fetch:

; 3081 :     }
; 3082 : 
; 3083 :     /* Set the main storage reference bit for the CCW location */
; 3084 :     ARCH_DEP( or_dev_storage_key )( dev, ccwaddr, STORKEY_REF );

  0011d	8b 44 24 58	 mov	 eax, DWORD PTR ccwaddr$[rsp]
  00121	41 b0 04	 mov	 r8b, 4
  00124	8b d0		 mov	 edx, eax
  00126	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0012b	e8 00 00 00 00	 call	 s390_or_dev_storage_key

; 3085 : 
; 3086 :     /* Point to the CCW in main storage */
; 3087 :     ccw = dev->mainstor + ccwaddr;

  00130	8b 44 24 58	 mov	 eax, DWORD PTR ccwaddr$[rsp]
  00134	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00139	48 03 81 80 00
	00 00		 add	 rax, QWORD PTR [rcx+128]
  00140	48 89 44 24 28	 mov	 QWORD PTR ccw$[rsp], rax

; 3088 : 
; 3089 :     /* Extract CCW opcode, flags, byte count, and data address */
; 3090 :     if (ccwfmt == 0)

  00145	0f b6 44 24 50	 movzx	 eax, BYTE PTR ccwfmt$[rsp]
  0014a	85 c0		 test	 eax, eax
  0014c	0f 85 ae 00 00
	00		 jne	 $LN11@s390_fetch

; 3091 :     {
; 3092 :         *code = ccw[0];

  00152	b8 01 00 00 00	 mov	 eax, 1
  00157	48 6b c0 00	 imul	 rax, rax, 0
  0015b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR code$[rsp]
  00160	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  00165	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00169	88 01		 mov	 BYTE PTR [rcx], al

; 3093 :         *addr = ((U32)(ccw[1]) << 16) | ((U32)(ccw[2]) << 8)

  0016b	b8 01 00 00 00	 mov	 eax, 1
  00170	48 6b c0 01	 imul	 rax, rax, 1
  00174	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ccw$[rsp]
  00179	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0017d	c1 e0 10	 shl	 eax, 16
  00180	b9 01 00 00 00	 mov	 ecx, 1
  00185	48 6b c9 02	 imul	 rcx, rcx, 2
  00189	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  0018e	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00192	c1 e1 08	 shl	 ecx, 8
  00195	0b c1		 or	 eax, ecx
  00197	b9 01 00 00 00	 mov	 ecx, 1
  0019c	48 6b c9 03	 imul	 rcx, rcx, 3
  001a0	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  001a5	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  001a9	0b c1		 or	 eax, ecx
  001ab	48 8b 4c 24 68	 mov	 rcx, QWORD PTR addr$[rsp]
  001b0	89 01		 mov	 DWORD PTR [rcx], eax

; 3094 :                     | ccw[3];
; 3095 :         *flags = ccw[4];

  001b2	b8 01 00 00 00	 mov	 eax, 1
  001b7	48 6b c0 04	 imul	 rax, rax, 4
  001bb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR flags$[rsp]
  001c0	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  001c5	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  001c9	88 01		 mov	 BYTE PTR [rcx], al

; 3096 :         *count = ((U16)(ccw[6]) << 8) | ccw[7];

  001cb	b8 01 00 00 00	 mov	 eax, 1
  001d0	48 6b c0 06	 imul	 rax, rax, 6
  001d4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ccw$[rsp]
  001d9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001dd	c1 e0 08	 shl	 eax, 8
  001e0	b9 01 00 00 00	 mov	 ecx, 1
  001e5	48 6b c9 07	 imul	 rcx, rcx, 7
  001e9	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  001ee	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  001f2	0b c1		 or	 eax, ecx
  001f4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR count$[rsp]
  001f9	89 01		 mov	 DWORD PTR [rcx], eax

; 3097 :     }

  001fb	e9 c0 00 00 00	 jmp	 $LN12@s390_fetch
$LN11@s390_fetch:

; 3098 :     else
; 3099 :     {
; 3100 :         *code = ccw[0];

  00200	b8 01 00 00 00	 mov	 eax, 1
  00205	48 6b c0 00	 imul	 rax, rax, 0
  00209	48 8b 4c 24 60	 mov	 rcx, QWORD PTR code$[rsp]
  0020e	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  00213	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00217	88 01		 mov	 BYTE PTR [rcx], al

; 3101 :         *flags = ccw[1];

  00219	b8 01 00 00 00	 mov	 eax, 1
  0021e	48 6b c0 01	 imul	 rax, rax, 1
  00222	48 8b 4c 24 70	 mov	 rcx, QWORD PTR flags$[rsp]
  00227	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  0022c	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00230	88 01		 mov	 BYTE PTR [rcx], al

; 3102 :         *count = ((U16)(ccw[2]) << 8) | ccw[3];

  00232	b8 01 00 00 00	 mov	 eax, 1
  00237	48 6b c0 02	 imul	 rax, rax, 2
  0023b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ccw$[rsp]
  00240	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00244	c1 e0 08	 shl	 eax, 8
  00247	b9 01 00 00 00	 mov	 ecx, 1
  0024c	48 6b c9 03	 imul	 rcx, rcx, 3
  00250	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  00255	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00259	0b c1		 or	 eax, ecx
  0025b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR count$[rsp]
  00260	89 01		 mov	 DWORD PTR [rcx], eax

; 3103 :         *addr = ((U32)(ccw[4]) << 24) | ((U32)(ccw[5]) << 16)

  00262	b8 01 00 00 00	 mov	 eax, 1
  00267	48 6b c0 04	 imul	 rax, rax, 4
  0026b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ccw$[rsp]
  00270	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00274	c1 e0 18	 shl	 eax, 24
  00277	b9 01 00 00 00	 mov	 ecx, 1
  0027c	48 6b c9 05	 imul	 rcx, rcx, 5
  00280	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  00285	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00289	c1 e1 10	 shl	 ecx, 16
  0028c	0b c1		 or	 eax, ecx
  0028e	b9 01 00 00 00	 mov	 ecx, 1
  00293	48 6b c9 06	 imul	 rcx, rcx, 6
  00297	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  0029c	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  002a0	c1 e1 08	 shl	 ecx, 8
  002a3	0b c1		 or	 eax, ecx
  002a5	b9 01 00 00 00	 mov	 ecx, 1
  002aa	48 6b c9 07	 imul	 rcx, rcx, 7
  002ae	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  002b3	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  002b7	0b c1		 or	 eax, ecx
  002b9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR addr$[rsp]
  002be	89 01		 mov	 DWORD PTR [rcx], eax
$LN12@s390_fetch:
$LN1@s390_fetch:

; 3104 :                     | ((U32)(ccw[6]) << 8) | ccw[7];
; 3105 :     }
; 3106 : } /* end function fetch_ccw */

  002c0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  002c4	c3		 ret	 0
s390_fetch_ccw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv86 = 32
dev$ = 64
ccwkey$ = 72
ccwfmt$ = 80
ccwaddr$ = 88
s390_raise_pci PROC

; 3006 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@s390_raise:

; 3007 : #if !defined(FEATURE_CHANNEL_SUBSYSTEM)
; 3008 :     UNREFERENCED(ccwfmt);
; 3009 : #endif
; 3010 : 
; 3011 :     IODELAY(dev);

  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001e	83 b8 e0 13 00
	00 00		 cmp	 DWORD PTR [rax+5088], 0
  00025	7e 2e		 jle	 SHORT $LN5@s390_raise
  00027	b8 01 00 00 00	 mov	 eax, 1
  0002c	48 6b c0 0a	 imul	 rax, rax, 10
  00030	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00035	0f b6 84 01 6c
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1388]
  0003d	83 f8 20	 cmp	 eax, 32			; 00000020H
  00040	75 13		 jne	 SHORT $LN5@s390_raise
  00042	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00049	8b 88 e0 13 00
	00		 mov	 ecx, DWORD PTR [rax+5088]
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN5@s390_raise:
  00055	33 c0		 xor	 eax, eax
  00057	85 c0		 test	 eax, eax
  00059	75 bc		 jne	 SHORT $LN4@s390_raise

; 3012 : 
; 3013 :     OBTAIN_INTLOCK(NULL);

  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182065
  00062	33 c9		 xor	 ecx, ecx
  00064	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 3014 :     obtain_lock (&dev->lock);

  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0006e	48 83 c0 38	 add	 rax, 56			; 00000038H
  00072	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182066
  00079	48 8b c8	 mov	 rcx, rax
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3015 : 
; 3016 :     /* Save the PCI SCSW replacing any previous pending PCI; always
; 3017 :      * track the channel in channel subsystem mode
; 3018 :      */
; 3019 :     dev->pciscsw.flag0 = ccwkey & SCSW0_KEY;

  00082	0f b6 44 24 48	 movzx	 eax, BYTE PTR ccwkey$[rsp]
  00087	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  0008c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00091	88 81 14 03 00
	00		 mov	 BYTE PTR [rcx+788], al

; 3020 :     dev->pciscsw.flag1 = (ccwfmt == 1 ? SCSW1_F : 0);

  00097	0f b6 44 24 50	 movzx	 eax, BYTE PTR ccwfmt$[rsp]
  0009c	83 f8 01	 cmp	 eax, 1
  0009f	75 0a		 jne	 SHORT $LN7@s390_raise
  000a1	c7 44 24 20 80
	00 00 00	 mov	 DWORD PTR tv86[rsp], 128 ; 00000080H
  000a9	eb 08		 jmp	 SHORT $LN8@s390_raise
$LN7@s390_raise:
  000ab	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
$LN8@s390_raise:
  000b3	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000b8	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR tv86[rsp]
  000bd	88 88 15 03 00
	00		 mov	 BYTE PTR [rax+789], cl

; 3021 :     dev->pciscsw.flag2 = SCSW2_FC_START;

  000c3	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000c8	c6 80 16 03 00
	00 40		 mov	 BYTE PTR [rax+790], 64	; 00000040H

; 3022 :     dev->pciscsw.flag3 = SCSW3_AC_SCHAC | SCSW3_AC_DEVAC

  000cf	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000d4	c6 80 17 03 00
	00 c9		 mov	 BYTE PTR [rax+791], 201	; 000000c9H

; 3023 :                        | SCSW3_SC_INTER | SCSW3_SC_PEND;
; 3024 :     STORE_FW(dev->pciscsw.ccwaddr,ccwaddr);

  000db	8b 4c 24 58	 mov	 ecx, DWORD PTR ccwaddr$[rsp]
  000df	e8 00 00 00 00	 call	 _byteswap_ulong
  000e4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000e9	48 81 c1 18 03
	00 00		 add	 rcx, 792		; 00000318H
  000f0	8b d0		 mov	 edx, eax
  000f2	e8 00 00 00 00	 call	 store_fw_noswap

; 3025 :     dev->pciscsw.unitstat = 0;

  000f7	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000fc	c6 80 1c 03 00
	00 00		 mov	 BYTE PTR [rax+796], 0

; 3026 :     dev->pciscsw.chanstat = CSW_PCI;

  00103	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00108	c6 80 1d 03 00
	00 80		 mov	 BYTE PTR [rax+797], 128	; 00000080H

; 3027 :     store_hw (dev->pciscsw.count, 0);

  0010f	33 c9		 xor	 ecx, ecx
  00111	e8 00 00 00 00	 call	 _byteswap_ushort
  00116	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0011b	48 81 c1 1e 03
	00 00		 add	 rcx, 798		; 0000031eH
  00122	0f b7 d0	 movzx	 edx, ax
  00125	e8 00 00 00 00	 call	 store_hw_noswap

; 3028 : 
; 3029 :     /* Queue the PCI pending interrupt */
; 3030 :     obtain_lock(&sysblk.iointqlk);

  0012a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00131	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  00137	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182067
  0013e	48 8b c8	 mov	 rcx, rax
  00141	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3031 :     QUEUE_IO_INTERRUPT_QLOCKED(&dev->pciioint,FALSE);

  00147	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0014c	48 05 40 02 00
	00		 add	 rax, 576		; 00000240H
  00152	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG182068
  00159	33 d2		 xor	 edx, edx
  0015b	48 8b c8	 mov	 rcx, rax
  0015e	e8 00 00 00 00	 call	 Queue_IO_Interrupt_QLocked

; 3032 : 
; 3033 :     /* Update interrupt status */
; 3034 :     subchannel_interrupt_queue_cleanup(dev);

  00163	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00168	e8 00 00 00 00	 call	 subchannel_interrupt_queue_cleanup

; 3035 :     UPDATE_IC_IOPENDING_QLOCKED();

  0016d	e8 00 00 00 00	 call	 Update_IC_IOPENDING_QLocked

; 3036 :     release_lock(&sysblk.iointqlk);

  00172	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00179	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  0017f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182069
  00186	48 8b c8	 mov	 rcx, rax
  00189	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3037 :     release_lock(&dev->lock);

  0018f	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00194	48 83 c0 38	 add	 rax, 56			; 00000038H
  00198	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182070
  0019f	48 8b c8	 mov	 rcx, rax
  001a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3038 :     RELEASE_INTLOCK(NULL);

  001a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182071
  001af	33 c9		 xor	 ecx, ecx
  001b1	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 3039 : 
; 3040 : } /* end function raise_pci */

  001b6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001ba	c3		 ret	 0
s390_raise_pci ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_dev_storage_key
_TEXT	SEGMENT
dev$ = 48
abs$ = 56
bits$ = 64
s390_or_dev_storage_key PROC				; COMDAT

; 299  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 300  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 301  :     ARCH_DEP( or_dev_2K_storage_key )( dev, abs, bits );
; 302  : #else
; 303  :     ARCH_DEP( or_dev_4K_storage_key )( dev, abs, bits );

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR bits$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR abs$[rsp]
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00023	e8 00 00 00 00	 call	 s390_or_dev_4K_storage_key

; 304  : #endif
; 305  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
s390_or_dev_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_get_dev_storage_key
_TEXT	SEGMENT
dev$ = 48
abs$ = 56
s390_get_dev_storage_key PROC				; COMDAT

; 263  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 264  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 265  :     return ARCH_DEP( get_dev_2K_storage_key )( dev, abs );
; 266  : #else
; 267  :     return ARCH_DEP( get_dev_4K_storage_key )( dev, abs );

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR abs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00018	e8 00 00 00 00	 call	 s390_get_dev_4K_storage_key

; 268  : #endif
; 269  : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
s390_get_dev_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_dev_4K_storage_key
_TEXT	SEGMENT
dev$ = 48
abs$ = 56
bits$ = 64
s390_or_dev_4K_storage_key PROC				; COMDAT

; 246  :   inline void  ARCH_DEP( or_dev_4K_storage_key )  ( DEVBLK* dev, U64 abs, BYTE bits ) {        ARCH_DEP( _or_dev_storage_key  )( dev, abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00013	0f b6 44 24 40	 movzx	 eax, BYTE PTR bits$[rsp]
  00018	83 e0 fe	 and	 eax, -2
  0001b	41 b1 04	 mov	 r9b, 4
  0001e	44 0f b6 c0	 movzx	 r8d, al
  00022	48 8b 54 24 38	 mov	 rdx, QWORD PTR abs$[rsp]
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0002c	e8 00 00 00 00	 call	 s390__or_dev_storage_key
  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
s390_or_dev_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_get_dev_4K_storage_key
_TEXT	SEGMENT
dev$ = 48
abs$ = 56
s390_get_dev_4K_storage_key PROC			; COMDAT

; 244  :   inline BYTE  ARCH_DEP( get_dev_4K_storage_key ) ( DEVBLK* dev, U64 abs            ) { return ARCH_DEP( _get_dev_storage_key )( dev, abs, 4 )  & ~STORKEY_BADFRM;      }

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	41 b0 04	 mov	 r8b, 4
  00011	48 8b 54 24 38	 mov	 rdx, QWORD PTR abs$[rsp]
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0001b	e8 00 00 00 00	 call	 s390__get_dev_storage_key
  00020	0f b6 c0	 movzx	 eax, al
  00023	83 e0 fe	 and	 eax, -2
  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
s390_get_dev_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390__or_dev_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
dev$ = 80
abs$ = 88
bits$ = 96
K$ = 104
s390__or_dev_storage_key PROC				; COMDAT

; 206  : {

$LN8:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390__or_d:

; 207  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	75 fa		 jne	 SHORT $LN4@s390__or_d

; 208  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  0001e	33 c0		 xor	 eax, eax
  00020	85 c0		 test	 eax, eax
  00022	74 5a		 je	 SHORT $LN5@s390__or_d

; 209  :     {
; 210  :         BYTE* skey1_ptr = _get_dev_storekey1_ptr( dev, abs );

  00024	48 8b 54 24 58	 mov	 rdx, QWORD PTR abs$[rsp]
  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0002e	e8 00 00 00 00	 call	 _get_dev_storekey1_ptr
  00033	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 211  :         BYTE* skey2_ptr = _get_dev_storekey2_ptr( dev, abs );

  00038	48 8b 54 24 58	 mov	 rdx, QWORD PTR abs$[rsp]
  0003d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00042	e8 00 00 00 00	 call	 _get_dev_storekey2_ptr
  00047	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 212  :         OR_SKEY( skey1_ptr, bits );

  0004c	0f b6 44 24 60	 movzx	 eax, BYTE PTR bits$[rsp]
  00051	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00056	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00059	0b c8		 or	 ecx, eax
  0005b	8b c1		 mov	 eax, ecx
  0005d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00062	88 01		 mov	 BYTE PTR [rcx], al

; 213  :         OR_SKEY( skey2_ptr, bits );

  00064	0f b6 44 24 60	 movzx	 eax, BYTE PTR bits$[rsp]
  00069	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00071	0b c8		 or	 ecx, eax
  00073	8b c1		 mov	 eax, ecx
  00075	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0007a	88 01		 mov	 BYTE PTR [rcx], al

; 214  :     }

  0007c	eb 32		 jmp	 SHORT $LN6@s390__or_d
$LN5@s390__or_d:

; 215  :     else
; 216  :     {
; 217  :         BYTE* skey_ptr  = _get_dev_storekey_ptr(  dev, abs, K );

  0007e	44 0f b6 44 24
	68		 movzx	 r8d, BYTE PTR K$[rsp]
  00084	48 8b 54 24 58	 mov	 rdx, QWORD PTR abs$[rsp]
  00089	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0008e	e8 00 00 00 00	 call	 _get_dev_storekey_ptr
  00093	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 218  :         OR_SKEY( skey_ptr, bits );

  00098	0f b6 44 24 60	 movzx	 eax, BYTE PTR bits$[rsp]
  0009d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  000a2	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000a5	0b c8		 or	 ecx, eax
  000a7	8b c1		 mov	 eax, ecx
  000a9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  000ae	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s390__or_d:

; 219  :     }
; 220  : }

  000b0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b4	c3		 ret	 0
s390__or_dev_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390__get_dev_storage_key
_TEXT	SEGMENT
skey$ = 32
dev$ = 64
abs$ = 72
K$ = 80
s390__get_dev_storage_key PROC				; COMDAT

; 144  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@s390__get_:

; 145  :     BYTE skey;
; 146  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	75 fa		 jne	 SHORT $LN4@s390__get_

; 147  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00019	33 c0		 xor	 eax, eax
  0001b	85 c0		 test	 eax, eax
  0001d	74 3c		 je	 SHORT $LN5@s390__get_

; 148  :     {
; 149  :         skey  = *_get_dev_storekey1_ptr( dev, abs );

  0001f	48 8b 54 24 48	 mov	 rdx, QWORD PTR abs$[rsp]
  00024	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00029	e8 00 00 00 00	 call	 _get_dev_storekey1_ptr
  0002e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00031	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 150  :         skey |= *_get_dev_storekey2_ptr( dev, abs ) & ~(STORKEY_KEY);

  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR abs$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0003f	e8 00 00 00 00	 call	 _get_dev_storekey2_ptr
  00044	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00047	25 0f ff ff ff	 and	 eax, -241		; ffffffffffffff0fH
  0004c	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR skey$[rsp]
  00051	0b c8		 or	 ecx, eax
  00053	8b c1		 mov	 eax, ecx
  00055	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 151  :     }

  00059	eb 1c		 jmp	 SHORT $LN6@s390__get_
$LN5@s390__get_:

; 152  :     else
; 153  :         skey  = *_get_dev_storekey_ptr(  dev, abs, K );

  0005b	44 0f b6 44 24
	50		 movzx	 r8d, BYTE PTR K$[rsp]
  00061	48 8b 54 24 48	 mov	 rdx, QWORD PTR abs$[rsp]
  00066	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0006b	e8 00 00 00 00	 call	 _get_dev_storekey_ptr
  00070	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00073	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al
$LN6@s390__get_:

; 154  :     return skey;

  00077	0f b6 44 24 20	 movzx	 eax, BYTE PTR skey$[rsp]

; 155  : }

  0007c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00080	c3		 ret	 0
s390__get_dev_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv305 = 32
tv314 = 36
pDEVLIST$ = 40
dev$ = 48
pZoneDevs$ = 56
pPrevDEVLIST$ = 64
io$ = 72
ioid$ = 96
ioparm$ = 104
iointid$ = 112
zone$ = 120
s390_present_zone_io_interrupt PROC

; 6356 : {

$LN34:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 6357 : IOINT  *io;                             /* -> I/O interrupt entry    */
; 6358 : DEVBLK *dev;                            /* -> Device control block   */
; 6359 : typedef struct _DEVLIST {               /* list of device block ptrs */
; 6360 :     struct _DEVLIST *next;              /* next list entry or NULL   */
; 6361 :     DEVBLK          *dev;               /* DEVBLK in requested zone  */
; 6362 :     U16              ssid;              /* Subsystem ID incl. lcssid */
; 6363 :     U16              subchan;           /* Subchannel number         */
; 6364 :     FWORD            intparm;           /* Interruption parameter    */
; 6365 :     int              visc;              /* Guest Interrupt Subclass  */
; 6366 : } DEVLIST;
; 6367 : DEVLIST *pDEVLIST, *pPrevDEVLIST = NULL;/* (work)                    */

  00018	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR pPrevDEVLIST$[rsp], 0

; 6368 : DEVLIST *pZoneDevs = NULL;              /* devices in requested zone */

  00021	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR pZoneDevs$[rsp], 0

; 6369 : 
; 6370 :     /* Gather devices within our zone with pending interrupt flagged */
; 6371 :     for (dev = sysblk.firstdev; dev; dev = dev->nextdev)

  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00031	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  00038	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax
  0003d	eb 0e		 jmp	 SHORT $LN4@s390_prese
$LN2@s390_prese:
  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00044	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00048	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax
$LN4@s390_prese:
  0004d	48 83 7c 24 30
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00053	0f 84 7a 01 00
	00		 je	 $LN3@s390_prese

; 6372 :     {
; 6373 :         /* Skip "devices" that don't actually exist */
; 6374 :         if (!IS_DEV(dev))

  00059	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0005e	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  00062	74 28		 je	 SHORT $LN20@s390_prese
  00064	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00069	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00070	83 e0 01	 and	 eax, 1
  00073	85 c0		 test	 eax, eax
  00075	75 17		 jne	 SHORT $LN19@s390_prese
  00077	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007e	48 8b 80 c8 11
	00 00		 mov	 rax, QWORD PTR [rax+4552]
  00085	48 39 44 24 30	 cmp	 QWORD PTR dev$[rsp], rax
  0008a	74 02		 je	 SHORT $LN19@s390_prese
$LN20@s390_prese:

; 6375 :             continue;

  0008c	eb b1		 jmp	 SHORT $LN2@s390_prese
$LN19@s390_prese:

; 6376 : 
; 6377 :         obtain_lock (&dev->lock);

  0008e	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00093	48 83 c0 38	 add	 rax, 56			; 00000038H
  00097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG183001
  0009e	48 8b c8	 mov	 rcx, rax
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 6378 : 
; 6379 :         if (1
; 6380 :             /* Subchannel valid and enabled */
; 6381 :             && ((dev->pmcw.flag5 & (PMCW5_E | PMCW5_V)) == (PMCW5_E | PMCW5_V))
; 6382 :             /* Within requested zone */
; 6383 :             && (dev->pmcw.zone == zone)
; 6384 :             /* Pending interrupt flagged */
; 6385 :             && ((dev->scsw.flag3 | dev->pciscsw.flag3) & SCSW3_SC_PEND)

  000a7	33 c0		 xor	 eax, eax
  000a9	83 f8 01	 cmp	 eax, 1
  000ac	0f 84 03 01 00
	00		 je	 $LN21@s390_prese
  000b2	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  000b7	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  000be	25 81 00 00 00	 and	 eax, 129		; 00000081H
  000c3	3d 81 00 00 00	 cmp	 eax, 129		; 00000081H
  000c8	0f 85 e7 00 00
	00		 jne	 $LN21@s390_prese
  000ce	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  000d3	0f b6 80 04 03
	00 00		 movzx	 eax, BYTE PTR [rax+772]
  000da	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR zone$[rsp]
  000df	3b c1		 cmp	 eax, ecx
  000e1	0f 85 ce 00 00
	00		 jne	 $LN21@s390_prese
  000e7	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  000ec	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  000f3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  000f8	0f b6 89 17 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+791]
  000ff	0b c1		 or	 eax, ecx
  00101	83 e0 01	 and	 eax, 1
  00104	85 c0		 test	 eax, eax
  00106	0f 84 a9 00 00
	00		 je	 $LN21@s390_prese

; 6386 :         )
; 6387 :         {
; 6388 :             /* (save this device for further scrutiny) */
; 6389 :             pDEVLIST          = (DEVLIST *)malloc( sizeof(DEVLIST) );

  0010c	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00117	48 89 44 24 28	 mov	 QWORD PTR pDEVLIST$[rsp], rax

; 6390 :             pDEVLIST->next    = NULL;

  0011c	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  00121	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 6391 :             pDEVLIST->dev     = dev;

  00128	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  0012d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00132	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 6392 :             pDEVLIST->ssid    = dev->ssid;

  00136	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  0013b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00140	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00144	66 89 48 10	 mov	 WORD PTR [rax+16], cx

; 6393 :             pDEVLIST->subchan = dev->subchan;

  00148	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  0014d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00152	0f b7 49 46	 movzx	 ecx, WORD PTR [rcx+70]
  00156	66 89 48 12	 mov	 WORD PTR [rax+18], cx

; 6394 : //          pDEVLIST->intparm = dev->pmcw.intparm;
; 6395 :             memcpy( pDEVLIST->intparm, dev->pmcw.intparm, sizeof(pDEVLIST->intparm) );

  0015a	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  0015f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00164	8b 89 ec 02 00
	00		 mov	 ecx, DWORD PTR [rcx+748]
  0016a	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 6396 :             pDEVLIST->visc    = (dev->pmcw.flag25 & PMCW25_VISC);

  0016d	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00172	0f b6 80 05 03
	00 00		 movzx	 eax, BYTE PTR [rax+773]
  00179	83 e0 07	 and	 eax, 7
  0017c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pDEVLIST$[rsp]
  00181	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 6397 : 
; 6398 :             if (!pZoneDevs)

  00184	48 83 7c 24 38
	00		 cmp	 QWORD PTR pZoneDevs$[rsp], 0
  0018a	75 0a		 jne	 SHORT $LN22@s390_prese

; 6399 :                 pZoneDevs = pDEVLIST;

  0018c	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  00191	48 89 44 24 38	 mov	 QWORD PTR pZoneDevs$[rsp], rax
$LN22@s390_prese:

; 6400 : 
; 6401 :             if (pPrevDEVLIST)

  00196	48 83 7c 24 40
	00		 cmp	 QWORD PTR pPrevDEVLIST$[rsp], 0
  0019c	74 0d		 je	 SHORT $LN23@s390_prese

; 6402 :                 pPrevDEVLIST->next = pDEVLIST;

  0019e	48 8b 44 24 40	 mov	 rax, QWORD PTR pPrevDEVLIST$[rsp]
  001a3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pDEVLIST$[rsp]
  001a8	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN23@s390_prese:

; 6403 : 
; 6404 :             pPrevDEVLIST = pDEVLIST;

  001ab	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  001b0	48 89 44 24 40	 mov	 QWORD PTR pPrevDEVLIST$[rsp], rax
$LN21@s390_prese:

; 6405 :         }
; 6406 : 
; 6407 :         release_lock (&dev->lock);

  001b5	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  001ba	48 83 c0 38	 add	 rax, 56			; 00000038H
  001be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG183005
  001c5	48 8b c8	 mov	 rcx, rax
  001c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6408 :     }

  001ce	e9 6c fe ff ff	 jmp	 $LN2@s390_prese
$LN3@s390_prese:

; 6409 : 
; 6410 :     /* Exit with condition code 0 if no devices
; 6411 :        within our zone with a pending interrupt */
; 6412 :     if (!pZoneDevs)

  001d3	48 83 7c 24 38
	00		 cmp	 QWORD PTR pZoneDevs$[rsp], 0
  001d9	75 07		 jne	 SHORT $LN24@s390_prese

; 6413 :         return 0;

  001db	33 c0		 xor	 eax, eax
  001dd	e9 83 02 00 00	 jmp	 $LN1@s390_prese
$LN24@s390_prese:

; 6414 : 
; 6415 :     /* Remove from our list those devices
; 6416 :        without a pending interrupt queued */
; 6417 :     obtain_lock(&sysblk.iointqlk);

  001e2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001e9	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  001ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG183007
  001f6	48 8b c8	 mov	 rcx, rax
  001f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 6418 :     for (pDEVLIST = pZoneDevs, pPrevDEVLIST = NULL; pDEVLIST;)

  001ff	48 8b 44 24 38	 mov	 rax, QWORD PTR pZoneDevs$[rsp]
  00204	48 89 44 24 28	 mov	 QWORD PTR pDEVLIST$[rsp], rax
  00209	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR pPrevDEVLIST$[rsp], 0
$LN5@s390_prese:
  00212	48 83 7c 24 28
	00		 cmp	 QWORD PTR pDEVLIST$[rsp], 0
  00218	0f 84 30 01 00
	00		 je	 $LN6@s390_prese

; 6419 :     {
; 6420 :         /* Search interrupt queue for this device */
; 6421 :         for (io = sysblk.iointq; io != NULL && io->dev != pDEVLIST->dev; io = io->next);

  0021e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00225	48 8b 80 28 12
	00 00		 mov	 rax, QWORD PTR [rax+4648]
  0022c	48 89 44 24 48	 mov	 QWORD PTR io$[rsp], rax
  00231	eb 0d		 jmp	 SHORT $LN10@s390_prese
$LN8@s390_prese:
  00233	48 8b 44 24 48	 mov	 rax, QWORD PTR io$[rsp]
  00238	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0023b	48 89 44 24 48	 mov	 QWORD PTR io$[rsp], rax
$LN10@s390_prese:
  00240	48 83 7c 24 48
	00		 cmp	 QWORD PTR io$[rsp], 0
  00246	74 16		 je	 SHORT $LN9@s390_prese
  00248	48 8b 44 24 48	 mov	 rax, QWORD PTR io$[rsp]
  0024d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pDEVLIST$[rsp]
  00252	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00256	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  0025a	74 02		 je	 SHORT $LN9@s390_prese
  0025c	eb d5		 jmp	 SHORT $LN8@s390_prese
$LN9@s390_prese:

; 6422 : 
; 6423 :         /* Is interrupt queued for this device? */
; 6424 :         if (io == NULL)

  0025e	48 83 7c 24 48
	00		 cmp	 QWORD PTR io$[rsp], 0
  00264	0f 85 c8 00 00
	00		 jne	 $LN25@s390_prese

; 6425 :         {
; 6426 :             /* No, remove it from our list */
; 6427 :             if (!pPrevDEVLIST)

  0026a	48 83 7c 24 40
	00		 cmp	 QWORD PTR pPrevDEVLIST$[rsp], 0
  00270	0f 85 92 00 00
	00		 jne	 $LN27@s390_prese
$LN13@s390_prese:

; 6428 :             {
; 6429 :                 ASSERT(pDEVLIST == pZoneDevs);

  00276	48 8b 44 24 38	 mov	 rax, QWORD PTR pZoneDevs$[rsp]
  0027b	48 39 44 24 28	 cmp	 QWORD PTR pDEVLIST$[rsp], rax
  00280	74 5c		 je	 SHORT $LN29@s390_prese
$LN16@s390_prese:
  00282	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG183013
  00289	41 b8 1d 19 00
	00		 mov	 r8d, 6429		; 0000191dH
  0028f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG183014
  00296	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG183015
  0029d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  002a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  002a9	85 c0		 test	 eax, eax
  002ab	74 20		 je	 SHORT $LN30@s390_prese
  002ad	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG183017
  002b4	41 b8 1d 19 00
	00		 mov	 r8d, 6429		; 0000191dH
  002ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG183018
  002c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG183019
  002c8	e8 00 00 00 00	 call	 DebuggerTrace
$LN30@s390_prese:
  002cd	33 c0		 xor	 eax, eax
  002cf	85 c0		 test	 eax, eax
  002d1	75 af		 jne	 SHORT $LN16@s390_prese
  002d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  002d9	85 c0		 test	 eax, eax
  002db	74 01		 je	 SHORT $LN31@s390_prese
  002dd	cc		 int	 3
$LN31@s390_prese:
$LN29@s390_prese:
  002de	33 c0		 xor	 eax, eax
  002e0	85 c0		 test	 eax, eax
  002e2	75 92		 jne	 SHORT $LN13@s390_prese

; 6430 :                 pZoneDevs = pDEVLIST->next;

  002e4	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  002e9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002ec	48 89 44 24 38	 mov	 QWORD PTR pZoneDevs$[rsp], rax

; 6431 :                 free(pDEVLIST);

  002f1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pDEVLIST$[rsp]
  002f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6432 :                 pDEVLIST = pZoneDevs;

  002fc	48 8b 44 24 38	 mov	 rax, QWORD PTR pZoneDevs$[rsp]
  00301	48 89 44 24 28	 mov	 QWORD PTR pDEVLIST$[rsp], rax

; 6433 :             }

  00306	eb 28		 jmp	 SHORT $LN28@s390_prese
$LN27@s390_prese:

; 6434 :             else
; 6435 :             {
; 6436 :                 pPrevDEVLIST->next = pDEVLIST->next;

  00308	48 8b 44 24 40	 mov	 rax, QWORD PTR pPrevDEVLIST$[rsp]
  0030d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pDEVLIST$[rsp]
  00312	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00315	48 89 08	 mov	 QWORD PTR [rax], rcx

; 6437 :                 free(pDEVLIST);

  00318	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pDEVLIST$[rsp]
  0031d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6438 :                 pDEVLIST = pPrevDEVLIST->next;

  00323	48 8b 44 24 40	 mov	 rax, QWORD PTR pPrevDEVLIST$[rsp]
  00328	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0032b	48 89 44 24 28	 mov	 QWORD PTR pDEVLIST$[rsp], rax
$LN28@s390_prese:

; 6439 :             }
; 6440 :         }

  00330	eb 17		 jmp	 SHORT $LN26@s390_prese
$LN25@s390_prese:

; 6441 :         else
; 6442 :         {
; 6443 :             /* Yes, go on to next list entry */
; 6444 :             pPrevDEVLIST = pDEVLIST;

  00332	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  00337	48 89 44 24 40	 mov	 QWORD PTR pPrevDEVLIST$[rsp], rax

; 6445 :             pDEVLIST = pDEVLIST->next;

  0033c	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  00341	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00344	48 89 44 24 28	 mov	 QWORD PTR pDEVLIST$[rsp], rax
$LN26@s390_prese:

; 6446 :         }
; 6447 :     }

  00349	e9 c4 fe ff ff	 jmp	 $LN5@s390_prese
$LN6@s390_prese:

; 6448 :     release_lock(&sysblk.iointqlk);

  0034e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00355	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  0035b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG183021
  00362	48 8b c8	 mov	 rcx, rax
  00365	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6449 : 
; 6450 :     /* If no devices remain, exit with condition code 0 */
; 6451 :     if (!pZoneDevs)

  0036b	48 83 7c 24 38
	00		 cmp	 QWORD PTR pZoneDevs$[rsp], 0
  00371	75 07		 jne	 SHORT $LN32@s390_prese

; 6452 :         return 0;

  00373	33 c0		 xor	 eax, eax
  00375	e9 eb 00 00 00	 jmp	 $LN1@s390_prese
$LN32@s390_prese:

; 6453 : 
; 6454 :     /* Extract the I/O address and interrupt parameter
; 6455 :        for the first pending subchannel */
; 6456 :     dev = pZoneDevs->dev;

  0037a	48 8b 44 24 38	 mov	 rax, QWORD PTR pZoneDevs$[rsp]
  0037f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00383	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax

; 6457 :     *ioid = (pZoneDevs->ssid << 16) | pZoneDevs->subchan;

  00388	48 8b 44 24 38	 mov	 rax, QWORD PTR pZoneDevs$[rsp]
  0038d	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  00391	c1 e0 10	 shl	 eax, 16
  00394	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pZoneDevs$[rsp]
  00399	0f b7 49 12	 movzx	 ecx, WORD PTR [rcx+18]
  0039d	0b c1		 or	 eax, ecx
  0039f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ioid$[rsp]
  003a4	89 01		 mov	 DWORD PTR [rcx], eax

; 6458 :     FETCH_FW(*ioparm,pZoneDevs->intparm);

  003a6	48 8b 44 24 38	 mov	 rax, QWORD PTR pZoneDevs$[rsp]
  003ab	48 83 c0 14	 add	 rax, 20
  003af	48 8b c8	 mov	 rcx, rax
  003b2	e8 00 00 00 00	 call	 fetch_fw_noswap
  003b7	8b c8		 mov	 ecx, eax
  003b9	e8 00 00 00 00	 call	 _byteswap_ulong
  003be	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ioparm$[rsp]
  003c3	89 01		 mov	 DWORD PTR [rcx], eax

; 6459 :     *iointid = (0x80000000 >> pZoneDevs->visc) | (zone << 16);

  003c5	48 8b 44 24 38	 mov	 rax, QWORD PTR pZoneDevs$[rsp]
  003ca	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  003cd	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  003d2	89 4c 24 20	 mov	 DWORD PTR tv305[rsp], ecx
  003d6	0f b6 c8	 movzx	 ecx, al
  003d9	8b 44 24 20	 mov	 eax, DWORD PTR tv305[rsp]
  003dd	d3 e8		 shr	 eax, cl
  003df	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR zone$[rsp]
  003e4	c1 e1 10	 shl	 ecx, 16
  003e7	0b c1		 or	 eax, ecx
  003e9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR iointid$[rsp]
  003ee	89 01		 mov	 DWORD PTR [rcx], eax

; 6460 :     pDEVLIST = pZoneDevs->next;

  003f0	48 8b 44 24 38	 mov	 rax, QWORD PTR pZoneDevs$[rsp]
  003f5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003f8	48 89 44 24 28	 mov	 QWORD PTR pDEVLIST$[rsp], rax

; 6461 :     free (pZoneDevs);

  003fd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pZoneDevs$[rsp]
  00402	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN17@s390_prese:

; 6462 : 
; 6463 :     /* Find all other pending subclasses */
; 6464 :     while (pDEVLIST)

  00408	48 83 7c 24 28
	00		 cmp	 QWORD PTR pDEVLIST$[rsp], 0
  0040e	74 50		 je	 SHORT $LN18@s390_prese

; 6465 :     {
; 6466 :         *iointid |= (0x80000000 >> pDEVLIST->visc);

  00410	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  00415	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00418	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  0041d	89 4c 24 24	 mov	 DWORD PTR tv314[rsp], ecx
  00421	0f b6 c8	 movzx	 ecx, al
  00424	8b 44 24 24	 mov	 eax, DWORD PTR tv314[rsp]
  00428	d3 e8		 shr	 eax, cl
  0042a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR iointid$[rsp]
  0042f	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00431	0b c8		 or	 ecx, eax
  00433	8b c1		 mov	 eax, ecx
  00435	48 8b 4c 24 70	 mov	 rcx, QWORD PTR iointid$[rsp]
  0043a	89 01		 mov	 DWORD PTR [rcx], eax

; 6467 :         pPrevDEVLIST = pDEVLIST;

  0043c	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  00441	48 89 44 24 40	 mov	 QWORD PTR pPrevDEVLIST$[rsp], rax

; 6468 :         pDEVLIST = pDEVLIST->next;

  00446	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  0044b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0044e	48 89 44 24 28	 mov	 QWORD PTR pDEVLIST$[rsp], rax

; 6469 :         free (pPrevDEVLIST);

  00453	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pPrevDEVLIST$[rsp]
  00458	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6470 :     }

  0045e	eb a8		 jmp	 SHORT $LN17@s390_prese
$LN18@s390_prese:

; 6471 : 
; 6472 :     /* Exit with condition code indicating interrupt pending */
; 6473 :     return 1;

  00460	b8 01 00 00 00	 mov	 eax, 1
$LN1@s390_prese:

; 6474 : 
; 6475 : } /* end function present_zone_io_interrupt */

  00465	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00469	c3		 ret	 0
s390_present_zone_io_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
dev$ = 48
io$ = 56
dotsch$ = 64
icode$ = 68
i$1 = 72
tv277 = 76
mask$2 = 80
tv231 = 88
tv251 = 92
io2$ = 96
wake$3 = 104
regs$4 = 112
cc$5 = 120
scsw$6 = 128
p$7 = 136
ioint$8 = 144
irb$9 = 160
__$ArrayPad$ = 224
regs$ = 256
ioid$ = 264
ioparm$ = 272
iointid$ = 280
csw$ = 288
pdev$ = 296
s390_present_io_interrupt PROC

; 6042 : {

$LN68:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 6043 : IOINT  *io, *io2;                       /* -> I/O interrupt entry    */
; 6044 : DEVBLK *dev;                            /* -> Device control block   */
; 6045 : int     icode = 0;                      /* Intercept code            */

  0002d	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR icode$[rsp], 0

; 6046 : bool    dotsch = true;                  /* perform TSCH after int    */

  00035	c6 44 24 40 01	 mov	 BYTE PTR dotsch$[rsp], 1
$LN4@s390_prese:

; 6047 :                                         /* except for THININT        */
; 6048 : 
; 6049 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY) || defined(_FEATURE_IO_ASSIST)
; 6050 : #if defined(FEATURE_QDIO_THININT)
; 6051 : /* The 2 following variables are only used for QDIO Thin Interrupt Processing */
; 6052 : bool    saved_dotsch  = dotsch;
; 6053 : bool    PCI_dequeued  = false;
; 6054 : #endif
; 6055 : #endif
; 6056 : 
; 6057 :     UNREFERENCED_370(ioparm);

  0003a	33 c0		 xor	 eax, eax
  0003c	85 c0		 test	 eax, eax
  0003e	75 fa		 jne	 SHORT $LN4@s390_prese
$LN7@s390_prese:

; 6058 :     UNREFERENCED_370(iointid);

  00040	33 c0		 xor	 eax, eax
  00042	85 c0		 test	 eax, eax
  00044	75 fa		 jne	 SHORT $LN7@s390_prese
$LN10@s390_prese:

; 6059 : #if defined(_FEATURE_IO_ASSIST)
; 6060 :     UNREFERENCED_390(iointid);

  00046	33 c0		 xor	 eax, eax
  00048	85 c0		 test	 eax, eax
  0004a	75 fa		 jne	 SHORT $LN10@s390_prese
$LN13@s390_prese:

; 6061 : #endif
; 6062 :     UNREFERENCED_390(csw);

  0004c	33 c0		 xor	 eax, eax
  0004e	85 c0		 test	 eax, eax
  00050	75 fa		 jne	 SHORT $LN13@s390_prese
$LN16@s390_prese:

; 6063 :     UNREFERENCED_900(csw);

  00052	33 c0		 xor	 eax, eax
  00054	85 c0		 test	 eax, eax
  00056	75 fa		 jne	 SHORT $LN16@s390_prese
$retry$69:

; 6064 : 
; 6065 : retry:
; 6066 : 
; 6067 :     /* Find a device with pending interrupt...
; 6068 : 
; 6069 :        Please remember that the device lock CANNOT be acquired
; 6070 :        while iointqlk is held. The iointqlk MUST be acquired AFTER
; 6071 :        the device lock is first acquired. Thus the retry logic.
; 6072 :     */
; 6073 :     dev = NULL;

  00058	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR dev$[rsp], 0

; 6074 : 
; 6075 :     obtain_lock( &sysblk.iointqlk );

  00061	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00068	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182908
  00075	48 8b c8	 mov	 rcx, rax
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 6076 :     {
; 6077 :         for (io = sysblk.iointq; io != NULL; io = io->next)

  0007e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00085	48 8b 80 28 12
	00 00		 mov	 rax, QWORD PTR [rax+4648]
  0008c	48 89 44 24 38	 mov	 QWORD PTR io$[rsp], rax
  00091	eb 0d		 jmp	 SHORT $LN19@s390_prese
$LN17@s390_prese:
  00093	48 8b 44 24 38	 mov	 rax, QWORD PTR io$[rsp]
  00098	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009b	48 89 44 24 38	 mov	 QWORD PTR io$[rsp], rax
$LN19@s390_prese:
  000a0	48 83 7c 24 38
	00		 cmp	 QWORD PTR io$[rsp], 0
  000a6	0f 84 17 01 00
	00		 je	 $LN18@s390_prese

; 6078 :         {
; 6079 :             /* Can't present interrupt while TEST SUBCHANNEL required
; 6080 :              * (interrupt already presented for this device)
; 6081 :              */
; 6082 :             if (io->dev->tschpending)

  000ac	48 8b 44 24 38	 mov	 rax, QWORD PTR io$[rsp]
  000b1	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000b5	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000bb	c1 e8 1b	 shr	 eax, 27
  000be	83 e0 01	 and	 eax, 1
  000c1	85 c0		 test	 eax, eax
  000c3	74 02		 je	 SHORT $LN40@s390_prese

; 6083 :                 continue;

  000c5	eb cc		 jmp	 SHORT $LN17@s390_prese
$LN40@s390_prese:

; 6084 : 
; 6085 :             /* Exit loop if enabled for interrupts from this device */
; 6086 :             if ((icode = ARCH_DEP( interrupt_enabled )( regs, io->dev ))
; 6087 : 
; 6088 : #if defined( _FEATURE_IO_ASSIST )
; 6089 :               && icode != SIE_INTERCEPT_IOINTP

  000c7	48 8b 44 24 38	 mov	 rax, QWORD PTR io$[rsp]
  000cc	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000d0	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d8	e8 00 00 00 00	 call	 s390_interrupt_enabled
  000dd	89 44 24 44	 mov	 DWORD PTR icode$[rsp], eax
  000e1	83 7c 24 44 00	 cmp	 DWORD PTR icode$[rsp], 0
  000e6	74 1a		 je	 SHORT $LN41@s390_prese
  000e8	83 7c 24 44 f0	 cmp	 DWORD PTR icode$[rsp], -16
  000ed	74 13		 je	 SHORT $LN41@s390_prese

; 6090 : #endif
; 6091 :             )
; 6092 :             {
; 6093 :                 dev = io->dev;

  000ef	48 8b 44 24 38	 mov	 rax, QWORD PTR io$[rsp]
  000f4	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000f8	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax

; 6094 :                 break;

  000fd	e9 c1 00 00 00	 jmp	 $LN18@s390_prese
$LN41@s390_prese:

; 6095 :             }
; 6096 : 
; 6097 :             /* See if another CPU can take this interrupt */
; 6098 :             {
; 6099 :                 REGS *regs;
; 6100 :                 CPU_BITMAP mask = sysblk.waiting_mask;

  00102	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00109	48 8b 80 b8 12
	00 00		 mov	 rax, QWORD PTR [rax+4792]
  00110	48 89 44 24 50	 mov	 QWORD PTR mask$2[rsp], rax

; 6101 :                 CPU_BITMAP wake;
; 6102 :                 int i;
; 6103 : 
; 6104 :                 /* If any CPUs are waiting, isolate to subgroup enabled for
; 6105 :                  * I/O interrupts.
; 6106 :                  */
; 6107 :                 if (mask)

  00115	48 83 7c 24 50
	00		 cmp	 QWORD PTR mask$2[rsp], 0
  0011b	0f 84 9d 00 00
	00		 je	 $LN42@s390_prese

; 6108 :                 {
; 6109 :                     wake = mask;

  00121	48 8b 44 24 50	 mov	 rax, QWORD PTR mask$2[rsp]
  00126	48 89 44 24 68	 mov	 QWORD PTR wake$3[rsp], rax

; 6110 : 
; 6111 :                     /* Turn off wake mask bits for waiting CPUs that aren't
; 6112 :                      * enabled for I/O interrupts for the device.
; 6113 :                      */
; 6114 :                     for (i=0; mask; mask >>= 1, ++i)

  0012b	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00133	eb 17		 jmp	 SHORT $LN22@s390_prese
$LN20@s390_prese:
  00135	48 8b 44 24 50	 mov	 rax, QWORD PTR mask$2[rsp]
  0013a	48 d1 e8	 shr	 rax, 1
  0013d	48 89 44 24 50	 mov	 QWORD PTR mask$2[rsp], rax
  00142	8b 44 24 48	 mov	 eax, DWORD PTR i$1[rsp]
  00146	ff c0		 inc	 eax
  00148	89 44 24 48	 mov	 DWORD PTR i$1[rsp], eax
$LN22@s390_prese:
  0014c	48 83 7c 24 50
	00		 cmp	 QWORD PTR mask$2[rsp], 0
  00152	74 59		 je	 SHORT $LN21@s390_prese

; 6115 :                     {
; 6116 :                         if (mask & 1)

  00154	48 8b 44 24 50	 mov	 rax, QWORD PTR mask$2[rsp]
  00159	48 83 e0 01	 and	 rax, 1
  0015d	48 85 c0	 test	 rax, rax
  00160	74 49		 je	 SHORT $LN43@s390_prese

; 6117 :                         {
; 6118 :                             regs = sysblk.regs[i];

  00162	48 63 44 24 48	 movsxd	 rax, DWORD PTR i$1[rsp]
  00167	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0016e	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00176	48 89 44 24 70	 mov	 QWORD PTR regs$4[rsp], rax

; 6119 : 
; 6120 :                             if (!ARCH_DEP( interrupt_enabled )( regs, io->dev ))

  0017b	48 8b 44 24 38	 mov	 rax, QWORD PTR io$[rsp]
  00180	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00184	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$4[rsp]
  00189	e8 00 00 00 00	 call	 s390_interrupt_enabled
  0018e	85 c0		 test	 eax, eax
  00190	75 19		 jne	 SHORT $LN44@s390_prese

; 6121 :                                 wake ^= regs->cpubit;

  00192	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$4[rsp]
  00197	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  0019b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR wake$3[rsp]
  001a0	48 33 c8	 xor	 rcx, rax
  001a3	48 8b c1	 mov	 rax, rcx
  001a6	48 89 44 24 68	 mov	 QWORD PTR wake$3[rsp], rax
$LN44@s390_prese:
$LN43@s390_prese:

; 6122 :                         }
; 6123 :                     }

  001ab	eb 88		 jmp	 SHORT $LN20@s390_prese
$LN21@s390_prese:

; 6124 : 
; 6125 :                     /* Wakeup the LRU waiting CPU enabled for I/O
; 6126 :                      * interrupts.
; 6127 :                      */
; 6128 :                     WAKEUP_CPU_MASK( wake );

  001ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182914
  001b4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR wake$3[rsp]
  001b9	e8 00 00 00 00	 call	 wakeup_cpu_mask
$LN42@s390_prese:

; 6129 :                 }
; 6130 :             }
; 6131 : 
; 6132 :         } /* end for(io) */

  001be	e9 d0 fe ff ff	 jmp	 $LN17@s390_prese
$LN18@s390_prese:

; 6133 : 
; 6134 : #if defined( _FEATURE_IO_ASSIST )
; 6135 :         /* In the case of I/O assist, do a rescan, to see
; 6136 :            if there are any devices with pending subclasses
; 6137 :            for which we are not enabled, if so cause an
; 6138 :            interception.
; 6139 :         */
; 6140 :         if (io == NULL && SIE_MODE( regs ))

  001c3	48 83 7c 24 38
	00		 cmp	 QWORD PTR io$[rsp], 0
  001c9	0f 85 db 00 00
	00		 jne	 $LN45@s390_prese
  001cf	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d7	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001dd	d1 e8		 shr	 eax, 1
  001df	83 e0 01	 and	 eax, 1
  001e2	85 c0		 test	 eax, eax
  001e4	0f 84 c0 00 00
	00		 je	 $LN45@s390_prese
$LN25@s390_prese:

; 6141 :         {
; 6142 :             /* Find a device with a pending interrupt, regardless
; 6143 :                of the interrupt subclass mask
; 6144 :             */
; 6145 :             ASSERT( dev == NULL );

  001ea	48 83 7c 24 30
	00		 cmp	 QWORD PTR dev$[rsp], 0
  001f0	74 5c		 je	 SHORT $LN46@s390_prese
$LN28@s390_prese:
  001f2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG182917
  001f9	41 b8 01 18 00
	00		 mov	 r8d, 6145		; 00001801H
  001ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182918
  00206	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182919
  0020d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00213	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00219	85 c0		 test	 eax, eax
  0021b	74 20		 je	 SHORT $LN47@s390_prese
  0021d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG182921
  00224	41 b8 01 18 00
	00		 mov	 r8d, 6145		; 00001801H
  0022a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182922
  00231	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182923
  00238	e8 00 00 00 00	 call	 DebuggerTrace
$LN47@s390_prese:
  0023d	33 c0		 xor	 eax, eax
  0023f	85 c0		 test	 eax, eax
  00241	75 af		 jne	 SHORT $LN28@s390_prese
  00243	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00249	85 c0		 test	 eax, eax
  0024b	74 01		 je	 SHORT $LN48@s390_prese
  0024d	cc		 int	 3
$LN48@s390_prese:
$LN46@s390_prese:
  0024e	33 c0		 xor	 eax, eax
  00250	85 c0		 test	 eax, eax
  00252	75 96		 jne	 SHORT $LN25@s390_prese

; 6146 : 
; 6147 :             for (io = sysblk.iointq; io != NULL; io = io->next)

  00254	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0025b	48 8b 80 28 12
	00 00		 mov	 rax, QWORD PTR [rax+4648]
  00262	48 89 44 24 38	 mov	 QWORD PTR io$[rsp], rax
  00267	eb 0d		 jmp	 SHORT $LN31@s390_prese
$LN29@s390_prese:
  00269	48 8b 44 24 38	 mov	 rax, QWORD PTR io$[rsp]
  0026e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00271	48 89 44 24 38	 mov	 QWORD PTR io$[rsp], rax
$LN31@s390_prese:
  00276	48 83 7c 24 38
	00		 cmp	 QWORD PTR io$[rsp], 0
  0027c	74 2c		 je	 SHORT $LN30@s390_prese

; 6148 :             {
; 6149 :                 /* Exit loop if pending interrupts from this device */
; 6150 :                 if (ARCH_DEP( interrupt_enabled )( regs, io->dev ))

  0027e	48 8b 44 24 38	 mov	 rax, QWORD PTR io$[rsp]
  00283	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00287	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028f	e8 00 00 00 00	 call	 s390_interrupt_enabled
  00294	85 c0		 test	 eax, eax
  00296	74 10		 je	 SHORT $LN49@s390_prese

; 6151 :                 {
; 6152 :                     dev = io->dev;

  00298	48 8b 44 24 38	 mov	 rax, QWORD PTR io$[rsp]
  0029d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  002a1	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax

; 6153 :                     break;

  002a6	eb 02		 jmp	 SHORT $LN30@s390_prese
$LN49@s390_prese:

; 6154 :                 }
; 6155 :             } /* end for(io) */

  002a8	eb bf		 jmp	 SHORT $LN29@s390_prese
$LN30@s390_prese:
$LN45@s390_prese:

; 6156 :         }
; 6157 : #endif
; 6158 :         /* If no interrupt pending, or no device, exit with
; 6159 :          * condition code 0
; 6160 :          */
; 6161 :         if (io == NULL || dev == NULL)

  002aa	48 83 7c 24 38
	00		 cmp	 QWORD PTR io$[rsp], 0
  002b0	74 08		 je	 SHORT $LN51@s390_prese
  002b2	48 83 7c 24 30
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002b8	75 4b		 jne	 SHORT $LN50@s390_prese
$LN51@s390_prese:

; 6162 :         {
; 6163 :             /* Pass back pointer to device block for device with interrupt */
; 6164 :             *pdev = dev;

  002ba	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR pdev$[rsp]
  002c2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  002c7	48 89 08	 mov	 QWORD PTR [rax], rcx

; 6165 : 
; 6166 :             if (dev != NULL)

  002ca	48 83 7c 24 30
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002d0	74 0a		 je	 SHORT $LN52@s390_prese

; 6167 :                 subchannel_interrupt_queue_cleanup( dev );

  002d2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  002d7	e8 00 00 00 00	 call	 subchannel_interrupt_queue_cleanup
$LN52@s390_prese:

; 6168 : 
; 6169 :             UPDATE_IC_IOPENDING_QLOCKED();

  002dc	e8 00 00 00 00	 call	 Update_IC_IOPENDING_QLocked

; 6170 : 
; 6171 :             release_lock( &sysblk.iointqlk );

  002e1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002e8	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  002ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182929
  002f5	48 8b c8	 mov	 rcx, rax
  002f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6172 :             return 0;

  002fe	33 c0		 xor	 eax, eax
  00300	e9 99 03 00 00	 jmp	 $LN1@s390_prese
$LN50@s390_prese:

; 6173 :         }
; 6174 :     }
; 6175 :     release_lock( &sysblk.iointqlk );

  00305	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0030c	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  00312	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182930
  00319	48 8b c8	 mov	 rcx, rax
  0031c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6176 : 
; 6177 :     /* Obtain device lock for device with interrupt */
; 6178 :     obtain_lock( &dev->lock );

  00322	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00327	48 83 c0 38	 add	 rax, 56			; 00000038H
  0032b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182931
  00332	48 8b c8	 mov	 rcx, rax
  00335	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 6179 :     {
; 6180 :         /* Pass back pointer to device block for device with interrupt */
; 6181 :         *pdev = dev;

  0033b	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR pdev$[rsp]
  00343	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00348	48 89 08	 mov	 QWORD PTR [rax], rcx

; 6182 : 
; 6183 :         /* Verify that the interrupt for this device still exists and that
; 6184 :            TEST SUBCHANNEL has to be issued to clear an existing interrupt.
; 6185 :          */
; 6186 :         obtain_lock( &sysblk.iointqlk );

  0034b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00352	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  00358	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182932
  0035f	48 8b c8	 mov	 rcx, rax
  00362	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 6187 :         {
; 6188 :             for (io2 = sysblk.iointq; io2 != NULL && io2 != io; io2 = io2->next);

  00368	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0036f	48 8b 80 28 12
	00 00		 mov	 rax, QWORD PTR [rax+4648]
  00376	48 89 44 24 60	 mov	 QWORD PTR io2$[rsp], rax
  0037b	eb 0d		 jmp	 SHORT $LN34@s390_prese
$LN32@s390_prese:
  0037d	48 8b 44 24 60	 mov	 rax, QWORD PTR io2$[rsp]
  00382	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00385	48 89 44 24 60	 mov	 QWORD PTR io2$[rsp], rax
$LN34@s390_prese:
  0038a	48 83 7c 24 60
	00		 cmp	 QWORD PTR io2$[rsp], 0
  00390	74 0e		 je	 SHORT $LN33@s390_prese
  00392	48 8b 44 24 38	 mov	 rax, QWORD PTR io$[rsp]
  00397	48 39 44 24 60	 cmp	 QWORD PTR io2$[rsp], rax
  0039c	74 02		 je	 SHORT $LN33@s390_prese
  0039e	eb dd		 jmp	 SHORT $LN32@s390_prese
$LN33@s390_prese:

; 6189 : 
; 6190 :             if (io2 == NULL || dev->tschpending)

  003a0	48 83 7c 24 60
	00		 cmp	 QWORD PTR io2$[rsp], 0
  003a6	74 15		 je	 SHORT $LN54@s390_prese
  003a8	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  003ad	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  003b3	c1 e8 1b	 shr	 eax, 27
  003b6	83 e0 01	 and	 eax, 1
  003b9	85 c0		 test	 eax, eax
  003bb	74 3b		 je	 SHORT $LN53@s390_prese
$LN54@s390_prese:

; 6191 :             {
; 6192 :                 /* Our interrupt was dequeued; retry */
; 6193 :                 release_lock( &sysblk.iointqlk );

  003bd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003c4	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  003ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182935
  003d1	48 8b c8	 mov	 rcx, rax
  003d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6194 :                 release_lock( &dev->lock );

  003da	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  003df	48 83 c0 38	 add	 rax, 56			; 00000038H
  003e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182936
  003ea	48 8b c8	 mov	 rcx, rax
  003ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6195 :                 goto retry;

  003f3	e9 60 fc ff ff	 jmp	 $retry$69
$LN53@s390_prese:

; 6196 :             }
; 6197 : 
; 6198 :             /* Extract the I/O address and interrupt parameter */
; 6199 :             *ioid = (dev->ssid << 16) | dev->subchan;

  003f8	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  003fd	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00401	c1 e0 10	 shl	 eax, 16
  00404	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00409	0f b7 49 46	 movzx	 ecx, WORD PTR [rcx+70]
  0040d	0b c1		 or	 eax, ecx
  0040f	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR ioid$[rsp]
  00417	89 01		 mov	 DWORD PTR [rcx], eax

; 6200 :             FETCH_FW( *ioparm,dev->pmcw.intparm );

  00419	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0041e	48 05 ec 02 00
	00		 add	 rax, 748		; 000002ecH
  00424	48 8b c8	 mov	 rcx, rax
  00427	e8 00 00 00 00	 call	 fetch_fw_noswap
  0042c	8b c8		 mov	 ecx, eax
  0042e	e8 00 00 00 00	 call	 _byteswap_ulong
  00433	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR ioparm$[rsp]
  0043b	89 01		 mov	 DWORD PTR [rcx], eax

; 6201 : 
; 6202 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) || defined( _FEATURE_IO_ASSIST )
; 6203 : #if defined( FEATURE_QDIO_THININT )
; 6204 :             if (unlikely( FACILITY_ENABLED( HERC_QDIO_THININT, regs )
; 6205 :                 && (dev->pciscsw.flag2 & SCSW2_Q) && dev->qdio.thinint ))
; 6206 :             {
; 6207 :                 saved_dotsch = dotsch;
; 6208 :                 PCI_dequeued = false;
; 6209 : 
; 6210 :                 dotsch = false;  /* Do not require TSCH after INT */
; 6211 : 
; 6212 :                 *iointid = 0x80000000
; 6213 :                      | (
; 6214 : #if defined( _FEATURE_IO_ASSIST )
; 6215 :                         /* For I/O Assisted devices use (V)ISC */
; 6216 :                         (SIE_MODE(regs)) ?
; 6217 :                           (icode == SIE_NO_INTERCEPT) ?
; 6218 :                             ((dev->pmcw.flag25 & PMCW25_VISC) << 27) :
; 6219 :                             ((dev->pmcw.flag25 & PMCW25_VISC) << 27)
; 6220 :                               | (dev->pmcw.zone << 16)
; 6221 :                               | ((dev->pmcw.flag27 & PMCW27_I) << 8) :
; 6222 : #endif
; 6223 :                         ((dev->pmcw.flag4 & PMCW4_ISC) << 24)
; 6224 :                           | ((dev->pmcw.flag25 & PMCW25_TYPE) << 7)
; 6225 : #if defined( _FEATURE_IO_ASSIST )
; 6226 :                           | (dev->pmcw.zone << 16)
; 6227 :                           | ((dev->pmcw.flag27 & PMCW27_I) << 8)
; 6228 : #endif
; 6229 :                 ); // *iointid =
; 6230 : 
; 6231 :                 if (!SIE_MODE(regs) || icode != SIE_INTERCEPT_IOINTP)
; 6232 :                 {
; 6233 :                     /* Dequeue the interrupt */
; 6234 :                     PCI_dequeued = DEQUEUE_IO_INTERRUPT_QLOCKED( &dev->pciioint ) == 0 ? true : false;
; 6235 : 
; 6236 :                     if (!PCI_dequeued)
; 6237 :                         dotsch = saved_dotsch; // (restore)
; 6238 :                     else
; 6239 :                     {
; 6240 :                         /* Clear the pending PCI status */
; 6241 :                         dev->pciscsw.flag2 &= ~(SCSW2_FC | SCSW2_AC);
; 6242 :                         dev->pciscsw.flag3 &= ~(SCSW3_SC);
; 6243 :                     }
; 6244 :                 }
; 6245 :                 else
; 6246 :                     PCI_dequeued = true; // (keep same logic as before!)
; 6247 :             }
; 6248 : 
; 6249 :             /* If no PCI interrupt dequeued, then dequeue a normal interrupt */
; 6250 :             if (!PCI_dequeued)
; 6251 : #endif /*defined( FEATURE_QDIO_THININT )*/
; 6252 : 
; 6253 :                 *iointid = (

  0043d	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00445	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0044b	d1 e8		 shr	 eax, 1
  0044d	83 e0 01	 and	 eax, 1
  00450	85 c0		 test	 eax, eax
  00452	74 67		 je	 SHORT $LN66@s390_prese
  00454	83 7c 24 44 ff	 cmp	 DWORD PTR icode$[rsp], -1
  00459	75 18		 jne	 SHORT $LN64@s390_prese
  0045b	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00460	0f b6 80 05 03
	00 00		 movzx	 eax, BYTE PTR [rax+773]
  00467	83 e0 07	 and	 eax, 7
  0046a	c1 e0 1b	 shl	 eax, 27
  0046d	89 44 24 58	 mov	 DWORD PTR tv231[rsp], eax
  00471	eb 3e		 jmp	 SHORT $LN65@s390_prese
$LN64@s390_prese:
  00473	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00478	0f b6 80 05 03
	00 00		 movzx	 eax, BYTE PTR [rax+773]
  0047f	83 e0 07	 and	 eax, 7
  00482	c1 e0 1b	 shl	 eax, 27
  00485	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0048a	0f b6 89 04 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+772]
  00491	c1 e1 10	 shl	 ecx, 16
  00494	0b c1		 or	 eax, ecx
  00496	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0049b	0f b6 89 07 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+775]
  004a2	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  004a8	c1 e1 08	 shl	 ecx, 8
  004ab	0b c1		 or	 eax, ecx
  004ad	89 44 24 58	 mov	 DWORD PTR tv231[rsp], eax
$LN65@s390_prese:
  004b1	8b 44 24 58	 mov	 eax, DWORD PTR tv231[rsp]
  004b5	89 44 24 5c	 mov	 DWORD PTR tv251[rsp], eax
  004b9	eb 55		 jmp	 SHORT $LN67@s390_prese
$LN66@s390_prese:
  004bb	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  004c0	0f b6 80 f0 02
	00 00		 movzx	 eax, BYTE PTR [rax+752]
  004c7	83 e0 38	 and	 eax, 56			; 00000038H
  004ca	c1 e0 18	 shl	 eax, 24
  004cd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  004d2	0f b6 89 05 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+773]
  004d9	81 e1 e0 00 00
	00		 and	 ecx, 224		; 000000e0H
  004df	c1 e1 07	 shl	 ecx, 7
  004e2	0b c1		 or	 eax, ecx
  004e4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  004e9	0f b6 89 04 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+772]
  004f0	c1 e1 10	 shl	 ecx, 16
  004f3	0b c1		 or	 eax, ecx
  004f5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  004fa	0f b6 89 07 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+775]
  00501	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00507	c1 e1 08	 shl	 ecx, 8
  0050a	0b c1		 or	 eax, ecx
  0050c	89 44 24 5c	 mov	 DWORD PTR tv251[rsp], eax
$LN67@s390_prese:
  00510	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR iointid$[rsp]
  00518	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv251[rsp]
  0051c	89 08		 mov	 DWORD PTR [rax], ecx

; 6254 : #if defined(_FEATURE_IO_ASSIST)
; 6255 :                             /* For I/O Assisted devices use (V)ISC */
; 6256 :                             (SIE_MODE(regs)) ?
; 6257 :                               (icode == SIE_NO_INTERCEPT) ?
; 6258 :                                 ((dev->pmcw.flag25 & PMCW25_VISC) << 27) :
; 6259 :                                 ((dev->pmcw.flag25 & PMCW25_VISC) << 27)
; 6260 :                                   | (dev->pmcw.zone << 16)
; 6261 :                                   | ((dev->pmcw.flag27 & PMCW27_I) << 8) :
; 6262 : #endif
; 6263 :                              ((dev->pmcw.flag4 & PMCW4_ISC) << 24)
; 6264 :                                | ((dev->pmcw.flag25 & PMCW25_TYPE) << 7)
; 6265 : #if defined(_FEATURE_IO_ASSIST)
; 6266 :                                | (dev->pmcw.zone << 16)
; 6267 :                                | ((dev->pmcw.flag27 & PMCW27_I) << 8)
; 6268 : #endif
; 6269 :                 ); // *iointid =
; 6270 : #endif /*defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) || defined( _FEATURE_IO_ASSIST ) */
; 6271 : 
; 6272 : #if defined( _FEATURE_IO_ASSIST )
; 6273 :             /* Do not drain pending interrupts
; 6274 :                on intercept due to zero ISC mask
; 6275 :              */
; 6276 :             if(!SIE_MODE(regs) || icode != SIE_INTERCEPT_IOINTP)

  0051e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00526	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0052c	d1 e8		 shr	 eax, 1
  0052e	83 e0 01	 and	 eax, 1
  00531	85 c0		 test	 eax, eax
  00533	74 07		 je	 SHORT $LN56@s390_prese
  00535	83 7c 24 44 f0	 cmp	 DWORD PTR icode$[rsp], -16
  0053a	74 4a		 je	 SHORT $LN55@s390_prese
$LN56@s390_prese:

; 6277 : #endif
; 6278 :             {
; 6279 :                 if (!SIE_MODE(regs) || icode != SIE_NO_INTERCEPT)

  0053c	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00544	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0054a	d1 e8		 shr	 eax, 1
  0054c	83 e0 01	 and	 eax, 1
  0054f	85 c0		 test	 eax, eax
  00551	74 07		 je	 SHORT $LN58@s390_prese
  00553	83 7c 24 44 ff	 cmp	 DWORD PTR icode$[rsp], -1
  00558	74 1b		 je	 SHORT $LN57@s390_prese
$LN58@s390_prese:

; 6280 :                     dev->pmcw.flag27 &= ~PMCW27_I;

  0055a	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0055f	0f b6 80 07 03
	00 00		 movzx	 eax, BYTE PTR [rax+775]
  00566	0f ba f0 07	 btr	 eax, 7
  0056a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0056f	88 81 07 03 00
	00		 mov	 BYTE PTR [rcx+775], al
$LN57@s390_prese:

; 6281 : 
; 6282 :                 /* Dequeue the interrupt */
; 6283 :                 DEQUEUE_IO_INTERRUPT_QLOCKED( io );

  00575	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182941
  0057c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR io$[rsp]
  00581	e8 00 00 00 00	 call	 Dequeue_IO_Interrupt_QLocked
$LN55@s390_prese:

; 6284 :             }
; 6285 : 
; 6286 :             /* TEST SUBCHANNEL is now required to clear the interrupt */
; 6287 :             dev->tschpending = dotsch;

  00586	0f b6 44 24 40	 movzx	 eax, BYTE PTR dotsch$[rsp]
  0058b	83 e0 01	 and	 eax, 1
  0058e	c1 e0 1b	 shl	 eax, 27
  00591	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00596	8b 89 f8 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1528]
  0059c	0f ba f1 1b	 btr	 ecx, 27
  005a0	0b c8		 or	 ecx, eax
  005a2	8b c1		 mov	 eax, ecx
  005a4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  005a9	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 6288 : 
; 6289 :             /* Perform additional architecture post processing and cleanup */
; 6290 :             switch (sysblk.arch_mode)

  005af	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005b6	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  005bc	89 44 24 4c	 mov	 DWORD PTR tv277[rsp], eax
  005c0	83 7c 24 4c 00	 cmp	 DWORD PTR tv277[rsp], 0
  005c5	74 10		 je	 SHORT $LN59@s390_prese
  005c7	83 7c 24 4c 01	 cmp	 DWORD PTR tv277[rsp], 1
  005cc	74 66		 je	 SHORT $LN60@s390_prese
  005ce	83 7c 24 4c 02	 cmp	 DWORD PTR tv277[rsp], 2
  005d3	74 61		 je	 SHORT $LN61@s390_prese
  005d5	eb 61		 jmp	 SHORT $LN62@s390_prese
$LN59@s390_prese:

; 6291 :             {
; 6292 :                 case ARCH_370_IDX:
; 6293 :                 {
; 6294 :                     IOINT*  ioint;              /* -> I/O interrupt          */
; 6295 :                     IRB     irb;                /* -> IRB                    */
; 6296 :                     SCSW*   scsw;               /* -> SCSW                   */
; 6297 :                     int     cc;                 /* Condition code ignored    */
; 6298 : 
; 6299 :                     /* Extract the I/O address and CSW */
; 6300 :                     *ioid = dev->devnum;

  005d7	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  005dc	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  005e0	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR ioid$[rsp]
  005e8	89 01		 mov	 DWORD PTR [rcx], eax

; 6301 : 
; 6302 :                     /* Perform core of TEST SUBCHANNEL work and store CSW */
; 6303 :                     cc = test_subchan_locked( regs, dev, &irb, &ioint, &scsw );

  005ea	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR scsw$6[rsp]
  005f2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005f7	4c 8d 8c 24 90
	00 00 00	 lea	 r9, QWORD PTR ioint$8[rsp]
  005ff	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR irb$9[rsp]
  00607	48 8b 54 24 30	 mov	 rdx, QWORD PTR dev$[rsp]
  0060c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00614	e8 00 00 00 00	 call	 test_subchan_locked
  00619	89 44 24 78	 mov	 DWORD PTR cc$5[rsp], eax

; 6304 :                     store_scsw_as_csw( regs, scsw );

  0061d	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR scsw$6[rsp]
  00625	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0062d	e8 00 00 00 00	 call	 store_scsw_as_csw

; 6305 :                     break;

  00632	eb 21		 jmp	 SHORT $LN35@s390_prese
$LN60@s390_prese:

; 6306 :                 }
; 6307 : 
; 6308 :                 case ARCH_390_IDX: break;

  00634	eb 1f		 jmp	 SHORT $LN35@s390_prese
$LN61@s390_prese:

; 6309 :                 case ARCH_900_IDX: break;

  00636	eb 1d		 jmp	 SHORT $LN35@s390_prese
$LN62@s390_prese:
$LN39@s390_prese:

; 6310 :                 default: CRASH();

  00638	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR p$7[rsp], 0
  00644	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR p$7[rsp]
  0064c	c6 00 00	 mov	 BYTE PTR [rax], 0
  0064f	33 c0		 xor	 eax, eax
  00651	85 c0		 test	 eax, eax
  00653	75 e3		 jne	 SHORT $LN39@s390_prese
$LN35@s390_prese:

; 6311 :             }
; 6312 : 
; 6313 :             subchannel_interrupt_queue_cleanup( dev );

  00655	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0065a	e8 00 00 00 00	 call	 subchannel_interrupt_queue_cleanup

; 6314 :             UPDATE_IC_IOPENDING_QLOCKED();

  0065f	e8 00 00 00 00	 call	 Update_IC_IOPENDING_QLocked

; 6315 :         }
; 6316 :         release_lock( &sysblk.iointqlk );

  00664	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0066b	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  00671	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182946
  00678	48 8b c8	 mov	 rcx, rax
  0067b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6317 : 
; 6318 : #if DEBUG_SCSW
; 6319 :         if (unlikely(dev->ccwtrace))
; 6320 :         {
; 6321 :             SCSW* scsw;   /* (selected SCSW) */
; 6322 : 
; 6323 :                  if (dev->pciscsw.flag3  & SCSW3_SC_PEND) scsw = &dev->pciscsw;
; 6324 :             else if (dev->scsw.flag3     & SCSW3_SC_PEND) scsw = &dev->scsw;
; 6325 :          /* else if (dev->attnscsw.flag3 & SCSW3_SC_PEND) scsw = &dev->attnscsw; */
; 6326 :             else scsw = NULL;
; 6327 : 
; 6328 :             /* Check interrupt validity */
; 6329 :             if (1
; 6330 :                 && scsw != NULL
; 6331 :                 && !(scsw->flag2 & (SCSW2_FC | SCSW2_AC))
; 6332 :                 && !(scsw->flag3 & SCSW3_AC)
; 6333 :             )
; 6334 :             {
; 6335 :                 WRMSG( HHC01393, "E", "  CHAN: Invalid SCSW presentation" );
; 6336 :                 DISPLAY_SCSW( dev, *scsw );
; 6337 :             }
; 6338 :         }
; 6339 : #endif /*DEBUG_SCSW*/
; 6340 :     }
; 6341 :     release_lock( &dev->lock );

  00681	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00686	48 83 c0 38	 add	 rax, 56			; 00000038H
  0068a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182947
  00691	48 8b c8	 mov	 rcx, rax
  00694	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6342 : 
; 6343 :     /* Exit with condition code indicating queued interrupt cleared */
; 6344 :     return icode;

  0069a	8b 44 24 44	 mov	 eax, DWORD PTR icode$[rsp]
$LN1@s390_prese:

; 6345 : 
; 6346 : } /* end function present_io_interrupt */

  0069e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  006a6	48 33 cc	 xor	 rcx, rsp
  006a9	e8 00 00 00 00	 call	 __security_check_cookie
  006ae	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  006b5	c3		 ret	 0
s390_present_io_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv156 = 96
tv182 = 100
tv338 = 104
tv344 = 108
tv196 = 112
tv200 = 116
tv203 = 120
tv207 = 124
rc$ = 128
tv375 = 136
msgbuf$1 = 144
__$ArrayPad$ = 272
regs$ = 320
dev$ = 328
orb$ = 336
s390_startio PROC

; 4199 : {

$LN31:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4200 : int     rc;                             /* Return code               */
; 4201 : 
; 4202 :     obtain_lock (&dev->lock);

  0002a	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00032	48 83 c0 38	 add	 rax, 56			; 00000038H
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182403
  0003d	48 8b c8	 mov	 rcx, rax
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4203 : 
; 4204 : #if defined(_FEATURE_IO_ASSIST)
; 4205 :     if(SIE_MODE(regs)
; 4206 :       && (regs->siebk->zone != dev->pmcw.zone

  00046	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00054	d1 e8		 shr	 eax, 1
  00056	83 e0 01	 and	 eax, 1
  00059	85 c0		 test	 eax, eax
  0005b	74 75		 je	 SHORT $LN2@s390_start
  0005d	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0006c	0f b6 40 74	 movzx	 eax, BYTE PTR [rax+116]
  00070	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00078	0f b6 89 04 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+772]
  0007f	3b c1		 cmp	 eax, ecx
  00081	75 18		 jne	 SHORT $LN3@s390_start
  00083	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0008b	0f b6 80 07 03
	00 00		 movzx	 eax, BYTE PTR [rax+775]
  00092	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00097	85 c0		 test	 eax, eax
  00099	75 37		 jne	 SHORT $LN2@s390_start
$LN3@s390_start:

; 4207 :         || !(dev->pmcw.flag27 & PMCW27_I)))
; 4208 :     {
; 4209 :         release_lock (&dev->lock);

  0009b	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a3	48 83 c0 38	 add	 rax, 56			; 00000038H
  000a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182406
  000ae	48 8b c8	 mov	 rcx, rax
  000b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4210 :         longjmp(regs->progjmp,SIE_INTERCEPT_INST);

  000b7	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bf	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000c5	ba fc ff ff ff	 mov	 edx, -4
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 longjmp
$LN2@s390_start:

; 4211 :     }
; 4212 : #endif
; 4213 : 
; 4214 :     /* Return condition code 1 if status pending */
; 4215 :     if (unlikely((dev->scsw.flag3     & SCSW3_SC_PEND)  ||

  000d2	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000da	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  000e1	83 e0 01	 and	 eax, 1
  000e4	85 c0		 test	 eax, eax
  000e6	75 4e		 jne	 SHORT $LN15@s390_start
  000e8	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000f0	0f b6 80 17 03
	00 00		 movzx	 eax, BYTE PTR [rax+791]
  000f7	83 e0 01	 and	 eax, 1
  000fa	85 c0		 test	 eax, eax
  000fc	75 38		 jne	 SHORT $LN15@s390_start
  000fe	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00106	0f b6 80 23 03
	00 00		 movzx	 eax, BYTE PTR [rax+803]
  0010d	83 e0 01	 and	 eax, 1
  00110	85 c0		 test	 eax, eax
  00112	75 22		 jne	 SHORT $LN15@s390_start
  00114	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0011c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00122	c1 e8 1b	 shr	 eax, 27
  00125	83 e0 01	 and	 eax, 1
  00128	85 c0		 test	 eax, eax
  0012a	75 0a		 jne	 SHORT $LN15@s390_start
  0012c	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv156[rsp], 0
  00134	eb 08		 jmp	 SHORT $LN18@s390_start
$LN15@s390_start:
  00136	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv156[rsp], 1
$LN18@s390_start:
  0013e	83 7c 24 60 00	 cmp	 DWORD PTR tv156[rsp], 0
  00143	74 26		 je	 SHORT $LN4@s390_start

; 4216 :                  (dev->pciscsw.flag3  & SCSW3_SC_PEND)  ||
; 4217 :                  (dev->attnscsw.flag3 & SCSW3_SC_PEND)  ||
; 4218 :                  dev->tschpending))
; 4219 :     {
; 4220 :         release_lock (&dev->lock);

  00145	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0014d	48 83 c0 38	 add	 rax, 56			; 00000038H
  00151	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182408
  00158	48 8b c8	 mov	 rcx, rax
  0015b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4221 :         return 1;

  00161	b8 01 00 00 00	 mov	 eax, 1
  00166	e9 06 06 00 00	 jmp	 $LN1@s390_start
$LN4@s390_start:

; 4222 :     }
; 4223 : 
; 4224 :     /* Return condition code 2 if device is busy */
; 4225 : #if defined( OPTION_SHARED_DEVICES )
; 4226 :     if (unlikely((dev->busy && dev->shioactive == DEV_SYS_LOCAL)

  0016b	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00173	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00179	c1 e8 13	 shr	 eax, 19
  0017c	83 e0 01	 and	 eax, 1
  0017f	85 c0		 test	 eax, eax
  00181	74 14		 je	 SHORT $LN19@s390_start
  00183	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0018b	81 b8 e4 05 00
	00 ff ff 00 00	 cmp	 DWORD PTR [rax+1508], 65535 ; 0000ffffH
  00195	74 22		 je	 SHORT $LN20@s390_start
$LN19@s390_start:
  00197	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0019f	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001a5	c1 e8 19	 shr	 eax, 25
  001a8	83 e0 01	 and	 eax, 1
  001ab	85 c0		 test	 eax, eax
  001ad	75 0a		 jne	 SHORT $LN20@s390_start
  001af	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv182[rsp], 0
  001b7	eb 08		 jmp	 SHORT $LN24@s390_start
$LN20@s390_start:
  001b9	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv182[rsp], 1
$LN24@s390_start:
  001c1	83 7c 24 64 00	 cmp	 DWORD PTR tv182[rsp], 0
  001c6	0f 84 22 01 00
	00		 je	 $LN5@s390_start

; 4227 :         || dev->startpending))
; 4228 : #else // !defined( OPTION_SHARED_DEVICES )
; 4229 :     if (unlikely((dev->busy)
; 4230 :         || dev->startpending))
; 4231 : #endif // defined( OPTION_SHARED_DEVICES )
; 4232 :     {
; 4233 :         release_lock (&dev->lock);

  001cc	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001d4	48 83 c0 38	 add	 rax, 56			; 00000038H
  001d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182410
  001df	48 8b c8	 mov	 rcx, rax
  001e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4234 : 
; 4235 :         /*************************************************************/
; 4236 :         /* VM system abends IQM00 were found to be caused by startio */
; 4237 :         /* SSCH resulting in cc=2 thanks to this additional log msg. */
; 4238 :         /*                        Peter J. Jansen, 21-Jun-2016       */
; 4239 :         /*************************************************************/
; 4240 :         if (dev->ccwtrace)

  001e8	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001f0	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001f6	c1 e8 0f	 shr	 eax, 15
  001f9	83 e0 01	 and	 eax, 1
  001fc	85 c0		 test	 eax, eax
  001fe	0f 84 e0 00 00
	00		 je	 $LN6@s390_start

; 4241 :         {
; 4242 :             if (sysblk.traceFILE)

  00204	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0020b	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00213	74 13		 je	 SHORT $LN7@s390_start

; 4243 :                 tf_1336( dev );

  00215	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0021d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1336
  00223	e9 bc 00 00 00	 jmp	 $LN8@s390_start
$LN7@s390_start:

; 4244 :             else
; 4245 :                 // "%1d:%04X CHAN: startio cc=2 (busy=%d startpending=%d)"
; 4246 :                 WRMSG( HHC01336, "I", SSID_TO_LCSS(dev->ssid),

  00228	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00230	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00236	c1 e8 19	 shr	 eax, 25
  00239	83 e0 01	 and	 eax, 1
  0023c	89 44 24 70	 mov	 DWORD PTR tv196[rsp], eax
  00240	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00248	8b 89 f8 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1528]
  0024e	c1 e9 13	 shr	 ecx, 19
  00251	83 e1 01	 and	 ecx, 1
  00254	89 4c 24 74	 mov	 DWORD PTR tv200[rsp], ecx
  00258	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00260	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00264	89 54 24 78	 mov	 DWORD PTR tv203[rsp], edx
  00268	4c 8b 84 24 48
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00270	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  00275	41 d1 f8	 sar	 r8d, 1
  00278	44 89 44 24 7c	 mov	 DWORD PTR tv207[rsp], r8d
  0027d	b9 01 00 00 00	 mov	 ecx, 1
  00282	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00288	8b 4c 24 70	 mov	 ecx, DWORD PTR tv196[rsp]
  0028c	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00290	8b 4c 24 74	 mov	 ecx, DWORD PTR tv200[rsp]
  00294	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00298	8b 4c 24 78	 mov	 ecx, DWORD PTR tv203[rsp]
  0029c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002a0	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv207[rsp]
  002a4	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182414
  002af	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182415
  002bb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002c0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c5	41 b9 03 00 00
	00		 mov	 r9d, 3
  002cb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG182416
  002d2	ba 97 10 00 00	 mov	 edx, 4247		; 00001097H
  002d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182417
  002de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN8@s390_start:
$LN6@s390_start:

; 4247 :                        dev->devnum, dev->busy, dev->startpending );
; 4248 :         }
; 4249 : 
; 4250 :         return 2;

  002e4	b8 02 00 00 00	 mov	 eax, 2
  002e9	e9 83 04 00 00	 jmp	 $LN1@s390_start
$LN5@s390_start:

; 4251 :     }
; 4252 : 
; 4253 :     /* Ensure clean status flag bits */
; 4254 :     dev->suspended          = 0;

  002ee	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002f6	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  002fc	0f ba f0 15	 btr	 eax, 21
  00300	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00308	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4255 :     dev->pending            = 0;

  0030e	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00316	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0031c	0f ba f0 16	 btr	 eax, 22
  00320	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00328	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4256 :     dev->pcipending         = 0;

  0032e	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00336	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0033c	0f ba f0 17	 btr	 eax, 23
  00340	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00348	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4257 :     dev->attnpending        = 0;

  0034e	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00356	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0035c	0f ba f0 18	 btr	 eax, 24
  00360	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00368	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4258 :     dev->startpending       = 0;

  0036e	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00376	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0037c	0f ba f0 19	 btr	 eax, 25
  00380	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00388	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4259 :     dev->resumesuspended    = 0;

  0038e	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00396	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0039c	0f ba f0 1a	 btr	 eax, 26
  003a0	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003a8	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4260 :     dev->tschpending        = 0;

  003ae	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003b6	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  003bc	0f ba f0 1b	 btr	 eax, 27
  003c0	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003c8	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4261 : 
; 4262 :     /* Initialize the subchannel status word */
; 4263 :     memset (&dev->scsw,     0, sizeof(SCSW));

  003ce	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003d6	48 05 08 03 00
	00		 add	 rax, 776		; 00000308H
  003dc	48 8b f8	 mov	 rdi, rax
  003df	33 c0		 xor	 eax, eax
  003e1	b9 0c 00 00 00	 mov	 ecx, 12
  003e6	f3 aa		 rep stosb

; 4264 :     dev->scsw.flag0 = (orb->flag4 & (SCSW0_KEY |

  003e8	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR orb$[rsp]
  003f0	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  003f4	25 f8 00 00 00	 and	 eax, 248		; 000000f8H
  003f9	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00401	88 81 08 03 00
	00		 mov	 BYTE PTR [rcx+776], al

; 4265 :                                      SCSW0_S));
; 4266 :     dev->scsw.flag1 = (orb->flag5 & (SCSW1_F   |

  00407	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR orb$[rsp]
  0040f	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00413	25 f8 00 00 00	 and	 eax, 248		; 000000f8H
  00418	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00420	88 81 09 03 00
	00		 mov	 BYTE PTR [rcx+777], al

; 4267 :                                      SCSW1_P   |
; 4268 :                                      SCSW1_I   |
; 4269 :                                      SCSW1_A   |
; 4270 :                                      SCSW1_U));
; 4271 : 
; 4272 :     /* Set the device busy indicator */
; 4273 :     set_subchannel_busy(dev);

  00426	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0042e	e8 00 00 00 00	 call	 set_subchannel_busy

; 4274 : 
; 4275 :     /* Initialize shadow SCSWs */
; 4276 :     memcpy(&dev->pciscsw,  &dev->scsw, sizeof(SCSW));

  00433	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0043b	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00443	48 8d b8 14 03
	00 00		 lea	 rdi, QWORD PTR [rax+788]
  0044a	48 8d b1 08 03
	00 00		 lea	 rsi, QWORD PTR [rcx+776]
  00451	b9 0c 00 00 00	 mov	 ecx, 12
  00456	f3 a4		 rep movsb

; 4277 :     memcpy(&dev->attnscsw, &dev->scsw, sizeof(SCSW));

  00458	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00460	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00468	48 8d b8 20 03
	00 00		 lea	 rdi, QWORD PTR [rax+800]
  0046f	48 8d b1 08 03
	00 00		 lea	 rsi, QWORD PTR [rcx+776]
  00476	b9 0c 00 00 00	 mov	 ecx, 12
  0047b	f3 a4		 rep movsb

; 4278 : 
; 4279 :     /* Make the subchannel start-pending */
; 4280 :     dev->scsw.flag2 |= SCSW2_FC_START | SCSW2_AC_START;

  0047d	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00485	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  0048c	83 c8 44	 or	 eax, 68			; 00000044H
  0048f	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00497	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 4281 :     dev->startpending = 1;

  0049d	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004a5	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  004ab	0f ba e8 19	 bts	 eax, 25
  004af	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004b7	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4282 : 
; 4283 :     /* Copy the I/O parameter to the path management control word */
; 4284 :     memcpy (dev->pmcw.intparm, orb->intparm,

  004bd	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004c5	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR orb$[rsp]
  004cd	8b 09		 mov	 ecx, DWORD PTR [rcx]
  004cf	89 88 ec 02 00
	00		 mov	 DWORD PTR [rax+748], ecx

; 4285 :                         sizeof(dev->pmcw.intparm));
; 4286 : 
; 4287 :     /* Store the start I/O parameters in the device block */
; 4288 :     if (orb->flag7 & ORB7_X)

  004d5	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR orb$[rsp]
  004dd	0f b6 40 07	 movzx	 eax, BYTE PTR [rax+7]
  004e1	83 e0 01	 and	 eax, 1
  004e4	85 c0		 test	 eax, eax
  004e6	74 20		 je	 SHORT $LN9@s390_start

; 4289 :     {
; 4290 :         /* Extended ORB */
; 4291 :         memcpy(&dev->orb, orb, sizeof(ORB));

  004e8	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004f0	48 8d b8 cc 02
	00 00		 lea	 rdi, QWORD PTR [rax+716]
  004f7	48 8b b4 24 50
	01 00 00	 mov	 rsi, QWORD PTR orb$[rsp]
  004ff	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00504	f3 a4		 rep movsb

; 4292 :     }

  00506	eb 38		 jmp	 SHORT $LN10@s390_start
$LN9@s390_start:

; 4293 :     else
; 4294 :     {
; 4295 :         /* Original ORB size */
; 4296 :         memcpy(&dev->orb, orb, 12);

  00508	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00510	48 8d b8 cc 02
	00 00		 lea	 rdi, QWORD PTR [rax+716]
  00517	48 8b b4 24 50
	01 00 00	 mov	 rsi, QWORD PTR orb$[rsp]
  0051f	b9 0c 00 00 00	 mov	 ecx, 12
  00524	f3 a4		 rep movsb

; 4297 :         memset(&dev->orb.csspriority, 0, sizeof(ORB) - 12);

  00526	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0052e	48 05 d8 02 00
	00		 add	 rax, 728		; 000002d8H
  00534	48 8b f8	 mov	 rdi, rax
  00537	33 c0		 xor	 eax, eax
  00539	b9 14 00 00 00	 mov	 ecx, 20
  0053e	f3 aa		 rep stosb
$LN10@s390_start:

; 4298 :     }
; 4299 : 
; 4300 :     if (dev->orbtrace)

  00540	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00548	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0054e	c1 e8 0e	 shr	 eax, 14
  00551	83 e0 01	 and	 eax, 1
  00554	85 c0		 test	 eax, eax
  00556	0f 84 24 01 00
	00		 je	 $LN11@s390_start

; 4301 :     {
; 4302 :         if (dev->ccwtrace && sysblk.traceFILE)

  0055c	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00564	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0056a	c1 e8 0f	 shr	 eax, 15
  0056d	83 e0 01	 and	 eax, 1
  00570	85 c0		 test	 eax, eax
  00572	74 2c		 je	 SHORT $LN12@s390_start
  00574	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0057b	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00583	74 1b		 je	 SHORT $LN12@s390_start

; 4303 :             tf_1334( dev, orb );

  00585	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR orb$[rsp]
  0058d	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00595	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1334
  0059b	e9 e0 00 00 00	 jmp	 $LN13@s390_start
$LN12@s390_start:

; 4304 :         else
; 4305 :         {
; 4306 :             char msgbuf[128] = {0};

  005a0	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR msgbuf$1[rsp]
  005a8	48 8b f8	 mov	 rdi, rax
  005ab	33 c0		 xor	 eax, eax
  005ad	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  005b2	f3 aa		 rep stosb

; 4307 :             FormatORB( orb, msgbuf, sizeof( msgbuf ));

  005b4	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  005ba	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR msgbuf$1[rsp]
  005c2	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR orb$[rsp]
  005ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FormatORB

; 4308 :             // "%1d:%04X CHAN: ORB: %s"
; 4309 :             WRMSG( HHC01334, "I", LCSS_DEVNUM, msgbuf );

  005d0	48 83 bc 24 48
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  005d9	74 12		 je	 SHORT $LN25@s390_start
  005db	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005e3	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  005e7	89 44 24 68	 mov	 DWORD PTR tv338[rsp], eax
  005eb	eb 08		 jmp	 SHORT $LN26@s390_start
$LN25@s390_start:
  005ed	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv338[rsp], 0
$LN26@s390_start:
  005f5	48 83 bc 24 48
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  005fe	74 14		 je	 SHORT $LN27@s390_start
  00600	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00608	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0060c	d1 f8		 sar	 eax, 1
  0060e	89 44 24 6c	 mov	 DWORD PTR tv344[rsp], eax
  00612	eb 08		 jmp	 SHORT $LN28@s390_start
$LN27@s390_start:
  00614	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv344[rsp], 0
$LN28@s390_start:
  0061c	b9 01 00 00 00	 mov	 ecx, 1
  00621	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00627	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR msgbuf$1[rsp]
  0062f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00634	8b 4c 24 68	 mov	 ecx, DWORD PTR tv338[rsp]
  00638	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0063c	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv344[rsp]
  00640	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00644	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182423
  0064b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00650	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182424
  00657	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0065c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00661	41 b9 03 00 00
	00		 mov	 r9d, 3
  00667	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG182425
  0066e	ba d5 10 00 00	 mov	 edx, 4309		; 000010d5H
  00673	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182426
  0067a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN13@s390_start:
$LN11@s390_start:

; 4310 :         }
; 4311 :     }
; 4312 : 
; 4313 :     /* Set I/O priority */
; 4314 :     dev->priority &= 0x00FF0000ULL;

  00680	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00688	48 63 80 18 02
	00 00		 movsxd	 rax, DWORD PTR [rax+536]
  0068f	48 25 00 00 ff
	00		 and	 rax, 16711680		; 00ff0000H
  00695	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0069d	89 81 18 02 00
	00		 mov	 DWORD PTR [rcx+536], eax

; 4315 :     dev->priority |= dev->orb.csspriority << 8;

  006a3	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006ab	0f b6 80 d8 02
	00 00		 movzx	 eax, BYTE PTR [rax+728]
  006b2	c1 e0 08	 shl	 eax, 8
  006b5	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006bd	8b 89 18 02 00
	00		 mov	 ecx, DWORD PTR [rcx+536]
  006c3	0b c8		 or	 ecx, eax
  006c5	8b c1		 mov	 eax, ecx
  006c7	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006cf	89 81 18 02 00
	00		 mov	 DWORD PTR [rcx+536], eax

; 4316 :     dev->priority |= dev->orb.cupriority;

  006d5	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006dd	0f b6 80 da 02
	00 00		 movzx	 eax, BYTE PTR [rax+730]
  006e4	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006ec	8b 89 18 02 00
	00		 mov	 ecx, DWORD PTR [rcx+536]
  006f2	0b c8		 or	 ecx, eax
  006f4	8b c1		 mov	 eax, ecx
  006f6	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006fe	89 81 18 02 00
	00		 mov	 DWORD PTR [rcx+536], eax

; 4317 : 
; 4318 :     /* Schedule the I/O for execution */
; 4319 :     rc = schedule_ioq((sysblk.arch_mode == ARCH_370_IDX) ? regs : NULL,

  00704	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0070b	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [rax+136], 0
  00712	75 12		 jne	 SHORT $LN29@s390_start
  00714	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0071c	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv375[rsp], rax
  00724	eb 0c		 jmp	 SHORT $LN30@s390_start
$LN29@s390_start:
  00726	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv375[rsp], 0
$LN30@s390_start:
  00732	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0073a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv375[rsp]
  00742	e8 00 00 00 00	 call	 schedule_ioq
  00747	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 4320 :                       dev);
; 4321 : 
; 4322 :     /* Done; release locks and return */
; 4323 :     release_lock (&dev->lock);

  0074e	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00756	48 83 c0 38	 add	 rax, 56			; 00000038H
  0075a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182427
  00761	48 8b c8	 mov	 rcx, rax
  00764	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4324 :     return (rc);

  0076a	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR rc$[rsp]
$LN1@s390_start:
$LN14@s390_start:

; 4325 : 
; 4326 : } /* end function startio */

  00771	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00779	48 33 cc	 xor	 rcx, rsp
  0077c	e8 00 00 00 00	 call	 __security_check_cookie
  00781	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  00788	5f		 pop	 rdi
  00789	5e		 pop	 rsi
  0078a	c3		 ret	 0
s390_startio ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
i$ = 0
tv160 = 4
regs$ = 32
dev$ = 40
s370_interrupt_enabled PROC

; 5914 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 5915 : int     i;                              /* Interruption subclass     */
; 5916 : 
; 5917 :     /* Ignore this device if subchannel not valid */
; 5918 :     if (!(dev->pmcw.flag5 & PMCW5_V))

  0000e	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00013	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0001a	83 e0 01	 and	 eax, 1
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN2@s370_inter

; 5919 :         return 0;

  00021	33 c0		 xor	 eax, eax
  00023	e9 7f 01 00 00	 jmp	 $LN1@s370_inter
$LN2@s370_inter:

; 5920 : 
; 5921 : #if defined(_FEATURE_IO_ASSIST)
; 5922 :     /* For I/O Assist the zone must match the guest zone */
; 5923 :     if(SIE_MODE(regs) && regs->siebk->zone != dev->pmcw.zone)

  00028	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  0002d	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00033	d1 e8		 shr	 eax, 1
  00035	83 e0 01	 and	 eax, 1
  00038	85 c0		 test	 eax, eax
  0003a	74 27		 je	 SHORT $LN3@s370_inter
  0003c	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00041	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00048	0f b6 40 74	 movzx	 eax, BYTE PTR [rax+116]
  0004c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dev$[rsp]
  00051	0f b6 89 04 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+772]
  00058	3b c1		 cmp	 eax, ecx
  0005a	74 07		 je	 SHORT $LN3@s370_inter

; 5924 :         return 0;

  0005c	33 c0		 xor	 eax, eax
  0005e	e9 44 01 00 00	 jmp	 $LN1@s370_inter
$LN3@s370_inter:

; 5925 : #endif
; 5926 : 
; 5927 : #if defined(_FEATURE_IO_ASSIST)
; 5928 :     /* The interrupt interlock control bit must be on
; 5929 :        if not we must intercept */
; 5930 :     if(SIE_MODE(regs) && !(dev->pmcw.flag27 & PMCW27_I))

  00063	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00068	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0006e	d1 e8		 shr	 eax, 1
  00070	83 e0 01	 and	 eax, 1
  00073	85 c0		 test	 eax, eax
  00075	74 1f		 je	 SHORT $LN4@s370_inter
  00077	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0007c	0f b6 80 07 03
	00 00		 movzx	 eax, BYTE PTR [rax+775]
  00083	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00088	85 c0		 test	 eax, eax
  0008a	75 0a		 jne	 SHORT $LN4@s370_inter

; 5931 :         return SIE_INTERCEPT_IOINT;

  0008c	b8 f1 ff ff ff	 mov	 eax, -15
  00091	e9 11 01 00 00	 jmp	 $LN1@s370_inter
$LN4@s370_inter:

; 5932 : #endif
; 5933 : 
; 5934 : #ifdef FEATURE_S370_CHANNEL
; 5935 : 
; 5936 : #if defined(FEATURE_CHANNEL_SWITCHING)
; 5937 :     /* Is this device on a channel connected to this CPU? */
; 5938 :     if(
; 5939 : #if defined(_FEATURE_IO_ASSIST)
; 5940 :        !SIE_MODE(regs) &&

  00096	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000a1	d1 e8		 shr	 eax, 1
  000a3	83 e0 01	 and	 eax, 1
  000a6	85 c0		 test	 eax, eax
  000a8	75 20		 jne	 SHORT $LN5@s370_inter
  000aa	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  000af	0f b7 80 38 08
	00 00		 movzx	 eax, WORD PTR [rax+2104]
  000b6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dev$[rsp]
  000bb	0f b7 49 4c	 movzx	 ecx, WORD PTR [rcx+76]
  000bf	3b c1		 cmp	 eax, ecx
  000c1	74 07		 je	 SHORT $LN5@s370_inter

; 5941 : #endif
; 5942 :        regs->chanset != dev->chanset)
; 5943 :         return 0;

  000c3	33 c0		 xor	 eax, eax
  000c5	e9 dd 00 00 00	 jmp	 $LN1@s370_inter
$LN5@s370_inter:

; 5944 : #endif /*defined(FEATURE_CHANNEL_SWITCHING)*/
; 5945 : 
; 5946 :     /* Isolate the channel number */
; 5947 :     i = dev->devnum >> 8;

  000ca	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  000cf	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000d3	c1 f8 08	 sar	 eax, 8
  000d6	89 04 24	 mov	 DWORD PTR i$[rsp], eax

; 5948 :     if (!ECMODE(&regs->psw) && i < 6)

  000d9	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  000de	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000e2	83 e0 08	 and	 eax, 8
  000e5	85 c0		 test	 eax, eax
  000e7	75 45		 jne	 SHORT $LN6@s370_inter
  000e9	83 3c 24 06	 cmp	 DWORD PTR i$[rsp], 6
  000ed	7d 3f		 jge	 SHORT $LN6@s370_inter

; 5949 :     {
; 5950 : #if defined(_FEATURE_IO_ASSIST)
; 5951 :         /* We must always intercept in BC mode */
; 5952 :         if(SIE_MODE(regs))

  000ef	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  000f4	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000fa	d1 e8		 shr	 eax, 1
  000fc	83 e0 01	 and	 eax, 1
  000ff	85 c0		 test	 eax, eax
  00101	74 0a		 je	 SHORT $LN8@s370_inter

; 5953 :             return SIE_INTERCEPT_IOINT;

  00103	b8 f1 ff ff ff	 mov	 eax, -15
  00108	e9 9a 00 00 00	 jmp	 $LN1@s370_inter
$LN8@s370_inter:

; 5954 : #endif
; 5955 :         /* For BC mode channels 0-5, test system mask bits 0-5 */
; 5956 :         if ((regs->psw.sysmask & (0x80 >> i)) == 0)

  0010d	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00112	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00116	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  00119	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0011e	d3 fa		 sar	 edx, cl
  00120	8b ca		 mov	 ecx, edx
  00122	23 c1		 and	 eax, ecx
  00124	85 c0		 test	 eax, eax
  00126	75 04		 jne	 SHORT $LN9@s370_inter

; 5957 :             return 0;

  00128	33 c0		 xor	 eax, eax
  0012a	eb 7b		 jmp	 SHORT $LN1@s370_inter
$LN9@s370_inter:

; 5958 :     }

  0012c	eb 74		 jmp	 SHORT $LN7@s370_inter
$LN6@s370_inter:

; 5959 :     else
; 5960 :     {
; 5961 :         /* For EC mode and channels 6-31, test system mask bit 6 */
; 5962 :         if ((regs->psw.sysmask & PSW_IOMASK) == 0)

  0012e	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00133	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00137	83 e0 02	 and	 eax, 2
  0013a	85 c0		 test	 eax, eax
  0013c	75 04		 jne	 SHORT $LN10@s370_inter

; 5963 :             return 0;

  0013e	33 c0		 xor	 eax, eax
  00140	eb 65		 jmp	 SHORT $LN1@s370_inter
$LN10@s370_inter:

; 5964 : 
; 5965 :         /* If I/O mask is enabled, test channel masks in CR2 */
; 5966 :         if (i > 31) i = 31;

  00142	83 3c 24 1f	 cmp	 DWORD PTR i$[rsp], 31
  00146	7e 07		 jle	 SHORT $LN11@s370_inter
  00148	c7 04 24 1f 00
	00 00		 mov	 DWORD PTR i$[rsp], 31
$LN11@s370_inter:

; 5967 :         if ((CHANNEL_MASKS(regs) & (0x80000000 >> i)) == 0)

  0014f	b8 08 00 00 00	 mov	 eax, 8
  00154	48 6b c0 03	 imul	 rax, rax, 3
  00158	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  0015b	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  00160	d3 ea		 shr	 edx, cl
  00162	8b ca		 mov	 ecx, edx
  00164	48 8b 54 24 20	 mov	 rdx, QWORD PTR regs$[rsp]
  00169	8b 84 02 00 06
	00 00		 mov	 eax, DWORD PTR [rdx+rax+1536]
  00170	23 c1		 and	 eax, ecx
  00172	85 c0		 test	 eax, eax
  00174	75 2c		 jne	 SHORT $LN12@s370_inter

; 5968 :             return

  00176	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  0017b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00181	d1 e8		 shr	 eax, 1
  00183	83 e0 01	 and	 eax, 1
  00186	85 c0		 test	 eax, eax
  00188	74 0a		 je	 SHORT $LN14@s370_inter
  0018a	c7 44 24 04 f0
	ff ff ff	 mov	 DWORD PTR tv160[rsp], -16
  00192	eb 08		 jmp	 SHORT $LN15@s370_inter
$LN14@s370_inter:
  00194	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv160[rsp], 0
$LN15@s370_inter:
  0019c	8b 44 24 04	 mov	 eax, DWORD PTR tv160[rsp]
  001a0	eb 05		 jmp	 SHORT $LN1@s370_inter
$LN12@s370_inter:
$LN7@s370_inter:

; 5969 : #if defined(_FEATURE_IO_ASSIST)
; 5970 :                    SIE_MODE(regs) ? SIE_INTERCEPT_IOINTP :
; 5971 : #endif
; 5972 :                                                            0;
; 5973 :     }
; 5974 : #endif /*FEATURE_S370_CHANNEL*/
; 5975 : 
; 5976 : #ifdef FEATURE_CHANNEL_SUBSYSTEM
; 5977 :     /* Ignore this device if subchannel not enabled */
; 5978 :     if (!(dev->pmcw.flag5 & PMCW5_E))
; 5979 :         return 0;
; 5980 : 
; 5981 :     /* Isolate the interruption subclass */
; 5982 :     i =
; 5983 : #if defined(_FEATURE_IO_ASSIST)
; 5984 :         /* For I/O Assisted devices use the guest (V)ISC */
; 5985 :         SIE_MODE(regs) ? (dev->pmcw.flag25 & PMCW25_VISC) :
; 5986 : #endif
; 5987 :         ((dev->pmcw.flag4 & PMCW4_ISC) >> 3);
; 5988 : 
; 5989 :     /* Test interruption subclass mask bit in CR6 */
; 5990 :     if ((regs->CR_L(6) & (0x80000000 >> i)) == 0)
; 5991 :         return
; 5992 : #if defined(_FEATURE_IO_ASSIST)
; 5993 :                    SIE_MODE(regs) ? SIE_INTERCEPT_IOINTP :
; 5994 : #endif
; 5995 :                                                            0;
; 5996 : #endif /*FEATURE_CHANNEL_SUBSYSTEM*/
; 5997 : 
; 5998 :     /* Interrupts are enabled for this device */
; 5999 :     return SIE_NO_INTERCEPT;

  001a2	b8 ff ff ff ff	 mov	 eax, -1
$LN1@s370_inter:

; 6000 : } /* end function interrupt_enabled */

  001a7	48 83 c4 18	 add	 rsp, 24
  001ab	c3		 ret	 0
s370_interrupt_enabled ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
pIOBUF$ = 48
pInitial_IOBUF$ = 56
pvRetVal$ = 64
execute_ccw_chain_fast_return PROC

; 4342 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4343 :     if (pIOBUF != pInitial_IOBUF)

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR pInitial_IOBUF$[rsp]
  00018	48 39 44 24 30	 cmp	 QWORD PTR pIOBUF$[rsp], rax
  0001d	74 0a		 je	 SHORT $LN2@execute_cc

; 4344 :         iobuf_destroy( pIOBUF );

  0001f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pIOBUF$[rsp]
  00024	e8 00 00 00 00	 call	 iobuf_destroy
$LN2@execute_cc:

; 4345 :     return pvRetVal;

  00029	48 8b 44 24 40	 mov	 rax, QWORD PTR pvRetVal$[rsp]

; 4346 : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
execute_ccw_chain_fast_return ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
idalen$ = 80
ps$ = 84
to_memory$ = 88
readbackwards$ = 89
storkey$ = 90
to_iobuf$ = 91
idacount$ = 92
page$ = 96
idawaddr$ = 104
idadata$ = 112
idaseq$ = 120
tv128 = 124
tv141 = 128
iobufptr$ = 136
idasize$ = 144
iobufptr$1 = 152
tv476 = 160
tv484 = 168
tv498 = 176
tv580 = 184
tv588 = 192
tv591 = 200
startpage$ = 208
endpage$ = 216
tv377 = 224
dev$ = 272
ccw$ = 280
code$ = 288
flags$ = 296
addr$ = 304
count$ = 312
ccwkey$ = 320
idawfmt$ = 328
idapmask$ = 336
iobuf$ = 344
iobufstart$ = 352
iobufend$ = 360
chanstat$ = 368
residual$ = 376
prefetch$ = 384
s370_copy_iobuf PROC

; 3372 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H

; 3373 : BYTE    *iobufptr = 0;                  /* Working I/O buffer addr   */

  0001d	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR iobufptr$[rsp], 0

; 3374 : u_int   ps = 0;                         /* Prefetch entry            */

  00029	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR ps$[rsp], 0

; 3375 : U32     idawaddr;                       /* Main storage addr of IDAW */
; 3376 : U16     idacount;                       /* IDA bytes remaining       */
; 3377 : int     idaseq;                         /* IDA sequence number       */
; 3378 : RADR    idadata;                        /* IDA data address          */
; 3379 : U16     idalen;                         /* IDA data length           */
; 3380 : int     idasize;                        /* IDAW Size                 */
; 3381 : BYTE    storkey;                        /* Storage key               */
; 3382 : RADR    page,startpage,endpage;         /* Storage key pages         */
; 3383 : BYTE    to_iobuf;                       /* 1=READ, SENSE, or RDBACK  */
; 3384 : BYTE    to_memory;                      /* 1=READ, SENSE, or RDBACK  */
; 3385 : BYTE    readbackwards;                  /* 1=RDBACK                  */
; 3386 : #if defined(FEATURE_MIDAW_FACILITY)
; 3387 : int     midawseq;                       /* MIDAW counter (0=1st)     */
; 3388 : U32     midawptr;                       /* Real addr of MIDAW        */
; 3389 : U16     midawrem;                       /* CCW bytes remaining       */
; 3390 : U16     midawlen=0;                     /* MIDAW data length         */
; 3391 : RADR    midawdat=0;                     /* MIDAW data area addr      */
; 3392 : BYTE    midawflg;                       /* MIDAW flags               */
; 3393 : #endif /*defined(FEATURE_MIDAW_FACILITY)*/
; 3394 : 
; 3395 : #if !defined(set_chanstat)
; 3396 : #define set_chanstat(_status)                                          \
; 3397 : do {                                                                   \
; 3398 :     if (prefetch->seq)                                                 \
; 3399 :         prefetch->chanstat[ps] = (_status);                            \
; 3400 :     else                                                               \
; 3401 :         *chanstat = (_status);                                         \
; 3402 : } while(0)
; 3403 : #endif
; 3404 : 
; 3405 : #if !defined(get_new_prefetch_entry)
; 3406 : #define get_new_prefetch_entry(_idawtype,_idawaddr)                    \
; 3407 : do {                                                                   \
; 3408 :     if (prefetch->seq)                                                 \
; 3409 :     {                                                                  \
; 3410 :         ps = prefetch->seq++;                                          \
; 3411 :         if (prefetch->seq > PF_SIZE)                                   \
; 3412 :         {                                                              \
; 3413 :             *chanstat = CSW_CDC;                                       \
; 3414 :             break;                                                     \
; 3415 :         }                                                              \
; 3416 :         prefetch->ccwaddr[ps] = prefetch->ccwaddr[ps-1];               \
; 3417 :         if ((_idawtype) != PF_NO_IDAW)                                 \
; 3418 :         {                                                              \
; 3419 :             prefetch->idawtype[ps] = (_idawtype);                      \
; 3420 :             prefetch->idawaddr[ps] = (_idawaddr);                      \
; 3421 :         }                                                              \
; 3422 :     }                                                                  \
; 3423 :     *chanstat = 0;                                                     \
; 3424 : } while(0)
; 3425 : #endif
; 3426 : 
; 3427 :     /* Set current prefetch sequence */
; 3428 :     if (prefetch->seq)

  00031	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00039	83 38 00	 cmp	 DWORD PTR [rax], 0
  0003c	74 10		 je	 SHORT $LN38@s370_copy_

; 3429 :         ps = prefetch->seq - 1;

  0003e	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00046	8b 00		 mov	 eax, DWORD PTR [rax]
  00048	ff c8		 dec	 eax
  0004a	89 44 24 54	 mov	 DWORD PTR ps$[rsp], eax
$LN38@s370_copy_:

; 3430 : 
; 3431 :     /* Channel Data Check if invalid I/O buffer */
; 3432 :     if ((size_t)iobufend < 131072   ||  /* Low host OS storage reference */
; 3433 :         iobuf < iobufstart          ||

  0004e	48 81 bc 24 68
	01 00 00 00 00
	02 00		 cmp	 QWORD PTR iobufend$[rsp], 131072 ; 00020000H
  0005a	72 24		 jb	 SHORT $LN40@s370_copy_
  0005c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR iobufstart$[rsp]
  00064	48 39 84 24 58
	01 00 00	 cmp	 QWORD PTR iobuf$[rsp], rax
  0006c	72 12		 jb	 SHORT $LN40@s370_copy_
  0006e	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR iobufend$[rsp]
  00076	48 39 84 24 58
	01 00 00	 cmp	 QWORD PTR iobuf$[rsp], rax
  0007e	76 36		 jbe	 SHORT $LN39@s370_copy_
$LN40@s370_copy_:
$LN4@s370_copy_:

; 3434 :         iobuf > iobufend)
; 3435 :     {
; 3436 :         set_chanstat(CSW_CDC);

  00080	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00088	83 38 00	 cmp	 DWORD PTR [rax], 0
  0008b	74 13		 je	 SHORT $LN41@s370_copy_
  0008d	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00091	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00099	c6 44 01 10 08	 mov	 BYTE PTR [rcx+rax+16], 8
  0009e	eb 0b		 jmp	 SHORT $LN42@s370_copy_
$LN41@s370_copy_:
  000a0	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  000a8	c6 00 08	 mov	 BYTE PTR [rax], 8
$LN42@s370_copy_:
  000ab	33 c0		 xor	 eax, eax
  000ad	85 c0		 test	 eax, eax
  000af	75 cf		 jne	 SHORT $LN4@s370_copy_

; 3437 :         return;

  000b1	e9 c0 10 00 00	 jmp	 $LN1@s370_copy_
$LN39@s370_copy_:

; 3438 :     }
; 3439 : 
; 3440 :     /* Exit if no bytes are to be copied */
; 3441 :     if (count == 0 || dev->is_immed)

  000b6	83 bc 24 38 01
	00 00 00	 cmp	 DWORD PTR count$[rsp], 0
  000be	74 11		 je	 SHORT $LN44@s370_copy_
  000c0	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000c8	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  000cf	74 36		 je	 SHORT $LN43@s370_copy_
$LN44@s370_copy_:
$LN7@s370_copy_:

; 3442 :     {
; 3443 :         set_chanstat(0);

  000d1	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  000d9	83 38 00	 cmp	 DWORD PTR [rax], 0
  000dc	74 13		 je	 SHORT $LN45@s370_copy_
  000de	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  000e2	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  000ea	c6 44 01 10 00	 mov	 BYTE PTR [rcx+rax+16], 0
  000ef	eb 0b		 jmp	 SHORT $LN46@s370_copy_
$LN45@s370_copy_:
  000f1	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  000f9	c6 00 00	 mov	 BYTE PTR [rax], 0
$LN46@s370_copy_:
  000fc	33 c0		 xor	 eax, eax
  000fe	85 c0		 test	 eax, eax
  00100	75 cf		 jne	 SHORT $LN7@s370_copy_

; 3444 :         return;

  00102	e9 6f 10 00 00	 jmp	 $LN1@s370_copy_
$LN43@s370_copy_:

; 3445 :     }
; 3446 : 
; 3447 :     /* Set flags indicating direction of data movement */
; 3448 :     if (IS_CCW_RDBACK(code))

  00107	0f b6 84 24 20
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0010f	83 e0 0f	 and	 eax, 15
  00112	83 f8 0c	 cmp	 eax, 12
  00115	75 15		 jne	 SHORT $LN47@s370_copy_

; 3449 :     {
; 3450 :         readbackwards = to_memory = 1;

  00117	c6 44 24 58 01	 mov	 BYTE PTR to_memory$[rsp], 1
  0011c	0f b6 44 24 58	 movzx	 eax, BYTE PTR to_memory$[rsp]
  00121	88 44 24 59	 mov	 BYTE PTR readbackwards$[rsp], al

; 3451 :         to_iobuf = 0;

  00125	c6 44 24 5b 00	 mov	 BYTE PTR to_iobuf$[rsp], 0

; 3452 :     }

  0012a	eb 38		 jmp	 SHORT $LN48@s370_copy_
$LN47@s370_copy_:

; 3453 :     else
; 3454 :     {
; 3455 :         readbackwards = 0;

  0012c	c6 44 24 59 00	 mov	 BYTE PTR readbackwards$[rsp], 0

; 3456 :         to_iobuf = code & 0x01;

  00131	0f b6 84 24 20
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  00139	83 e0 01	 and	 eax, 1
  0013c	88 44 24 5b	 mov	 BYTE PTR to_iobuf$[rsp], al

; 3457 :         to_memory = !to_iobuf;

  00140	0f b6 44 24 5b	 movzx	 eax, BYTE PTR to_iobuf$[rsp]
  00145	85 c0		 test	 eax, eax
  00147	75 0a		 jne	 SHORT $LN128@s370_copy_
  00149	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR tv128[rsp], 1
  00151	eb 08		 jmp	 SHORT $LN129@s370_copy_
$LN128@s370_copy_:
  00153	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
$LN129@s370_copy_:
  0015b	0f b6 44 24 7c	 movzx	 eax, BYTE PTR tv128[rsp]
  00160	88 44 24 58	 mov	 BYTE PTR to_memory$[rsp], al
$LN48@s370_copy_:

; 3458 :     }
; 3459 : 
; 3460 : 
; 3461 : #if defined(FEATURE_MIDAW_FACILITY)
; 3462 :     /* Move data when modified indirect data addressing is used */
; 3463 :     if (flags & CCW_FLAGS_MIDAW)
; 3464 :     {
; 3465 :         if (prefetch->seq)
; 3466 :             prefetch->datalen[ps] = 0;
; 3467 : 
; 3468 :         midawptr = addr;
; 3469 :         midawrem = count;
; 3470 :         midawflg = 0;
; 3471 : 
; 3472 :         for (midawseq = 0;
; 3473 :              midawrem > 0 &&
; 3474 :                 (midawflg & MIDAW_LAST) == 0 &&
; 3475 :                 chanstat != 0 &&
; 3476 :                 !(prefetch->seq &&
; 3477 :                     (prefetch->chanstat[ps] ||
; 3478 :                         ((ps+1) < prefetch->seq &&
; 3479 :                             prefetch->chanstat[ps+1])));
; 3480 :              midawseq++)
; 3481 :         {
; 3482 :             /* Get new prefetch entry */
; 3483 :             get_new_prefetch_entry(PF_MIDAW, midawptr);
; 3484 :             if (*chanstat != 0)
; 3485 :                 break;
; 3486 : 
; 3487 :             /* Fetch MIDAW and set data address, length, flags */
; 3488 :             ARCH_DEP(fetch_midaw) (dev, code, ccwkey,
; 3489 :                     midawseq, midawptr,
; 3490 :                     &midawdat, &midawlen, &midawflg, chanstat);
; 3491 : 
; 3492 :             /* Exit if fetch_midaw detected channel program check */
; 3493 :             if (prefetch->seq)
; 3494 :             {
; 3495 :                 prefetch->idawflag[ps] = midawflg;
; 3496 :                 prefetch->dataaddr[ps] = midawdat;
; 3497 :                 prefetch->datalen[ps] = midawlen;
; 3498 :                 if (*chanstat != 0)
; 3499 :                 {
; 3500 :                     prefetch->chanstat[ps] = *chanstat;
; 3501 :                     *chanstat = 0;
; 3502 :                     break;
; 3503 :                 }
; 3504 :             }
; 3505 :             else if (*chanstat != 0)
; 3506 :                 break;
; 3507 : 
; 3508 :             /* Channel program check if MIDAW length
; 3509 :                exceeds the remaining CCW count */
; 3510 :             if (midawlen > midawrem)
; 3511 :             {
; 3512 :                 set_chanstat(CSW_PROGC);
; 3513 :                 return;
; 3514 :             }
; 3515 : 
; 3516 :             /* MIDAW length may be zero during prefetch operations */
; 3517 :             if (!prefetch->seq || (prefetch->seq && midawlen))
; 3518 :             {
; 3519 : 
; 3520 :                 /* Perform data movement unless SKIP flag is set in
; 3521 :                    MIDAW */
; 3522 :                 if ((midawflg & MIDAW_SKIP) ==0)
; 3523 :                 {
; 3524 :                     /* Note: MIDAW data area cannot cross a page
; 3525 :                        boundary. The fetch_midaw function enforces this
; 3526 :                        restriction */
; 3527 : 
; 3528 :                     /* Channel protection check if MIDAW data location
; 3529 :                        is fetch protected, or if location is store
; 3530 :                        protected and command is READ, READ BACKWARD, or
; 3531 :                        SENSE */
; 3532 :                     storkey = ARCH_DEP( get_dev_storage_key )( dev, midawdat );
; 3533 :                     if (ccwkey != 0
; 3534 :                         && (storkey & STORKEY_KEY) != ccwkey
; 3535 :                         && ((storkey & STORKEY_FETCH) || to_memory))
; 3536 :                     {
; 3537 :                         set_chanstat(CSW_PROTC);
; 3538 :                         return;
; 3539 :                     }
; 3540 : 
; 3541 :                     /* Ensure memcpy will stay within buffer         */
; 3542 :                     /* Channel data check if outside buffer          */
; 3543 :                     /* SA22-7201-05:                                 */
; 3544 :                     /*  p. 16-27, Channel-Data Check                 */
; 3545 :                     if (readbackwards)
; 3546 :                     {
; 3547 :                         iobufptr = iobuf + dev->curblkrem + midawrem -
; 3548 :                                    midawlen;
; 3549 :                         if (!midawlen                        ||
; 3550 :                             (iobufptr + midawlen) > iobufend ||
; 3551 :                             iobufptr < iobufstart)
; 3552 :                         {
; 3553 :                             *chanstat = CSW_CDC;
; 3554 :                             return;
; 3555 :                         }
; 3556 :                     }
; 3557 :                     else if (!midawlen                     ||
; 3558 :                              (iobuf + midawlen) > iobufend ||
; 3559 :                              iobuf < iobufstart)
; 3560 :                     {
; 3561 :                             set_chanstat(CSW_CDC);
; 3562 :                             return;
; 3563 :                     }
; 3564 : 
; 3565 :                     /* Set the main storage reference and change
; 3566 :                        bits */
; 3567 :                     if (to_memory)
; 3568 :                         ARCH_DEP( or_dev_storage_key )( dev, midawdat, (STORKEY_REF | STORKEY_CHANGE) );
; 3569 :                     else
; 3570 :                         ARCH_DEP( or_dev_storage_key )( dev, midawdat, STORKEY_REF );
; 3571 : 
; 3572 :                     /* Copy data between main storage and channel
; 3573 :                        buffer */
; 3574 :                     if (readbackwards)
; 3575 :                     {
; 3576 :                         midawdat = (midawdat - midawlen) + 1;
; 3577 :                         memcpy_backwards (dev->mainstor + midawdat,
; 3578 :                                           iobufptr,
; 3579 :                                           midawlen);
; 3580 : 
; 3581 :                         /* Decrement buffer pointer */
; 3582 :                         iobuf -= midawlen;
; 3583 :                     }
; 3584 :                     else
; 3585 :                     {
; 3586 :                         if (to_iobuf)
; 3587 :                         {
; 3588 :                             memcpy (iobuf,
; 3589 :                                     dev->mainstor + midawdat,
; 3590 :                                     midawlen);
; 3591 :                             prefetch->pos += midawlen;
; 3592 :                             if (prefetch->seq)
; 3593 :                                 prefetch->datalen[ps] = midawlen;
; 3594 :                         }
; 3595 :                         else
; 3596 :                         {
; 3597 :                             memcpy (dev->mainstor + midawdat,
; 3598 :                                     iobuf,
; 3599 :                                     midawlen);
; 3600 :                         }
; 3601 : 
; 3602 :                         /* Increment buffer pointer */
; 3603 :                         iobuf += midawlen;
; 3604 :                     }
; 3605 : 
; 3606 :                 } /* end if(!MIDAW_FLAG_SKIP) */
; 3607 : 
; 3608 :                 /* Display the MIDAW if CCW tracing is on */
; 3609 :                 if (!prefetch->seq && dev->ccwtrace)
; 3610 :                 {
; 3611 :                     /* Trace the CCW first, then the MIDAW, but only
; 3612 :                        if this is a read type CCW as determined by
; 3613 :                        the direction of the copying. (For write type
; 3614 :                        CCws, channel code properly traces CCWs before
; 3615 :                        we're even called.)
; 3616 :                     */
; 3617 :                     if (to_memory)
; 3618 :                         DISPLAY_CCW( dev, ccw, addr, count, flags );
; 3619 :                     DISPLAY_IDAW( dev, PF_MIDAW, midawflg, midawdat, midawlen );
; 3620 :                 }
; 3621 : #if DEBUG_DUMP
; 3622 :                 if (dev->ccwtrace)
; 3623 :                 {
; 3624 :                     if (to_memory)
; 3625 :                         DUMP("iobuf:", iobuf, midawlen);
; 3626 :                     DUMP_STORAGE("Storage:", midawdat, midawlen);
; 3627 :                     if (to_iobuf)
; 3628 :                         DUMP("iobuf:", iobuf, midawlen);
; 3629 :                 }
; 3630 : #endif
; 3631 :                 /* Decrement remaining count */
; 3632 :                 midawrem -= midawlen;
; 3633 : 
; 3634 :             }
; 3635 : 
; 3636 :             /* Increment to next MIDAW address */
; 3637 :             midawptr += 16;
; 3638 : 
; 3639 :         } /* end for(midawseq) */
; 3640 : 
; 3641 :         /* Channel program check if sum of MIDAW lengths
; 3642 :            did not exhaust the CCW count and no pending status */
; 3643 :         if (1
; 3644 :             && midawrem > 0
; 3645 :             && *chanstat != 0
; 3646 :             && !(prefetch->seq && prefetch->chanstat[ps])
; 3647 :         )
; 3648 :             set_chanstat( CSW_PROGC );
; 3649 : 
; 3650 :     } /* end if(CCW_FLAGS_MIDAW) */
; 3651 :     else
; 3652 : #endif /*defined(FEATURE_MIDAW_FACILITY)*/
; 3653 :     /* Move data when indirect data addressing is used */
; 3654 :     if (flags & CCW_FLAGS_IDA)

  00164	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR flags$[rsp]
  0016c	83 e0 04	 and	 eax, 4
  0016f	85 c0		 test	 eax, eax
  00171	0f 84 20 09 00
	00		 je	 $LN49@s370_copy_

; 3655 :     {
; 3656 :         if (prefetch->seq)

  00177	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  0017f	83 38 00	 cmp	 DWORD PTR [rax], 0
  00182	74 17		 je	 SHORT $LN51@s370_copy_

; 3657 :             prefetch->datalen[ps] = 0;

  00184	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00188	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00190	c7 84 81 10 05
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+1296], 0
$LN51@s370_copy_:

; 3658 : 
; 3659 :         idawaddr = addr;

  0019b	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  001a2	89 44 24 68	 mov	 DWORD PTR idawaddr$[rsp], eax

; 3660 :         idacount = count;

  001a6	0f b7 84 24 38
	01 00 00	 movzx	 eax, WORD PTR count$[rsp]
  001ae	66 89 44 24 5c	 mov	 WORD PTR idacount$[rsp], ax

; 3661 :         idasize = (idawfmt == PF_IDAW1) ? 4 : 8;

  001b3	0f b6 84 24 48
	01 00 00	 movzx	 eax, BYTE PTR idawfmt$[rsp]
  001bb	83 f8 01	 cmp	 eax, 1
  001be	75 0d		 jne	 SHORT $LN130@s370_copy_
  001c0	c7 84 24 80 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv141[rsp], 4
  001cb	eb 0b		 jmp	 SHORT $LN131@s370_copy_
$LN130@s370_copy_:
  001cd	c7 84 24 80 00
	00 00 08 00 00
	00		 mov	 DWORD PTR tv141[rsp], 8
$LN131@s370_copy_:
  001d8	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv141[rsp]
  001df	89 84 24 90 00
	00 00		 mov	 DWORD PTR idasize$[rsp], eax

; 3662 : 
; 3663 :         for (idaseq = 0;

  001e6	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR idaseq$[rsp], 0
  001ee	eb 0a		 jmp	 SHORT $LN10@s370_copy_
$LN8@s370_copy_:

; 3666 :                 !(prefetch->seq &&
; 3667 :                     (prefetch->chanstat[ps] ||
; 3668 :                         ((ps+1) < prefetch->seq &&
; 3669 :                             prefetch->chanstat[ps+1])));
; 3670 :              idaseq++)

  001f0	8b 44 24 78	 mov	 eax, DWORD PTR idaseq$[rsp]
  001f4	ff c0		 inc	 eax
  001f6	89 44 24 78	 mov	 DWORD PTR idaseq$[rsp], eax
$LN10@s370_copy_:

; 3664 :              idacount > 0 &&
; 3665 :                 chanstat != 0 &&

  001fa	0f b7 44 24 5c	 movzx	 eax, WORD PTR idacount$[rsp]
  001ff	85 c0		 test	 eax, eax
  00201	0f 8e 8b 08 00
	00		 jle	 $LN9@s370_copy_
  00207	48 83 bc 24 70
	01 00 00 00	 cmp	 QWORD PTR chanstat$[rsp], 0
  00210	0f 84 7c 08 00
	00		 je	 $LN9@s370_copy_
  00216	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  0021e	83 38 00	 cmp	 DWORD PTR [rax], 0
  00221	74 48		 je	 SHORT $LN52@s370_copy_
  00223	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00227	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  0022f	0f b6 44 01 10	 movzx	 eax, BYTE PTR [rcx+rax+16]
  00234	85 c0		 test	 eax, eax
  00236	0f 85 56 08 00
	00		 jne	 $LN9@s370_copy_
  0023c	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00240	ff c0		 inc	 eax
  00242	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  0024a	3b 01		 cmp	 eax, DWORD PTR [rcx]
  0024c	73 1d		 jae	 SHORT $LN53@s370_copy_
  0024e	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00252	ff c0		 inc	 eax
  00254	8b c0		 mov	 eax, eax
  00256	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  0025e	0f b6 44 01 10	 movzx	 eax, BYTE PTR [rcx+rax+16]
  00263	85 c0		 test	 eax, eax
  00265	0f 85 27 08 00
	00		 jne	 $LN9@s370_copy_
$LN53@s370_copy_:
$LN52@s370_copy_:
$LN13@s370_copy_:

; 3671 :         {
; 3672 :             /* Get new prefetch entry */
; 3673 :             get_new_prefetch_entry( idawfmt, idawaddr );

  0026b	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00273	83 38 00	 cmp	 DWORD PTR [rax], 0
  00276	0f 84 aa 00 00
	00		 je	 $LN54@s370_copy_
  0027c	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00284	8b 00		 mov	 eax, DWORD PTR [rax]
  00286	89 44 24 54	 mov	 DWORD PTR ps$[rsp], eax
  0028a	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00292	8b 00		 mov	 eax, DWORD PTR [rax]
  00294	ff c0		 inc	 eax
  00296	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  0029e	89 01		 mov	 DWORD PTR [rcx], eax
  002a0	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  002a8	81 38 00 01 00
	00		 cmp	 DWORD PTR [rax], 256	; 00000100H
  002ae	76 0d		 jbe	 SHORT $LN55@s370_copy_
  002b0	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  002b8	c6 00 08	 mov	 BYTE PTR [rax], 8
  002bb	eb 7e		 jmp	 SHORT $LN12@s370_copy_
$LN55@s370_copy_:
  002bd	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  002c1	ff c8		 dec	 eax
  002c3	8b c0		 mov	 eax, eax
  002c5	8b 4c 24 54	 mov	 ecx, DWORD PTR ps$[rsp]
  002c9	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR prefetch$[rsp]
  002d1	4c 8b 84 24 80
	01 00 00	 mov	 r8, QWORD PTR prefetch$[rsp]
  002d9	41 8b 84 80 10
	01 00 00	 mov	 eax, DWORD PTR [r8+rax*4+272]
  002e1	89 84 8a 10 01
	00 00		 mov	 DWORD PTR [rdx+rcx*4+272], eax
  002e8	0f b6 84 24 48
	01 00 00	 movzx	 eax, BYTE PTR idawfmt$[rsp]
  002f0	85 c0		 test	 eax, eax
  002f2	74 32		 je	 SHORT $LN56@s370_copy_
  002f4	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  002f8	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00300	0f b6 94 24 48
	01 00 00	 movzx	 edx, BYTE PTR idawfmt$[rsp]
  00308	88 94 01 10 18
	00 00		 mov	 BYTE PTR [rcx+rax+6160], dl
  0030f	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00313	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  0031b	8b 54 24 68	 mov	 edx, DWORD PTR idawaddr$[rsp]
  0031f	89 94 81 10 14
	00 00		 mov	 DWORD PTR [rcx+rax*4+5136], edx
$LN56@s370_copy_:
$LN54@s370_copy_:
  00326	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  0032e	c6 00 00	 mov	 BYTE PTR [rax], 0
  00331	33 c0		 xor	 eax, eax
  00333	85 c0		 test	 eax, eax
  00335	0f 85 30 ff ff
	ff		 jne	 $LN13@s370_copy_
$LN12@s370_copy_:

; 3674 : 
; 3675 :             if (*chanstat != 0)

  0033b	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00343	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00346	85 c0		 test	 eax, eax
  00348	74 05		 je	 SHORT $LN57@s370_copy_

; 3676 :                 break;

  0034a	e9 43 07 00 00	 jmp	 $LN9@s370_copy_
$LN57@s370_copy_:

; 3677 : 
; 3678 :             /* Fetch the IDAW and set IDA pointer and length */
; 3679 :             ARCH_DEP( fetch_idaw )( dev, code, ccwkey, idawfmt,

  0034f	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00357	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0035c	48 8d 44 24 50	 lea	 rax, QWORD PTR idalen$[rsp]
  00361	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00366	48 8d 44 24 70	 lea	 rax, QWORD PTR idadata$[rsp]
  0036b	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00370	8b 44 24 68	 mov	 eax, DWORD PTR idawaddr$[rsp]
  00374	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00378	8b 44 24 78	 mov	 eax, DWORD PTR idaseq$[rsp]
  0037c	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00380	0f b7 84 24 50
	01 00 00	 movzx	 eax, WORD PTR idapmask$[rsp]
  00388	66 89 44 24 20	 mov	 WORD PTR [rsp+32], ax
  0038d	44 0f b6 8c 24
	48 01 00 00	 movzx	 r9d, BYTE PTR idawfmt$[rsp]
  00396	44 0f b6 84 24
	40 01 00 00	 movzx	 r8d, BYTE PTR ccwkey$[rsp]
  0039f	0f b6 94 24 20
	01 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  003a7	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003af	e8 00 00 00 00	 call	 s370_fetch_idaw

; 3680 :                         idapmask, idaseq, idawaddr,
; 3681 :                         &idadata, &idalen, chanstat );
; 3682 : 
; 3683 :             /* Exit if fetch_idaw detected channel program check */
; 3684 :             if (prefetch->seq)

  003b4	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  003bc	83 38 00	 cmp	 DWORD PTR [rax], 0
  003bf	74 6d		 je	 SHORT $LN58@s370_copy_

; 3685 :             {
; 3686 :                 prefetch->dataaddr[ps] = idadata;

  003c1	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  003c5	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  003cd	48 8b 54 24 70	 mov	 rdx, QWORD PTR idadata$[rsp]
  003d2	48 89 94 c1 10
	09 00 00	 mov	 QWORD PTR [rcx+rax*8+2320], rdx

; 3687 :                 prefetch->datalen[ps]  = idalen;

  003da	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  003de	0f b7 4c 24 50	 movzx	 ecx, WORD PTR idalen$[rsp]
  003e3	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR prefetch$[rsp]
  003eb	89 8c 82 10 05
	00 00		 mov	 DWORD PTR [rdx+rax*4+1296], ecx

; 3688 : 
; 3689 :                 if (*chanstat != 0)

  003f2	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  003fa	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003fd	85 c0		 test	 eax, eax
  003ff	74 2b		 je	 SHORT $LN60@s370_copy_

; 3690 :                 {
; 3691 :                     prefetch->chanstat[ps] = *chanstat;

  00401	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00405	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  0040d	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR chanstat$[rsp]
  00415	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  00418	88 54 01 10	 mov	 BYTE PTR [rcx+rax+16], dl

; 3692 :                     *chanstat = 0;

  0041c	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00424	c6 00 00	 mov	 BYTE PTR [rax], 0

; 3693 :                     break;

  00427	e9 66 06 00 00	 jmp	 $LN9@s370_copy_
$LN60@s370_copy_:

; 3694 :                 }
; 3695 :             }

  0042c	eb 14		 jmp	 SHORT $LN59@s370_copy_
$LN58@s370_copy_:

; 3696 :             else if (*chanstat != 0)

  0042e	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00436	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00439	85 c0		 test	 eax, eax
  0043b	74 05		 je	 SHORT $LN61@s370_copy_

; 3697 :                 break;

  0043d	e9 50 06 00 00	 jmp	 $LN9@s370_copy_
$LN61@s370_copy_:
$LN59@s370_copy_:

; 3698 : 
; 3699 :             /* Channel protection check if IDAW data location is
; 3700 :                fetch protected, or if location is store protected
; 3701 :                and command is READ, READ BACKWARD, or SENSE */
; 3702 :             storkey = ARCH_DEP( get_dev_storage_key )( dev, idadata );

  00442	48 8b 54 24 70	 mov	 rdx, QWORD PTR idadata$[rsp]
  00447	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0044f	e8 00 00 00 00	 call	 s370_get_dev_storage_key
  00454	88 44 24 5a	 mov	 BYTE PTR storkey$[rsp], al

; 3703 : 
; 3704 :             if (1
; 3705 :                 && ccwkey != 0
; 3706 :                 && (storkey & STORKEY_KEY) != ccwkey
; 3707 :                 && ((storkey & STORKEY_FETCH) || to_memory)

  00458	33 c0		 xor	 eax, eax
  0045a	83 f8 01	 cmp	 eax, 1
  0045d	74 6d		 je	 SHORT $LN62@s370_copy_
  0045f	0f b6 84 24 40
	01 00 00	 movzx	 eax, BYTE PTR ccwkey$[rsp]
  00467	85 c0		 test	 eax, eax
  00469	74 61		 je	 SHORT $LN62@s370_copy_
  0046b	0f b6 44 24 5a	 movzx	 eax, BYTE PTR storkey$[rsp]
  00470	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00475	0f b6 8c 24 40
	01 00 00	 movzx	 ecx, BYTE PTR ccwkey$[rsp]
  0047d	3b c1		 cmp	 eax, ecx
  0047f	74 4b		 je	 SHORT $LN62@s370_copy_
  00481	0f b6 44 24 5a	 movzx	 eax, BYTE PTR storkey$[rsp]
  00486	83 e0 08	 and	 eax, 8
  00489	85 c0		 test	 eax, eax
  0048b	75 09		 jne	 SHORT $LN63@s370_copy_
  0048d	0f b6 44 24 58	 movzx	 eax, BYTE PTR to_memory$[rsp]
  00492	85 c0		 test	 eax, eax
  00494	74 36		 je	 SHORT $LN62@s370_copy_
$LN63@s370_copy_:
$LN16@s370_copy_:

; 3708 :             )
; 3709 :             {
; 3710 :                 set_chanstat(CSW_PROTC);

  00496	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  0049e	83 38 00	 cmp	 DWORD PTR [rax], 0
  004a1	74 13		 je	 SHORT $LN64@s370_copy_
  004a3	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  004a7	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  004af	c6 44 01 10 10	 mov	 BYTE PTR [rcx+rax+16], 16
  004b4	eb 0b		 jmp	 SHORT $LN65@s370_copy_
$LN64@s370_copy_:
  004b6	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  004be	c6 00 10	 mov	 BYTE PTR [rax], 16
$LN65@s370_copy_:
  004c1	33 c0		 xor	 eax, eax
  004c3	85 c0		 test	 eax, eax
  004c5	75 cf		 jne	 SHORT $LN16@s370_copy_

; 3711 :                 break;

  004c7	e9 c6 05 00 00	 jmp	 $LN9@s370_copy_
$LN62@s370_copy_:

; 3712 :             }
; 3713 : 
; 3714 :             /* Reduce length if less than one page remaining */
; 3715 :             if (idalen > idacount)

  004cc	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  004d1	0f b7 4c 24 5c	 movzx	 ecx, WORD PTR idacount$[rsp]
  004d6	3b c1		 cmp	 eax, ecx
  004d8	7e 2f		 jle	 SHORT $LN66@s370_copy_

; 3716 :             {
; 3717 :                 idalen = idacount;

  004da	0f b7 44 24 5c	 movzx	 eax, WORD PTR idacount$[rsp]
  004df	66 89 44 24 50	 mov	 WORD PTR idalen$[rsp], ax

; 3718 : 
; 3719 :                 if (prefetch->seq)

  004e4	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  004ec	83 38 00	 cmp	 DWORD PTR [rax], 0
  004ef	74 18		 je	 SHORT $LN67@s370_copy_

; 3720 :                    prefetch->datalen[ps] = idacount;

  004f1	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  004f5	0f b7 4c 24 5c	 movzx	 ecx, WORD PTR idacount$[rsp]
  004fa	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR prefetch$[rsp]
  00502	89 8c 82 10 05
	00 00		 mov	 DWORD PTR [rdx+rax*4+1296], ecx
$LN67@s370_copy_:
$LN66@s370_copy_:

; 3721 :             }
; 3722 : 
; 3723 :             /* Ensure memcpy will stay within buffer         */
; 3724 :             /* Channel data check if outside buffer          */
; 3725 :             /* SA22-7201-05:                                 */
; 3726 :             /*  p. 16-27, Channel-Data Check                 */
; 3727 :             if (readbackwards)

  00509	0f b6 44 24 59	 movzx	 eax, BYTE PTR readbackwards$[rsp]
  0050e	85 c0		 test	 eax, eax
  00510	0f 84 c6 00 00
	00		 je	 $LN68@s370_copy_

; 3728 :             {
; 3729 :                 iobufptr = iobuf + dev->curblkrem + idacount - idalen;

  00516	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0051e	8b 80 18 10 00
	00		 mov	 eax, DWORD PTR [rax+4120]
  00524	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0052c	48 03 c8	 add	 rcx, rax
  0052f	48 8b c1	 mov	 rax, rcx
  00532	0f b7 4c 24 5c	 movzx	 ecx, WORD PTR idacount$[rsp]
  00537	48 03 c1	 add	 rax, rcx
  0053a	0f b7 4c 24 50	 movzx	 ecx, WORD PTR idalen$[rsp]
  0053f	48 2b c1	 sub	 rax, rcx
  00542	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR iobufptr$[rsp], rax

; 3730 : 
; 3731 :                 if ((iobufptr + idalen) > (iobufend + 1) ||

  0054a	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  0054f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR iobufptr$[rsp]
  00557	48 03 c8	 add	 rcx, rax
  0055a	48 8b c1	 mov	 rax, rcx
  0055d	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR iobufend$[rsp]
  00565	48 ff c1	 inc	 rcx
  00568	48 3b c1	 cmp	 rax, rcx
  0056b	77 1d		 ja	 SHORT $LN71@s370_copy_
  0056d	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  00572	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR iobufptr$[rsp]
  0057a	48 03 c8	 add	 rcx, rax
  0057d	48 8b c1	 mov	 rax, rcx
  00580	48 3b 84 24 60
	01 00 00	 cmp	 rax, QWORD PTR iobufstart$[rsp]
  00588	77 10		 ja	 SHORT $LN70@s370_copy_
$LN71@s370_copy_:

; 3732 :                     (iobufptr + idalen) <= iobufstart)
; 3733 :                 {
; 3734 :                     *chanstat = CSW_CDC;

  0058a	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00592	c6 00 08	 mov	 BYTE PTR [rax], 8

; 3735 :                     return;

  00595	e9 dc 0b 00 00	 jmp	 $LN1@s370_copy_
$LN70@s370_copy_:

; 3736 :                 }
; 3737 : 
; 3738 :                 if (iobufptr < iobufstart)

  0059a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR iobufstart$[rsp]
  005a2	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR iobufptr$[rsp], rax
  005aa	73 2b		 jae	 SHORT $LN72@s370_copy_

; 3739 :                 {
; 3740 :                     *chanstat = CSW_CDC;

  005ac	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  005b4	c6 00 08	 mov	 BYTE PTR [rax], 8

; 3741 : 
; 3742 :                     /* Reset length to copy to buffer */
; 3743 :                     idalen = iobufptr + idalen - iobufstart;

  005b7	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  005bc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR iobufptr$[rsp]
  005c4	48 03 c8	 add	 rcx, rax
  005c7	48 8b c1	 mov	 rax, rcx
  005ca	48 2b 84 24 60
	01 00 00	 sub	 rax, QWORD PTR iobufstart$[rsp]
  005d2	66 89 44 24 50	 mov	 WORD PTR idalen$[rsp], ax
$LN72@s370_copy_:

; 3744 :                 }
; 3745 :             }

  005d7	e9 45 02 00 00	 jmp	 $LN69@s370_copy_
$LN68@s370_copy_:

; 3746 :             else if (iobuf < iobufstart || iobuf > iobufend)

  005dc	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR iobufstart$[rsp]
  005e4	48 39 84 24 58
	01 00 00	 cmp	 QWORD PTR iobuf$[rsp], rax
  005ec	72 12		 jb	 SHORT $LN75@s370_copy_
  005ee	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR iobufend$[rsp]
  005f6	48 39 84 24 58
	01 00 00	 cmp	 QWORD PTR iobuf$[rsp], rax
  005fe	76 3b		 jbe	 SHORT $LN73@s370_copy_
$LN75@s370_copy_:
$LN19@s370_copy_:

; 3747 :             {
; 3748 :                 set_chanstat( CSW_CDC );

  00600	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00608	83 38 00	 cmp	 DWORD PTR [rax], 0
  0060b	74 13		 je	 SHORT $LN76@s370_copy_
  0060d	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00611	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00619	c6 44 01 10 08	 mov	 BYTE PTR [rcx+rax+16], 8
  0061e	eb 0b		 jmp	 SHORT $LN77@s370_copy_
$LN76@s370_copy_:
  00620	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00628	c6 00 08	 mov	 BYTE PTR [rax], 8
$LN77@s370_copy_:
  0062b	33 c0		 xor	 eax, eax
  0062d	85 c0		 test	 eax, eax
  0062f	75 cf		 jne	 SHORT $LN19@s370_copy_

; 3749 :                 break;

  00631	e9 5c 04 00 00	 jmp	 $LN9@s370_copy_

; 3750 :             }

  00636	e9 e6 01 00 00	 jmp	 $LN74@s370_copy_
$LN73@s370_copy_:

; 3751 :             else if ((iobuf + idalen) > (iobufend + 1))

  0063b	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  00640	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00648	48 03 c8	 add	 rcx, rax
  0064b	48 8b c1	 mov	 rax, rcx
  0064e	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR iobufend$[rsp]
  00656	48 ff c1	 inc	 rcx
  00659	48 3b c1	 cmp	 rax, rcx
  0065c	0f 86 bf 01 00
	00		 jbe	 $LN78@s370_copy_

; 3752 :             {
; 3753 :                 /* Reset length to copy to buffer */
; 3754 :                 idalen = iobufend - iobuf + 1;

  00662	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  0066a	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR iobufend$[rsp]
  00672	48 2b c8	 sub	 rcx, rax
  00675	48 8b c1	 mov	 rax, rcx
  00678	48 ff c0	 inc	 rax
  0067b	66 89 44 24 50	 mov	 WORD PTR idalen$[rsp], ax

; 3755 : 
; 3756 :                 if (prefetch->seq)

  00680	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00688	83 38 00	 cmp	 DWORD PTR [rax], 0
  0068b	0f 84 5f 01 00
	00		 je	 $LN79@s370_copy_

; 3757 :                 {
; 3758 :                     prefetch->datalen[ps] = idalen;

  00691	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00695	0f b7 4c 24 50	 movzx	 ecx, WORD PTR idalen$[rsp]
  0069a	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR prefetch$[rsp]
  006a2	89 8c 82 10 05
	00 00		 mov	 DWORD PTR [rdx+rax*4+1296], ecx
$LN22@s370_copy_:

; 3759 : 
; 3760 :                     /* Get new prefetch entry for channel data
; 3761 :                        check */
; 3762 :                     get_new_prefetch_entry( idawfmt, idawaddr );

  006a9	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  006b1	83 38 00	 cmp	 DWORD PTR [rax], 0
  006b4	0f 84 aa 00 00
	00		 je	 $LN81@s370_copy_
  006ba	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  006c2	8b 00		 mov	 eax, DWORD PTR [rax]
  006c4	89 44 24 54	 mov	 DWORD PTR ps$[rsp], eax
  006c8	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  006d0	8b 00		 mov	 eax, DWORD PTR [rax]
  006d2	ff c0		 inc	 eax
  006d4	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  006dc	89 01		 mov	 DWORD PTR [rcx], eax
  006de	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  006e6	81 38 00 01 00
	00		 cmp	 DWORD PTR [rax], 256	; 00000100H
  006ec	76 0d		 jbe	 SHORT $LN82@s370_copy_
  006ee	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  006f6	c6 00 08	 mov	 BYTE PTR [rax], 8
  006f9	eb 7e		 jmp	 SHORT $LN21@s370_copy_
$LN82@s370_copy_:
  006fb	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  006ff	ff c8		 dec	 eax
  00701	8b c0		 mov	 eax, eax
  00703	8b 4c 24 54	 mov	 ecx, DWORD PTR ps$[rsp]
  00707	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR prefetch$[rsp]
  0070f	4c 8b 84 24 80
	01 00 00	 mov	 r8, QWORD PTR prefetch$[rsp]
  00717	41 8b 84 80 10
	01 00 00	 mov	 eax, DWORD PTR [r8+rax*4+272]
  0071f	89 84 8a 10 01
	00 00		 mov	 DWORD PTR [rdx+rcx*4+272], eax
  00726	0f b6 84 24 48
	01 00 00	 movzx	 eax, BYTE PTR idawfmt$[rsp]
  0072e	85 c0		 test	 eax, eax
  00730	74 32		 je	 SHORT $LN83@s370_copy_
  00732	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00736	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  0073e	0f b6 94 24 48
	01 00 00	 movzx	 edx, BYTE PTR idawfmt$[rsp]
  00746	88 94 01 10 18
	00 00		 mov	 BYTE PTR [rcx+rax+6160], dl
  0074d	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00751	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00759	8b 54 24 68	 mov	 edx, DWORD PTR idawaddr$[rsp]
  0075d	89 94 81 10 14
	00 00		 mov	 DWORD PTR [rcx+rax*4+5136], edx
$LN83@s370_copy_:
$LN81@s370_copy_:
  00764	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  0076c	c6 00 00	 mov	 BYTE PTR [rax], 0
  0076f	33 c0		 xor	 eax, eax
  00771	85 c0		 test	 eax, eax
  00773	0f 85 30 ff ff
	ff		 jne	 $LN22@s370_copy_
$LN21@s370_copy_:

; 3763 : 
; 3764 :                     if (*chanstat != 0)

  00779	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00781	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00784	85 c0		 test	 eax, eax
  00786	74 05		 je	 SHORT $LN84@s370_copy_

; 3765 :                         break;

  00788	e9 05 03 00 00	 jmp	 $LN9@s370_copy_
$LN84@s370_copy_:

; 3766 : 
; 3767 :                     prefetch->dataaddr[ps] = idadata + idalen;

  0078d	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  00792	48 8b 4c 24 70	 mov	 rcx, QWORD PTR idadata$[rsp]
  00797	48 03 c8	 add	 rcx, rax
  0079a	48 8b c1	 mov	 rax, rcx
  0079d	8b 4c 24 54	 mov	 ecx, DWORD PTR ps$[rsp]
  007a1	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR prefetch$[rsp]
  007a9	48 89 84 ca 10
	09 00 00	 mov	 QWORD PTR [rdx+rcx*8+2320], rax

; 3768 :                     prefetch->datalen[ps]  = 1;

  007b1	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  007b5	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  007bd	c7 84 81 10 05
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+1296], 1

; 3769 :                     prefetch->chanstat[ps] = *chanstat = CSW_CDC;

  007c8	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  007d0	c6 00 08	 mov	 BYTE PTR [rax], 8
  007d3	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  007d7	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  007df	c6 44 01 10 08	 mov	 BYTE PTR [rcx+rax+16], 8

; 3770 : 
; 3771 :                     ps -= 1;

  007e4	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  007e8	ff c8		 dec	 eax
  007ea	89 44 24 54	 mov	 DWORD PTR ps$[rsp], eax

; 3772 :                 }

  007ee	eb 31		 jmp	 SHORT $LN80@s370_copy_
$LN79@s370_copy_:
$LN25@s370_copy_:

; 3773 : 
; 3774 :                 /* Set channel data check and permit copy to/from
; 3775 :                    end-of-buffer */
; 3776 :                 else
; 3777 :                     set_chanstat( CSW_CDC );

  007f0	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  007f8	83 38 00	 cmp	 DWORD PTR [rax], 0
  007fb	74 13		 je	 SHORT $LN85@s370_copy_
  007fd	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00801	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00809	c6 44 01 10 08	 mov	 BYTE PTR [rcx+rax+16], 8
  0080e	eb 0b		 jmp	 SHORT $LN86@s370_copy_
$LN85@s370_copy_:
  00810	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00818	c6 00 08	 mov	 BYTE PTR [rax], 8
$LN86@s370_copy_:
  0081b	33 c0		 xor	 eax, eax
  0081d	85 c0		 test	 eax, eax
  0081f	75 cf		 jne	 SHORT $LN25@s370_copy_
$LN80@s370_copy_:
$LN78@s370_copy_:
$LN74@s370_copy_:
$LN69@s370_copy_:

; 3778 :             }
; 3779 : 
; 3780 :             /* Copy to I/O buffer */
; 3781 :             if (idalen)

  00821	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  00826	85 c0		 test	 eax, eax
  00828	0f 84 6b 01 00
	00		 je	 $LN87@s370_copy_

; 3782 :             {
; 3783 :                 /* Set the main storage reference and change bits */
; 3784 :                 if (to_memory)

  0082e	0f b6 44 24 58	 movzx	 eax, BYTE PTR to_memory$[rsp]
  00833	85 c0		 test	 eax, eax
  00835	74 17		 je	 SHORT $LN88@s370_copy_

; 3785 :                     ARCH_DEP( or_dev_storage_key )( dev, idadata, (STORKEY_REF | STORKEY_CHANGE) );

  00837	41 b0 06	 mov	 r8b, 6
  0083a	48 8b 54 24 70	 mov	 rdx, QWORD PTR idadata$[rsp]
  0083f	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00847	e8 00 00 00 00	 call	 s370_or_dev_storage_key
  0084c	eb 15		 jmp	 SHORT $LN89@s370_copy_
$LN88@s370_copy_:

; 3786 :                 else
; 3787 :                     ARCH_DEP( or_dev_storage_key )( dev, idadata, STORKEY_REF );

  0084e	41 b0 04	 mov	 r8b, 4
  00851	48 8b 54 24 70	 mov	 rdx, QWORD PTR idadata$[rsp]
  00856	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0085e	e8 00 00 00 00	 call	 s370_or_dev_storage_key
$LN89@s370_copy_:

; 3788 : 
; 3789 :                 /* Copy data between main storage and channel buffer */
; 3790 :                 if (readbackwards)

  00863	0f b6 44 24 59	 movzx	 eax, BYTE PTR readbackwards$[rsp]
  00868	85 c0		 test	 eax, eax
  0086a	0f 84 98 00 00
	00		 je	 $LN90@s370_copy_

; 3791 :                 {
; 3792 :                     idadata = (idadata - idalen) + 1;

  00870	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  00875	48 8b 4c 24 70	 mov	 rcx, QWORD PTR idadata$[rsp]
  0087a	48 2b c8	 sub	 rcx, rax
  0087d	48 8b c1	 mov	 rax, rcx
  00880	48 ff c0	 inc	 rax
  00883	48 89 44 24 70	 mov	 QWORD PTR idadata$[rsp], rax

; 3793 :                     memcpy_backwards( dev->mainstor + idadata,

  00888	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  0088d	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00895	8b 89 18 10 00
	00		 mov	 ecx, DWORD PTR [rcx+4120]
  0089b	48 8b 94 24 58
	01 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  008a3	48 03 d1	 add	 rdx, rcx
  008a6	48 8b ca	 mov	 rcx, rdx
  008a9	0f b7 54 24 5c	 movzx	 edx, WORD PTR idacount$[rsp]
  008ae	48 03 ca	 add	 rcx, rdx
  008b1	0f b7 54 24 50	 movzx	 edx, WORD PTR idalen$[rsp]
  008b6	48 2b ca	 sub	 rcx, rdx
  008b9	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  008c1	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  008c8	48 03 54 24 70	 add	 rdx, QWORD PTR idadata$[rsp]
  008cd	48 89 94 24 e0
	00 00 00	 mov	 QWORD PTR tv377[rsp], rdx
  008d5	44 8b c0	 mov	 r8d, eax
  008d8	48 8b d1	 mov	 rdx, rcx
  008db	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv377[rsp]
  008e3	48 8b c8	 mov	 rcx, rax
  008e6	e8 00 00 00 00	 call	 memcpy_backwards

; 3794 :                                       iobuf + dev->curblkrem + idacount - idalen,
; 3795 :                                       idalen );
; 3796 : 
; 3797 :                     /* Decrement buffer pointer for next IDAW*/
; 3798 :                     iobuf -= idalen;

  008eb	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  008f0	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  008f8	48 2b c8	 sub	 rcx, rax
  008fb	48 8b c1	 mov	 rax, rcx
  008fe	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR iobuf$[rsp], rax

; 3799 :                 }

  00906	eb 76		 jmp	 SHORT $LN91@s370_copy_
$LN90@s370_copy_:

; 3800 :                 else
; 3801 :                 {
; 3802 :                     if (to_iobuf)

  00908	0f b6 44 24 5b	 movzx	 eax, BYTE PTR to_iobuf$[rsp]
  0090d	85 c0		 test	 eax, eax
  0090f	74 2a		 je	 SHORT $LN92@s370_copy_

; 3803 :                     {
; 3804 :                         memcpy( iobuf, dev->mainstor + idadata, idalen );

  00911	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  00916	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0091e	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00925	48 03 4c 24 70	 add	 rcx, QWORD PTR idadata$[rsp]
  0092a	48 8b bc 24 58
	01 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  00932	48 8b f1	 mov	 rsi, rcx
  00935	8b c8		 mov	 ecx, eax
  00937	f3 a4		 rep movsb

; 3805 :                     }

  00939	eb 28		 jmp	 SHORT $LN93@s370_copy_
$LN92@s370_copy_:

; 3806 :                     else
; 3807 :                     {
; 3808 :                         memcpy( dev->mainstor + idadata, iobuf, idalen );

  0093b	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  00940	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00948	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  0094f	48 03 4c 24 70	 add	 rcx, QWORD PTR idadata$[rsp]
  00954	48 8b f9	 mov	 rdi, rcx
  00957	48 8b b4 24 58
	01 00 00	 mov	 rsi, QWORD PTR iobuf$[rsp]
  0095f	8b c8		 mov	 ecx, eax
  00961	f3 a4		 rep movsb
$LN93@s370_copy_:

; 3809 :                     }
; 3810 : 
; 3811 :                     /* Increment buffer pointer for next IDAW*/
; 3812 :                     iobuf += idalen;

  00963	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  00968	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00970	48 03 c8	 add	 rcx, rax
  00973	48 8b c1	 mov	 rax, rcx
  00976	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR iobuf$[rsp], rax
$LN91@s370_copy_:

; 3813 :                 }
; 3814 : 
; 3815 :                 /* Update prefetch completed bytes */
; 3816 :                 prefetch->pos += idalen;

  0097e	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  00983	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  0098b	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  0098e	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00996	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN87@s370_copy_:

; 3817 :             }
; 3818 : 
; 3819 :             /* If not prefetch, display the IDAW if CCW tracing */
; 3820 :             if (!prefetch->seq && dev->ccwtrace)

  00999	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  009a1	83 38 00	 cmp	 DWORD PTR [rax], 0
  009a4	0f 85 bd 00 00
	00		 jne	 $LN94@s370_copy_
  009aa	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  009b2	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  009b8	c1 e8 0f	 shr	 eax, 15
  009bb	83 e0 01	 and	 eax, 1
  009be	85 c0		 test	 eax, eax
  009c0	0f 84 a1 00 00
	00		 je	 $LN94@s370_copy_

; 3821 :             {
; 3822 :                 /* Trace the CCW first, then the IDAW, but only
; 3823 :                    if this is a read type CCW as determined by
; 3824 :                    the direction of the copying. (For write type
; 3825 :                    CCws, channel code properly traces CCWs before
; 3826 :                    we're even called.)
; 3827 :                 */
; 3828 :                 if (to_memory)

  009c6	0f b6 44 24 58	 movzx	 eax, BYTE PTR to_memory$[rsp]
  009cb	85 c0		 test	 eax, eax
  009cd	74 51		 je	 SHORT $LN95@s370_copy_

; 3829 :                     DISPLAY_CCW( dev, ccw, addr, count, flags );

  009cf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171285
  009d6	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  009db	c7 44 24 30 f5
	0e 00 00	 mov	 DWORD PTR [rsp+48], 3829 ; 00000ef5H
  009e3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171286
  009ea	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  009ef	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR flags$[rsp]
  009f7	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  009fb	44 8b 8c 24 38
	01 00 00	 mov	 r9d, DWORD PTR count$[rsp]
  00a03	44 8b 84 24 30
	01 00 00	 mov	 r8d, DWORD PTR addr$[rsp]
  00a0b	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR ccw$[rsp]
  00a13	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a1b	e8 00 00 00 00	 call	 _display_ccw
$LN95@s370_copy_:

; 3830 :                 DISPLAY_IDAW( dev, idawfmt, 0, idadata, idalen );

  00a20	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171287
  00a27	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00a2c	c7 44 24 30 f6
	0e 00 00	 mov	 DWORD PTR [rsp+48], 3830 ; 00000ef6H
  00a34	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171288
  00a3b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00a40	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  00a45	66 89 44 24 20	 mov	 WORD PTR [rsp+32], ax
  00a4a	4c 8b 4c 24 70	 mov	 r9, QWORD PTR idadata$[rsp]
  00a4f	45 33 c0	 xor	 r8d, r8d
  00a52	0f b6 94 24 48
	01 00 00	 movzx	 edx, BYTE PTR idawfmt$[rsp]
  00a5a	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a62	e8 00 00 00 00	 call	 _display_idaw
$LN94@s370_copy_:

; 3831 :             }
; 3832 : 
; 3833 : #if DEBUG_DUMP
; 3834 :             if (dev->ccwtrace)
; 3835 :             {
; 3836 :                 if (to_memory)
; 3837 :                     DUMP( "iobuf:", iobuf-idalen, idalen );
; 3838 :                 DUMP_STORAGE( "Storage:", idadata, idalen );
; 3839 :                 if (to_iobuf)
; 3840 :                     DUMP( "iobuf:", iobuf-idalen, idalen );
; 3841 :             }
; 3842 : #endif
; 3843 :             /* Decrement remaining count, increment buffer pointer */
; 3844 :             idacount -= idalen;

  00a67	0f b7 44 24 50	 movzx	 eax, WORD PTR idalen$[rsp]
  00a6c	0f b7 4c 24 5c	 movzx	 ecx, WORD PTR idacount$[rsp]
  00a71	2b c8		 sub	 ecx, eax
  00a73	8b c1		 mov	 eax, ecx
  00a75	66 89 44 24 5c	 mov	 WORD PTR idacount$[rsp], ax

; 3845 : 
; 3846 :             /* Increment to next IDAW address */
; 3847 :             idawaddr += idasize;

  00a7a	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idasize$[rsp]
  00a81	8b 4c 24 68	 mov	 ecx, DWORD PTR idawaddr$[rsp]
  00a85	03 c8		 add	 ecx, eax
  00a87	8b c1		 mov	 eax, ecx
  00a89	89 44 24 68	 mov	 DWORD PTR idawaddr$[rsp], eax

; 3848 : 
; 3849 :         } /* end for(idaseq) */

  00a8d	e9 5e f7 ff ff	 jmp	 $LN8@s370_copy_
$LN9@s370_copy_:

; 3850 :     }

  00a92	e9 df 06 00 00	 jmp	 $LN50@s370_copy_
$LN49@s370_copy_:

; 3851 :     else                              /* Non-IDA data addressing */
; 3852 :     {
; 3853 :         /* Point to start of data for read backward command */
; 3854 :         if (readbackwards)

  00a97	0f b6 44 24 59	 movzx	 eax, BYTE PTR readbackwards$[rsp]
  00a9c	85 c0		 test	 eax, eax
  00a9e	74 1b		 je	 SHORT $LN96@s370_copy_

; 3855 :             addr = addr - (count - 1);

  00aa0	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00aa7	ff c8		 dec	 eax
  00aa9	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00ab0	2b c8		 sub	 ecx, eax
  00ab2	8b c1		 mov	 eax, ecx
  00ab4	89 84 24 30 01
	00 00		 mov	 DWORD PTR addr$[rsp], eax
$LN96@s370_copy_:

; 3856 : 
; 3857 :         /* Channel protection check if any data is fetch protected,
; 3858 :            or if location is store protected and command is READ,
; 3859 :            READ BACKWARD, or SENSE.
; 3860 :         */
; 3861 :         startpage = addr;

  00abb	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00ac2	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR startpage$[rsp], rax

; 3862 :         endpage = addr + (count - 1);

  00aca	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00ad1	8b 8c 24 38 01
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  00ad8	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00adc	8b c0		 mov	 eax, eax
  00ade	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR endpage$[rsp], rax

; 3863 : 
; 3864 :         for (page = startpage & STORAGE_KEY_PAGEMASK;

  00ae6	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR startpage$[rsp]
  00aee	48 25 00 f8 ff
	7f		 and	 rax, 2147481600		; 7ffff800H
  00af4	48 89 44 24 60	 mov	 QWORD PTR page$[rsp], rax
  00af9	eb 10		 jmp	 SHORT $LN28@s370_copy_
$LN26@s370_copy_:

; 3866 :              page += STORAGE_KEY_PAGESIZE)

  00afb	48 8b 44 24 60	 mov	 rax, QWORD PTR page$[rsp]
  00b00	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  00b06	48 89 44 24 60	 mov	 QWORD PTR page$[rsp], rax
$LN28@s370_copy_:

; 3865 :              page <= (endpage | STORAGE_KEY_BYTEMASK);

  00b0b	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR endpage$[rsp]
  00b13	48 0d ff 07 00
	00		 or	 rax, 2047		; 000007ffH
  00b19	48 39 44 24 60	 cmp	 QWORD PTR page$[rsp], rax
  00b1e	0f 87 18 03 00
	00		 ja	 $LN27@s370_copy_

; 3867 :         {
; 3868 :             /* Channel program check if data is outside main storage */
; 3869 :             if (CHADDRCHK( page, dev ))

  00b24	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b2c	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00b33	48 39 44 24 60	 cmp	 QWORD PTR page$[rsp], rax
  00b38	76 41		 jbe	 SHORT $LN97@s370_copy_

; 3870 :             {
; 3871 :                 if (prefetch->seq)

  00b3a	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00b42	83 38 00	 cmp	 DWORD PTR [rax], 0
  00b45	74 16		 je	 SHORT $LN98@s370_copy_

; 3872 :                 {
; 3873 :                     prefetch->chanstat[ps] = CSW_PROGC;

  00b47	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00b4b	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00b53	c6 44 01 10 20	 mov	 BYTE PTR [rcx+rax+16], 32 ; 00000020H

; 3874 :                     break;

  00b58	e9 df 02 00 00	 jmp	 $LN27@s370_copy_
$LN98@s370_copy_:

; 3875 :                 }
; 3876 : 
; 3877 :                 *chanstat = CSW_PROGC;

  00b5d	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00b65	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3878 : 
; 3879 :                 if (readbackwards)

  00b68	0f b6 44 24 59	 movzx	 eax, BYTE PTR readbackwards$[rsp]
  00b6d	85 c0		 test	 eax, eax
  00b6f	74 05		 je	 SHORT $LN99@s370_copy_

; 3880 :                     return;

  00b71	e9 00 06 00 00	 jmp	 $LN1@s370_copy_
$LN99@s370_copy_:

; 3881 : 
; 3882 :                 break;

  00b76	e9 c1 02 00 00	 jmp	 $LN27@s370_copy_
$LN97@s370_copy_:

; 3883 :             }
; 3884 : 
; 3885 :             storkey = ARCH_DEP( get_dev_storage_key )( dev, page );

  00b7b	48 8b 54 24 60	 mov	 rdx, QWORD PTR page$[rsp]
  00b80	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00b88	e8 00 00 00 00	 call	 s370_get_dev_storage_key
  00b8d	88 44 24 5a	 mov	 BYTE PTR storkey$[rsp], al

; 3886 : 
; 3887 :             if (1
; 3888 :                 && ccwkey != 0
; 3889 :                 && (storkey & STORKEY_KEY) != ccwkey
; 3890 :                 && ((storkey & STORKEY_FETCH) || to_memory)

  00b91	33 c0		 xor	 eax, eax
  00b93	83 f8 01	 cmp	 eax, 1
  00b96	0f 84 9b 02 00
	00		 je	 $LN100@s370_copy_
  00b9c	0f b6 84 24 40
	01 00 00	 movzx	 eax, BYTE PTR ccwkey$[rsp]
  00ba4	85 c0		 test	 eax, eax
  00ba6	0f 84 8b 02 00
	00		 je	 $LN100@s370_copy_
  00bac	0f b6 44 24 5a	 movzx	 eax, BYTE PTR storkey$[rsp]
  00bb1	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00bb6	0f b6 8c 24 40
	01 00 00	 movzx	 ecx, BYTE PTR ccwkey$[rsp]
  00bbe	3b c1		 cmp	 eax, ecx
  00bc0	0f 84 71 02 00
	00		 je	 $LN100@s370_copy_
  00bc6	0f b6 44 24 5a	 movzx	 eax, BYTE PTR storkey$[rsp]
  00bcb	83 e0 08	 and	 eax, 8
  00bce	85 c0		 test	 eax, eax
  00bd0	75 0d		 jne	 SHORT $LN101@s370_copy_
  00bd2	0f b6 44 24 58	 movzx	 eax, BYTE PTR to_memory$[rsp]
  00bd7	85 c0		 test	 eax, eax
  00bd9	0f 84 58 02 00
	00		 je	 $LN100@s370_copy_
$LN101@s370_copy_:

; 3891 :             )
; 3892 :             {
; 3893 :                 if (readbackwards)

  00bdf	0f b6 44 24 59	 movzx	 eax, BYTE PTR readbackwards$[rsp]
  00be4	85 c0		 test	 eax, eax
  00be6	74 5b		 je	 SHORT $LN102@s370_copy_

; 3894 :                 {
; 3895 :                     *residual = MAX( page, addr ) - addr;

  00be8	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00bef	48 39 44 24 60	 cmp	 QWORD PTR page$[rsp], rax
  00bf4	76 0f		 jbe	 SHORT $LN132@s370_copy_
  00bf6	48 8b 44 24 60	 mov	 rax, QWORD PTR page$[rsp]
  00bfb	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv476[rsp], rax
  00c03	eb 0f		 jmp	 SHORT $LN133@s370_copy_
$LN132@s370_copy_:
  00c05	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00c0c	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv476[rsp], rax
$LN133@s370_copy_:
  00c14	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00c1b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv476[rsp]
  00c23	48 2b c8	 sub	 rcx, rax
  00c26	48 8b c1	 mov	 rax, rcx
  00c29	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00c31	89 01		 mov	 DWORD PTR [rcx], eax

; 3896 :                     *chanstat = CSW_PROTC;

  00c33	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00c3b	c6 00 10	 mov	 BYTE PTR [rax], 16

; 3897 :                     break;

  00c3e	e9 f9 01 00 00	 jmp	 $LN27@s370_copy_
$LN102@s370_copy_:

; 3898 :                 }
; 3899 : 
; 3900 :                 /* Calculate residual */
; 3901 :                 *residual = count - (MAX( page, addr ) - addr);

  00c43	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00c4a	48 39 44 24 60	 cmp	 QWORD PTR page$[rsp], rax
  00c4f	76 0f		 jbe	 SHORT $LN134@s370_copy_
  00c51	48 8b 44 24 60	 mov	 rax, QWORD PTR page$[rsp]
  00c56	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv484[rsp], rax
  00c5e	eb 0f		 jmp	 SHORT $LN135@s370_copy_
$LN134@s370_copy_:
  00c60	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00c67	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv484[rsp], rax
$LN135@s370_copy_:
  00c6f	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00c76	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00c7d	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR tv484[rsp]
  00c85	48 2b d1	 sub	 rdx, rcx
  00c88	48 8b ca	 mov	 rcx, rdx
  00c8b	48 2b c1	 sub	 rax, rcx
  00c8e	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00c96	89 01		 mov	 DWORD PTR [rcx], eax

; 3902 : 
; 3903 :                 /* Handle prefetch */
; 3904 :                 if (prefetch->seq)

  00c98	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00ca0	83 38 00	 cmp	 DWORD PTR [rax], 0
  00ca3	0f 84 81 01 00
	00		 je	 $LN103@s370_copy_

; 3905 :                 {
; 3906 :                     prefetch->datalen[ps] = MAX( page, addr ) - addr;

  00ca9	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00cb0	48 39 44 24 60	 cmp	 QWORD PTR page$[rsp], rax
  00cb5	76 0f		 jbe	 SHORT $LN136@s370_copy_
  00cb7	48 8b 44 24 60	 mov	 rax, QWORD PTR page$[rsp]
  00cbc	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv498[rsp], rax
  00cc4	eb 0f		 jmp	 SHORT $LN137@s370_copy_
$LN136@s370_copy_:
  00cc6	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00ccd	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv498[rsp], rax
$LN137@s370_copy_:
  00cd5	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00cdc	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv498[rsp]
  00ce4	48 2b c8	 sub	 rcx, rax
  00ce7	48 8b c1	 mov	 rax, rcx
  00cea	8b 4c 24 54	 mov	 ecx, DWORD PTR ps$[rsp]
  00cee	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR prefetch$[rsp]
  00cf6	89 84 8a 10 05
	00 00		 mov	 DWORD PTR [rdx+rcx*4+1296], eax

; 3907 : 
; 3908 :                     if (*residual)

  00cfd	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  00d05	83 38 00	 cmp	 DWORD PTR [rax], 0
  00d08	0f 84 09 01 00
	00		 je	 $LN104@s370_copy_
$LN31@s370_copy_:

; 3909 :                     {
; 3910 :                         /* Split entry */
; 3911 :                         get_new_prefetch_entry( PF_NO_IDAW, page );

  00d0e	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00d16	83 38 00	 cmp	 DWORD PTR [rax], 0
  00d19	0f 84 9c 00 00
	00		 je	 $LN105@s370_copy_
  00d1f	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00d27	8b 00		 mov	 eax, DWORD PTR [rax]
  00d29	89 44 24 54	 mov	 DWORD PTR ps$[rsp], eax
  00d2d	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00d35	8b 00		 mov	 eax, DWORD PTR [rax]
  00d37	ff c0		 inc	 eax
  00d39	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00d41	89 01		 mov	 DWORD PTR [rcx], eax
  00d43	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  00d4b	81 38 00 01 00
	00		 cmp	 DWORD PTR [rax], 256	; 00000100H
  00d51	76 0d		 jbe	 SHORT $LN106@s370_copy_
  00d53	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00d5b	c6 00 08	 mov	 BYTE PTR [rax], 8
  00d5e	eb 70		 jmp	 SHORT $LN30@s370_copy_
$LN106@s370_copy_:
  00d60	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00d64	ff c8		 dec	 eax
  00d66	8b c0		 mov	 eax, eax
  00d68	8b 4c 24 54	 mov	 ecx, DWORD PTR ps$[rsp]
  00d6c	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR prefetch$[rsp]
  00d74	48 8b bc 24 80
	01 00 00	 mov	 rdi, QWORD PTR prefetch$[rsp]
  00d7c	8b 84 87 10 01
	00 00		 mov	 eax, DWORD PTR [rdi+rax*4+272]
  00d83	89 84 8a 10 01
	00 00		 mov	 DWORD PTR [rdx+rcx*4+272], eax
  00d8a	33 c0		 xor	 eax, eax
  00d8c	85 c0		 test	 eax, eax
  00d8e	74 2b		 je	 SHORT $LN107@s370_copy_
  00d90	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00d94	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00d9c	c6 84 01 10 18
	00 00 00	 mov	 BYTE PTR [rcx+rax+6160], 0
  00da4	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00da8	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00db0	8b 54 24 60	 mov	 edx, DWORD PTR page$[rsp]
  00db4	89 94 81 10 14
	00 00		 mov	 DWORD PTR [rcx+rax*4+5136], edx
$LN107@s370_copy_:
$LN105@s370_copy_:
  00dbb	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00dc3	c6 00 00	 mov	 BYTE PTR [rax], 0
  00dc6	33 c0		 xor	 eax, eax
  00dc8	85 c0		 test	 eax, eax
  00dca	0f 85 3e ff ff
	ff		 jne	 $LN31@s370_copy_
$LN30@s370_copy_:

; 3912 : 
; 3913 :                         if (*chanstat != 0)

  00dd0	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00dd8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00ddb	85 c0		 test	 eax, eax
  00ddd	74 02		 je	 SHORT $LN108@s370_copy_

; 3914 :                             break;

  00ddf	eb 5b		 jmp	 SHORT $LN27@s370_copy_
$LN108@s370_copy_:

; 3915 : 
; 3916 :                         prefetch->dataaddr[ps] = page;

  00de1	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00de5	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00ded	48 8b 54 24 60	 mov	 rdx, QWORD PTR page$[rsp]
  00df2	48 89 94 c1 10
	09 00 00	 mov	 QWORD PTR [rcx+rax*8+2320], rdx

; 3917 :                         prefetch->datalen[ps] = *residual;

  00dfa	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00dfe	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00e06	48 8b 94 24 78
	01 00 00	 mov	 rdx, QWORD PTR residual$[rsp]
  00e0e	8b 12		 mov	 edx, DWORD PTR [rdx]
  00e10	89 94 81 10 05
	00 00		 mov	 DWORD PTR [rcx+rax*4+1296], edx
$LN104@s370_copy_:

; 3918 :                     }
; 3919 : 
; 3920 :                     prefetch->chanstat[ps] = CSW_PROTC;

  00e17	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  00e1b	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  00e23	c6 44 01 10 10	 mov	 BYTE PTR [rcx+rax+16], 16

; 3921 :                     break;

  00e28	eb 12		 jmp	 SHORT $LN27@s370_copy_
$LN103@s370_copy_:

; 3922 :                 }
; 3923 : 
; 3924 :                 *chanstat = CSW_PROTC;

  00e2a	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00e32	c6 00 10	 mov	 BYTE PTR [rax], 16

; 3925 :                 break;

  00e35	eb 05		 jmp	 SHORT $LN27@s370_copy_
$LN100@s370_copy_:

; 3926 :             }
; 3927 : 
; 3928 :         } /* end for(page) */

  00e37	e9 bf fc ff ff	 jmp	 $LN26@s370_copy_
$LN27@s370_copy_:

; 3929 : 
; 3930 :         /* Adjust local count for copy to main storage */
; 3931 :         count = MIN( count, MAX( page, addr ) - addr );

  00e3c	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00e43	48 39 44 24 60	 cmp	 QWORD PTR page$[rsp], rax
  00e48	76 0f		 jbe	 SHORT $LN138@s370_copy_
  00e4a	48 8b 44 24 60	 mov	 rax, QWORD PTR page$[rsp]
  00e4f	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv580[rsp], rax
  00e57	eb 0f		 jmp	 SHORT $LN139@s370_copy_
$LN138@s370_copy_:
  00e59	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00e60	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv580[rsp], rax
$LN139@s370_copy_:
  00e68	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00e6f	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00e76	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR tv580[rsp]
  00e7e	48 2b d1	 sub	 rdx, rcx
  00e81	48 8b ca	 mov	 rcx, rdx
  00e84	48 3b c1	 cmp	 rax, rcx
  00e87	73 11		 jae	 SHORT $LN142@s370_copy_
  00e89	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00e90	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv591[rsp], rax
  00e98	eb 49		 jmp	 SHORT $LN143@s370_copy_
$LN142@s370_copy_:
  00e9a	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00ea1	48 39 44 24 60	 cmp	 QWORD PTR page$[rsp], rax
  00ea6	76 0f		 jbe	 SHORT $LN140@s370_copy_
  00ea8	48 8b 44 24 60	 mov	 rax, QWORD PTR page$[rsp]
  00ead	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv588[rsp], rax
  00eb5	eb 0f		 jmp	 SHORT $LN141@s370_copy_
$LN140@s370_copy_:
  00eb7	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00ebe	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv588[rsp], rax
$LN141@s370_copy_:
  00ec6	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00ecd	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv588[rsp]
  00ed5	48 2b c8	 sub	 rcx, rax
  00ed8	48 8b c1	 mov	 rax, rcx
  00edb	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv591[rsp], rax
$LN143@s370_copy_:
  00ee3	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR tv591[rsp]
  00eea	89 84 24 38 01
	00 00		 mov	 DWORD PTR count$[rsp], eax

; 3932 : 
; 3933 :         /* Count may be zero during prefetch operations */
; 3934 :         if (count)

  00ef1	83 bc 24 38 01
	00 00 00	 cmp	 DWORD PTR count$[rsp], 0
  00ef9	0f 84 77 02 00
	00		 je	 $LN109@s370_copy_

; 3935 :         {
; 3936 :             /* Set the main storage reference and change bits */
; 3937 :             for (page = startpage & STORAGE_KEY_PAGEMASK;

  00eff	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR startpage$[rsp]
  00f07	48 25 00 f8 ff
	7f		 and	 rax, 2147481600		; 7ffff800H
  00f0d	48 89 44 24 60	 mov	 QWORD PTR page$[rsp], rax
  00f12	eb 10		 jmp	 SHORT $LN34@s370_copy_
$LN32@s370_copy_:

; 3939 :                  page += STORAGE_KEY_PAGESIZE)

  00f14	48 8b 44 24 60	 mov	 rax, QWORD PTR page$[rsp]
  00f19	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  00f1f	48 89 44 24 60	 mov	 QWORD PTR page$[rsp], rax
$LN34@s370_copy_:

; 3938 :                  page <= (endpage | STORAGE_KEY_BYTEMASK);

  00f24	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR endpage$[rsp]
  00f2c	48 0d ff 07 00
	00		 or	 rax, 2047		; 000007ffH
  00f32	48 39 44 24 60	 cmp	 QWORD PTR page$[rsp], rax
  00f37	77 37		 ja	 SHORT $LN33@s370_copy_

; 3940 :             {
; 3941 :                 if (to_memory)

  00f39	0f b6 44 24 58	 movzx	 eax, BYTE PTR to_memory$[rsp]
  00f3e	85 c0		 test	 eax, eax
  00f40	74 17		 je	 SHORT $LN110@s370_copy_

; 3942 :                     ARCH_DEP( or_dev_storage_key )( dev, page, (STORKEY_REF | STORKEY_CHANGE) );

  00f42	41 b0 06	 mov	 r8b, 6
  00f45	48 8b 54 24 60	 mov	 rdx, QWORD PTR page$[rsp]
  00f4a	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00f52	e8 00 00 00 00	 call	 s370_or_dev_storage_key
  00f57	eb 15		 jmp	 SHORT $LN111@s370_copy_
$LN110@s370_copy_:

; 3943 :                 else
; 3944 :                     ARCH_DEP( or_dev_storage_key )( dev, page, STORKEY_REF );

  00f59	41 b0 04	 mov	 r8b, 4
  00f5c	48 8b 54 24 60	 mov	 rdx, QWORD PTR page$[rsp]
  00f61	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00f69	e8 00 00 00 00	 call	 s370_or_dev_storage_key
$LN111@s370_copy_:

; 3945 :             } /* end for(page) */

  00f6e	eb a4		 jmp	 SHORT $LN32@s370_copy_
$LN33@s370_copy_:

; 3946 : 
; 3947 : #if DEBUG_PREFETCH
; 3948 :             if (dev->ccwtrace)
; 3949 :             {
; 3950 :                 char msgbuf[133];
; 3951 : 
; 3952 :                 MSGBUF( msgbuf,
; 3953 :                     "CCW %2.2X %2.2X %4.4X %8.8X to_memory=%d to_iobuf=%d readbackwards=%d",
; 3954 :                     (U8)code, (U8)flags, (U16)count, (U32)addr, to_memory, to_iobuf, readbackwards );
; 3955 :                 WRMSG( HHC01392, "D", msgbuf );
; 3956 :             }
; 3957 : #endif
; 3958 :             /* Copy data between main storage and channel buffer */
; 3959 :             if (readbackwards)

  00f70	0f b6 44 24 59	 movzx	 eax, BYTE PTR readbackwards$[rsp]
  00f75	85 c0		 test	 eax, eax
  00f77	0f 84 a5 00 00
	00		 je	 $LN112@s370_copy_

; 3960 :             {
; 3961 :                 BYTE *iobufptr = iobuf + dev->curblkrem;

  00f7d	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f85	8b 80 18 10 00
	00		 mov	 eax, DWORD PTR [rax+4120]
  00f8b	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00f93	48 03 c8	 add	 rcx, rax
  00f96	48 8b c1	 mov	 rax, rcx
  00f99	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR iobufptr$1[rsp], rax

; 3962 : 
; 3963 :                 /* Channel check if outside buffer                   */
; 3964 :                 /* SA22-7201-05:                                     */
; 3965 :                 /*  p. 16-27, Channel-Data Check                     */
; 3966 :                 if (!count                              ||
; 3967 :                     (iobufptr + count) > (iobufend + 1) ||

  00fa1	83 bc 24 38 01
	00 00 00	 cmp	 DWORD PTR count$[rsp], 0
  00fa9	74 37		 je	 SHORT $LN116@s370_copy_
  00fab	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00fb2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR iobufptr$1[rsp]
  00fba	48 03 c8	 add	 rcx, rax
  00fbd	48 8b c1	 mov	 rax, rcx
  00fc0	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR iobufend$[rsp]
  00fc8	48 ff c1	 inc	 rcx
  00fcb	48 3b c1	 cmp	 rax, rcx
  00fce	77 12		 ja	 SHORT $LN116@s370_copy_
  00fd0	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR iobufstart$[rsp]
  00fd8	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR iobufptr$1[rsp], rax
  00fe0	73 0d		 jae	 SHORT $LN114@s370_copy_
$LN116@s370_copy_:

; 3968 :                     iobufptr < iobufstart)
; 3969 :                     *chanstat = CSW_CDC;

  00fe2	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00fea	c6 00 08	 mov	 BYTE PTR [rax], 8
  00fed	eb 2e		 jmp	 SHORT $LN115@s370_copy_
$LN114@s370_copy_:

; 3970 :                 else
; 3971 :                 {
; 3972 :                     /* read backward  - use END of buffer */
; 3973 :                     memcpy_backwards( dev->mainstor + addr,

  00fef	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00ff6	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ffe	48 03 81 80 00
	00 00		 add	 rax, QWORD PTR [rcx+128]
  01005	44 8b 84 24 38
	01 00 00	 mov	 r8d, DWORD PTR count$[rsp]
  0100d	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR iobufptr$1[rsp]
  01015	48 8b c8	 mov	 rcx, rax
  01018	e8 00 00 00 00	 call	 memcpy_backwards
$LN115@s370_copy_:

; 3974 :                         iobufptr, count );
; 3975 :                 }
; 3976 :             }

  0101d	e9 1e 01 00 00	 jmp	 $LN113@s370_copy_
$LN112@s370_copy_:

; 3977 : 
; 3978 :             /* Channel check if outside buffer                       */
; 3979 :             /* SA22-7201-05:                                         */
; 3980 :             /*  p. 16-27, Channel-Data Check                         */
; 3981 :             else if (!count                           ||
; 3982 :                      (iobuf + count) > (iobufend + 1) ||

  01022	83 bc 24 38 01
	00 00 00	 cmp	 DWORD PTR count$[rsp], 0
  0102a	74 37		 je	 SHORT $LN119@s370_copy_
  0102c	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  01033	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0103b	48 03 c8	 add	 rcx, rax
  0103e	48 8b c1	 mov	 rax, rcx
  01041	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR iobufend$[rsp]
  01049	48 ff c1	 inc	 rcx
  0104c	48 3b c1	 cmp	 rax, rcx
  0104f	77 12		 ja	 SHORT $LN119@s370_copy_
  01051	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR iobufstart$[rsp]
  01059	48 39 84 24 58
	01 00 00	 cmp	 QWORD PTR iobuf$[rsp], rax
  01061	73 36		 jae	 SHORT $LN117@s370_copy_
$LN119@s370_copy_:
$LN37@s370_copy_:

; 3983 :                      iobuf < iobufstart)
; 3984 :                 set_chanstat( CSW_CDC );

  01063	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  0106b	83 38 00	 cmp	 DWORD PTR [rax], 0
  0106e	74 13		 je	 SHORT $LN120@s370_copy_
  01070	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  01074	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  0107c	c6 44 01 10 08	 mov	 BYTE PTR [rcx+rax+16], 8
  01081	eb 0b		 jmp	 SHORT $LN121@s370_copy_
$LN120@s370_copy_:
  01083	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  0108b	c6 00 08	 mov	 BYTE PTR [rax], 8
$LN121@s370_copy_:
  0108e	33 c0		 xor	 eax, eax
  01090	85 c0		 test	 eax, eax
  01092	75 cf		 jne	 SHORT $LN37@s370_copy_
  01094	e9 a7 00 00 00	 jmp	 $LN118@s370_copy_
$LN117@s370_copy_:

; 3985 : 
; 3986 :             /* Handle Write and Control transfer to I/O buffer */
; 3987 :             else if (to_iobuf)

  01099	0f b6 44 24 5b	 movzx	 eax, BYTE PTR to_iobuf$[rsp]
  0109e	85 c0		 test	 eax, eax
  010a0	74 72		 je	 SHORT $LN122@s370_copy_

; 3988 :             {
; 3989 :                 memcpy( iobuf, dev->mainstor + addr, count );

  010a2	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  010a9	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  010b0	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  010b8	48 03 8a 80 00
	00 00		 add	 rcx, QWORD PTR [rdx+128]
  010bf	48 8b bc 24 58
	01 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  010c7	48 8b f1	 mov	 rsi, rcx
  010ca	8b c8		 mov	 ecx, eax
  010cc	f3 a4		 rep movsb

; 3990 : 
; 3991 :                 prefetch->pos += count;

  010ce	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  010d6	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  010d9	03 84 24 38 01
	00 00		 add	 eax, DWORD PTR count$[rsp]
  010e0	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  010e8	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 3992 : 
; 3993 :                 if (prefetch->seq)

  010eb	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR prefetch$[rsp]
  010f3	83 38 00	 cmp	 DWORD PTR [rax], 0
  010f6	74 1a		 je	 SHORT $LN124@s370_copy_

; 3994 :                     prefetch->datalen[ps] = count;

  010f8	8b 44 24 54	 mov	 eax, DWORD PTR ps$[rsp]
  010fc	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR prefetch$[rsp]
  01104	8b 94 24 38 01
	00 00		 mov	 edx, DWORD PTR count$[rsp]
  0110b	89 94 81 10 05
	00 00		 mov	 DWORD PTR [rcx+rax*4+1296], edx
$LN124@s370_copy_:

; 3995 : 
; 3996 :             }

  01112	eb 2c		 jmp	 SHORT $LN123@s370_copy_
$LN122@s370_copy_:

; 3997 : 
; 3998 :             /* Handle Read transfer from I/O buffer */
; 3999 :             else
; 4000 :             {
; 4001 :                 memcpy( dev->mainstor + addr, iobuf, count );

  01114	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  0111b	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  01122	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0112a	48 03 8a 80 00
	00 00		 add	 rcx, QWORD PTR [rdx+128]
  01131	48 8b f9	 mov	 rdi, rcx
  01134	48 8b b4 24 58
	01 00 00	 mov	 rsi, QWORD PTR iobuf$[rsp]
  0113c	8b c8		 mov	 ecx, eax
  0113e	f3 a4		 rep movsb
$LN123@s370_copy_:
$LN118@s370_copy_:
$LN113@s370_copy_:

; 4002 :             }
; 4003 : 
; 4004 : #ifdef FEATURE_S370_CHANNEL
; 4005 :             if (dev->devtype == 0x2703)

  01140	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01148	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0114c	3d 03 27 00 00	 cmp	 eax, 9987		; 00002703H
  01151	75 23		 jne	 SHORT $LN125@s370_copy_

; 4006 :                 if (dev->commadpt->lnctl == COMMADPT_LNCTL_ASYNC)

  01153	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0115b	48 8b 80 68 11
	00 00		 mov	 rax, QWORD PTR [rax+4456]
  01162	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  01166	83 f8 02	 cmp	 eax, 2
  01169	75 0b		 jne	 SHORT $LN126@s370_copy_

; 4007 :                     usleep(5000);

  0116b	b9 88 13 00 00	 mov	 ecx, 5000		; 00001388H
  01170	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN126@s370_copy_:
$LN125@s370_copy_:
$LN109@s370_copy_:
$LN50@s370_copy_:
$LN1@s370_copy_:

; 4008 : #endif
; 4009 : 
; 4010 : #if DEBUG_DUMP
; 4011 :             if (dev->ccwtrace)
; 4012 :             {
; 4013 :                 char msgbuf[133];
; 4014 : 
; 4015 :                 MSGBUF( msgbuf, "iobuf->%8.8X.%4.4X", addr, count );
; 4016 :                 WRMSG( HHC01390, "D", msgbuf );
; 4017 : 
; 4018 :                 MSGBUF( msgbuf, "addr=%8.8X count=%d residual=%d copy=%d",
; 4019 :                     addr, count, *residual, count );
; 4020 :                 WRMSG( HHC01390, "D", msgbuf );
; 4021 : 
; 4022 :                 if (to_memory)
; 4023 :                     DUMP( "iobuf:", iobuf, count );
; 4024 :                 DUMP_STORAGE( "Storage:", addr, count );
; 4025 :                 if (to_iobuf)
; 4026 :                     DUMP( "iobuf:", iobuf, count );
; 4027 :             }
; 4028 : #endif
; 4029 :         }
; 4030 : 
; 4031 :     } /* end if(!IDA) */
; 4032 : 
; 4033 : #undef get_new_prefetch_entry
; 4034 : #undef set_chanstat
; 4035 : 
; 4036 : } /* end function copy_iobuf */

  01176	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  0117d	5f		 pop	 rdi
  0117e	5e		 pop	 rsi
  0117f	c3		 ret	 0
s370_copy_iobuf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
storkey$ = 32
idalen$ = 36
tv67 = 40
idaw1$ = 44
idaw$ = 48
idapage$ = 56
idaw2$ = 64
dev$ = 96
code$ = 104
ccwkey$ = 112
idawfmt$ = 120
idapmask$ = 128
idaseq$ = 136
idawaddr$ = 144
addr$ = 152
len$ = 160
chanstat$ = 168
s370_fetch_idaw PROC

; 3123 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@s370_fetch:

; 3124 : RADR    idaw;                           /* Contents of IDAW          */
; 3125 : U32     idaw1;                          /* Format-1 IDAW             */
; 3126 : U64     idaw2;                          /* Format-2 IDAW             */
; 3127 : RADR    idapage;                        /* Addr of next IDA page     */
; 3128 : U16     idalen;                         /* #of bytes until next page */
; 3129 : BYTE    storkey;                        /* Storage key               */
; 3130 : 
; 3131 :     UNREFERENCED_370(dev);

  00017	33 c0		 xor	 eax, eax
  00019	85 c0		 test	 eax, eax
  0001b	75 fa		 jne	 SHORT $LN4@s370_fetch

; 3132 :     *addr = 0;

  0001d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00025	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 3133 :     *len = 0;

  0002c	33 c0		 xor	 eax, eax
  0002e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  00036	66 89 01	 mov	 WORD PTR [rcx], ax

; 3134 : 
; 3135 :     /* Channel program check if IDAW is not on correct
; 3136 :        boundary or is outside limit of main storage */
; 3137 :     if ((idawaddr & ((idawfmt == PF_IDAW2) ? 0x07 : 0x03))
; 3138 :         || CHADDRCHK(idawaddr, dev)
; 3139 :         /* Program check if Format-0 CCW and IDAW address > 16M      */
; 3140 :         /* SA22-7201-05:                                             */
; 3141 :         /*  p. 16-25, Invalid IDAW Address                           */
; 3142 :         || (!(dev->orb.flag5 & ORB5_F) && (idawaddr & 0xFF000000)))

  00039	0f b6 44 24 78	 movzx	 eax, BYTE PTR idawfmt$[rsp]
  0003e	83 f8 02	 cmp	 eax, 2
  00041	75 0a		 jne	 SHORT $LN18@s370_fetch
  00043	c7 44 24 28 07
	00 00 00	 mov	 DWORD PTR tv67[rsp], 7
  0004b	eb 08		 jmp	 SHORT $LN19@s370_fetch
$LN18@s370_fetch:
  0004d	c7 44 24 28 03
	00 00 00	 mov	 DWORD PTR tv67[rsp], 3
$LN19@s370_fetch:
  00055	8b 44 24 28	 mov	 eax, DWORD PTR tv67[rsp]
  00059	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR idawaddr$[rsp]
  00060	23 c8		 and	 ecx, eax
  00062	8b c1		 mov	 eax, ecx
  00064	85 c0		 test	 eax, eax
  00066	75 3a		 jne	 SHORT $LN6@s370_fetch
  00068	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idawaddr$[rsp]
  0006f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00074	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  0007b	77 25		 ja	 SHORT $LN6@s370_fetch
  0007d	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00082	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  00089	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0008e	85 c0		 test	 eax, eax
  00090	75 20		 jne	 SHORT $LN5@s370_fetch
  00092	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idawaddr$[rsp]
  00099	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  0009e	85 c0		 test	 eax, eax
  000a0	74 10		 je	 SHORT $LN5@s370_fetch
$LN6@s370_fetch:

; 3143 :     {
; 3144 :         *chanstat = CSW_PROGC;

  000a2	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  000aa	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3145 :         return;

  000ad	e9 54 02 00 00	 jmp	 $LN1@s370_fetch
$LN5@s370_fetch:

; 3146 :     }
; 3147 : 
; 3148 :     /* Channel protection check if IDAW is fetch protected */
; 3149 :     storkey = ARCH_DEP( get_dev_storage_key )( dev, idawaddr );

  000b2	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idawaddr$[rsp]
  000b9	8b d0		 mov	 edx, eax
  000bb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000c0	e8 00 00 00 00	 call	 s370_get_dev_storage_key
  000c5	88 44 24 20	 mov	 BYTE PTR storkey$[rsp], al

; 3150 :     if (ccwkey != 0 && (storkey & STORKEY_FETCH)
; 3151 :         && (storkey & STORKEY_KEY) != ccwkey)

  000c9	0f b6 44 24 70	 movzx	 eax, BYTE PTR ccwkey$[rsp]
  000ce	85 c0		 test	 eax, eax
  000d0	74 2f		 je	 SHORT $LN7@s370_fetch
  000d2	0f b6 44 24 20	 movzx	 eax, BYTE PTR storkey$[rsp]
  000d7	83 e0 08	 and	 eax, 8
  000da	85 c0		 test	 eax, eax
  000dc	74 23		 je	 SHORT $LN7@s370_fetch
  000de	0f b6 44 24 20	 movzx	 eax, BYTE PTR storkey$[rsp]
  000e3	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  000e8	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR ccwkey$[rsp]
  000ed	3b c1		 cmp	 eax, ecx
  000ef	74 10		 je	 SHORT $LN7@s370_fetch

; 3152 :     {
; 3153 :         *chanstat = CSW_PROTC;

  000f1	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  000f9	c6 00 10	 mov	 BYTE PTR [rax], 16

; 3154 :         return;

  000fc	e9 05 02 00 00	 jmp	 $LN1@s370_fetch
$LN7@s370_fetch:

; 3155 :     }
; 3156 : 
; 3157 :     /* Set the main storage reference bit for the IDAW location */
; 3158 :     ARCH_DEP( or_dev_storage_key )( dev, idawaddr, STORKEY_REF );

  00101	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idawaddr$[rsp]
  00108	41 b0 04	 mov	 r8b, 4
  0010b	8b d0		 mov	 edx, eax
  0010d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00112	e8 00 00 00 00	 call	 s370_or_dev_storage_key

; 3159 : 
; 3160 :     /* Fetch IDAW from main storage */
; 3161 :     if (idawfmt == PF_IDAW2)

  00117	0f b6 44 24 78	 movzx	 eax, BYTE PTR idawfmt$[rsp]
  0011c	83 f8 02	 cmp	 eax, 2
  0011f	75 4f		 jne	 SHORT $LN8@s370_fetch

; 3162 :     {
; 3163 :         /* Fetch format-2 IDAW */
; 3164 :         FETCH_DW(idaw2, dev->mainstor + idawaddr);

  00121	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idawaddr$[rsp]
  00128	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0012d	48 03 81 80 00
	00 00		 add	 rax, QWORD PTR [rcx+128]
  00134	48 8b c8	 mov	 rcx, rax
  00137	e8 00 00 00 00	 call	 fetch_dw_noswap
  0013c	48 8b c8	 mov	 rcx, rax
  0013f	e8 00 00 00 00	 call	 _byteswap_uint64
  00144	48 89 44 24 40	 mov	 QWORD PTR idaw2$[rsp], rax

; 3165 : 
; 3166 : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 3167 :         /* Channel program check in ESA/390 mode
; 3168 :            if the format-2 IDAW exceeds 2GB-1 */
; 3169 :         if (idaw2 > 0x7FFFFFFF)

  00149	48 81 7c 24 40
	ff ff ff 7f	 cmp	 QWORD PTR idaw2$[rsp], 2147483647 ; 7fffffffH
  00152	76 10		 jbe	 SHORT $LN10@s370_fetch

; 3170 :         {
; 3171 :             *chanstat = CSW_PROGC;

  00154	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  0015c	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3172 :             return;

  0015f	e9 a2 01 00 00	 jmp	 $LN1@s370_fetch
$LN10@s370_fetch:

; 3173 :         }
; 3174 : #endif
; 3175 :         /* Save contents of format-2 IDAW */
; 3176 :         idaw = idaw2;

  00164	48 8b 44 24 40	 mov	 rax, QWORD PTR idaw2$[rsp]
  00169	48 89 44 24 30	 mov	 QWORD PTR idaw$[rsp], rax

; 3177 :     }

  0016e	eb 4c		 jmp	 SHORT $LN9@s370_fetch
$LN8@s370_fetch:

; 3178 :     else
; 3179 :     {
; 3180 :         /* Fetch format-1 IDAW */
; 3181 :         FETCH_FW(idaw1, dev->mainstor + idawaddr);

  00170	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idawaddr$[rsp]
  00177	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0017c	48 03 81 80 00
	00 00		 add	 rax, QWORD PTR [rcx+128]
  00183	48 8b c8	 mov	 rcx, rax
  00186	e8 00 00 00 00	 call	 fetch_fw_noswap
  0018b	8b c8		 mov	 ecx, eax
  0018d	e8 00 00 00 00	 call	 _byteswap_ulong
  00192	89 44 24 2c	 mov	 DWORD PTR idaw1$[rsp], eax

; 3182 : 
; 3183 :         /* Channel program check if bit 0 of
; 3184 :            the format-1 IDAW is not zero */
; 3185 :         if (idaw1 & 0x80000000)

  00196	8b 44 24 2c	 mov	 eax, DWORD PTR idaw1$[rsp]
  0019a	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0019f	85 c0		 test	 eax, eax
  001a1	74 10		 je	 SHORT $LN11@s370_fetch

; 3186 :         {
; 3187 :             *chanstat = CSW_PROGC;

  001a3	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  001ab	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3188 :             return;

  001ae	e9 53 01 00 00	 jmp	 $LN1@s370_fetch
$LN11@s370_fetch:

; 3189 :         }
; 3190 : 
; 3191 :         /* Save contents of format-1 IDAW */
; 3192 :         idaw = idaw1;

  001b3	8b 44 24 2c	 mov	 eax, DWORD PTR idaw1$[rsp]
  001b7	48 89 44 24 30	 mov	 QWORD PTR idaw$[rsp], rax
$LN9@s370_fetch:

; 3193 :     }
; 3194 : 
; 3195 :     /* Channel program check if IDAW data
; 3196 :        location is outside main storage */
; 3197 :     if ( CHADDRCHK(idaw, dev) )

  001bc	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001c1	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  001c8	48 39 44 24 30	 cmp	 QWORD PTR idaw$[rsp], rax
  001cd	76 10		 jbe	 SHORT $LN12@s370_fetch

; 3198 :     {
; 3199 :         *chanstat = CSW_PROGC;

  001cf	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  001d7	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3200 :         return;

  001da	e9 27 01 00 00	 jmp	 $LN1@s370_fetch
$LN12@s370_fetch:

; 3201 :     }
; 3202 : 
; 3203 :     /* Channel program check if IDAW data location is not
; 3204 :        on a page boundary, except for the first IDAW */
; 3205 :     if (IS_CCW_RDBACK (code))

  001df	0f b6 44 24 68	 movzx	 eax, BYTE PTR code$[rsp]
  001e4	83 e0 0f	 and	 eax, 15
  001e7	83 f8 0c	 cmp	 eax, 12
  001ea	0f 85 8b 00 00
	00		 jne	 $LN13@s370_fetch

; 3206 :     {
; 3207 :         if (idaseq > 0 && ((idaw+1) & idapmask) != 0)

  001f0	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR idaseq$[rsp], 0
  001f8	7e 28		 jle	 SHORT $LN15@s370_fetch
  001fa	48 8b 44 24 30	 mov	 rax, QWORD PTR idaw$[rsp]
  001ff	48 ff c0	 inc	 rax
  00202	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR idapmask$[rsp]
  0020a	48 23 c1	 and	 rax, rcx
  0020d	48 85 c0	 test	 rax, rax
  00210	74 10		 je	 SHORT $LN15@s370_fetch

; 3208 :         {
; 3209 :             *chanstat = CSW_PROGC;

  00212	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  0021a	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3210 :             return;

  0021d	e9 e4 00 00 00	 jmp	 $LN1@s370_fetch
$LN15@s370_fetch:

; 3211 :         }
; 3212 : 
; 3213 :         /* Calculate address of next page boundary */
; 3214 :         idapage = (idaw & ~idapmask);

  00222	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR idapmask$[rsp]
  0022a	f7 d0		 not	 eax
  0022c	48 98		 cdqe
  0022e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR idaw$[rsp]
  00233	48 23 c8	 and	 rcx, rax
  00236	48 8b c1	 mov	 rax, rcx
  00239	48 89 44 24 38	 mov	 QWORD PTR idapage$[rsp], rax

; 3215 :         idalen = (idaw - idapage) + 1;

  0023e	48 8b 44 24 38	 mov	 rax, QWORD PTR idapage$[rsp]
  00243	48 8b 4c 24 30	 mov	 rcx, QWORD PTR idaw$[rsp]
  00248	48 2b c8	 sub	 rcx, rax
  0024b	48 8b c1	 mov	 rax, rcx
  0024e	48 ff c0	 inc	 rax
  00251	66 89 44 24 24	 mov	 WORD PTR idalen$[rsp], ax

; 3216 : 
; 3217 :         /* Return the address and length for this IDAW */
; 3218 :         *addr = idaw;

  00256	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  0025e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR idaw$[rsp]
  00263	48 89 08	 mov	 QWORD PTR [rax], rcx

; 3219 :         *len = idalen;

  00266	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  0026e	0f b7 4c 24 24	 movzx	 ecx, WORD PTR idalen$[rsp]
  00273	66 89 08	 mov	 WORD PTR [rax], cx

; 3220 :     }

  00276	e9 8b 00 00 00	 jmp	 $LN14@s370_fetch
$LN13@s370_fetch:

; 3221 :     else
; 3222 :     {
; 3223 :         if (idaseq > 0 && (idaw & idapmask) != 0)

  0027b	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR idaseq$[rsp], 0
  00283	7e 25		 jle	 SHORT $LN16@s370_fetch
  00285	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR idapmask$[rsp]
  0028d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR idaw$[rsp]
  00292	48 23 c8	 and	 rcx, rax
  00295	48 8b c1	 mov	 rax, rcx
  00298	48 85 c0	 test	 rax, rax
  0029b	74 0d		 je	 SHORT $LN16@s370_fetch

; 3224 :         {
; 3225 :             *chanstat = CSW_PROGC;

  0029d	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  002a5	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3226 :             return;

  002a8	eb 5c		 jmp	 SHORT $LN1@s370_fetch
$LN16@s370_fetch:

; 3227 :         }
; 3228 : 
; 3229 :         /* Calculate address of next page boundary */
; 3230 :         idapage = (idaw + idapmask + 1) & ~idapmask;

  002aa	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR idapmask$[rsp]
  002b2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR idaw$[rsp]
  002b7	48 8d 44 01 01	 lea	 rax, QWORD PTR [rcx+rax+1]
  002bc	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR idapmask$[rsp]
  002c4	f7 d1		 not	 ecx
  002c6	48 63 c9	 movsxd	 rcx, ecx
  002c9	48 23 c1	 and	 rax, rcx
  002cc	48 89 44 24 38	 mov	 QWORD PTR idapage$[rsp], rax

; 3231 :         idalen = idapage - idaw;

  002d1	48 8b 44 24 30	 mov	 rax, QWORD PTR idaw$[rsp]
  002d6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR idapage$[rsp]
  002db	48 2b c8	 sub	 rcx, rax
  002de	48 8b c1	 mov	 rax, rcx
  002e1	66 89 44 24 24	 mov	 WORD PTR idalen$[rsp], ax

; 3232 : 
; 3233 :         /* Return the address and length for this IDAW */
; 3234 :         *addr = idaw;

  002e6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  002ee	48 8b 4c 24 30	 mov	 rcx, QWORD PTR idaw$[rsp]
  002f3	48 89 08	 mov	 QWORD PTR [rax], rcx

; 3235 :         *len = idalen;

  002f6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  002fe	0f b7 4c 24 24	 movzx	 ecx, WORD PTR idalen$[rsp]
  00303	66 89 08	 mov	 WORD PTR [rax], cx
$LN14@s370_fetch:
$LN1@s370_fetch:

; 3236 :     }
; 3237 : 
; 3238 : } /* end function fetch_idaw */

  00306	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0030a	c3		 ret	 0
s370_fetch_idaw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
storkey$ = 32
ccw$ = 40
dev$ = 64
ccwkey$ = 72
ccwfmt$ = 80
ccwaddr$ = 88
code$ = 96
addr$ = 104
flags$ = 112
count$ = 120
chanstat$ = 128
s370_fetch_ccw PROC

; 3056 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@s370_fetch:

; 3057 : BYTE    storkey;                        /* Storage key               */
; 3058 : BYTE   *ccw;                            /* CCW pointer               */
; 3059 : 
; 3060 :     UNREFERENCED_370(dev);

  00017	33 c0		 xor	 eax, eax
  00019	85 c0		 test	 eax, eax
  0001b	75 fa		 jne	 SHORT $LN4@s370_fetch

; 3061 :     *code=0;

  0001d	48 8b 44 24 60	 mov	 rax, QWORD PTR code$[rsp]
  00022	c6 00 00	 mov	 BYTE PTR [rax], 0

; 3062 :     *count=0;

  00025	48 8b 44 24 78	 mov	 rax, QWORD PTR count$[rsp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 3063 :     *flags=0;

  00030	48 8b 44 24 70	 mov	 rax, QWORD PTR flags$[rsp]
  00035	c6 00 00	 mov	 BYTE PTR [rax], 0

; 3064 :     *addr=0;

  00038	48 8b 44 24 68	 mov	 rax, QWORD PTR addr$[rsp]
  0003d	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 3065 : 
; 3066 :     /* Channel program check if CCW is not on a doubleword
; 3067 :        boundary or is outside limit of main storage */
; 3068 :     if ( (ccwaddr & 0x00000007) || CHADDRCHK(ccwaddr, dev) )

  00043	8b 44 24 58	 mov	 eax, DWORD PTR ccwaddr$[rsp]
  00047	83 e0 07	 and	 eax, 7
  0004a	85 c0		 test	 eax, eax
  0004c	75 12		 jne	 SHORT $LN6@s370_fetch
  0004e	8b 44 24 58	 mov	 eax, DWORD PTR ccwaddr$[rsp]
  00052	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00057	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  0005e	76 10		 jbe	 SHORT $LN5@s370_fetch
$LN6@s370_fetch:

; 3069 :     {
; 3070 :         *chanstat = CSW_PROGC;

  00060	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  00068	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 3071 :         return;

  0006b	e9 ef 01 00 00	 jmp	 $LN1@s370_fetch
$LN5@s370_fetch:

; 3072 :     }
; 3073 : 
; 3074 :     /* Channel protection check if CCW is fetch protected */
; 3075 :     storkey = ARCH_DEP( get_dev_storage_key )( dev, ccwaddr );

  00070	8b 44 24 58	 mov	 eax, DWORD PTR ccwaddr$[rsp]
  00074	8b d0		 mov	 edx, eax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0007b	e8 00 00 00 00	 call	 s370_get_dev_storage_key
  00080	88 44 24 20	 mov	 BYTE PTR storkey$[rsp], al

; 3076 :     if (ccwkey != 0 && (storkey & STORKEY_FETCH)
; 3077 :         && (storkey & STORKEY_KEY) != ccwkey)

  00084	0f b6 44 24 48	 movzx	 eax, BYTE PTR ccwkey$[rsp]
  00089	85 c0		 test	 eax, eax
  0008b	74 2f		 je	 SHORT $LN7@s370_fetch
  0008d	0f b6 44 24 20	 movzx	 eax, BYTE PTR storkey$[rsp]
  00092	83 e0 08	 and	 eax, 8
  00095	85 c0		 test	 eax, eax
  00097	74 23		 je	 SHORT $LN7@s370_fetch
  00099	0f b6 44 24 20	 movzx	 eax, BYTE PTR storkey$[rsp]
  0009e	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  000a3	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR ccwkey$[rsp]
  000a8	3b c1		 cmp	 eax, ecx
  000aa	74 10		 je	 SHORT $LN7@s370_fetch

; 3078 :     {
; 3079 :         *chanstat = CSW_PROTC;

  000ac	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR chanstat$[rsp]
  000b4	c6 00 10	 mov	 BYTE PTR [rax], 16

; 3080 :         return;

  000b7	e9 a3 01 00 00	 jmp	 $LN1@s370_fetch
$LN7@s370_fetch:

; 3081 :     }
; 3082 : 
; 3083 :     /* Set the main storage reference bit for the CCW location */
; 3084 :     ARCH_DEP( or_dev_storage_key )( dev, ccwaddr, STORKEY_REF );

  000bc	8b 44 24 58	 mov	 eax, DWORD PTR ccwaddr$[rsp]
  000c0	41 b0 04	 mov	 r8b, 4
  000c3	8b d0		 mov	 edx, eax
  000c5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000ca	e8 00 00 00 00	 call	 s370_or_dev_storage_key

; 3085 : 
; 3086 :     /* Point to the CCW in main storage */
; 3087 :     ccw = dev->mainstor + ccwaddr;

  000cf	8b 44 24 58	 mov	 eax, DWORD PTR ccwaddr$[rsp]
  000d3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000d8	48 03 81 80 00
	00 00		 add	 rax, QWORD PTR [rcx+128]
  000df	48 89 44 24 28	 mov	 QWORD PTR ccw$[rsp], rax

; 3088 : 
; 3089 :     /* Extract CCW opcode, flags, byte count, and data address */
; 3090 :     if (ccwfmt == 0)

  000e4	0f b6 44 24 50	 movzx	 eax, BYTE PTR ccwfmt$[rsp]
  000e9	85 c0		 test	 eax, eax
  000eb	0f 85 ae 00 00
	00		 jne	 $LN8@s370_fetch

; 3091 :     {
; 3092 :         *code = ccw[0];

  000f1	b8 01 00 00 00	 mov	 eax, 1
  000f6	48 6b c0 00	 imul	 rax, rax, 0
  000fa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR code$[rsp]
  000ff	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  00104	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00108	88 01		 mov	 BYTE PTR [rcx], al

; 3093 :         *addr = ((U32)(ccw[1]) << 16) | ((U32)(ccw[2]) << 8)

  0010a	b8 01 00 00 00	 mov	 eax, 1
  0010f	48 6b c0 01	 imul	 rax, rax, 1
  00113	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ccw$[rsp]
  00118	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0011c	c1 e0 10	 shl	 eax, 16
  0011f	b9 01 00 00 00	 mov	 ecx, 1
  00124	48 6b c9 02	 imul	 rcx, rcx, 2
  00128	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  0012d	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00131	c1 e1 08	 shl	 ecx, 8
  00134	0b c1		 or	 eax, ecx
  00136	b9 01 00 00 00	 mov	 ecx, 1
  0013b	48 6b c9 03	 imul	 rcx, rcx, 3
  0013f	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  00144	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00148	0b c1		 or	 eax, ecx
  0014a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR addr$[rsp]
  0014f	89 01		 mov	 DWORD PTR [rcx], eax

; 3094 :                     | ccw[3];
; 3095 :         *flags = ccw[4];

  00151	b8 01 00 00 00	 mov	 eax, 1
  00156	48 6b c0 04	 imul	 rax, rax, 4
  0015a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR flags$[rsp]
  0015f	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  00164	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00168	88 01		 mov	 BYTE PTR [rcx], al

; 3096 :         *count = ((U16)(ccw[6]) << 8) | ccw[7];

  0016a	b8 01 00 00 00	 mov	 eax, 1
  0016f	48 6b c0 06	 imul	 rax, rax, 6
  00173	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ccw$[rsp]
  00178	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0017c	c1 e0 08	 shl	 eax, 8
  0017f	b9 01 00 00 00	 mov	 ecx, 1
  00184	48 6b c9 07	 imul	 rcx, rcx, 7
  00188	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  0018d	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00191	0b c1		 or	 eax, ecx
  00193	48 8b 4c 24 78	 mov	 rcx, QWORD PTR count$[rsp]
  00198	89 01		 mov	 DWORD PTR [rcx], eax

; 3097 :     }

  0019a	e9 c0 00 00 00	 jmp	 $LN9@s370_fetch
$LN8@s370_fetch:

; 3098 :     else
; 3099 :     {
; 3100 :         *code = ccw[0];

  0019f	b8 01 00 00 00	 mov	 eax, 1
  001a4	48 6b c0 00	 imul	 rax, rax, 0
  001a8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR code$[rsp]
  001ad	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  001b2	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  001b6	88 01		 mov	 BYTE PTR [rcx], al

; 3101 :         *flags = ccw[1];

  001b8	b8 01 00 00 00	 mov	 eax, 1
  001bd	48 6b c0 01	 imul	 rax, rax, 1
  001c1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR flags$[rsp]
  001c6	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  001cb	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  001cf	88 01		 mov	 BYTE PTR [rcx], al

; 3102 :         *count = ((U16)(ccw[2]) << 8) | ccw[3];

  001d1	b8 01 00 00 00	 mov	 eax, 1
  001d6	48 6b c0 02	 imul	 rax, rax, 2
  001da	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ccw$[rsp]
  001df	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001e3	c1 e0 08	 shl	 eax, 8
  001e6	b9 01 00 00 00	 mov	 ecx, 1
  001eb	48 6b c9 03	 imul	 rcx, rcx, 3
  001ef	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  001f4	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  001f8	0b c1		 or	 eax, ecx
  001fa	48 8b 4c 24 78	 mov	 rcx, QWORD PTR count$[rsp]
  001ff	89 01		 mov	 DWORD PTR [rcx], eax

; 3103 :         *addr = ((U32)(ccw[4]) << 24) | ((U32)(ccw[5]) << 16)

  00201	b8 01 00 00 00	 mov	 eax, 1
  00206	48 6b c0 04	 imul	 rax, rax, 4
  0020a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ccw$[rsp]
  0020f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00213	c1 e0 18	 shl	 eax, 24
  00216	b9 01 00 00 00	 mov	 ecx, 1
  0021b	48 6b c9 05	 imul	 rcx, rcx, 5
  0021f	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  00224	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00228	c1 e1 10	 shl	 ecx, 16
  0022b	0b c1		 or	 eax, ecx
  0022d	b9 01 00 00 00	 mov	 ecx, 1
  00232	48 6b c9 06	 imul	 rcx, rcx, 6
  00236	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  0023b	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0023f	c1 e1 08	 shl	 ecx, 8
  00242	0b c1		 or	 eax, ecx
  00244	b9 01 00 00 00	 mov	 ecx, 1
  00249	48 6b c9 07	 imul	 rcx, rcx, 7
  0024d	48 8b 54 24 28	 mov	 rdx, QWORD PTR ccw$[rsp]
  00252	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00256	0b c1		 or	 eax, ecx
  00258	48 8b 4c 24 68	 mov	 rcx, QWORD PTR addr$[rsp]
  0025d	89 01		 mov	 DWORD PTR [rcx], eax
$LN9@s370_fetch:
$LN1@s370_fetch:

; 3104 :                     | ((U32)(ccw[6]) << 8) | ccw[7];
; 3105 :     }
; 3106 : } /* end function fetch_ccw */

  0025f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00263	c3		 ret	 0
s370_fetch_ccw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv87 = 32
dev$ = 64
ccwkey$ = 72
ccwfmt$ = 80
ccwaddr$ = 88
s370_raise_pci PROC

; 3006 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@s370_raise:

; 3007 : #if !defined(FEATURE_CHANNEL_SUBSYSTEM)
; 3008 :     UNREFERENCED(ccwfmt);

  00017	33 c0		 xor	 eax, eax
  00019	85 c0		 test	 eax, eax
  0001b	75 fa		 jne	 SHORT $LN4@s370_raise
$LN7@s370_raise:

; 3009 : #endif
; 3010 : 
; 3011 :     IODELAY(dev);

  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00024	83 b8 e0 13 00
	00 00		 cmp	 DWORD PTR [rax+5088], 0
  0002b	7e 2e		 jle	 SHORT $LN8@s370_raise
  0002d	b8 01 00 00 00	 mov	 eax, 1
  00032	48 6b c0 0a	 imul	 rax, rax, 10
  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0003b	0f b6 84 01 6c
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1388]
  00043	83 f8 20	 cmp	 eax, 32			; 00000020H
  00046	75 13		 jne	 SHORT $LN8@s370_raise
  00048	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0004f	8b 88 e0 13 00
	00		 mov	 ecx, DWORD PTR [rax+5088]
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN8@s370_raise:
  0005b	33 c0		 xor	 eax, eax
  0005d	85 c0		 test	 eax, eax
  0005f	75 bc		 jne	 SHORT $LN7@s370_raise

; 3012 : 
; 3013 :     OBTAIN_INTLOCK(NULL);

  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171055
  00068	33 c9		 xor	 ecx, ecx
  0006a	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 3014 :     obtain_lock (&dev->lock);

  0006f	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00074	48 83 c0 38	 add	 rax, 56			; 00000038H
  00078	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171056
  0007f	48 8b c8	 mov	 rcx, rax
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3015 : 
; 3016 :     /* Save the PCI SCSW replacing any previous pending PCI; always
; 3017 :      * track the channel in channel subsystem mode
; 3018 :      */
; 3019 :     dev->pciscsw.flag0 = ccwkey & SCSW0_KEY;

  00088	0f b6 44 24 48	 movzx	 eax, BYTE PTR ccwkey$[rsp]
  0008d	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00092	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00097	88 81 14 03 00
	00		 mov	 BYTE PTR [rcx+788], al

; 3020 :     dev->pciscsw.flag1 = (ccwfmt == 1 ? SCSW1_F : 0);

  0009d	0f b6 44 24 50	 movzx	 eax, BYTE PTR ccwfmt$[rsp]
  000a2	83 f8 01	 cmp	 eax, 1
  000a5	75 0a		 jne	 SHORT $LN10@s370_raise
  000a7	c7 44 24 20 80
	00 00 00	 mov	 DWORD PTR tv87[rsp], 128 ; 00000080H
  000af	eb 08		 jmp	 SHORT $LN11@s370_raise
$LN10@s370_raise:
  000b1	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
$LN11@s370_raise:
  000b9	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000be	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR tv87[rsp]
  000c3	88 88 15 03 00
	00		 mov	 BYTE PTR [rax+789], cl

; 3021 :     dev->pciscsw.flag2 = SCSW2_FC_START;

  000c9	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000ce	c6 80 16 03 00
	00 40		 mov	 BYTE PTR [rax+790], 64	; 00000040H

; 3022 :     dev->pciscsw.flag3 = SCSW3_AC_SCHAC | SCSW3_AC_DEVAC

  000d5	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000da	c6 80 17 03 00
	00 c9		 mov	 BYTE PTR [rax+791], 201	; 000000c9H

; 3023 :                        | SCSW3_SC_INTER | SCSW3_SC_PEND;
; 3024 :     STORE_FW(dev->pciscsw.ccwaddr,ccwaddr);

  000e1	8b 4c 24 58	 mov	 ecx, DWORD PTR ccwaddr$[rsp]
  000e5	e8 00 00 00 00	 call	 _byteswap_ulong
  000ea	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000ef	48 81 c1 18 03
	00 00		 add	 rcx, 792		; 00000318H
  000f6	8b d0		 mov	 edx, eax
  000f8	e8 00 00 00 00	 call	 store_fw_noswap

; 3025 :     dev->pciscsw.unitstat = 0;

  000fd	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00102	c6 80 1c 03 00
	00 00		 mov	 BYTE PTR [rax+796], 0

; 3026 :     dev->pciscsw.chanstat = CSW_PCI;

  00109	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0010e	c6 80 1d 03 00
	00 80		 mov	 BYTE PTR [rax+797], 128	; 00000080H

; 3027 :     store_hw (dev->pciscsw.count, 0);

  00115	33 c9		 xor	 ecx, ecx
  00117	e8 00 00 00 00	 call	 _byteswap_ushort
  0011c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00121	48 81 c1 1e 03
	00 00		 add	 rcx, 798		; 0000031eH
  00128	0f b7 d0	 movzx	 edx, ax
  0012b	e8 00 00 00 00	 call	 store_hw_noswap

; 3028 : 
; 3029 :     /* Queue the PCI pending interrupt */
; 3030 :     obtain_lock(&sysblk.iointqlk);

  00130	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00137	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  0013d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171057
  00144	48 8b c8	 mov	 rcx, rax
  00147	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3031 :     QUEUE_IO_INTERRUPT_QLOCKED(&dev->pciioint,FALSE);

  0014d	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00152	48 05 40 02 00
	00		 add	 rax, 576		; 00000240H
  00158	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171058
  0015f	33 d2		 xor	 edx, edx
  00161	48 8b c8	 mov	 rcx, rax
  00164	e8 00 00 00 00	 call	 Queue_IO_Interrupt_QLocked

; 3032 : 
; 3033 :     /* Update interrupt status */
; 3034 :     subchannel_interrupt_queue_cleanup(dev);

  00169	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0016e	e8 00 00 00 00	 call	 subchannel_interrupt_queue_cleanup

; 3035 :     UPDATE_IC_IOPENDING_QLOCKED();

  00173	e8 00 00 00 00	 call	 Update_IC_IOPENDING_QLocked

; 3036 :     release_lock(&sysblk.iointqlk);

  00178	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0017f	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  00185	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171059
  0018c	48 8b c8	 mov	 rcx, rax
  0018f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3037 :     release_lock(&dev->lock);

  00195	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0019a	48 83 c0 38	 add	 rax, 56			; 00000038H
  0019e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171060
  001a5	48 8b c8	 mov	 rcx, rax
  001a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3038 :     RELEASE_INTLOCK(NULL);

  001ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171061
  001b5	33 c9		 xor	 ecx, ecx
  001b7	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 3039 : 
; 3040 : } /* end function raise_pci */

  001bc	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001c0	c3		 ret	 0
s370_raise_pci ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
device_resume$ = 32
count$ = 36
rc$ = 40
ioq$ = 48
previoq$ = 56
nextioq$ = 64
dev$ = 96
ScheduleIORequest PROC

; 2730 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2731 :     DEVBLK *ioq, *previoq, *nextioq;    /* Device I/O queue pointers */
; 2732 :     int     count;                      /* I/O queue length          */
; 2733 :     int     rc = 0;                     /* Return Code               */

  00009	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 2734 :     U8      device_resume;              /* Resume I/O flag - Device  */
; 2735 : 
; 2736 :     /* Determine if the device is resuming */
; 2737 :     device_resume = (dev->scsw.flag2 & SCSW2_AC_RESUM);

  00011	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00016	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  0001d	83 e0 08	 and	 eax, 8
  00020	88 44 24 20	 mov	 BYTE PTR device_resume$[rsp], al

; 2738 : 
; 2739 :     /* Lock the I/O request queue */
; 2740 :     obtain_lock( &sysblk.ioqlock );

  00024	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002b	48 05 38 12 00
	00		 add	 rax, 4664		; 00001238H
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170977
  00038	48 8b c8	 mov	 rcx, rax
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2741 : 
; 2742 :     /* Insert this I/O request into the appropriate I/O queue slot */
; 2743 :     for (ioq = sysblk.ioq, previoq = NULL, count = 0;

  00041	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00048	48 8b 80 30 12
	00 00		 mov	 rax, QWORD PTR [rax+4656]
  0004f	48 89 44 24 30	 mov	 QWORD PTR ioq$[rsp], rax
  00054	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR previoq$[rsp], 0
  0005d	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR count$[rsp], 0
  00065	eb 25		 jmp	 SHORT $LN4@ScheduleIO
$LN2@ScheduleIO:

; 2745 :         ++count, previoq = ioq, ioq = ioq->nextioq)

  00067	8b 44 24 24	 mov	 eax, DWORD PTR count$[rsp]
  0006b	ff c0		 inc	 eax
  0006d	89 44 24 24	 mov	 DWORD PTR count$[rsp], eax
  00071	48 8b 44 24 30	 mov	 rax, QWORD PTR ioq$[rsp]
  00076	48 89 44 24 38	 mov	 QWORD PTR previoq$[rsp], rax
  0007b	48 8b 44 24 30	 mov	 rax, QWORD PTR ioq$[rsp]
  00080	48 8b 80 20 02
	00 00		 mov	 rax, QWORD PTR [rax+544]
  00087	48 89 44 24 30	 mov	 QWORD PTR ioq$[rsp], rax
$LN4@ScheduleIO:

; 2744 :         ioq;

  0008c	48 83 7c 24 30
	00		 cmp	 QWORD PTR ioq$[rsp], 0
  00092	74 6a		 je	 SHORT $LN3@ScheduleIO

; 2746 :     {
; 2747 :         /* If DEVBLK already in queue, fail queueing of DEVBLK */
; 2748 :         if (ioq == dev)

  00094	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00099	48 39 44 24 30	 cmp	 QWORD PTR ioq$[rsp], rax
  0009e	75 0b		 jne	 SHORT $LN8@ScheduleIO

; 2749 :         {
; 2750 :             rc = 2;

  000a0	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR rc$[rsp], 2

; 2751 :             BREAK_INTO_DEBUGGER();

  000a8	cc		 int	 3

; 2752 :             break;

  000a9	eb 53		 jmp	 SHORT $LN3@ScheduleIO
$LN8@ScheduleIO:

; 2753 :         }
; 2754 : 
; 2755 :         /* 1. Look for priority partition. */
; 2756 :         if (dev->priority > ioq->priority)

  000ab	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000b0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ioq$[rsp]
  000b5	8b 89 18 02 00
	00		 mov	 ecx, DWORD PTR [rcx+536]
  000bb	39 88 18 02 00
	00		 cmp	 DWORD PTR [rax+536], ecx
  000c1	7e 02		 jle	 SHORT $LN9@ScheduleIO

; 2757 :             break;

  000c3	eb 39		 jmp	 SHORT $LN3@ScheduleIO
$LN9@ScheduleIO:

; 2758 :         if (dev->priority < ioq->priority)

  000c5	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000ca	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ioq$[rsp]
  000cf	8b 89 18 02 00
	00		 mov	 ecx, DWORD PTR [rcx+536]
  000d5	39 88 18 02 00
	00		 cmp	 DWORD PTR [rax+536], ecx
  000db	7d 02		 jge	 SHORT $LN10@ScheduleIO

; 2759 :             continue;

  000dd	eb 88		 jmp	 SHORT $LN2@ScheduleIO
$LN10@ScheduleIO:

; 2760 : 
; 2761 :         /* 2. Resumes precede Start I/Os in each priority partition */
; 2762 :         if (device_resume > (ioq->scsw.flag2 & SCSW2_AC_RESUM))

  000df	0f b6 44 24 20	 movzx	 eax, BYTE PTR device_resume$[rsp]
  000e4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ioq$[rsp]
  000e9	0f b6 89 0a 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+778]
  000f0	83 e1 08	 and	 ecx, 8
  000f3	3b c1		 cmp	 eax, ecx
  000f5	7e 02		 jle	 SHORT $LN11@ScheduleIO

; 2763 :             break;

  000f7	eb 05		 jmp	 SHORT $LN3@ScheduleIO
$LN11@ScheduleIO:

; 2764 :     }

  000f9	e9 69 ff ff ff	 jmp	 $LN2@ScheduleIO
$LN3@ScheduleIO:

; 2765 : 
; 2766 :     if (rc == 0)

  000fe	83 7c 24 28 00	 cmp	 DWORD PTR rc$[rsp], 0
  00103	0f 85 b2 00 00
	00		 jne	 $LN12@ScheduleIO

; 2767 :     {
; 2768 :         /* Save next I/O queue position */
; 2769 :         nextioq = ioq;

  00109	48 8b 44 24 30	 mov	 rax, QWORD PTR ioq$[rsp]
  0010e	48 89 44 24 40	 mov	 QWORD PTR nextioq$[rsp], rax

; 2770 : 
; 2771 :         /* Validate and complete sanity count of I/O queue entries */
; 2772 :         for (++count;

  00113	8b 44 24 24	 mov	 eax, DWORD PTR count$[rsp]
  00117	ff c0		 inc	 eax
  00119	89 44 24 24	 mov	 DWORD PTR count$[rsp], eax
  0011d	eb 1b		 jmp	 SHORT $LN7@ScheduleIO
$LN5@ScheduleIO:

; 2774 :              ++count, ioq = ioq->nextioq)

  0011f	8b 44 24 24	 mov	 eax, DWORD PTR count$[rsp]
  00123	ff c0		 inc	 eax
  00125	89 44 24 24	 mov	 DWORD PTR count$[rsp], eax
  00129	48 8b 44 24 30	 mov	 rax, QWORD PTR ioq$[rsp]
  0012e	48 8b 80 20 02
	00 00		 mov	 rax, QWORD PTR [rax+544]
  00135	48 89 44 24 30	 mov	 QWORD PTR ioq$[rsp], rax
$LN7@ScheduleIO:

; 2773 :              ioq;

  0013a	48 83 7c 24 30
	00		 cmp	 QWORD PTR ioq$[rsp], 0
  00140	74 19		 je	 SHORT $LN6@ScheduleIO

; 2775 :         {
; 2776 :             /* If DEVBLK already in queue, fail queueing of DEVBLK */
; 2777 :             if (ioq == dev)

  00142	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00147	48 39 44 24 30	 cmp	 QWORD PTR ioq$[rsp], rax
  0014c	75 0b		 jne	 SHORT $LN13@ScheduleIO

; 2778 :             {
; 2779 :                 rc = 2;

  0014e	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR rc$[rsp], 2

; 2780 :                 BREAK_INTO_DEBUGGER();

  00156	cc		 int	 3

; 2781 :                 break;

  00157	eb 02		 jmp	 SHORT $LN6@ScheduleIO
$LN13@ScheduleIO:

; 2782 :             }
; 2783 :         }

  00159	eb c4		 jmp	 SHORT $LN5@ScheduleIO
$LN6@ScheduleIO:

; 2784 : 
; 2785 :         /* I/O queue has been validated, insert DEVBLK into I/O queue.
; 2786 :          */
; 2787 :         if (rc == 0)

  0015b	83 7c 24 28 00	 cmp	 DWORD PTR rc$[rsp], 0
  00160	75 59		 jne	 SHORT $LN14@ScheduleIO

; 2788 :         {
; 2789 :             /* Chain our request ahead of this one */
; 2790 :             dev->nextioq = nextioq;

  00162	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00167	48 8b 4c 24 40	 mov	 rcx, QWORD PTR nextioq$[rsp]
  0016c	48 89 88 20 02
	00 00		 mov	 QWORD PTR [rax+544], rcx

; 2791 : 
; 2792 :             /* Chain previous one (if any) to ours */
; 2793 :             if (previoq != NULL)

  00173	48 83 7c 24 38
	00		 cmp	 QWORD PTR previoq$[rsp], 0
  00179	74 13		 je	 SHORT $LN15@ScheduleIO

; 2794 :                 previoq->nextioq = dev;

  0017b	48 8b 44 24 38	 mov	 rax, QWORD PTR previoq$[rsp]
  00180	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00185	48 89 88 20 02
	00 00		 mov	 QWORD PTR [rax+544], rcx
  0018c	eb 13		 jmp	 SHORT $LN16@ScheduleIO
$LN15@ScheduleIO:

; 2795 :             else
; 2796 :                 sysblk.ioq = dev;

  0018e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00195	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0019a	48 89 88 30 12
	00 00		 mov	 QWORD PTR [rax+4656], rcx
$LN16@ScheduleIO:

; 2797 : 
; 2798 :             /* Update device thread unavailable count. It will be
; 2799 :              * decremented once a thread grabs this request.
; 2800 :              */
; 2801 :             sysblk.devtunavail = count;

  001a1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001a8	8b 4c 24 24	 mov	 ecx, DWORD PTR count$[rsp]
  001ac	89 88 58 12 00
	00		 mov	 DWORD PTR [rax+4696], ecx

; 2802 : 
; 2803 :             /* Create another device thread, if needed, to service this
; 2804 :              * I/O
; 2805 :              */
; 2806 :             rc = create_device_thread();

  001b2	e8 00 00 00 00	 call	 create_device_thread
  001b7	89 44 24 28	 mov	 DWORD PTR rc$[rsp], eax
$LN14@ScheduleIO:
$LN12@ScheduleIO:

; 2807 :         }
; 2808 :     }
; 2809 : 
; 2810 :     /* Release the I/O queue lock */
; 2811 :     release_lock( &sysblk.ioqlock );

  001bb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001c2	48 05 38 12 00
	00		 add	 rax, 4664		; 00001238H
  001c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170987
  001cf	48 8b c8	 mov	 rcx, rax
  001d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2812 : 
; 2813 :     /* Return condition code */
; 2814 :     return rc;

  001d8	8b 44 24 28	 mov	 eax, DWORD PTR rc$[rsp]

; 2815 : }

  001dc	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001e0	c3		 ret	 0
ScheduleIORequest ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
i$1 = 64
rc$ = 68
tid$ = 72
ioq$2 = 80
tv89 = 88
create_device_thread PROC

; 2536 : {

  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2537 : int     rc;                             /* Return code               */
; 2538 : TID     tid;                            /* Thread ID                 */
; 2539 : 
; 2540 :     /* Ensure correct number of ioq entries tracked */
; 2541 :     {
; 2542 :         register int i;
; 2543 :         register DEVBLK  *ioq;
; 2544 : 
; 2545 :         for (ioq = sysblk.ioq, i = 0;

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	48 8b 80 30 12
	00 00		 mov	 rax, QWORD PTR [rax+4656]
  00012	48 89 44 24 50	 mov	 QWORD PTR ioq$2[rsp], rax
  00017	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  0001f	eb 1b		 jmp	 SHORT $LN4@create_dev
$LN2@create_dev:

; 2547 :              ioq = ioq->nextioq, i++);

  00021	48 8b 44 24 50	 mov	 rax, QWORD PTR ioq$2[rsp]
  00026	48 8b 80 20 02
	00 00		 mov	 rax, QWORD PTR [rax+544]
  0002d	48 89 44 24 50	 mov	 QWORD PTR ioq$2[rsp], rax
  00032	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  00036	ff c0		 inc	 eax
  00038	89 44 24 40	 mov	 DWORD PTR i$1[rsp], eax
$LN4@create_dev:

; 2546 :              ioq;

  0003c	48 83 7c 24 50
	00		 cmp	 QWORD PTR ioq$2[rsp], 0
  00042	74 02		 je	 SHORT $LN3@create_dev

; 2547 :              ioq = ioq->nextioq, i++);

  00044	eb db		 jmp	 SHORT $LN2@create_dev
$LN3@create_dev:

; 2548 :         sysblk.devtunavail = i;

  00046	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0004d	8b 4c 24 40	 mov	 ecx, DWORD PTR i$1[rsp]
  00051	89 88 58 12 00
	00		 mov	 DWORD PTR [rax+4696], ecx

; 2549 : 
; 2550 :         /* If no additional work, return */
; 2551 :         if (!i)

  00057	83 7c 24 40 00	 cmp	 DWORD PTR i$1[rsp], 0
  0005c	75 07		 jne	 SHORT $LN5@create_dev

; 2552 :             return 0;

  0005e	33 c0		 xor	 eax, eax
  00060	e9 9b 01 00 00	 jmp	 $LN1@create_dev
$LN5@create_dev:

; 2553 : 
; 2554 :     }
; 2555 : 
; 2556 :     /* If work is waiting and permitted, schedule another device     */
; 2557 :     /* thread to handle                                              */
; 2558 :     if ((sysblk.devtunavail > sysblk.devtwait &&
; 2559 :          (sysblk.devtmax == 0 || sysblk.devtnbr < sysblk.devtmax)) ||

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00073	8b 89 48 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4680]
  00079	39 88 58 12 00
	00		 cmp	 DWORD PTR [rax+4696], ecx
  0007f	7e 2c		 jle	 SHORT $LN8@create_dev
  00081	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00088	83 b8 50 12 00
	00 00		 cmp	 DWORD PTR [rax+4688], 0
  0008f	74 30		 je	 SHORT $LN7@create_dev
  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0009f	8b 89 50 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4688]
  000a5	39 88 4c 12 00
	00		 cmp	 DWORD PTR [rax+4684], ecx
  000ab	7c 14		 jl	 SHORT $LN7@create_dev
$LN8@create_dev:
  000ad	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000b4	83 b8 50 12 00
	00 00		 cmp	 DWORD PTR [rax+4688], 0
  000bb	0f 8d 20 01 00
	00		 jge	 $LN6@create_dev
$LN7@create_dev:

; 2560 :         sysblk.devtmax < 0)
; 2561 :     {
; 2562 :         rc = create_thread (&tid, DETACHED, device_thread, NULL,

  000c1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000c8	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  000ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170906
  000d5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170907
  000e1	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000e6	45 33 c9	 xor	 r9d, r9d
  000e9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:device_thread
  000f0	48 8b d0	 mov	 rdx, rax
  000f3	48 8d 4c 24 48	 lea	 rcx, QWORD PTR tid$[rsp]
  000f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  000fe	89 44 24 44	 mov	 DWORD PTR rc$[rsp], eax

; 2563 :                             "idle device thread");
; 2564 :         if (rc)

  00102	83 7c 24 44 00	 cmp	 DWORD PTR rc$[rsp], 0
  00107	74 6a		 je	 SHORT $LN9@create_dev

; 2565 :         {
; 2566 :             WRMSG (HHC00102, "E", strerror(rc));

  00109	8b 4c 24 44	 mov	 ecx, DWORD PTR rc$[rsp]
  0010d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00113	48 89 44 24 58	 mov	 QWORD PTR tv89[rsp], rax
  00118	b9 01 00 00 00	 mov	 ecx, 1
  0011d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00123	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv89[rsp]
  00128	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0012d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170909
  00134	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00139	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170910
  00140	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00145	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0014a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00150	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170911
  00157	ba 06 0a 00 00	 mov	 edx, 2566		; 00000a06H
  0015c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170912
  00163	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2567 :             return 2;

  00169	b8 02 00 00 00	 mov	 eax, 2
  0016e	e9 8d 00 00 00	 jmp	 $LN1@create_dev
$LN9@create_dev:

; 2568 :         }
; 2569 : 
; 2570 :         /* Update counters */
; 2571 :         sysblk.devtnbr++;

  00173	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0017a	8b 80 4c 12 00
	00		 mov	 eax, DWORD PTR [rax+4684]
  00180	ff c0		 inc	 eax
  00182	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00189	89 81 4c 12 00
	00		 mov	 DWORD PTR [rcx+4684], eax

; 2572 :         sysblk.devtwait++;

  0018f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00196	8b 80 48 12 00
	00		 mov	 eax, DWORD PTR [rax+4680]
  0019c	ff c0		 inc	 eax
  0019e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001a5	89 81 48 12 00
	00		 mov	 DWORD PTR [rcx+4680], eax

; 2573 :         if (sysblk.devtnbr > sysblk.devthwm)

  001ab	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001b2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001b9	8b 89 54 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4692]
  001bf	39 88 4c 12 00
	00		 cmp	 DWORD PTR [rax+4684], ecx
  001c5	7e 1a		 jle	 SHORT $LN10@create_dev

; 2574 :             sysblk.devthwm = sysblk.devtnbr;

  001c7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001ce	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001d5	8b 89 4c 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4684]
  001db	89 88 54 12 00
	00		 mov	 DWORD PTR [rax+4692], ecx
$LN10@create_dev:
$LN6@create_dev:

; 2575 :     }
; 2576 : 
; 2577 :     /* Signal possible waiting I/O threads */
; 2578 :     signal_condition(&sysblk.ioqcond);

  001e1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001e8	48 05 40 12 00
	00		 add	 rax, 4672		; 00001240H
  001ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170914
  001f5	48 8b c8	 mov	 rcx, rax
  001f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 2579 : 
; 2580 :     return 0;

  001fe	33 c0		 xor	 eax, eax
$LN1@create_dev:

; 2581 : }

  00200	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00204	c3		 ret	 0
create_device_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
group$1 = 32
dev$ = 64
device_reset PROC

; 2319 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2320 :     obtain_lock (&dev->lock);

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0000f	48 83 c0 38	 add	 rax, 56			; 00000038H
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170818
  0001a	48 8b c8	 mov	 rcx, rax
  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2321 : 
; 2322 :     if (dev->group)

  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00028	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0002d	74 3d		 je	 SHORT $LN2@device_res

; 2323 :     {
; 2324 :         DEVGRP* group = dev->group;

  0002f	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00034	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00038	48 89 44 24 20	 mov	 QWORD PTR group$1[rsp], rax

; 2325 :         if (group->members != group->acount)

  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR group$1[rsp]
  00042	48 8b 4c 24 20	 mov	 rcx, QWORD PTR group$1[rsp]
  00047	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  0004a	39 08		 cmp	 DWORD PTR [rax], ecx
  0004c	74 1e		 je	 SHORT $LN3@device_res

; 2326 :         {
; 2327 :             /* Group is incomplete; ignore */
; 2328 :             release_lock (&dev->lock);

  0004e	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00053	48 83 c0 38	 add	 rax, 56			; 00000038H
  00057	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170821
  0005e	48 8b c8	 mov	 rcx, rax
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2329 :             return;

  00067	e9 17 05 00 00	 jmp	 $LN1@device_res
$LN3@device_res:
$LN2@device_res:

; 2330 :         }
; 2331 :     }
; 2332 : 
; 2333 :     obtain_lock(&sysblk.iointqlk);

  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00073	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  00079	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170822
  00080	48 8b c8	 mov	 rcx, rax
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2334 :     DEQUEUE_IO_INTERRUPT_QLOCKED(&dev->ioint);

  00089	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0008e	48 05 28 02 00
	00		 add	 rax, 552		; 00000228H
  00094	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170823
  0009b	48 8b c8	 mov	 rcx, rax
  0009e	e8 00 00 00 00	 call	 Dequeue_IO_Interrupt_QLocked

; 2335 :     DEQUEUE_IO_INTERRUPT_QLOCKED(&dev->pciioint);

  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000a8	48 05 40 02 00
	00		 add	 rax, 576		; 00000240H
  000ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170824
  000b5	48 8b c8	 mov	 rcx, rax
  000b8	e8 00 00 00 00	 call	 Dequeue_IO_Interrupt_QLocked

; 2336 :     DEQUEUE_IO_INTERRUPT_QLOCKED(&dev->attnioint);

  000bd	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000c2	48 05 58 02 00
	00		 add	 rax, 600		; 00000258H
  000c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170825
  000cf	48 8b c8	 mov	 rcx, rax
  000d2	e8 00 00 00 00	 call	 Dequeue_IO_Interrupt_QLocked

; 2337 :     release_lock(&sysblk.iointqlk);

  000d7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000de	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  000e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170826
  000eb	48 8b c8	 mov	 rcx, rax
  000ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2338 : 
; 2339 :     clear_subchannel_busy(dev);

  000f4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000f9	e8 00 00 00 00	 call	 clear_subchannel_busy

; 2340 : 
; 2341 :     dev->reserved = dev->pending = dev->pcipending =

  000fe	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00103	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00109	0f ba f0 19	 btr	 eax, 25
  0010d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00112	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
  00118	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0011d	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00123	0f ba f0 18	 btr	 eax, 24
  00127	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0012c	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
  00132	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00137	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0013d	0f ba f0 17	 btr	 eax, 23
  00141	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00146	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
  0014c	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00151	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00157	0f ba f0 16	 btr	 eax, 22
  0015b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00160	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
  00166	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0016b	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00171	0f ba f0 14	 btr	 eax, 20
  00175	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0017a	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 2342 :     dev->attnpending = dev->startpending = 0;
; 2343 : #if defined( OPTION_SHARED_DEVICES )
; 2344 :     dev->shioactive = DEV_SYS_NONE;

  00180	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00185	c7 80 e4 05 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1508], 0

; 2345 : #endif // defined( OPTION_SHARED_DEVICES )
; 2346 :     if (dev->suspended)

  0018f	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00194	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0019a	c1 e8 15	 shr	 eax, 21
  0019d	83 e0 01	 and	 eax, 1
  001a0	85 c0		 test	 eax, eax
  001a2	74 26		 je	 SHORT $LN4@device_res

; 2347 :     {
; 2348 :         dev->suspended = 0;

  001a4	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  001a9	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001af	0f ba f0 15	 btr	 eax, 21
  001b3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  001b8	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 2349 :         schedule_ioq(NULL, dev);

  001be	48 8b 54 24 40	 mov	 rdx, QWORD PTR dev$[rsp]
  001c3	33 c9		 xor	 ecx, ecx
  001c5	e8 00 00 00 00	 call	 schedule_ioq
$LN4@device_res:

; 2350 :     }
; 2351 : #if defined( OPTION_SHARED_DEVICES )
; 2352 :     if (dev->shiowaiters)

  001ca	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  001cf	83 b8 e0 05 00
	00 00		 cmp	 DWORD PTR [rax+1504], 0
  001d6	74 1b		 je	 SHORT $LN5@device_res

; 2353 :         signal_condition (&dev->shiocond);

  001d8	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  001dd	48 05 d8 05 00
	00		 add	 rax, 1496		; 000005d8H
  001e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170829
  001ea	48 8b c8	 mov	 rcx, rax
  001ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN5@device_res:

; 2354 : #endif // defined( OPTION_SHARED_DEVICES )
; 2355 :     store_fw (dev->pmcw.intparm, 0);

  001f3	33 c9		 xor	 ecx, ecx
  001f5	e8 00 00 00 00	 call	 _byteswap_ulong
  001fa	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  001ff	48 81 c1 ec 02
	00 00		 add	 rcx, 748		; 000002ecH
  00206	8b d0		 mov	 edx, eax
  00208	e8 00 00 00 00	 call	 store_fw_noswap

; 2356 :     dev->pmcw.flag4 &= ~PMCW4_ISC;

  0020d	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00212	0f b6 80 f0 02
	00 00		 movzx	 eax, BYTE PTR [rax+752]
  00219	83 e0 c7	 and	 eax, -57		; ffffffffffffffc7H
  0021c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00221	88 81 f0 02 00
	00		 mov	 BYTE PTR [rcx+752], al

; 2357 :     dev->pmcw.flag5 &= ~(PMCW5_E | PMCW5_LM | PMCW5_MM | PMCW5_D);

  00227	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0022c	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00233	25 03 ff ff ff	 and	 eax, -253		; ffffffffffffff03H
  00238	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0023d	88 81 f1 02 00
	00		 mov	 BYTE PTR [rcx+753], al

; 2358 :     dev->pmcw.pnom = 0;

  00243	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00248	c6 80 f5 02 00
	00 00		 mov	 BYTE PTR [rax+757], 0

; 2359 :     dev->pmcw.lpum = 0;

  0024f	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00254	c6 80 f6 02 00
	00 00		 mov	 BYTE PTR [rax+758], 0

; 2360 :     store_hw (dev->pmcw.mbi, 0);

  0025b	33 c9		 xor	 ecx, ecx
  0025d	e8 00 00 00 00	 call	 _byteswap_ushort
  00262	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00267	48 81 c1 f8 02
	00 00		 add	 rcx, 760		; 000002f8H
  0026e	0f b7 d0	 movzx	 edx, ax
  00271	e8 00 00 00 00	 call	 store_hw_noswap

; 2361 :     dev->pmcw.flag27 &= ~PMCW27_S;

  00276	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0027b	0f b6 80 07 03
	00 00		 movzx	 eax, BYTE PTR [rax+775]
  00282	83 e0 fe	 and	 eax, -2
  00285	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0028a	88 81 07 03 00
	00		 mov	 BYTE PTR [rcx+775], al

; 2362 : #if defined(_FEATURE_IO_ASSIST)
; 2363 :     dev->pmcw.zone = 0;

  00290	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00295	c6 80 04 03 00
	00 00		 mov	 BYTE PTR [rax+772], 0

; 2364 :     dev->pmcw.flag25 &= ~PMCW25_VISC;

  0029c	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  002a1	0f b6 80 05 03
	00 00		 movzx	 eax, BYTE PTR [rax+773]
  002a8	83 e0 f8	 and	 eax, -8
  002ab	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  002b0	88 81 05 03 00
	00		 mov	 BYTE PTR [rcx+773], al

; 2365 :     dev->pmcw.flag27 &= ~PMCW27_I;

  002b6	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  002bb	0f b6 80 07 03
	00 00		 movzx	 eax, BYTE PTR [rax+775]
  002c2	0f ba f0 07	 btr	 eax, 7
  002c6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  002cb	88 81 07 03 00
	00		 mov	 BYTE PTR [rcx+775], al

; 2366 : #endif
; 2367 :     memset (&dev->scsw, 0, sizeof(SCSW));

  002d1	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  002d6	48 05 08 03 00
	00		 add	 rax, 776		; 00000308H
  002dc	48 8b f8	 mov	 rdi, rax
  002df	33 c0		 xor	 eax, eax
  002e1	b9 0c 00 00 00	 mov	 ecx, 12
  002e6	f3 aa		 rep stosb

; 2368 :     memset (&dev->pciscsw, 0, sizeof(SCSW));

  002e8	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  002ed	48 05 14 03 00
	00		 add	 rax, 788		; 00000314H
  002f3	48 8b f8	 mov	 rdi, rax
  002f6	33 c0		 xor	 eax, eax
  002f8	b9 0c 00 00 00	 mov	 ecx, 12
  002fd	f3 aa		 rep stosb

; 2369 :     memset (&dev->attnscsw, 0, sizeof(SCSW));

  002ff	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00304	48 05 20 03 00
	00		 add	 rax, 800		; 00000320H
  0030a	48 8b f8	 mov	 rdi, rax
  0030d	33 c0		 xor	 eax, eax
  0030f	b9 0c 00 00 00	 mov	 ecx, 12
  00314	f3 aa		 rep stosb

; 2370 : 
; 2371 :     dev->readpending = 0;

  00316	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0031b	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00321	25 3f ff ff ff	 and	 eax, -193		; ffffff3fH
  00326	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0032b	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 2372 :     dev->ckdxtdef = 0;

  00331	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00336	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0033c	83 e0 fd	 and	 eax, -3			; fffffffdH
  0033f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00344	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 2373 :     dev->ckdsetfm = 0;

  0034a	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0034f	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00355	83 e0 fb	 and	 eax, -5			; fffffffbH
  00358	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0035d	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 2374 :     dev->ckdlcount = 0;

  00363	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00368	c6 80 02 13 00
	00 00		 mov	 BYTE PTR [rax+4866], 0

; 2375 :     dev->ckdssi = 0;

  0036f	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00374	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0037a	0f ba f0 10	 btr	 eax, 16
  0037e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00383	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 2376 :     memset (dev->sense, 0, sizeof(dev->sense));

  00389	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0038e	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  00394	48 8b f8	 mov	 rdi, rax
  00397	33 c0		 xor	 eax, eax
  00399	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0039e	f3 aa		 rep stosb

; 2377 :     dev->sns_pending = 0;

  003a0	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  003a5	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  003ab	83 e0 fb	 and	 eax, -5			; fffffffbH
  003ae	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  003b3	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax

; 2378 :     memset (dev->pgid, 0, sizeof(dev->pgid));

  003b9	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  003be	48 05 ad 05 00
	00		 add	 rax, 1453		; 000005adH
  003c4	48 8b f8	 mov	 rdi, rax
  003c7	33 c0		 xor	 eax, eax
  003c9	b9 0b 00 00 00	 mov	 ecx, 11
  003ce	f3 aa		 rep stosb

; 2379 :     /* By Adrian - Reset drive password */
; 2380 :     memset (dev->drvpwd, 0, sizeof(dev->drvpwd));

  003d0	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  003d5	48 05 e8 05 00
	00		 add	 rax, 1512		; 000005e8H
  003db	48 8b f8	 mov	 rdi, rax
  003de	33 c0		 xor	 eax, eax
  003e0	b9 0b 00 00 00	 mov	 ecx, 11
  003e5	f3 aa		 rep stosb

; 2381 : 
; 2382 :     dev->mainstor = sysblk.mainstor;

  003e7	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  003ec	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  003f3	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  003fa	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 2383 :     dev->storkeys = sysblk.storkeys;

  00401	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00406	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0040d	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00414	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 2384 :     dev->mainlim = sysblk.mainsize - 1;

  0041b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00422	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00429	48 ff c8	 dec	 rax
  0042c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00431	48 89 81 90 00
	00 00		 mov	 QWORD PTR [rcx+144], rax

; 2385 : 
; 2386 :     dev->s370start = 0;

  00438	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0043d	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00443	83 e0 fd	 and	 eax, -3			; fffffffdH
  00446	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0044b	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 2387 : 
; 2388 :     dev->pending = 0;

  00451	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00456	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0045c	0f ba f0 16	 btr	 eax, 22
  00460	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00465	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 2389 :     dev->ioint.dev = dev;

  0046b	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00470	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00475	48 89 88 30 02
	00 00		 mov	 QWORD PTR [rax+560], rcx

; 2390 :     dev->ioint.pending = 1;

  0047c	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00481	8b 80 3c 02 00
	00		 mov	 eax, DWORD PTR [rax+572]
  00487	83 c8 01	 or	 eax, 1
  0048a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0048f	89 81 3c 02 00
	00		 mov	 DWORD PTR [rcx+572], eax

; 2391 :     dev->pciioint.dev = dev;

  00495	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0049a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0049f	48 89 88 48 02
	00 00		 mov	 QWORD PTR [rax+584], rcx

; 2392 :     dev->pciioint.pcipending = 1;

  004a6	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  004ab	8b 80 54 02 00
	00		 mov	 eax, DWORD PTR [rax+596]
  004b1	83 c8 02	 or	 eax, 2
  004b4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  004b9	89 81 54 02 00
	00		 mov	 DWORD PTR [rcx+596], eax

; 2393 :     dev->attnioint.dev = dev;

  004bf	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  004c4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  004c9	48 89 88 60 02
	00 00		 mov	 QWORD PTR [rax+608], rcx

; 2394 :     dev->attnioint.attnpending = 1;

  004d0	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  004d5	8b 80 6c 02 00
	00		 mov	 eax, DWORD PTR [rax+620]
  004db	83 c8 04	 or	 eax, 4
  004de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  004e3	89 81 6c 02 00
	00		 mov	 DWORD PTR [rcx+620], eax

; 2395 :     dev->tschpending = 0;

  004e9	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  004ee	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  004f4	0f ba f0 1b	 btr	 eax, 27
  004f8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  004fd	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 2396 : 
; 2397 : #if defined(FEATURE_VM_BLOCKIO)
; 2398 :     if (dev->vmd250env)

  00503	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00508	48 83 b8 18 06
	00 00 00	 cmp	 QWORD PTR [rax+1560], 0
  00510	74 22		 je	 SHORT $LN6@device_res

; 2399 :     {
; 2400 :        free(dev->vmd250env);

  00512	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00517	48 8b 88 18 06
	00 00		 mov	 rcx, QWORD PTR [rax+1560]
  0051e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2401 :        dev->vmd250env = 0 ;

  00524	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00529	48 c7 80 18 06
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1560], 0
$LN6@device_res:

; 2402 :     }
; 2403 : #endif /* defined(FEATURE_VM_BLOCKIO) */
; 2404 : 
; 2405 :     if (dev->hnd && dev->hnd->halt)

  00534	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00539	48 83 b8 90 02
	00 00 00	 cmp	 QWORD PTR [rax+656], 0
  00541	74 27		 je	 SHORT $LN7@device_res
  00543	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00548	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0054f	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  00554	74 14		 je	 SHORT $LN7@device_res

; 2406 :         dev->hnd->halt(dev);

  00556	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0055b	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00562	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00567	ff 50 48	 call	 QWORD PTR [rax+72]
$LN7@device_res:

; 2407 : 
; 2408 :     release_lock (&dev->lock);

  0056a	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0056f	48 83 c0 38	 add	 rax, 56			; 00000038H
  00573	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170832
  0057a	48 8b c8	 mov	 rcx, rax
  0057d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN1@device_res:

; 2409 : } /* end device_reset() */

  00583	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00587	5f		 pop	 rdi
  00588	c3		 ret	 0
device_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
dev$ = 48
perform_halt PROC

; 2086 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2087 :     OBTAIN_INTLOCK(NULL);

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170732
  00010	33 c9		 xor	 ecx, ecx
  00012	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 2088 :     obtain_lock(&dev->lock);

  00017	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0001c	48 83 c0 38	 add	 rax, 56			; 00000038H
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170733
  00027	48 8b c8	 mov	 rcx, rax
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2089 :     perform_halt_and_release_lock(dev);

  00030	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00035	e8 00 00 00 00	 call	 perform_halt_and_release_lock

; 2090 :     RELEASE_INTLOCK(NULL);

  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170734
  00041	33 c9		 xor	 ecx, ecx
  00043	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 2091 : }

  00048	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004c	c3		 ret	 0
perform_halt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv137 = 80
tv178 = 84
tv184 = 88
dev$ = 112
perform_halt_and_release_lock PROC

; 1996 : {

$LN25:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1997 :     /* If status incomplete,
; 1998 :      * [15.4.2] Perform halt function signaling
; 1999 :      */
; 2000 :     if (!(dev->scsw.flag3 & (SCSW3_SC_PRI | SCSW3_SC_SEC) &&

  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00015	83 e0 06	 and	 eax, 6
  00018	85 c0		 test	 eax, eax
  0001a	74 17		 je	 SHORT $LN5@perform_ha
  0001c	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00021	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00028	83 e0 01	 and	 eax, 1
  0002b	85 c0		 test	 eax, eax
  0002d	0f 85 73 01 00
	00		 jne	 $LN4@perform_ha
$LN5@perform_ha:

; 2001 :           dev->scsw.flag3 & SCSW3_SC_PEND))
; 2002 :     {
; 2003 :         /* Indicate HALT started */
; 2004 :         set_subchannel_busy(dev);

  00033	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00038	e8 00 00 00 00	 call	 set_subchannel_busy

; 2005 :         dev->scsw.flag2 |= SCSW2_FC_HALT;

  0003d	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00042	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00049	83 c8 20	 or	 eax, 32			; 00000020H
  0004c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00051	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 2006 :         dev->scsw.flag2 &= ~SCSW2_AC_HALT;

  00057	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0005c	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00063	83 e0 fd	 and	 eax, -3
  00066	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0006b	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 2007 : 
; 2008 :         /* If intermediate status pending with subchannel and device
; 2009 :          * active, reset intermediate status pending (HSCH, fifth
; 2010 :          * paragraph).
; 2011 :          */
; 2012 :         if ((dev->scsw.flag3 &
; 2013 :              (SCSW3_AC_SCHAC | SCSW3_AC_DEVAC | SCSW3_SC_INTER | SCSW3_SC_PEND)) ==

  00071	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00076	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  0007d	25 c9 00 00 00	 and	 eax, 201		; 000000c9H
  00082	3d c9 00 00 00	 cmp	 eax, 201		; 000000c9H
  00087	75 1a		 jne	 SHORT $LN6@perform_ha

; 2014 :              (SCSW3_AC_SCHAC | SCSW3_AC_DEVAC | SCSW3_SC_INTER | SCSW3_SC_PEND))
; 2015 :             dev->scsw.flag3 &= ~(SCSW3_SC_INTER | SCSW3_SC_PEND);

  00089	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0008e	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00095	83 e0 f6	 and	 eax, -10
  00098	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0009d	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al
$LN6@perform_ha:

; 2016 : 
; 2017 :         /* Interim post-facto check for missing deferred condition code
; 2018 :          * Based on the Deferred-Condition-Code Meaning for Status-
; 2019 :          * Pending Subchannel (Figure 16-5).
; 2020 :          */
; 2021 :         if (!(dev->scsw.flag0 & SCSW0_CC) &&

  000a3	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000a8	0f b6 80 08 03
	00 00		 movzx	 eax, BYTE PTR [rax+776]
  000af	83 e0 03	 and	 eax, 3
  000b2	85 c0		 test	 eax, eax
  000b4	0f 85 ab 00 00
	00		 jne	 $LN7@perform_ha
  000ba	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000bf	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  000c6	83 e0 4c	 and	 eax, 76			; 0000004cH
  000c9	85 c0		 test	 eax, eax
  000cb	0f 84 94 00 00
	00		 je	 $LN7@perform_ha

; 2022 :              (dev->scsw.flag2 & (SCSW2_FC_START |
; 2023 :                                  SCSW2_AC_RESUM |
; 2024 :                                  SCSW2_AC_START)))
; 2025 :         {
; 2026 :             switch (AIPSX(&dev->scsw) & 0x0F)

  000d1	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000d6	48 05 08 03 00
	00		 add	 rax, 776		; 00000308H
  000dc	48 8b c8	 mov	 rcx, rax
  000df	e8 00 00 00 00	 call	 AIPSX
  000e4	0f b6 c0	 movzx	 eax, al
  000e7	83 e0 0f	 and	 eax, 15
  000ea	89 44 24 50	 mov	 DWORD PTR tv137[rsp], eax
  000ee	8b 44 24 50	 mov	 eax, DWORD PTR tv137[rsp]
  000f2	ff c8		 dec	 eax
  000f4	89 44 24 50	 mov	 DWORD PTR tv137[rsp], eax
  000f8	83 7c 24 50 0e	 cmp	 DWORD PTR tv137[rsp], 14
  000fd	77 66		 ja	 SHORT $LN2@perform_ha
  000ff	48 63 44 24 50	 movsxd	 rax, DWORD PTR tv137[rsp]
  00104	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0010b	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN24@perform_ha[rcx+rax*4]
  00112	48 03 c1	 add	 rax, rcx
  00115	ff e0		 jmp	 rax
$LN8@perform_ha:
$LN9@perform_ha:
$LN10@perform_ha:
$LN11@perform_ha:
$LN12@perform_ha:
$LN13@perform_ha:
$LN14@perform_ha:

; 2027 :             {
; 2028 :                 case 0x0F:
; 2029 :                 case 0x0D:
; 2030 :                 case 0x09:
; 2031 :                 case 0x07:
; 2032 :                 case 0x05:
; 2033 :                 case 0x03:
; 2034 :                 case 0x01:
; 2035 :                     dev->scsw.flag0 &= ~SCSW0_CC;

  00117	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0011c	0f b6 80 08 03
	00 00		 movzx	 eax, BYTE PTR [rax+776]
  00123	83 e0 fc	 and	 eax, -4
  00126	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0012b	88 81 08 03 00
	00		 mov	 BYTE PTR [rcx+776], al

; 2036 :                     dev->scsw.flag1 &= ~SCSW1_Z;

  00131	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00136	0f b6 80 09 03
	00 00		 movzx	 eax, BYTE PTR [rax+777]
  0013d	83 e0 fb	 and	 eax, -5
  00140	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00145	88 81 09 03 00
	00		 mov	 BYTE PTR [rcx+777], al

; 2037 :                     dev->scsw.flag0 |=  SCSW0_CC_1;

  0014b	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00150	0f b6 80 08 03
	00 00		 movzx	 eax, BYTE PTR [rax+776]
  00157	83 c8 01	 or	 eax, 1
  0015a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0015f	88 81 08 03 00
	00		 mov	 BYTE PTR [rcx+776], al
$LN2@perform_ha:
$LN7@perform_ha:

; 2038 :                     break;
; 2039 :             }
; 2040 :         }
; 2041 : 
; 2042 :         /* Invoke the provided halt device routine if it has been
; 2043 :          * provided by the handler code at init; SCSW has not yet been
; 2044 :          * reset to permit device handlers to see HALT condition.
; 2045 :          */
; 2046 :         if (dev->hnd->halt != NULL)

  00165	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0016a	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00171	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  00176	74 14		 je	 SHORT $LN15@perform_ha

; 2047 :             dev->hnd->halt( dev );

  00178	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0017d	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00184	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00189	ff 50 48	 call	 QWORD PTR [rax+72]
$LN15@perform_ha:

; 2048 : 
; 2049 :         /* Mark pending interrupt */
; 2050 :         dev->scsw.flag3 |= SCSW3_SC_PEND;

  0018c	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00191	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00198	83 c8 01	 or	 eax, 1
  0019b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  001a0	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al
$LN4@perform_ha:

; 2051 :     }
; 2052 : 
; 2053 :     /* Trace HALT */
; 2054 :     if (dev->ccwtrace)

  001a6	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  001ab	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001b1	c1 e8 0f	 shr	 eax, 15
  001b4	83 e0 01	 and	 eax, 1
  001b7	85 c0		 test	 eax, eax
  001b9	0f 84 c3 00 00
	00		 je	 $LN16@perform_ha

; 2055 :     {
; 2056 :         if (sysblk.traceFILE)

  001bf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001c6	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  001ce	74 12		 je	 SHORT $LN17@perform_ha

; 2057 :             tf_1300( dev, 0 );

  001d0	33 d2		 xor	 edx, edx
  001d2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  001d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1300
  001dd	e9 a0 00 00 00	 jmp	 $LN18@perform_ha
$LN17@perform_ha:

; 2058 :         else
; 2059 :             // "%1d:%04X CHAN: halt subchannel: cc=%d"
; 2060 :             WRMSG( HHC01300, "I", LCSS_DEVNUM, 0 );

  001e2	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  001e8	74 0f		 je	 SHORT $LN20@perform_ha
  001ea	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  001ef	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001f3	89 44 24 54	 mov	 DWORD PTR tv178[rsp], eax
  001f7	eb 08		 jmp	 SHORT $LN21@perform_ha
$LN20@perform_ha:
  001f9	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv178[rsp], 0
$LN21@perform_ha:
  00201	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00207	74 11		 je	 SHORT $LN22@perform_ha
  00209	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0020e	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00212	d1 f8		 sar	 eax, 1
  00214	89 44 24 58	 mov	 DWORD PTR tv184[rsp], eax
  00218	eb 08		 jmp	 SHORT $LN23@perform_ha
$LN22@perform_ha:
  0021a	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv184[rsp], 0
$LN23@perform_ha:
  00222	b9 01 00 00 00	 mov	 ecx, 1
  00227	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0022d	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  00236	8b 4c 24 54	 mov	 ecx, DWORD PTR tv178[rsp]
  0023a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0023e	8b 4c 24 58	 mov	 ecx, DWORD PTR tv184[rsp]
  00242	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00246	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170721
  0024d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00252	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170722
  00259	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0025e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00263	41 b9 03 00 00
	00		 mov	 r9d, 3
  00269	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170723
  00270	ba 0c 08 00 00	 mov	 edx, 2060		; 0000080cH
  00275	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170724
  0027c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN18@perform_ha:
$LN16@perform_ha:

; 2061 :     }
; 2062 : 
; 2063 :     /* Queue pending I/O interrupt and update status */
; 2064 :     queue_io_interrupt_and_update_status_locked(dev,TRUE);

  00282	ba 01 00 00 00	 mov	 edx, 1
  00287	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0028c	e8 00 00 00 00	 call	 queue_io_interrupt_and_update_status_locked

; 2065 : 
; 2066 :     release_lock(&dev->lock);

  00291	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00296	48 83 c0 38	 add	 rax, 56			; 00000038H
  0029a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170725
  002a1	48 8b c8	 mov	 rcx, rax
  002a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2067 : }

  002aa	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002ae	c3		 ret	 0
  002af	90		 npad	 1
$LN24@perform_ha:
  002b0	00 00 00 00	 DD	 $LN14@perform_ha
  002b4	00 00 00 00	 DD	 $LN2@perform_ha
  002b8	00 00 00 00	 DD	 $LN13@perform_ha
  002bc	00 00 00 00	 DD	 $LN2@perform_ha
  002c0	00 00 00 00	 DD	 $LN12@perform_ha
  002c4	00 00 00 00	 DD	 $LN2@perform_ha
  002c8	00 00 00 00	 DD	 $LN11@perform_ha
  002cc	00 00 00 00	 DD	 $LN2@perform_ha
  002d0	00 00 00 00	 DD	 $LN10@perform_ha
  002d4	00 00 00 00	 DD	 $LN2@perform_ha
  002d8	00 00 00 00	 DD	 $LN2@perform_ha
  002dc	00 00 00 00	 DD	 $LN2@perform_ha
  002e0	00 00 00 00	 DD	 $LN9@perform_ha
  002e4	00 00 00 00	 DD	 $LN2@perform_ha
  002e8	00 00 00 00	 DD	 $LN8@perform_ha
perform_halt_and_release_lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv185 = 80
tv191 = 84
dev$ = 112
perform_clear_subchan PROC

; 1826 : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1827 :     /* Dequeue pending interrupts */
; 1828 :     obtain_lock(&sysblk.iointqlk);

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00010	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170644
  0001d	48 8b c8	 mov	 rcx, rax
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1829 :     DEQUEUE_IO_INTERRUPT_QLOCKED(&dev->ioint);

  00026	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0002b	48 05 28 02 00
	00		 add	 rax, 552		; 00000228H
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170645
  00038	48 8b c8	 mov	 rcx, rax
  0003b	e8 00 00 00 00	 call	 Dequeue_IO_Interrupt_QLocked

; 1830 :     dev->scsw.flag3 &= ~SCSW3_SC_PEND;

  00040	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00045	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  0004c	83 e0 fe	 and	 eax, -2
  0004f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00054	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 1831 :     dev->pending = 0;

  0005a	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0005f	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00065	0f ba f0 16	 btr	 eax, 22
  00069	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0006e	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 1832 :     clear_device_busy(dev);

  00074	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00079	e8 00 00 00 00	 call	 clear_device_busy

; 1833 :     clear_subchannel_busy(dev);

  0007e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00083	e8 00 00 00 00	 call	 clear_subchannel_busy

; 1834 :     DEQUEUE_IO_INTERRUPT_QLOCKED(&dev->pciioint);

  00088	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0008d	48 05 40 02 00
	00		 add	 rax, 576		; 00000240H
  00093	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170646
  0009a	48 8b c8	 mov	 rcx, rax
  0009d	e8 00 00 00 00	 call	 Dequeue_IO_Interrupt_QLocked

; 1835 :     dev->pciscsw.flag3 &= ~SCSW3_SC_PEND;

  000a2	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000a7	0f b6 80 17 03
	00 00		 movzx	 eax, BYTE PTR [rax+791]
  000ae	83 e0 fe	 and	 eax, -2
  000b1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  000b6	88 81 17 03 00
	00		 mov	 BYTE PTR [rcx+791], al

; 1836 :     dev->pcipending = 0;

  000bc	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000c1	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000c7	0f ba f0 17	 btr	 eax, 23
  000cb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  000d0	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 1837 :     clear_subchannel_busy_scsw(&dev->pciscsw);

  000d6	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000db	48 05 14 03 00
	00		 add	 rax, 788		; 00000314H
  000e1	48 8b c8	 mov	 rcx, rax
  000e4	e8 00 00 00 00	 call	 clear_subchannel_busy_scsw

; 1838 :     DEQUEUE_IO_INTERRUPT_QLOCKED(&dev->attnioint);

  000e9	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000ee	48 05 58 02 00
	00		 add	 rax, 600		; 00000258H
  000f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170647
  000fb	48 8b c8	 mov	 rcx, rax
  000fe	e8 00 00 00 00	 call	 Dequeue_IO_Interrupt_QLocked

; 1839 :     dev->attnscsw.flag3 &= ~SCSW3_SC_PEND;

  00103	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00108	0f b6 80 23 03
	00 00		 movzx	 eax, BYTE PTR [rax+803]
  0010f	83 e0 fe	 and	 eax, -2
  00112	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00117	88 81 23 03 00
	00		 mov	 BYTE PTR [rcx+803], al

; 1840 :     dev->attnpending = 0;

  0011d	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00122	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00128	0f ba f0 18	 btr	 eax, 24
  0012c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00131	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 1841 :     dev->tschpending = 0;

  00137	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0013c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00142	0f ba f0 1b	 btr	 eax, 27
  00146	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0014b	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 1842 : 
; 1843 :     /* [15.3.2] Perform clear function subchannel modification */
; 1844 :     dev->pmcw.pom = 0xFF;

  00151	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00156	c6 80 fa 02 00
	00 ff		 mov	 BYTE PTR [rax+762], 255	; 000000ffH

; 1845 :     dev->pmcw.lpum = 0x00;

  0015d	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00162	c6 80 f6 02 00
	00 00		 mov	 BYTE PTR [rax+758], 0

; 1846 :     dev->pmcw.pnom = 0x00;

  00169	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0016e	c6 80 f5 02 00
	00 00		 mov	 BYTE PTR [rax+757], 0

; 1847 : 
; 1848 :     /* [15.3.3] Perform clear function signaling and completion */
; 1849 :     dev->scsw.flag0 = 0;

  00175	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0017a	c6 80 08 03 00
	00 00		 mov	 BYTE PTR [rax+776], 0

; 1850 :     dev->scsw.flag1 = 0;

  00181	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00186	c6 80 09 03 00
	00 00		 mov	 BYTE PTR [rax+777], 0

; 1851 :     dev->scsw.flag2 &= ~(SCSW2_FC | SCSW2_AC);

  0018d	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00192	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00199	83 e0 80	 and	 eax, -128		; ffffffffffffff80H
  0019c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  001a1	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 1852 :     dev->scsw.flag2 |= SCSW2_FC_CLEAR;

  001a7	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  001ac	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  001b3	83 c8 10	 or	 eax, 16
  001b6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  001bb	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 1853 :     /* Shortcut setting of flag3 due to clear and setting of just the
; 1854 :      * status pending flag:
; 1855 :      *   scsw.flag3 &= ~(SCSW3_AC | SCSW3_SC);
; 1856 :      *   scsw.flag3 |= SCSW3_SC_PEND;
; 1857 :      */
; 1858 :     dev->scsw.flag3 = SCSW3_SC_PEND;

  001c1	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  001c6	c6 80 0b 03 00
	00 01		 mov	 BYTE PTR [rax+779], 1

; 1859 :     store_fw (dev->scsw.ccwaddr, 0);

  001cd	33 c9		 xor	 ecx, ecx
  001cf	e8 00 00 00 00	 call	 _byteswap_ulong
  001d4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  001d9	48 81 c1 0c 03
	00 00		 add	 rcx, 780		; 0000030cH
  001e0	8b d0		 mov	 edx, eax
  001e2	e8 00 00 00 00	 call	 store_fw_noswap

; 1860 :     dev->scsw.chanstat = 0;

  001e7	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  001ec	c6 80 11 03 00
	00 00		 mov	 BYTE PTR [rax+785], 0

; 1861 :     dev->scsw.unitstat = 0;

  001f3	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  001f8	c6 80 10 03 00
	00 00		 mov	 BYTE PTR [rax+784], 0

; 1862 :     store_hw (dev->scsw.count, 0);

  001ff	33 c9		 xor	 ecx, ecx
  00201	e8 00 00 00 00	 call	 _byteswap_ushort
  00206	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0020b	48 81 c1 12 03
	00 00		 add	 rcx, 786		; 00000312H
  00212	0f b7 d0	 movzx	 edx, ax
  00215	e8 00 00 00 00	 call	 store_hw_noswap

; 1863 : 
; 1864 :     /* Queue the pending interrupt and update status */
; 1865 :     QUEUE_IO_INTERRUPT_QLOCKED(&dev->ioint,TRUE);

  0021a	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0021f	48 05 28 02 00
	00		 add	 rax, 552		; 00000228H
  00225	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170648
  0022c	b2 01		 mov	 dl, 1
  0022e	48 8b c8	 mov	 rcx, rax
  00231	e8 00 00 00 00	 call	 Queue_IO_Interrupt_QLocked

; 1866 :     subchannel_interrupt_queue_cleanup(dev);

  00236	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0023b	e8 00 00 00 00	 call	 subchannel_interrupt_queue_cleanup

; 1867 :     UPDATE_IC_IOPENDING_QLOCKED();

  00240	e8 00 00 00 00	 call	 Update_IC_IOPENDING_QLocked

; 1868 :     release_lock(&sysblk.iointqlk);

  00245	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0024c	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  00252	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170649
  00259	48 8b c8	 mov	 rcx, rax
  0025c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1869 : 
; 1870 :     if (dev->ccwtrace)

  00262	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00267	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0026d	c1 e8 0f	 shr	 eax, 15
  00270	83 e0 01	 and	 eax, 1
  00273	85 c0		 test	 eax, eax
  00275	0f 84 b8 00 00
	00		 je	 $LN2@perform_cl

; 1871 :     {
; 1872 :         if (sysblk.traceFILE)

  0027b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00282	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  0028a	74 10		 je	 SHORT $LN3@perform_cl

; 1873 :             tf_1308( dev );

  0028c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00291	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1308
  00297	e9 97 00 00 00	 jmp	 $LN4@perform_cl
$LN3@perform_cl:

; 1874 :         else
; 1875 :             // "%1d:%04X CHAN: clear completed"
; 1876 :             WRMSG( HHC01308, "I", LCSS_DEVNUM );

  0029c	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002a2	74 0f		 je	 SHORT $LN8@perform_cl
  002a4	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  002a9	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002ad	89 44 24 50	 mov	 DWORD PTR tv185[rsp], eax
  002b1	eb 08		 jmp	 SHORT $LN9@perform_cl
$LN8@perform_cl:
  002b3	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv185[rsp], 0
$LN9@perform_cl:
  002bb	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002c1	74 11		 je	 SHORT $LN10@perform_cl
  002c3	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  002c8	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  002cc	d1 f8		 sar	 eax, 1
  002ce	89 44 24 54	 mov	 DWORD PTR tv191[rsp], eax
  002d2	eb 08		 jmp	 SHORT $LN11@perform_cl
$LN10@perform_cl:
  002d4	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv191[rsp], 0
$LN11@perform_cl:
  002dc	b9 01 00 00 00	 mov	 ecx, 1
  002e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002e7	8b 4c 24 50	 mov	 ecx, DWORD PTR tv185[rsp]
  002eb	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002ef	8b 4c 24 54	 mov	 ecx, DWORD PTR tv191[rsp]
  002f3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170653
  002fe	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00303	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170654
  0030a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0030f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00314	41 b9 03 00 00
	00		 mov	 r9d, 3
  0031a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170655
  00321	ba 54 07 00 00	 mov	 edx, 1876		; 00000754H
  00326	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170656
  0032d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@perform_cl:
$LN2@perform_cl:

; 1877 :     }
; 1878 : 
; 1879 : #if defined( OPTION_SHARED_DEVICES )
; 1880 :     /* Wake up any waiters if the device isn't reserved */
; 1881 :     if (!dev->reserved)

  00333	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00338	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0033e	c1 e8 14	 shr	 eax, 20
  00341	83 e0 01	 and	 eax, 1
  00344	85 c0		 test	 eax, eax
  00346	75 38		 jne	 SHORT $LN5@perform_cl

; 1882 :     {
; 1883 :         dev->shioactive = DEV_SYS_NONE;

  00348	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0034d	c7 80 e4 05 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1508], 0

; 1884 :         if (dev->shiowaiters)

  00357	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0035c	83 b8 e0 05 00
	00 00		 cmp	 DWORD PTR [rax+1504], 0
  00363	74 1b		 je	 SHORT $LN6@perform_cl

; 1885 :            signal_condition (&dev->shiocond);

  00365	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0036a	48 05 d8 05 00
	00		 add	 rax, 1496		; 000005d8H
  00370	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170659
  00377	48 8b c8	 mov	 rcx, rax
  0037a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN6@perform_cl:
$LN5@perform_cl:

; 1886 :     }
; 1887 : #endif // defined( OPTION_SHARED_DEVICES )
; 1888 : }

  00380	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00384	c3		 ret	 0
perform_clear_subchan ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
cc$ = 32
dev$ = 64
scsw$ = 72
test_subchan_clear PROC

; 1579 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1580 :     int cc = 1;                         /* Status not cleared        */

  0000e	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1

; 1581 : 
; 1582 :     /* Remove pending condition and requirement for TEST SUBCHANNEL */
; 1583 :     dev->tschpending = 0;

  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0001b	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00021	0f ba f0 1b	 btr	 eax, 27
  00025	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0002a	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 1584 : 
; 1585 :     /* Clearing only occurs if status is pending */
; 1586 :     if (scsw != NULL && scsw->flag3 & SCSW3_SC_PEND)

  00030	48 83 7c 24 48
	00		 cmp	 QWORD PTR scsw$[rsp], 0
  00036	0f 84 39 01 00
	00		 je	 $LN2@test_subch
  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR scsw$[rsp]
  00041	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00045	83 e0 01	 and	 eax, 1
  00048	85 c0		 test	 eax, eax
  0004a	0f 84 25 01 00
	00		 je	 $LN2@test_subch

; 1587 :     {
; 1588 :         if (scsw->flag3 & SCSW3_SC_INTER)

  00050	48 8b 44 24 48	 mov	 rax, QWORD PTR scsw$[rsp]
  00055	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00059	83 e0 08	 and	 eax, 8
  0005c	85 c0		 test	 eax, eax
  0005e	74 49		 je	 SHORT $LN3@test_subch

; 1589 :         {
; 1590 :                                         /* SA22-7832-09, page 16-22  */
; 1591 :             scsw->flag1 &= ~SCSW1_Z;    /* Reset Zero Condition Code */

  00060	48 8b 44 24 48	 mov	 rax, QWORD PTR scsw$[rsp]
  00065	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00069	83 e0 fb	 and	 eax, -5
  0006c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR scsw$[rsp]
  00071	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 1592 : 
; 1593 :             scsw_clear_fc_Nc(scsw);

  00074	48 8b 4c 24 48	 mov	 rcx, QWORD PTR scsw$[rsp]
  00079	e8 00 00 00 00	 call	 scsw_clear_fc_Nc

; 1594 :             scsw_clear_ac_Nr(scsw);

  0007e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR scsw$[rsp]
  00083	e8 00 00 00 00	 call	 scsw_clear_ac_Nr

; 1595 :             scsw_clear_sc_Cs(scsw);

  00088	48 8b 4c 24 48	 mov	 rcx, QWORD PTR scsw$[rsp]
  0008d	e8 00 00 00 00	 call	 scsw_clear_sc_Cs

; 1596 :             /*          n_Nr(scsw); Implied by ac_NR */
; 1597 :             scsw_clear_q_C(scsw);

  00092	48 8b 4c 24 48	 mov	 rcx, QWORD PTR scsw$[rsp]
  00097	e8 00 00 00 00	 call	 scsw_clear_q_C

; 1598 :             cc = 0;

  0009c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0

; 1599 :         }

  000a4	e9 cc 00 00 00	 jmp	 $LN4@test_subch
$LN3@test_subch:

; 1600 :         else if ((scsw->flag3 & (SCSW3_SC_ALERT  |
; 1601 :                                  SCSW3_SC_PRI    |
; 1602 :                                  SCSW3_SC_SEC))  ||

  000a9	48 8b 44 24 48	 mov	 rax, QWORD PTR scsw$[rsp]
  000ae	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  000b2	83 e0 16	 and	 eax, 22
  000b5	85 c0		 test	 eax, eax
  000b7	75 15		 jne	 SHORT $LN6@test_subch
  000b9	48 8b 44 24 48	 mov	 rax, QWORD PTR scsw$[rsp]
  000be	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  000c2	83 e0 1f	 and	 eax, 31
  000c5	83 f8 01	 cmp	 eax, 1
  000c8	0f 85 a7 00 00
	00		 jne	 $LN5@test_subch
$LN6@test_subch:

; 1603 :                  (scsw->flag3 & SCSW3_SC) == SCSW3_SC_PEND)
; 1604 :         {
; 1605 :             /* SA22-7832-09, page 16-17, TEST SUBCHANNEL clears
; 1606 :              * device suspended indication if suppressed
; 1607 :              */
; 1608 :             if (1
; 1609 :                 && scsw == &dev->scsw
; 1610 :                 && scsw->flag1 & SCSW1_U
; 1611 :                 && scsw->flag3 & SCSW3_AC_SUSP

  000ce	33 c0		 xor	 eax, eax
  000d0	83 f8 01	 cmp	 eax, 1
  000d3	74 66		 je	 SHORT $LN7@test_subch
  000d5	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000da	48 05 08 03 00
	00		 add	 rax, 776		; 00000308H
  000e0	48 39 44 24 48	 cmp	 QWORD PTR scsw$[rsp], rax
  000e5	75 54		 jne	 SHORT $LN7@test_subch
  000e7	48 8b 44 24 48	 mov	 rax, QWORD PTR scsw$[rsp]
  000ec	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  000f0	83 e0 08	 and	 eax, 8
  000f3	85 c0		 test	 eax, eax
  000f5	74 44		 je	 SHORT $LN7@test_subch
  000f7	48 8b 44 24 48	 mov	 rax, QWORD PTR scsw$[rsp]
  000fc	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00100	83 e0 20	 and	 eax, 32			; 00000020H
  00103	85 c0		 test	 eax, eax
  00105	74 34		 je	 SHORT $LN7@test_subch

; 1612 :             )
; 1613 :             {
; 1614 :                 dev->busy = 0;

  00107	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0010c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00112	0f ba f0 13	 btr	 eax, 19
  00116	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0011b	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 1615 :                 dev->suspended = 0;

  00121	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00126	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0012c	0f ba f0 15	 btr	 eax, 21
  00130	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00135	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
$LN7@test_subch:

; 1616 :             }
; 1617 : 
; 1618 :             scsw_clear_fc_C(scsw);

  0013b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR scsw$[rsp]
  00140	e8 00 00 00 00	 call	 scsw_clear_fc_C

; 1619 :             scsw_clear_ac_Cp(scsw);

  00145	48 8b 4c 24 48	 mov	 rcx, QWORD PTR scsw$[rsp]
  0014a	e8 00 00 00 00	 call	 scsw_clear_ac_Cp

; 1620 :             scsw_clear_sc_Cs(scsw);

  0014f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR scsw$[rsp]
  00154	e8 00 00 00 00	 call	 scsw_clear_sc_Cs

; 1621 :             scsw_clear_n_C(scsw);

  00159	48 8b 4c 24 48	 mov	 rcx, QWORD PTR scsw$[rsp]
  0015e	e8 00 00 00 00	 call	 scsw_clear_n_C

; 1622 :             scsw_clear_q_C(scsw);

  00163	48 8b 4c 24 48	 mov	 rcx, QWORD PTR scsw$[rsp]
  00168	e8 00 00 00 00	 call	 scsw_clear_q_C

; 1623 :             cc = 0;

  0016d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0
$LN5@test_subch:
$LN4@test_subch:
$LN2@test_subch:

; 1624 :         }
; 1625 :     }
; 1626 : 
; 1627 :     /* Ensure old DEVBLK status bits are maintained */
; 1628 :     subchannel_interrupt_queue_cleanup(dev);

  00175	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0017a	e8 00 00 00 00	 call	 subchannel_interrupt_queue_cleanup

; 1629 : 
; 1630 :     /* Return completion code */
; 1631 :     return (cc);

  0017f	8b 44 24 20	 mov	 eax, DWORD PTR cc$[rsp]

; 1632 : }

  00183	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00187	c3		 ret	 0
test_subchan_clear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv164 = 176
tv170 = 180
tv84 = 184
tv89 = 188
tv94 = 192
tv141 = 196
tv144 = 200
tv147 = 204
tv150 = 208
$T1 = 224
csw$2 = 240
__$ArrayPad$ = 248
dev$ = 304
scsw$ = 312
file$ = 320
line$ = 328
func$ = 336
_display_scsw PROC

; 989  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	53		 push	 rbx
  00015	55		 push	 rbp
  00016	56		 push	 rsi
  00017	57		 push	 rdi
  00018	41 56		 push	 r14
  0001a	48 81 ec 00 01
	00 00		 sub	 rsp, 256		; 00000100H
  00021	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00028	48 33 c4	 xor	 rax, rsp
  0002b	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 990  :     if (ARCH_370_IDX == sysblk.arch_mode)

  00033	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003a	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [rax+136], 0
  00041	75 4c		 jne	 SHORT $LN2@display_sc

; 991  :     {
; 992  :         U8 csw[8];
; 993  :         scsw2csw( &scsw, csw );

  00043	48 8d 94 24 f0
	00 00 00	 lea	 rdx, QWORD PTR csw$2[rsp]
  0004b	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR scsw$[rsp]
  00053	e8 00 00 00 00	 call	 scsw2csw

; 994  : //      DISPLAY_CSW( dev, csw );
; 995  :         _display_csw( dev, csw, file, line, func );

  00058	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR func$[rsp]
  00060	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00065	44 8b 8c 24 48
	01 00 00	 mov	 r9d, DWORD PTR line$[rsp]
  0006d	4c 8b 84 24 40
	01 00 00	 mov	 r8, QWORD PTR file$[rsp]
  00075	48 8d 94 24 f0
	00 00 00	 lea	 rdx, QWORD PTR csw$2[rsp]
  0007d	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00085	e8 00 00 00 00	 call	 _display_csw

; 996  :         return;

  0008a	e9 8f 02 00 00	 jmp	 $LN1@display_sc
$LN2@display_sc:

; 997  :     }
; 998  : 
; 999  :     if (dev->ccwtrace && sysblk.traceFILE)

  0008f	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00097	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0009d	c1 e8 0f	 shr	 eax, 15
  000a0	83 e0 01	 and	 eax, 1
  000a3	85 c0		 test	 eax, eax
  000a5	74 46		 je	 SHORT $LN3@display_sc
  000a7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ae	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  000b6	74 35		 je	 SHORT $LN3@display_sc

; 1000 :         tf_1317( dev, scsw );

  000b8	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR $T1[rsp]
  000c0	48 8b f8	 mov	 rdi, rax
  000c3	48 8b b4 24 38
	01 00 00	 mov	 rsi, QWORD PTR scsw$[rsp]
  000cb	b9 0c 00 00 00	 mov	 ecx, 12
  000d0	f3 a4		 rep movsb
  000d2	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR $T1[rsp]
  000da	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1317
  000e8	e9 31 02 00 00	 jmp	 $LN4@display_sc
$LN3@display_sc:

; 1001 :     else
; 1002 :     {
; 1003 :         // "%1d:%04X CHAN: scsw %2.2X%2.2X%2.2X%2.2X, stat %2.2X%2.2X, count %2.2X%2.2X, ccw %2.2X%2.2X%2.2X%2.2X"
; 1004 :         fwritemsg

  000ed	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000f6	74 15		 je	 SHORT $LN6@display_sc
  000f8	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00100	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00104	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv164[rsp], eax
  0010b	eb 0b		 jmp	 SHORT $LN7@display_sc
$LN6@display_sc:
  0010d	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv164[rsp], 0
$LN7@display_sc:
  00118	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00121	74 17		 je	 SHORT $LN8@display_sc
  00123	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0012b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0012f	d1 f8		 sar	 eax, 1
  00131	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv170[rsp], eax
  00138	eb 0b		 jmp	 SHORT $LN9@display_sc
$LN8@display_sc:
  0013a	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv170[rsp], 0
$LN9@display_sc:
  00145	b8 01 00 00 00	 mov	 eax, 1
  0014a	48 6b c0 03	 imul	 rax, rax, 3
  0014e	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR scsw$[rsp]
  00156	0f b6 44 01 04	 movzx	 eax, BYTE PTR [rcx+rax+4]
  0015b	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv84[rsp], eax
  00162	b9 01 00 00 00	 mov	 ecx, 1
  00167	48 6b c9 02	 imul	 rcx, rcx, 2
  0016b	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR scsw$[rsp]
  00173	0f b6 4c 0a 04	 movzx	 ecx, BYTE PTR [rdx+rcx+4]
  00178	89 8c 24 bc 00
	00 00		 mov	 DWORD PTR tv89[rsp], ecx
  0017f	ba 01 00 00 00	 mov	 edx, 1
  00184	48 6b d2 01	 imul	 rdx, rdx, 1
  00188	48 8b bc 24 38
	01 00 00	 mov	 rdi, QWORD PTR scsw$[rsp]
  00190	0f b6 54 17 04	 movzx	 edx, BYTE PTR [rdi+rdx+4]
  00195	89 94 24 c0 00
	00 00		 mov	 DWORD PTR tv94[rsp], edx
  0019c	bf 01 00 00 00	 mov	 edi, 1
  001a1	48 6b ff 00	 imul	 rdi, rdi, 0
  001a5	48 8b b4 24 38
	01 00 00	 mov	 rsi, QWORD PTR scsw$[rsp]
  001ad	0f b6 7c 3e 04	 movzx	 edi, BYTE PTR [rsi+rdi+4]
  001b2	be 01 00 00 00	 mov	 esi, 1
  001b7	48 6b f6 01	 imul	 rsi, rsi, 1
  001bb	4c 8b 84 24 38
	01 00 00	 mov	 r8, QWORD PTR scsw$[rsp]
  001c3	41 0f b6 74 30
	0a		 movzx	 esi, BYTE PTR [r8+rsi+10]
  001c9	41 b8 01 00 00
	00		 mov	 r8d, 1
  001cf	4d 6b c0 00	 imul	 r8, r8, 0
  001d3	4c 8b 8c 24 38
	01 00 00	 mov	 r9, QWORD PTR scsw$[rsp]
  001db	47 0f b6 44 01
	0a		 movzx	 r8d, BYTE PTR [r9+r8+10]
  001e1	44 89 84 24 c4
	00 00 00	 mov	 DWORD PTR tv141[rsp], r8d
  001e9	4c 8b 8c 24 38
	01 00 00	 mov	 r9, QWORD PTR scsw$[rsp]
  001f1	45 0f b6 49 09	 movzx	 r9d, BYTE PTR [r9+9]
  001f6	44 89 8c 24 c8
	00 00 00	 mov	 DWORD PTR tv144[rsp], r9d
  001fe	4c 8b 94 24 38
	01 00 00	 mov	 r10, QWORD PTR scsw$[rsp]
  00206	45 0f b6 52 08	 movzx	 r10d, BYTE PTR [r10+8]
  0020b	44 89 94 24 cc
	00 00 00	 mov	 DWORD PTR tv147[rsp], r10d
  00213	4c 8b 9c 24 38
	01 00 00	 mov	 r11, QWORD PTR scsw$[rsp]
  0021b	45 0f b6 5b 03	 movzx	 r11d, BYTE PTR [r11+3]
  00220	44 89 9c 24 d0
	00 00 00	 mov	 DWORD PTR tv150[rsp], r11d
  00228	48 8b 9c 24 38
	01 00 00	 mov	 rbx, QWORD PTR scsw$[rsp]
  00230	0f b6 5b 02	 movzx	 ebx, BYTE PTR [rbx+2]
  00234	48 8b ac 24 38
	01 00 00	 mov	 rbp, QWORD PTR scsw$[rsp]
  0023c	0f b6 6d 01	 movzx	 ebp, BYTE PTR [rbp+1]
  00240	4c 8b b4 24 38
	01 00 00	 mov	 r14, QWORD PTR scsw$[rsp]
  00248	45 0f b6 36	 movzx	 r14d, BYTE PTR [r14]
  0024c	b9 01 00 00 00	 mov	 ecx, 1
  00251	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00257	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv84[rsp]
  0025e	89 8c 24 a0 00
	00 00		 mov	 DWORD PTR [rsp+160], ecx
  00265	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv89[rsp]
  0026c	89 8c 24 98 00
	00 00		 mov	 DWORD PTR [rsp+152], ecx
  00273	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv94[rsp]
  0027a	89 8c 24 90 00
	00 00		 mov	 DWORD PTR [rsp+144], ecx
  00281	89 bc 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], edi
  00288	89 b4 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], esi
  0028f	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv141[rsp]
  00296	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  0029a	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv144[rsp]
  002a1	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  002a5	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv147[rsp]
  002ac	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  002b0	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv150[rsp]
  002b7	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  002bb	89 5c 24 58	 mov	 DWORD PTR [rsp+88], ebx
  002bf	89 6c 24 50	 mov	 DWORD PTR [rsp+80], ebp
  002c3	44 89 74 24 48	 mov	 DWORD PTR [rsp+72], r14d
  002c8	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv164[rsp]
  002cf	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002d3	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv170[rsp]
  002da	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170365
  002e5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170366
  002f1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002f6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002fb	41 b9 03 00 00
	00		 mov	 r9d, 3
  00301	4c 8b 84 24 50
	01 00 00	 mov	 r8, QWORD PTR func$[rsp]
  00309	8b 94 24 48 01
	00 00		 mov	 edx, DWORD PTR line$[rsp]
  00310	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  00318	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@display_sc:
$LN1@display_sc:

; 1005 :         (
; 1006 :             file, line, func, WRMSG_NORMAL, stdout,
; 1007 :             MSG
; 1008 :             (
; 1009 :                 HHC01317, "I", LCSS_DEVNUM,
; 1010 :                 scsw.flag0, scsw.flag1, scsw.flag2, scsw.flag3,
; 1011 :                 scsw.unitstat, scsw.chanstat,
; 1012 :                 scsw.count[0], scsw.count[1],
; 1013 :                 scsw.ccwaddr[0], scsw.ccwaddr[1],
; 1014 :                 scsw.ccwaddr[2], scsw.ccwaddr[3]
; 1015 :             )
; 1016 :         );
; 1017 :     }
; 1018 : }

  0031e	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00326	48 33 cc	 xor	 rcx, rsp
  00329	e8 00 00 00 00	 call	 __security_check_cookie
  0032e	48 81 c4 00 01
	00 00		 add	 rsp, 256		; 00000100H
  00335	41 5e		 pop	 r14
  00337	5f		 pop	 rdi
  00338	5e		 pop	 rsi
  00339	5d		 pop	 rbp
  0033a	5b		 pop	 rbx
  0033b	c3		 ret	 0
_display_scsw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv139 = 144
tv145 = 148
tv74 = 152
tv78 = 156
tv82 = 160
tv86 = 164
tv90 = 168
tv94 = 172
dev$ = 208
csw$ = 216
file$ = 224
line$ = 232
func$ = 240
_display_csw PROC

; 959  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	53		 push	 rbx
  00015	57		 push	 rdi
  00016	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 960  :     if (dev->ccwtrace && sysblk.traceFILE)

  0001d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00025	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0002b	c1 e8 0f	 shr	 eax, 15
  0002e	83 e0 01	 and	 eax, 1
  00031	85 c0		 test	 eax, eax
  00033	74 2c		 je	 SHORT $LN2@display_cs
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003c	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00044	74 1b		 je	 SHORT $LN2@display_cs

; 961  :         tf_1316( dev, csw );

  00046	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR csw$[rsp]
  0004e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1316
  0005c	e9 e6 01 00 00	 jmp	 $LN3@display_cs
$LN2@display_cs:

; 962  :     else
; 963  :     {
; 964  :         // "%1d:%04X CHAN: csw %2.2X, stat %2.2X%2.2X, count %2.2X%2.2X, ccw %2.2X%2.2X%2.2X"
; 965  :         fwritemsg

  00061	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0006a	74 15		 je	 SHORT $LN5@display_cs
  0006c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00074	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00078	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv139[rsp], eax
  0007f	eb 0b		 jmp	 SHORT $LN6@display_cs
$LN5@display_cs:
  00081	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv139[rsp], 0
$LN6@display_cs:
  0008c	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00095	74 17		 je	 SHORT $LN7@display_cs
  00097	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0009f	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000a3	d1 f8		 sar	 eax, 1
  000a5	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv145[rsp], eax
  000ac	eb 0b		 jmp	 SHORT $LN8@display_cs
$LN7@display_cs:
  000ae	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv145[rsp], 0
$LN8@display_cs:
  000b9	b8 01 00 00 00	 mov	 eax, 1
  000be	48 6b c0 03	 imul	 rax, rax, 3
  000c2	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR csw$[rsp]
  000ca	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ce	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv74[rsp], eax
  000d5	b9 01 00 00 00	 mov	 ecx, 1
  000da	48 6b c9 02	 imul	 rcx, rcx, 2
  000de	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR csw$[rsp]
  000e6	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000ea	89 8c 24 9c 00
	00 00		 mov	 DWORD PTR tv78[rsp], ecx
  000f1	ba 01 00 00 00	 mov	 edx, 1
  000f6	48 6b d2 01	 imul	 rdx, rdx, 1
  000fa	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR csw$[rsp]
  00102	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  00107	89 94 24 a0 00
	00 00		 mov	 DWORD PTR tv82[rsp], edx
  0010e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00114	4d 6b c0 07	 imul	 r8, r8, 7
  00118	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR csw$[rsp]
  00120	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  00125	44 89 84 24 a4
	00 00 00	 mov	 DWORD PTR tv86[rsp], r8d
  0012d	41 b9 01 00 00
	00		 mov	 r9d, 1
  00133	4d 6b c9 06	 imul	 r9, r9, 6
  00137	4c 8b 94 24 d8
	00 00 00	 mov	 r10, QWORD PTR csw$[rsp]
  0013f	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  00144	44 89 8c 24 a8
	00 00 00	 mov	 DWORD PTR tv90[rsp], r9d
  0014c	41 ba 01 00 00
	00		 mov	 r10d, 1
  00152	4d 6b d2 05	 imul	 r10, r10, 5
  00156	4c 8b 9c 24 d8
	00 00 00	 mov	 r11, QWORD PTR csw$[rsp]
  0015e	47 0f b6 14 13	 movzx	 r10d, BYTE PTR [r11+r10]
  00163	44 89 94 24 ac
	00 00 00	 mov	 DWORD PTR tv94[rsp], r10d
  0016b	41 bb 01 00 00
	00		 mov	 r11d, 1
  00171	4d 6b db 04	 imul	 r11, r11, 4
  00175	48 8b 9c 24 d8
	00 00 00	 mov	 rbx, QWORD PTR csw$[rsp]
  0017d	42 0f b6 1c 1b	 movzx	 ebx, BYTE PTR [rbx+r11]
  00182	41 bb 01 00 00
	00		 mov	 r11d, 1
  00188	4d 6b db 00	 imul	 r11, r11, 0
  0018c	48 8b bc 24 d8
	00 00 00	 mov	 rdi, QWORD PTR csw$[rsp]
  00194	42 0f b6 3c 1f	 movzx	 edi, BYTE PTR [rdi+r11]
  00199	b9 01 00 00 00	 mov	 ecx, 1
  0019e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001a4	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv74[rsp]
  001ab	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  001b2	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv78[rsp]
  001b9	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  001bd	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv82[rsp]
  001c4	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  001c8	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv86[rsp]
  001cf	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  001d3	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv90[rsp]
  001da	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  001de	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv94[rsp]
  001e5	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  001e9	89 5c 24 50	 mov	 DWORD PTR [rsp+80], ebx
  001ed	89 7c 24 48	 mov	 DWORD PTR [rsp+72], edi
  001f1	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv139[rsp]
  001f8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001fc	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv145[rsp]
  00203	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00207	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170347
  0020e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00213	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170348
  0021a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0021f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00224	41 b9 03 00 00
	00		 mov	 r9d, 3
  0022a	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR func$[rsp]
  00232	8b 94 24 e8 00
	00 00		 mov	 edx, DWORD PTR line$[rsp]
  00239	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  00241	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN3@display_cs:

; 966  :         (
; 967  :             file, line, func, WRMSG_NORMAL, stdout,
; 968  :             MSG
; 969  :             (
; 970  :                 HHC01316, "I", LCSS_DEVNUM,
; 971  :                 csw[0],
; 972  :                 csw[4], csw[5], csw[6], csw[7],
; 973  :                 csw[1], csw[2], csw[3]
; 974  :             )
; 975  :         );
; 976  :     }
; 977  : }

  00247	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0024e	5f		 pop	 rdi
  0024f	5b		 pop	 rbx
  00250	c3		 ret	 0
_display_csw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
amt$1 = 112
tv142 = 116
tv93 = 120
tv150 = 124
tv156 = 128
tv174 = 132
tv180 = 136
tv200 = 140
tv206 = 144
tv144 = 148
tv168 = 152
tv193 = 156
tv195 = 160
tv79 = 168
tv91 = 176
tv70 = 184
tv82 = 192
area$2 = 208
__$ArrayPad$ = 272
dev$ = 304
type$ = 312
flag$ = 320
addr$ = 328
count$ = 336
file$ = 344
line$ = 352
func$ = 360
_display_idaw PROC

; 905  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 906  :     if (dev->ccwtrace && sysblk.traceFILE)

  0002c	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00034	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0003a	c1 e8 0f	 shr	 eax, 15
  0003d	83 e0 01	 and	 eax, 1
  00040	85 c0		 test	 eax, eax
  00042	0f 84 5e 01 00
	00		 je	 $LN4@display_id
  00048	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0004f	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00057	0f 84 49 01 00
	00		 je	 $LN4@display_id

; 907  :     {
; 908  :         BYTE amt = MIN( 16, CAPPED_BUFFLEN( addr, count, dev ));

  0005d	0f b7 84 24 50
	01 00 00	 movzx	 eax, WORD PTR count$[rsp]
  00065	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv70[rsp], rax
  0006d	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00075	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0007d	e8 00 00 00 00	 call	 BytesToEndOfStorage
  00082	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv70[rsp]
  0008a	48 3b c8	 cmp	 rcx, rax
  0008d	73 12		 jae	 SHORT $LN10@display_id
  0008f	0f b7 84 24 50
	01 00 00	 movzx	 eax, WORD PTR count$[rsp]
  00097	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv79[rsp], rax
  0009f	eb 1d		 jmp	 SHORT $LN11@display_id
$LN10@display_id:
  000a1	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  000a9	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  000b1	e8 00 00 00 00	 call	 BytesToEndOfStorage
  000b6	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv79[rsp], rax
$LN11@display_id:
  000be	83 bc 24 a8 00
	00 00 10	 cmp	 DWORD PTR tv79[rsp], 16
  000c6	76 0a		 jbe	 SHORT $LN14@display_id
  000c8	c7 44 24 78 10
	00 00 00	 mov	 DWORD PTR tv93[rsp], 16
  000d0	eb 6c		 jmp	 SHORT $LN15@display_id
$LN14@display_id:
  000d2	0f b7 84 24 50
	01 00 00	 movzx	 eax, WORD PTR count$[rsp]
  000da	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv82[rsp], rax
  000e2	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  000ea	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  000f2	e8 00 00 00 00	 call	 BytesToEndOfStorage
  000f7	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv82[rsp]
  000ff	48 3b c8	 cmp	 rcx, rax
  00102	73 12		 jae	 SHORT $LN12@display_id
  00104	0f b7 84 24 50
	01 00 00	 movzx	 eax, WORD PTR count$[rsp]
  0010c	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv91[rsp], rax
  00114	eb 1d		 jmp	 SHORT $LN13@display_id
$LN12@display_id:
  00116	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0011e	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  00126	e8 00 00 00 00	 call	 BytesToEndOfStorage
  0012b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv91[rsp], rax
$LN13@display_id:
  00133	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv91[rsp]
  0013a	89 44 24 78	 mov	 DWORD PTR tv93[rsp], eax
$LN15@display_id:
  0013e	0f b6 44 24 78	 movzx	 eax, BYTE PTR tv93[rsp]
  00143	88 44 24 70	 mov	 BYTE PTR amt$1[rsp], al

; 909  :         tf_1301( dev, addr, count, dev->mainstor + addr, amt, flag, type );

  00147	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0014f	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00156	48 03 84 24 48
	01 00 00	 add	 rax, QWORD PTR addr$[rsp]
  0015e	0f b6 8c 24 38
	01 00 00	 movzx	 ecx, BYTE PTR type$[rsp]
  00166	88 4c 24 30	 mov	 BYTE PTR [rsp+48], cl
  0016a	0f b6 8c 24 40
	01 00 00	 movzx	 ecx, BYTE PTR flag$[rsp]
  00172	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00176	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR amt$1[rsp]
  0017b	88 4c 24 20	 mov	 BYTE PTR [rsp+32], cl
  0017f	4c 8b c8	 mov	 r9, rax
  00182	44 0f b7 84 24
	50 01 00 00	 movzx	 r8d, WORD PTR count$[rsp]
  0018b	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  00193	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0019b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1301

; 910  :     }

  001a1	e9 36 03 00 00	 jmp	 $LN5@display_id
$LN4@display_id:

; 911  :     else
; 912  :     {
; 913  :         BYTE area[64];
; 914  : 
; 915  :         format_iobuf_data( addr, area, dev, count );

  001a6	0f b7 84 24 50
	01 00 00	 movzx	 eax, WORD PTR count$[rsp]
  001ae	44 8b c8	 mov	 r9d, eax
  001b1	4c 8b 84 24 30
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  001b9	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR area$2[rsp]
  001c1	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  001c9	e8 00 00 00 00	 call	 format_iobuf_data

; 916  : 
; 917  :         switch (type)

  001ce	0f b6 84 24 38
	01 00 00	 movzx	 eax, BYTE PTR type$[rsp]
  001d6	88 44 24 74	 mov	 BYTE PTR tv142[rsp], al
  001da	80 7c 24 74 01	 cmp	 BYTE PTR tv142[rsp], 1
  001df	74 1b		 je	 SHORT $LN6@display_id
  001e1	80 7c 24 74 02	 cmp	 BYTE PTR tv142[rsp], 2
  001e6	0f 84 f7 00 00
	00		 je	 $LN7@display_id
  001ec	80 7c 24 74 03	 cmp	 BYTE PTR tv142[rsp], 3
  001f1	0f 84 de 01 00
	00		 je	 $LN8@display_id
  001f7	e9 e0 02 00 00	 jmp	 $LN2@display_id
$LN6@display_id:

; 918  :         {
; 919  :             case PF_IDAW1:
; 920  :                 // "%1d:%04X CHAN: idaw %8.8"PRIX32", len %3.3"PRIX16": %s"
; 921  :                 fwritemsg

  001fc	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00205	74 12		 je	 SHORT $LN16@display_id
  00207	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0020f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00213	89 44 24 7c	 mov	 DWORD PTR tv150[rsp], eax
  00217	eb 08		 jmp	 SHORT $LN17@display_id
$LN16@display_id:
  00219	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv150[rsp], 0
$LN17@display_id:
  00221	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0022a	74 17		 je	 SHORT $LN18@display_id
  0022c	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00234	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00238	d1 f8		 sar	 eax, 1
  0023a	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv156[rsp], eax
  00241	eb 0b		 jmp	 SHORT $LN19@display_id
$LN18@display_id:
  00243	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv156[rsp], 0
$LN19@display_id:
  0024e	0f b7 84 24 50
	01 00 00	 movzx	 eax, WORD PTR count$[rsp]
  00256	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv144[rsp], eax
  0025d	b9 01 00 00 00	 mov	 ecx, 1
  00262	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00268	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR area$2[rsp]
  00270	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00275	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv144[rsp]
  0027c	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00280	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00287	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0028b	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv150[rsp]
  0028f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00293	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv156[rsp]
  0029a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0029e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170325
  002a5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170326
  002b1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002b6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002bb	41 b9 03 00 00
	00		 mov	 r9d, 3
  002c1	4c 8b 84 24 68
	01 00 00	 mov	 r8, QWORD PTR func$[rsp]
  002c9	8b 94 24 60 01
	00 00		 mov	 edx, DWORD PTR line$[rsp]
  002d0	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  002d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 922  :                 (
; 923  :                     file, line, func, WRMSG_NORMAL, stdout,
; 924  :                     MSG( HHC01302, "I", LCSS_DEVNUM, (U32)addr, count, area )
; 925  :                 );
; 926  :                 break;

  002de	e9 f9 01 00 00	 jmp	 $LN2@display_id
$LN7@display_id:

; 927  : 
; 928  :             case PF_IDAW2:
; 929  :                 // "%1d:%04X CHAN: idaw %16.16"PRIX64", len %4.4"PRIX16": %s"
; 930  :                 fwritemsg

  002e3	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002ec	74 15		 je	 SHORT $LN20@display_id
  002ee	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002f6	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002fa	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv174[rsp], eax
  00301	eb 0b		 jmp	 SHORT $LN21@display_id
$LN20@display_id:
  00303	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv174[rsp], 0
$LN21@display_id:
  0030e	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00317	74 17		 je	 SHORT $LN22@display_id
  00319	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00321	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00325	d1 f8		 sar	 eax, 1
  00327	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv180[rsp], eax
  0032e	eb 0b		 jmp	 SHORT $LN23@display_id
$LN22@display_id:
  00330	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv180[rsp], 0
$LN23@display_id:
  0033b	0f b7 84 24 50
	01 00 00	 movzx	 eax, WORD PTR count$[rsp]
  00343	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv168[rsp], eax
  0034a	b9 01 00 00 00	 mov	 ecx, 1
  0034f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00355	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR area$2[rsp]
  0035d	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00362	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv168[rsp]
  00369	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0036d	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  00375	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0037a	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv174[rsp]
  00381	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00385	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv180[rsp]
  0038c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00390	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170328
  00397	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0039c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170329
  003a3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003a8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003ad	41 b9 03 00 00
	00		 mov	 r9d, 3
  003b3	4c 8b 84 24 68
	01 00 00	 mov	 r8, QWORD PTR func$[rsp]
  003bb	8b 94 24 60 01
	00 00		 mov	 edx, DWORD PTR line$[rsp]
  003c2	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  003ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 931  :                 (
; 932  :                     file, line, func, WRMSG_NORMAL, stdout,
; 933  :                     MSG( HHC01303, "I", LCSS_DEVNUM, (U64)addr, count, area )
; 934  :                 );
; 935  :                 break;

  003d0	e9 07 01 00 00	 jmp	 $LN2@display_id
$LN8@display_id:

; 936  : 
; 937  :             case PF_MIDAW:
; 938  :                 // "%1d:%04X CHAN: midaw %2.2X %4.4"PRIX16" %16.16"PRIX64": %s"
; 939  :                 fwritemsg

  003d5	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003de	74 15		 je	 SHORT $LN24@display_id
  003e0	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003e8	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003ec	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv200[rsp], eax
  003f3	eb 0b		 jmp	 SHORT $LN25@display_id
$LN24@display_id:
  003f5	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv200[rsp], 0
$LN25@display_id:
  00400	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00409	74 17		 je	 SHORT $LN26@display_id
  0040b	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00413	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00417	d1 f8		 sar	 eax, 1
  00419	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv206[rsp], eax
  00420	eb 0b		 jmp	 SHORT $LN27@display_id
$LN26@display_id:
  00422	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv206[rsp], 0
$LN27@display_id:
  0042d	0f b7 84 24 50
	01 00 00	 movzx	 eax, WORD PTR count$[rsp]
  00435	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv193[rsp], eax
  0043c	0f b6 8c 24 40
	01 00 00	 movzx	 ecx, BYTE PTR flag$[rsp]
  00444	89 8c 24 a0 00
	00 00		 mov	 DWORD PTR tv195[rsp], ecx
  0044b	b9 01 00 00 00	 mov	 ecx, 1
  00450	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00456	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR area$2[rsp]
  0045e	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00463	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0046b	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00470	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv193[rsp]
  00477	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0047b	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv195[rsp]
  00482	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00486	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv200[rsp]
  0048d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00491	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv206[rsp]
  00498	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0049c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170331
  004a3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170332
  004af	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004b4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004b9	41 b9 03 00 00
	00		 mov	 r9d, 3
  004bf	4c 8b 84 24 68
	01 00 00	 mov	 r8, QWORD PTR func$[rsp]
  004c7	8b 94 24 60 01
	00 00		 mov	 edx, DWORD PTR line$[rsp]
  004ce	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  004d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN2@display_id:
$LN5@display_id:

; 940  :                 (
; 941  :                     file, line, func, WRMSG_NORMAL, stdout,
; 942  :                     MSG( HHC01301, "I", LCSS_DEVNUM, flag, count, (U64)addr, area )
; 943  :                 );
; 944  :                 break;
; 945  :         }
; 946  :     }
; 947  : }

  004dc	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004e4	48 33 cc	 xor	 rcx, rsp
  004e7	e8 00 00 00 00	 call	 __security_check_cookie
  004ec	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  004f3	c3		 ret	 0
_display_idaw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv84 = 80
tv90 = 84
snsbuf$ = 96
__$ArrayPad$ = 224
dev$ = 256
file$ = 264
line$ = 272
func$ = 280
_display_sense PROC

; 875  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 876  :     char snsbuf[128];
; 877  : 
; 878  :     /* Let the device interpret its own sense bytes if possible */
; 879  :     if (dev->sns)

  0002d	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00035	48 83 b8 c0 02
	00 00 00	 cmp	 QWORD PTR [rax+704], 0
  0003d	74 23		 je	 SHORT $LN2@display_se

; 880  :         dev->sns( dev, snsbuf, sizeof( snsbuf ));

  0003f	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  00045	48 8d 54 24 60	 lea	 rdx, QWORD PTR snsbuf$[rsp]
  0004a	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00052	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0005a	ff 90 c0 02 00
	00		 call	 QWORD PTR [rax+704]
  00060	eb 43		 jmp	 SHORT $LN3@display_se
$LN2@display_se:

; 881  :     else
; 882  :         /* Otherwise we use our default interpretation */
; 883  :         default_sns( snsbuf, sizeof( snsbuf ), dev->sense[0], dev->sense[1] );

  00062	b8 01 00 00 00	 mov	 eax, 1
  00067	48 6b c0 01	 imul	 rax, rax, 1
  0006b	b9 01 00 00 00	 mov	 ecx, 1
  00070	48 6b c9 00	 imul	 rcx, rcx, 0
  00074	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0007c	44 0f b6 8c 02
	64 03 00 00	 movzx	 r9d, BYTE PTR [rdx+rax+868]
  00085	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0008d	44 0f b6 84 08
	64 03 00 00	 movzx	 r8d, BYTE PTR [rax+rcx+868]
  00096	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0009b	48 8d 4c 24 60	 lea	 rcx, QWORD PTR snsbuf$[rsp]
  000a0	e8 00 00 00 00	 call	 default_sns
$LN3@display_se:

; 884  : 
; 885  :     // "%1d:%04X CHAN: sense %s"
; 886  :     fwritemsg

  000a5	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000ae	74 12		 je	 SHORT $LN5@display_se
  000b0	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b8	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000bc	89 44 24 50	 mov	 DWORD PTR tv84[rsp], eax
  000c0	eb 08		 jmp	 SHORT $LN6@display_se
$LN5@display_se:
  000c2	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
$LN6@display_se:
  000ca	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000d3	74 14		 je	 SHORT $LN7@display_se
  000d5	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000dd	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000e1	d1 f8		 sar	 eax, 1
  000e3	89 44 24 54	 mov	 DWORD PTR tv90[rsp], eax
  000e7	eb 08		 jmp	 SHORT $LN8@display_se
$LN7@display_se:
  000e9	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN8@display_se:
  000f1	b9 01 00 00 00	 mov	 ecx, 1
  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000fc	48 8d 4c 24 60	 lea	 rcx, QWORD PTR snsbuf$[rsp]
  00101	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00106	8b 4c 24 50	 mov	 ecx, DWORD PTR tv84[rsp]
  0010a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0010e	8b 4c 24 54	 mov	 ecx, DWORD PTR tv90[rsp]
  00112	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00116	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170285
  0011d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00122	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170286
  00129	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0012e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00133	41 b9 03 00 00
	00		 mov	 r9d, 3
  00139	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR func$[rsp]
  00141	8b 94 24 10 01
	00 00		 mov	 edx, DWORD PTR line$[rsp]
  00148	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  00150	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 887  :     (
; 888  :         file, line, func, WRMSG_NORMAL, stdout,
; 889  :         MSG( HHC01314, "I", LCSS_DEVNUM, snsbuf )
; 890  :     );
; 891  : }

  00156	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0015e	48 33 cc	 xor	 rcx, rsp
  00161	e8 00 00 00 00	 call	 __security_check_cookie
  00166	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  0016d	c3		 ret	 0
_display_sense ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
amt$1 = 144
tv129 = 148
tv197 = 152
tv203 = 156
tv164 = 160
tv168 = 164
tv172 = 168
tv176 = 172
tv180 = 176
tv184 = 180
tv81 = 184
tv95 = 192
$T2 = 200
tv70 = 208
tv84 = 216
area$3 = 224
__$ArrayPad$ = 288
dev$ = 336
ccw$ = 344
addr$ = 352
count$ = 360
flags$ = 368
file$ = 376
line$ = 384
func$ = 392
_display_ccw PROC

; 802  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	53		 push	 rbx
  00015	57		 push	 rdi
  00016	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 803  :     if (dev->ccwtrace && sysblk.traceFILE)

  0002f	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00037	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0003d	c1 e8 0f	 shr	 eax, 15
  00040	83 e0 01	 and	 eax, 1
  00043	85 c0		 test	 eax, eax
  00045	0f 84 5a 01 00
	00		 je	 $LN2@display_cc
  0004b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00052	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  0005a	0f 84 45 01 00
	00		 je	 $LN2@display_cc

; 804  :     {
; 805  :         BYTE amt = MIN( 16, CAPPED_BUFFLEN( addr, count, dev ));

  00060	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00067	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv70[rsp], rax
  0006f	8b 8c 24 60 01
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00076	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0007e	e8 00 00 00 00	 call	 BytesToEndOfStorage
  00083	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv70[rsp]
  0008b	48 3b c8	 cmp	 rcx, rax
  0008e	73 11		 jae	 SHORT $LN8@display_cc
  00090	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00097	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv81[rsp], rax
  0009f	eb 1e		 jmp	 SHORT $LN9@display_cc
$LN8@display_cc:
  000a1	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  000a8	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  000b0	8b c8		 mov	 ecx, eax
  000b2	e8 00 00 00 00	 call	 BytesToEndOfStorage
  000b7	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv81[rsp], rax
$LN9@display_cc:
  000bf	83 bc 24 b8 00
	00 00 10	 cmp	 DWORD PTR tv81[rsp], 16
  000c7	76 0d		 jbe	 SHORT $LN12@display_cc
  000c9	c7 84 24 94 00
	00 00 10 00 00
	00		 mov	 DWORD PTR tv129[rsp], 16
  000d4	eb 6d		 jmp	 SHORT $LN13@display_cc
$LN12@display_cc:
  000d6	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  000dd	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv84[rsp], rax
  000e5	8b 8c 24 60 01
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000ec	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  000f4	e8 00 00 00 00	 call	 BytesToEndOfStorage
  000f9	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv84[rsp]
  00101	48 3b c8	 cmp	 rcx, rax
  00104	73 11		 jae	 SHORT $LN10@display_cc
  00106	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  0010d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv95[rsp], rax
  00115	eb 1e		 jmp	 SHORT $LN11@display_cc
$LN10@display_cc:
  00117	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  0011e	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00126	8b c8		 mov	 ecx, eax
  00128	e8 00 00 00 00	 call	 BytesToEndOfStorage
  0012d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv95[rsp], rax
$LN11@display_cc:
  00135	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR tv95[rsp]
  0013c	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv129[rsp], eax
$LN13@display_cc:
  00143	0f b6 84 24 94
	00 00 00	 movzx	 eax, BYTE PTR tv129[rsp]
  0014b	88 84 24 90 00
	00 00		 mov	 BYTE PTR amt$1[rsp], al

; 806  :         tf_1315( dev, ccw, addr, count, dev->mainstor + addr, amt );

  00152	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00159	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00161	48 03 81 80 00
	00 00		 add	 rax, QWORD PTR [rcx+128]
  00168	0f b6 8c 24 90
	00 00 00	 movzx	 ecx, BYTE PTR amt$1[rsp]
  00170	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00174	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00179	44 0f b7 8c 24
	68 01 00 00	 movzx	 r9d, WORD PTR count$[rsp]
  00182	44 8b 84 24 60
	01 00 00	 mov	 r8d, DWORD PTR addr$[rsp]
  0018a	48 8b 94 24 58
	01 00 00	 mov	 rdx, QWORD PTR ccw$[rsp]
  00192	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0019a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1315

; 807  :     }

  001a0	e9 9d 02 00 00	 jmp	 $LN3@display_cc
$LN2@display_cc:

; 808  :     else
; 809  :     {
; 810  :         BYTE area[64];
; 811  : 
; 812  :         /* No data to be formatted if CCW is a NOP or TIC
; 813  :            or the CCW "Skip data transfer" flag is on. */
; 814  :         if (0
; 815  :             || flags & CCW_FLAGS_SKIP
; 816  :             || IS_CCW_NOP( ccw[0] )
; 817  :             || IS_CCW_TIC( ccw[0] )

  001a5	33 c0		 xor	 eax, eax
  001a7	85 c0		 test	 eax, eax
  001a9	75 46		 jne	 SHORT $LN6@display_cc
  001ab	0f b6 84 24 70
	01 00 00	 movzx	 eax, BYTE PTR flags$[rsp]
  001b3	83 e0 10	 and	 eax, 16
  001b6	85 c0		 test	 eax, eax
  001b8	75 37		 jne	 SHORT $LN6@display_cc
  001ba	b8 01 00 00 00	 mov	 eax, 1
  001bf	48 6b c0 00	 imul	 rax, rax, 0
  001c3	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR ccw$[rsp]
  001cb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001cf	83 f8 03	 cmp	 eax, 3
  001d2	74 1d		 je	 SHORT $LN6@display_cc
  001d4	b8 01 00 00 00	 mov	 eax, 1
  001d9	48 6b c0 00	 imul	 rax, rax, 0
  001dd	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR ccw$[rsp]
  001e5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001e9	83 e0 0f	 and	 eax, 15
  001ec	83 f8 08	 cmp	 eax, 8
  001ef	75 35		 jne	 SHORT $LN4@display_cc
$LN6@display_cc:

; 818  :         )
; 819  :             area[0] = 0;

  001f1	b8 01 00 00 00	 mov	 eax, 1
  001f6	48 6b c0 00	 imul	 rax, rax, 0
  001fa	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR $T2[rsp], rax
  00202	48 83 bc 24 c8
	00 00 00 40	 cmp	 QWORD PTR $T2[rsp], 64	; 00000040H
  0020b	73 02		 jae	 SHORT $LN14@display_cc
  0020d	eb 05		 jmp	 SHORT $LN15@display_cc
$LN14@display_cc:
  0020f	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN15@display_cc:
  00214	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR $T2[rsp]
  0021c	c6 84 04 e0 00
	00 00 00	 mov	 BYTE PTR area$3[rsp+rax], 0
  00224	eb 26		 jmp	 SHORT $LN5@display_cc
$LN4@display_cc:

; 820  :         else
; 821  :             format_iobuf_data( addr, area, dev, count );

  00226	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  0022d	44 8b 8c 24 68
	01 00 00	 mov	 r9d, DWORD PTR count$[rsp]
  00235	4c 8b 84 24 50
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0023d	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR area$3[rsp]
  00245	8b c8		 mov	 ecx, eax
  00247	e8 00 00 00 00	 call	 format_iobuf_data
$LN5@display_cc:

; 822  : 
; 823  :         // "%1d:%04X CHAN: ccw %2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X%s"
; 824  :         fwritemsg

  0024c	48 83 bc 24 50
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00255	74 15		 je	 SHORT $LN16@display_cc
  00257	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0025f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00263	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv197[rsp], eax
  0026a	eb 0b		 jmp	 SHORT $LN17@display_cc
$LN16@display_cc:
  0026c	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv197[rsp], 0
$LN17@display_cc:
  00277	48 83 bc 24 50
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00280	74 17		 je	 SHORT $LN18@display_cc
  00282	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0028a	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0028e	d1 f8		 sar	 eax, 1
  00290	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv203[rsp], eax
  00297	eb 0b		 jmp	 SHORT $LN19@display_cc
$LN18@display_cc:
  00299	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv203[rsp], 0
$LN19@display_cc:
  002a4	b8 01 00 00 00	 mov	 eax, 1
  002a9	48 6b c0 07	 imul	 rax, rax, 7
  002ad	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR ccw$[rsp]
  002b5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002b9	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv164[rsp], eax
  002c0	b9 01 00 00 00	 mov	 ecx, 1
  002c5	48 6b c9 06	 imul	 rcx, rcx, 6
  002c9	48 8b 94 24 58
	01 00 00	 mov	 rdx, QWORD PTR ccw$[rsp]
  002d1	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  002d5	89 8c 24 a4 00
	00 00		 mov	 DWORD PTR tv168[rsp], ecx
  002dc	ba 01 00 00 00	 mov	 edx, 1
  002e1	48 6b d2 05	 imul	 rdx, rdx, 5
  002e5	4c 8b 84 24 58
	01 00 00	 mov	 r8, QWORD PTR ccw$[rsp]
  002ed	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  002f2	89 94 24 a8 00
	00 00		 mov	 DWORD PTR tv172[rsp], edx
  002f9	41 b8 01 00 00
	00		 mov	 r8d, 1
  002ff	4d 6b c0 04	 imul	 r8, r8, 4
  00303	4c 8b 8c 24 58
	01 00 00	 mov	 r9, QWORD PTR ccw$[rsp]
  0030b	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  00310	44 89 84 24 ac
	00 00 00	 mov	 DWORD PTR tv176[rsp], r8d
  00318	41 b9 01 00 00
	00		 mov	 r9d, 1
  0031e	4d 6b c9 03	 imul	 r9, r9, 3
  00322	4c 8b 94 24 58
	01 00 00	 mov	 r10, QWORD PTR ccw$[rsp]
  0032a	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  0032f	44 89 8c 24 b0
	00 00 00	 mov	 DWORD PTR tv180[rsp], r9d
  00337	41 ba 01 00 00
	00		 mov	 r10d, 1
  0033d	4d 6b d2 02	 imul	 r10, r10, 2
  00341	4c 8b 9c 24 58
	01 00 00	 mov	 r11, QWORD PTR ccw$[rsp]
  00349	47 0f b6 14 13	 movzx	 r10d, BYTE PTR [r11+r10]
  0034e	44 89 94 24 b4
	00 00 00	 mov	 DWORD PTR tv184[rsp], r10d
  00356	41 bb 01 00 00
	00		 mov	 r11d, 1
  0035c	4d 6b db 01	 imul	 r11, r11, 1
  00360	48 8b 9c 24 58
	01 00 00	 mov	 rbx, QWORD PTR ccw$[rsp]
  00368	42 0f b6 1c 1b	 movzx	 ebx, BYTE PTR [rbx+r11]
  0036d	41 bb 01 00 00
	00		 mov	 r11d, 1
  00373	4d 6b db 00	 imul	 r11, r11, 0
  00377	48 8b bc 24 58
	01 00 00	 mov	 rdi, QWORD PTR ccw$[rsp]
  0037f	42 0f b6 3c 1f	 movzx	 edi, BYTE PTR [rdi+r11]
  00384	b9 01 00 00 00	 mov	 ecx, 1
  00389	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0038f	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR area$3[rsp]
  00397	48 89 8c 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rcx
  0039f	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv164[rsp]
  003a6	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  003ad	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv168[rsp]
  003b4	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  003b8	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv172[rsp]
  003bf	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  003c3	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv176[rsp]
  003ca	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  003ce	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv180[rsp]
  003d5	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  003d9	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv184[rsp]
  003e0	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  003e4	89 5c 24 50	 mov	 DWORD PTR [rsp+80], ebx
  003e8	89 7c 24 48	 mov	 DWORD PTR [rsp+72], edi
  003ec	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv197[rsp]
  003f3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  003f7	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv203[rsp]
  003fe	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00402	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170228
  00409	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0040e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170229
  00415	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0041a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0041f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00425	4c 8b 84 24 88
	01 00 00	 mov	 r8, QWORD PTR func$[rsp]
  0042d	8b 94 24 80 01
	00 00		 mov	 edx, DWORD PTR line$[rsp]
  00434	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  0043c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN3@display_cc:
$LN7@display_cc:

; 825  :         (
; 826  :             file, line, func, WRMSG_NORMAL, stdout,
; 827  :             MSG
; 828  :             (
; 829  :                 HHC01315, "I", LCSS_DEVNUM,
; 830  :                 ccw[0], ccw[1], ccw[2], ccw[3],
; 831  :                 ccw[4], ccw[5], ccw[6], ccw[7], area
; 832  :             )
; 833  :         );
; 834  :     }
; 835  : }

  00442	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0044a	48 33 cc	 xor	 rcx, rsp
  0044d	e8 00 00 00 00	 call	 __security_check_cookie
  00452	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  00459	5f		 pop	 rdi
  0045a	5b		 pop	 rbx
  0045b	c3		 ret	 0
_display_ccw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
k$ = 32
tv73 = 40
tv86 = 48
tv89 = 56
tv64 = 64
tv77 = 72
workarea$ = 80
__$ArrayPad$ = 104
addr$ = 144
dest$ = 152
dev$ = 160
len$ = 168
format_iobuf_data PROC

; 664  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 44 24 68	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 665  : u_int   k;                              /* Array subscripts          */
; 666  : BYTE    workarea[17];                   /* Character string work     */
; 667  : 
; 668  :     k = MIN(sizeof(workarea)-1,CAPPED_BUFFLEN(addr,len,dev));

  00029	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00030	48 89 44 24 40	 mov	 QWORD PTR tv64[rsp], rax
  00035	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0003d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  00045	e8 00 00 00 00	 call	 BytesToEndOfStorage
  0004a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv64[rsp]
  0004f	48 3b c8	 cmp	 rcx, rax
  00052	73 0e		 jae	 SHORT $LN5@format_iob
  00054	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  0005b	48 89 44 24 28	 mov	 QWORD PTR tv73[rsp], rax
  00060	eb 1a		 jmp	 SHORT $LN6@format_iob
$LN5@format_iob:
  00062	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0006a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  00072	e8 00 00 00 00	 call	 BytesToEndOfStorage
  00077	48 89 44 24 28	 mov	 QWORD PTR tv73[rsp], rax
$LN6@format_iob:
  0007c	8b 44 24 28	 mov	 eax, DWORD PTR tv73[rsp]
  00080	48 83 f8 10	 cmp	 rax, 16
  00084	76 0b		 jbe	 SHORT $LN9@format_iob
  00086	48 c7 44 24 38
	10 00 00 00	 mov	 QWORD PTR tv89[rsp], 16
  0008f	eb 5c		 jmp	 SHORT $LN10@format_iob
$LN9@format_iob:
  00091	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00098	48 89 44 24 48	 mov	 QWORD PTR tv77[rsp], rax
  0009d	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  000a5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  000ad	e8 00 00 00 00	 call	 BytesToEndOfStorage
  000b2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv77[rsp]
  000b7	48 3b c8	 cmp	 rcx, rax
  000ba	73 0e		 jae	 SHORT $LN7@format_iob
  000bc	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  000c3	48 89 44 24 30	 mov	 QWORD PTR tv86[rsp], rax
  000c8	eb 1a		 jmp	 SHORT $LN8@format_iob
$LN7@format_iob:
  000ca	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  000d2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  000da	e8 00 00 00 00	 call	 BytesToEndOfStorage
  000df	48 89 44 24 30	 mov	 QWORD PTR tv86[rsp], rax
$LN8@format_iob:
  000e4	8b 44 24 30	 mov	 eax, DWORD PTR tv86[rsp]
  000e8	48 89 44 24 38	 mov	 QWORD PTR tv89[rsp], rax
$LN10@format_iob:
  000ed	8b 44 24 38	 mov	 eax, DWORD PTR tv89[rsp]
  000f1	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 669  : 
; 670  :     if (k)

  000f5	83 7c 24 20 00	 cmp	 DWORD PTR k$[rsp], 0
  000fa	74 61		 je	 SHORT $LN2@format_iob

; 671  :     {
; 672  :         memcpy(workarea, dev->mainstor + addr, k);

  000fc	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  00100	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00108	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  0010f	48 03 8c 24 90
	00 00 00	 add	 rcx, QWORD PTR addr$[rsp]
  00117	48 8d 54 24 50	 lea	 rdx, QWORD PTR workarea$[rsp]
  0011c	48 8b fa	 mov	 rdi, rdx
  0011f	48 8b f1	 mov	 rsi, rcx
  00122	8b c8		 mov	 ecx, eax
  00124	f3 a4		 rep movsb

; 673  :         memcpy(dest, "=>", 2);

  00126	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
  0012e	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR $SG170191
  00135	66 89 08	 mov	 WORD PTR [rax], cx

; 674  :         format_data(dest + 2, 52, workarea,  k);

  00138	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
  00140	48 83 c0 02	 add	 rax, 2
  00144	44 8b 4c 24 20	 mov	 r9d, DWORD PTR k$[rsp]
  00149	4c 8d 44 24 50	 lea	 r8, QWORD PTR workarea$[rsp]
  0014e	ba 34 00 00 00	 mov	 edx, 52			; 00000034H
  00153	48 8b c8	 mov	 rcx, rax
  00156	e8 00 00 00 00	 call	 _format_data

; 675  :     }

  0015b	eb 0b		 jmp	 SHORT $LN3@format_iob
$LN2@format_iob:

; 676  :     else
; 677  :         *dest = 0;

  0015d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
  00165	c6 00 00	 mov	 BYTE PTR [rax], 0
$LN3@format_iob:

; 678  : 
; 679  : } /* end function format_iobuf_data */

  00168	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0016d	48 33 cc	 xor	 rcx, rsp
  00170	e8 00 00 00 00	 call	 __security_check_cookie
  00175	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00179	5f		 pop	 rdi
  0017a	5e		 pop	 rsi
  0017b	c3		 ret	 0
format_iobuf_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
j$ = 160
k$ = 164
tv65 = 168
i$ = 172
tv154 = 176
tv158 = 180
tv176 = 184
buffer$ = 272
buflen$ = 280
a$ = 288
len$ = 296
_format_data PROC

; 608  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	53		 push	 rbx
  00014	55		 push	 rbp
  00015	56		 push	 rsi
  00016	57		 push	 rdi
  00017	41 54		 push	 r12
  00019	41 55		 push	 r13
  0001b	41 56		 push	 r14
  0001d	41 57		 push	 r15
  0001f	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 609  : u_int   i, k;                           /* Array subscripts          */
; 610  : int     j;
; 611  : 
; 612  :     k = MIN(len, 16);

  00026	83 bc 24 28 01
	00 00 10	 cmp	 DWORD PTR len$[rsp], 16
  0002e	73 10		 jae	 SHORT $LN11@format_dat
  00030	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00037	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv65[rsp], eax
  0003e	eb 0b		 jmp	 SHORT $LN12@format_dat
$LN11@format_dat:
  00040	c7 84 24 a8 00
	00 00 10 00 00
	00		 mov	 DWORD PTR tv65[rsp], 16
$LN12@format_dat:
  0004b	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv65[rsp]
  00052	89 84 24 a4 00
	00 00		 mov	 DWORD PTR k$[rsp], eax

; 613  : 
; 614  :     if (k)

  00059	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR k$[rsp], 0
  00061	0f 84 2d 03 00
	00		 je	 $LN2@format_dat

; 615  :     {
; 616  :         j = snprintf((char *)buffer, buflen,

  00067	b8 01 00 00 00	 mov	 eax, 1
  0006c	48 6b c0 0f	 imul	 rax, rax, 15
  00070	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00078	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0007c	b9 01 00 00 00	 mov	 ecx, 1
  00081	48 6b c9 0e	 imul	 rcx, rcx, 14
  00085	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR a$[rsp]
  0008d	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00091	ba 01 00 00 00	 mov	 edx, 1
  00096	48 6b d2 0d	 imul	 rdx, rdx, 13
  0009a	4c 8b 84 24 20
	01 00 00	 mov	 r8, QWORD PTR a$[rsp]
  000a2	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  000a7	41 b8 01 00 00
	00		 mov	 r8d, 1
  000ad	4d 6b c0 0c	 imul	 r8, r8, 12
  000b1	4c 8b 8c 24 20
	01 00 00	 mov	 r9, QWORD PTR a$[rsp]
  000b9	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  000be	41 b9 01 00 00
	00		 mov	 r9d, 1
  000c4	4d 6b c9 0b	 imul	 r9, r9, 11
  000c8	4c 8b 94 24 20
	01 00 00	 mov	 r10, QWORD PTR a$[rsp]
  000d0	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  000d5	41 ba 01 00 00
	00		 mov	 r10d, 1
  000db	4d 6b d2 0a	 imul	 r10, r10, 10
  000df	4c 8b 9c 24 20
	01 00 00	 mov	 r11, QWORD PTR a$[rsp]
  000e7	47 0f b6 14 13	 movzx	 r10d, BYTE PTR [r11+r10]
  000ec	41 bb 01 00 00
	00		 mov	 r11d, 1
  000f2	4d 6b db 09	 imul	 r11, r11, 9
  000f6	48 8b 9c 24 20
	01 00 00	 mov	 rbx, QWORD PTR a$[rsp]
  000fe	42 0f b6 1c 1b	 movzx	 ebx, BYTE PTR [rbx+r11]
  00103	41 bb 01 00 00
	00		 mov	 r11d, 1
  00109	4d 6b db 08	 imul	 r11, r11, 8
  0010d	48 8b bc 24 20
	01 00 00	 mov	 rdi, QWORD PTR a$[rsp]
  00115	42 0f b6 3c 1f	 movzx	 edi, BYTE PTR [rdi+r11]
  0011a	41 bb 01 00 00
	00		 mov	 r11d, 1
  00120	4d 6b db 07	 imul	 r11, r11, 7
  00124	48 8b b4 24 20
	01 00 00	 mov	 rsi, QWORD PTR a$[rsp]
  0012c	42 0f b6 34 1e	 movzx	 esi, BYTE PTR [rsi+r11]
  00131	41 bb 01 00 00
	00		 mov	 r11d, 1
  00137	4d 6b db 06	 imul	 r11, r11, 6
  0013b	48 8b ac 24 20
	01 00 00	 mov	 rbp, QWORD PTR a$[rsp]
  00143	41 0f b6 2c 2b	 movzx	 ebp, BYTE PTR [r11+rbp]
  00148	41 bb 01 00 00
	00		 mov	 r11d, 1
  0014e	4d 6b db 05	 imul	 r11, r11, 5
  00152	4c 8b b4 24 20
	01 00 00	 mov	 r14, QWORD PTR a$[rsp]
  0015a	47 0f b6 1c 1e	 movzx	 r11d, BYTE PTR [r14+r11]
  0015f	41 be 01 00 00
	00		 mov	 r14d, 1
  00165	4d 6b f6 04	 imul	 r14, r14, 4
  00169	4c 8b bc 24 20
	01 00 00	 mov	 r15, QWORD PTR a$[rsp]
  00171	47 0f b6 34 37	 movzx	 r14d, BYTE PTR [r15+r14]
  00176	41 bf 01 00 00
	00		 mov	 r15d, 1
  0017c	4d 6b ff 03	 imul	 r15, r15, 3
  00180	4c 8b a4 24 20
	01 00 00	 mov	 r12, QWORD PTR a$[rsp]
  00188	47 0f b6 3c 3c	 movzx	 r15d, BYTE PTR [r12+r15]
  0018d	41 bc 01 00 00
	00		 mov	 r12d, 1
  00193	4d 6b e4 02	 imul	 r12, r12, 2
  00197	4c 8b ac 24 20
	01 00 00	 mov	 r13, QWORD PTR a$[rsp]
  0019f	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  001a4	44 89 a4 24 b0
	00 00 00	 mov	 DWORD PTR tv154[rsp], r12d
  001ac	41 bd 01 00 00
	00		 mov	 r13d, 1
  001b2	4d 6b ed 01	 imul	 r13, r13, 1
  001b6	4c 8b a4 24 20
	01 00 00	 mov	 r12, QWORD PTR a$[rsp]
  001be	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  001c3	44 89 a4 24 b4
	00 00 00	 mov	 DWORD PTR tv158[rsp], r12d
  001cb	41 bd 01 00 00
	00		 mov	 r13d, 1
  001d1	4d 6b ed 00	 imul	 r13, r13, 0
  001d5	4c 8b a4 24 20
	01 00 00	 mov	 r12, QWORD PTR a$[rsp]
  001dd	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  001e2	44 8b ac 24 18
	01 00 00	 mov	 r13d, DWORD PTR buflen$[rsp]
  001ea	89 84 24 90 00
	00 00		 mov	 DWORD PTR [rsp+144], eax
  001f1	89 8c 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], ecx
  001f8	89 94 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], edx
  001ff	44 89 44 24 78	 mov	 DWORD PTR [rsp+120], r8d
  00204	44 89 4c 24 70	 mov	 DWORD PTR [rsp+112], r9d
  00209	44 89 54 24 68	 mov	 DWORD PTR [rsp+104], r10d
  0020e	89 5c 24 60	 mov	 DWORD PTR [rsp+96], ebx
  00212	89 7c 24 58	 mov	 DWORD PTR [rsp+88], edi
  00216	89 74 24 50	 mov	 DWORD PTR [rsp+80], esi
  0021a	89 6c 24 48	 mov	 DWORD PTR [rsp+72], ebp
  0021e	44 89 5c 24 40	 mov	 DWORD PTR [rsp+64], r11d
  00223	44 89 74 24 38	 mov	 DWORD PTR [rsp+56], r14d
  00228	44 89 7c 24 30	 mov	 DWORD PTR [rsp+48], r15d
  0022d	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv154[rsp]
  00234	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00238	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR tv158[rsp]
  0023f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00243	45 8b cc	 mov	 r9d, r12d
  00246	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170156
  0024d	41 8b d5	 mov	 edx, r13d
  00250	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  00258	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  0025e	89 84 24 a0 00
	00 00		 mov	 DWORD PTR j$[rsp], eax

; 617  :                 "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X "
; 618  :                 "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X",
; 619  :                 a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7],
; 620  :                 a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
; 621  :         if (j < 0)

  00265	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR j$[rsp], 0
  0026d	7d 10		 jge	 SHORT $LN4@format_dat

; 622  :             *buffer = 0;

  0026f	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  00277	c6 00 00	 mov	 BYTE PTR [rax], 0
  0027a	e9 13 01 00 00	 jmp	 $LN5@format_dat
$LN4@format_dat:

; 623  :         else
; 624  :         {
; 625  :             /* Blank out unused data */
; 626  :             if (k != 16)

  0027f	83 bc 24 a4 00
	00 00 10	 cmp	 DWORD PTR k$[rsp], 16
  00287	74 5e		 je	 SHORT $LN6@format_dat

; 627  :             {
; 628  :                 i = (k << 1) + (k >> 2);

  00289	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  00290	c1 e8 02	 shr	 eax, 2
  00293	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR k$[rsp]
  0029a	8d 04 48	 lea	 eax, DWORD PTR [rax+rcx*2]
  0029d	89 84 24 ac 00
	00 00		 mov	 DWORD PTR i$[rsp], eax

; 629  :                 memset(buffer + i, ' ', j - i);

  002a4	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  002ab	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR j$[rsp]
  002b2	2b c8		 sub	 ecx, eax
  002b4	8b c1		 mov	 eax, ecx
  002b6	8b c0		 mov	 eax, eax
  002b8	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv176[rsp], rax
  002c0	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  002c7	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR buffer$[rsp]
  002cf	48 03 d1	 add	 rdx, rcx
  002d2	48 8b ca	 mov	 rcx, rdx
  002d5	48 8b f9	 mov	 rdi, rcx
  002d8	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  002dd	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv176[rsp]
  002e5	f3 aa		 rep stosb
$LN6@format_dat:

; 630  :             }
; 631  : 
; 632  :             /* If space is available, add translation */
; 633  :             if ((u_int)j < buflen)

  002e7	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR buflen$[rsp]
  002ee	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR j$[rsp], eax
  002f5	0f 83 97 00 00
	00		 jae	 $LN7@format_dat

; 634  :             {
; 635  :                 /* Insert blank separator */
; 636  :                 buffer[j++] = ' ';

  002fb	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR j$[rsp]
  00303	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  0030b	c6 04 01 20	 mov	 BYTE PTR [rcx+rax], 32	; 00000020H
  0030f	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  00316	ff c0		 inc	 eax
  00318	89 84 24 a0 00
	00 00		 mov	 DWORD PTR j$[rsp], eax

; 637  : 
; 638  :                 /* If space still available, complete translation */
; 639  :                 if ((u_int)j < buflen)

  0031f	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR buflen$[rsp]
  00326	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR j$[rsp], eax
  0032d	73 63		 jae	 SHORT $LN8@format_dat

; 640  :                 {
; 641  :                     /* Adjust data display size if necessary */
; 642  :                     if ((j + k) > buflen)

  0032f	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  00336	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR j$[rsp]
  0033d	03 c8		 add	 ecx, eax
  0033f	8b c1		 mov	 eax, ecx
  00341	3b 84 24 18 01
	00 00		 cmp	 eax, DWORD PTR buflen$[rsp]
  00348	76 19		 jbe	 SHORT $LN9@format_dat

; 643  :                         k = buflen - j;

  0034a	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  00351	8b 8c 24 18 01
	00 00		 mov	 ecx, DWORD PTR buflen$[rsp]
  00358	2b c8		 sub	 ecx, eax
  0035a	8b c1		 mov	 eax, ecx
  0035c	89 84 24 a4 00
	00 00		 mov	 DWORD PTR k$[rsp], eax
$LN9@format_dat:

; 644  : 
; 645  :                     /* Append translation */
; 646  :                     prt_guest_to_host(a, buffer + j, k);

  00363	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR j$[rsp]
  0036b	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  00373	48 03 c8	 add	 rcx, rax
  00376	48 8b c1	 mov	 rax, rcx
  00379	44 8b 84 24 a4
	00 00 00	 mov	 r8d, DWORD PTR k$[rsp]
  00381	48 8b d0	 mov	 rdx, rax
  00384	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0038c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_prt_guest_to_host
$LN8@format_dat:
$LN7@format_dat:
$LN5@format_dat:

; 647  :                 }
; 648  :             }
; 649  :         }
; 650  : 
; 651  :     }

  00392	eb 0b		 jmp	 SHORT $LN3@format_dat
$LN2@format_dat:

; 652  :     else
; 653  :         *buffer = 0;

  00394	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  0039c	c6 00 00	 mov	 BYTE PTR [rax], 0
$LN3@format_dat:

; 654  : 
; 655  : } /* end function format_data */

  0039f	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  003a6	41 5f		 pop	 r15
  003a8	41 5e		 pop	 r14
  003aa	41 5d		 pop	 r13
  003ac	41 5c		 pop	 r12
  003ae	5f		 pop	 rdi
  003af	5e		 pop	 rsi
  003b0	5d		 pop	 rbp
  003b1	5b		 pop	 rbx
  003b2	c3		 ret	 0
_format_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
to$ = 8
from$ = 16
length$ = 24
memcpy_backwards PROC

; 588  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 589  :     if (length)

  0000f	83 7c 24 18 00	 cmp	 DWORD PTR length$[rsp], 0
  00014	74 68		 je	 SHORT $LN5@memcpy_bac

; 590  :     {
; 591  :         for (to += length, from += length; length; --length)

  00016	48 63 44 24 18	 movsxd	 rax, DWORD PTR length$[rsp]
  0001b	48 8b 4c 24 08	 mov	 rcx, QWORD PTR to$[rsp]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx
  00026	48 89 44 24 08	 mov	 QWORD PTR to$[rsp], rax
  0002b	48 63 44 24 18	 movsxd	 rax, DWORD PTR length$[rsp]
  00030	48 8b 4c 24 10	 mov	 rcx, QWORD PTR from$[rsp]
  00035	48 03 c8	 add	 rcx, rax
  00038	48 8b c1	 mov	 rax, rcx
  0003b	48 89 44 24 10	 mov	 QWORD PTR from$[rsp], rax
  00040	eb 0a		 jmp	 SHORT $LN4@memcpy_bac
$LN2@memcpy_bac:
  00042	8b 44 24 18	 mov	 eax, DWORD PTR length$[rsp]
  00046	ff c8		 dec	 eax
  00048	89 44 24 18	 mov	 DWORD PTR length$[rsp], eax
$LN4@memcpy_bac:
  0004c	83 7c 24 18 00	 cmp	 DWORD PTR length$[rsp], 0
  00051	74 2b		 je	 SHORT $LN3@memcpy_bac

; 592  :             *(--to) = *(--from);

  00053	48 8b 44 24 10	 mov	 rax, QWORD PTR from$[rsp]
  00058	48 ff c8	 dec	 rax
  0005b	48 89 44 24 10	 mov	 QWORD PTR from$[rsp], rax
  00060	48 8b 44 24 08	 mov	 rax, QWORD PTR to$[rsp]
  00065	48 ff c8	 dec	 rax
  00068	48 89 44 24 08	 mov	 QWORD PTR to$[rsp], rax
  0006d	48 8b 44 24 08	 mov	 rax, QWORD PTR to$[rsp]
  00072	48 8b 4c 24 10	 mov	 rcx, QWORD PTR from$[rsp]
  00077	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0007a	88 08		 mov	 BYTE PTR [rax], cl
  0007c	eb c4		 jmp	 SHORT $LN2@memcpy_bac
$LN3@memcpy_bac:
$LN5@memcpy_bac:

; 593  :     }
; 594  : }

  0007e	c3		 ret	 0
memcpy_backwards ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv71 = 32
dev$ = 64
clrbsy$ = 72
queue_io_interrupt_and_update_status PROC

; 548  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 549  :     if (likely(dev->scsw.flag3 & SCSW3_SC_PEND))

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00012	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00019	83 e0 01	 and	 eax, 1
  0001c	85 c0		 test	 eax, eax
  0001e	74 0a		 je	 SHORT $LN7@queue_io_i
  00020	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv71[rsp], 1
  00028	eb 08		 jmp	 SHORT $LN8@queue_io_i
$LN7@queue_io_i:
  0002a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
$LN8@queue_io_i:
  00032	83 7c 24 20 00	 cmp	 DWORD PTR tv71[rsp], 0
  00037	74 61		 je	 SHORT $LN2@queue_io_i

; 550  :     {
; 551  :         OBTAIN_INTLOCK(NULL);

  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170117
  00040	33 c9		 xor	 ecx, ecx
  00042	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 552  :         obtain_lock(&dev->lock);

  00047	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0004c	48 83 c0 38	 add	 rax, 56			; 00000038H
  00050	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170118
  00057	48 8b c8	 mov	 rcx, rax
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 553  :         queue_io_interrupt_and_update_status_locked(dev,clrbsy);

  00060	8b 54 24 48	 mov	 edx, DWORD PTR clrbsy$[rsp]
  00064	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00069	e8 00 00 00 00	 call	 queue_io_interrupt_and_update_status_locked

; 554  : 
; 555  :         /* Finish releasing locks */
; 556  :         release_lock(&dev->lock);

  0006e	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00073	48 83 c0 38	 add	 rax, 56			; 00000038H
  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170119
  0007e	48 8b c8	 mov	 rcx, rax
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 557  :         RELEASE_INTLOCK(NULL);

  00087	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170120
  0008e	33 c9		 xor	 ecx, ecx
  00090	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 558  :     }

  00095	e9 94 00 00 00	 jmp	 $LN3@queue_io_i
$LN2@queue_io_i:

; 559  : #if defined( OPTION_SHARED_DEVICES )
; 560  :     else    /* No interrupt pending */
; 561  :     {
; 562  :         /* Wake up any waiters if the device isn't active or reserved */
; 563  :         if (!(dev->scsw.flag3 & (SCSW3_AC_SCHAC | SCSW3_AC_DEVAC)) &&

  0009a	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0009f	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  000a6	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  000ab	85 c0		 test	 eax, eax
  000ad	75 7f		 jne	 SHORT $LN4@queue_io_i
  000af	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000b4	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000ba	c1 e8 14	 shr	 eax, 20
  000bd	83 e0 01	 and	 eax, 1
  000c0	85 c0		 test	 eax, eax
  000c2	75 6a		 jne	 SHORT $LN4@queue_io_i

; 564  :             !dev->reserved)
; 565  :         {
; 566  :             obtain_lock(&dev->lock);

  000c4	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000c9	48 83 c0 38	 add	 rax, 56			; 00000038H
  000cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170122
  000d4	48 8b c8	 mov	 rcx, rax
  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 567  :             dev->shioactive = DEV_SYS_NONE;

  000dd	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000e2	c7 80 e4 05 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1508], 0

; 568  :             if (dev->shiowaiters)

  000ec	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000f1	83 b8 e0 05 00
	00 00		 cmp	 DWORD PTR [rax+1504], 0
  000f8	74 1b		 je	 SHORT $LN5@queue_io_i

; 569  :                 signal_condition (&dev->shiocond);

  000fa	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000ff	48 05 d8 05 00
	00		 add	 rax, 1496		; 000005d8H
  00105	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170124
  0010c	48 8b c8	 mov	 rcx, rax
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN5@queue_io_i:

; 570  :             release_lock(&dev->lock);

  00115	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0011a	48 83 c0 38	 add	 rax, 56			; 00000038H
  0011e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170125
  00125	48 8b c8	 mov	 rcx, rax
  00128	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN4@queue_io_i:
$LN3@queue_io_i:

; 571  :         }
; 572  :     }
; 573  : #endif // defined( OPTION_SHARED_DEVICES )
; 574  : }

  0012e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00132	c3		 ret	 0
queue_io_interrupt_and_update_status ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
dev$ = 48
clrbsy$ = 56
queue_io_interrupt_and_update_status_locked PROC

; 502  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 503  :     /* Get the I/O interrupt queue lock */
; 504  :     obtain_lock(&sysblk.iointqlk);

  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00014	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170098
  00021	48 8b c8	 mov	 rcx, rax
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 505  : 
; 506  :     /* Ensure the interrupt is queued/dequeued per pending flag */
; 507  :     if (dev->scsw.flag3 & SCSW3_SC_PEND)

  0002a	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0002f	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00036	83 e0 01	 and	 eax, 1
  00039	85 c0		 test	 eax, eax
  0003b	74 21		 je	 SHORT $LN2@queue_io_i

; 508  :         QUEUE_IO_INTERRUPT_QLOCKED(&dev->ioint,clrbsy);

  0003d	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00042	48 05 28 02 00
	00		 add	 rax, 552		; 00000228H
  00048	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170101
  0004f	0f b6 54 24 38	 movzx	 edx, BYTE PTR clrbsy$[rsp]
  00054	48 8b c8	 mov	 rcx, rax
  00057	e8 00 00 00 00	 call	 Queue_IO_Interrupt_QLocked
  0005c	eb 1a		 jmp	 SHORT $LN3@queue_io_i
$LN2@queue_io_i:

; 509  :     else
; 510  :         DEQUEUE_IO_INTERRUPT_QLOCKED(&dev->ioint);

  0005e	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00063	48 05 28 02 00
	00		 add	 rax, 552		; 00000228H
  00069	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170102
  00070	48 8b c8	 mov	 rcx, rax
  00073	e8 00 00 00 00	 call	 Dequeue_IO_Interrupt_QLocked
$LN3@queue_io_i:

; 511  : 
; 512  :     /* Perform cleanup for DEVBLK flags being deprecated */
; 513  :     subchannel_interrupt_queue_cleanup(dev);

  00078	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0007d	e8 00 00 00 00	 call	 subchannel_interrupt_queue_cleanup

; 514  : 
; 515  :     /* Update interrupts */
; 516  :     UPDATE_IC_IOPENDING_QLOCKED();

  00082	e8 00 00 00 00	 call	 Update_IC_IOPENDING_QLocked

; 517  : 
; 518  :     /* Release the I/O interrupt queue lock */
; 519  :     release_lock(&sysblk.iointqlk);

  00087	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0008e	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  00094	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170103
  0009b	48 8b c8	 mov	 rcx, rax
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 520  : 
; 521  : #if defined( OPTION_SHARED_DEVICES )
; 522  :     /* Wake up any waiters if the device isn't active or reserved */
; 523  :     if (!(dev->scsw.flag3 & (SCSW3_AC_SCHAC | SCSW3_AC_DEVAC)) &&

  000a4	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  000a9	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  000b0	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  000b5	85 c0		 test	 eax, eax
  000b7	75 4d		 jne	 SHORT $LN4@queue_io_i
  000b9	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  000be	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000c4	c1 e8 14	 shr	 eax, 20
  000c7	83 e0 01	 and	 eax, 1
  000ca	85 c0		 test	 eax, eax
  000cc	75 38		 jne	 SHORT $LN4@queue_io_i

; 524  :         !dev->reserved)
; 525  :     {
; 526  :         dev->shioactive = DEV_SYS_NONE;

  000ce	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  000d3	c7 80 e4 05 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1508], 0

; 527  :         if (dev->shiowaiters)

  000dd	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  000e2	83 b8 e0 05 00
	00 00		 cmp	 DWORD PTR [rax+1504], 0
  000e9	74 1b		 je	 SHORT $LN5@queue_io_i

; 528  :             signal_condition (&dev->shiocond);

  000eb	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  000f0	48 05 d8 05 00
	00		 add	 rax, 1496		; 000005d8H
  000f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170106
  000fd	48 8b c8	 mov	 rcx, rax
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN5@queue_io_i:
$LN4@queue_io_i:

; 529  :     }
; 530  : #endif // defined( OPTION_SHARED_DEVICES )
; 531  : }

  00106	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010a	c3		 ret	 0
queue_io_interrupt_and_update_status_locked ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
result$ = 0
scsw$ = 32
AIPSX	PROC

; 478  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 479  :     U8  result =  (scsw->flag1 & SCSW1_A)           /* >> 4 << 4  */

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR scsw$[rsp]
  0000e	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00012	83 e0 10	 and	 eax, 16
  00015	48 8b 4c 24 20	 mov	 rcx, QWORD PTR scsw$[rsp]
  0001a	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0001e	83 e1 20	 and	 ecx, 32			; 00000020H
  00021	c1 f9 02	 sar	 ecx, 2
  00024	48 8b 54 24 20	 mov	 rdx, QWORD PTR scsw$[rsp]
  00029	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  0002c	83 e2 08	 and	 edx, 8
  0002f	c1 fa 02	 sar	 edx, 2
  00032	0b ca		 or	 ecx, edx
  00034	0b c1		 or	 eax, ecx
  00036	48 8b 4c 24 20	 mov	 rcx, QWORD PTR scsw$[rsp]
  0003b	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0003f	83 e1 40	 and	 ecx, 64			; 00000040H
  00042	c1 f9 04	 sar	 ecx, 4
  00045	0b c1		 or	 eax, ecx
  00047	48 8b 4c 24 20	 mov	 rcx, QWORD PTR scsw$[rsp]
  0004c	0f b6 49 03	 movzx	 ecx, BYTE PTR [rcx+3]
  00050	83 e1 01	 and	 ecx, 1
  00053	0b c1		 or	 eax, ecx
  00055	88 04 24	 mov	 BYTE PTR result$[rsp], al

; 480  :                | ((scsw->flag1 & SCSW1_I) >> 2      /* >> 5 << 3  */
; 481  :                |  (scsw->flag0 & SCSW0_S) >> 2)     /* >> 3 << 1  */
; 482  :                | ((scsw->flag1 & SCSW1_P) >> 4)     /* >> 6 << 2  */
; 483  :                |  (scsw->flag3 & SCSW3_SC_PEND);    /* >> 0 << 0  */
; 484  :     return (result);

  00058	0f b6 04 24	 movzx	 eax, BYTE PTR result$[rsp]

; 485  : }

  0005c	48 83 c4 18	 add	 rsp, 24
  00060	c3		 ret	 0
AIPSX	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
scsw$ = 8
scsw_clear_sc_Cs PROC

; 460  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 461  :     scsw->flag3 &= ~(SCSW3_SC_ALERT |

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR scsw$[rsp]
  0000a	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0000e	83 e0 e0	 and	 eax, -32		; ffffffffffffffe0H
  00011	48 8b 4c 24 08	 mov	 rcx, QWORD PTR scsw$[rsp]
  00016	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 462  :                      SCSW3_SC_INTER |
; 463  :                      SCSW3_SC_PRI   |
; 464  :                      SCSW3_SC_SEC   |
; 465  :                      SCSW3_SC_PEND);
; 466  : }

  00019	c3		 ret	 0
scsw_clear_sc_Cs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
scsw$ = 48
scsw_clear_ac_Nr PROC

; 443  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 444  :     if (scsw->flag2 & SCSW2_FC_START &&

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR scsw$[rsp]
  0000e	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00012	83 e0 40	 and	 eax, 64			; 00000040H
  00015	85 c0		 test	 eax, eax
  00017	74 4a		 je	 SHORT $LN2@scsw_clear
  00019	48 8b 44 24 30	 mov	 rax, QWORD PTR scsw$[rsp]
  0001e	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00022	83 e0 20	 and	 eax, 32			; 00000020H
  00025	85 c0		 test	 eax, eax
  00027	74 3a		 je	 SHORT $LN2@scsw_clear

; 445  :         scsw->flag3 & SCSW3_AC_SUSP)
; 446  :     {
; 447  :         if (scsw->flag2 & SCSW2_FC_HALT)

  00029	48 8b 44 24 30	 mov	 rax, QWORD PTR scsw$[rsp]
  0002e	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00032	83 e0 20	 and	 eax, 32			; 00000020H
  00035	85 c0		 test	 eax, eax
  00037	74 0c		 je	 SHORT $LN3@scsw_clear

; 448  :             scsw_clear_ac_Cp(scsw);

  00039	48 8b 4c 24 30	 mov	 rcx, QWORD PTR scsw$[rsp]
  0003e	e8 00 00 00 00	 call	 scsw_clear_ac_Cp
  00043	eb 1e		 jmp	 SHORT $LN4@scsw_clear
$LN3@scsw_clear:

; 449  :         else
; 450  :         {
; 451  :             scsw->flag2 &= ~SCSW2_AC_RESUM;

  00045	48 8b 44 24 30	 mov	 rax, QWORD PTR scsw$[rsp]
  0004a	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0004e	83 e0 f7	 and	 eax, -9
  00051	48 8b 4c 24 30	 mov	 rcx, QWORD PTR scsw$[rsp]
  00056	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 452  :             scsw_clear_n_C(scsw);

  00059	48 8b 4c 24 30	 mov	 rcx, QWORD PTR scsw$[rsp]
  0005e	e8 00 00 00 00	 call	 scsw_clear_n_C
$LN4@scsw_clear:
$LN2@scsw_clear:

; 453  :         }
; 454  :     }
; 455  : }

  00063	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00067	c3		 ret	 0
scsw_clear_ac_Nr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
scsw$ = 8
scsw_clear_ac_Cp PROC

; 432  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 433  :     scsw->flag2 &= ~(SCSW2_AC_RESUM |

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR scsw$[rsp]
  0000a	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0000e	83 e0 f0	 and	 eax, -16
  00011	48 8b 4c 24 08	 mov	 rcx, QWORD PTR scsw$[rsp]
  00016	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 434  :                          SCSW2_AC_START |
; 435  :                          SCSW2_AC_HALT  |
; 436  :                          SCSW2_AC_CLEAR);
; 437  :     scsw->flag3 &= ~SCSW3_AC_SUSP;

  00019	48 8b 44 24 08	 mov	 rax, QWORD PTR scsw$[rsp]
  0001e	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00022	83 e0 df	 and	 eax, -33		; ffffffffffffffdfH
  00025	48 8b 4c 24 08	 mov	 rcx, QWORD PTR scsw$[rsp]
  0002a	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 438  : }

  0002d	c3		 ret	 0
scsw_clear_ac_Cp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
scsw$ = 48
scsw_clear_fc_Nc PROC

; 423  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 424  :     if (scsw->flag2 & SCSW2_FC_HALT &&

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR scsw$[rsp]
  0000e	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00012	83 e0 20	 and	 eax, 32			; 00000020H
  00015	85 c0		 test	 eax, eax
  00017	74 1a		 je	 SHORT $LN2@scsw_clear
  00019	48 8b 44 24 30	 mov	 rax, QWORD PTR scsw$[rsp]
  0001e	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00022	83 e0 20	 and	 eax, 32			; 00000020H
  00025	85 c0		 test	 eax, eax
  00027	74 0a		 je	 SHORT $LN2@scsw_clear

; 425  :         scsw->flag3 & SCSW3_AC_SUSP)
; 426  :         scsw_clear_fc_C(scsw);

  00029	48 8b 4c 24 30	 mov	 rcx, QWORD PTR scsw$[rsp]
  0002e	e8 00 00 00 00	 call	 scsw_clear_fc_C
$LN2@scsw_clear:

; 427  : }

  00033	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00037	c3		 ret	 0
scsw_clear_fc_Nc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
scsw$ = 8
scsw_clear_fc_C PROC

; 416  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 417  :     scsw->flag2 &= ~SCSW2_FC;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR scsw$[rsp]
  0000a	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0000e	83 e0 8f	 and	 eax, -113		; ffffffffffffff8fH
  00011	48 8b 4c 24 08	 mov	 rcx, QWORD PTR scsw$[rsp]
  00016	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 418  : }

  00019	c3		 ret	 0
scsw_clear_fc_C ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
scsw$ = 8
scsw_clear_q_C PROC

; 409  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 410  :     scsw->flag2 &= ~SCSW2_Q;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR scsw$[rsp]
  0000a	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0000e	0f ba f0 07	 btr	 eax, 7
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR scsw$[rsp]
  00017	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 411  : }

  0001a	c3		 ret	 0
scsw_clear_q_C ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
scsw$ = 8
scsw_clear_n_C PROC

; 402  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 403  :     scsw->flag1 &= ~SCSW1_N;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR scsw$[rsp]
  0000a	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0000e	83 e0 fe	 and	 eax, -2
  00011	48 8b 4c 24 08	 mov	 rcx, QWORD PTR scsw$[rsp]
  00016	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 404  : }

  00019	c3		 ret	 0
scsw_clear_n_C ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv70 = 0
tv75 = 8
addr$ = 32
dev$ = 40
BytesToEndOfStorage PROC

; 381  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 382  :     if (dev) return ((addr <= dev->mainlim)   ? (dev->mainlim+1  - addr) : 0);

  0000e	48 83 7c 24 28
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00014	74 3d		 je	 SHORT $LN2@BytesToEnd
  00016	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0001b	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00022	48 39 44 24 20	 cmp	 QWORD PTR addr$[rsp], rax
  00027	77 1a		 ja	 SHORT $LN5@BytesToEnd
  00029	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0002e	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00035	48 ff c0	 inc	 rax
  00038	48 2b 44 24 20	 sub	 rax, QWORD PTR addr$[rsp]
  0003d	48 89 04 24	 mov	 QWORD PTR tv70[rsp], rax
  00041	eb 08		 jmp	 SHORT $LN6@BytesToEnd
$LN5@BytesToEnd:
  00043	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR tv70[rsp], 0
$LN6@BytesToEnd:
  0004b	48 8b 04 24	 mov	 rax, QWORD PTR tv70[rsp]
  0004f	eb 42		 jmp	 SHORT $LN1@BytesToEnd
  00051	eb 40		 jmp	 SHORT $LN3@BytesToEnd
$LN2@BytesToEnd:

; 383  :     else     return ((addr < sysblk.mainsize) ? (sysblk.mainsize - addr) : 0);

  00053	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0005a	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00061	48 39 44 24 20	 cmp	 QWORD PTR addr$[rsp], rax
  00066	73 1d		 jae	 SHORT $LN7@BytesToEnd
  00068	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR addr$[rsp]
  00074	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0007b	48 2b c1	 sub	 rax, rcx
  0007e	48 89 44 24 08	 mov	 QWORD PTR tv75[rsp], rax
  00083	eb 09		 jmp	 SHORT $LN8@BytesToEnd
$LN7@BytesToEnd:
  00085	48 c7 44 24 08
	00 00 00 00	 mov	 QWORD PTR tv75[rsp], 0
$LN8@BytesToEnd:
  0008e	48 8b 44 24 08	 mov	 rax, QWORD PTR tv75[rsp]
$LN3@BytesToEnd:
$LN1@BytesToEnd:

; 384  : }

  00093	48 83 c4 18	 add	 rsp, 24
  00097	c3		 ret	 0
BytesToEndOfStorage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv78 = 32
iobufnew$ = 40
p$1 = 48
iobuf$ = 96
size$ = 104
iobuf_reallocate PROC

; 287  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 288  :     IOBUF *iobufnew;
; 289  :     /* PROGRAMMING NOTE: The tests below are purposely neither macros
; 290  :      * or inlined routines. This is to permit breakpoints during
; 291  :      * development and testing. In the future, instead of aborting
; 292  :      * and/or crashing, the code will branch (or longjmp) to a point in
; 293  :      * channel code where the current CCW chain will be terminated,
; 294  :      * cleanup performed, and a Channel Check, and/or a Machine Check,
; 295  :      * will be returned.
; 296  :      */
; 297  :     if (iobuf == NULL)

  0000f	48 83 7c 24 60
	00		 cmp	 QWORD PTR iobuf$[rsp], 0
  00015	75 07		 jne	 SHORT $LN5@iobuf_real

; 298  :         return NULL;

  00017	33 c0		 xor	 eax, eax
  00019	e9 98 00 00 00	 jmp	 $LN1@iobuf_real
$LN5@iobuf_real:

; 299  :     if (!iobuf_validate(iobuf))

  0001e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00023	e8 00 00 00 00	 call	 iobuf_validate
  00028	85 c0		 test	 eax, eax
  0002a	75 17		 jne	 SHORT $LN6@iobuf_real
$LN4@iobuf_real:

; 300  :         CRASH();

  0002c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00035	48 8b 44 24 30	 mov	 rax, QWORD PTR p$1[rsp]
  0003a	c6 00 00	 mov	 BYTE PTR [rax], 0
  0003d	33 c0		 xor	 eax, eax
  0003f	85 c0		 test	 eax, eax
  00041	75 e9		 jne	 SHORT $LN4@iobuf_real
$LN6@iobuf_real:

; 301  :     iobufnew = iobuf_create(size);

  00043	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  00047	e8 00 00 00 00	 call	 iobuf_create
  0004c	48 89 44 24 28	 mov	 QWORD PTR iobufnew$[rsp], rax

; 302  :     if (iobufnew == NULL)

  00051	48 83 7c 24 28
	00		 cmp	 QWORD PTR iobufnew$[rsp], 0
  00057	75 04		 jne	 SHORT $LN7@iobuf_real

; 303  :         return NULL;

  00059	33 c0		 xor	 eax, eax
  0005b	eb 59		 jmp	 SHORT $LN1@iobuf_real
$LN7@iobuf_real:

; 304  :     memcpy(iobufnew->start, iobuf->start, MIN(iobuf->size, size));

  0005d	48 8b 44 24 60	 mov	 rax, QWORD PTR iobuf$[rsp]
  00062	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  00066	39 08		 cmp	 DWORD PTR [rax], ecx
  00068	73 0d		 jae	 SHORT $LN10@iobuf_real
  0006a	48 8b 44 24 60	 mov	 rax, QWORD PTR iobuf$[rsp]
  0006f	8b 00		 mov	 eax, DWORD PTR [rax]
  00071	89 44 24 20	 mov	 DWORD PTR tv78[rsp], eax
  00075	eb 08		 jmp	 SHORT $LN11@iobuf_real
$LN10@iobuf_real:
  00077	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  0007b	89 44 24 20	 mov	 DWORD PTR tv78[rsp], eax
$LN11@iobuf_real:
  0007f	8b 44 24 20	 mov	 eax, DWORD PTR tv78[rsp]
  00083	48 8b 4c 24 28	 mov	 rcx, QWORD PTR iobufnew$[rsp]
  00088	48 8b 54 24 60	 mov	 rdx, QWORD PTR iobuf$[rsp]
  0008d	48 8b 79 08	 mov	 rdi, QWORD PTR [rcx+8]
  00091	48 8b 72 08	 mov	 rsi, QWORD PTR [rdx+8]
  00095	8b c8		 mov	 ecx, eax
  00097	f3 a4		 rep movsb

; 305  :     if (iobuf->size > IOBUF_MINSIZE)

  00099	48 8b 44 24 60	 mov	 rax, QWORD PTR iobuf$[rsp]
  0009e	81 38 00 00 01
	00		 cmp	 DWORD PTR [rax], 65536	; 00010000H
  000a4	76 0b		 jbe	 SHORT $LN8@iobuf_real

; 306  :         free_aligned(iobuf);

  000a6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR iobuf$[rsp]
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free
$LN8@iobuf_real:

; 307  :     return iobufnew;

  000b1	48 8b 44 24 28	 mov	 rax, QWORD PTR iobufnew$[rsp]
$LN1@iobuf_real:

; 308  : }

  000b6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ba	5f		 pop	 rdi
  000bb	5e		 pop	 rsi
  000bc	c3		 ret	 0
iobuf_reallocate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
p$1 = 32
iobuf$ = 64
iobuf_destroy PROC

; 268  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 269  :     /* PROGRAMMING NOTE: The tests below are purposely neither macros
; 270  :      * or inlined routines. This is to permit breakpoints during
; 271  :      * development and testing. In the future, instead of aborting
; 272  :      * and/or crashing, the code will branch (or longjmp) to a point in
; 273  :      * channel code where the current CCW chain will be terminated,
; 274  :      * cleanup performed, and a Channel Check, and/or a Machine Check,
; 275  :      * will be returned.
; 276  :      */
; 277  :     if (iobuf == NULL)

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR iobuf$[rsp], 0
  0000f	75 02		 jne	 SHORT $LN5@iobuf_dest

; 278  :         return;

  00011	eb 3d		 jmp	 SHORT $LN1@iobuf_dest
$LN5@iobuf_dest:

; 279  :     if (!iobuf_validate(iobuf))

  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00018	e8 00 00 00 00	 call	 iobuf_validate
  0001d	85 c0		 test	 eax, eax
  0001f	75 17		 jne	 SHORT $LN6@iobuf_dest
$LN4@iobuf_dest:

; 280  :         CRASH();

  00021	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  0002a	48 8b 44 24 20	 mov	 rax, QWORD PTR p$1[rsp]
  0002f	c6 00 00	 mov	 BYTE PTR [rax], 0
  00032	33 c0		 xor	 eax, eax
  00034	85 c0		 test	 eax, eax
  00036	75 e9		 jne	 SHORT $LN4@iobuf_dest
$LN6@iobuf_dest:

; 281  :     if (iobuf->size > IOBUF_MINSIZE)

  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR iobuf$[rsp]
  0003d	81 38 00 00 01
	00		 cmp	 DWORD PTR [rax], 65536	; 00010000H
  00043	76 0b		 jbe	 SHORT $LN7@iobuf_dest

; 282  :         free_aligned(iobuf);

  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free
$LN7@iobuf_dest:
$LN1@iobuf_dest:

; 283  : }

  00050	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00054	c3		 ret	 0
iobuf_destroy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv77 = 0
iobuf$ = 32
iobuf_validate PROC

; 257  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 258  :     return

  00009	48 83 7c 24 20
	00		 cmp	 QWORD PTR iobuf$[rsp], 0
  0000f	74 4b		 je	 SHORT $LN3@iobuf_vali
  00011	48 8b 44 24 20	 mov	 rax, QWORD PTR iobuf$[rsp]
  00016	81 38 00 00 01
	00		 cmp	 DWORD PTR [rax], 65536	; 00010000H
  0001c	72 3e		 jb	 SHORT $LN3@iobuf_vali
  0001e	48 8b 44 24 20	 mov	 rax, QWORD PTR iobuf$[rsp]
  00023	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00029	48 8b 4c 24 20	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0002e	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  00032	75 28		 jne	 SHORT $LN3@iobuf_vali
  00034	48 8b 44 24 20	 mov	 rax, QWORD PTR iobuf$[rsp]
  00039	8b 00		 mov	 eax, DWORD PTR [rax]
  0003b	ff c8		 dec	 eax
  0003d	8b c0		 mov	 eax, eax
  0003f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00044	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00048	48 8b 4c 24 20	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0004d	48 39 41 10	 cmp	 QWORD PTR [rcx+16], rax
  00051	75 09		 jne	 SHORT $LN3@iobuf_vali
  00053	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv77[rsp], 1
  0005a	eb 07		 jmp	 SHORT $LN4@iobuf_vali
$LN3@iobuf_vali:
  0005c	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv77[rsp], 0
$LN4@iobuf_vali:
  00063	8b 04 24	 mov	 eax, DWORD PTR tv77[rsp]

; 259  :     ((iobuf == NULL                         ||
; 260  :       iobuf->size < IOBUF_MINSIZE           ||
; 261  :       iobuf->start != (BYTE *)iobuf->data   ||
; 262  :       iobuf->end   != (BYTE *)iobuf->start + (iobuf->size - 1 )) ?
; 263  :      0 : 1);
; 264  : }

  00066	48 83 c4 18	 add	 rsp, 24
  0006a	c3		 ret	 0
iobuf_validate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv68 = 32
iobuf$ = 40
size$ = 64
iobuf_create PROC

; 246  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 247  :     IOBUF *iobuf;
; 248  :     size = ROUND_UP( size, IOBUF_INCREASE );

  00008	83 7c 24 40 00	 cmp	 DWORD PTR size$[rsp], 0
  0000d	74 1e		 je	 SHORT $LN4@iobuf_crea
  0000f	8b 44 24 40	 mov	 eax, DWORD PTR size$[rsp]
  00013	05 ff ff 0f 00	 add	 eax, 1048575		; 000fffffH
  00018	33 d2		 xor	 edx, edx
  0001a	b9 00 00 10 00	 mov	 ecx, 1048576		; 00100000H
  0001f	f7 f1		 div	 ecx
  00021	69 c0 00 00 10
	00		 imul	 eax, eax, 1048576	; 00100000H
  00027	89 44 24 20	 mov	 DWORD PTR tv68[rsp], eax
  0002b	eb 08		 jmp	 SHORT $LN5@iobuf_crea
$LN4@iobuf_crea:
  0002d	c7 44 24 20 00
	00 10 00	 mov	 DWORD PTR tv68[rsp], 1048576 ; 00100000H
$LN5@iobuf_crea:
  00035	8b 44 24 20	 mov	 eax, DWORD PTR tv68[rsp]
  00039	89 44 24 40	 mov	 DWORD PTR size$[rsp], eax

; 249  :     iobuf = (IOBUF*)malloc_aligned(offsetof(IOBUF,data) + size, IOBUF_ALIGN);

  0003d	8b 44 24 40	 mov	 eax, DWORD PTR size$[rsp]
  00041	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00047	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  0004c	48 8b c8	 mov	 rcx, rax
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_malloc
  00055	48 89 44 24 28	 mov	 QWORD PTR iobuf$[rsp], rax

; 250  :     if (iobuf != NULL)

  0005a	48 83 7c 24 28
	00		 cmp	 QWORD PTR iobuf$[rsp], 0
  00060	74 0e		 je	 SHORT $LN2@iobuf_crea

; 251  :         iobuf_initialize(iobuf, size);

  00062	8b 54 24 40	 mov	 edx, DWORD PTR size$[rsp]
  00066	48 8b 4c 24 28	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0006b	e8 00 00 00 00	 call	 iobuf_initialize
$LN2@iobuf_crea:

; 252  :     return iobuf;

  00070	48 8b 44 24 28	 mov	 rax, QWORD PTR iobuf$[rsp]

; 253  : }

  00075	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00079	c3		 ret	 0
iobuf_create ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
iobuf$ = 8
size$ = 16
iobuf_initialize PROC

; 238  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 239  :     iobuf->size  = size;

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR iobuf$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR size$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 240  :     iobuf->start = (BYTE *)iobuf->data;

  00014	48 8b 44 24 08	 mov	 rax, QWORD PTR iobuf$[rsp]
  00019	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  0001f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00024	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 241  :     iobuf->end   = (BYTE *)iobuf->start + (size - 1);

  00028	8b 44 24 10	 mov	 eax, DWORD PTR size$[rsp]
  0002c	ff c8		 dec	 eax
  0002e	8b c0		 mov	 eax, eax
  00030	48 8b 4c 24 08	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00035	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00039	48 8b 4c 24 08	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0003e	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 242  : }

  00042	c3		 ret	 0
iobuf_initialize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
dev$ = 48
clear_device_busy PROC

; 169  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 170  :     clear_device_busy_scsw(&dev->scsw);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	48 05 08 03 00
	00		 add	 rax, 776		; 00000308H
  00014	48 8b c8	 mov	 rcx, rax
  00017	e8 00 00 00 00	 call	 clear_device_busy_scsw

; 171  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
clear_device_busy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
scsw$ = 8
clear_device_busy_scsw PROC

; 163  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 164  :     scsw->flag3 &= ~SCSW3_AC_DEVAC;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR scsw$[rsp]
  0000a	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0000e	83 e0 bf	 and	 eax, -65		; ffffffffffffffbfH
  00011	48 8b 4c 24 08	 mov	 rcx, QWORD PTR scsw$[rsp]
  00016	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 165  : }

  00019	c3		 ret	 0
clear_device_busy_scsw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
dev$ = 48
clear_subchannel_busy PROC

; 155  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 156  :     clear_subchannel_busy_scsw(&dev->scsw);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	48 05 08 03 00
	00		 add	 rax, 776		; 00000308H
  00014	48 8b c8	 mov	 rcx, rax
  00017	e8 00 00 00 00	 call	 clear_subchannel_busy_scsw

; 157  :     dev->startpending = 0;

  0001c	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00021	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00027	0f ba f0 19	 btr	 eax, 25
  0002b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00030	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 158  :     dev->busy = 0;

  00036	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0003b	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00041	0f ba f0 13	 btr	 eax, 19
  00045	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0004a	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 159  : }

  00050	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00054	c3		 ret	 0
clear_subchannel_busy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
scsw$ = 8
clear_subchannel_busy_scsw PROC

; 147  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 148  :     scsw->flag3 &= ~(SCSW3_AC_SCHAC |

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR scsw$[rsp]
  0000a	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0000e	25 37 ff ff ff	 and	 eax, -201		; ffffffffffffff37H
  00013	48 8b 4c 24 08	 mov	 rcx, QWORD PTR scsw$[rsp]
  00018	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 149  :                      SCSW3_AC_DEVAC |
; 150  :                      SCSW3_SC_INTER);
; 151  : }

  0001b	c3		 ret	 0
clear_subchannel_busy_scsw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
dev$ = 48
set_device_busy PROC

; 140  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 141  :     set_subchannel_busy(dev);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0000e	e8 00 00 00 00	 call	 set_subchannel_busy

; 142  :     dev->scsw.flag3 |= SCSW3_AC_DEVAC;

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00018	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  0001f	83 c8 40	 or	 eax, 64			; 00000040H
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00027	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 143  : }

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
set_device_busy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
dev$ = 8
set_subchannel_busy PROC

; 133  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 134  :     dev->busy = 1;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR dev$[rsp]
  0000a	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00010	0f ba e8 13	 bts	 eax, 19
  00014	48 8b 4c 24 08	 mov	 rcx, QWORD PTR dev$[rsp]
  00019	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 135  :     dev->scsw.flag3 |= SCSW3_AC_SCHAC | SCSW3_SC_INTER;

  0001f	48 8b 44 24 08	 mov	 rax, QWORD PTR dev$[rsp]
  00024	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  0002b	0d 88 00 00 00	 or	 eax, 136		; 00000088H
  00030	48 8b 4c 24 08	 mov	 rcx, QWORD PTR dev$[rsp]
  00035	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 136  : }

  0003b	c3		 ret	 0
set_subchannel_busy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv85 = 0
dev$ = 32
code$ = 40
IS_CCW_IMMEDIATE PROC

; 122  : {

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 123  :     return

  0000d	33 c0		 xor	 eax, eax
  0000f	85 c0		 test	 eax, eax
  00011	75 77		 jne	 SHORT $LN4@IS_CCW_IMM
  00013	48 8b 44 24 20	 mov	 rax, QWORD PTR dev$[rsp]
  00018	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0001f	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00027	74 20		 je	 SHORT $LN3@IS_CCW_IMM
  00029	48 8b 44 24 20	 mov	 rax, QWORD PTR dev$[rsp]
  0002e	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00035	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR code$[rsp]
  0003a	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00041	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00045	85 c0		 test	 eax, eax
  00047	75 41		 jne	 SHORT $LN4@IS_CCW_IMM
$LN3@IS_CCW_IMM:
  00049	48 8b 44 24 20	 mov	 rax, QWORD PTR dev$[rsp]
  0004e	48 83 b8 98 02
	00 00 00	 cmp	 QWORD PTR [rax+664], 0
  00056	74 18		 je	 SHORT $LN5@IS_CCW_IMM
  00058	0f b6 44 24 28	 movzx	 eax, BYTE PTR code$[rsp]
  0005d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  00062	48 8b 89 98 02
	00 00		 mov	 rcx, QWORD PTR [rcx+664]
  00069	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  0006e	75 1a		 jne	 SHORT $LN4@IS_CCW_IMM
$LN5@IS_CCW_IMM:
  00070	48 8b 44 24 20	 mov	 rax, QWORD PTR dev$[rsp]
  00075	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  0007c	83 f8 03	 cmp	 eax, 3
  0007f	74 09		 je	 SHORT $LN4@IS_CCW_IMM
  00081	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv85[rsp], 0
  00088	eb 07		 jmp	 SHORT $LN6@IS_CCW_IMM
$LN4@IS_CCW_IMM:
  0008a	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv85[rsp], 1
$LN6@IS_CCW_IMM:
  00091	0f b6 04 24	 movzx	 eax, BYTE PTR tv85[rsp]

; 124  :     (0
; 125  :         || (dev->hnd->immed && dev->hnd->immed[code])
; 126  :         || (dev->immed      && dev->immed[code])
; 127  :         || IS_CCW_NOP( dev->code )
; 128  :     );
; 129  : }

  00095	48 83 c4 18	 add	 rsp, 24
  00099	c3		 ret	 0
IS_CCW_IMMEDIATE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
status$ = 48
tv75 = 52
tv128 = 56
tv149 = 60
cc$ = 64
$T1 = 80
regs$ = 128
dev$ = 136
irb$ = 144
ioint$ = 152
scsw$ = 160
test_subchan_locked PROC

; 1660 : {

$LN23:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 68	 sub	 rsp, 104		; 00000068H
$LN4@test_subch:

; 1661 :     enum                                /* Status types              */
; 1662 :     {                                   /* ...                       */
; 1663 :         pci,                            /* PCI Status                */
; 1664 :         normal,                         /* Normal Status             */
; 1665 :         attn                            /* Attention Status          */
; 1666 :     } status;                           /* ...                       */
; 1667 : 
; 1668 :     int cc;                             /* Returned condition code   */
; 1669 : 
; 1670 :     UNREFERENCED( regs );

  0001a	33 c0		 xor	 eax, eax
  0001c	85 c0		 test	 eax, eax
  0001e	75 fa		 jne	 SHORT $LN4@test_subch

; 1671 : 
; 1672 :     if (unlikely((dev->pciscsw.flag3 & SCSW3_SC_PEND)))

  00020	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00028	0f b6 80 17 03
	00 00		 movzx	 eax, BYTE PTR [rax+791]
  0002f	83 e0 01	 and	 eax, 1
  00032	85 c0		 test	 eax, eax
  00034	74 0a		 je	 SHORT $LN17@test_subch
  00036	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  0003e	eb 08		 jmp	 SHORT $LN18@test_subch
$LN17@test_subch:
  00040	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN18@test_subch:
  00048	83 7c 24 34 00	 cmp	 DWORD PTR tv75[rsp], 0
  0004d	74 3f		 je	 SHORT $LN7@test_subch

; 1673 :     {
; 1674 :         status = pci;

  0004f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR status$[rsp], 0

; 1675 :         *ioint = &dev->pciioint;

  00057	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0005f	48 05 40 02 00
	00		 add	 rax, 576		; 00000240H
  00065	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR ioint$[rsp]
  0006d	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1676 :         *scsw  = &dev->pciscsw;

  00070	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00078	48 05 14 03 00
	00		 add	 rax, 788		; 00000314H
  0007e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR scsw$[rsp]
  00086	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1677 :     }

  00089	e9 bb 00 00 00	 jmp	 $LN8@test_subch
$LN7@test_subch:

; 1678 :     else if (likely( (dev->scsw.flag3     & SCSW3_SC_PEND)  ||

  0008e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00096	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  0009d	83 e0 01	 and	 eax, 1
  000a0	85 c0		 test	 eax, eax
  000a2	75 20		 jne	 SHORT $LN19@test_subch
  000a4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ac	0f b6 80 23 03
	00 00		 movzx	 eax, BYTE PTR [rax+803]
  000b3	83 e0 01	 and	 eax, 1
  000b6	85 c0		 test	 eax, eax
  000b8	74 0a		 je	 SHORT $LN19@test_subch
  000ba	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
  000c2	eb 08		 jmp	 SHORT $LN22@test_subch
$LN19@test_subch:
  000c4	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv128[rsp], 1
$LN22@test_subch:
  000cc	83 7c 24 38 00	 cmp	 DWORD PTR tv128[rsp], 0
  000d1	74 3c		 je	 SHORT $LN9@test_subch

; 1679 :                     !(dev->attnscsw.flag3 & SCSW3_SC_PEND)))
; 1680 :     {
; 1681 :         status = normal;

  000d3	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR status$[rsp], 1

; 1682 :         *ioint = &dev->ioint;

  000db	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000e3	48 05 28 02 00
	00		 add	 rax, 552		; 00000228H
  000e9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR ioint$[rsp]
  000f1	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1683 :         *scsw  = &dev->scsw;

  000f4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000fc	48 05 08 03 00
	00		 add	 rax, 776		; 00000308H
  00102	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR scsw$[rsp]
  0010a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1684 :     }

  0010d	eb 3a		 jmp	 SHORT $LN10@test_subch
$LN9@test_subch:

; 1685 :     else
; 1686 :     {
; 1687 :         status = attn;

  0010f	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR status$[rsp], 2

; 1688 :         *ioint = &dev->attnioint;

  00117	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0011f	48 05 58 02 00
	00		 add	 rax, 600		; 00000258H
  00125	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR ioint$[rsp]
  0012d	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1689 :         *scsw  = &dev->attnscsw;

  00130	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00138	48 05 20 03 00
	00		 add	 rax, 800		; 00000320H
  0013e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR scsw$[rsp]
  00146	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN10@test_subch:
$LN8@test_subch:

; 1690 :     }
; 1691 : 
; 1692 :     /* Ensure status removed from interrupt queue */
; 1693 :     DEQUEUE_IO_INTERRUPT_QLOCKED(*ioint);

  00149	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170592
  00150	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ioint$[rsp]
  00158	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0015b	e8 00 00 00 00	 call	 Dequeue_IO_Interrupt_QLocked

; 1694 : 
; 1695 :     /* Display the subchannel status word */
; 1696 :     if (dev->ccwtrace)

  00160	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00168	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0016e	c1 e8 0f	 shr	 eax, 15
  00171	83 e0 01	 and	 eax, 1
  00174	85 c0		 test	 eax, eax
  00176	74 48		 je	 SHORT $LN11@test_subch

; 1697 :         DISPLAY_SCSW( dev, **scsw );

  00178	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR scsw$[rsp]
  00180	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00183	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T1[rsp]
  00188	48 8b f9	 mov	 rdi, rcx
  0018b	48 8b f0	 mov	 rsi, rax
  0018e	b9 0c 00 00 00	 mov	 ecx, 12
  00193	f3 a4		 rep movsb
  00195	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170594
  0019c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a1	41 b9 a1 06 00
	00		 mov	 r9d, 1697		; 000006a1H
  001a7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170595
  001ae	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T1[rsp]
  001b3	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001bb	e8 00 00 00 00	 call	 _display_scsw
$LN11@test_subch:

; 1698 : 
; 1699 :     /* Copy the SCSW to the IRB */
; 1700 :     irb->scsw = **scsw;

  001c0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR scsw$[rsp]
  001c8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001cb	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR irb$[rsp]
  001d3	48 8b f0	 mov	 rsi, rax
  001d6	b9 0c 00 00 00	 mov	 ecx, 12
  001db	f3 a4		 rep movsb

; 1701 : 
; 1702 :     /* Clear the ESW and ECW in the IRB */
; 1703 :     switch (status)

  001dd	8b 44 24 30	 mov	 eax, DWORD PTR status$[rsp]
  001e1	89 44 24 3c	 mov	 DWORD PTR tv149[rsp], eax
  001e5	83 7c 24 3c 01	 cmp	 DWORD PTR tv149[rsp], 1
  001ea	74 02		 je	 SHORT $LN12@test_subch
  001ec	eb 46		 jmp	 SHORT $LN13@test_subch
$LN12@test_subch:

; 1704 :     {
; 1705 :         case normal:
; 1706 : 
; 1707 :             /* Copy the extended status word to the IRB */
; 1708 :             irb->esw = dev->esw;

  001ee	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR irb$[rsp]
  001f6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001fe	48 8d 78 0c	 lea	 rdi, QWORD PTR [rax+12]
  00202	48 8d b1 2c 03
	00 00		 lea	 rsi, QWORD PTR [rcx+812]
  00209	b9 14 00 00 00	 mov	 ecx, 20
  0020e	f3 a4		 rep movsb

; 1709 : 
; 1710 :             /* Copy the extended control word to the IRB */
; 1711 :             memcpy (irb->ecw, dev->ecw, sizeof(irb->ecw));

  00210	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR irb$[rsp]
  00218	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00220	48 8d 78 20	 lea	 rdi, QWORD PTR [rax+32]
  00224	48 8d b1 40 03
	00 00		 lea	 rsi, QWORD PTR [rcx+832]
  0022b	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00230	f3 a4		 rep movsb

; 1712 :             break;

  00232	eb 3c		 jmp	 SHORT $LN5@test_subch
$LN13@test_subch:

; 1713 : 
; 1714 :         default:
; 1715 :             /* Clear the ESW and ECW in the IRB */
; 1716 :             memset (&irb->esw, 0, sizeof(ESW));

  00234	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR irb$[rsp]
  0023c	48 83 c0 0c	 add	 rax, 12
  00240	48 8b f8	 mov	 rdi, rax
  00243	33 c0		 xor	 eax, eax
  00245	b9 14 00 00 00	 mov	 ecx, 20
  0024a	f3 aa		 rep stosb

; 1717 :             irb->esw.lpum = 0x80;

  0024c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR irb$[rsp]
  00254	c6 40 0d 80	 mov	 BYTE PTR [rax+13], 128	; 00000080H

; 1718 :             memset (irb->ecw, 0, sizeof(irb->ecw));

  00258	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR irb$[rsp]
  00260	48 83 c0 20	 add	 rax, 32			; 00000020H
  00264	48 8b f8	 mov	 rdi, rax
  00267	33 c0		 xor	 eax, eax
  00269	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0026e	f3 aa		 rep stosb
$LN5@test_subch:

; 1719 :             break;
; 1720 :     }
; 1721 : 
; 1722 :     /* Clear the subchannel and set condition code */
; 1723 :     cc = test_subchan_clear(dev, *scsw);

  00270	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR scsw$[rsp]
  00278	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0027b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00283	e8 00 00 00 00	 call	 test_subchan_clear
  00288	89 44 24 40	 mov	 DWORD PTR cc$[rsp], eax

; 1724 : 
; 1725 :     /* Update pending interrupts */
; 1726 :     UPDATE_IC_IOPENDING_QLOCKED();

  0028c	e8 00 00 00 00	 call	 Update_IC_IOPENDING_QLocked

; 1727 : 
; 1728 :     /* Return condition code */
; 1729 :     return (cc);

  00291	8b 44 24 40	 mov	 eax, DWORD PTR cc$[rsp]

; 1730 : }

  00295	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00299	5f		 pop	 rdi
  0029a	5e		 pop	 rsi
  0029b	c3		 ret	 0
test_subchan_locked ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv69 = 0
tv80 = 4
tv91 = 8
dev$ = 32
subchannel_interrupt_queue_cleanup PROC

; 1550 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 1551 :     /* Begin the deprecation of the pending status bits in the
; 1552 :      * DEVBLK; the pending bits are now set from the corresponding
; 1553 :      * SCSWs.
; 1554 :      *
; 1555 :      * Implementation Note
; 1556 :      * -------------------
; 1557 :      * While SCSW3_SC_PEND is bit 31 of the SCSW, the old pending flags
; 1558 :      * are at "unknown" bit positions. Ensure that *ALL* C compilers
; 1559 :      * set the target bit fields properly.
; 1560 :      */
; 1561 :     dev->pcipending  = (dev->pciscsw.flag3  & SCSW3_SC_PEND) ? 1 : 0;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	0f b6 80 17 03
	00 00		 movzx	 eax, BYTE PTR [rax+791]
  00015	83 e0 01	 and	 eax, 1
  00018	85 c0		 test	 eax, eax
  0001a	74 09		 je	 SHORT $LN3@subchannel
  0001c	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv69[rsp], 1
  00023	eb 07		 jmp	 SHORT $LN4@subchannel
$LN3@subchannel:
  00025	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv69[rsp], 0
$LN4@subchannel:
  0002c	8b 04 24	 mov	 eax, DWORD PTR tv69[rsp]
  0002f	83 e0 01	 and	 eax, 1
  00032	c1 e0 17	 shl	 eax, 23
  00035	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  0003a	8b 89 f8 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1528]
  00040	0f ba f1 17	 btr	 ecx, 23
  00044	0b c8		 or	 ecx, eax
  00046	8b c1		 mov	 eax, ecx
  00048	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  0004d	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 1562 :     dev->pending     = (dev->scsw.flag3     & SCSW3_SC_PEND) ? 1 : 0;

  00053	48 8b 44 24 20	 mov	 rax, QWORD PTR dev$[rsp]
  00058	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  0005f	83 e0 01	 and	 eax, 1
  00062	85 c0		 test	 eax, eax
  00064	74 0a		 je	 SHORT $LN5@subchannel
  00066	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN6@subchannel
$LN5@subchannel:
  00070	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN6@subchannel:
  00078	8b 44 24 04	 mov	 eax, DWORD PTR tv80[rsp]
  0007c	83 e0 01	 and	 eax, 1
  0007f	c1 e0 16	 shl	 eax, 22
  00082	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  00087	8b 89 f8 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1528]
  0008d	0f ba f1 16	 btr	 ecx, 22
  00091	0b c8		 or	 ecx, eax
  00093	8b c1		 mov	 eax, ecx
  00095	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  0009a	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 1563 :     dev->attnpending = (dev->attnscsw.flag3 & SCSW3_SC_PEND) ? 1 : 0;

  000a0	48 8b 44 24 20	 mov	 rax, QWORD PTR dev$[rsp]
  000a5	0f b6 80 23 03
	00 00		 movzx	 eax, BYTE PTR [rax+803]
  000ac	83 e0 01	 and	 eax, 1
  000af	85 c0		 test	 eax, eax
  000b1	74 0a		 je	 SHORT $LN7@subchannel
  000b3	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR tv91[rsp], 1
  000bb	eb 08		 jmp	 SHORT $LN8@subchannel
$LN7@subchannel:
  000bd	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
$LN8@subchannel:
  000c5	8b 44 24 08	 mov	 eax, DWORD PTR tv91[rsp]
  000c9	83 e0 01	 and	 eax, 1
  000cc	c1 e0 18	 shl	 eax, 24
  000cf	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  000d4	8b 89 f8 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1528]
  000da	0f ba f1 18	 btr	 ecx, 24
  000de	0b c8		 or	 ecx, eax
  000e0	8b c1		 mov	 eax, ecx
  000e2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  000e7	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 1564 : }

  000ed	48 83 c4 18	 add	 rsp, 24
  000f1	c3		 ret	 0
subchannel_interrupt_queue_cleanup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
result$ = 32
regs$ = 64
dev$ = 72
schedule_ioq PROC

; 2849 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2850 :     int result = 2;                     /* 0=Thread scheduled        */

  0000e	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR result$[rsp], 2

; 2851 :                                         /* 2=Unable to schedule      */
; 2852 : 
; 2853 :     /* If shutdown in progress, don't schedule or perform I/O
; 2854 :      * operation.
; 2855 :      */
; 2856 :     if (sysblk.shutdown)

  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001d	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00023	c1 e8 0b	 shr	 eax, 11
  00026	83 e0 01	 and	 eax, 1
  00029	85 c0		 test	 eax, eax
  0002b	74 26		 je	 SHORT $LN2@schedule_i

; 2857 :     {
; 2858 :         signal_condition(&sysblk.ioqcond);

  0002d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00034	48 05 40 12 00
	00		 add	 rax, 4672		; 00001240H
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170996
  00041	48 8b c8	 mov	 rcx, rax
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 2859 :         return (result);

  0004a	8b 44 24 20	 mov	 eax, DWORD PTR result$[rsp]
  0004e	e9 81 00 00 00	 jmp	 $LN1@schedule_i
$LN2@schedule_i:

; 2860 :     }
; 2861 : 
; 2862 :     if (dev->s370start && regs != NULL)

  00053	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00058	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0005e	d1 e8		 shr	 eax, 1
  00060	83 e0 01	 and	 eax, 1
  00063	85 c0		 test	 eax, eax
  00065	74 5b		 je	 SHORT $LN3@schedule_i
  00067	48 83 7c 24 40
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0006d	74 53		 je	 SHORT $LN3@schedule_i

; 2863 :     {
; 2864 :         release_lock(&dev->lock);

  0006f	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00074	48 83 c0 38	 add	 rax, 56			; 00000038H
  00078	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170999
  0007f	48 8b c8	 mov	 rcx, rax
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2865 :         call_execute_ccw_chain(sysblk.arch_mode, dev);

  00088	48 8b 54 24 48	 mov	 rdx, QWORD PTR dev$[rsp]
  0008d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00094	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [rax+136]
  0009a	e8 00 00 00 00	 call	 call_execute_ccw_chain

; 2866 :         obtain_lock(&dev->lock);

  0009f	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  000a4	48 83 c0 38	 add	 rax, 56			; 00000038H
  000a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171000
  000af	48 8b c8	 mov	 rcx, rax
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2867 :         result = 0;

  000b8	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0

; 2868 :     }

  000c0	eb 0e		 jmp	 SHORT $LN4@schedule_i
$LN3@schedule_i:

; 2869 :     else
; 2870 :         result = ScheduleIORequest(dev);

  000c2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  000c7	e8 00 00 00 00	 call	 ScheduleIORequest
  000cc	89 44 24 20	 mov	 DWORD PTR result$[rsp], eax
$LN4@schedule_i:

; 2871 : 
; 2872 :     return (result);

  000d0	8b 44 24 20	 mov	 eax, DWORD PTR result$[rsp]
$LN1@schedule_i:

; 2873 : }

  000d4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d8	c3		 ret	 0
schedule_ioq ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
current_priority$ = 48
dev$ = 56
waitcount$ = 64
tv86 = 68
tv135 = 72
tv219 = 76
tv233 = 80
rc$ = 84
thread_name$1 = 88
__$ArrayPad$ = 104
arg$ = 128
device_thread PROC

; 2589 : {

$LN32:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 68	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2590 : DEVBLK *dev;
; 2591 : int     current_priority;               /* Current thread priority   */
; 2592 : int     rc = 0;                         /* Return code               */

  00018	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 2593 : u_int   waitcount = 0;                  /* Wait counter              */

  00020	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR waitcount$[rsp], 0
$LN4@device_thr:

; 2594 : 
; 2595 :     UNREFERENCED(arg);

  00028	33 c0		 xor	 eax, eax
  0002a	85 c0		 test	 eax, eax
  0002c	75 fa		 jne	 SHORT $LN4@device_thr

; 2596 : 
; 2597 :     /* Automatically adjust to priority change if needed */
; 2598 :     current_priority = get_thread_priority();

  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170938
  0003b	8b c8		 mov	 ecx, eax
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  00043	89 44 24 30	 mov	 DWORD PTR current_priority$[rsp], eax

; 2599 :     if (current_priority != sysblk.devprio)

  00047	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0004e	8b 80 70 13 00
	00		 mov	 eax, DWORD PTR [rax+4976]
  00054	39 44 24 30	 cmp	 DWORD PTR current_priority$[rsp], eax
  00058	74 33		 je	 SHORT $LN15@device_thr

; 2600 :     {
; 2601 :         set_thread_priority( sysblk.devprio );

  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00060	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170940
  00067	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0006e	8b 91 70 13 00
	00		 mov	 edx, DWORD PTR [rcx+4976]
  00074	8b c8		 mov	 ecx, eax
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_thread_prio

; 2602 :         current_priority = sysblk.devprio;

  0007c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00083	8b 80 70 13 00
	00		 mov	 eax, DWORD PTR [rax+4976]
  00089	89 44 24 30	 mov	 DWORD PTR current_priority$[rsp], eax
$LN15@device_thr:

; 2603 :     }
; 2604 : 
; 2605 :     obtain_lock(&sysblk.ioqlock);

  0008d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00094	48 05 38 12 00
	00		 add	 rax, 4664		; 00001238H
  0009a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170941
  000a1	48 8b c8	 mov	 rcx, rax
  000a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2606 : 
; 2607 :     sysblk.devtwait = MAX(0, sysblk.devtwait - 1);

  000aa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000b1	8b 80 48 12 00
	00		 mov	 eax, DWORD PTR [rax+4680]
  000b7	ff c8		 dec	 eax
  000b9	85 c0		 test	 eax, eax
  000bb	7d 0a		 jge	 SHORT $LN24@device_thr
  000bd	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
  000c5	eb 13		 jmp	 SHORT $LN25@device_thr
$LN24@device_thr:
  000c7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ce	8b 80 48 12 00
	00		 mov	 eax, DWORD PTR [rax+4680]
  000d4	ff c8		 dec	 eax
  000d6	89 44 24 44	 mov	 DWORD PTR tv86[rsp], eax
$LN25@device_thr:
  000da	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000e1	8b 4c 24 44	 mov	 ecx, DWORD PTR tv86[rsp]
  000e5	89 88 48 12 00
	00		 mov	 DWORD PTR [rax+4680], ecx
$LN5@device_thr:

; 2608 : 
; 2609 :     while (1)

  000eb	33 c0		 xor	 eax, eax
  000ed	83 f8 01	 cmp	 eax, 1
  000f0	0f 84 8b 03 00
	00		 je	 $LN6@device_thr
$LN7@device_thr:

; 2610 :     {
; 2611 :         while ((dev=sysblk.ioq)  &&

  000f6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000fd	48 8b 80 30 12
	00 00		 mov	 rax, QWORD PTR [rax+4656]
  00104	48 89 44 24 38	 mov	 QWORD PTR dev$[rsp], rax
  00109	48 83 7c 24 38
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0010f	0f 84 de 01 00
	00		 je	 $LN8@device_thr
  00115	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0011c	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00122	c1 e8 0b	 shr	 eax, 11
  00125	83 e0 01	 and	 eax, 1
  00128	85 c0		 test	 eax, eax
  0012a	0f 85 c3 01 00
	00		 jne	 $LN8@device_thr

; 2612 :                !sysblk.shutdown)
; 2613 :         {
; 2614 :             /* Reset local wait count */
; 2615 :             waitcount = 0;

  00130	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR waitcount$[rsp], 0

; 2616 : 
; 2617 :             /* Set next IOQ entry and zero pointer in current DEVBLK */
; 2618 :             sysblk.ioq = dev->nextioq;

  00138	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0013f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  00144	48 8b 89 20 02
	00 00		 mov	 rcx, QWORD PTR [rcx+544]
  0014b	48 89 88 30 12
	00 00		 mov	 QWORD PTR [rax+4656], rcx

; 2619 :             dev->nextioq = 0;

  00152	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00157	48 c7 80 20 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+544], 0

; 2620 : 
; 2621 :             /* Decrement waiting IOQ count */
; 2622 :             sysblk.devtunavail = MAX(0, sysblk.devtunavail - 1);

  00162	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00169	8b 80 58 12 00
	00		 mov	 eax, DWORD PTR [rax+4696]
  0016f	ff c8		 dec	 eax
  00171	85 c0		 test	 eax, eax
  00173	7d 0a		 jge	 SHORT $LN26@device_thr
  00175	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
  0017d	eb 13		 jmp	 SHORT $LN27@device_thr
$LN26@device_thr:
  0017f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00186	8b 80 58 12 00
	00		 mov	 eax, DWORD PTR [rax+4696]
  0018c	ff c8		 dec	 eax
  0018e	89 44 24 48	 mov	 DWORD PTR tv135[rsp], eax
$LN27@device_thr:
  00192	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00199	8b 4c 24 48	 mov	 ecx, DWORD PTR tv135[rsp]
  0019d	89 88 58 12 00
	00		 mov	 DWORD PTR [rax+4696], ecx

; 2623 : 
; 2624 :             /* Create another device thread if pending work */
; 2625 :             create_device_thread();

  001a3	e8 00 00 00 00	 call	 create_device_thread

; 2626 : 
; 2627 :             /* Set thread id */
; 2628 :             dev->tid = thread_id();

  001a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  001ae	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  001b3	89 81 14 02 00
	00		 mov	 DWORD PTR [rcx+532], eax

; 2629 : 
; 2630 :             /* Set thread name */
; 2631 :             {
; 2632 :                 char thread_name[16];
; 2633 :                 MSGBUF( thread_name, "dev %4.4X thrd", dev->devnum );

  001b9	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  001be	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001c2	44 8b c8	 mov	 r9d, eax
  001c5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170942
  001cc	ba 10 00 00 00	 mov	 edx, 16
  001d1	48 8d 4c 24 58	 lea	 rcx, QWORD PTR thread_name$1[rsp]
  001d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN11@device_thr:

; 2634 :                 SET_THREAD_NAME( thread_name );

  001dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  001e2	48 8d 54 24 58	 lea	 rdx, QWORD PTR thread_name$1[rsp]
  001e7	8b c8		 mov	 ecx, eax
  001e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_set_thread_name
  001ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  001f5	48 8d 54 24 58	 lea	 rdx, QWORD PTR thread_name$1[rsp]
  001fa	8b c8		 mov	 ecx, eax
  001fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_thread_name
  00202	33 c0		 xor	 eax, eax
  00204	85 c0		 test	 eax, eax
  00206	75 d4		 jne	 SHORT $LN11@device_thr

; 2635 :             }
; 2636 : 
; 2637 :             release_lock (&sysblk.ioqlock);

  00208	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0020f	48 05 38 12 00
	00		 add	 rax, 4664		; 00001238H
  00215	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170943
  0021c	48 8b c8	 mov	 rcx, rax
  0021f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2638 : 
; 2639 :             /* Set priority to requested device priority; should not */
; 2640 :             /* have any Hercules locks held                          */
; 2641 :             if (dev->devprio != current_priority)

  00225	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0022a	8b 4c 24 30	 mov	 ecx, DWORD PTR current_priority$[rsp]
  0022e	39 88 74 02 00
	00		 cmp	 DWORD PTR [rax+628], ecx
  00234	74 2f		 je	 SHORT $LN16@device_thr

; 2642 :             {
; 2643 :                 set_thread_priority( dev->devprio);

  00236	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  0023c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170945
  00243	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  00248	8b 91 74 02 00
	00		 mov	 edx, DWORD PTR [rcx+628]
  0024e	8b c8		 mov	 ecx, eax
  00250	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_thread_prio

; 2644 :                 current_priority = dev->devprio;

  00256	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0025b	8b 80 74 02 00
	00		 mov	 eax, DWORD PTR [rax+628]
  00261	89 44 24 30	 mov	 DWORD PTR current_priority$[rsp], eax
$LN16@device_thr:

; 2645 :             }
; 2646 : 
; 2647 :             /* Execute requested CCW chain */
; 2648 :             call_execute_ccw_chain(sysblk.arch_mode, dev);

  00265	48 8b 54 24 38	 mov	 rdx, QWORD PTR dev$[rsp]
  0026a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00271	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [rax+136]
  00277	e8 00 00 00 00	 call	 call_execute_ccw_chain

; 2649 : 
; 2650 :             /* Reset priority back to device default priority */
; 2651 :             if (current_priority != sysblk.devprio)

  0027c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00283	8b 80 70 13 00
	00		 mov	 eax, DWORD PTR [rax+4976]
  00289	39 44 24 30	 cmp	 DWORD PTR current_priority$[rsp], eax
  0028d	74 33		 je	 SHORT $LN17@device_thr

; 2652 :             {
; 2653 :                 set_thread_priority( sysblk.devprio);

  0028f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00295	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170947
  0029c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002a3	8b 91 70 13 00
	00		 mov	 edx, DWORD PTR [rcx+4976]
  002a9	8b c8		 mov	 ecx, eax
  002ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_thread_prio

; 2654 :                 current_priority = sysblk.devprio;

  002b1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002b8	8b 80 70 13 00
	00		 mov	 eax, DWORD PTR [rax+4976]
  002be	89 44 24 30	 mov	 DWORD PTR current_priority$[rsp], eax
$LN17@device_thr:

; 2655 :             }
; 2656 : 
; 2657 :             /* Done. Reset the threadid used by the device and       */
; 2658 :             /* re-obtain ioqlock                                     */
; 2659 :             obtain_lock(&sysblk.ioqlock);

  002c2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002c9	48 05 38 12 00
	00		 add	 rax, 4664		; 00001238H
  002cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170948
  002d6	48 8b c8	 mov	 rcx, rax
  002d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2660 :             dev->tid = 0;

  002df	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  002e4	c7 80 14 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+532], 0

; 2661 :         }

  002ee	e9 03 fe ff ff	 jmp	 $LN7@device_thr
$LN8@device_thr:

; 2662 : 
; 2663 :         /* Shutdown thread on request, if idle for more than two     */
; 2664 :         /* seconds, or more than four idle threads                   */
; 2665 :         if ((sysblk.devtmax == 0 &&
; 2666 :                 waitcount >= 20 &&
; 2667 :                 sysblk.devtwait > 3)                                 ||
; 2668 :             (sysblk.devtmax >  0 && sysblk.devtnbr > sysblk.devtmax) ||
; 2669 :             sysblk.devtmax < 0                                       ||

  002f3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002fa	83 b8 50 12 00
	00 00		 cmp	 DWORD PTR [rax+4688], 0
  00301	75 17		 jne	 SHORT $LN20@device_thr
  00303	83 7c 24 40 14	 cmp	 DWORD PTR waitcount$[rsp], 20
  00308	72 10		 jb	 SHORT $LN20@device_thr
  0030a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00311	83 b8 48 12 00
	00 03		 cmp	 DWORD PTR [rax+4680], 3
  00318	7f 53		 jg	 SHORT $LN19@device_thr
$LN20@device_thr:
  0031a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00321	83 b8 50 12 00
	00 00		 cmp	 DWORD PTR [rax+4688], 0
  00328	7e 1c		 jle	 SHORT $LN21@device_thr
  0032a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00331	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00338	8b 89 50 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4688]
  0033e	39 88 4c 12 00
	00		 cmp	 DWORD PTR [rax+4684], ecx
  00344	7f 27		 jg	 SHORT $LN19@device_thr
$LN21@device_thr:
  00346	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0034d	83 b8 50 12 00
	00 00		 cmp	 DWORD PTR [rax+4688], 0
  00354	7c 17		 jl	 SHORT $LN19@device_thr
  00356	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0035d	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00363	c1 e8 0b	 shr	 eax, 11
  00366	83 e0 01	 and	 eax, 1
  00369	85 c0		 test	 eax, eax
  0036b	74 05		 je	 SHORT $LN18@device_thr
$LN19@device_thr:

; 2670 :             sysblk.shutdown)
; 2671 :             break;

  0036d	e9 0f 01 00 00	 jmp	 $LN6@device_thr
$LN18@device_thr:

; 2672 : 
; 2673 :         /* Show thread as idle */
; 2674 :         waitcount++;

  00372	8b 44 24 40	 mov	 eax, DWORD PTR waitcount$[rsp]
  00376	ff c0		 inc	 eax
  00378	89 44 24 40	 mov	 DWORD PTR waitcount$[rsp], eax

; 2675 :         sysblk.devtwait++;

  0037c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00383	8b 80 48 12 00
	00		 mov	 eax, DWORD PTR [rax+4680]
  00389	ff c0		 inc	 eax
  0038b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00392	89 81 48 12 00
	00		 mov	 DWORD PTR [rcx+4680], eax
$LN14@device_thr:

; 2676 :         SET_THREAD_NAME( "idle dev thrd" );

  00398	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  0039e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170953
  003a5	8b c8		 mov	 ecx, eax
  003a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_set_thread_name
  003ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  003b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170954
  003ba	8b c8		 mov	 ecx, eax
  003bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_thread_name
  003c2	33 c0		 xor	 eax, eax
  003c4	85 c0		 test	 eax, eax
  003c6	75 d0		 jne	 SHORT $LN14@device_thr

; 2677 : 
; 2678 :         /* Wait for work to arrive */
; 2679 :         rc = timed_wait_condition_relative_usecs (&sysblk.ioqcond,

  003c8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003cf	48 05 38 12 00
	00		 add	 rax, 4664		; 00001238H
  003d5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  003dc	48 81 c1 40 12
	00 00		 add	 rcx, 4672		; 00001240H
  003e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170955
  003ea	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  003ef	45 33 c9	 xor	 r9d, r9d
  003f2	41 b8 a0 86 01
	00		 mov	 r8d, 100000		; 000186a0H
  003f8	48 8b d0	 mov	 rdx, rax
  003fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_timed_wait_condition_relative_usecs_impl
  00401	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax

; 2680 :                                                   &sysblk.ioqlock,
; 2681 :                                                   100000 /* 100 ms */,
; 2682 :                                                   NULL);
; 2683 : 
; 2684 :         /* Decrement thread waiting count */
; 2685 :         sysblk.devtwait = MAX(0, sysblk.devtwait - 1);

  00405	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0040c	8b 80 48 12 00
	00		 mov	 eax, DWORD PTR [rax+4680]
  00412	ff c8		 dec	 eax
  00414	85 c0		 test	 eax, eax
  00416	7d 0a		 jge	 SHORT $LN28@device_thr
  00418	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv219[rsp], 0
  00420	eb 13		 jmp	 SHORT $LN29@device_thr
$LN28@device_thr:
  00422	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00429	8b 80 48 12 00
	00		 mov	 eax, DWORD PTR [rax+4680]
  0042f	ff c8		 dec	 eax
  00431	89 44 24 4c	 mov	 DWORD PTR tv219[rsp], eax
$LN29@device_thr:
  00435	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0043c	8b 4c 24 4c	 mov	 ecx, DWORD PTR tv219[rsp]
  00440	89 88 48 12 00
	00		 mov	 DWORD PTR [rax+4680], ecx

; 2686 : 
; 2687 :         /* If shutdown requested, terminate the thread after signaling
; 2688 :          * next I/O thread to shutdown.
; 2689 :          */
; 2690 :         if (sysblk.shutdown)

  00446	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0044d	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00453	c1 e8 0b	 shr	 eax, 11
  00456	83 e0 01	 and	 eax, 1
  00459	85 c0		 test	 eax, eax
  0045b	74 1f		 je	 SHORT $LN22@device_thr

; 2691 :         {
; 2692 :             signal_condition (&sysblk.ioqcond);

  0045d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00464	48 05 40 12 00
	00		 add	 rax, 4672		; 00001240H
  0046a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170957
  00471	48 8b c8	 mov	 rcx, rax
  00474	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 2693 :             break;

  0047a	eb 05		 jmp	 SHORT $LN6@device_thr
$LN22@device_thr:

; 2694 :         }
; 2695 :     }

  0047c	e9 6a fc ff ff	 jmp	 $LN5@device_thr
$LN6@device_thr:

; 2696 : 
; 2697 :     /* Decrement total number of device threads */
; 2698 :     sysblk.devtnbr = MAX(0, sysblk.devtnbr - 1);

  00481	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00488	8b 80 4c 12 00
	00		 mov	 eax, DWORD PTR [rax+4684]
  0048e	ff c8		 dec	 eax
  00490	85 c0		 test	 eax, eax
  00492	7d 0a		 jge	 SHORT $LN30@device_thr
  00494	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv233[rsp], 0
  0049c	eb 13		 jmp	 SHORT $LN31@device_thr
$LN30@device_thr:
  0049e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004a5	8b 80 4c 12 00
	00		 mov	 eax, DWORD PTR [rax+4684]
  004ab	ff c8		 dec	 eax
  004ad	89 44 24 50	 mov	 DWORD PTR tv233[rsp], eax
$LN31@device_thr:
  004b1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004b8	8b 4c 24 50	 mov	 ecx, DWORD PTR tv233[rsp]
  004bc	89 88 4c 12 00
	00		 mov	 DWORD PTR [rax+4684], ecx

; 2699 : 
; 2700 :     /* Release queue lock and return */
; 2701 :     release_lock (&sysblk.ioqlock);

  004c2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004c9	48 05 38 12 00
	00		 add	 rax, 4664		; 00001238H
  004cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170958
  004d6	48 8b c8	 mov	 rcx, rax
  004d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2702 :     return (NULL);

  004df	33 c0		 xor	 eax, eax

; 2703 : 
; 2704 : } /* end function device_thread */

  004e1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004e6	48 33 cc	 xor	 rcx, rsp
  004e9	e8 00 00 00 00	 call	 __security_check_cookie
  004ee	48 83 c4 78	 add	 rsp, 120		; 00000078H
  004f2	c3		 ret	 0
device_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv64 = 32
p$1 = 40
arch_mode$ = 64
pDevBlk$ = 72
call_execute_ccw_chain PROC

; 6522 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6523 :     switch (arch_mode)

  0000d	8b 44 24 40	 mov	 eax, DWORD PTR arch_mode$[rsp]
  00011	89 44 24 20	 mov	 DWORD PTR tv64[rsp], eax
  00015	83 7c 24 20 00	 cmp	 DWORD PTR tv64[rsp], 0
  0001a	74 10		 je	 SHORT $LN7@call_execu
  0001c	83 7c 24 20 01	 cmp	 DWORD PTR tv64[rsp], 1
  00021	74 15		 je	 SHORT $LN8@call_execu
  00023	83 7c 24 20 02	 cmp	 DWORD PTR tv64[rsp], 2
  00028	74 1a		 je	 SHORT $LN9@call_execu
  0002a	eb 24		 jmp	 SHORT $LN10@call_execu
$LN7@call_execu:

; 6524 :     {
; 6525 : #if defined(_370)
; 6526 :         case ARCH_370_IDX: s370_execute_ccw_chain((DEVBLK*)pDevBlk); break;

  0002c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pDevBlk$[rsp]
  00031	e8 00 00 00 00	 call	 s370_execute_ccw_chain
  00036	eb 2f		 jmp	 SHORT $LN2@call_execu
$LN8@call_execu:

; 6527 : #endif
; 6528 : #if defined(_390)
; 6529 :         case ARCH_390_IDX: s390_execute_ccw_chain((DEVBLK*)pDevBlk); break;

  00038	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pDevBlk$[rsp]
  0003d	e8 00 00 00 00	 call	 s390_execute_ccw_chain
  00042	eb 23		 jmp	 SHORT $LN2@call_execu
$LN9@call_execu:

; 6530 : #endif
; 6531 : #if defined(_900)
; 6532 :         case ARCH_900_IDX: z900_execute_ccw_chain((DEVBLK*)pDevBlk); break;

  00044	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pDevBlk$[rsp]
  00049	e8 00 00 00 00	 call	 z900_execute_ccw_chain
  0004e	eb 17		 jmp	 SHORT $LN2@call_execu
$LN10@call_execu:
$LN6@call_execu:

; 6533 : #endif
; 6534 :         default: CRASH();

  00050	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00059	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0005e	c6 00 00	 mov	 BYTE PTR [rax], 0
  00061	33 c0		 xor	 eax, eax
  00063	85 c0		 test	 eax, eax
  00065	75 e9		 jne	 SHORT $LN6@call_execu
$LN2@call_execu:

; 6535 :     }
; 6536 : }

  00067	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006b	c3		 ret	 0
call_execute_ccw_chain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
devclass$1 = 32
dev$ = 64
chanstat$ = 72
unitstat$ = 80
is_ch9oflow PROC

; 89   : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 90   :     static const BYTE unitck = (CSW_CE | CSW_DE | CSW_UC);
; 91   : 
; 92   :     if (1
; 93   :         &&    0      == chanstat
; 94   :         &&  unitck   == unitstat
; 95   :         && SENSE_CH9 == dev->sense[0]
; 96   :         &&    0      == dev->sense[1]
; 97   :         && dev->hnd->query

  00012	33 c0		 xor	 eax, eax
  00014	83 f8 01	 cmp	 eax, 1
  00017	0f 84 a7 00 00
	00		 je	 $LN2@is_ch9oflo
  0001d	0f b6 44 24 48	 movzx	 eax, BYTE PTR chanstat$[rsp]
  00022	85 c0		 test	 eax, eax
  00024	0f 85 9a 00 00
	00		 jne	 $LN2@is_ch9oflo
  0002a	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?unitck@?1??is_ch9oflow@@9@9
  00031	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR unitstat$[rsp]
  00036	3b c1		 cmp	 eax, ecx
  00038	0f 85 86 00 00
	00		 jne	 $LN2@is_ch9oflo
  0003e	b8 01 00 00 00	 mov	 eax, 1
  00043	48 6b c0 00	 imul	 rax, rax, 0
  00047	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0004c	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  00054	83 f8 01	 cmp	 eax, 1
  00057	75 6b		 jne	 SHORT $LN2@is_ch9oflo
  00059	b8 01 00 00 00	 mov	 eax, 1
  0005e	48 6b c0 01	 imul	 rax, rax, 1
  00062	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00067	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  0006f	85 c0		 test	 eax, eax
  00071	75 51		 jne	 SHORT $LN2@is_ch9oflo
  00073	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00078	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0007f	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00084	74 3e		 je	 SHORT $LN2@is_ch9oflo

; 98   :     )
; 99   :     {
; 100  :         char* devclass = NULL;

  00086	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR devclass$1[rsp], 0

; 101  :         dev->hnd->query( NULL, &devclass, 0, NULL );

  0008f	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00094	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0009b	45 33 c9	 xor	 r9d, r9d
  0009e	45 33 c0	 xor	 r8d, r8d
  000a1	48 8d 54 24 20	 lea	 rdx, QWORD PTR devclass$1[rsp]
  000a6	33 c9		 xor	 ecx, ecx
  000a8	ff 50 18	 call	 QWORD PTR [rax+24]

; 102  :         if (strcmp( devclass, "PRT" ) == 0)

  000ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169899
  000b2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR devclass$1[rsp]
  000b7	e8 00 00 00 00	 call	 strcmp
  000bc	85 c0		 test	 eax, eax
  000be	75 04		 jne	 SHORT $LN3@is_ch9oflo

; 103  :             return TRUE;

  000c0	b0 01		 mov	 al, 1
  000c2	eb 02		 jmp	 SHORT $LN1@is_ch9oflo
$LN3@is_ch9oflo:
$LN2@is_ch9oflo:

; 104  :     }
; 105  :     return FALSE;

  000c4	32 c0		 xor	 al, al
$LN1@is_ch9oflo:

; 106  : }

  000c6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ca	c3		 ret	 0
is_ch9oflow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_or_dev_storage_key
_TEXT	SEGMENT
dev$ = 48
abs$ = 56
bits$ = 64
s370_or_dev_storage_key PROC				; COMDAT

; 299  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 300  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 301  :     ARCH_DEP( or_dev_2K_storage_key )( dev, abs, bits );

  00013	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR bits$[rsp]
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR abs$[rsp]
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00023	e8 00 00 00 00	 call	 s370_or_dev_2K_storage_key

; 302  : #else
; 303  :     ARCH_DEP( or_dev_4K_storage_key )( dev, abs, bits );
; 304  : #endif
; 305  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
s370_or_dev_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_get_dev_storage_key
_TEXT	SEGMENT
dev$ = 48
abs$ = 56
s370_get_dev_storage_key PROC				; COMDAT

; 263  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 264  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 265  :     return ARCH_DEP( get_dev_2K_storage_key )( dev, abs );

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR abs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00018	e8 00 00 00 00	 call	 s370_get_dev_2K_storage_key

; 266  : #else
; 267  :     return ARCH_DEP( get_dev_4K_storage_key )( dev, abs );
; 268  : #endif
; 269  : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
s370_get_dev_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_or_dev_2K_storage_key
_TEXT	SEGMENT
dev$ = 48
abs$ = 56
bits$ = 64
s370_or_dev_2K_storage_key PROC				; COMDAT

; 235  :   inline void  ARCH_DEP( or_dev_2K_storage_key )  ( DEVBLK* dev, U64 abs, BYTE bits ) {        ARCH_DEP( _or_dev_storage_key  )( dev, abs, bits & ~STORKEY_BADFRM, 2 ); }

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00013	0f b6 44 24 40	 movzx	 eax, BYTE PTR bits$[rsp]
  00018	83 e0 fe	 and	 eax, -2
  0001b	41 b1 02	 mov	 r9b, 2
  0001e	44 0f b6 c0	 movzx	 r8d, al
  00022	48 8b 54 24 38	 mov	 rdx, QWORD PTR abs$[rsp]
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0002c	e8 00 00 00 00	 call	 s370__or_dev_storage_key
  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
s370_or_dev_2K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_get_dev_2K_storage_key
_TEXT	SEGMENT
dev$ = 48
abs$ = 56
s370_get_dev_2K_storage_key PROC			; COMDAT

; 233  :   inline BYTE  ARCH_DEP( get_dev_2K_storage_key ) ( DEVBLK* dev, U64 abs            ) { return ARCH_DEP( _get_dev_storage_key )( dev, abs, 2 )  & ~STORKEY_BADFRM;      }

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	41 b0 02	 mov	 r8b, 2
  00011	48 8b 54 24 38	 mov	 rdx, QWORD PTR abs$[rsp]
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0001b	e8 00 00 00 00	 call	 s370__get_dev_storage_key
  00020	0f b6 c0	 movzx	 eax, al
  00023	83 e0 fe	 and	 eax, -2
  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
s370_get_dev_2K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370__or_dev_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
dev$ = 80
abs$ = 88
bits$ = 96
K$ = 104
s370__or_dev_storage_key PROC				; COMDAT

; 206  : {

$LN8:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s370__or_d:

; 207  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	75 fa		 jne	 SHORT $LN4@s370__or_d

; 208  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  0001e	0f b6 44 24 68	 movzx	 eax, BYTE PTR K$[rsp]
  00023	83 f8 04	 cmp	 eax, 4
  00026	75 61		 jne	 SHORT $LN5@s370__or_d
  00028	33 c0		 xor	 eax, eax
  0002a	83 f8 01	 cmp	 eax, 1
  0002d	74 5a		 je	 SHORT $LN5@s370__or_d

; 209  :     {
; 210  :         BYTE* skey1_ptr = _get_dev_storekey1_ptr( dev, abs );

  0002f	48 8b 54 24 58	 mov	 rdx, QWORD PTR abs$[rsp]
  00034	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00039	e8 00 00 00 00	 call	 _get_dev_storekey1_ptr
  0003e	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 211  :         BYTE* skey2_ptr = _get_dev_storekey2_ptr( dev, abs );

  00043	48 8b 54 24 58	 mov	 rdx, QWORD PTR abs$[rsp]
  00048	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0004d	e8 00 00 00 00	 call	 _get_dev_storekey2_ptr
  00052	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 212  :         OR_SKEY( skey1_ptr, bits );

  00057	0f b6 44 24 60	 movzx	 eax, BYTE PTR bits$[rsp]
  0005c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00061	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00064	0b c8		 or	 ecx, eax
  00066	8b c1		 mov	 eax, ecx
  00068	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  0006d	88 01		 mov	 BYTE PTR [rcx], al

; 213  :         OR_SKEY( skey2_ptr, bits );

  0006f	0f b6 44 24 60	 movzx	 eax, BYTE PTR bits$[rsp]
  00074	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00079	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0007c	0b c8		 or	 ecx, eax
  0007e	8b c1		 mov	 eax, ecx
  00080	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00085	88 01		 mov	 BYTE PTR [rcx], al

; 214  :     }

  00087	eb 32		 jmp	 SHORT $LN6@s370__or_d
$LN5@s370__or_d:

; 215  :     else
; 216  :     {
; 217  :         BYTE* skey_ptr  = _get_dev_storekey_ptr(  dev, abs, K );

  00089	44 0f b6 44 24
	68		 movzx	 r8d, BYTE PTR K$[rsp]
  0008f	48 8b 54 24 58	 mov	 rdx, QWORD PTR abs$[rsp]
  00094	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00099	e8 00 00 00 00	 call	 _get_dev_storekey_ptr
  0009e	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 218  :         OR_SKEY( skey_ptr, bits );

  000a3	0f b6 44 24 60	 movzx	 eax, BYTE PTR bits$[rsp]
  000a8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  000ad	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000b0	0b c8		 or	 ecx, eax
  000b2	8b c1		 mov	 eax, ecx
  000b4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  000b9	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s370__or_d:

; 219  :     }
; 220  : }

  000bb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000bf	c3		 ret	 0
s370__or_dev_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370__get_dev_storage_key
_TEXT	SEGMENT
skey$ = 32
dev$ = 64
abs$ = 72
K$ = 80
s370__get_dev_storage_key PROC				; COMDAT

; 144  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@s370__get_:

; 145  :     BYTE skey;
; 146  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	75 fa		 jne	 SHORT $LN4@s370__get_

; 147  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00019	0f b6 44 24 50	 movzx	 eax, BYTE PTR K$[rsp]
  0001e	83 f8 04	 cmp	 eax, 4
  00021	75 43		 jne	 SHORT $LN5@s370__get_
  00023	33 c0		 xor	 eax, eax
  00025	83 f8 01	 cmp	 eax, 1
  00028	74 3c		 je	 SHORT $LN5@s370__get_

; 148  :     {
; 149  :         skey  = *_get_dev_storekey1_ptr( dev, abs );

  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR abs$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00034	e8 00 00 00 00	 call	 _get_dev_storekey1_ptr
  00039	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003c	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 150  :         skey |= *_get_dev_storekey2_ptr( dev, abs ) & ~(STORKEY_KEY);

  00040	48 8b 54 24 48	 mov	 rdx, QWORD PTR abs$[rsp]
  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0004a	e8 00 00 00 00	 call	 _get_dev_storekey2_ptr
  0004f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00052	25 0f ff ff ff	 and	 eax, -241		; ffffffffffffff0fH
  00057	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR skey$[rsp]
  0005c	0b c8		 or	 ecx, eax
  0005e	8b c1		 mov	 eax, ecx
  00060	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 151  :     }

  00064	eb 1c		 jmp	 SHORT $LN6@s370__get_
$LN5@s370__get_:

; 152  :     else
; 153  :         skey  = *_get_dev_storekey_ptr(  dev, abs, K );

  00066	44 0f b6 44 24
	50		 movzx	 r8d, BYTE PTR K$[rsp]
  0006c	48 8b 54 24 48	 mov	 rdx, QWORD PTR abs$[rsp]
  00071	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00076	e8 00 00 00 00	 call	 _get_dev_storekey_ptr
  0007b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0007e	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al
$LN6@s370__get_:

; 154  :     return skey;

  00082	0f b6 44 24 20	 movzx	 eax, BYTE PTR skey$[rsp]

; 155  : }

  00087	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008b	c3		 ret	 0
s370__get_dev_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_dev_storekey2_ptr
_TEXT	SEGMENT
dev$ = 8
abs$ = 16
_get_dev_storekey2_ptr PROC				; COMDAT

; 72   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 73   :     ABS_CHECK( abs );
; 74   :     return &STOREKEY2( abs, dev );

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR abs$[rsp]
  0000f	48 c1 e8 0b	 shr	 rax, 11
  00013	48 83 c8 01	 or	 rax, 1
  00017	48 8b 4c 24 08	 mov	 rcx, QWORD PTR dev$[rsp]
  0001c	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  00023	48 03 c8	 add	 rcx, rax
  00026	48 8b c1	 mov	 rax, rcx

; 75   : }

  00029	c3		 ret	 0
_get_dev_storekey2_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_dev_storekey1_ptr
_TEXT	SEGMENT
dev$ = 8
abs$ = 16
_get_dev_storekey1_ptr PROC				; COMDAT

; 66   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 67   :     ABS_CHECK( abs );
; 68   :     return &STOREKEY1( abs, dev );

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR abs$[rsp]
  0000f	48 c1 e8 0b	 shr	 rax, 11
  00013	48 83 e0 fe	 and	 rax, -2
  00017	48 8b 4c 24 08	 mov	 rcx, QWORD PTR dev$[rsp]
  0001c	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  00023	48 03 c8	 add	 rcx, rax
  00026	48 8b c1	 mov	 rax, rcx

; 69   : }

  00029	c3		 ret	 0
_get_dev_storekey1_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_dev_storekey_ptr
_TEXT	SEGMENT
tv75 = 0
dev$ = 32
abs$ = 40
K$ = 48
_get_dev_storekey_ptr PROC				; COMDAT

; 47   : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 48   :     ABS_CHECK( abs );
; 49   :     return (4 == K) ? &STOREKEY1( abs, dev ) // (see feature.h PROGRAMMING NOTE)

  00013	0f b6 44 24 30	 movzx	 eax, BYTE PTR K$[rsp]
  00018	83 f8 04	 cmp	 eax, 4
  0001b	75 25		 jne	 SHORT $LN3@get_dev_st
  0001d	48 8b 44 24 28	 mov	 rax, QWORD PTR abs$[rsp]
  00022	48 c1 e8 0b	 shr	 rax, 11
  00026	48 83 e0 fe	 and	 rax, -2
  0002a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  0002f	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  00036	48 03 c8	 add	 rcx, rax
  00039	48 8b c1	 mov	 rax, rcx
  0003c	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
  00040	eb 1f		 jmp	 SHORT $LN4@get_dev_st
$LN3@get_dev_st:
  00042	48 8b 44 24 28	 mov	 rax, QWORD PTR abs$[rsp]
  00047	48 c1 e8 0b	 shr	 rax, 11
  0004b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  00050	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  00057	48 03 c8	 add	 rcx, rax
  0005a	48 8b c1	 mov	 rax, rcx
  0005d	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
$LN4@get_dev_st:
  00061	48 8b 04 24	 mov	 rax, QWORD PTR tv75[rsp]

; 50   :                     : &STOREKEY(  abs, dev );
; 51   : }

  00065	48 83 c4 18	 add	 rsp, 24
  00069	c3		 ret	 0
_get_dev_storekey_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Release_Interrupt_Lock PROC

; 403  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@Release_In:

; 404  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@Release_In

; 405  :     sysblk.intowner = LOCK_OWNER_NONE;

  00014	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00020	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 406  :     hthread_release_lock( &sysblk.intlock, location );

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00034	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 407  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
Release_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Obtain_Interrupt_Lock PROC

; 379  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 380  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	74 13		 je	 SHORT $LN2@Obtain_Int

; 381  :         HOSTREGS->intwait = true;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00022	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN2@Obtain_Int:

; 382  :     hthread_obtain_lock( &sysblk.intlock, location );

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00036	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 383  :     Interrupt_Lock_Obtained( regs, location );

  00044	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	e8 00 00 00 00	 call	 Interrupt_Lock_Obtained

; 384  : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
Obtain_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Interrupt_Lock_Obtained PROC

; 347  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 348  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	0f 84 db 00 00
	00		 je	 $LN4@Interrupt_
$LN2@Interrupt_:

; 349  :     {
; 350  :         /* Wait for any SYNCHRONIZE_CPUS to finish before proceeding */
; 351  :         while (sysblk.syncing)

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8f 00 00
	00		 je	 $LN3@Interrupt_

; 352  :         {
; 353  :             /* Indicate we have reached the sync point */
; 354  :             sysblk.sync_mask &= ~HOSTREGS->cpubit;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00035	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 f7 d0	 not	 rax
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004a	48 8b 89 80 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4992]
  00051	48 23 c8	 and	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 89 81 80 13
	00 00		 mov	 QWORD PTR [rcx+4992], rax

; 355  : 
; 356  :             /* If we're the last CPU to reach this sync point,
; 357  :                signal the CPU that requested the sync that it
; 358  :                may now safely proceed with its exclusive logic.
; 359  :             */
; 360  :             if (!sysblk.sync_mask)

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 83 b8 80 13
	00 00 00	 cmp	 QWORD PTR [rax+4992], 0
  00074	75 1b		 jne	 SHORT $LN6@Interrupt_

; 361  :                 hthread_signal_condition( &sysblk.all_synced_cond, location );

  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00083	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN6@Interrupt_:

; 362  : 
; 363  :             /* Wait for CPU that requested the sync to indicate
; 364  :                it's done and thus is now safe for us to proceed.
; 365  :             */
; 366  :             hthread_wait_condition( &sysblk.sync_done_cond, &sysblk.intlock, location );

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  000ac	4c 8b 44 24 38	 mov	 r8, QWORD PTR location$[rsp]
  000b1	48 8b d0	 mov	 rdx, rax
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 367  :         }

  000ba	e9 5b ff ff ff	 jmp	 $LN2@Interrupt_
$LN3@Interrupt_:

; 368  : 
; 369  :         HOSTREGS->intwait = false;

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cb	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0

; 370  :         sysblk.intowner = HOSTREGS->cpuad;

  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e5	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ec	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 371  :     }

  000f3	eb 13		 jmp	 SHORT $LN5@Interrupt_
$LN4@Interrupt_:

; 372  :     else
; 373  :         sysblk.intowner = LOCK_OWNER_OTHER;

  000f5	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00101	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN5@Interrupt_:

; 374  : }

  00108	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010c	c3		 ret	 0
Interrupt_Lock_Obtained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
i$ = 32
current_waittod$ = 40
lru_regs$ = 48
current_regs$ = 56
lru_waittod$ = 64
mask$ = 96
location$ = 104
wakeup_cpu_mask PROC

; 275  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 276  :     REGS*  current_regs;
; 277  :     REGS*  lru_regs = NULL;

  0000e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR lru_regs$[rsp], 0

; 278  :     TOD    current_waittod;
; 279  :     TOD    lru_waittod;
; 280  :     int    i;
; 281  : 
; 282  :     if (mask)

  00017	48 83 7c 24 60
	00		 cmp	 QWORD PTR mask$[rsp], 0
  0001d	0f 84 d3 00 00
	00		 je	 $LN5@wakeup_cpu

; 283  :     {
; 284  :         for (i=0; mask; mask >>= 1, ++i)

  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0002b	eb 17		 jmp	 SHORT $LN4@wakeup_cpu
$LN2@wakeup_cpu:
  0002d	48 8b 44 24 60	 mov	 rax, QWORD PTR mask$[rsp]
  00032	48 d1 e8	 shr	 rax, 1
  00035	48 89 44 24 60	 mov	 QWORD PTR mask$[rsp], rax
  0003a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0003e	ff c0		 inc	 eax
  00040	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@wakeup_cpu:
  00044	48 83 7c 24 60
	00		 cmp	 QWORD PTR mask$[rsp], 0
  0004a	0f 84 97 00 00
	00		 je	 $LN3@wakeup_cpu

; 285  :         {
; 286  :             if (mask & 1)

  00050	48 8b 44 24 60	 mov	 rax, QWORD PTR mask$[rsp]
  00055	48 83 e0 01	 and	 rax, 1
  00059	48 85 c0	 test	 rax, rax
  0005c	0f 84 80 00 00
	00		 je	 $LN6@wakeup_cpu

; 287  :             {
; 288  :                 current_regs = sysblk.regs[i];

  00062	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00067	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0006e	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00076	48 89 44 24 38	 mov	 QWORD PTR current_regs$[rsp], rax

; 289  :                 current_waittod = current_regs->waittod;

  0007b	48 8b 44 24 38	 mov	 rax, QWORD PTR current_regs$[rsp]
  00080	48 8b 80 b8 07
	00 00		 mov	 rax, QWORD PTR [rax+1976]
  00087	48 89 44 24 28	 mov	 QWORD PTR current_waittod$[rsp], rax

; 290  : 
; 291  :                 /* Select least recently used CPU
; 292  :                  *
; 293  :                  * The LRU CPU is chosen to keep the CPU threads active
; 294  :                  * and to distribute the I/O load across the available
; 295  :                  * CPUs.
; 296  :                  *
; 297  :                  * The current_waittod should never be zero; however,
; 298  :                  * we check it in case the cache from another processor
; 299  :                  * has not yet been written back to memory, which can
; 300  :                  * happen once the lock structure is updated for
; 301  :                  * individual CPU locks. (OBTAIN/RELEASE_INTLOCK(regs)
; 302  :                  * at present locks ALL CPUs, despite the specification
; 303  :                  * of regs.)
; 304  :                  */
; 305  :                 if (lru_regs == NULL ||

  0008c	48 83 7c 24 30
	00		 cmp	 QWORD PTR lru_regs$[rsp], 0
  00092	74 3a		 je	 SHORT $LN8@wakeup_cpu
  00094	48 83 7c 24 28
	00		 cmp	 QWORD PTR current_waittod$[rsp], 0
  0009a	76 46		 jbe	 SHORT $LN7@wakeup_cpu
  0009c	48 8b 44 24 40	 mov	 rax, QWORD PTR lru_waittod$[rsp]
  000a1	48 39 44 24 28	 cmp	 QWORD PTR current_waittod$[rsp], rax
  000a6	72 26		 jb	 SHORT $LN9@wakeup_cpu
  000a8	48 8b 44 24 40	 mov	 rax, QWORD PTR lru_waittod$[rsp]
  000ad	48 39 44 24 28	 cmp	 QWORD PTR current_waittod$[rsp], rax
  000b2	75 2e		 jne	 SHORT $LN7@wakeup_cpu
  000b4	48 8b 44 24 38	 mov	 rax, QWORD PTR current_regs$[rsp]
  000b9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lru_regs$[rsp]
  000be	48 8b 89 c0 07
	00 00		 mov	 rcx, QWORD PTR [rcx+1984]
  000c5	48 39 88 c0 07
	00 00		 cmp	 QWORD PTR [rax+1984], rcx
  000cc	72 14		 jb	 SHORT $LN7@wakeup_cpu
$LN9@wakeup_cpu:
$LN8@wakeup_cpu:

; 306  :                     (current_waittod > 0 &&
; 307  :                      (current_waittod < lru_waittod ||
; 308  :                       (current_waittod == lru_waittod &&
; 309  :                        current_regs->waittime >= lru_regs->waittime))))
; 310  :                 {
; 311  :                     lru_regs = current_regs;

  000ce	48 8b 44 24 38	 mov	 rax, QWORD PTR current_regs$[rsp]
  000d3	48 89 44 24 30	 mov	 QWORD PTR lru_regs$[rsp], rax

; 312  :                     lru_waittod = current_waittod;

  000d8	48 8b 44 24 28	 mov	 rax, QWORD PTR current_waittod$[rsp]
  000dd	48 89 44 24 40	 mov	 QWORD PTR lru_waittod$[rsp], rax
$LN7@wakeup_cpu:
$LN6@wakeup_cpu:

; 313  :                 }
; 314  :             }
; 315  :         }

  000e2	e9 46 ff ff ff	 jmp	 $LN2@wakeup_cpu
$LN3@wakeup_cpu:

; 316  : 
; 317  :         /* Wake up the least recently used CPU */
; 318  :         wakeup_cpu( lru_regs, location );

  000e7	48 8b 54 24 68	 mov	 rdx, QWORD PTR location$[rsp]
  000ec	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lru_regs$[rsp]
  000f1	e8 00 00 00 00	 call	 wakeup_cpu
$LN5@wakeup_cpu:

; 319  :     }
; 320  : }

  000f6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000fa	c3		 ret	 0
wakeup_cpu_mask ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
wakeup_cpu PROC

; 268  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 269  :     hthread_signal_condition( &regs->intcond, location );

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 05 80 0c 00
	00		 add	 rax, 3200		; 00000c80H
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0001e	48 8b c8	 mov	 rcx, rax
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 270  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
wakeup_cpu ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
tv71 = 32
pfx$ = 40
psa$ = 48
regs$ = 80
scsw$ = 88
store_scsw_as_csw PROC

; 172  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 173  :     PSA_3XX*   psa;            /* -> Prefixed storage area  */
; 174  :     RADR       pfx;            /* Current prefix            */
; 175  : 
; 176  :     /* Establish prefixing */
; 177  :     pfx =

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00013	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00019	d1 e8		 shr	 eax, 1
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 13		 je	 SHORT $LN3@store_scsw
  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00027	48 8b 80 90 08
	00 00		 mov	 rax, QWORD PTR [rax+2192]
  0002e	48 89 44 24 20	 mov	 QWORD PTR tv71[rsp], rax
  00033	eb 0d		 jmp	 SHORT $LN4@store_scsw
$LN3@store_scsw:
  00035	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0003a	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0003d	48 89 44 24 20	 mov	 QWORD PTR tv71[rsp], rax
$LN4@store_scsw:
  00042	48 8b 44 24 20	 mov	 rax, QWORD PTR tv71[rsp]
  00047	48 89 44 24 28	 mov	 QWORD PTR pfx$[rsp], rax

; 178  : #if defined(_FEATURE_SIE)
; 179  :           SIE_MODE(regs) ? regs->sie_px :
; 180  : #endif
; 181  :           regs->PX;
; 182  : 
; 183  :     /* Establish current PSA with prefixing applied */
; 184  :     psa = (PSA_3XX*)(regs->mainstor + pfx);

  0004c	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00051	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00058	48 03 44 24 28	 add	 rax, QWORD PTR pfx$[rsp]
  0005d	48 89 44 24 30	 mov	 QWORD PTR psa$[rsp], rax

; 185  : 
; 186  :     /* Store the channel status word at PSA+X'40' (64)*/
; 187  :     scsw2csw( scsw, psa->csw );

  00062	48 8b 44 24 30	 mov	 rax, QWORD PTR psa$[rsp]
  00067	48 83 c0 40	 add	 rax, 64			; 00000040H
  0006b	48 8b d0	 mov	 rdx, rax
  0006e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR scsw$[rsp]
  00073	e8 00 00 00 00	 call	 scsw2csw

; 188  : 
; 189  :     /* Update storage key for reference and change done by caller */
; 190  : }

  00078	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0007c	c3		 ret	 0
store_scsw_as_csw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
scsw$ = 8
csw$ = 16
scsw2csw PROC

; 162  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 163  :     memcpy( csw, scsw->ccwaddr, 8 );

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR csw$[rsp]
  0000f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR scsw$[rsp]
  00014	48 8b 49 04	 mov	 rcx, QWORD PTR [rcx+4]
  00018	48 89 08	 mov	 QWORD PTR [rax], rcx

; 164  :     csw[0] = scsw->flag0;

  0001b	b8 01 00 00 00	 mov	 eax, 1
  00020	48 6b c0 00	 imul	 rax, rax, 0
  00024	48 8b 4c 24 10	 mov	 rcx, QWORD PTR csw$[rsp]
  00029	48 8b 54 24 08	 mov	 rdx, QWORD PTR scsw$[rsp]
  0002e	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  00031	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 165  : }

  00034	c3		 ret	 0
scsw2csw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
x$ = 32
a$1 = 36
tv70 = 40
limit$ = 48
addr$ = 80
n$ = 88
__clear_io_buffer PROC

; 110  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 111  :     unsigned int x;
; 112  :     void* limit;
; 113  : 
; 114  :     /* Let the C compiler perform special case optimization */
; 115  :     if ((x = (U64)(uintptr_t)addr & 0x00000FFF))

  0000f	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00014	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0001a	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax
  0001e	83 7c 24 20 00	 cmp	 DWORD PTR x$[rsp], 0
  00023	74 42		 je	 SHORT $LN5@clear_io_b

; 116  :     {
; 117  :         unsigned int a = 4096 - x;

  00025	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  0002a	2b 44 24 20	 sub	 eax, DWORD PTR x$[rsp]
  0002e	89 44 24 24	 mov	 DWORD PTR a$1[rsp], eax

; 118  : 
; 119  :         __optimize_clear( addr, a );

  00032	8b 44 24 24	 mov	 eax, DWORD PTR a$1[rsp]
  00036	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
  0003b	48 8b 7c 24 50	 mov	 rdi, QWORD PTR addr$[rsp]
  00040	33 c0		 xor	 eax, eax
  00042	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv70[rsp]
  00047	f3 aa		 rep stosb

; 120  : 
; 121  :         if (!(n -= a))

  00049	8b 44 24 24	 mov	 eax, DWORD PTR a$1[rsp]
  0004d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR n$[rsp]
  00052	48 2b c8	 sub	 rcx, rax
  00055	48 8b c1	 mov	 rax, rcx
  00058	48 89 44 24 58	 mov	 QWORD PTR n$[rsp], rax
  0005d	48 83 7c 24 58
	00		 cmp	 QWORD PTR n$[rsp], 0
  00063	75 02		 jne	 SHORT $LN6@clear_io_b

; 122  :             return;

  00065	eb 7f		 jmp	 SHORT $LN1@clear_io_b
$LN6@clear_io_b:
$LN5@clear_io_b:

; 123  :     }
; 124  : 
; 125  :     /* Calculate page clear size */
; 126  :     if ((x = n & ~0x00000FFF))

  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  0006c	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00072	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax
  00076	83 7c 24 20 00	 cmp	 DWORD PTR x$[rsp], 0
  0007b	74 53		 je	 SHORT $LN7@clear_io_b

; 127  :     {
; 128  :         /* Set loop limit */
; 129  :         limit = (BYTE*)addr + x;

  0007d	8b 44 24 20	 mov	 eax, DWORD PTR x$[rsp]
  00081	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00086	48 03 c8	 add	 rcx, rax
  00089	48 8b c1	 mov	 rax, rcx
  0008c	48 89 44 24 30	 mov	 QWORD PTR limit$[rsp], rax

; 130  :         n -= x;

  00091	8b 44 24 20	 mov	 eax, DWORD PTR x$[rsp]
  00095	48 8b 4c 24 58	 mov	 rcx, QWORD PTR n$[rsp]
  0009a	48 2b c8	 sub	 rcx, rax
  0009d	48 8b c1	 mov	 rax, rcx
  000a0	48 89 44 24 58	 mov	 QWORD PTR n$[rsp], rax
$LN4@clear_io_b:

; 131  : 
; 132  :         /* Loop through pages */
; 133  :         do
; 134  :         {
; 135  :             __clear_page( addr, (size_t)( FOUR_KILOBYTE / 64 ) );

  000a5	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  000aa	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  000af	e8 00 00 00 00	 call	 __clear_page

; 136  :             addr = (BYTE*)addr + 4096;

  000b4	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  000b9	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  000bf	48 89 44 24 50	 mov	 QWORD PTR addr$[rsp], rax

; 137  :         }
; 138  :         while (addr < limit);

  000c4	48 8b 44 24 30	 mov	 rax, QWORD PTR limit$[rsp]
  000c9	48 39 44 24 50	 cmp	 QWORD PTR addr$[rsp], rax
  000ce	72 d5		 jb	 SHORT $LN4@clear_io_b
$LN7@clear_io_b:

; 139  :     }
; 140  : 
; 141  :     /* Clean up any remainder */
; 142  :     if (n)

  000d0	48 83 7c 24 58
	00		 cmp	 QWORD PTR n$[rsp], 0
  000d6	74 0e		 je	 SHORT $LN8@clear_io_b

; 143  :         __optimize_clear( addr, n );

  000d8	48 8b 7c 24 50	 mov	 rdi, QWORD PTR addr$[rsp]
  000dd	33 c0		 xor	 eax, eax
  000df	48 8b 4c 24 58	 mov	 rcx, QWORD PTR n$[rsp]
  000e4	f3 aa		 rep stosb
$LN8@clear_io_b:
$LN1@clear_io_b:

; 144  : 
; 145  :     return;
; 146  : 
; 147  : }

  000e6	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000ea	5f		 pop	 rdi
  000eb	c3		 ret	 0
__clear_io_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
i$ = 0
locaddr$ = 8
xmm0$ = 16
addr$ = 48
pgszmod64$ = 56
__clear_page PROC

; 49   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 50   :     // Variables of type __m128 map to one of the XMM[0-7] registers
; 51   :     // and are used with SSE and SSE2 instructions intrinsics defined
; 52   :     // in the <xmmintrin.h> header. They are automatically aligned
; 53   :     // on 16-byte boundaries. You should not access the __m128 fields
; 54   :     // directly. You can, however, see these types in the debugger.
; 55   : 
; 56   :     unsigned int i;                 /* (work var for loop) */
; 57   :     float* locaddr;                 /* local copy of addr  */
; 58   :     __m128 xmm0;                    /* (work XMM register) */
; 59   : 
; 60   :     /* Init work reg to 0 */
; 61   :     xmm0 = _mm_setzero_ps();        // (suppresses C4700; will be optimized out)

  0000e	0f 57 c0	 xorps	 xmm0, xmm0
  00011	0f 29 44 24 10	 movaps	 XMMWORD PTR xmm0$[rsp], xmm0

; 62   :     _mm_xor_ps( xmm0, xmm0 );
; 63   : 
; 64   :     /* Copy addr */
; 65   :     locaddr = addr;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR addr$[rsp]
  0001b	48 89 44 24 08	 mov	 QWORD PTR locaddr$[rsp], rax

; 66   : 
; 67   :     /* Clear requested page WITHOUT polluting our cache */
; 68   :     for (i=0; i < pgszmod64; i++, locaddr += 16)

  00020	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  00027	eb 16		 jmp	 SHORT $LN4@clear_page
$LN2@clear_page:
  00029	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0002c	ff c0		 inc	 eax
  0002e	89 04 24	 mov	 DWORD PTR i$[rsp], eax
  00031	48 8b 44 24 08	 mov	 rax, QWORD PTR locaddr$[rsp]
  00036	48 83 c0 40	 add	 rax, 64			; 00000040H
  0003a	48 89 44 24 08	 mov	 QWORD PTR locaddr$[rsp], rax
$LN4@clear_page:
  0003f	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00042	48 3b 44 24 38	 cmp	 rax, QWORD PTR pgszmod64$[rsp]
  00047	73 42		 jae	 SHORT $LN3@clear_page

; 69   :     {
; 70   :         _mm_stream_ps( locaddr+ 0, xmm0 );

  00049	48 8b 44 24 08	 mov	 rax, QWORD PTR locaddr$[rsp]
  0004e	0f 28 44 24 10	 movaps	 xmm0, XMMWORD PTR xmm0$[rsp]
  00053	0f 2b 00	 movntps XMMWORD PTR [rax], xmm0

; 71   :         _mm_stream_ps( locaddr+ 4, xmm0 );

  00056	48 8b 44 24 08	 mov	 rax, QWORD PTR locaddr$[rsp]
  0005b	48 83 c0 10	 add	 rax, 16
  0005f	0f 28 44 24 10	 movaps	 xmm0, XMMWORD PTR xmm0$[rsp]
  00064	0f 2b 00	 movntps XMMWORD PTR [rax], xmm0

; 72   :         _mm_stream_ps( locaddr+ 8, xmm0 );

  00067	48 8b 44 24 08	 mov	 rax, QWORD PTR locaddr$[rsp]
  0006c	48 83 c0 20	 add	 rax, 32			; 00000020H
  00070	0f 28 44 24 10	 movaps	 xmm0, XMMWORD PTR xmm0$[rsp]
  00075	0f 2b 00	 movntps XMMWORD PTR [rax], xmm0

; 73   :         _mm_stream_ps( locaddr+12, xmm0 );

  00078	48 8b 44 24 08	 mov	 rax, QWORD PTR locaddr$[rsp]
  0007d	48 83 c0 30	 add	 rax, 48			; 00000030H
  00081	0f 28 44 24 10	 movaps	 xmm0, XMMWORD PTR xmm0$[rsp]
  00086	0f 2b 00	 movntps XMMWORD PTR [rax], xmm0

; 74   :     }

  00089	eb 9e		 jmp	 SHORT $LN2@clear_page
$LN3@clear_page:

; 75   : 
; 76   :     /* Copy addr back */
; 77   :     addr = locaddr;

  0008b	48 8b 44 24 08	 mov	 rax, QWORD PTR locaddr$[rsp]
  00090	48 89 44 24 30	 mov	 QWORD PTR addr$[rsp], rax

; 78   : 
; 79   :     /* An SFENCE guarantees that every preceding store
; 80   :        is globally visible before any subsequent store. */
; 81   :     SFENCE();

  00095	f0 83 0c 24 00	 lock or DWORD PTR [rsp], 0

; 82   : 
; 83   :     return;
; 84   : }

  0009a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0009e	c3		 ret	 0
__clear_page ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
i$1 = 32
i$2 = 36
regs$3 = 40
mask$4 = 48
mask$5 = 56
wake$6 = 64
Update_IC_IOPENDING_QLocked PROC

; 6670 : {

$LN23:
  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 6671 :     if (!sysblk.iointq)

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	48 83 b8 28 12
	00 00 00	 cmp	 QWORD PTR [rax+4648], 0
  00013	0f 85 c5 00 00
	00		 jne	 $LN14@Update_IC_
$LN4@Update_IC_:

; 6672 :     {
; 6673 :         OFF_IC_IOPENDING;

  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00020	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00026	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0002b	85 c0		 test	 eax, eax
  0002d	0f 84 9c 00 00
	00		 je	 $LN16@Update_IC_
  00033	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003a	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00040	0f ba f0 1e	 btr	 eax, 30
  00044	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004b	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  00051	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00058	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  0005f	48 89 44 24 38	 mov	 QWORD PTR mask$5[rsp], rax
  00064	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  0006c	eb 0a		 jmp	 SHORT $LN7@Update_IC_
$LN5@Update_IC_:
  0006e	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00072	ff c0		 inc	 eax
  00074	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN7@Update_IC_:
  00078	48 83 7c 24 38
	00		 cmp	 QWORD PTR mask$5[rsp], 0
  0007e	74 4f		 je	 SHORT $LN6@Update_IC_
  00080	48 8b 44 24 38	 mov	 rax, QWORD PTR mask$5[rsp]
  00085	48 83 e0 01	 and	 rax, 1
  00089	48 85 c0	 test	 rax, rax
  0008c	74 32		 je	 SHORT $LN17@Update_IC_
  0008e	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  00093	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0009a	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000a2	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000a5	0f ba f0 1e	 btr	 eax, 30
  000a9	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$1[rsp]
  000ae	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  000b5	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  000bd	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN17@Update_IC_:
  000c0	48 8b 44 24 38	 mov	 rax, QWORD PTR mask$5[rsp]
  000c5	48 d1 e8	 shr	 rax, 1
  000c8	48 89 44 24 38	 mov	 QWORD PTR mask$5[rsp], rax
  000cd	eb 9f		 jmp	 SHORT $LN5@Update_IC_
$LN6@Update_IC_:
$LN16@Update_IC_:
  000cf	33 c0		 xor	 eax, eax
  000d1	85 c0		 test	 eax, eax
  000d3	0f 85 40 ff ff
	ff		 jne	 $LN4@Update_IC_

; 6674 :     }

  000d9	e9 1e 01 00 00	 jmp	 $LN15@Update_IC_
$LN14@Update_IC_:
$LN10@Update_IC_:

; 6675 :     else
; 6676 :     {
; 6677 :         ON_IC_IOPENDING;

  000de	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000e5	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  000ec	48 89 44 24 30	 mov	 QWORD PTR mask$4[rsp], rax
  000f1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000f8	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  000fe	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00103	85 c0		 test	 eax, eax
  00105	0f 85 e7 00 00
	00		 jne	 $LN18@Update_IC_
  0010b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00112	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00118	0f ba e8 1e	 bts	 eax, 30
  0011c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00123	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  00129	48 8b 44 24 30	 mov	 rax, QWORD PTR mask$4[rsp]
  0012e	48 89 44 24 40	 mov	 QWORD PTR wake$6[rsp], rax
  00133	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  0013b	eb 17		 jmp	 SHORT $LN13@Update_IC_
$LN11@Update_IC_:
  0013d	48 8b 44 24 30	 mov	 rax, QWORD PTR mask$4[rsp]
  00142	48 d1 e8	 shr	 rax, 1
  00145	48 89 44 24 30	 mov	 QWORD PTR mask$4[rsp], rax
  0014a	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  0014e	ff c0		 inc	 eax
  00150	89 44 24 24	 mov	 DWORD PTR i$2[rsp], eax
$LN13@Update_IC_:
  00154	48 83 7c 24 30
	00		 cmp	 QWORD PTR mask$4[rsp], 0
  0015a	0f 84 81 00 00
	00		 je	 $LN12@Update_IC_
  00160	48 8b 44 24 30	 mov	 rax, QWORD PTR mask$4[rsp]
  00165	48 83 e0 01	 and	 rax, 1
  00169	48 85 c0	 test	 rax, rax
  0016c	74 6e		 je	 SHORT $LN19@Update_IC_
  0016e	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$2[rsp]
  00173	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0017a	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00182	48 89 44 24 28	 mov	 QWORD PTR regs$3[rsp], rax
  00187	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$3[rsp]
  0018c	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0018f	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00194	85 c0		 test	 eax, eax
  00196	74 17		 je	 SHORT $LN20@Update_IC_
  00198	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$3[rsp]
  0019d	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  001a0	0d 00 00 00 c0	 or	 eax, -1073741824	; c0000000H
  001a5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$3[rsp]
  001aa	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  001ad	eb 2d		 jmp	 SHORT $LN21@Update_IC_
$LN20@Update_IC_:
  001af	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$3[rsp]
  001b4	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  001b7	0f ba e8 1e	 bts	 eax, 30
  001bb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$3[rsp]
  001c0	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  001c3	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$3[rsp]
  001c8	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  001cc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR wake$6[rsp]
  001d1	48 33 c8	 xor	 rcx, rax
  001d4	48 8b c1	 mov	 rax, rcx
  001d7	48 89 44 24 40	 mov	 QWORD PTR wake$6[rsp], rax
$LN21@Update_IC_:
$LN19@Update_IC_:
  001dc	e9 5c ff ff ff	 jmp	 $LN11@Update_IC_
$LN12@Update_IC_:
  001e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG197208
  001e8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR wake$6[rsp]
  001ed	e8 00 00 00 00	 call	 wakeup_cpu_mask
$LN18@Update_IC_:
  001f2	33 c0		 xor	 eax, eax
  001f4	85 c0		 test	 eax, eax
  001f6	0f 85 e2 fe ff
	ff		 jne	 $LN10@Update_IC_
$LN15@Update_IC_:

; 6678 :     }
; 6679 : }

  001fc	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00200	c3		 ret	 0
Update_IC_IOPENDING_QLocked ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
Update_IC_IOPENDING PROC

; 6663 : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 6664 :     obtain_lock( &sysblk.iointqlk );

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG197170
  00018	48 8b c8	 mov	 rcx, rax
  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 6665 :     Update_IC_IOPENDING_QLocked();

  00021	e8 00 00 00 00	 call	 Update_IC_IOPENDING_QLocked

; 6666 :     release_lock( &sysblk.iointqlk );

  00026	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002d	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG197171
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6667 : }

  00043	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00047	c3		 ret	 0
Update_IC_IOPENDING ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
rc$ = 0
prev$ = 8
io$ = 32
location$ = 40
Dequeue_IO_Interrupt_QLocked PROC

; 6615 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 6616 : IOINT* prev;
; 6617 : int rc = -1;        /* No I/O interrupts were queued for this device */

  0000e	c7 04 24 ff ff
	ff ff		 mov	 DWORD PTR rc$[rsp], -1
$LN4@Dequeue_IO:

; 6618 : 
; 6619 :     UNREFERENCED( location );

  00015	33 c0		 xor	 eax, eax
  00017	85 c0		 test	 eax, eax
  00019	75 fa		 jne	 SHORT $LN4@Dequeue_IO

; 6620 : 
; 6621 :     /* Search the I/O interrupt queue for an interrupt
; 6622 :        for this device and dequeue it if one is found. */
; 6623 :     for
; 6624 :     (
; 6625 :         prev = (IOINT*) &sysblk.iointq;

  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00022	48 05 28 12 00
	00		 add	 rax, 4648		; 00001228H
  00028	48 89 44 24 08	 mov	 QWORD PTR prev$[rsp], rax
  0002d	eb 0d		 jmp	 SHORT $LN7@Dequeue_IO
$LN5@Dequeue_IO:

; 6627 :         prev = prev->next

  0002f	48 8b 44 24 08	 mov	 rax, QWORD PTR prev$[rsp]
  00034	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00037	48 89 44 24 08	 mov	 QWORD PTR prev$[rsp], rax
$LN7@Dequeue_IO:

; 6626 :         prev->next != NULL;

  0003c	48 8b 44 24 08	 mov	 rax, QWORD PTR prev$[rsp]
  00041	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00045	0f 84 cd 00 00
	00		 je	 $LN6@Dequeue_IO

; 6628 :     )
; 6629 :     {
; 6630 :         /* Is this I/O interrupt for requested device? */
; 6631 :         if (prev->next == io)

  0004b	48 8b 44 24 08	 mov	 rax, QWORD PTR prev$[rsp]
  00050	48 8b 4c 24 20	 mov	 rcx, QWORD PTR io$[rsp]
  00055	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00058	0f 85 b5 00 00
	00		 jne	 $LN8@Dequeue_IO

; 6632 :         {
; 6633 :             /* Yes, dequeue the I/O interrupt and update
; 6634 :                device flags according to interrupt type. */
; 6635 :             prev->next = io->next;

  0005e	48 8b 44 24 08	 mov	 rax, QWORD PTR prev$[rsp]
  00063	48 8b 4c 24 20	 mov	 rcx, QWORD PTR io$[rsp]
  00068	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0006b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 6636 :                  if (io->pending)     io->dev->pending     = 0;

  0006e	48 8b 44 24 20	 mov	 rax, QWORD PTR io$[rsp]
  00073	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00076	83 e0 01	 and	 eax, 1
  00079	85 c0		 test	 eax, eax
  0007b	74 24		 je	 SHORT $LN9@Dequeue_IO
  0007d	48 8b 44 24 20	 mov	 rax, QWORD PTR io$[rsp]
  00082	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00086	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0008c	0f ba f0 16	 btr	 eax, 22
  00090	48 8b 4c 24 20	 mov	 rcx, QWORD PTR io$[rsp]
  00095	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00099	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
  0009f	eb 69		 jmp	 SHORT $LN10@Dequeue_IO
$LN9@Dequeue_IO:

; 6637 :             else if (io->pcipending)  io->dev->pcipending  = 0;

  000a1	48 8b 44 24 20	 mov	 rax, QWORD PTR io$[rsp]
  000a6	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000a9	d1 e8		 shr	 eax, 1
  000ab	83 e0 01	 and	 eax, 1
  000ae	85 c0		 test	 eax, eax
  000b0	74 24		 je	 SHORT $LN11@Dequeue_IO
  000b2	48 8b 44 24 20	 mov	 rax, QWORD PTR io$[rsp]
  000b7	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000bb	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000c1	0f ba f0 17	 btr	 eax, 23
  000c5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR io$[rsp]
  000ca	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000ce	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
  000d4	eb 34		 jmp	 SHORT $LN12@Dequeue_IO
$LN11@Dequeue_IO:

; 6638 :             else if (io->attnpending) io->dev->attnpending = 0;

  000d6	48 8b 44 24 20	 mov	 rax, QWORD PTR io$[rsp]
  000db	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000de	c1 e8 02	 shr	 eax, 2
  000e1	83 e0 01	 and	 eax, 1
  000e4	85 c0		 test	 eax, eax
  000e6	74 22		 je	 SHORT $LN13@Dequeue_IO
  000e8	48 8b 44 24 20	 mov	 rax, QWORD PTR io$[rsp]
  000ed	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000f1	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000f7	0f ba f0 18	 btr	 eax, 24
  000fb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR io$[rsp]
  00100	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00104	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
$LN13@Dequeue_IO:
$LN12@Dequeue_IO:
$LN10@Dequeue_IO:

; 6639 : 
; 6640 :             rc = 0;   /* I/O interrupt successfully dequeued */

  0010a	c7 04 24 00 00
	00 00		 mov	 DWORD PTR rc$[rsp], 0

; 6641 :             break;    /* I/O interrupt successfully dequeued */

  00111	eb 05		 jmp	 SHORT $LN6@Dequeue_IO
$LN8@Dequeue_IO:

; 6642 :         }
; 6643 :     }

  00113	e9 17 ff ff ff	 jmp	 $LN5@Dequeue_IO
$LN6@Dequeue_IO:

; 6644 : #if 0 // (debugging example)
; 6645 :     if (sysblk.fishtest && io->dev->devnum == 0x0604)
; 6646 :         TRACE("+++ %s interrupt %sDEQueued for %4.4X @ %s\n",
; 6647 :             io->pending     ? "Normal" :
; 6648 :             io->attnpending ? "ATTN"   :
; 6649 :             io->pcipending  ? "PCI"    : "UNKNOWN!",
; 6650 :             rc == 0 ? "" : "NOT ",
; 6651 :             io->dev->devnum, location );
; 6652 : #endif
; 6653 :     return rc;  /* rc=0: interrupt dequeued, rc=-1: NOTHING dequeued */

  00118	8b 04 24	 mov	 eax, DWORD PTR rc$[rsp]

; 6654 : }

  0011b	48 83 c4 18	 add	 rsp, 24
  0011f	c3		 ret	 0
Dequeue_IO_Interrupt_QLocked ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
rc$ = 32
io$ = 64
location$ = 72
Dequeue_IO_Interrupt PROC

; 6606 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6607 : int rc;
; 6608 :     obtain_lock( &sysblk.iointqlk );

  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00015	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG197146
  00022	48 8b c8	 mov	 rcx, rax
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 6609 :     rc = Dequeue_IO_Interrupt_QLocked( io, location );

  0002b	48 8b 54 24 48	 mov	 rdx, QWORD PTR location$[rsp]
  00030	48 8b 4c 24 40	 mov	 rcx, QWORD PTR io$[rsp]
  00035	e8 00 00 00 00	 call	 Dequeue_IO_Interrupt_QLocked
  0003a	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 6610 :     release_lock( &sysblk.iointqlk );

  0003e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00045	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG197147
  00052	48 8b c8	 mov	 rcx, rax
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6611 :     return rc;

  0005b	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 6612 : }

  0005f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00063	c3		 ret	 0
Dequeue_IO_Interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
prev$ = 0
io$ = 32
clrbsy$ = 40
location$ = 48
Queue_IO_Interrupt_QLocked PROC

; 6551 : {

$LN16:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 18	 sub	 rsp, 24
$LN4@Queue_IO_I:

; 6552 : IOINT* prev;
; 6553 : 
; 6554 :     UNREFERENCED( location );

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@Queue_IO_I

; 6555 : 
; 6556 :     /* Check if an I/O interrupt is already queued for this device */
; 6557 :     for
; 6558 :     (
; 6559 :         prev = (IOINT*) &sysblk.iointq;

  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001f	48 05 28 12 00
	00		 add	 rax, 4648		; 00001228H
  00025	48 89 04 24	 mov	 QWORD PTR prev$[rsp], rax
  00029	eb 0b		 jmp	 SHORT $LN7@Queue_IO_I
$LN5@Queue_IO_I:

; 6564 :         );
; 6565 :         prev = prev->next

  0002b	48 8b 04 24	 mov	 rax, QWORD PTR prev$[rsp]
  0002f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00032	48 89 04 24	 mov	 QWORD PTR prev$[rsp], rax
$LN7@Queue_IO_I:

; 6560 :         (1
; 6561 :             && prev->next != NULL
; 6562 :             && prev->next != io
; 6563 :             && prev->next->priority >= io->dev->priority

  00036	33 c0		 xor	 eax, eax
  00038	83 f8 01	 cmp	 eax, 1
  0003b	74 35		 je	 SHORT $LN6@Queue_IO_I
  0003d	48 8b 04 24	 mov	 rax, QWORD PTR prev$[rsp]
  00041	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00045	74 2b		 je	 SHORT $LN6@Queue_IO_I
  00047	48 8b 04 24	 mov	 rax, QWORD PTR prev$[rsp]
  0004b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR io$[rsp]
  00050	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00053	74 1d		 je	 SHORT $LN6@Queue_IO_I
  00055	48 8b 04 24	 mov	 rax, QWORD PTR prev$[rsp]
  00059	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR io$[rsp]
  00061	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00065	8b 89 18 02 00
	00		 mov	 ecx, DWORD PTR [rcx+536]
  0006b	39 48 10	 cmp	 DWORD PTR [rax+16], ecx
  0006e	7c 02		 jl	 SHORT $LN6@Queue_IO_I

; 6566 :     )
; 6567 :     {
; 6568 :         ;   /* (do nothing, we are only searching) */
; 6569 :     }

  00070	eb b9		 jmp	 SHORT $LN5@Queue_IO_I
$LN6@Queue_IO_I:

; 6570 : 
; 6571 :     /* If no interrupt in queue for this device then add one */
; 6572 :     if (prev->next != io)

  00072	48 8b 04 24	 mov	 rax, QWORD PTR prev$[rsp]
  00076	48 8b 4c 24 20	 mov	 rcx, QWORD PTR io$[rsp]
  0007b	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0007e	74 32		 je	 SHORT $LN8@Queue_IO_I

; 6573 :     {
; 6574 :         io->next     = prev->next;

  00080	48 8b 44 24 20	 mov	 rax, QWORD PTR io$[rsp]
  00085	48 8b 0c 24	 mov	 rcx, QWORD PTR prev$[rsp]
  00089	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0008c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 6575 :         prev->next   = io;

  0008f	48 8b 04 24	 mov	 rax, QWORD PTR prev$[rsp]
  00093	48 8b 4c 24 20	 mov	 rcx, QWORD PTR io$[rsp]
  00098	48 89 08	 mov	 QWORD PTR [rax], rcx

; 6576 :         io->priority = io->dev->priority;

  0009b	48 8b 44 24 20	 mov	 rax, QWORD PTR io$[rsp]
  000a0	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000a4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR io$[rsp]
  000a9	8b 80 18 02 00
	00		 mov	 eax, DWORD PTR [rax+536]
  000af	89 41 10	 mov	 DWORD PTR [rcx+16], eax
$LN8@Queue_IO_I:

; 6577 :     }
; 6578 : 
; 6579 :     /* Update device flags according to interrupt type */
; 6580 :          if (io->pending)     io->dev->pending     = 1;

  000b2	48 8b 44 24 20	 mov	 rax, QWORD PTR io$[rsp]
  000b7	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 24		 je	 SHORT $LN9@Queue_IO_I
  000c1	48 8b 44 24 20	 mov	 rax, QWORD PTR io$[rsp]
  000c6	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000ca	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000d0	0f ba e8 16	 bts	 eax, 22
  000d4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR io$[rsp]
  000d9	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000dd	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
  000e3	eb 69		 jmp	 SHORT $LN10@Queue_IO_I
$LN9@Queue_IO_I:

; 6581 :     else if (io->pcipending)  io->dev->pcipending  = 1;

  000e5	48 8b 44 24 20	 mov	 rax, QWORD PTR io$[rsp]
  000ea	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000ed	d1 e8		 shr	 eax, 1
  000ef	83 e0 01	 and	 eax, 1
  000f2	85 c0		 test	 eax, eax
  000f4	74 24		 je	 SHORT $LN11@Queue_IO_I
  000f6	48 8b 44 24 20	 mov	 rax, QWORD PTR io$[rsp]
  000fb	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000ff	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00105	0f ba e8 17	 bts	 eax, 23
  00109	48 8b 4c 24 20	 mov	 rcx, QWORD PTR io$[rsp]
  0010e	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00112	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
  00118	eb 34		 jmp	 SHORT $LN12@Queue_IO_I
$LN11@Queue_IO_I:

; 6582 :     else if (io->attnpending) io->dev->attnpending = 1;

  0011a	48 8b 44 24 20	 mov	 rax, QWORD PTR io$[rsp]
  0011f	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00122	c1 e8 02	 shr	 eax, 2
  00125	83 e0 01	 and	 eax, 1
  00128	85 c0		 test	 eax, eax
  0012a	74 22		 je	 SHORT $LN13@Queue_IO_I
  0012c	48 8b 44 24 20	 mov	 rax, QWORD PTR io$[rsp]
  00131	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00135	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0013b	0f ba e8 18	 bts	 eax, 24
  0013f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR io$[rsp]
  00144	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00148	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
$LN13@Queue_IO_I:
$LN12@Queue_IO_I:
$LN10@Queue_IO_I:

; 6583 : 
; 6584 :     /* While I/O interrupt queue is locked
; 6585 :        clear subchannel busy if asked to do so */
; 6586 :     if (clrbsy)

  0014e	0f b6 44 24 28	 movzx	 eax, BYTE PTR clrbsy$[rsp]
  00153	85 c0		 test	 eax, eax
  00155	74 68		 je	 SHORT $LN14@Queue_IO_I

; 6587 :     {
; 6588 :         io->dev->scsw.flag3 &= ~( SCSW3_AC_SCHAC |

  00157	48 8b 44 24 20	 mov	 rax, QWORD PTR io$[rsp]
  0015c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00160	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00167	25 37 ff ff ff	 and	 eax, -201		; ffffffffffffff37H
  0016c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR io$[rsp]
  00171	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00175	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 6589 :                                   SCSW3_AC_DEVAC |
; 6590 :                                   SCSW3_SC_INTER );
; 6591 :         io->dev->startpending = 0;

  0017b	48 8b 44 24 20	 mov	 rax, QWORD PTR io$[rsp]
  00180	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00184	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0018a	0f ba f0 19	 btr	 eax, 25
  0018e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR io$[rsp]
  00193	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00197	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 6592 :         io->dev->busy = 0;

  0019d	48 8b 44 24 20	 mov	 rax, QWORD PTR io$[rsp]
  001a2	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001a6	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001ac	0f ba f0 13	 btr	 eax, 19
  001b0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR io$[rsp]
  001b5	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  001b9	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
$LN14@Queue_IO_I:

; 6593 :     }
; 6594 : 
; 6595 : #if 0 // (debugging example)
; 6596 :     if (sysblk.fishtest && io->dev->devnum == 0x0604)
; 6597 :         TRACE("+++ %s interrupt Queued for %4.4X @ %s\n",
; 6598 :             io->pending     ? "Normal" :
; 6599 :             io->attnpending ? "ATTN"   :
; 6600 :             io->pcipending  ? "PCI"    : "UNKNOWN!",
; 6601 :             io->dev->devnum, location );
; 6602 : #endif
; 6603 : }

  001bf	48 83 c4 18	 add	 rsp, 24
  001c3	c3		 ret	 0
Queue_IO_Interrupt_QLocked ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
io$ = 48
clrbsy$ = 56
location$ = 64
Queue_IO_Interrupt PROC

; 6544 : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 6545 :     obtain_lock( &sysblk.iointqlk );

  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00019	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG197115
  00026	48 8b c8	 mov	 rcx, rax
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 6546 :     Queue_IO_Interrupt_QLocked( io, clrbsy, location );

  0002f	4c 8b 44 24 40	 mov	 r8, QWORD PTR location$[rsp]
  00034	0f b6 54 24 38	 movzx	 edx, BYTE PTR clrbsy$[rsp]
  00039	48 8b 4c 24 30	 mov	 rcx, QWORD PTR io$[rsp]
  0003e	e8 00 00 00 00	 call	 Queue_IO_Interrupt_QLocked

; 6547 :     release_lock( &sysblk.iointqlk );

  00043	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0004a	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  00050	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG197116
  00057	48 8b c8	 mov	 rcx, rax
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6548 : }

  00060	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00064	c3		 ret	 0
Queue_IO_Interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv68 = 160
tv73 = 168
tv78 = 176
tv83 = 184
tv88 = 192
tv93 = 200
tv130 = 208
tv135 = 216
tv140 = 224
tv145 = 232
tv150 = 240
tv155 = 248
tv160 = 256
tv165 = 264
tv170 = 272
tv175 = 280
buf$ = 304
buflen$ = 312
b0$ = 320
b1$ = 328
default_sns PROC

; 842  : {

$LN35:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H

; 843  :     snprintf( buf, buflen, "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s"

  0001b	0f b6 84 24 48
	01 00 00	 movzx	 eax, BYTE PTR b1$[rsp]
  00023	83 e0 01	 and	 eax, 1
  00026	85 c0		 test	 eax, eax
  00028	74 11		 je	 SHORT $LN3@default_sn
  0002a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170239
  00031	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv68[rsp], rax
  00039	eb 0f		 jmp	 SHORT $LN4@default_sn
$LN3@default_sn:
  0003b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170240
  00042	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv68[rsp], rax
$LN4@default_sn:
  0004a	0f b6 84 24 48
	01 00 00	 movzx	 eax, BYTE PTR b1$[rsp]
  00052	83 e0 02	 and	 eax, 2
  00055	85 c0		 test	 eax, eax
  00057	74 11		 je	 SHORT $LN5@default_sn
  00059	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170241
  00060	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv73[rsp], rax
  00068	eb 0f		 jmp	 SHORT $LN6@default_sn
$LN5@default_sn:
  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170242
  00071	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv73[rsp], rax
$LN6@default_sn:
  00079	0f b6 84 24 48
	01 00 00	 movzx	 eax, BYTE PTR b1$[rsp]
  00081	83 e0 04	 and	 eax, 4
  00084	85 c0		 test	 eax, eax
  00086	74 11		 je	 SHORT $LN7@default_sn
  00088	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170243
  0008f	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv78[rsp], rax
  00097	eb 0f		 jmp	 SHORT $LN8@default_sn
$LN7@default_sn:
  00099	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170244
  000a0	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv78[rsp], rax
$LN8@default_sn:
  000a8	0f b6 84 24 48
	01 00 00	 movzx	 eax, BYTE PTR b1$[rsp]
  000b0	83 e0 08	 and	 eax, 8
  000b3	85 c0		 test	 eax, eax
  000b5	74 11		 je	 SHORT $LN9@default_sn
  000b7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170245
  000be	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv83[rsp], rax
  000c6	eb 0f		 jmp	 SHORT $LN10@default_sn
$LN9@default_sn:
  000c8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170246
  000cf	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv83[rsp], rax
$LN10@default_sn:
  000d7	0f b6 84 24 48
	01 00 00	 movzx	 eax, BYTE PTR b1$[rsp]
  000df	83 e0 10	 and	 eax, 16
  000e2	85 c0		 test	 eax, eax
  000e4	74 11		 je	 SHORT $LN11@default_sn
  000e6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170247
  000ed	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv88[rsp], rax
  000f5	eb 0f		 jmp	 SHORT $LN12@default_sn
$LN11@default_sn:
  000f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170248
  000fe	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv88[rsp], rax
$LN12@default_sn:
  00106	0f b6 84 24 48
	01 00 00	 movzx	 eax, BYTE PTR b1$[rsp]
  0010e	83 e0 20	 and	 eax, 32			; 00000020H
  00111	85 c0		 test	 eax, eax
  00113	74 11		 je	 SHORT $LN13@default_sn
  00115	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170249
  0011c	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv93[rsp], rax
  00124	eb 0f		 jmp	 SHORT $LN14@default_sn
$LN13@default_sn:
  00126	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170250
  0012d	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv93[rsp], rax
$LN14@default_sn:
  00135	0f b6 84 24 48
	01 00 00	 movzx	 eax, BYTE PTR b1$[rsp]
  0013d	83 e0 40	 and	 eax, 64			; 00000040H
  00140	85 c0		 test	 eax, eax
  00142	74 11		 je	 SHORT $LN15@default_sn
  00144	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170251
  0014b	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv130[rsp], rax
  00153	eb 0f		 jmp	 SHORT $LN16@default_sn
$LN15@default_sn:
  00155	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170252
  0015c	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv130[rsp], rax
$LN16@default_sn:
  00164	0f b6 84 24 48
	01 00 00	 movzx	 eax, BYTE PTR b1$[rsp]
  0016c	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00171	85 c0		 test	 eax, eax
  00173	74 11		 je	 SHORT $LN17@default_sn
  00175	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170253
  0017c	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv135[rsp], rax
  00184	eb 0f		 jmp	 SHORT $LN18@default_sn
$LN17@default_sn:
  00186	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170254
  0018d	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv135[rsp], rax
$LN18@default_sn:
  00195	0f b6 84 24 40
	01 00 00	 movzx	 eax, BYTE PTR b0$[rsp]
  0019d	83 e0 01	 and	 eax, 1
  001a0	85 c0		 test	 eax, eax
  001a2	74 11		 je	 SHORT $LN19@default_sn
  001a4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170255
  001ab	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv140[rsp], rax
  001b3	eb 0f		 jmp	 SHORT $LN20@default_sn
$LN19@default_sn:
  001b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170256
  001bc	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv140[rsp], rax
$LN20@default_sn:
  001c4	0f b6 84 24 40
	01 00 00	 movzx	 eax, BYTE PTR b0$[rsp]
  001cc	83 e0 02	 and	 eax, 2
  001cf	85 c0		 test	 eax, eax
  001d1	74 11		 je	 SHORT $LN21@default_sn
  001d3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170257
  001da	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv145[rsp], rax
  001e2	eb 0f		 jmp	 SHORT $LN22@default_sn
$LN21@default_sn:
  001e4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170258
  001eb	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv145[rsp], rax
$LN22@default_sn:
  001f3	0f b6 84 24 40
	01 00 00	 movzx	 eax, BYTE PTR b0$[rsp]
  001fb	83 e0 04	 and	 eax, 4
  001fe	85 c0		 test	 eax, eax
  00200	74 11		 je	 SHORT $LN23@default_sn
  00202	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170259
  00209	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv150[rsp], rax
  00211	eb 0f		 jmp	 SHORT $LN24@default_sn
$LN23@default_sn:
  00213	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170260
  0021a	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv150[rsp], rax
$LN24@default_sn:
  00222	0f b6 84 24 40
	01 00 00	 movzx	 eax, BYTE PTR b0$[rsp]
  0022a	83 e0 08	 and	 eax, 8
  0022d	85 c0		 test	 eax, eax
  0022f	74 11		 je	 SHORT $LN25@default_sn
  00231	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170261
  00238	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv155[rsp], rax
  00240	eb 0f		 jmp	 SHORT $LN26@default_sn
$LN25@default_sn:
  00242	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170262
  00249	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv155[rsp], rax
$LN26@default_sn:
  00251	0f b6 84 24 40
	01 00 00	 movzx	 eax, BYTE PTR b0$[rsp]
  00259	83 e0 10	 and	 eax, 16
  0025c	85 c0		 test	 eax, eax
  0025e	74 11		 je	 SHORT $LN27@default_sn
  00260	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170263
  00267	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv160[rsp], rax
  0026f	eb 0f		 jmp	 SHORT $LN28@default_sn
$LN27@default_sn:
  00271	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170264
  00278	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv160[rsp], rax
$LN28@default_sn:
  00280	0f b6 84 24 40
	01 00 00	 movzx	 eax, BYTE PTR b0$[rsp]
  00288	83 e0 20	 and	 eax, 32			; 00000020H
  0028b	85 c0		 test	 eax, eax
  0028d	74 11		 je	 SHORT $LN29@default_sn
  0028f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170265
  00296	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv165[rsp], rax
  0029e	eb 0f		 jmp	 SHORT $LN30@default_sn
$LN29@default_sn:
  002a0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170266
  002a7	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv165[rsp], rax
$LN30@default_sn:
  002af	0f b6 84 24 40
	01 00 00	 movzx	 eax, BYTE PTR b0$[rsp]
  002b7	83 e0 40	 and	 eax, 64			; 00000040H
  002ba	85 c0		 test	 eax, eax
  002bc	74 11		 je	 SHORT $LN31@default_sn
  002be	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170267
  002c5	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv170[rsp], rax
  002cd	eb 0f		 jmp	 SHORT $LN32@default_sn
$LN31@default_sn:
  002cf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170268
  002d6	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv170[rsp], rax
$LN32@default_sn:
  002de	0f b6 84 24 40
	01 00 00	 movzx	 eax, BYTE PTR b0$[rsp]
  002e6	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002eb	85 c0		 test	 eax, eax
  002ed	74 11		 je	 SHORT $LN33@default_sn
  002ef	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170269
  002f6	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv175[rsp], rax
  002fe	eb 0f		 jmp	 SHORT $LN34@default_sn
$LN33@default_sn:
  00300	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170270
  00307	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv175[rsp], rax
$LN34@default_sn:
  0030f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv68[rsp]
  00317	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rax
  0031f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv73[rsp]
  00327	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rax
  0032f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv78[rsp]
  00337	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rax
  0033f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv83[rsp]
  00347	48 89 44 24 78	 mov	 QWORD PTR [rsp+120], rax
  0034c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv88[rsp]
  00354	48 89 44 24 70	 mov	 QWORD PTR [rsp+112], rax
  00359	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv93[rsp]
  00361	48 89 44 24 68	 mov	 QWORD PTR [rsp+104], rax
  00366	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv130[rsp]
  0036e	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  00373	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR tv135[rsp]
  0037b	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  00380	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv140[rsp]
  00388	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  0038d	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR tv145[rsp]
  00395	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0039a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR tv150[rsp]
  003a2	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  003a7	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR tv155[rsp]
  003af	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  003b4	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR tv160[rsp]
  003bc	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  003c1	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR tv165[rsp]
  003c9	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003ce	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR tv170[rsp]
  003d6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003db	4c 8b 8c 24 18
	01 00 00	 mov	 r9, QWORD PTR tv175[rsp]
  003e3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170271
  003ea	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR buflen$[rsp]
  003f2	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  003fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 844  : 
; 845  :             , (b0 & SENSE_CR  ) ? "CMDREJ " : ""
; 846  :             , (b0 & SENSE_IR  ) ? "INTREQ " : ""
; 847  :             , (b0 & SENSE_BOC ) ? "BUSCK "  : ""
; 848  :             , (b0 & SENSE_EC  ) ? "EQPCK "  : ""
; 849  :             , (b0 & SENSE_DC  ) ? "DATCK "  : ""
; 850  :             , (b0 & SENSE_OR  ) ? "OVRUN "  : ""
; 851  :             , (b0 & SENSE_CC  ) ? "CTLCK "  : ""
; 852  :             , (b0 & SENSE_OC  ) ? "OPRCK "  : ""
; 853  : 
; 854  :             , (b1 & SENSE1_PER) ? "PERM "   : ""
; 855  :             , (b1 & SENSE1_ITF) ? "ITF "    : ""
; 856  :             , (b1 & SENSE1_EOC) ? "EOC "    : ""
; 857  :             , (b1 & SENSE1_MTO) ? "MSG "    : ""
; 858  :             , (b1 & SENSE1_NRF) ? "NRF "    : ""
; 859  :             , (b1 & SENSE1_FP ) ? "FP "     : ""
; 860  :             , (b1 & SENSE1_WRI) ? "WRI "    : ""
; 861  :             , (b1 & SENSE1_IE ) ? "IE "     : ""
; 862  :     );
; 863  : }

  00400	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  00407	c3		 ret	 0
default_sns ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv167 = 80
tv173 = 84
rc$1 = 88
tv199 = 92
tv205 = 96
dev$ = 128
unitstat$ = 136
s370_device_attention PROC

; 4066 : {

$LN22:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 4067 :     OBTAIN_INTLOCK(NULL);

  0000d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171334
  00014	33 c9		 xor	 ecx, ecx
  00016	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 4068 :     obtain_lock( &dev->lock );

  0001b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00023	48 83 c0 38	 add	 rax, 56			; 00000038H
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171335
  0002e	48 8b c8	 mov	 rcx, rax
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4069 : 
; 4070 :     if (dev->hnd->attention)

  00037	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003f	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00046	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  0004b	74 1a		 je	 SHORT $LN2@s370_devic

; 4071 :         dev->hnd->attention( dev );

  0004d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00055	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0005c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00064	ff 50 78	 call	 QWORD PTR [rax+120]
$LN2@s370_devic:

; 4072 : 
; 4073 : #ifdef FEATURE_CHANNEL_SUBSYSTEM
; 4074 :     /* If subchannel not valid and enabled, do not present interrupt */
; 4075 :     if (0
; 4076 :         || (dev->pmcw.flag5 & PMCW5_V) == 0
; 4077 :         || (dev->pmcw.flag5 & PMCW5_E) == 0
; 4078 :     )
; 4079 :     {
; 4080 :         release_lock( &dev->lock );
; 4081 :         RELEASE_INTLOCK(NULL);
; 4082 :         return 3;
; 4083 :     }
; 4084 : #endif /*FEATURE_CHANNEL_SUBSYSTEM*/
; 4085 : 
; 4086 : 
; 4087 :     /* If device is already busy or interrupt pending */
; 4088 :     if (0
; 4089 :         || dev->busy
; 4090 :         || IOPENDING( dev )
; 4091 :         || (dev->scsw.flag3 & SCSW3_SC_PEND)

  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	0f 85 92 00 00
	00		 jne	 $LN4@s370_devic
  00071	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00079	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0007f	c1 e8 13	 shr	 eax, 19
  00082	83 e0 01	 and	 eax, 1
  00085	85 c0		 test	 eax, eax
  00087	75 7a		 jne	 SHORT $LN4@s370_devic
  00089	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00091	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00097	c1 e8 16	 shr	 eax, 22
  0009a	83 e0 01	 and	 eax, 1
  0009d	85 c0		 test	 eax, eax
  0009f	75 62		 jne	 SHORT $LN4@s370_devic
  000a1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a9	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000af	c1 e8 17	 shr	 eax, 23
  000b2	83 e0 01	 and	 eax, 1
  000b5	85 c0		 test	 eax, eax
  000b7	75 4a		 jne	 SHORT $LN4@s370_devic
  000b9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000c1	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000c7	c1 e8 18	 shr	 eax, 24
  000ca	83 e0 01	 and	 eax, 1
  000cd	85 c0		 test	 eax, eax
  000cf	75 32		 jne	 SHORT $LN4@s370_devic
  000d1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000d9	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000df	c1 e8 1b	 shr	 eax, 27
  000e2	83 e0 01	 and	 eax, 1
  000e5	85 c0		 test	 eax, eax
  000e7	75 1a		 jne	 SHORT $LN4@s370_devic
  000e9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000f1	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  000f8	83 e0 01	 and	 eax, 1
  000fb	85 c0		 test	 eax, eax
  000fd	0f 84 cd 01 00
	00		 je	 $LN3@s370_devic
$LN4@s370_devic:

; 4092 :     )
; 4093 :     {
; 4094 :         int rc;                         /* Return code               */
; 4095 : 
; 4096 :         /* Resume the suspended device with attention set            */
; 4097 :         /* SA22-7204-00:                                             */
; 4098 :         /*  p. 4-1, Attention                                        */
; 4099 :         if(dev->scsw.flag3 & SCSW3_AC_SUSP)

  00103	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0010b	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00112	83 e0 20	 and	 eax, 32			; 00000020H
  00115	85 c0		 test	 eax, eax
  00117	0f 84 78 01 00
	00		 je	 $LN5@s370_devic

; 4100 :         {
; 4101 :             unitstat |= CSW_ATTN;

  0011d	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR unitstat$[rsp]
  00125	0f ba e8 07	 bts	 eax, 7
  00129	88 84 24 88 00
	00 00		 mov	 BYTE PTR unitstat$[rsp], al

; 4102 : 
; 4103 :             dev->scsw.unitstat |= unitstat;

  00130	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR unitstat$[rsp]
  00138	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00140	0f b6 89 10 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+784]
  00147	0b c8		 or	 ecx, eax
  00149	8b c1		 mov	 eax, ecx
  0014b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00153	88 81 10 03 00
	00		 mov	 BYTE PTR [rcx+784], al

; 4104 :             dev->scsw.flag2    |= SCSW2_AC_RESUM;

  00159	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00161	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00168	83 c8 08	 or	 eax, 8
  0016b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00173	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 4105 :             dev->scsw.flag3    |= SCSW3_SC_ALERT | SCSW3_SC_PEND;

  00179	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00181	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00188	83 c8 11	 or	 eax, 17
  0018b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00193	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 4106 : 
; 4107 :             schedule_ioq( NULL, dev );

  00199	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  001a1	33 c9		 xor	 ecx, ecx
  001a3	e8 00 00 00 00	 call	 schedule_ioq

; 4108 : 
; 4109 :             if (dev->ccwtrace)

  001a8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001b0	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001b6	c1 e8 0f	 shr	 eax, 15
  001b9	83 e0 01	 and	 eax, 1
  001bc	85 c0		 test	 eax, eax
  001be	0f 84 c7 00 00
	00		 je	 $LN7@s370_devic

; 4110 :             {
; 4111 :                 if (sysblk.traceFILE)

  001c4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001cb	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  001d3	74 13		 je	 SHORT $LN8@s370_devic

; 4112 :                     tf_1304( dev );

  001d5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1304
  001e3	e9 a3 00 00 00	 jmp	 $LN9@s370_devic
$LN8@s370_devic:

; 4113 :                 else
; 4114 :                     // "%1d:%04X CHAN: attention signaled"
; 4115 :                     WRMSG( HHC01304, "I", LCSS_DEVNUM );

  001e8	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001f1	74 12		 je	 SHORT $LN14@s370_devic
  001f3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001fb	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001ff	89 44 24 50	 mov	 DWORD PTR tv167[rsp], eax
  00203	eb 08		 jmp	 SHORT $LN15@s370_devic
$LN14@s370_devic:
  00205	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv167[rsp], 0
$LN15@s370_devic:
  0020d	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00216	74 14		 je	 SHORT $LN16@s370_devic
  00218	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00220	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00224	d1 f8		 sar	 eax, 1
  00226	89 44 24 54	 mov	 DWORD PTR tv173[rsp], eax
  0022a	eb 08		 jmp	 SHORT $LN17@s370_devic
$LN16@s370_devic:
  0022c	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv173[rsp], 0
$LN17@s370_devic:
  00234	b9 01 00 00 00	 mov	 ecx, 1
  00239	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0023f	8b 4c 24 50	 mov	 ecx, DWORD PTR tv167[rsp]
  00243	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00247	8b 4c 24 54	 mov	 ecx, DWORD PTR tv173[rsp]
  0024b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0024f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171344
  00256	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0025b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171345
  00262	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00267	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0026c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00272	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171346
  00279	ba 13 10 00 00	 mov	 edx, 4115		; 00001013H
  0027e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171347
  00285	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@s370_devic:
$LN7@s370_devic:

; 4116 :             }
; 4117 :             rc = 0;

  0028b	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR rc$1[rsp], 0

; 4118 :         }

  00293	eb 08		 jmp	 SHORT $LN6@s370_devic
$LN5@s370_devic:

; 4119 :         else
; 4120 :             rc = 1;

  00295	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR rc$1[rsp], 1
$LN6@s370_devic:

; 4121 : 
; 4122 :         release_lock( &dev->lock );

  0029d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002a5	48 83 c0 38	 add	 rax, 56			; 00000038H
  002a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171348
  002b0	48 8b c8	 mov	 rcx, rax
  002b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4123 :         RELEASE_INTLOCK(NULL);

  002b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171349
  002c0	33 c9		 xor	 ecx, ecx
  002c2	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 4124 :         return rc;

  002c7	8b 44 24 58	 mov	 eax, DWORD PTR rc$1[rsp]
  002cb	e9 e9 01 00 00	 jmp	 $LN1@s370_devic
$LN3@s370_devic:

; 4125 :     }
; 4126 : 
; 4127 :     if (dev->ccwtrace)

  002d0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002d8	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  002de	c1 e8 0f	 shr	 eax, 15
  002e1	83 e0 01	 and	 eax, 1
  002e4	85 c0		 test	 eax, eax
  002e6	0f 84 c7 00 00
	00		 je	 $LN10@s370_devic

; 4128 :     {
; 4129 :         if (sysblk.traceFILE)

  002ec	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002f3	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  002fb	74 13		 je	 SHORT $LN11@s370_devic

; 4130 :             tf_1305( dev );

  002fd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00305	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1305
  0030b	e9 a3 00 00 00	 jmp	 $LN12@s370_devic
$LN11@s370_devic:

; 4131 :         else
; 4132 :             // "%1d:%04X CHAN: attention"
; 4133 :             WRMSG( HHC01305, "I", LCSS_DEVNUM );

  00310	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00319	74 12		 je	 SHORT $LN18@s370_devic
  0031b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00323	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00327	89 44 24 5c	 mov	 DWORD PTR tv199[rsp], eax
  0032b	eb 08		 jmp	 SHORT $LN19@s370_devic
$LN18@s370_devic:
  0032d	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv199[rsp], 0
$LN19@s370_devic:
  00335	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0033e	74 14		 je	 SHORT $LN20@s370_devic
  00340	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00348	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0034c	d1 f8		 sar	 eax, 1
  0034e	89 44 24 60	 mov	 DWORD PTR tv205[rsp], eax
  00352	eb 08		 jmp	 SHORT $LN21@s370_devic
$LN20@s370_devic:
  00354	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv205[rsp], 0
$LN21@s370_devic:
  0035c	b9 01 00 00 00	 mov	 ecx, 1
  00361	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00367	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv199[rsp]
  0036b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0036f	8b 4c 24 60	 mov	 ecx, DWORD PTR tv205[rsp]
  00373	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00377	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171353
  0037e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00383	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171354
  0038a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0038f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00394	41 b9 03 00 00
	00		 mov	 r9d, 3
  0039a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171355
  003a1	ba 25 10 00 00	 mov	 edx, 4133		; 00001025H
  003a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171356
  003ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN12@s370_devic:
$LN10@s370_devic:

; 4134 :     }
; 4135 : 
; 4136 :     /* We already have INTLOCK and dev->lock held, so now
; 4137 :        we only need to acquire the interrupt queue lock. */
; 4138 :     obtain_lock(&sysblk.iointqlk);

  003b3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003ba	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  003c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171357
  003c7	48 8b c8	 mov	 rcx, rax
  003ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4139 : 
; 4140 :     /* Set SCSW for attention interrupt                              */
; 4141 :     /* SA22-7201-05:                                                 */
; 4142 :     /*  p. 16-3, Unsolicited Interuption Condition                   */
; 4143 :     /*           Solicited Interuption Condition                     */
; 4144 :     /*           Figure 16-1, Interruption Condition for Status-     */
; 4145 :     /*                        Control-Bit Combinations               */
; 4146 :     /*  p. 16-4, Alert Interruption Condition                        */
; 4147 :     /*  p. 16-16 -- 16-17, Alert Status (Bit 27)                     */
; 4148 :     /*  p. 16-18, Status-Pending (Bit 31)                            */
; 4149 :     /*                                                               */
; 4150 :     /*  Hercules maintains for tracking purposes regardless of       */
; 4151 :     /*  architecture.                                                */
; 4152 :     /*                                                               */
; 4153 :     /* Set CSW for attention interrupt when in S/360 or S/370 mode,  */
; 4154 :     /* CSW will be derived from the SCSW when interrupt is issued    */
; 4155 :     /* SA22-7204-00:                                                 */
; 4156 :     /*  p. 4-1, Attention                                            */
; 4157 :     /* GA22-6974-09:                                                 */
; 4158 :     /*  pp. 2-13 -- 2-14, Attention                                  */
; 4159 :     dev->attnscsw.flag3 = SCSW3_SC_ALERT | SCSW3_SC_PEND;

  003d0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003d8	c6 80 23 03 00
	00 11		 mov	 BYTE PTR [rax+803], 17

; 4160 :     store_fw (dev->attnscsw.ccwaddr, 0);

  003df	33 c9		 xor	 ecx, ecx
  003e1	e8 00 00 00 00	 call	 _byteswap_ulong
  003e6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003ee	48 81 c1 24 03
	00 00		 add	 rcx, 804		; 00000324H
  003f5	8b d0		 mov	 edx, eax
  003f7	e8 00 00 00 00	 call	 store_fw_noswap

; 4161 :     dev->attnscsw.unitstat = unitstat;

  003fc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00404	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR unitstat$[rsp]
  0040c	88 88 28 03 00
	00		 mov	 BYTE PTR [rax+808], cl

; 4162 :     dev->attnscsw.chanstat = 0;

  00412	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0041a	c6 80 29 03 00
	00 00		 mov	 BYTE PTR [rax+809], 0

; 4163 :     store_hw (dev->attnscsw.count, 0);

  00421	33 c9		 xor	 ecx, ecx
  00423	e8 00 00 00 00	 call	 _byteswap_ushort
  00428	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00430	48 81 c1 2a 03
	00 00		 add	 rcx, 810		; 0000032aH
  00437	0f b7 d0	 movzx	 edx, ax
  0043a	e8 00 00 00 00	 call	 store_hw_noswap

; 4164 : 
; 4165 :     /* Queue the attention interrupt */
; 4166 :     QUEUE_IO_INTERRUPT_QLOCKED(&dev->attnioint,FALSE);

  0043f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00447	48 05 58 02 00
	00		 add	 rax, 600		; 00000258H
  0044d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171358
  00454	33 d2		 xor	 edx, edx
  00456	48 8b c8	 mov	 rcx, rax
  00459	e8 00 00 00 00	 call	 Queue_IO_Interrupt_QLocked

; 4167 : 
; 4168 :     /* Update interrupt status */
; 4169 :     subchannel_interrupt_queue_cleanup(dev);

  0045e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00466	e8 00 00 00 00	 call	 subchannel_interrupt_queue_cleanup

; 4170 :     UPDATE_IC_IOPENDING_QLOCKED();

  0046b	e8 00 00 00 00	 call	 Update_IC_IOPENDING_QLocked

; 4171 : 
; 4172 :     /* Release locks and return to caller */
; 4173 :     release_lock(&sysblk.iointqlk);

  00470	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00477	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  0047d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171359
  00484	48 8b c8	 mov	 rcx, rax
  00487	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4174 :     release_lock(&dev->lock);

  0048d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00495	48 83 c0 38	 add	 rax, 56			; 00000038H
  00499	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171360
  004a0	48 8b c8	 mov	 rcx, rax
  004a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4175 :     RELEASE_INTLOCK(NULL);

  004a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171361
  004b0	33 c9		 xor	 ecx, ecx
  004b2	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 4176 : 
; 4177 :     return 0;

  004b7	33 c0		 xor	 eax, eax
$LN1@s370_devic:

; 4178 : } /* end function device_attention */

  004b9	48 83 c4 78	 add	 rsp, 120		; 00000078H
  004bd	c3		 ret	 0
s370_device_attention ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv65 = 32
p$1 = 40
dev$ = 64
unitstat$ = 72
device_attention PROC

; 6500 : {

$LN14:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6501 :     switch(sysblk.arch_mode)

  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00014	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0001a	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  0001e	83 7c 24 20 00	 cmp	 DWORD PTR tv65[rsp], 0
  00023	74 10		 je	 SHORT $LN7@device_att
  00025	83 7c 24 20 01	 cmp	 DWORD PTR tv65[rsp], 1
  0002a	74 47		 je	 SHORT $LN10@device_att
  0002c	83 7c 24 20 02	 cmp	 DWORD PTR tv65[rsp], 2
  00031	74 51		 je	 SHORT $LN11@device_att
  00033	eb 60		 jmp	 SHORT $LN12@device_att
$LN7@device_att:

; 6502 :     {
; 6503 : #if defined(_370)
; 6504 :         case ARCH_370_IDX:
; 6505 :             /* Do NOT raise if initial power-on state */
; 6506 :             if (!INITIAL_POWERON_370())

  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003c	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00042	d1 e8		 shr	 eax, 1
  00044	83 e0 01	 and	 eax, 1
  00047	85 c0		 test	 eax, eax
  00049	75 10		 jne	 SHORT $LN9@device_att
  0004b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00052	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [rax+136], 0
  00059	74 11		 je	 SHORT $LN8@device_att
$LN9@device_att:

; 6507 :                 return s370_device_attention(dev, unitstat);

  0005b	0f b6 54 24 48	 movzx	 edx, BYTE PTR unitstat$[rsp]
  00060	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00065	e8 00 00 00 00	 call	 s370_device_attention
  0006a	eb 45		 jmp	 SHORT $LN1@device_att
$LN8@device_att:

; 6508 :             return 3;   /* subchannel is not valid or not enabled */

  0006c	b8 03 00 00 00	 mov	 eax, 3
  00071	eb 3e		 jmp	 SHORT $LN1@device_att
$LN10@device_att:

; 6509 : #endif
; 6510 : #if defined(_390)
; 6511 :         case ARCH_390_IDX: return s390_device_attention(dev, unitstat);

  00073	0f b6 54 24 48	 movzx	 edx, BYTE PTR unitstat$[rsp]
  00078	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0007d	e8 00 00 00 00	 call	 s390_device_attention
  00082	eb 2d		 jmp	 SHORT $LN1@device_att
$LN11@device_att:

; 6512 : #endif
; 6513 : #if defined(_900)
; 6514 :         case ARCH_900_IDX: return z900_device_attention(dev, unitstat);

  00084	0f b6 54 24 48	 movzx	 edx, BYTE PTR unitstat$[rsp]
  00089	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0008e	e8 00 00 00 00	 call	 z900_device_attention
  00093	eb 1c		 jmp	 SHORT $LN1@device_att
$LN12@device_att:
$LN6@device_att:

; 6515 : #endif
; 6516 :         default: CRASH();

  00095	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  0009e	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  000a3	c6 00 00	 mov	 BYTE PTR [rax], 0
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 e9		 jne	 SHORT $LN6@device_att

; 6517 :     }
; 6518 :     return 3;   /* subchannel is not valid or not enabled */

  000ac	b8 03 00 00 00	 mov	 eax, 3
$LN1@device_att:

; 6519 : }

  000b1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b5	c3		 ret	 0
device_attention ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv83 = 32
dev$ = 64
shared_iowait PROC

; 2969 : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN2@shared_iow:

; 2970 :     while (dev->shioactive != DEV_SYS_NONE
; 2971 :         && dev->shioactive != DEV_SYS_LOCAL)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	83 b8 e4 05 00
	00 00		 cmp	 DWORD PTR [rax+1508], 0
  00015	0f 84 8e 00 00
	00		 je	 $LN3@shared_iow
  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00020	81 b8 e4 05 00
	00 ff ff 00 00	 cmp	 DWORD PTR [rax+1508], 65535 ; 0000ffffH
  0002a	74 7d		 je	 SHORT $LN3@shared_iow

; 2972 :     {
; 2973 :         dev->shiowaiters++;

  0002c	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00031	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  00037	ff c0		 inc	 eax
  00039	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0003e	89 81 e0 05 00
	00		 mov	 DWORD PTR [rcx+1504], eax

; 2974 :         wait_condition(&dev->shiocond, &dev->lock);

  00044	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00049	48 83 c0 38	 add	 rax, 56			; 00000038H
  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00052	48 81 c1 d8 05
	00 00		 add	 rcx, 1496		; 000005d8H
  00059	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171031
  00060	48 8b d0	 mov	 rdx, rax
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 2975 :         dev->shiowaiters = MAX(0, dev->shiowaiters - 1);

  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0006e	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  00074	ff c8		 dec	 eax
  00076	85 c0		 test	 eax, eax
  00078	7d 0a		 jge	 SHORT $LN5@shared_iow
  0007a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
  00082	eb 11		 jmp	 SHORT $LN6@shared_iow
$LN5@shared_iow:
  00084	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00089	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  0008f	ff c8		 dec	 eax
  00091	89 44 24 20	 mov	 DWORD PTR tv83[rsp], eax
$LN6@shared_iow:
  00095	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0009a	8b 4c 24 20	 mov	 ecx, DWORD PTR tv83[rsp]
  0009e	89 88 e0 05 00
	00		 mov	 DWORD PTR [rax+1504], ecx

; 2976 :     }

  000a4	e9 60 ff ff ff	 jmp	 $LN2@shared_iow
$LN3@shared_iow:

; 2977 : }

  000a9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ad	c3		 ret	 0
shared_iowait ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_dw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_dw_noswap PROC					; COMDAT

; 816  :     inline U64 fetch_dw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 817  :       U64 value;
; 818  :       memcpy(&value, (BYTE *)ptr, 8);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 04 24	 mov	 QWORD PTR value$[rsp], rax

; 819  :       return value;

  00015	48 8b 04 24	 mov	 rax, QWORD PTR value$[rsp]

; 820  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
dev$ = 32
regs$ = 64
channelset_reset PROC

; 2421 : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2422 : DEVBLK *dev;                            /* -> Device control block   */
; 2423 : 
; 2424 :     /* Reset each device in the configuration */
; 2425 :     for (dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00010	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  00017	48 89 44 24 20	 mov	 QWORD PTR dev$[rsp], rax
  0001c	eb 0e		 jmp	 SHORT $LN4@channelset
$LN2@channelset:
  0001e	48 8b 44 24 20	 mov	 rax, QWORD PTR dev$[rsp]
  00023	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00027	48 89 44 24 20	 mov	 QWORD PTR dev$[rsp], rax
$LN4@channelset:
  0002c	48 83 7c 24 20
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00032	74 5a		 je	 SHORT $LN3@channelset

; 2426 :     {
; 2427 :         /* Skip "devices" that don't actually exist */
; 2428 :         if (!IS_DEV(dev))

  00034	48 8b 44 24 20	 mov	 rax, QWORD PTR dev$[rsp]
  00039	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  0003d	74 28		 je	 SHORT $LN6@channelset
  0003f	48 8b 44 24 20	 mov	 rax, QWORD PTR dev$[rsp]
  00044	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0004b	83 e0 01	 and	 eax, 1
  0004e	85 c0		 test	 eax, eax
  00050	75 17		 jne	 SHORT $LN5@channelset
  00052	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00059	48 8b 80 c8 11
	00 00		 mov	 rax, QWORD PTR [rax+4552]
  00060	48 39 44 24 20	 cmp	 QWORD PTR dev$[rsp], rax
  00065	74 02		 je	 SHORT $LN5@channelset
$LN6@channelset:

; 2429 :             continue;

  00067	eb b5		 jmp	 SHORT $LN2@channelset
$LN5@channelset:

; 2430 : 
; 2431 :         if( regs->chanset == dev->chanset)

  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	0f b7 80 38 08
	00 00		 movzx	 eax, WORD PTR [rax+2104]
  00075	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  0007a	0f b7 49 4c	 movzx	 ecx, WORD PTR [rcx+76]
  0007e	3b c1		 cmp	 eax, ecx
  00080	75 0a		 jne	 SHORT $LN7@channelset

; 2432 :             device_reset(dev);

  00082	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  00087	e8 00 00 00 00	 call	 device_reset
$LN7@channelset:

; 2433 :     }

  0008c	eb 90		 jmp	 SHORT $LN2@channelset
$LN3@channelset:

; 2434 : } /* end function channelset_reset */

  0008e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00092	c3		 ret	 0
channelset_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
i$ = 32
reset$ = 36
dev$ = 40
chpid$ = 64
solicited$ = 72
chp_reset PROC

; 2446 : {

$LN12:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00008	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2447 : DEVBLK *dev;                            /* -> Device control block   */
; 2448 : int i;
; 2449 : int reset = 0;

  0000c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR reset$[rsp], 0

; 2450 : 
; 2451 :     /* Reset each device in the configuration with this chpid */
; 2452 :     for (reset=0, dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  00014	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR reset$[rsp], 0
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00023	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  0002a	48 89 44 24 28	 mov	 QWORD PTR dev$[rsp], rax
  0002f	eb 0e		 jmp	 SHORT $LN4@chp_reset
$LN2@chp_reset:
  00031	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00036	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0003a	48 89 44 24 28	 mov	 QWORD PTR dev$[rsp], rax
$LN4@chp_reset:
  0003f	48 83 7c 24 28
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00045	0f 84 bf 00 00
	00		 je	 $LN3@chp_reset

; 2453 :     {
; 2454 :         /* Skip "devices" that don't actually exist */
; 2455 :         if (!IS_DEV(dev))

  0004b	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00050	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  00054	74 28		 je	 SHORT $LN9@chp_reset
  00056	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0005b	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00062	83 e0 01	 and	 eax, 1
  00065	85 c0		 test	 eax, eax
  00067	75 17		 jne	 SHORT $LN8@chp_reset
  00069	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00070	48 8b 80 c8 11
	00 00		 mov	 rax, QWORD PTR [rax+4552]
  00077	48 39 44 24 28	 cmp	 QWORD PTR dev$[rsp], rax
  0007c	74 02		 je	 SHORT $LN8@chp_reset
$LN9@chp_reset:

; 2456 :             continue;

  0007e	eb b1		 jmp	 SHORT $LN2@chp_reset
$LN8@chp_reset:

; 2457 : 
; 2458 :         for (i=0; i < 8; i++)

  00080	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00088	eb 0a		 jmp	 SHORT $LN7@chp_reset
$LN5@chp_reset:
  0008a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0008e	ff c0		 inc	 eax
  00090	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@chp_reset:
  00094	83 7c 24 20 08	 cmp	 DWORD PTR i$[rsp], 8
  00099	7d 6a		 jge	 SHORT $LN6@chp_reset

; 2459 :         {
; 2460 :             if((chpid == dev->pmcw.chpid[i])
; 2461 :               && (dev->pmcw.pim & dev->pmcw.pam & dev->pmcw.pom & (0x80 >> i)) )

  0009b	0f b6 44 24 40	 movzx	 eax, BYTE PTR chpid$[rsp]
  000a0	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000a5	48 8b 54 24 28	 mov	 rdx, QWORD PTR dev$[rsp]
  000aa	0f b6 8c 0a fc
	02 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+764]
  000b2	3b c1		 cmp	 eax, ecx
  000b4	75 4d		 jne	 SHORT $LN10@chp_reset
  000b6	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  000bb	0f b6 80 f7 02
	00 00		 movzx	 eax, BYTE PTR [rax+759]
  000c2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dev$[rsp]
  000c7	0f b6 89 fb 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+763]
  000ce	23 c1		 and	 eax, ecx
  000d0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dev$[rsp]
  000d5	0f b6 89 fa 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+762]
  000dc	23 c1		 and	 eax, ecx
  000de	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  000e2	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  000e7	d3 fa		 sar	 edx, cl
  000e9	8b ca		 mov	 ecx, edx
  000eb	23 c1		 and	 eax, ecx
  000ed	85 c0		 test	 eax, eax
  000ef	74 12		 je	 SHORT $LN10@chp_reset

; 2462 :             {
; 2463 :                 reset = 1;

  000f1	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR reset$[rsp], 1

; 2464 :                 device_reset(dev);

  000f9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dev$[rsp]
  000fe	e8 00 00 00 00	 call	 device_reset
$LN10@chp_reset:

; 2465 :             }
; 2466 :         }

  00103	eb 85		 jmp	 SHORT $LN5@chp_reset
$LN6@chp_reset:

; 2467 :     }

  00105	e9 27 ff ff ff	 jmp	 $LN2@chp_reset
$LN3@chp_reset:

; 2468 : 
; 2469 :     /* Indicate channel path reset completed */
; 2470 :     build_chp_reset_chrpt( chpid, solicited, reset );

  0010a	44 8b 44 24 24	 mov	 r8d, DWORD PTR reset$[rsp]
  0010f	8b 54 24 48	 mov	 edx, DWORD PTR solicited$[rsp]
  00113	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR chpid$[rsp]
  00118	e8 00 00 00 00	 call	 build_chp_reset_chrpt

; 2471 :     return 0;

  0011d	33 c0		 xor	 eax, eax

; 2472 : 
; 2473 : } /* end function chp_reset */

  0011f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00123	c3		 ret	 0
chp_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
i$ = 32
i$1 = 36
tv80 = 40
dev$ = 48
mask$2 = 56
io_reset PROC

; 2489 : {

$LN22:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2490 : DEVBLK *dev;                            /* -> Device control block   */
; 2491 : int i;
; 2492 : 
; 2493 :     /* Reset channel subsystem back to default initial non-MSS state */
; 2494 :     sysblk.mss = FALSE;                 /* (not enabled by default)  */

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	c7 80 00 12 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4608], 0

; 2495 :     sysblk.lcssmax = 0;                 /* (default to single lcss)  */

  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001c	c7 80 04 12 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4612], 0

; 2496 : 
; 2497 :     /* reset sclp interface */
; 2498 :     sclp_reset();

  00026	e8 00 00 00 00	 call	 sclp_reset

; 2499 : 
; 2500 :     /* Connect each channel set to its home cpu */
; 2501 :     for (i = 0; i < sysblk.maxcpu; i++)

  0002b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00033	eb 0a		 jmp	 SHORT $LN4@io_reset
$LN2@io_reset:
  00035	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00039	ff c0		 inc	 eax
  0003b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@io_reset:
  0003f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00046	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0004c	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00050	7d 52		 jge	 SHORT $LN3@io_reset

; 2502 :         if (IS_CPU_ONLINE(i))

  00052	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00067	74 39		 je	 SHORT $LN14@io_reset

; 2503 :             sysblk.regs[i]->chanset = i < FEATURE_LCSS_MAX ? i : 0xFFFF;

  00069	83 7c 24 20 04	 cmp	 DWORD PTR i$[rsp], 4
  0006e	7d 0a		 jge	 SHORT $LN20@io_reset
  00070	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00074	89 44 24 28	 mov	 DWORD PTR tv80[rsp], eax
  00078	eb 08		 jmp	 SHORT $LN21@io_reset
$LN20@io_reset:
  0007a	c7 44 24 28 ff
	ff 00 00	 mov	 DWORD PTR tv80[rsp], 65535 ; 0000ffffH
$LN21@io_reset:
  00082	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00087	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0008e	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00096	0f b7 4c 24 28	 movzx	 ecx, WORD PTR tv80[rsp]
  0009b	66 89 88 38 08
	00 00		 mov	 WORD PTR [rax+2104], cx
$LN14@io_reset:
  000a2	eb 91		 jmp	 SHORT $LN2@io_reset
$LN3@io_reset:

; 2504 : 
; 2505 :     /* Reset each device in the configuration */
; 2506 :     for (dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  000a4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ab	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  000b2	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax
  000b7	eb 0e		 jmp	 SHORT $LN7@io_reset
$LN5@io_reset:
  000b9	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  000be	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000c2	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax
$LN7@io_reset:
  000c7	48 83 7c 24 30
	00		 cmp	 QWORD PTR dev$[rsp], 0
  000cd	74 41		 je	 SHORT $LN6@io_reset

; 2507 :     {
; 2508 :         /* Skip "devices" that don't actually exist */
; 2509 :         if (!IS_DEV(dev))

  000cf	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  000d4	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  000d8	74 28		 je	 SHORT $LN16@io_reset
  000da	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  000df	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  000e6	83 e0 01	 and	 eax, 1
  000e9	85 c0		 test	 eax, eax
  000eb	75 17		 jne	 SHORT $LN15@io_reset
  000ed	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000f4	48 8b 80 c8 11
	00 00		 mov	 rax, QWORD PTR [rax+4552]
  000fb	48 39 44 24 30	 cmp	 QWORD PTR dev$[rsp], rax
  00100	74 02		 je	 SHORT $LN15@io_reset
$LN16@io_reset:

; 2510 :             continue;

  00102	eb b5		 jmp	 SHORT $LN5@io_reset
$LN15@io_reset:

; 2511 : 
; 2512 :         device_reset(dev);

  00104	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00109	e8 00 00 00 00	 call	 device_reset

; 2513 :     }

  0010e	eb a9		 jmp	 SHORT $LN5@io_reset
$LN6@io_reset:

; 2514 : 
; 2515 :     /* No crws pending anymore */
; 2516 :     OBTAIN_CRWLOCK();

  00110	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00117	48 05 08 12 00
	00		 add	 rax, 4616		; 00001208H
  0011d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170888
  00124	48 8b c8	 mov	 rcx, rax
  00127	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2517 :     sysblk.crwcount = 0;

  0012d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00134	c7 80 1c 12 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4636], 0

; 2518 :     sysblk.crwindex = 0;

  0013e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00145	c7 80 20 12 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4640], 0

; 2519 :     RELEASE_CRWLOCK();

  0014f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00156	48 05 08 12 00
	00		 add	 rax, 4616		; 00001208H
  0015c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170889
  00163	48 8b c8	 mov	 rcx, rax
  00166	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN10@io_reset:

; 2520 :     OFF_IC_CHANRPT;

  0016c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00173	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00179	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0017e	85 c0		 test	 eax, eax
  00180	0f 84 9c 00 00
	00		 je	 $LN17@io_reset
  00186	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0018d	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00193	0f ba f0 1c	 btr	 eax, 28
  00197	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0019e	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  001a4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001ab	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  001b2	48 89 44 24 38	 mov	 QWORD PTR mask$2[rsp], rax
  001b7	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  001bf	eb 0a		 jmp	 SHORT $LN13@io_reset
$LN11@io_reset:
  001c1	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  001c5	ff c0		 inc	 eax
  001c7	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
$LN13@io_reset:
  001cb	48 83 7c 24 38
	00		 cmp	 QWORD PTR mask$2[rsp], 0
  001d1	74 4f		 je	 SHORT $LN12@io_reset
  001d3	48 8b 44 24 38	 mov	 rax, QWORD PTR mask$2[rsp]
  001d8	48 83 e0 01	 and	 rax, 1
  001dc	48 85 c0	 test	 rax, rax
  001df	74 32		 je	 SHORT $LN18@io_reset
  001e1	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$1[rsp]
  001e6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001ed	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  001f5	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  001f8	0f ba f0 1c	 btr	 eax, 28
  001fc	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00201	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00208	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00210	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN18@io_reset:
  00213	48 8b 44 24 38	 mov	 rax, QWORD PTR mask$2[rsp]
  00218	48 d1 e8	 shr	 rax, 1
  0021b	48 89 44 24 38	 mov	 QWORD PTR mask$2[rsp], rax
  00220	eb 9f		 jmp	 SHORT $LN11@io_reset
$LN12@io_reset:
$LN17@io_reset:
  00222	33 c0		 xor	 eax, eax
  00224	85 c0		 test	 eax, eax
  00226	0f 85 40 ff ff
	ff		 jne	 $LN10@io_reset

; 2521 : 
; 2522 : } /* end function io_reset */

  0022c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00230	c3		 ret	 0
io_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv305 = 32
tv314 = 36
pDEVLIST$ = 40
dev$ = 48
pZoneDevs$ = 56
pPrevDEVLIST$ = 64
io$ = 72
ioid$ = 96
ioparm$ = 104
iointid$ = 112
zone$ = 120
s370_present_zone_io_interrupt PROC

; 6356 : {

$LN34:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 6357 : IOINT  *io;                             /* -> I/O interrupt entry    */
; 6358 : DEVBLK *dev;                            /* -> Device control block   */
; 6359 : typedef struct _DEVLIST {               /* list of device block ptrs */
; 6360 :     struct _DEVLIST *next;              /* next list entry or NULL   */
; 6361 :     DEVBLK          *dev;               /* DEVBLK in requested zone  */
; 6362 :     U16              ssid;              /* Subsystem ID incl. lcssid */
; 6363 :     U16              subchan;           /* Subchannel number         */
; 6364 :     FWORD            intparm;           /* Interruption parameter    */
; 6365 :     int              visc;              /* Guest Interrupt Subclass  */
; 6366 : } DEVLIST;
; 6367 : DEVLIST *pDEVLIST, *pPrevDEVLIST = NULL;/* (work)                    */

  00018	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR pPrevDEVLIST$[rsp], 0

; 6368 : DEVLIST *pZoneDevs = NULL;              /* devices in requested zone */

  00021	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR pZoneDevs$[rsp], 0

; 6369 : 
; 6370 :     /* Gather devices within our zone with pending interrupt flagged */
; 6371 :     for (dev = sysblk.firstdev; dev; dev = dev->nextdev)

  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00031	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  00038	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax
  0003d	eb 0e		 jmp	 SHORT $LN4@s370_prese
$LN2@s370_prese:
  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00044	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00048	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax
$LN4@s370_prese:
  0004d	48 83 7c 24 30
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00053	0f 84 7a 01 00
	00		 je	 $LN3@s370_prese

; 6372 :     {
; 6373 :         /* Skip "devices" that don't actually exist */
; 6374 :         if (!IS_DEV(dev))

  00059	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0005e	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  00062	74 28		 je	 SHORT $LN20@s370_prese
  00064	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00069	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00070	83 e0 01	 and	 eax, 1
  00073	85 c0		 test	 eax, eax
  00075	75 17		 jne	 SHORT $LN19@s370_prese
  00077	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007e	48 8b 80 c8 11
	00 00		 mov	 rax, QWORD PTR [rax+4552]
  00085	48 39 44 24 30	 cmp	 QWORD PTR dev$[rsp], rax
  0008a	74 02		 je	 SHORT $LN19@s370_prese
$LN20@s370_prese:

; 6375 :             continue;

  0008c	eb b1		 jmp	 SHORT $LN2@s370_prese
$LN19@s370_prese:

; 6376 : 
; 6377 :         obtain_lock (&dev->lock);

  0008e	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00093	48 83 c0 38	 add	 rax, 56			; 00000038H
  00097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171988
  0009e	48 8b c8	 mov	 rcx, rax
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 6378 : 
; 6379 :         if (1
; 6380 :             /* Subchannel valid and enabled */
; 6381 :             && ((dev->pmcw.flag5 & (PMCW5_E | PMCW5_V)) == (PMCW5_E | PMCW5_V))
; 6382 :             /* Within requested zone */
; 6383 :             && (dev->pmcw.zone == zone)
; 6384 :             /* Pending interrupt flagged */
; 6385 :             && ((dev->scsw.flag3 | dev->pciscsw.flag3) & SCSW3_SC_PEND)

  000a7	33 c0		 xor	 eax, eax
  000a9	83 f8 01	 cmp	 eax, 1
  000ac	0f 84 03 01 00
	00		 je	 $LN21@s370_prese
  000b2	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  000b7	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  000be	25 81 00 00 00	 and	 eax, 129		; 00000081H
  000c3	3d 81 00 00 00	 cmp	 eax, 129		; 00000081H
  000c8	0f 85 e7 00 00
	00		 jne	 $LN21@s370_prese
  000ce	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  000d3	0f b6 80 04 03
	00 00		 movzx	 eax, BYTE PTR [rax+772]
  000da	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR zone$[rsp]
  000df	3b c1		 cmp	 eax, ecx
  000e1	0f 85 ce 00 00
	00		 jne	 $LN21@s370_prese
  000e7	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  000ec	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  000f3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  000f8	0f b6 89 17 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+791]
  000ff	0b c1		 or	 eax, ecx
  00101	83 e0 01	 and	 eax, 1
  00104	85 c0		 test	 eax, eax
  00106	0f 84 a9 00 00
	00		 je	 $LN21@s370_prese

; 6386 :         )
; 6387 :         {
; 6388 :             /* (save this device for further scrutiny) */
; 6389 :             pDEVLIST          = (DEVLIST *)malloc( sizeof(DEVLIST) );

  0010c	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00117	48 89 44 24 28	 mov	 QWORD PTR pDEVLIST$[rsp], rax

; 6390 :             pDEVLIST->next    = NULL;

  0011c	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  00121	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 6391 :             pDEVLIST->dev     = dev;

  00128	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  0012d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00132	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 6392 :             pDEVLIST->ssid    = dev->ssid;

  00136	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  0013b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00140	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00144	66 89 48 10	 mov	 WORD PTR [rax+16], cx

; 6393 :             pDEVLIST->subchan = dev->subchan;

  00148	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  0014d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00152	0f b7 49 46	 movzx	 ecx, WORD PTR [rcx+70]
  00156	66 89 48 12	 mov	 WORD PTR [rax+18], cx

; 6394 : //          pDEVLIST->intparm = dev->pmcw.intparm;
; 6395 :             memcpy( pDEVLIST->intparm, dev->pmcw.intparm, sizeof(pDEVLIST->intparm) );

  0015a	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  0015f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00164	8b 89 ec 02 00
	00		 mov	 ecx, DWORD PTR [rcx+748]
  0016a	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 6396 :             pDEVLIST->visc    = (dev->pmcw.flag25 & PMCW25_VISC);

  0016d	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00172	0f b6 80 05 03
	00 00		 movzx	 eax, BYTE PTR [rax+773]
  00179	83 e0 07	 and	 eax, 7
  0017c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pDEVLIST$[rsp]
  00181	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 6397 : 
; 6398 :             if (!pZoneDevs)

  00184	48 83 7c 24 38
	00		 cmp	 QWORD PTR pZoneDevs$[rsp], 0
  0018a	75 0a		 jne	 SHORT $LN22@s370_prese

; 6399 :                 pZoneDevs = pDEVLIST;

  0018c	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  00191	48 89 44 24 38	 mov	 QWORD PTR pZoneDevs$[rsp], rax
$LN22@s370_prese:

; 6400 : 
; 6401 :             if (pPrevDEVLIST)

  00196	48 83 7c 24 40
	00		 cmp	 QWORD PTR pPrevDEVLIST$[rsp], 0
  0019c	74 0d		 je	 SHORT $LN23@s370_prese

; 6402 :                 pPrevDEVLIST->next = pDEVLIST;

  0019e	48 8b 44 24 40	 mov	 rax, QWORD PTR pPrevDEVLIST$[rsp]
  001a3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pDEVLIST$[rsp]
  001a8	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN23@s370_prese:

; 6403 : 
; 6404 :             pPrevDEVLIST = pDEVLIST;

  001ab	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  001b0	48 89 44 24 40	 mov	 QWORD PTR pPrevDEVLIST$[rsp], rax
$LN21@s370_prese:

; 6405 :         }
; 6406 : 
; 6407 :         release_lock (&dev->lock);

  001b5	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  001ba	48 83 c0 38	 add	 rax, 56			; 00000038H
  001be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171992
  001c5	48 8b c8	 mov	 rcx, rax
  001c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6408 :     }

  001ce	e9 6c fe ff ff	 jmp	 $LN2@s370_prese
$LN3@s370_prese:

; 6409 : 
; 6410 :     /* Exit with condition code 0 if no devices
; 6411 :        within our zone with a pending interrupt */
; 6412 :     if (!pZoneDevs)

  001d3	48 83 7c 24 38
	00		 cmp	 QWORD PTR pZoneDevs$[rsp], 0
  001d9	75 07		 jne	 SHORT $LN24@s370_prese

; 6413 :         return 0;

  001db	33 c0		 xor	 eax, eax
  001dd	e9 83 02 00 00	 jmp	 $LN1@s370_prese
$LN24@s370_prese:

; 6414 : 
; 6415 :     /* Remove from our list those devices
; 6416 :        without a pending interrupt queued */
; 6417 :     obtain_lock(&sysblk.iointqlk);

  001e2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001e9	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  001ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171994
  001f6	48 8b c8	 mov	 rcx, rax
  001f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 6418 :     for (pDEVLIST = pZoneDevs, pPrevDEVLIST = NULL; pDEVLIST;)

  001ff	48 8b 44 24 38	 mov	 rax, QWORD PTR pZoneDevs$[rsp]
  00204	48 89 44 24 28	 mov	 QWORD PTR pDEVLIST$[rsp], rax
  00209	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR pPrevDEVLIST$[rsp], 0
$LN5@s370_prese:
  00212	48 83 7c 24 28
	00		 cmp	 QWORD PTR pDEVLIST$[rsp], 0
  00218	0f 84 30 01 00
	00		 je	 $LN6@s370_prese

; 6419 :     {
; 6420 :         /* Search interrupt queue for this device */
; 6421 :         for (io = sysblk.iointq; io != NULL && io->dev != pDEVLIST->dev; io = io->next);

  0021e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00225	48 8b 80 28 12
	00 00		 mov	 rax, QWORD PTR [rax+4648]
  0022c	48 89 44 24 48	 mov	 QWORD PTR io$[rsp], rax
  00231	eb 0d		 jmp	 SHORT $LN10@s370_prese
$LN8@s370_prese:
  00233	48 8b 44 24 48	 mov	 rax, QWORD PTR io$[rsp]
  00238	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0023b	48 89 44 24 48	 mov	 QWORD PTR io$[rsp], rax
$LN10@s370_prese:
  00240	48 83 7c 24 48
	00		 cmp	 QWORD PTR io$[rsp], 0
  00246	74 16		 je	 SHORT $LN9@s370_prese
  00248	48 8b 44 24 48	 mov	 rax, QWORD PTR io$[rsp]
  0024d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pDEVLIST$[rsp]
  00252	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00256	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  0025a	74 02		 je	 SHORT $LN9@s370_prese
  0025c	eb d5		 jmp	 SHORT $LN8@s370_prese
$LN9@s370_prese:

; 6422 : 
; 6423 :         /* Is interrupt queued for this device? */
; 6424 :         if (io == NULL)

  0025e	48 83 7c 24 48
	00		 cmp	 QWORD PTR io$[rsp], 0
  00264	0f 85 c8 00 00
	00		 jne	 $LN25@s370_prese

; 6425 :         {
; 6426 :             /* No, remove it from our list */
; 6427 :             if (!pPrevDEVLIST)

  0026a	48 83 7c 24 40
	00		 cmp	 QWORD PTR pPrevDEVLIST$[rsp], 0
  00270	0f 85 92 00 00
	00		 jne	 $LN27@s370_prese
$LN13@s370_prese:

; 6428 :             {
; 6429 :                 ASSERT(pDEVLIST == pZoneDevs);

  00276	48 8b 44 24 38	 mov	 rax, QWORD PTR pZoneDevs$[rsp]
  0027b	48 39 44 24 28	 cmp	 QWORD PTR pDEVLIST$[rsp], rax
  00280	74 5c		 je	 SHORT $LN29@s370_prese
$LN16@s370_prese:
  00282	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172000
  00289	41 b8 1d 19 00
	00		 mov	 r8d, 6429		; 0000191dH
  0028f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172001
  00296	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172002
  0029d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  002a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  002a9	85 c0		 test	 eax, eax
  002ab	74 20		 je	 SHORT $LN30@s370_prese
  002ad	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172004
  002b4	41 b8 1d 19 00
	00		 mov	 r8d, 6429		; 0000191dH
  002ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172005
  002c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172006
  002c8	e8 00 00 00 00	 call	 DebuggerTrace
$LN30@s370_prese:
  002cd	33 c0		 xor	 eax, eax
  002cf	85 c0		 test	 eax, eax
  002d1	75 af		 jne	 SHORT $LN16@s370_prese
  002d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  002d9	85 c0		 test	 eax, eax
  002db	74 01		 je	 SHORT $LN31@s370_prese
  002dd	cc		 int	 3
$LN31@s370_prese:
$LN29@s370_prese:
  002de	33 c0		 xor	 eax, eax
  002e0	85 c0		 test	 eax, eax
  002e2	75 92		 jne	 SHORT $LN13@s370_prese

; 6430 :                 pZoneDevs = pDEVLIST->next;

  002e4	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  002e9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002ec	48 89 44 24 38	 mov	 QWORD PTR pZoneDevs$[rsp], rax

; 6431 :                 free(pDEVLIST);

  002f1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pDEVLIST$[rsp]
  002f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6432 :                 pDEVLIST = pZoneDevs;

  002fc	48 8b 44 24 38	 mov	 rax, QWORD PTR pZoneDevs$[rsp]
  00301	48 89 44 24 28	 mov	 QWORD PTR pDEVLIST$[rsp], rax

; 6433 :             }

  00306	eb 28		 jmp	 SHORT $LN28@s370_prese
$LN27@s370_prese:

; 6434 :             else
; 6435 :             {
; 6436 :                 pPrevDEVLIST->next = pDEVLIST->next;

  00308	48 8b 44 24 40	 mov	 rax, QWORD PTR pPrevDEVLIST$[rsp]
  0030d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pDEVLIST$[rsp]
  00312	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00315	48 89 08	 mov	 QWORD PTR [rax], rcx

; 6437 :                 free(pDEVLIST);

  00318	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pDEVLIST$[rsp]
  0031d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6438 :                 pDEVLIST = pPrevDEVLIST->next;

  00323	48 8b 44 24 40	 mov	 rax, QWORD PTR pPrevDEVLIST$[rsp]
  00328	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0032b	48 89 44 24 28	 mov	 QWORD PTR pDEVLIST$[rsp], rax
$LN28@s370_prese:

; 6439 :             }
; 6440 :         }

  00330	eb 17		 jmp	 SHORT $LN26@s370_prese
$LN25@s370_prese:

; 6441 :         else
; 6442 :         {
; 6443 :             /* Yes, go on to next list entry */
; 6444 :             pPrevDEVLIST = pDEVLIST;

  00332	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  00337	48 89 44 24 40	 mov	 QWORD PTR pPrevDEVLIST$[rsp], rax

; 6445 :             pDEVLIST = pDEVLIST->next;

  0033c	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  00341	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00344	48 89 44 24 28	 mov	 QWORD PTR pDEVLIST$[rsp], rax
$LN26@s370_prese:

; 6446 :         }
; 6447 :     }

  00349	e9 c4 fe ff ff	 jmp	 $LN5@s370_prese
$LN6@s370_prese:

; 6448 :     release_lock(&sysblk.iointqlk);

  0034e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00355	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  0035b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172008
  00362	48 8b c8	 mov	 rcx, rax
  00365	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6449 : 
; 6450 :     /* If no devices remain, exit with condition code 0 */
; 6451 :     if (!pZoneDevs)

  0036b	48 83 7c 24 38
	00		 cmp	 QWORD PTR pZoneDevs$[rsp], 0
  00371	75 07		 jne	 SHORT $LN32@s370_prese

; 6452 :         return 0;

  00373	33 c0		 xor	 eax, eax
  00375	e9 eb 00 00 00	 jmp	 $LN1@s370_prese
$LN32@s370_prese:

; 6453 : 
; 6454 :     /* Extract the I/O address and interrupt parameter
; 6455 :        for the first pending subchannel */
; 6456 :     dev = pZoneDevs->dev;

  0037a	48 8b 44 24 38	 mov	 rax, QWORD PTR pZoneDevs$[rsp]
  0037f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00383	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax

; 6457 :     *ioid = (pZoneDevs->ssid << 16) | pZoneDevs->subchan;

  00388	48 8b 44 24 38	 mov	 rax, QWORD PTR pZoneDevs$[rsp]
  0038d	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  00391	c1 e0 10	 shl	 eax, 16
  00394	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pZoneDevs$[rsp]
  00399	0f b7 49 12	 movzx	 ecx, WORD PTR [rcx+18]
  0039d	0b c1		 or	 eax, ecx
  0039f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ioid$[rsp]
  003a4	89 01		 mov	 DWORD PTR [rcx], eax

; 6458 :     FETCH_FW(*ioparm,pZoneDevs->intparm);

  003a6	48 8b 44 24 38	 mov	 rax, QWORD PTR pZoneDevs$[rsp]
  003ab	48 83 c0 14	 add	 rax, 20
  003af	48 8b c8	 mov	 rcx, rax
  003b2	e8 00 00 00 00	 call	 fetch_fw_noswap
  003b7	8b c8		 mov	 ecx, eax
  003b9	e8 00 00 00 00	 call	 _byteswap_ulong
  003be	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ioparm$[rsp]
  003c3	89 01		 mov	 DWORD PTR [rcx], eax

; 6459 :     *iointid = (0x80000000 >> pZoneDevs->visc) | (zone << 16);

  003c5	48 8b 44 24 38	 mov	 rax, QWORD PTR pZoneDevs$[rsp]
  003ca	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  003cd	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  003d2	89 4c 24 20	 mov	 DWORD PTR tv305[rsp], ecx
  003d6	0f b6 c8	 movzx	 ecx, al
  003d9	8b 44 24 20	 mov	 eax, DWORD PTR tv305[rsp]
  003dd	d3 e8		 shr	 eax, cl
  003df	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR zone$[rsp]
  003e4	c1 e1 10	 shl	 ecx, 16
  003e7	0b c1		 or	 eax, ecx
  003e9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR iointid$[rsp]
  003ee	89 01		 mov	 DWORD PTR [rcx], eax

; 6460 :     pDEVLIST = pZoneDevs->next;

  003f0	48 8b 44 24 38	 mov	 rax, QWORD PTR pZoneDevs$[rsp]
  003f5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003f8	48 89 44 24 28	 mov	 QWORD PTR pDEVLIST$[rsp], rax

; 6461 :     free (pZoneDevs);

  003fd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pZoneDevs$[rsp]
  00402	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN17@s370_prese:

; 6462 : 
; 6463 :     /* Find all other pending subclasses */
; 6464 :     while (pDEVLIST)

  00408	48 83 7c 24 28
	00		 cmp	 QWORD PTR pDEVLIST$[rsp], 0
  0040e	74 50		 je	 SHORT $LN18@s370_prese

; 6465 :     {
; 6466 :         *iointid |= (0x80000000 >> pDEVLIST->visc);

  00410	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  00415	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00418	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  0041d	89 4c 24 24	 mov	 DWORD PTR tv314[rsp], ecx
  00421	0f b6 c8	 movzx	 ecx, al
  00424	8b 44 24 24	 mov	 eax, DWORD PTR tv314[rsp]
  00428	d3 e8		 shr	 eax, cl
  0042a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR iointid$[rsp]
  0042f	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00431	0b c8		 or	 ecx, eax
  00433	8b c1		 mov	 eax, ecx
  00435	48 8b 4c 24 70	 mov	 rcx, QWORD PTR iointid$[rsp]
  0043a	89 01		 mov	 DWORD PTR [rcx], eax

; 6467 :         pPrevDEVLIST = pDEVLIST;

  0043c	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  00441	48 89 44 24 40	 mov	 QWORD PTR pPrevDEVLIST$[rsp], rax

; 6468 :         pDEVLIST = pDEVLIST->next;

  00446	48 8b 44 24 28	 mov	 rax, QWORD PTR pDEVLIST$[rsp]
  0044b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0044e	48 89 44 24 28	 mov	 QWORD PTR pDEVLIST$[rsp], rax

; 6469 :         free (pPrevDEVLIST);

  00453	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pPrevDEVLIST$[rsp]
  00458	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6470 :     }

  0045e	eb a8		 jmp	 SHORT $LN17@s370_prese
$LN18@s370_prese:

; 6471 : 
; 6472 :     /* Exit with condition code indicating interrupt pending */
; 6473 :     return 1;

  00460	b8 01 00 00 00	 mov	 eax, 1
$LN1@s370_prese:

; 6474 : 
; 6475 : } /* end function present_zone_io_interrupt */

  00465	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00469	c3		 ret	 0
s370_present_zone_io_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
dev$ = 48
io$ = 56
dotsch$ = 64
icode$ = 68
i$1 = 72
tv277 = 76
mask$2 = 80
tv231 = 88
tv251 = 92
io2$ = 96
wake$3 = 104
regs$4 = 112
cc$5 = 120
scsw$6 = 128
p$7 = 136
ioint$8 = 144
irb$9 = 160
__$ArrayPad$ = 224
regs$ = 256
ioid$ = 264
ioparm$ = 272
iointid$ = 280
csw$ = 288
pdev$ = 296
s370_present_io_interrupt PROC

; 6042 : {

$LN68:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 6043 : IOINT  *io, *io2;                       /* -> I/O interrupt entry    */
; 6044 : DEVBLK *dev;                            /* -> Device control block   */
; 6045 : int     icode = 0;                      /* Intercept code            */

  0002d	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR icode$[rsp], 0

; 6046 : bool    dotsch = true;                  /* perform TSCH after int    */

  00035	c6 44 24 40 01	 mov	 BYTE PTR dotsch$[rsp], 1
$LN4@s370_prese:

; 6047 :                                         /* except for THININT        */
; 6048 : 
; 6049 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY) || defined(_FEATURE_IO_ASSIST)
; 6050 : #if defined(FEATURE_QDIO_THININT)
; 6051 : /* The 2 following variables are only used for QDIO Thin Interrupt Processing */
; 6052 : bool    saved_dotsch  = dotsch;
; 6053 : bool    PCI_dequeued  = false;
; 6054 : #endif
; 6055 : #endif
; 6056 : 
; 6057 :     UNREFERENCED_370(ioparm);

  0003a	33 c0		 xor	 eax, eax
  0003c	85 c0		 test	 eax, eax
  0003e	75 fa		 jne	 SHORT $LN4@s370_prese
$LN7@s370_prese:

; 6058 :     UNREFERENCED_370(iointid);

  00040	33 c0		 xor	 eax, eax
  00042	85 c0		 test	 eax, eax
  00044	75 fa		 jne	 SHORT $LN7@s370_prese
$LN10@s370_prese:

; 6059 : #if defined(_FEATURE_IO_ASSIST)
; 6060 :     UNREFERENCED_390(iointid);

  00046	33 c0		 xor	 eax, eax
  00048	85 c0		 test	 eax, eax
  0004a	75 fa		 jne	 SHORT $LN10@s370_prese
$LN13@s370_prese:

; 6061 : #endif
; 6062 :     UNREFERENCED_390(csw);

  0004c	33 c0		 xor	 eax, eax
  0004e	85 c0		 test	 eax, eax
  00050	75 fa		 jne	 SHORT $LN13@s370_prese
$LN16@s370_prese:

; 6063 :     UNREFERENCED_900(csw);

  00052	33 c0		 xor	 eax, eax
  00054	85 c0		 test	 eax, eax
  00056	75 fa		 jne	 SHORT $LN16@s370_prese
$retry$69:

; 6064 : 
; 6065 : retry:
; 6066 : 
; 6067 :     /* Find a device with pending interrupt...
; 6068 : 
; 6069 :        Please remember that the device lock CANNOT be acquired
; 6070 :        while iointqlk is held. The iointqlk MUST be acquired AFTER
; 6071 :        the device lock is first acquired. Thus the retry logic.
; 6072 :     */
; 6073 :     dev = NULL;

  00058	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR dev$[rsp], 0

; 6074 : 
; 6075 :     obtain_lock( &sysblk.iointqlk );

  00061	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00068	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171895
  00075	48 8b c8	 mov	 rcx, rax
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 6076 :     {
; 6077 :         for (io = sysblk.iointq; io != NULL; io = io->next)

  0007e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00085	48 8b 80 28 12
	00 00		 mov	 rax, QWORD PTR [rax+4648]
  0008c	48 89 44 24 38	 mov	 QWORD PTR io$[rsp], rax
  00091	eb 0d		 jmp	 SHORT $LN19@s370_prese
$LN17@s370_prese:
  00093	48 8b 44 24 38	 mov	 rax, QWORD PTR io$[rsp]
  00098	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009b	48 89 44 24 38	 mov	 QWORD PTR io$[rsp], rax
$LN19@s370_prese:
  000a0	48 83 7c 24 38
	00		 cmp	 QWORD PTR io$[rsp], 0
  000a6	0f 84 17 01 00
	00		 je	 $LN18@s370_prese

; 6078 :         {
; 6079 :             /* Can't present interrupt while TEST SUBCHANNEL required
; 6080 :              * (interrupt already presented for this device)
; 6081 :              */
; 6082 :             if (io->dev->tschpending)

  000ac	48 8b 44 24 38	 mov	 rax, QWORD PTR io$[rsp]
  000b1	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000b5	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000bb	c1 e8 1b	 shr	 eax, 27
  000be	83 e0 01	 and	 eax, 1
  000c1	85 c0		 test	 eax, eax
  000c3	74 02		 je	 SHORT $LN40@s370_prese

; 6083 :                 continue;

  000c5	eb cc		 jmp	 SHORT $LN17@s370_prese
$LN40@s370_prese:

; 6084 : 
; 6085 :             /* Exit loop if enabled for interrupts from this device */
; 6086 :             if ((icode = ARCH_DEP( interrupt_enabled )( regs, io->dev ))
; 6087 : 
; 6088 : #if defined( _FEATURE_IO_ASSIST )
; 6089 :               && icode != SIE_INTERCEPT_IOINTP

  000c7	48 8b 44 24 38	 mov	 rax, QWORD PTR io$[rsp]
  000cc	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000d0	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d8	e8 00 00 00 00	 call	 s370_interrupt_enabled
  000dd	89 44 24 44	 mov	 DWORD PTR icode$[rsp], eax
  000e1	83 7c 24 44 00	 cmp	 DWORD PTR icode$[rsp], 0
  000e6	74 1a		 je	 SHORT $LN41@s370_prese
  000e8	83 7c 24 44 f0	 cmp	 DWORD PTR icode$[rsp], -16
  000ed	74 13		 je	 SHORT $LN41@s370_prese

; 6090 : #endif
; 6091 :             )
; 6092 :             {
; 6093 :                 dev = io->dev;

  000ef	48 8b 44 24 38	 mov	 rax, QWORD PTR io$[rsp]
  000f4	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000f8	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax

; 6094 :                 break;

  000fd	e9 c1 00 00 00	 jmp	 $LN18@s370_prese
$LN41@s370_prese:

; 6095 :             }
; 6096 : 
; 6097 :             /* See if another CPU can take this interrupt */
; 6098 :             {
; 6099 :                 REGS *regs;
; 6100 :                 CPU_BITMAP mask = sysblk.waiting_mask;

  00102	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00109	48 8b 80 b8 12
	00 00		 mov	 rax, QWORD PTR [rax+4792]
  00110	48 89 44 24 50	 mov	 QWORD PTR mask$2[rsp], rax

; 6101 :                 CPU_BITMAP wake;
; 6102 :                 int i;
; 6103 : 
; 6104 :                 /* If any CPUs are waiting, isolate to subgroup enabled for
; 6105 :                  * I/O interrupts.
; 6106 :                  */
; 6107 :                 if (mask)

  00115	48 83 7c 24 50
	00		 cmp	 QWORD PTR mask$2[rsp], 0
  0011b	0f 84 9d 00 00
	00		 je	 $LN42@s370_prese

; 6108 :                 {
; 6109 :                     wake = mask;

  00121	48 8b 44 24 50	 mov	 rax, QWORD PTR mask$2[rsp]
  00126	48 89 44 24 68	 mov	 QWORD PTR wake$3[rsp], rax

; 6110 : 
; 6111 :                     /* Turn off wake mask bits for waiting CPUs that aren't
; 6112 :                      * enabled for I/O interrupts for the device.
; 6113 :                      */
; 6114 :                     for (i=0; mask; mask >>= 1, ++i)

  0012b	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00133	eb 17		 jmp	 SHORT $LN22@s370_prese
$LN20@s370_prese:
  00135	48 8b 44 24 50	 mov	 rax, QWORD PTR mask$2[rsp]
  0013a	48 d1 e8	 shr	 rax, 1
  0013d	48 89 44 24 50	 mov	 QWORD PTR mask$2[rsp], rax
  00142	8b 44 24 48	 mov	 eax, DWORD PTR i$1[rsp]
  00146	ff c0		 inc	 eax
  00148	89 44 24 48	 mov	 DWORD PTR i$1[rsp], eax
$LN22@s370_prese:
  0014c	48 83 7c 24 50
	00		 cmp	 QWORD PTR mask$2[rsp], 0
  00152	74 59		 je	 SHORT $LN21@s370_prese

; 6115 :                     {
; 6116 :                         if (mask & 1)

  00154	48 8b 44 24 50	 mov	 rax, QWORD PTR mask$2[rsp]
  00159	48 83 e0 01	 and	 rax, 1
  0015d	48 85 c0	 test	 rax, rax
  00160	74 49		 je	 SHORT $LN43@s370_prese

; 6117 :                         {
; 6118 :                             regs = sysblk.regs[i];

  00162	48 63 44 24 48	 movsxd	 rax, DWORD PTR i$1[rsp]
  00167	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0016e	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00176	48 89 44 24 70	 mov	 QWORD PTR regs$4[rsp], rax

; 6119 : 
; 6120 :                             if (!ARCH_DEP( interrupt_enabled )( regs, io->dev ))

  0017b	48 8b 44 24 38	 mov	 rax, QWORD PTR io$[rsp]
  00180	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00184	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$4[rsp]
  00189	e8 00 00 00 00	 call	 s370_interrupt_enabled
  0018e	85 c0		 test	 eax, eax
  00190	75 19		 jne	 SHORT $LN44@s370_prese

; 6121 :                                 wake ^= regs->cpubit;

  00192	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$4[rsp]
  00197	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  0019b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR wake$3[rsp]
  001a0	48 33 c8	 xor	 rcx, rax
  001a3	48 8b c1	 mov	 rax, rcx
  001a6	48 89 44 24 68	 mov	 QWORD PTR wake$3[rsp], rax
$LN44@s370_prese:
$LN43@s370_prese:

; 6122 :                         }
; 6123 :                     }

  001ab	eb 88		 jmp	 SHORT $LN20@s370_prese
$LN21@s370_prese:

; 6124 : 
; 6125 :                     /* Wakeup the LRU waiting CPU enabled for I/O
; 6126 :                      * interrupts.
; 6127 :                      */
; 6128 :                     WAKEUP_CPU_MASK( wake );

  001ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171901
  001b4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR wake$3[rsp]
  001b9	e8 00 00 00 00	 call	 wakeup_cpu_mask
$LN42@s370_prese:

; 6129 :                 }
; 6130 :             }
; 6131 : 
; 6132 :         } /* end for(io) */

  001be	e9 d0 fe ff ff	 jmp	 $LN17@s370_prese
$LN18@s370_prese:

; 6133 : 
; 6134 : #if defined( _FEATURE_IO_ASSIST )
; 6135 :         /* In the case of I/O assist, do a rescan, to see
; 6136 :            if there are any devices with pending subclasses
; 6137 :            for which we are not enabled, if so cause an
; 6138 :            interception.
; 6139 :         */
; 6140 :         if (io == NULL && SIE_MODE( regs ))

  001c3	48 83 7c 24 38
	00		 cmp	 QWORD PTR io$[rsp], 0
  001c9	0f 85 db 00 00
	00		 jne	 $LN45@s370_prese
  001cf	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d7	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001dd	d1 e8		 shr	 eax, 1
  001df	83 e0 01	 and	 eax, 1
  001e2	85 c0		 test	 eax, eax
  001e4	0f 84 c0 00 00
	00		 je	 $LN45@s370_prese
$LN25@s370_prese:

; 6141 :         {
; 6142 :             /* Find a device with a pending interrupt, regardless
; 6143 :                of the interrupt subclass mask
; 6144 :             */
; 6145 :             ASSERT( dev == NULL );

  001ea	48 83 7c 24 30
	00		 cmp	 QWORD PTR dev$[rsp], 0
  001f0	74 5c		 je	 SHORT $LN46@s370_prese
$LN28@s370_prese:
  001f2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171904
  001f9	41 b8 01 18 00
	00		 mov	 r8d, 6145		; 00001801H
  001ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171905
  00206	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171906
  0020d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00213	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00219	85 c0		 test	 eax, eax
  0021b	74 20		 je	 SHORT $LN47@s370_prese
  0021d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171908
  00224	41 b8 01 18 00
	00		 mov	 r8d, 6145		; 00001801H
  0022a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171909
  00231	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171910
  00238	e8 00 00 00 00	 call	 DebuggerTrace
$LN47@s370_prese:
  0023d	33 c0		 xor	 eax, eax
  0023f	85 c0		 test	 eax, eax
  00241	75 af		 jne	 SHORT $LN28@s370_prese
  00243	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00249	85 c0		 test	 eax, eax
  0024b	74 01		 je	 SHORT $LN48@s370_prese
  0024d	cc		 int	 3
$LN48@s370_prese:
$LN46@s370_prese:
  0024e	33 c0		 xor	 eax, eax
  00250	85 c0		 test	 eax, eax
  00252	75 96		 jne	 SHORT $LN25@s370_prese

; 6146 : 
; 6147 :             for (io = sysblk.iointq; io != NULL; io = io->next)

  00254	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0025b	48 8b 80 28 12
	00 00		 mov	 rax, QWORD PTR [rax+4648]
  00262	48 89 44 24 38	 mov	 QWORD PTR io$[rsp], rax
  00267	eb 0d		 jmp	 SHORT $LN31@s370_prese
$LN29@s370_prese:
  00269	48 8b 44 24 38	 mov	 rax, QWORD PTR io$[rsp]
  0026e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00271	48 89 44 24 38	 mov	 QWORD PTR io$[rsp], rax
$LN31@s370_prese:
  00276	48 83 7c 24 38
	00		 cmp	 QWORD PTR io$[rsp], 0
  0027c	74 2c		 je	 SHORT $LN30@s370_prese

; 6148 :             {
; 6149 :                 /* Exit loop if pending interrupts from this device */
; 6150 :                 if (ARCH_DEP( interrupt_enabled )( regs, io->dev ))

  0027e	48 8b 44 24 38	 mov	 rax, QWORD PTR io$[rsp]
  00283	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00287	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028f	e8 00 00 00 00	 call	 s370_interrupt_enabled
  00294	85 c0		 test	 eax, eax
  00296	74 10		 je	 SHORT $LN49@s370_prese

; 6151 :                 {
; 6152 :                     dev = io->dev;

  00298	48 8b 44 24 38	 mov	 rax, QWORD PTR io$[rsp]
  0029d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  002a1	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax

; 6153 :                     break;

  002a6	eb 02		 jmp	 SHORT $LN30@s370_prese
$LN49@s370_prese:

; 6154 :                 }
; 6155 :             } /* end for(io) */

  002a8	eb bf		 jmp	 SHORT $LN29@s370_prese
$LN30@s370_prese:
$LN45@s370_prese:

; 6156 :         }
; 6157 : #endif
; 6158 :         /* If no interrupt pending, or no device, exit with
; 6159 :          * condition code 0
; 6160 :          */
; 6161 :         if (io == NULL || dev == NULL)

  002aa	48 83 7c 24 38
	00		 cmp	 QWORD PTR io$[rsp], 0
  002b0	74 08		 je	 SHORT $LN51@s370_prese
  002b2	48 83 7c 24 30
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002b8	75 4b		 jne	 SHORT $LN50@s370_prese
$LN51@s370_prese:

; 6162 :         {
; 6163 :             /* Pass back pointer to device block for device with interrupt */
; 6164 :             *pdev = dev;

  002ba	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR pdev$[rsp]
  002c2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  002c7	48 89 08	 mov	 QWORD PTR [rax], rcx

; 6165 : 
; 6166 :             if (dev != NULL)

  002ca	48 83 7c 24 30
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002d0	74 0a		 je	 SHORT $LN52@s370_prese

; 6167 :                 subchannel_interrupt_queue_cleanup( dev );

  002d2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  002d7	e8 00 00 00 00	 call	 subchannel_interrupt_queue_cleanup
$LN52@s370_prese:

; 6168 : 
; 6169 :             UPDATE_IC_IOPENDING_QLOCKED();

  002dc	e8 00 00 00 00	 call	 Update_IC_IOPENDING_QLocked

; 6170 : 
; 6171 :             release_lock( &sysblk.iointqlk );

  002e1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002e8	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  002ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171916
  002f5	48 8b c8	 mov	 rcx, rax
  002f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6172 :             return 0;

  002fe	33 c0		 xor	 eax, eax
  00300	e9 99 03 00 00	 jmp	 $LN1@s370_prese
$LN50@s370_prese:

; 6173 :         }
; 6174 :     }
; 6175 :     release_lock( &sysblk.iointqlk );

  00305	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0030c	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  00312	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171917
  00319	48 8b c8	 mov	 rcx, rax
  0031c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6176 : 
; 6177 :     /* Obtain device lock for device with interrupt */
; 6178 :     obtain_lock( &dev->lock );

  00322	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00327	48 83 c0 38	 add	 rax, 56			; 00000038H
  0032b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171918
  00332	48 8b c8	 mov	 rcx, rax
  00335	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 6179 :     {
; 6180 :         /* Pass back pointer to device block for device with interrupt */
; 6181 :         *pdev = dev;

  0033b	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR pdev$[rsp]
  00343	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00348	48 89 08	 mov	 QWORD PTR [rax], rcx

; 6182 : 
; 6183 :         /* Verify that the interrupt for this device still exists and that
; 6184 :            TEST SUBCHANNEL has to be issued to clear an existing interrupt.
; 6185 :          */
; 6186 :         obtain_lock( &sysblk.iointqlk );

  0034b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00352	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  00358	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171919
  0035f	48 8b c8	 mov	 rcx, rax
  00362	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 6187 :         {
; 6188 :             for (io2 = sysblk.iointq; io2 != NULL && io2 != io; io2 = io2->next);

  00368	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0036f	48 8b 80 28 12
	00 00		 mov	 rax, QWORD PTR [rax+4648]
  00376	48 89 44 24 60	 mov	 QWORD PTR io2$[rsp], rax
  0037b	eb 0d		 jmp	 SHORT $LN34@s370_prese
$LN32@s370_prese:
  0037d	48 8b 44 24 60	 mov	 rax, QWORD PTR io2$[rsp]
  00382	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00385	48 89 44 24 60	 mov	 QWORD PTR io2$[rsp], rax
$LN34@s370_prese:
  0038a	48 83 7c 24 60
	00		 cmp	 QWORD PTR io2$[rsp], 0
  00390	74 0e		 je	 SHORT $LN33@s370_prese
  00392	48 8b 44 24 38	 mov	 rax, QWORD PTR io$[rsp]
  00397	48 39 44 24 60	 cmp	 QWORD PTR io2$[rsp], rax
  0039c	74 02		 je	 SHORT $LN33@s370_prese
  0039e	eb dd		 jmp	 SHORT $LN32@s370_prese
$LN33@s370_prese:

; 6189 : 
; 6190 :             if (io2 == NULL || dev->tschpending)

  003a0	48 83 7c 24 60
	00		 cmp	 QWORD PTR io2$[rsp], 0
  003a6	74 15		 je	 SHORT $LN54@s370_prese
  003a8	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  003ad	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  003b3	c1 e8 1b	 shr	 eax, 27
  003b6	83 e0 01	 and	 eax, 1
  003b9	85 c0		 test	 eax, eax
  003bb	74 3b		 je	 SHORT $LN53@s370_prese
$LN54@s370_prese:

; 6191 :             {
; 6192 :                 /* Our interrupt was dequeued; retry */
; 6193 :                 release_lock( &sysblk.iointqlk );

  003bd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003c4	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  003ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171922
  003d1	48 8b c8	 mov	 rcx, rax
  003d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6194 :                 release_lock( &dev->lock );

  003da	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  003df	48 83 c0 38	 add	 rax, 56			; 00000038H
  003e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171923
  003ea	48 8b c8	 mov	 rcx, rax
  003ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6195 :                 goto retry;

  003f3	e9 60 fc ff ff	 jmp	 $retry$69
$LN53@s370_prese:

; 6196 :             }
; 6197 : 
; 6198 :             /* Extract the I/O address and interrupt parameter */
; 6199 :             *ioid = (dev->ssid << 16) | dev->subchan;

  003f8	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  003fd	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00401	c1 e0 10	 shl	 eax, 16
  00404	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00409	0f b7 49 46	 movzx	 ecx, WORD PTR [rcx+70]
  0040d	0b c1		 or	 eax, ecx
  0040f	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR ioid$[rsp]
  00417	89 01		 mov	 DWORD PTR [rcx], eax

; 6200 :             FETCH_FW( *ioparm,dev->pmcw.intparm );

  00419	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0041e	48 05 ec 02 00
	00		 add	 rax, 748		; 000002ecH
  00424	48 8b c8	 mov	 rcx, rax
  00427	e8 00 00 00 00	 call	 fetch_fw_noswap
  0042c	8b c8		 mov	 ecx, eax
  0042e	e8 00 00 00 00	 call	 _byteswap_ulong
  00433	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR ioparm$[rsp]
  0043b	89 01		 mov	 DWORD PTR [rcx], eax

; 6201 : 
; 6202 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) || defined( _FEATURE_IO_ASSIST )
; 6203 : #if defined( FEATURE_QDIO_THININT )
; 6204 :             if (unlikely( FACILITY_ENABLED( HERC_QDIO_THININT, regs )
; 6205 :                 && (dev->pciscsw.flag2 & SCSW2_Q) && dev->qdio.thinint ))
; 6206 :             {
; 6207 :                 saved_dotsch = dotsch;
; 6208 :                 PCI_dequeued = false;
; 6209 : 
; 6210 :                 dotsch = false;  /* Do not require TSCH after INT */
; 6211 : 
; 6212 :                 *iointid = 0x80000000
; 6213 :                      | (
; 6214 : #if defined( _FEATURE_IO_ASSIST )
; 6215 :                         /* For I/O Assisted devices use (V)ISC */
; 6216 :                         (SIE_MODE(regs)) ?
; 6217 :                           (icode == SIE_NO_INTERCEPT) ?
; 6218 :                             ((dev->pmcw.flag25 & PMCW25_VISC) << 27) :
; 6219 :                             ((dev->pmcw.flag25 & PMCW25_VISC) << 27)
; 6220 :                               | (dev->pmcw.zone << 16)
; 6221 :                               | ((dev->pmcw.flag27 & PMCW27_I) << 8) :
; 6222 : #endif
; 6223 :                         ((dev->pmcw.flag4 & PMCW4_ISC) << 24)
; 6224 :                           | ((dev->pmcw.flag25 & PMCW25_TYPE) << 7)
; 6225 : #if defined( _FEATURE_IO_ASSIST )
; 6226 :                           | (dev->pmcw.zone << 16)
; 6227 :                           | ((dev->pmcw.flag27 & PMCW27_I) << 8)
; 6228 : #endif
; 6229 :                 ); // *iointid =
; 6230 : 
; 6231 :                 if (!SIE_MODE(regs) || icode != SIE_INTERCEPT_IOINTP)
; 6232 :                 {
; 6233 :                     /* Dequeue the interrupt */
; 6234 :                     PCI_dequeued = DEQUEUE_IO_INTERRUPT_QLOCKED( &dev->pciioint ) == 0 ? true : false;
; 6235 : 
; 6236 :                     if (!PCI_dequeued)
; 6237 :                         dotsch = saved_dotsch; // (restore)
; 6238 :                     else
; 6239 :                     {
; 6240 :                         /* Clear the pending PCI status */
; 6241 :                         dev->pciscsw.flag2 &= ~(SCSW2_FC | SCSW2_AC);
; 6242 :                         dev->pciscsw.flag3 &= ~(SCSW3_SC);
; 6243 :                     }
; 6244 :                 }
; 6245 :                 else
; 6246 :                     PCI_dequeued = true; // (keep same logic as before!)
; 6247 :             }
; 6248 : 
; 6249 :             /* If no PCI interrupt dequeued, then dequeue a normal interrupt */
; 6250 :             if (!PCI_dequeued)
; 6251 : #endif /*defined( FEATURE_QDIO_THININT )*/
; 6252 : 
; 6253 :                 *iointid = (

  0043d	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00445	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0044b	d1 e8		 shr	 eax, 1
  0044d	83 e0 01	 and	 eax, 1
  00450	85 c0		 test	 eax, eax
  00452	74 67		 je	 SHORT $LN66@s370_prese
  00454	83 7c 24 44 ff	 cmp	 DWORD PTR icode$[rsp], -1
  00459	75 18		 jne	 SHORT $LN64@s370_prese
  0045b	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00460	0f b6 80 05 03
	00 00		 movzx	 eax, BYTE PTR [rax+773]
  00467	83 e0 07	 and	 eax, 7
  0046a	c1 e0 1b	 shl	 eax, 27
  0046d	89 44 24 58	 mov	 DWORD PTR tv231[rsp], eax
  00471	eb 3e		 jmp	 SHORT $LN65@s370_prese
$LN64@s370_prese:
  00473	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00478	0f b6 80 05 03
	00 00		 movzx	 eax, BYTE PTR [rax+773]
  0047f	83 e0 07	 and	 eax, 7
  00482	c1 e0 1b	 shl	 eax, 27
  00485	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0048a	0f b6 89 04 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+772]
  00491	c1 e1 10	 shl	 ecx, 16
  00494	0b c1		 or	 eax, ecx
  00496	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0049b	0f b6 89 07 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+775]
  004a2	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  004a8	c1 e1 08	 shl	 ecx, 8
  004ab	0b c1		 or	 eax, ecx
  004ad	89 44 24 58	 mov	 DWORD PTR tv231[rsp], eax
$LN65@s370_prese:
  004b1	8b 44 24 58	 mov	 eax, DWORD PTR tv231[rsp]
  004b5	89 44 24 5c	 mov	 DWORD PTR tv251[rsp], eax
  004b9	eb 55		 jmp	 SHORT $LN67@s370_prese
$LN66@s370_prese:
  004bb	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  004c0	0f b6 80 f0 02
	00 00		 movzx	 eax, BYTE PTR [rax+752]
  004c7	83 e0 38	 and	 eax, 56			; 00000038H
  004ca	c1 e0 18	 shl	 eax, 24
  004cd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  004d2	0f b6 89 05 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+773]
  004d9	81 e1 e0 00 00
	00		 and	 ecx, 224		; 000000e0H
  004df	c1 e1 07	 shl	 ecx, 7
  004e2	0b c1		 or	 eax, ecx
  004e4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  004e9	0f b6 89 04 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+772]
  004f0	c1 e1 10	 shl	 ecx, 16
  004f3	0b c1		 or	 eax, ecx
  004f5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  004fa	0f b6 89 07 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+775]
  00501	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00507	c1 e1 08	 shl	 ecx, 8
  0050a	0b c1		 or	 eax, ecx
  0050c	89 44 24 5c	 mov	 DWORD PTR tv251[rsp], eax
$LN67@s370_prese:
  00510	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR iointid$[rsp]
  00518	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv251[rsp]
  0051c	89 08		 mov	 DWORD PTR [rax], ecx

; 6254 : #if defined(_FEATURE_IO_ASSIST)
; 6255 :                             /* For I/O Assisted devices use (V)ISC */
; 6256 :                             (SIE_MODE(regs)) ?
; 6257 :                               (icode == SIE_NO_INTERCEPT) ?
; 6258 :                                 ((dev->pmcw.flag25 & PMCW25_VISC) << 27) :
; 6259 :                                 ((dev->pmcw.flag25 & PMCW25_VISC) << 27)
; 6260 :                                   | (dev->pmcw.zone << 16)
; 6261 :                                   | ((dev->pmcw.flag27 & PMCW27_I) << 8) :
; 6262 : #endif
; 6263 :                              ((dev->pmcw.flag4 & PMCW4_ISC) << 24)
; 6264 :                                | ((dev->pmcw.flag25 & PMCW25_TYPE) << 7)
; 6265 : #if defined(_FEATURE_IO_ASSIST)
; 6266 :                                | (dev->pmcw.zone << 16)
; 6267 :                                | ((dev->pmcw.flag27 & PMCW27_I) << 8)
; 6268 : #endif
; 6269 :                 ); // *iointid =
; 6270 : #endif /*defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) || defined( _FEATURE_IO_ASSIST ) */
; 6271 : 
; 6272 : #if defined( _FEATURE_IO_ASSIST )
; 6273 :             /* Do not drain pending interrupts
; 6274 :                on intercept due to zero ISC mask
; 6275 :              */
; 6276 :             if(!SIE_MODE(regs) || icode != SIE_INTERCEPT_IOINTP)

  0051e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00526	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0052c	d1 e8		 shr	 eax, 1
  0052e	83 e0 01	 and	 eax, 1
  00531	85 c0		 test	 eax, eax
  00533	74 07		 je	 SHORT $LN56@s370_prese
  00535	83 7c 24 44 f0	 cmp	 DWORD PTR icode$[rsp], -16
  0053a	74 4a		 je	 SHORT $LN55@s370_prese
$LN56@s370_prese:

; 6277 : #endif
; 6278 :             {
; 6279 :                 if (!SIE_MODE(regs) || icode != SIE_NO_INTERCEPT)

  0053c	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00544	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0054a	d1 e8		 shr	 eax, 1
  0054c	83 e0 01	 and	 eax, 1
  0054f	85 c0		 test	 eax, eax
  00551	74 07		 je	 SHORT $LN58@s370_prese
  00553	83 7c 24 44 ff	 cmp	 DWORD PTR icode$[rsp], -1
  00558	74 1b		 je	 SHORT $LN57@s370_prese
$LN58@s370_prese:

; 6280 :                     dev->pmcw.flag27 &= ~PMCW27_I;

  0055a	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0055f	0f b6 80 07 03
	00 00		 movzx	 eax, BYTE PTR [rax+775]
  00566	0f ba f0 07	 btr	 eax, 7
  0056a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0056f	88 81 07 03 00
	00		 mov	 BYTE PTR [rcx+775], al
$LN57@s370_prese:

; 6281 : 
; 6282 :                 /* Dequeue the interrupt */
; 6283 :                 DEQUEUE_IO_INTERRUPT_QLOCKED( io );

  00575	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171928
  0057c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR io$[rsp]
  00581	e8 00 00 00 00	 call	 Dequeue_IO_Interrupt_QLocked
$LN55@s370_prese:

; 6284 :             }
; 6285 : 
; 6286 :             /* TEST SUBCHANNEL is now required to clear the interrupt */
; 6287 :             dev->tschpending = dotsch;

  00586	0f b6 44 24 40	 movzx	 eax, BYTE PTR dotsch$[rsp]
  0058b	83 e0 01	 and	 eax, 1
  0058e	c1 e0 1b	 shl	 eax, 27
  00591	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00596	8b 89 f8 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1528]
  0059c	0f ba f1 1b	 btr	 ecx, 27
  005a0	0b c8		 or	 ecx, eax
  005a2	8b c1		 mov	 eax, ecx
  005a4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  005a9	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 6288 : 
; 6289 :             /* Perform additional architecture post processing and cleanup */
; 6290 :             switch (sysblk.arch_mode)

  005af	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005b6	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  005bc	89 44 24 4c	 mov	 DWORD PTR tv277[rsp], eax
  005c0	83 7c 24 4c 00	 cmp	 DWORD PTR tv277[rsp], 0
  005c5	74 10		 je	 SHORT $LN59@s370_prese
  005c7	83 7c 24 4c 01	 cmp	 DWORD PTR tv277[rsp], 1
  005cc	74 66		 je	 SHORT $LN60@s370_prese
  005ce	83 7c 24 4c 02	 cmp	 DWORD PTR tv277[rsp], 2
  005d3	74 61		 je	 SHORT $LN61@s370_prese
  005d5	eb 61		 jmp	 SHORT $LN62@s370_prese
$LN59@s370_prese:

; 6291 :             {
; 6292 :                 case ARCH_370_IDX:
; 6293 :                 {
; 6294 :                     IOINT*  ioint;              /* -> I/O interrupt          */
; 6295 :                     IRB     irb;                /* -> IRB                    */
; 6296 :                     SCSW*   scsw;               /* -> SCSW                   */
; 6297 :                     int     cc;                 /* Condition code ignored    */
; 6298 : 
; 6299 :                     /* Extract the I/O address and CSW */
; 6300 :                     *ioid = dev->devnum;

  005d7	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  005dc	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  005e0	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR ioid$[rsp]
  005e8	89 01		 mov	 DWORD PTR [rcx], eax

; 6301 : 
; 6302 :                     /* Perform core of TEST SUBCHANNEL work and store CSW */
; 6303 :                     cc = test_subchan_locked( regs, dev, &irb, &ioint, &scsw );

  005ea	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR scsw$6[rsp]
  005f2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005f7	4c 8d 8c 24 90
	00 00 00	 lea	 r9, QWORD PTR ioint$8[rsp]
  005ff	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR irb$9[rsp]
  00607	48 8b 54 24 30	 mov	 rdx, QWORD PTR dev$[rsp]
  0060c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00614	e8 00 00 00 00	 call	 test_subchan_locked
  00619	89 44 24 78	 mov	 DWORD PTR cc$5[rsp], eax

; 6304 :                     store_scsw_as_csw( regs, scsw );

  0061d	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR scsw$6[rsp]
  00625	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0062d	e8 00 00 00 00	 call	 store_scsw_as_csw

; 6305 :                     break;

  00632	eb 21		 jmp	 SHORT $LN35@s370_prese
$LN60@s370_prese:

; 6306 :                 }
; 6307 : 
; 6308 :                 case ARCH_390_IDX: break;

  00634	eb 1f		 jmp	 SHORT $LN35@s370_prese
$LN61@s370_prese:

; 6309 :                 case ARCH_900_IDX: break;

  00636	eb 1d		 jmp	 SHORT $LN35@s370_prese
$LN62@s370_prese:
$LN39@s370_prese:

; 6310 :                 default: CRASH();

  00638	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR p$7[rsp], 0
  00644	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR p$7[rsp]
  0064c	c6 00 00	 mov	 BYTE PTR [rax], 0
  0064f	33 c0		 xor	 eax, eax
  00651	85 c0		 test	 eax, eax
  00653	75 e3		 jne	 SHORT $LN39@s370_prese
$LN35@s370_prese:

; 6311 :             }
; 6312 : 
; 6313 :             subchannel_interrupt_queue_cleanup( dev );

  00655	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0065a	e8 00 00 00 00	 call	 subchannel_interrupt_queue_cleanup

; 6314 :             UPDATE_IC_IOPENDING_QLOCKED();

  0065f	e8 00 00 00 00	 call	 Update_IC_IOPENDING_QLocked

; 6315 :         }
; 6316 :         release_lock( &sysblk.iointqlk );

  00664	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0066b	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  00671	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171933
  00678	48 8b c8	 mov	 rcx, rax
  0067b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6317 : 
; 6318 : #if DEBUG_SCSW
; 6319 :         if (unlikely(dev->ccwtrace))
; 6320 :         {
; 6321 :             SCSW* scsw;   /* (selected SCSW) */
; 6322 : 
; 6323 :                  if (dev->pciscsw.flag3  & SCSW3_SC_PEND) scsw = &dev->pciscsw;
; 6324 :             else if (dev->scsw.flag3     & SCSW3_SC_PEND) scsw = &dev->scsw;
; 6325 :          /* else if (dev->attnscsw.flag3 & SCSW3_SC_PEND) scsw = &dev->attnscsw; */
; 6326 :             else scsw = NULL;
; 6327 : 
; 6328 :             /* Check interrupt validity */
; 6329 :             if (1
; 6330 :                 && scsw != NULL
; 6331 :                 && !(scsw->flag2 & (SCSW2_FC | SCSW2_AC))
; 6332 :                 && !(scsw->flag3 & SCSW3_AC)
; 6333 :             )
; 6334 :             {
; 6335 :                 WRMSG( HHC01393, "E", "  CHAN: Invalid SCSW presentation" );
; 6336 :                 DISPLAY_SCSW( dev, *scsw );
; 6337 :             }
; 6338 :         }
; 6339 : #endif /*DEBUG_SCSW*/
; 6340 :     }
; 6341 :     release_lock( &dev->lock );

  00681	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00686	48 83 c0 38	 add	 rax, 56			; 00000038H
  0068a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171934
  00691	48 8b c8	 mov	 rcx, rax
  00694	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6342 : 
; 6343 :     /* Exit with condition code indicating queued interrupt cleared */
; 6344 :     return icode;

  0069a	8b 44 24 44	 mov	 eax, DWORD PTR icode$[rsp]
$LN1@s370_prese:

; 6345 : 
; 6346 : } /* end function present_io_interrupt */

  0069e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  006a6	48 33 cc	 xor	 rcx, rsp
  006a9	e8 00 00 00 00	 call	 __security_check_cookie
  006ae	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  006b5	c3		 ret	 0
s370_present_io_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
cc$ = 80
tv177 = 84
tv204 = 88
tv210 = 92
regs$ = 112
dev$ = 120
resume_subchan PROC

; 2889 : {

$LN22:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2890 : int cc;                                 /* Return code               */
; 2891 : 
; 2892 :     obtain_lock (&dev->lock);

  0000e	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00013	48 83 c0 38	 add	 rax, 56			; 00000038H
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171008
  0001e	48 8b c8	 mov	 rcx, rax
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2893 : 
; 2894 : #if defined(_FEATURE_IO_ASSIST)
; 2895 :     if(SIE_MODE(regs)
; 2896 :       && (regs->siebk->zone != dev->pmcw.zone

  00027	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0002c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00032	d1 e8		 shr	 eax, 1
  00034	83 e0 01	 and	 eax, 1
  00037	85 c0		 test	 eax, eax
  00039	74 66		 je	 SHORT $LN2@resume_sub
  0003b	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00040	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00047	0f b6 40 74	 movzx	 eax, BYTE PTR [rax+116]
  0004b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dev$[rsp]
  00050	0f b6 89 04 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+772]
  00057	3b c1		 cmp	 eax, ecx
  00059	75 15		 jne	 SHORT $LN3@resume_sub
  0005b	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00060	0f b6 80 07 03
	00 00		 movzx	 eax, BYTE PTR [rax+775]
  00067	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0006c	85 c0		 test	 eax, eax
  0006e	75 31		 jne	 SHORT $LN2@resume_sub
$LN3@resume_sub:

; 2897 :         || !(dev->pmcw.flag27 & PMCW27_I)))
; 2898 :     {
; 2899 :         release_lock (&dev->lock);

  00070	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00075	48 83 c0 38	 add	 rax, 56			; 00000038H
  00079	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171011
  00080	48 8b c8	 mov	 rcx, rax
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2900 :         longjmp(regs->progjmp,SIE_INTERCEPT_INST);

  00089	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0008e	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00094	ba fc ff ff ff	 mov	 edx, -4
  00099	48 8b c8	 mov	 rcx, rax
  0009c	e8 00 00 00 00	 call	 longjmp
$LN2@resume_sub:

; 2901 :     }
; 2902 : #endif
; 2903 : 
; 2904 :     /* Set condition code 1 if subchannel has status pending
; 2905 :      *
; 2906 :      * SA22-7832-09, RESUME SUBCHANNEL, Condition Code 1, p. 14-11
; 2907 :      */
; 2908 :     if (dev->scsw.flag3     & SCSW3_SC_PEND ||
; 2909 :         dev->pciscsw.flag3  & SCSW3_SC_PEND ||

  000a1	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  000a6	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  000ad	83 e0 01	 and	 eax, 1
  000b0	85 c0		 test	 eax, eax
  000b2	75 26		 jne	 SHORT $LN6@resume_sub
  000b4	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  000b9	0f b6 80 17 03
	00 00		 movzx	 eax, BYTE PTR [rax+791]
  000c0	83 e0 01	 and	 eax, 1
  000c3	85 c0		 test	 eax, eax
  000c5	75 13		 jne	 SHORT $LN6@resume_sub
  000c7	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  000cc	0f b6 80 23 03
	00 00		 movzx	 eax, BYTE PTR [rax+803]
  000d3	83 e0 01	 and	 eax, 1
  000d6	85 c0		 test	 eax, eax
  000d8	74 0d		 je	 SHORT $LN4@resume_sub
$LN6@resume_sub:

; 2910 :         dev->attnscsw.flag3 & SCSW3_SC_PEND)
; 2911 :     {
; 2912 :         cc = 1;

  000da	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1

; 2913 :     }

  000e2	e9 cd 00 00 00	 jmp	 $LN5@resume_sub
$LN4@resume_sub:

; 2914 : 
; 2915 :     /* Set condition code 2 if subchannel has any function active, is
; 2916 :      * already resume pending, or the ORB for the SSCH did not specify
; 2917 :      * suspend control.
; 2918 :      *
; 2919 :      * SA22-7832-09, RESUME SUBCHANNEL, Condition Code 2, p. 14-11
; 2920 :      */
; 2921 :     else if (unlikely(!(dev->orb.flag4  & ORB4_S)           ||

  000e7	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  000ec	0f b6 80 d0 02
	00 00		 movzx	 eax, BYTE PTR [rax+720]
  000f3	83 e0 08	 and	 eax, 8
  000f6	85 c0		 test	 eax, eax
  000f8	74 58		 je	 SHORT $LN14@resume_sub
  000fa	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  000ff	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00106	83 e0 70	 and	 eax, 112		; 00000070H
  00109	85 c0		 test	 eax, eax
  0010b	74 45		 je	 SHORT $LN14@resume_sub
  0010d	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00112	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00119	83 e0 20	 and	 eax, 32			; 00000020H
  0011c	85 c0		 test	 eax, eax
  0011e	74 32		 je	 SHORT $LN14@resume_sub
  00120	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00125	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  0012c	83 e0 3f	 and	 eax, 63			; 0000003fH
  0012f	85 c0		 test	 eax, eax
  00131	75 1f		 jne	 SHORT $LN14@resume_sub
  00133	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00138	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  0013f	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  00144	85 c0		 test	 eax, eax
  00146	75 0a		 jne	 SHORT $LN14@resume_sub
  00148	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv177[rsp], 0
  00150	eb 08		 jmp	 SHORT $LN17@resume_sub
$LN14@resume_sub:
  00152	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv177[rsp], 1
$LN17@resume_sub:
  0015a	83 7c 24 54 00	 cmp	 DWORD PTR tv177[rsp], 0
  0015f	74 0a		 je	 SHORT $LN7@resume_sub

; 2922 :                       !(dev->scsw.flag2 & SCSW2_FC)         ||
; 2923 :                       !(dev->scsw.flag3 & SCSW3_AC_SUSP)    ||
; 2924 :                       (dev->scsw.flag2 &
; 2925 :                        (SCSW2_FC_HALT  | SCSW2_FC_CLEAR |
; 2926 :                         SCSW2_AC_RESUM | SCSW2_AC_START |
; 2927 :                         SCSW2_AC_HALT  | SCSW2_AC_CLEAR))   ||
; 2928 :                       (dev->scsw.flag3 &
; 2929 :                        (SCSW3_AC_SCHAC | SCSW3_AC_DEVAC))))
; 2930 :     {
; 2931 :         cc = 2;

  00161	c7 44 24 50 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2

; 2932 :     }

  00169	eb 49		 jmp	 SHORT $LN8@resume_sub
$LN7@resume_sub:

; 2933 : 
; 2934 :     /* Otherwise, schedule the resume request */
; 2935 :     else
; 2936 :     {
; 2937 :         /* Clear the path not-operational mask if in suspend state */
; 2938 :         if (dev->scsw.flag3 & SCSW3_AC_SUSP)

  0016b	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00170	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00177	83 e0 20	 and	 eax, 32			; 00000020H
  0017a	85 c0		 test	 eax, eax
  0017c	74 0c		 je	 SHORT $LN9@resume_sub

; 2939 :             dev->pmcw.pnom = 0x00;

  0017e	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00183	c6 80 f5 02 00
	00 00		 mov	 BYTE PTR [rax+757], 0
$LN9@resume_sub:

; 2940 : 
; 2941 :         /* Set the resume pending flag and signal the subchannel */
; 2942 :         dev->scsw.flag2 |= SCSW2_AC_RESUM;

  0018a	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  0018f	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00196	83 c8 08	 or	 eax, 8
  00199	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dev$[rsp]
  0019e	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 2943 :         cc = schedule_ioq(NULL, dev);

  001a4	48 8b 54 24 78	 mov	 rdx, QWORD PTR dev$[rsp]
  001a9	33 c9		 xor	 ecx, ecx
  001ab	e8 00 00 00 00	 call	 schedule_ioq
  001b0	89 44 24 50	 mov	 DWORD PTR cc$[rsp], eax
$LN8@resume_sub:
$LN5@resume_sub:

; 2944 :     }
; 2945 : 
; 2946 :     /* If tracing, write trace message */
; 2947 :     if (dev->ccwtrace)

  001b4	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  001b9	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001bf	c1 e8 0f	 shr	 eax, 15
  001c2	83 e0 01	 and	 eax, 1
  001c5	85 c0		 test	 eax, eax
  001c7	0f 84 c5 00 00
	00		 je	 $LN10@resume_sub

; 2948 :     {
; 2949 :         if (sysblk.traceFILE)

  001cd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001d4	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  001dc	74 15		 je	 SHORT $LN11@resume_sub

; 2950 :             tf_1333( dev, cc );

  001de	0f b6 54 24 50	 movzx	 edx, BYTE PTR cc$[rsp]
  001e3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dev$[rsp]
  001e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1333
  001ee	e9 9f 00 00 00	 jmp	 $LN12@resume_sub
$LN11@resume_sub:

; 2951 :         else
; 2952 :             // "%1d:%04X CHAN: resume subchannel: cc=%d"
; 2953 :             WRMSG( HHC01333, "I", LCSS_DEVNUM, cc );

  001f3	48 83 7c 24 78
	00		 cmp	 QWORD PTR dev$[rsp], 0
  001f9	74 0f		 je	 SHORT $LN18@resume_sub
  001fb	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00200	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00204	89 44 24 58	 mov	 DWORD PTR tv204[rsp], eax
  00208	eb 08		 jmp	 SHORT $LN19@resume_sub
$LN18@resume_sub:
  0020a	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv204[rsp], 0
$LN19@resume_sub:
  00212	48 83 7c 24 78
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00218	74 11		 je	 SHORT $LN20@resume_sub
  0021a	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  0021f	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00223	d1 f8		 sar	 eax, 1
  00225	89 44 24 5c	 mov	 DWORD PTR tv210[rsp], eax
  00229	eb 08		 jmp	 SHORT $LN21@resume_sub
$LN20@resume_sub:
  0022b	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv210[rsp], 0
$LN21@resume_sub:
  00233	b9 01 00 00 00	 mov	 ecx, 1
  00238	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0023e	8b 4c 24 50	 mov	 ecx, DWORD PTR cc$[rsp]
  00242	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00246	8b 4c 24 58	 mov	 ecx, DWORD PTR tv204[rsp]
  0024a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0024e	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv210[rsp]
  00252	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00256	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171021
  0025d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00262	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171022
  00269	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0026e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00273	41 b9 03 00 00
	00		 mov	 r9d, 3
  00279	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171023
  00280	ba 89 0b 00 00	 mov	 edx, 2953		; 00000b89H
  00285	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171024
  0028c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN12@resume_sub:
$LN10@resume_sub:

; 2954 :     }
; 2955 : 
; 2956 :     release_lock (&dev->lock);

  00292	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00297	48 83 c0 38	 add	 rax, 56			; 00000038H
  0029b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171025
  002a2	48 8b c8	 mov	 rcx, rax
  002a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2957 : 
; 2958 :     /* Return the condition code */
; 2959 :     return cc;

  002ab	8b 44 24 50	 mov	 eax, DWORD PTR cc$[rsp]
$LN13@resume_sub:

; 2960 : 
; 2961 : } /* end function resume_subchan */

  002af	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002b3	c3		 ret	 0
resume_subchan ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
cc$ = 80
tv75 = 84
tv81 = 88
tv244 = 92
tv250 = 96
psa$ = 104
regs$ = 128
dev$ = 136
ibyte$ = 144
haltio	PROC

; 1316 : {

$LN30:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H
$LN4@haltio:

; 1317 :     int       cc;                       /* Condition code            */
; 1318 :     PSA_3XX*  psa;                      /* -> Prefixed storage area  */
; 1319 : 
; 1320 :     UNREFERENCED( ibyte );

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	75 fa		 jne	 SHORT $LN4@haltio

; 1321 : 
; 1322 :     if (dev->ccwtrace)

  00019	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00021	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00027	c1 e8 0f	 shr	 eax, 15
  0002a	83 e0 01	 and	 eax, 1
  0002d	85 c0		 test	 eax, eax
  0002f	0f 84 c7 00 00
	00		 je	 $LN5@haltio

; 1323 :     {
; 1324 :         if (sysblk.traceFILE)

  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003c	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00044	74 13		 je	 SHORT $LN6@haltio

; 1325 :             tf_1329( dev );

  00046	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1329
  00054	e9 a3 00 00 00	 jmp	 $LN7@haltio
$LN6@haltio:

; 1326 :         else
; 1327 :             // "%1d:%04X CHAN: halt I/O"
; 1328 :             WRMSG( HHC01329, "I", LCSS_DEVNUM );

  00059	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00062	74 12		 je	 SHORT $LN22@haltio
  00064	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0006c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00070	89 44 24 54	 mov	 DWORD PTR tv75[rsp], eax
  00074	eb 08		 jmp	 SHORT $LN23@haltio
$LN22@haltio:
  00076	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN23@haltio:
  0007e	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00087	74 14		 je	 SHORT $LN24@haltio
  00089	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00091	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00095	d1 f8		 sar	 eax, 1
  00097	89 44 24 58	 mov	 DWORD PTR tv81[rsp], eax
  0009b	eb 08		 jmp	 SHORT $LN25@haltio
$LN24@haltio:
  0009d	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN25@haltio:
  000a5	b9 01 00 00 00	 mov	 ecx, 1
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b0	8b 4c 24 54	 mov	 ecx, DWORD PTR tv75[rsp]
  000b4	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000b8	8b 4c 24 58	 mov	 ecx, DWORD PTR tv81[rsp]
  000bc	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170478
  000c7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170479
  000d3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000d8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000dd	41 b9 03 00 00
	00		 mov	 r9d, 3
  000e3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170480
  000ea	ba 30 05 00 00	 mov	 edx, 1328		; 00000530H
  000ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170481
  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN7@haltio:
$LN5@haltio:

; 1329 :     }
; 1330 : 
; 1331 :     OBTAIN_INTLOCK( regs );

  000fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170482
  00103	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010b	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 1332 :     obtain_lock( &dev->lock );

  00110	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00118	48 83 c0 38	 add	 rax, 56			; 00000038H
  0011c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170483
  00123	48 8b c8	 mov	 rcx, rax
  00126	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1333 : 
; 1334 :     /* Test device status and set condition code */
; 1335 :     if (dev->busy
; 1336 :         /* CTCE devices need dev->hnd->halt to always be called
; 1337 :            even when not busy!
; 1338 :         */
; 1339 :         || dev->ctctype == CTC_CTCE)

  0012c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00134	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0013a	c1 e8 13	 shr	 eax, 19
  0013d	83 e0 01	 and	 eax, 1
  00140	85 c0		 test	 eax, eax
  00142	75 18		 jne	 SHORT $LN10@haltio
  00144	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0014c	0f b6 80 1c 07
	00 00		 movzx	 eax, BYTE PTR [rax+1820]
  00153	83 f8 04	 cmp	 eax, 4
  00156	0f 85 73 01 00
	00		 jne	 $LN8@haltio
$LN10@haltio:

; 1340 :     {
; 1341 :         /* Invoke the provided halt device routine */
; 1342 :         /* if it has been provided by the handler  */
; 1343 :         /* code at init                            */
; 1344 :         if (dev->hnd->halt != NULL)

  0015c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00164	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0016b	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  00170	74 6c		 je	 SHORT $LN11@haltio

; 1345 :         {
; 1346 :             dev->hnd->halt( dev );

  00172	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0017a	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00181	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00189	ff 50 48	 call	 QWORD PTR [rax+72]

; 1347 :             psa = (PSA_3XX*)( regs->mainstor + regs->PX );

  0018c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00194	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00197	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0019f	48 03 81 48 08
	00 00		 add	 rax, QWORD PTR [rcx+2120]
  001a6	48 89 44 24 68	 mov	 QWORD PTR psa$[rsp], rax

; 1348 :             psa->csw[4] = 0;    /*  Store partial CSW   */

  001ab	b8 01 00 00 00	 mov	 eax, 1
  001b0	48 6b c0 04	 imul	 rax, rax, 4
  001b4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR psa$[rsp]
  001b9	c6 44 01 40 00	 mov	 BYTE PTR [rcx+rax+64], 0

; 1349 :             psa->csw[5] = 0;

  001be	b8 01 00 00 00	 mov	 eax, 1
  001c3	48 6b c0 05	 imul	 rax, rax, 5
  001c7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR psa$[rsp]
  001cc	c6 44 01 40 00	 mov	 BYTE PTR [rcx+rax+64], 0

; 1350 :             cc = 1;             /*  CC1 == CSW stored   */

  001d1	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1

; 1351 :         }

  001d9	e9 ec 00 00 00	 jmp	 $LN12@haltio
$LN11@haltio:

; 1352 :         else
; 1353 :         {
; 1354 :             /* Set condition code 2 if device is busy */
; 1355 :             cc = 2;

  001de	c7 44 24 50 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2

; 1356 : 
; 1357 :             /* Tell channel and device to halt */
; 1358 :             dev->scsw.flag2 |= SCSW2_AC_HALT;

  001e6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ee	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  001f5	83 c8 02	 or	 eax, 2
  001f8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00200	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 1359 : 
; 1360 :             /* Clear pending interrupts */
; 1361 : 
; 1362 :             DEQUEUE_IO_INTERRUPT_QLOCKED( &dev->pciioint  );

  00206	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0020e	48 05 40 02 00
	00		 add	 rax, 576		; 00000240H
  00214	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170489
  0021b	48 8b c8	 mov	 rcx, rax
  0021e	e8 00 00 00 00	 call	 Dequeue_IO_Interrupt_QLocked

; 1363 :             DEQUEUE_IO_INTERRUPT_QLOCKED( &dev->ioint     );

  00223	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0022b	48 05 28 02 00
	00		 add	 rax, 552		; 00000228H
  00231	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170490
  00238	48 8b c8	 mov	 rcx, rax
  0023b	e8 00 00 00 00	 call	 Dequeue_IO_Interrupt_QLocked

; 1364 :             DEQUEUE_IO_INTERRUPT_QLOCKED( &dev->attnioint );

  00240	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00248	48 05 58 02 00
	00		 add	 rax, 600		; 00000258H
  0024e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170491
  00255	48 8b c8	 mov	 rcx, rax
  00258	e8 00 00 00 00	 call	 Dequeue_IO_Interrupt_QLocked

; 1365 : 
; 1366 :             dev->pciscsw.flag3  &= ~(SCSW3_SC_ALERT |

  0025d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00265	0f b6 80 17 03
	00 00		 movzx	 eax, BYTE PTR [rax+791]
  0026c	83 e0 e8	 and	 eax, -24
  0026f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00277	88 81 17 03 00
	00		 mov	 BYTE PTR [rcx+791], al

; 1367 :                                      SCSW3_SC_PRI   |
; 1368 :                                      SCSW3_SC_SEC   |
; 1369 :                                      SCSW3_SC_PEND);
; 1370 : 
; 1371 :             dev->scsw.flag3     &= ~(SCSW3_SC_ALERT |

  0027d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00285	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  0028c	83 e0 e8	 and	 eax, -24
  0028f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00297	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 1372 :                                      SCSW3_SC_PRI   |
; 1373 :                                      SCSW3_SC_SEC   |
; 1374 :                                      SCSW3_SC_PEND);
; 1375 : 
; 1376 :             dev->attnscsw.flag3 &= ~(SCSW3_SC_ALERT |

  0029d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002a5	0f b6 80 23 03
	00 00		 movzx	 eax, BYTE PTR [rax+803]
  002ac	83 e0 e8	 and	 eax, -24
  002af	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002b7	88 81 23 03 00
	00		 mov	 BYTE PTR [rcx+803], al

; 1377 :                                      SCSW3_SC_PRI   |
; 1378 :                                      SCSW3_SC_SEC   |
; 1379 :                                      SCSW3_SC_PEND);
; 1380 : 
; 1381 :             subchannel_interrupt_queue_cleanup( dev );

  002bd	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002c5	e8 00 00 00 00	 call	 subchannel_interrupt_queue_cleanup
$LN12@haltio:

; 1382 :         }
; 1383 :     }

  002ca	e9 ca 02 00 00	 jmp	 $LN9@haltio
$LN8@haltio:

; 1384 :     else if (!IOPENDING( dev ) && dev->ctctype != CTC_LCS)

  002cf	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002d7	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  002dd	c1 e8 16	 shr	 eax, 22
  002e0	83 e0 01	 and	 eax, 1
  002e3	85 c0		 test	 eax, eax
  002e5	0f 85 00 01 00
	00		 jne	 $LN13@haltio
  002eb	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002f3	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  002f9	c1 e8 17	 shr	 eax, 23
  002fc	83 e0 01	 and	 eax, 1
  002ff	85 c0		 test	 eax, eax
  00301	0f 85 e4 00 00
	00		 jne	 $LN13@haltio
  00307	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0030f	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00315	c1 e8 18	 shr	 eax, 24
  00318	83 e0 01	 and	 eax, 1
  0031b	85 c0		 test	 eax, eax
  0031d	0f 85 c8 00 00
	00		 jne	 $LN13@haltio
  00323	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0032b	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00331	c1 e8 1b	 shr	 eax, 27
  00334	83 e0 01	 and	 eax, 1
  00337	85 c0		 test	 eax, eax
  00339	0f 85 ac 00 00
	00		 jne	 $LN13@haltio
  0033f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00347	0f b6 80 1c 07
	00 00		 movzx	 eax, BYTE PTR [rax+1820]
  0034e	83 f8 01	 cmp	 eax, 1
  00351	0f 84 94 00 00
	00		 je	 $LN13@haltio

; 1385 :     {
; 1386 :         /* Set condition code 1 */
; 1387 :         cc = 1;

  00357	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1

; 1388 : 
; 1389 :         /* Store the channel status word at PSA+X'40' */
; 1390 :         store_scsw_as_csw( regs, &dev->scsw );

  0035f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00367	48 05 08 03 00
	00		 add	 rax, 776		; 00000308H
  0036d	48 8b d0	 mov	 rdx, rax
  00370	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00378	e8 00 00 00 00	 call	 store_scsw_as_csw

; 1391 : 
; 1392 :         if (dev->ccwtrace)

  0037d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00385	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0038b	c1 e8 0f	 shr	 eax, 15
  0038e	83 e0 01	 and	 eax, 1
  00391	85 c0		 test	 eax, eax
  00393	74 51		 je	 SHORT $LN15@haltio

; 1393 :         {
; 1394 :             psa = (PSA_3XX*)(regs->mainstor + regs->PX);

  00395	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0039d	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  003a0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a8	48 03 81 48 08
	00 00		 add	 rax, QWORD PTR [rcx+2120]
  003af	48 89 44 24 68	 mov	 QWORD PTR psa$[rsp], rax

; 1395 :             DISPLAY_CSW( dev, psa->csw );

  003b4	48 8b 44 24 68	 mov	 rax, QWORD PTR psa$[rsp]
  003b9	48 83 c0 40	 add	 rax, 64			; 00000040H
  003bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170495
  003c4	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  003c9	41 b9 73 05 00
	00		 mov	 r9d, 1395		; 00000573H
  003cf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170496
  003d6	48 8b d0	 mov	 rdx, rax
  003d9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003e1	e8 00 00 00 00	 call	 _display_csw
$LN15@haltio:

; 1396 :         }
; 1397 :     }

  003e6	e9 ae 01 00 00	 jmp	 $LN14@haltio
$LN13@haltio:

; 1398 :     else if (dev->ctctype == CTC_LCS)

  003eb	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003f3	0f b6 80 1c 07
	00 00		 movzx	 eax, BYTE PTR [rax+1820]
  003fa	83 f8 01	 cmp	 eax, 1
  003fd	0f 85 8e 01 00
	00		 jne	 $LN16@haltio

; 1399 :     {
; 1400 :         /* Set cc 1 if interrupt is not pending and LCS CTC */
; 1401 :         cc = 1;

  00403	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1

; 1402 : 
; 1403 :         /* Store the channel status word at PSA+X'40' */
; 1404 :         store_scsw_as_csw( regs, &dev->scsw );

  0040b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00413	48 05 08 03 00
	00		 add	 rax, 776		; 00000308H
  00419	48 8b d0	 mov	 rdx, rax
  0041c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00424	e8 00 00 00 00	 call	 store_scsw_as_csw

; 1405 : 
; 1406 :         if (dev->ccwtrace)

  00429	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00431	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00437	c1 e8 0f	 shr	 eax, 15
  0043a	83 e0 01	 and	 eax, 1
  0043d	85 c0		 test	 eax, eax
  0043f	0f 84 4a 01 00
	00		 je	 $LN18@haltio

; 1407 :         {
; 1408 :             psa = (PSA_3XX*)(regs->mainstor + regs->PX);

  00445	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0044d	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00450	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00458	48 03 81 48 08
	00 00		 add	 rax, QWORD PTR [rcx+2120]
  0045f	48 89 44 24 68	 mov	 QWORD PTR psa$[rsp], rax

; 1409 :             if (sysblk.traceFILE)

  00464	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0046b	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00473	74 45		 je	 SHORT $LN19@haltio

; 1410 :             {
; 1411 :                 tf_1330( dev );

  00475	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0047d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1330

; 1412 :                 DISPLAY_CSW( dev, psa->csw );

  00483	48 8b 44 24 68	 mov	 rax, QWORD PTR psa$[rsp]
  00488	48 83 c0 40	 add	 rax, 64			; 00000040H
  0048c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170502
  00493	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00498	41 b9 84 05 00
	00		 mov	 r9d, 1412		; 00000584H
  0049e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170503
  004a5	48 8b d0	 mov	 rdx, rax
  004a8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004b0	e8 00 00 00 00	 call	 _display_csw

; 1413 :             }

  004b5	e9 d5 00 00 00	 jmp	 $LN20@haltio
$LN19@haltio:

; 1414 :             else
; 1415 :             {
; 1416 :                 // "%1d:%04X CHAN: HIO modification executed: cc=1"
; 1417 :                 WRMSG( HHC01330, "I", LCSS_DEVNUM );

  004ba	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  004c3	74 12		 je	 SHORT $LN26@haltio
  004c5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004cd	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  004d1	89 44 24 5c	 mov	 DWORD PTR tv244[rsp], eax
  004d5	eb 08		 jmp	 SHORT $LN27@haltio
$LN26@haltio:
  004d7	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv244[rsp], 0
$LN27@haltio:
  004df	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  004e8	74 14		 je	 SHORT $LN28@haltio
  004ea	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004f2	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  004f6	d1 f8		 sar	 eax, 1
  004f8	89 44 24 60	 mov	 DWORD PTR tv250[rsp], eax
  004fc	eb 08		 jmp	 SHORT $LN29@haltio
$LN28@haltio:
  004fe	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv250[rsp], 0
$LN29@haltio:
  00506	b9 01 00 00 00	 mov	 ecx, 1
  0050b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00511	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv244[rsp]
  00515	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00519	8b 4c 24 60	 mov	 ecx, DWORD PTR tv250[rsp]
  0051d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00521	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170504
  00528	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0052d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170505
  00534	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00539	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0053e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00544	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170506
  0054b	ba 89 05 00 00	 mov	 edx, 1417		; 00000589H
  00550	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170507
  00557	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1418 :                 DISPLAY_CSW( dev, psa->csw );

  0055d	48 8b 44 24 68	 mov	 rax, QWORD PTR psa$[rsp]
  00562	48 83 c0 40	 add	 rax, 64			; 00000040H
  00566	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170508
  0056d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00572	41 b9 8a 05 00
	00		 mov	 r9d, 1418		; 0000058aH
  00578	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170509
  0057f	48 8b d0	 mov	 rdx, rax
  00582	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0058a	e8 00 00 00 00	 call	 _display_csw
$LN20@haltio:
$LN18@haltio:

; 1419 :             }
; 1420 :         }
; 1421 :     }

  0058f	eb 08		 jmp	 SHORT $LN17@haltio
$LN16@haltio:

; 1422 :     else
; 1423 :     {
; 1424 :         /* Set condition code 0 if interrupt is pending */
; 1425 :         cc = 0;

  00591	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0
$LN17@haltio:
$LN14@haltio:
$LN9@haltio:

; 1426 :     }
; 1427 : 
; 1428 :     /* Update interrupt status */
; 1429 :     subchannel_interrupt_queue_cleanup( dev );

  00599	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005a1	e8 00 00 00 00	 call	 subchannel_interrupt_queue_cleanup

; 1430 :     UPDATE_IC_IOPENDING_QLOCKED();

  005a6	e8 00 00 00 00	 call	 Update_IC_IOPENDING_QLocked

; 1431 : 
; 1432 :     /* Release locks */
; 1433 :     release_lock( &dev->lock );

  005ab	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005b3	48 83 c0 38	 add	 rax, 56			; 00000038H
  005b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170510
  005be	48 8b c8	 mov	 rcx, rax
  005c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1434 :     RELEASE_INTLOCK( regs );

  005c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170511
  005ce	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005d6	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1435 : 
; 1436 :     /* Return the condition code */
; 1437 :     return cc;

  005db	8b 44 24 50	 mov	 eax, DWORD PTR cc$[rsp]

; 1438 : 
; 1439 : } /* end function haltio */

  005df	48 83 c4 78	 add	 rsp, 120		; 00000078H
  005e3	c3		 ret	 0
haltio	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv75 = 80
tv81 = 84
tv179 = 88
tv185 = 92
tv217 = 96
tv223 = 100
tv443 = 104
tmp$1 = 112
regs$ = 144
dev$ = 152
halt_subchan PROC

; 2106 : {

$LN54:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
$LN4@halt_subch:

; 2107 :     UNREFERENCED( regs );

  00011	33 c0		 xor	 eax, eax
  00013	85 c0		 test	 eax, eax
  00015	75 fa		 jne	 SHORT $LN4@halt_subch

; 2108 : 
; 2109 :     if (dev->ccwtrace)

  00017	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0001f	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00025	c1 e8 0f	 shr	 eax, 15
  00028	83 e0 01	 and	 eax, 1
  0002b	85 c0		 test	 eax, eax
  0002d	0f 84 c7 00 00
	00		 je	 $LN8@halt_subch

; 2110 :     {
; 2111 :         if (sysblk.traceFILE)

  00033	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003a	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00042	74 13		 je	 SHORT $LN9@halt_subch

; 2112 :             tf_1332( dev );

  00044	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1332
  00052	e9 a3 00 00 00	 jmp	 $LN10@halt_subch
$LN9@halt_subch:

; 2113 :         else
; 2114 :             // "%1d:%04X CHAN: halt subchannel"
; 2115 :             WRMSG( HHC01332, "I", LCSS_DEVNUM );

  00057	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00060	74 12		 je	 SHORT $LN40@halt_subch
  00062	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0006a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0006e	89 44 24 50	 mov	 DWORD PTR tv75[rsp], eax
  00072	eb 08		 jmp	 SHORT $LN41@halt_subch
$LN40@halt_subch:
  00074	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN41@halt_subch:
  0007c	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00085	74 14		 je	 SHORT $LN42@halt_subch
  00087	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0008f	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00093	d1 f8		 sar	 eax, 1
  00095	89 44 24 54	 mov	 DWORD PTR tv81[rsp], eax
  00099	eb 08		 jmp	 SHORT $LN43@halt_subch
$LN42@halt_subch:
  0009b	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN43@halt_subch:
  000a3	b9 01 00 00 00	 mov	 ecx, 1
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000ae	8b 4c 24 50	 mov	 ecx, DWORD PTR tv75[rsp]
  000b2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000b6	8b 4c 24 54	 mov	 ecx, DWORD PTR tv81[rsp]
  000ba	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170751
  000c5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170752
  000d1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000d6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000db	41 b9 03 00 00
	00		 mov	 r9d, 3
  000e1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170753
  000e8	ba 43 08 00 00	 mov	 edx, 2115		; 00000843H
  000ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170754
  000f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN10@halt_subch:
$LN8@halt_subch:

; 2116 :     }
; 2117 : 
; 2118 :     OBTAIN_INTLOCK( regs );

  000fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170755
  00101	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00109	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 2119 :     obtain_lock( &dev->lock );

  0010e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00116	48 83 c0 38	 add	 rax, 56			; 00000038H
  0011a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170756
  00121	48 8b c8	 mov	 rcx, rax
  00124	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2120 : 
; 2121 : #if defined( _FEATURE_IO_ASSIST )
; 2122 :     if (1
; 2123 :         && SIE_MODE(regs)
; 2124 :         && (0

  0012a	33 c0		 xor	 eax, eax
  0012c	83 f8 01	 cmp	 eax, 1
  0012f	0f 84 aa 00 00
	00		 je	 $LN11@halt_subch
  00135	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013d	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00143	d1 e8		 shr	 eax, 1
  00145	83 e0 01	 and	 eax, 1
  00148	85 c0		 test	 eax, eax
  0014a	0f 84 8f 00 00
	00		 je	 $LN11@halt_subch
  00150	33 c0		 xor	 eax, eax
  00152	85 c0		 test	 eax, eax
  00154	75 3e		 jne	 SHORT $LN12@halt_subch
  00156	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015e	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00165	0f b6 40 74	 movzx	 eax, BYTE PTR [rax+116]
  00169	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00171	0f b6 89 04 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+772]
  00178	3b c1		 cmp	 eax, ecx
  0017a	75 18		 jne	 SHORT $LN12@halt_subch
  0017c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00184	0f b6 80 07 03
	00 00		 movzx	 eax, BYTE PTR [rax+775]
  0018b	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00190	85 c0		 test	 eax, eax
  00192	75 4b		 jne	 SHORT $LN11@halt_subch
$LN12@halt_subch:

; 2125 :             || regs->siebk->zone != dev->pmcw.zone
; 2126 :             || !(dev->pmcw.flag27 & PMCW27_I)
; 2127 :            )
; 2128 :     )
; 2129 :     {
; 2130 :         release_lock( &dev->lock );

  00194	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0019c	48 83 c0 38	 add	 rax, 56			; 00000038H
  001a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170759
  001a7	48 8b c8	 mov	 rcx, rax
  001aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2131 :         RELEASE_INTLOCK( regs );

  001b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170760
  001b7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001bf	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 2132 :         longjmp( regs->progjmp, SIE_INTERCEPT_INST );

  001c4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cc	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  001d2	ba fc ff ff ff	 mov	 edx, -4
  001d7	48 8b c8	 mov	 rcx, rax
  001da	e8 00 00 00 00	 call	 longjmp
$LN11@halt_subch:

; 2133 :     }
; 2134 : #endif
; 2135 : 
; 2136 :     /* Set condition code 1 if subchannel is status pending alone or
; 2137 :        is status pending with alert, primary, or secondary status
; 2138 :     */
; 2139 :     if (0
; 2140 :         || (dev->scsw.flag3 & SCSW3_SC) == SCSW3_SC_PEND
; 2141 :         || (1

  001df	33 c0		 xor	 eax, eax
  001e1	85 c0		 test	 eax, eax
  001e3	75 56		 jne	 SHORT $LN14@halt_subch
  001e5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ed	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  001f4	83 e0 1f	 and	 eax, 31
  001f7	83 f8 01	 cmp	 eax, 1
  001fa	74 3f		 je	 SHORT $LN14@halt_subch
  001fc	33 c0		 xor	 eax, eax
  001fe	83 f8 01	 cmp	 eax, 1
  00201	0f 84 5b 01 00
	00		 je	 $LN13@halt_subch
  00207	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0020f	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00216	83 e0 01	 and	 eax, 1
  00219	85 c0		 test	 eax, eax
  0021b	0f 84 41 01 00
	00		 je	 $LN13@halt_subch
  00221	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00229	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00230	83 e0 16	 and	 eax, 22
  00233	85 c0		 test	 eax, eax
  00235	0f 84 27 01 00
	00		 je	 $LN13@halt_subch
$LN14@halt_subch:

; 2142 :                 && (dev->scsw.flag3 & SCSW3_SC_PEND)
; 2143 :                 && (dev->scsw.flag3 & (SCSW3_SC_ALERT | SCSW3_SC_PRI | SCSW3_SC_SEC))
; 2144 :            )
; 2145 :     )
; 2146 :     {
; 2147 :         if (dev->ccwtrace)

  0023b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00243	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00249	c1 e8 0f	 shr	 eax, 15
  0024c	83 e0 01	 and	 eax, 1
  0024f	85 c0		 test	 eax, eax
  00251	0f 84 d1 00 00
	00		 je	 $LN15@halt_subch

; 2148 :         {
; 2149 :             if (sysblk.traceFILE)

  00257	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0025e	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00266	74 15		 je	 SHORT $LN16@halt_subch

; 2150 :                 tf_1300( dev, 1 );

  00268	b2 01		 mov	 dl, 1
  0026a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00272	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1300
  00278	e9 ab 00 00 00	 jmp	 $LN17@halt_subch
$LN16@halt_subch:

; 2151 :             else
; 2152 :                 // "%1d:%04X CHAN: halt subchannel: cc=%d"
; 2153 :                 WRMSG( HHC01300, "I", LCSS_DEVNUM, 1 );

  0027d	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00286	74 12		 je	 SHORT $LN44@halt_subch
  00288	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00290	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00294	89 44 24 58	 mov	 DWORD PTR tv179[rsp], eax
  00298	eb 08		 jmp	 SHORT $LN45@halt_subch
$LN44@halt_subch:
  0029a	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv179[rsp], 0
$LN45@halt_subch:
  002a2	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002ab	74 14		 je	 SHORT $LN46@halt_subch
  002ad	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002b5	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  002b9	d1 f8		 sar	 eax, 1
  002bb	89 44 24 5c	 mov	 DWORD PTR tv185[rsp], eax
  002bf	eb 08		 jmp	 SHORT $LN47@halt_subch
$LN46@halt_subch:
  002c1	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv185[rsp], 0
$LN47@halt_subch:
  002c9	b9 01 00 00 00	 mov	 ecx, 1
  002ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002d4	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR [rsp+72], 1
  002dc	8b 4c 24 58	 mov	 ecx, DWORD PTR tv179[rsp]
  002e0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002e4	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv185[rsp]
  002e8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170766
  002f3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170767
  002ff	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00304	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00309	41 b9 03 00 00
	00		 mov	 r9d, 3
  0030f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170768
  00316	ba 69 08 00 00	 mov	 edx, 2153		; 00000869H
  0031b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170769
  00322	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN17@halt_subch:
$LN15@halt_subch:

; 2154 :         }
; 2155 :         release_lock( &dev->lock );

  00328	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00330	48 83 c0 38	 add	 rax, 56			; 00000038H
  00334	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170770
  0033b	48 8b c8	 mov	 rcx, rax
  0033e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2156 :         RELEASE_INTLOCK( regs );

  00344	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170771
  0034b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00353	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 2157 :         return 1;

  00358	b8 01 00 00 00	 mov	 eax, 1
  0035d	e9 40 07 00 00	 jmp	 $LN1@halt_subch
$LN13@halt_subch:

; 2158 :     }
; 2159 : 
; 2160 :     /* Set condition code 2 if the halt function or the clear
; 2161 :        function is already in progress at the subchannel
; 2162 :     */
; 2163 :     if (dev->scsw.flag2 & (SCSW2_AC_HALT | SCSW2_AC_CLEAR))

  00362	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0036a	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00371	83 e0 03	 and	 eax, 3
  00374	85 c0		 test	 eax, eax
  00376	0f 84 27 01 00
	00		 je	 $LN18@halt_subch

; 2164 :     {
; 2165 :         if (dev->ccwtrace)

  0037c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00384	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0038a	c1 e8 0f	 shr	 eax, 15
  0038d	83 e0 01	 and	 eax, 1
  00390	85 c0		 test	 eax, eax
  00392	0f 84 d1 00 00
	00		 je	 $LN19@halt_subch

; 2166 :         {
; 2167 :             if (sysblk.traceFILE)

  00398	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0039f	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  003a7	74 15		 je	 SHORT $LN20@halt_subch

; 2168 :                 tf_1300( dev, 2 );

  003a9	b2 02		 mov	 dl, 2
  003ab	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1300
  003b9	e9 ab 00 00 00	 jmp	 $LN21@halt_subch
$LN20@halt_subch:

; 2169 :             else
; 2170 :                 // "%1d:%04X CHAN: halt subchannel: cc=%d"
; 2171 :                 WRMSG( HHC01300, "I", LCSS_DEVNUM, 2 );

  003be	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003c7	74 12		 je	 SHORT $LN48@halt_subch
  003c9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003d1	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003d5	89 44 24 60	 mov	 DWORD PTR tv217[rsp], eax
  003d9	eb 08		 jmp	 SHORT $LN49@halt_subch
$LN48@halt_subch:
  003db	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv217[rsp], 0
$LN49@halt_subch:
  003e3	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003ec	74 14		 je	 SHORT $LN50@halt_subch
  003ee	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003f6	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  003fa	d1 f8		 sar	 eax, 1
  003fc	89 44 24 64	 mov	 DWORD PTR tv223[rsp], eax
  00400	eb 08		 jmp	 SHORT $LN51@halt_subch
$LN50@halt_subch:
  00402	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv223[rsp], 0
$LN51@halt_subch:
  0040a	b9 01 00 00 00	 mov	 ecx, 1
  0040f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00415	c7 44 24 48 02
	00 00 00	 mov	 DWORD PTR [rsp+72], 2
  0041d	8b 4c 24 60	 mov	 ecx, DWORD PTR tv217[rsp]
  00421	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00425	8b 4c 24 64	 mov	 ecx, DWORD PTR tv223[rsp]
  00429	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0042d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170776
  00434	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00439	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170777
  00440	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00445	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0044a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00450	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170778
  00457	ba 7b 08 00 00	 mov	 edx, 2171		; 0000087bH
  0045c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170779
  00463	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN21@halt_subch:
$LN19@halt_subch:

; 2172 :         }
; 2173 :         release_lock( &dev->lock );

  00469	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00471	48 83 c0 38	 add	 rax, 56			; 00000038H
  00475	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170780
  0047c	48 8b c8	 mov	 rcx, rax
  0047f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2174 :         RELEASE_INTLOCK( regs );

  00485	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170781
  0048c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00494	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 2175 :         return 2;

  00499	b8 02 00 00 00	 mov	 eax, 2
  0049e	e9 ff 05 00 00	 jmp	 $LN1@halt_subch
$LN18@halt_subch:

; 2176 :     }
; 2177 : 
; 2178 :     /* Ensure SCSW flags are set from the ORB */
; 2179 :     if (dev->orb.flag4 & ORB4_S)

  004a3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004ab	0f b6 80 d0 02
	00 00		 movzx	 eax, BYTE PTR [rax+720]
  004b2	83 e0 08	 and	 eax, 8
  004b5	85 c0		 test	 eax, eax
  004b7	74 60		 je	 SHORT $LN22@halt_subch

; 2180 :     {
; 2181 :         dev->scsw.flag0     |= SCSW0_S;

  004b9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004c1	0f b6 80 08 03
	00 00		 movzx	 eax, BYTE PTR [rax+776]
  004c8	83 c8 08	 or	 eax, 8
  004cb	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004d3	88 81 08 03 00
	00		 mov	 BYTE PTR [rcx+776], al

; 2182 :         dev->pciscsw.flag0  |= SCSW0_S;

  004d9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004e1	0f b6 80 14 03
	00 00		 movzx	 eax, BYTE PTR [rax+788]
  004e8	83 c8 08	 or	 eax, 8
  004eb	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004f3	88 81 14 03 00
	00		 mov	 BYTE PTR [rcx+788], al

; 2183 :         dev->attnscsw.flag0 |= SCSW0_S;

  004f9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00501	0f b6 80 20 03
	00 00		 movzx	 eax, BYTE PTR [rax+800]
  00508	83 c8 08	 or	 eax, 8
  0050b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00513	88 81 20 03 00
	00		 mov	 BYTE PTR [rcx+800], al
$LN22@halt_subch:

; 2184 :     }
; 2185 : 
; 2186 :     if (dev->orb.flag5 & ORB5_F)

  00519	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00521	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  00528	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0052d	85 c0		 test	 eax, eax
  0052f	74 63		 je	 SHORT $LN23@halt_subch

; 2187 :     {
; 2188 :         dev->scsw.flag1     |= SCSW1_F;

  00531	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00539	0f b6 80 09 03
	00 00		 movzx	 eax, BYTE PTR [rax+777]
  00540	0f ba e8 07	 bts	 eax, 7
  00544	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0054c	88 81 09 03 00
	00		 mov	 BYTE PTR [rcx+777], al

; 2189 :         dev->pciscsw.flag1  |= SCSW1_F;

  00552	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0055a	0f b6 80 15 03
	00 00		 movzx	 eax, BYTE PTR [rax+789]
  00561	0f ba e8 07	 bts	 eax, 7
  00565	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0056d	88 81 15 03 00
	00		 mov	 BYTE PTR [rcx+789], al

; 2190 :         dev->attnscsw.flag1 |= SCSW1_F;

  00573	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0057b	0f b6 80 21 03
	00 00		 movzx	 eax, BYTE PTR [rax+801]
  00582	0f ba e8 07	 bts	 eax, 7
  00586	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0058e	88 81 21 03 00
	00		 mov	 BYTE PTR [rcx+801], al
$LN23@halt_subch:

; 2191 :     }
; 2192 : 
; 2193 :     if (dev->orb.flag5 & ORB5_P)

  00594	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0059c	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  005a3	83 e0 40	 and	 eax, 64			; 00000040H
  005a6	85 c0		 test	 eax, eax
  005a8	74 60		 je	 SHORT $LN24@halt_subch

; 2194 :     {
; 2195 :         dev->scsw.flag1     |= SCSW1_P;

  005aa	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005b2	0f b6 80 09 03
	00 00		 movzx	 eax, BYTE PTR [rax+777]
  005b9	83 c8 40	 or	 eax, 64			; 00000040H
  005bc	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005c4	88 81 09 03 00
	00		 mov	 BYTE PTR [rcx+777], al

; 2196 :         dev->pciscsw.flag1  |= SCSW1_P;

  005ca	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005d2	0f b6 80 15 03
	00 00		 movzx	 eax, BYTE PTR [rax+789]
  005d9	83 c8 40	 or	 eax, 64			; 00000040H
  005dc	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005e4	88 81 15 03 00
	00		 mov	 BYTE PTR [rcx+789], al

; 2197 :         dev->attnscsw.flag1 |= SCSW1_P;

  005ea	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005f2	0f b6 80 21 03
	00 00		 movzx	 eax, BYTE PTR [rax+801]
  005f9	83 c8 40	 or	 eax, 64			; 00000040H
  005fc	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00604	88 81 21 03 00
	00		 mov	 BYTE PTR [rcx+801], al
$LN24@halt_subch:

; 2198 :     }
; 2199 : 
; 2200 :     if (dev->orb.flag5 & ORB5_I)

  0060a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00612	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  00619	83 e0 20	 and	 eax, 32			; 00000020H
  0061c	85 c0		 test	 eax, eax
  0061e	74 60		 je	 SHORT $LN25@halt_subch

; 2201 :     {
; 2202 :         dev->scsw.flag1     |= SCSW1_I;

  00620	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00628	0f b6 80 09 03
	00 00		 movzx	 eax, BYTE PTR [rax+777]
  0062f	83 c8 20	 or	 eax, 32			; 00000020H
  00632	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0063a	88 81 09 03 00
	00		 mov	 BYTE PTR [rcx+777], al

; 2203 :         dev->pciscsw.flag1  |= SCSW1_I;

  00640	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00648	0f b6 80 15 03
	00 00		 movzx	 eax, BYTE PTR [rax+789]
  0064f	83 c8 20	 or	 eax, 32			; 00000020H
  00652	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0065a	88 81 15 03 00
	00		 mov	 BYTE PTR [rcx+789], al

; 2204 :         dev->attnscsw.flag1 |= SCSW1_I;

  00660	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00668	0f b6 80 21 03
	00 00		 movzx	 eax, BYTE PTR [rax+801]
  0066f	83 c8 20	 or	 eax, 32			; 00000020H
  00672	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0067a	88 81 21 03 00
	00		 mov	 BYTE PTR [rcx+801], al
$LN25@halt_subch:

; 2205 :     }
; 2206 : 
; 2207 :     if (dev->orb.flag5 & ORB5_A)

  00680	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00688	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  0068f	83 e0 10	 and	 eax, 16
  00692	85 c0		 test	 eax, eax
  00694	74 60		 je	 SHORT $LN26@halt_subch

; 2208 :     {
; 2209 :         dev->scsw.flag1     |= SCSW1_A;

  00696	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0069e	0f b6 80 09 03
	00 00		 movzx	 eax, BYTE PTR [rax+777]
  006a5	83 c8 10	 or	 eax, 16
  006a8	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006b0	88 81 09 03 00
	00		 mov	 BYTE PTR [rcx+777], al

; 2210 :         dev->pciscsw.flag1  |= SCSW1_A;

  006b6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006be	0f b6 80 15 03
	00 00		 movzx	 eax, BYTE PTR [rax+789]
  006c5	83 c8 10	 or	 eax, 16
  006c8	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006d0	88 81 15 03 00
	00		 mov	 BYTE PTR [rcx+789], al

; 2211 :         dev->attnscsw.flag1 |= SCSW1_A;

  006d6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006de	0f b6 80 21 03
	00 00		 movzx	 eax, BYTE PTR [rax+801]
  006e5	83 c8 10	 or	 eax, 16
  006e8	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006f0	88 81 21 03 00
	00		 mov	 BYTE PTR [rcx+801], al
$LN26@halt_subch:

; 2212 :     }
; 2213 : 
; 2214 :     if (dev->orb.flag5 & ORB5_U)

  006f6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006fe	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  00705	83 e0 08	 and	 eax, 8
  00708	85 c0		 test	 eax, eax
  0070a	74 60		 je	 SHORT $LN27@halt_subch

; 2215 :     {
; 2216 :         dev->scsw.flag1     |= SCSW1_U;

  0070c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00714	0f b6 80 09 03
	00 00		 movzx	 eax, BYTE PTR [rax+777]
  0071b	83 c8 08	 or	 eax, 8
  0071e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00726	88 81 09 03 00
	00		 mov	 BYTE PTR [rcx+777], al

; 2217 :         dev->pciscsw.flag1  |= SCSW1_U;

  0072c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00734	0f b6 80 15 03
	00 00		 movzx	 eax, BYTE PTR [rax+789]
  0073b	83 c8 08	 or	 eax, 8
  0073e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00746	88 81 15 03 00
	00		 mov	 BYTE PTR [rcx+789], al

; 2218 :         dev->attnscsw.flag1 |= SCSW1_U;

  0074c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00754	0f b6 80 21 03
	00 00		 movzx	 eax, BYTE PTR [rax+801]
  0075b	83 c8 08	 or	 eax, 8
  0075e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00766	88 81 21 03 00
	00		 mov	 BYTE PTR [rcx+801], al
$LN27@halt_subch:

; 2219 :     }
; 2220 : 
; 2221 :     /* Indicate halt pending to the various SCSWs for device */
; 2222 :     dev->attnscsw.flag2 |= SCSW2_AC_HALT;

  0076c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00774	0f b6 80 22 03
	00 00		 movzx	 eax, BYTE PTR [rax+802]
  0077b	83 c8 02	 or	 eax, 2
  0077e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00786	88 81 22 03 00
	00		 mov	 BYTE PTR [rcx+802], al

; 2223 :     dev->pciscsw.flag2  |= SCSW2_AC_HALT;

  0078c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00794	0f b6 80 16 03
	00 00		 movzx	 eax, BYTE PTR [rax+790]
  0079b	83 c8 02	 or	 eax, 2
  0079e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  007a6	88 81 16 03 00
	00		 mov	 BYTE PTR [rcx+790], al

; 2224 :     dev->scsw.flag2     |= SCSW2_AC_HALT;

  007ac	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007b4	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  007bb	83 c8 02	 or	 eax, 2
  007be	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  007c6	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 2225 : 
; 2226 :     /* If intermediate status pending with subchannel and device active,
; 2227 :      * reset intermediate status pending (HSCH, fifth paragraph).
; 2228 :      */
; 2229 :     if ((dev->scsw.flag3 & (SCSW3_AC_SCHAC | SCSW3_AC_DEVAC | SCSW3_SC_INTER | SCSW3_SC_PEND))
; 2230 :                 ==         (SCSW3_AC_SCHAC | SCSW3_AC_DEVAC | SCSW3_SC_INTER | SCSW3_SC_PEND)

  007cc	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007d4	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  007db	25 c9 00 00 00	 and	 eax, 201		; 000000c9H
  007e0	3d c9 00 00 00	 cmp	 eax, 201		; 000000c9H
  007e5	75 20		 jne	 SHORT $LN28@halt_subch

; 2231 :     )
; 2232 :         dev->scsw.flag3 &= ~(SCSW3_SC_INTER | SCSW3_SC_PEND);

  007e7	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007ef	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  007f6	83 e0 f6	 and	 eax, -10
  007f9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00801	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al
$LN28@halt_subch:

; 2233 : 
; 2234 :     /* If the device is busy then signal the subchannel to halt,
; 2235 :        UNLESS it's suspended (in which case signal it to resume;
; 2236 :        the halt will occur when resumed). If it's startpending,
; 2237 :        remove the I/O from the queue and then halt subhchannel.
; 2238 :        Otherwise (not busy/startpending/suspended) do nothing.
; 2239 :     */
; 2240 :     if (0
; 2241 : #if defined( OPTION_SHARED_DEVICES )
; 2242 :         || (dev->busy && dev->shioactive == DEV_SYS_LOCAL)
; 2243 : #else
; 2244 :         || dev->busy
; 2245 : #endif
; 2246 :         || dev->startpending
; 2247 :         || dev->suspended

  00807	33 c0		 xor	 eax, eax
  00809	85 c0		 test	 eax, eax
  0080b	75 60		 jne	 SHORT $LN30@halt_subch
  0080d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00815	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0081b	c1 e8 13	 shr	 eax, 19
  0081e	83 e0 01	 and	 eax, 1
  00821	85 c0		 test	 eax, eax
  00823	74 14		 je	 SHORT $LN31@halt_subch
  00825	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0082d	81 b8 e4 05 00
	00 ff ff 00 00	 cmp	 DWORD PTR [rax+1508], 65535 ; 0000ffffH
  00837	74 34		 je	 SHORT $LN30@halt_subch
$LN31@halt_subch:
  00839	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00841	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00847	c1 e8 19	 shr	 eax, 25
  0084a	83 e0 01	 and	 eax, 1
  0084d	85 c0		 test	 eax, eax
  0084f	75 1c		 jne	 SHORT $LN30@halt_subch
  00851	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00859	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0085f	c1 e8 15	 shr	 eax, 21
  00862	83 e0 01	 and	 eax, 1
  00865	85 c0		 test	 eax, eax
  00867	0f 84 12 02 00
	00		 je	 $LN29@halt_subch
$LN30@halt_subch:

; 2248 :     )
; 2249 :     {
; 2250 :         /* Set halt condition and reset pending condition */
; 2251 :         dev->scsw.flag2 |= (SCSW2_FC_HALT | SCSW2_AC_HALT);

  0086d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00875	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  0087c	83 c8 22	 or	 eax, 34			; 00000022H
  0087f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00887	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 2252 :         dev->scsw.flag3 &= ~SCSW3_SC_PEND;

  0088d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00895	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  0089c	83 e0 fe	 and	 eax, -2
  0089f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  008a7	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 2253 : 
; 2254 :         /* Signal the subchannel to resume if it is suspended */
; 2255 :         if (dev->scsw.flag3 & SCSW3_AC_SUSP)

  008ad	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  008b5	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  008bc	83 e0 20	 and	 eax, 32			; 00000020H
  008bf	85 c0		 test	 eax, eax
  008c1	74 34		 je	 SHORT $LN32@halt_subch

; 2256 :         {
; 2257 :             dev->scsw.flag2 |= SCSW2_AC_RESUM;

  008c3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  008cb	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  008d2	83 c8 08	 or	 eax, 8
  008d5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  008dd	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 2258 :             schedule_ioq( NULL, dev );

  008e3	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  008eb	33 c9		 xor	 ecx, ecx
  008ed	e8 00 00 00 00	 call	 schedule_ioq

; 2259 :         }

  008f2	e9 88 01 00 00	 jmp	 $LN33@halt_subch
$LN32@halt_subch:

; 2260 :         else /* Device is busy or startpending, NOT suspended */
; 2261 :         {
; 2262 :             /* Remove the device from the ioq if startpending and queued;
; 2263 :              * lock required before test to keep from entering queue and
; 2264 :              * becoming active prior to queue manipulation.
; 2265 :              */
; 2266 :             obtain_lock( &sysblk.ioqlock );

  008f7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  008fe	48 05 38 12 00
	00		 add	 rax, 4664		; 00001238H
  00904	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170794
  0090b	48 8b c8	 mov	 rcx, rax
  0090e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2267 :             {
; 2268 :                 if (dev->startpending)

  00914	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0091c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00922	c1 e8 19	 shr	 eax, 25
  00925	83 e0 01	 and	 eax, 1
  00928	85 c0		 test	 eax, eax
  0092a	0f 84 32 01 00
	00		 je	 $LN34@halt_subch

; 2269 :                 {
; 2270 :                     /* If 1st entry in ioq is this device, remove it */
; 2271 :                     if (sysblk.ioq == dev)

  00930	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00937	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0093f	48 39 88 30 12
	00 00		 cmp	 QWORD PTR [rax+4656], rcx
  00946	75 22		 jne	 SHORT $LN35@halt_subch

; 2272 :                         sysblk.ioq = dev->nextioq;

  00948	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0094f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00957	48 8b 89 20 02
	00 00		 mov	 rcx, QWORD PTR [rcx+544]
  0095e	48 89 88 30 12
	00 00		 mov	 QWORD PTR [rax+4656], rcx
  00965	e9 d8 00 00 00	 jmp	 $LN36@halt_subch
$LN35@halt_subch:

; 2273 :                     /* Otherwise search queued I/Os if there are any */
; 2274 :                     else if (sysblk.ioq)

  0096a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00971	48 83 b8 30 12
	00 00 00	 cmp	 QWORD PTR [rax+4656], 0
  00979	0f 84 c3 00 00
	00		 je	 $LN37@halt_subch

; 2275 :                     {
; 2276 :                         DEVBLK* tmp;
; 2277 :                         /* Look for ioq entry for this device */
; 2278 :                         for (tmp = sysblk.ioq;

  0097f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00986	48 8b 80 30 12
	00 00		 mov	 rax, QWORD PTR [rax+4656]
  0098d	48 89 44 24 70	 mov	 QWORD PTR tmp$1[rsp], rax
  00992	eb 11		 jmp	 SHORT $LN7@halt_subch
$LN5@halt_subch:

; 2280 :                              tmp = tmp->nextioq) { };

  00994	48 8b 44 24 70	 mov	 rax, QWORD PTR tmp$1[rsp]
  00999	48 8b 80 20 02
	00 00		 mov	 rax, QWORD PTR [rax+544]
  009a0	48 89 44 24 70	 mov	 QWORD PTR tmp$1[rsp], rax
$LN7@halt_subch:

; 2279 :                              tmp->nextioq && tmp->nextioq != dev;

  009a5	48 8b 44 24 70	 mov	 rax, QWORD PTR tmp$1[rsp]
  009aa	48 83 b8 20 02
	00 00 00	 cmp	 QWORD PTR [rax+544], 0
  009b2	74 18		 je	 SHORT $LN6@halt_subch
  009b4	48 8b 44 24 70	 mov	 rax, QWORD PTR tmp$1[rsp]
  009b9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  009c1	48 39 88 20 02
	00 00		 cmp	 QWORD PTR [rax+544], rcx
  009c8	74 02		 je	 SHORT $LN6@halt_subch

; 2280 :                              tmp = tmp->nextioq) { };

  009ca	eb c8		 jmp	 SHORT $LN5@halt_subch
$LN6@halt_subch:

; 2281 :                         /* Is an I/O queued for this device? */
; 2282 :                         if (tmp->nextioq == dev)

  009cc	48 8b 44 24 70	 mov	 rax, QWORD PTR tmp$1[rsp]
  009d1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  009d9	48 39 88 20 02
	00 00		 cmp	 QWORD PTR [rax+544], rcx
  009e0	75 60		 jne	 SHORT $LN38@halt_subch

; 2283 :                         {
; 2284 :                             /* Remove this device's ioq entry */
; 2285 :                             tmp->nextioq = tmp->nextioq->nextioq;

  009e2	48 8b 44 24 70	 mov	 rax, QWORD PTR tmp$1[rsp]
  009e7	48 8b 80 20 02
	00 00		 mov	 rax, QWORD PTR [rax+544]
  009ee	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tmp$1[rsp]
  009f3	48 8b 80 20 02
	00 00		 mov	 rax, QWORD PTR [rax+544]
  009fa	48 89 81 20 02
	00 00		 mov	 QWORD PTR [rcx+544], rax

; 2286 :                             sysblk.devtunavail = MAX( 0, sysblk.devtunavail - 1 );

  00a01	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a08	8b 80 58 12 00
	00		 mov	 eax, DWORD PTR [rax+4696]
  00a0e	ff c8		 dec	 eax
  00a10	85 c0		 test	 eax, eax
  00a12	7d 0a		 jge	 SHORT $LN52@halt_subch
  00a14	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv443[rsp], 0
  00a1c	eb 13		 jmp	 SHORT $LN53@halt_subch
$LN52@halt_subch:
  00a1e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a25	8b 80 58 12 00
	00		 mov	 eax, DWORD PTR [rax+4696]
  00a2b	ff c8		 dec	 eax
  00a2d	89 44 24 68	 mov	 DWORD PTR tv443[rsp], eax
$LN53@halt_subch:
  00a31	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a38	8b 4c 24 68	 mov	 ecx, DWORD PTR tv443[rsp]
  00a3c	89 88 58 12 00
	00		 mov	 DWORD PTR [rax+4696], ecx
$LN38@halt_subch:
$LN37@halt_subch:
$LN36@halt_subch:

; 2287 :                         }
; 2288 :                     }
; 2289 :                     dev->startpending = 0;

  00a42	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a4a	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00a50	0f ba f0 19	 btr	 eax, 25
  00a54	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a5c	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
$LN34@halt_subch:

; 2290 :                 }
; 2291 :             }
; 2292 :             release_lock( &sysblk.ioqlock );

  00a62	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a69	48 05 38 12 00
	00		 add	 rax, 4664		; 00001238H
  00a6f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170800
  00a76	48 8b c8	 mov	 rcx, rax
  00a79	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN33@halt_subch:
$LN29@halt_subch:

; 2293 :         }
; 2294 :     }
; 2295 : 
; 2296 :     /* Halt the device */
; 2297 :     perform_halt_and_release_lock( dev );

  00a7f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a87	e8 00 00 00 00	 call	 perform_halt_and_release_lock

; 2298 : 
; 2299 :     RELEASE_INTLOCK( regs );

  00a8c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170801
  00a93	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a9b	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 2300 : 
; 2301 :     /* Return condition code zero */
; 2302 :     return 0;

  00aa0	33 c0		 xor	 eax, eax
$LN1@halt_subch:
$LN39@halt_subch:

; 2303 : 
; 2304 : } /* end function halt_subchan */

  00aa2	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00aa9	c3		 ret	 0
halt_subchan ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv75 = 80
tv81 = 84
regs$ = 112
dev$ = 120
clear_subchan PROC

; 1899 : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H
$LN4@clear_subc:

; 1900 :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@clear_subc

; 1901 : 
; 1902 :     if (dev->ccwtrace)

  00014	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00019	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0001f	c1 e8 0f	 shr	 eax, 15
  00022	83 e0 01	 and	 eax, 1
  00025	85 c0		 test	 eax, eax
  00027	0f 84 b8 00 00
	00		 je	 $LN5@clear_subc

; 1903 :     {
; 1904 :         if (sysblk.traceFILE)

  0002d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00034	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  0003c	74 10		 je	 SHORT $LN6@clear_subc

; 1905 :             tf_1331( dev );

  0003e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dev$[rsp]
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1331
  00049	e9 97 00 00 00	 jmp	 $LN7@clear_subc
$LN6@clear_subc:

; 1906 :         else
; 1907 :             // "%1d:%04X CHAN: clear subchannel"
; 1908 :             WRMSG( HHC01331, "I", LCSS_DEVNUM );

  0004e	48 83 7c 24 78
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00054	74 0f		 je	 SHORT $LN17@clear_subc
  00056	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  0005b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0005f	89 44 24 50	 mov	 DWORD PTR tv75[rsp], eax
  00063	eb 08		 jmp	 SHORT $LN18@clear_subc
$LN17@clear_subc:
  00065	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN18@clear_subc:
  0006d	48 83 7c 24 78
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00073	74 11		 je	 SHORT $LN19@clear_subc
  00075	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  0007a	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0007e	d1 f8		 sar	 eax, 1
  00080	89 44 24 54	 mov	 DWORD PTR tv81[rsp], eax
  00084	eb 08		 jmp	 SHORT $LN20@clear_subc
$LN19@clear_subc:
  00086	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN20@clear_subc:
  0008e	b9 01 00 00 00	 mov	 ecx, 1
  00093	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00099	8b 4c 24 50	 mov	 ecx, DWORD PTR tv75[rsp]
  0009d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000a1	8b 4c 24 54	 mov	 ecx, DWORD PTR tv81[rsp]
  000a5	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170677
  000b0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170678
  000bc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000c1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c6	41 b9 03 00 00
	00		 mov	 r9d, 3
  000cc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170679
  000d3	ba 74 07 00 00	 mov	 edx, 1908		; 00000774H
  000d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170680
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN7@clear_subc:
$LN5@clear_subc:

; 1909 :     }
; 1910 : 
; 1911 : #if defined( _FEATURE_IO_ASSIST )
; 1912 :     if (1
; 1913 :         && SIE_MODE( regs )
; 1914 :         && (0

  000e5	33 c0		 xor	 eax, eax
  000e7	83 f8 01	 cmp	 eax, 1
  000ea	74 67		 je	 SHORT $LN8@clear_subc
  000ec	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000f7	d1 e8		 shr	 eax, 1
  000f9	83 e0 01	 and	 eax, 1
  000fc	85 c0		 test	 eax, eax
  000fe	74 53		 je	 SHORT $LN8@clear_subc
  00100	33 c0		 xor	 eax, eax
  00102	85 c0		 test	 eax, eax
  00104	75 35		 jne	 SHORT $LN9@clear_subc
  00106	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0010b	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00112	0f b6 40 74	 movzx	 eax, BYTE PTR [rax+116]
  00116	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dev$[rsp]
  0011b	0f b6 89 04 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+772]
  00122	3b c1		 cmp	 eax, ecx
  00124	75 15		 jne	 SHORT $LN9@clear_subc
  00126	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  0012b	0f b6 80 07 03
	00 00		 movzx	 eax, BYTE PTR [rax+775]
  00132	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00137	85 c0		 test	 eax, eax
  00139	75 18		 jne	 SHORT $LN8@clear_subc
$LN9@clear_subc:

; 1915 :             || regs->siebk->zone != dev->pmcw.zone
; 1916 :             || !(dev->pmcw.flag27 & PMCW27_I)
; 1917 :            )
; 1918 :     )
; 1919 :     {
; 1920 :         longjmp( regs->progjmp, SIE_INTERCEPT_INST );

  0013b	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00146	ba fc ff ff ff	 mov	 edx, -4
  0014b	48 8b c8	 mov	 rcx, rax
  0014e	e8 00 00 00 00	 call	 longjmp
$LN8@clear_subc:

; 1921 :     }
; 1922 : #endif
; 1923 : 
; 1924 :     OBTAIN_INTLOCK( NULL );

  00153	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170683
  0015a	33 c9		 xor	 ecx, ecx
  0015c	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 1925 :     obtain_lock( &dev->lock );

  00161	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00166	48 83 c0 38	 add	 rax, 56			; 00000038H
  0016a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170684
  00171	48 8b c8	 mov	 rcx, rax
  00174	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1926 : 
; 1927 :     /* If the device is busy then signal the device to clear */
; 1928 :     if (0
; 1929 :         || (dev->busy
; 1930 : #if defined( OPTION_SHARED_DEVICES )
; 1931 :         && dev->shioactive == DEV_SYS_LOCAL
; 1932 : #endif
; 1933 :            )
; 1934 :         || dev->startpending
; 1935 :         /* CTCE devices need dev->hnd->halt to always be called
; 1936 :            even when not busy or startpending!
; 1937 :         */
; 1938 :         || dev->ctctype == CTC_CTCE

  0017a	33 c0		 xor	 eax, eax
  0017c	85 c0		 test	 eax, eax
  0017e	75 50		 jne	 SHORT $LN11@clear_subc
  00180	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00185	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0018b	c1 e8 13	 shr	 eax, 19
  0018e	83 e0 01	 and	 eax, 1
  00191	85 c0		 test	 eax, eax
  00193	74 11		 je	 SHORT $LN12@clear_subc
  00195	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  0019a	81 b8 e4 05 00
	00 ff ff 00 00	 cmp	 DWORD PTR [rax+1508], 65535 ; 0000ffffH
  001a4	74 2a		 je	 SHORT $LN11@clear_subc
$LN12@clear_subc:
  001a6	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  001ab	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001b1	c1 e8 19	 shr	 eax, 25
  001b4	83 e0 01	 and	 eax, 1
  001b7	85 c0		 test	 eax, eax
  001b9	75 15		 jne	 SHORT $LN11@clear_subc
  001bb	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  001c0	0f b6 80 1c 07
	00 00		 movzx	 eax, BYTE PTR [rax+1820]
  001c7	83 f8 04	 cmp	 eax, 4
  001ca	0f 85 03 01 00
	00		 jne	 $LN10@clear_subc
$LN11@clear_subc:

; 1939 :     )
; 1940 :     {
; 1941 :         /* Set clear pending condition */
; 1942 :         dev->scsw.flag2 |= SCSW2_FC_CLEAR | SCSW2_AC_CLEAR;

  001d0	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  001d5	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  001dc	83 c8 11	 or	 eax, 17
  001df	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dev$[rsp]
  001e4	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 1943 : 
; 1944 :         /* Signal the subchannel to resume if it is suspended */
; 1945 :         if (dev->scsw.flag3 & SCSW3_AC_SUSP)

  001ea	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  001ef	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  001f6	83 e0 20	 and	 eax, 32			; 00000020H
  001f9	85 c0		 test	 eax, eax
  001fb	74 2b		 je	 SHORT $LN13@clear_subc

; 1946 :         {
; 1947 :             dev->scsw.flag2 |= SCSW2_AC_RESUM;

  001fd	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00202	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00209	83 c8 08	 or	 eax, 8
  0020c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dev$[rsp]
  00211	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 1948 :             schedule_ioq( NULL, dev );

  00217	48 8b 54 24 78	 mov	 rdx, QWORD PTR dev$[rsp]
  0021c	33 c9		 xor	 ecx, ecx
  0021e	e8 00 00 00 00	 call	 schedule_ioq

; 1949 :         }

  00223	e9 ab 00 00 00	 jmp	 $LN14@clear_subc
$LN13@clear_subc:

; 1950 : 
; 1951 :         /* Invoke the provided halt device routine if it has been
; 1952 :          * provided by the handler code at init
; 1953 :          */
; 1954 :         else if (dev->hnd->halt != NULL)

  00228	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  0022d	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00234	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  00239	0f 84 94 00 00
	00		 je	 $LN15@clear_subc

; 1955 :         {
; 1956 :             /* Revert to just holding dev->lock */
; 1957 :             release_lock( &dev->lock );

  0023f	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00244	48 83 c0 38	 add	 rax, 56			; 00000038H
  00248	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170691
  0024f	48 8b c8	 mov	 rcx, rax
  00252	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1958 :             RELEASE_INTLOCK( NULL );

  00258	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170692
  0025f	33 c9		 xor	 ecx, ecx
  00261	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1959 : 
; 1960 :             obtain_lock( &dev->lock );

  00266	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  0026b	48 83 c0 38	 add	 rax, 56			; 00000038H
  0026f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170693
  00276	48 8b c8	 mov	 rcx, rax
  00279	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1961 :             {
; 1962 :                 /* Call the device's halt routine */
; 1963 :                 dev->hnd->halt( dev );

  0027f	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00284	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0028b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dev$[rsp]
  00290	ff 50 48	 call	 QWORD PTR [rax+72]

; 1964 :             }
; 1965 :             release_lock( &dev->lock );

  00293	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00298	48 83 c0 38	 add	 rax, 56			; 00000038H
  0029c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170694
  002a3	48 8b c8	 mov	 rcx, rax
  002a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1966 : 
; 1967 :             /* Return to holding BOTH intlock *and* dev->lock */
; 1968 :             OBTAIN_INTLOCK( NULL );

  002ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170695
  002b3	33 c9		 xor	 ecx, ecx
  002b5	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 1969 :             obtain_lock( &dev->lock );

  002ba	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  002bf	48 83 c0 38	 add	 rax, 56			; 00000038H
  002c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170696
  002ca	48 8b c8	 mov	 rcx, rax
  002cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN15@clear_subc:
$LN14@clear_subc:
$LN10@clear_subc:

; 1970 :         }
; 1971 :     }
; 1972 : 
; 1973 :     /* Perform clear subchannel operation and queue interrupt */
; 1974 :     perform_clear_subchan( dev );

  002d3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dev$[rsp]
  002d8	e8 00 00 00 00	 call	 perform_clear_subchan

; 1975 : 
; 1976 :     release_lock( &dev->lock );

  002dd	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  002e2	48 83 c0 38	 add	 rax, 56			; 00000038H
  002e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170697
  002ed	48 8b c8	 mov	 rcx, rax
  002f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1977 :     RELEASE_INTLOCK( NULL );

  002f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170698
  002fd	33 c9		 xor	 ecx, ecx
  002ff	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN16@clear_subc:

; 1978 : 
; 1979 : } /* end function clear_subchan */

  00304	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00308	c3		 ret	 0
clear_subchan ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
cc$ = 32
tv158 = 36
tmp$1 = 40
regs$ = 64
dev$ = 72
cancel_subchan PROC

; 1456 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@cancel_sub:

; 1457 : int     cc;                             /* Condition code            */
; 1458 : 
; 1459 :     UNREFERENCED(regs);

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@cancel_sub

; 1460 : 
; 1461 :     obtain_lock (&dev->lock);

  00014	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00019	48 83 c0 38	 add	 rax, 56			; 00000038H
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170528
  00024	48 8b c8	 mov	 rcx, rax
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1462 : 
; 1463 : #if defined(_FEATURE_IO_ASSIST)
; 1464 :     if(SIE_MODE(regs)
; 1465 :       && (regs->siebk->zone != dev->pmcw.zone

  0002d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00032	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00038	d1 e8		 shr	 eax, 1
  0003a	83 e0 01	 and	 eax, 1
  0003d	85 c0		 test	 eax, eax
  0003f	74 66		 je	 SHORT $LN8@cancel_sub
  00041	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00046	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0004d	0f b6 40 74	 movzx	 eax, BYTE PTR [rax+116]
  00051	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  00056	0f b6 89 04 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+772]
  0005d	3b c1		 cmp	 eax, ecx
  0005f	75 15		 jne	 SHORT $LN9@cancel_sub
  00061	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00066	0f b6 80 07 03
	00 00		 movzx	 eax, BYTE PTR [rax+775]
  0006d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00072	85 c0		 test	 eax, eax
  00074	75 31		 jne	 SHORT $LN8@cancel_sub
$LN9@cancel_sub:

; 1466 :         || !(dev->pmcw.flag27 & PMCW27_I)))
; 1467 :     {
; 1468 :         release_lock (&dev->lock);

  00076	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  0007b	48 83 c0 38	 add	 rax, 56			; 00000038H
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170531
  00086	48 8b c8	 mov	 rcx, rax
  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1469 :         longjmp(regs->progjmp,SIE_INTERCEPT_INST);

  0008f	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00094	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0009a	ba fc ff ff ff	 mov	 edx, -4
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	e8 00 00 00 00	 call	 longjmp
$LN8@cancel_sub:

; 1470 :     }
; 1471 : #endif
; 1472 : 
; 1473 :     /* Check pending status */
; 1474 :     if ((dev->pciscsw.flag3 & SCSW3_SC_PEND)
; 1475 :      || (dev->scsw.flag3    & SCSW3_SC_PEND)
; 1476 :      || (dev->attnscsw.flag3    & SCSW3_SC_PEND))

  000a7	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  000ac	0f b6 80 17 03
	00 00		 movzx	 eax, BYTE PTR [rax+791]
  000b3	83 e0 01	 and	 eax, 1
  000b6	85 c0		 test	 eax, eax
  000b8	75 26		 jne	 SHORT $LN12@cancel_sub
  000ba	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  000bf	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  000c6	83 e0 01	 and	 eax, 1
  000c9	85 c0		 test	 eax, eax
  000cb	75 13		 jne	 SHORT $LN12@cancel_sub
  000cd	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  000d2	0f b6 80 23 03
	00 00		 movzx	 eax, BYTE PTR [rax+803]
  000d9	83 e0 01	 and	 eax, 1
  000dc	85 c0		 test	 eax, eax
  000de	74 0d		 je	 SHORT $LN10@cancel_sub
$LN12@cancel_sub:

; 1477 :         cc = 1;

  000e0	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1
  000e8	e9 da 01 00 00	 jmp	 $LN11@cancel_sub
$LN10@cancel_sub:

; 1478 :     else
; 1479 :     {
; 1480 :         cc = 1;

  000ed	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1

; 1481 :         obtain_lock(&sysblk.ioqlock);

  000f5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000fc	48 05 38 12 00
	00		 add	 rax, 4664		; 00001238H
  00102	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170535
  00109	48 8b c8	 mov	 rcx, rax
  0010c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1482 :         if(sysblk.ioq != NULL)

  00112	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00119	48 83 b8 30 12
	00 00 00	 cmp	 QWORD PTR [rax+4656], 0
  00121	0f 84 01 01 00
	00		 je	 $LN13@cancel_sub

; 1483 :         {
; 1484 :         DEVBLK *tmp;
; 1485 : 
; 1486 :             /* special case for head of queue */
; 1487 :             if(sysblk.ioq == dev)

  00127	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0012e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  00133	48 39 88 30 12
	00 00		 cmp	 QWORD PTR [rax+4656], rcx
  0013a	75 27		 jne	 SHORT $LN14@cancel_sub

; 1488 :             {
; 1489 :                 /* Remove device from the i/o queue */
; 1490 :                 sysblk.ioq = dev->nextioq;

  0013c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00143	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  00148	48 8b 89 20 02
	00 00		 mov	 rcx, QWORD PTR [rcx+544]
  0014f	48 89 88 30 12
	00 00		 mov	 QWORD PTR [rax+4656], rcx

; 1491 :                 cc = 0;

  00156	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0

; 1492 :             }

  0015e	e9 c5 00 00 00	 jmp	 $LN15@cancel_sub
$LN14@cancel_sub:

; 1493 :             else
; 1494 :             {
; 1495 :                 /* Search for device on i/o queue */
; 1496 :                 for(tmp = sysblk.ioq;

  00163	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0016a	48 8b 80 30 12
	00 00		 mov	 rax, QWORD PTR [rax+4656]
  00171	48 89 44 24 28	 mov	 QWORD PTR tmp$1[rsp], rax
  00176	eb 11		 jmp	 SHORT $LN7@cancel_sub
$LN5@cancel_sub:

; 1498 :                     tmp = tmp->nextioq);

  00178	48 8b 44 24 28	 mov	 rax, QWORD PTR tmp$1[rsp]
  0017d	48 8b 80 20 02
	00 00		 mov	 rax, QWORD PTR [rax+544]
  00184	48 89 44 24 28	 mov	 QWORD PTR tmp$1[rsp], rax
$LN7@cancel_sub:

; 1497 :                     tmp->nextioq != NULL && tmp->nextioq != dev;

  00189	48 8b 44 24 28	 mov	 rax, QWORD PTR tmp$1[rsp]
  0018e	48 83 b8 20 02
	00 00 00	 cmp	 QWORD PTR [rax+544], 0
  00196	74 15		 je	 SHORT $LN6@cancel_sub
  00198	48 8b 44 24 28	 mov	 rax, QWORD PTR tmp$1[rsp]
  0019d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  001a2	48 39 88 20 02
	00 00		 cmp	 QWORD PTR [rax+544], rcx
  001a9	74 02		 je	 SHORT $LN6@cancel_sub

; 1498 :                     tmp = tmp->nextioq);

  001ab	eb cb		 jmp	 SHORT $LN5@cancel_sub
$LN6@cancel_sub:

; 1499 : 
; 1500 :                 /* Remove from queue if found */
; 1501 :                 if(tmp->nextioq == dev)

  001ad	48 8b 44 24 28	 mov	 rax, QWORD PTR tmp$1[rsp]
  001b2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  001b7	48 39 88 20 02
	00 00		 cmp	 QWORD PTR [rax+544], rcx
  001be	75 68		 jne	 SHORT $LN16@cancel_sub

; 1502 :                 {
; 1503 :                     tmp->nextioq = tmp->nextioq->nextioq;

  001c0	48 8b 44 24 28	 mov	 rax, QWORD PTR tmp$1[rsp]
  001c5	48 8b 80 20 02
	00 00		 mov	 rax, QWORD PTR [rax+544]
  001cc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tmp$1[rsp]
  001d1	48 8b 80 20 02
	00 00		 mov	 rax, QWORD PTR [rax+544]
  001d8	48 89 81 20 02
	00 00		 mov	 QWORD PTR [rcx+544], rax

; 1504 :                     sysblk.devtunavail = MAX(0, sysblk.devtunavail - 1);

  001df	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001e6	8b 80 58 12 00
	00		 mov	 eax, DWORD PTR [rax+4696]
  001ec	ff c8		 dec	 eax
  001ee	85 c0		 test	 eax, eax
  001f0	7d 0a		 jge	 SHORT $LN21@cancel_sub
  001f2	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv158[rsp], 0
  001fa	eb 13		 jmp	 SHORT $LN22@cancel_sub
$LN21@cancel_sub:
  001fc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00203	8b 80 58 12 00
	00		 mov	 eax, DWORD PTR [rax+4696]
  00209	ff c8		 dec	 eax
  0020b	89 44 24 24	 mov	 DWORD PTR tv158[rsp], eax
$LN22@cancel_sub:
  0020f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00216	8b 4c 24 24	 mov	 ecx, DWORD PTR tv158[rsp]
  0021a	89 88 58 12 00
	00		 mov	 DWORD PTR [rax+4696], ecx

; 1505 :                     cc = 0;

  00220	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0
$LN16@cancel_sub:
$LN15@cancel_sub:
$LN13@cancel_sub:

; 1506 :                 }
; 1507 :             }
; 1508 :         }
; 1509 :         release_lock(&sysblk.ioqlock);

  00228	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0022f	48 05 38 12 00
	00		 add	 rax, 4664		; 00001238H
  00235	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170540
  0023c	48 8b c8	 mov	 rcx, rax
  0023f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1510 : 
; 1511 :         /* Reset the device */
; 1512 :         if(!cc)

  00245	83 7c 24 20 00	 cmp	 DWORD PTR cc$[rsp], 0
  0024a	75 7b		 jne	 SHORT $LN17@cancel_sub

; 1513 :         {
; 1514 :             /* Terminate suspended channel program */
; 1515 :             if (dev->scsw.flag3 & SCSW3_AC_SUSP)

  0024c	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00251	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00258	83 e0 20	 and	 eax, 32			; 00000020H
  0025b	85 c0		 test	 eax, eax
  0025d	74 28		 je	 SHORT $LN18@cancel_sub

; 1516 :             {
; 1517 :                 dev->suspended = 0;

  0025f	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00264	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0026a	0f ba f0 15	 btr	 eax, 21
  0026e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  00273	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 1518 :                 schedule_ioq(NULL, dev);

  00279	48 8b 54 24 48	 mov	 rdx, QWORD PTR dev$[rsp]
  0027e	33 c9		 xor	 ecx, ecx
  00280	e8 00 00 00 00	 call	 schedule_ioq

; 1519 :             }

  00285	eb 40		 jmp	 SHORT $LN19@cancel_sub
$LN18@cancel_sub:

; 1520 :             else
; 1521 :             {
; 1522 :                 /* Reset the scsw */
; 1523 :                 dev->scsw.flag2 &= ~(SCSW2_AC_RESUM |

  00287	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  0028c	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00293	83 e0 b3	 and	 eax, -77		; ffffffffffffffb3H
  00296	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  0029b	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 1524 :                                      SCSW2_FC_START |
; 1525 :                                      SCSW2_AC_START);
; 1526 :                 dev->scsw.flag3 &= ~(SCSW3_AC_SCHAC |

  002a1	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  002a6	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  002ad	25 1f ff ff ff	 and	 eax, -225		; ffffffffffffff1fH
  002b2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  002b7	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 1527 :                                      SCSW3_AC_DEVAC |
; 1528 :                                      SCSW3_AC_SUSP);
; 1529 : 
; 1530 :                 /* Reset the device busy indicator */
; 1531 :                 clear_subchannel_busy(dev);

  002bd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  002c2	e8 00 00 00 00	 call	 clear_subchannel_busy
$LN19@cancel_sub:
$LN17@cancel_sub:
$LN11@cancel_sub:

; 1532 :             }
; 1533 :         }
; 1534 :     }
; 1535 : 
; 1536 :     release_lock (&dev->lock);

  002c7	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  002cc	48 83 c0 38	 add	 rax, 56			; 00000038H
  002d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170544
  002d7	48 8b c8	 mov	 rcx, rax
  002da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1537 : 
; 1538 :     /* Return the condition code */
; 1539 :     return cc;

  002e0	8b 44 24 20	 mov	 eax, DWORD PTR cc$[rsp]
$LN20@cancel_sub:

; 1540 : 
; 1541 : } /* end function cancel_subchan */

  002e4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  002e8	c3		 ret	 0
cancel_subchan ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
cc$ = 80
tv178 = 84
tv184 = 88
scsw$ = 96
ioint$ = 104
regs$ = 128
dev$ = 136
irb$ = 144
test_subchan PROC

; 1748 : {

$LN15:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1749 :     int     cc;                         /* Condition code            */
; 1750 :     IOINT*  ioint;                      /* I/O interrupt structure   */
; 1751 :     SCSW*   scsw;                       /* SCSW structure            */
; 1752 : 
; 1753 :     OBTAIN_INTLOCK(regs);

  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170608
  0001a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00022	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 1754 :     obtain_lock (&dev->lock);

  00027	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0002f	48 83 c0 38	 add	 rax, 56			; 00000038H
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170609
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1755 : 
; 1756 : #if defined(_FEATURE_IO_ASSIST)
; 1757 :     if(SIE_MODE(regs))

  00043	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00051	d1 e8		 shr	 eax, 1
  00053	83 e0 01	 and	 eax, 1
  00056	85 c0		 test	 eax, eax
  00058	0f 84 5f 01 00
	00		 je	 $LN2@test_subch

; 1758 :     {
; 1759 :         if (regs->siebk->zone != dev->pmcw.zone
; 1760 :             || !(dev->pmcw.flag27 & PMCW27_I))

  0005e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00066	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0006d	0f b6 40 74	 movzx	 eax, BYTE PTR [rax+116]
  00071	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00079	0f b6 89 04 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+772]
  00080	3b c1		 cmp	 eax, ecx
  00082	75 18		 jne	 SHORT $LN4@test_subch
  00084	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0008c	0f b6 80 07 03
	00 00		 movzx	 eax, BYTE PTR [rax+775]
  00093	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00098	85 c0		 test	 eax, eax
  0009a	75 4b		 jne	 SHORT $LN3@test_subch
$LN4@test_subch:

; 1761 :         {
; 1762 :             release_lock (&dev->lock);

  0009c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a4	48 83 c0 38	 add	 rax, 56			; 00000038H
  000a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170613
  000af	48 8b c8	 mov	 rcx, rax
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1763 :             RELEASE_INTLOCK(regs);

  000b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170614
  000bf	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c7	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1764 :             longjmp(regs->progjmp,SIE_INTERCEPT_INST);

  000cc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000da	ba fc ff ff ff	 mov	 edx, -4
  000df	48 8b c8	 mov	 rcx, rax
  000e2	e8 00 00 00 00	 call	 longjmp
$LN3@test_subch:

; 1765 :         }
; 1766 : 
; 1767 :         /* For I/O assisted devices we must intercept if type B
; 1768 :            status is present on the subchannel */
; 1769 :         if (dev->pciscsw.flag3 & SCSW3_SC_PEND &&

  000e7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ef	0f b6 80 17 03
	00 00		 movzx	 eax, BYTE PTR [rax+791]
  000f6	83 e0 01	 and	 eax, 1
  000f9	85 c0		 test	 eax, eax
  000fb	0f 84 bc 00 00
	00		 je	 $LN5@test_subch
  00101	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00109	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00110	0f b6 40 76	 movzx	 eax, BYTE PTR [rax+118]
  00114	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0011c	0f b6 89 1c 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+796]
  00123	23 c1		 and	 eax, ecx
  00125	85 c0		 test	 eax, eax
  00127	75 28		 jne	 SHORT $LN6@test_subch
  00129	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00131	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00138	0f b6 40 77	 movzx	 eax, BYTE PTR [rax+119]
  0013c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00144	0f b6 89 1d 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+797]
  0014b	23 c1		 and	 eax, ecx
  0014d	85 c0		 test	 eax, eax
  0014f	74 6c		 je	 SHORT $LN5@test_subch
$LN6@test_subch:

; 1770 :             (regs->siebk->tschds & dev->pciscsw.unitstat  ||
; 1771 :              regs->siebk->tschsc & dev->pciscsw.chanstat))
; 1772 :         {
; 1773 :             dev->pmcw.flag27 &= ~PMCW27_I;

  00151	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00159	0f b6 80 07 03
	00 00		 movzx	 eax, BYTE PTR [rax+775]
  00160	0f ba f0 07	 btr	 eax, 7
  00164	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0016c	88 81 07 03 00
	00		 mov	 BYTE PTR [rcx+775], al

; 1774 :             release_lock (&dev->lock);

  00172	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0017a	48 83 c0 38	 add	 rax, 56			; 00000038H
  0017e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170617
  00185	48 8b c8	 mov	 rcx, rax
  00188	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1775 :             RELEASE_INTLOCK(regs);

  0018e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170618
  00195	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0019d	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1776 :             longjmp(regs->progjmp,SIE_INTERCEPT_IOINST);

  001a2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001aa	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  001b0	ba ef ff ff ff	 mov	 edx, -17
  001b5	48 8b c8	 mov	 rcx, rax
  001b8	e8 00 00 00 00	 call	 longjmp
$LN5@test_subch:
$LN2@test_subch:

; 1777 :         }
; 1778 :     }
; 1779 : #endif
; 1780 : 
; 1781 :     /* Obtain the I/O interrupt queue lock */
; 1782 :     obtain_lock(&sysblk.iointqlk);

  001bd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001c4	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  001ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170619
  001d1	48 8b c8	 mov	 rcx, rax
  001d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1783 : 
; 1784 :     /* Perform core of TEST SUBCHANNEL work */
; 1785 :     cc = test_subchan_locked (regs, dev, irb, &ioint, &scsw);

  001da	48 8d 44 24 60	 lea	 rax, QWORD PTR scsw$[rsp]
  001df	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e4	4c 8d 4c 24 68	 lea	 r9, QWORD PTR ioint$[rsp]
  001e9	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR irb$[rsp]
  001f1	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  001f9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00201	e8 00 00 00 00	 call	 test_subchan_locked
  00206	89 44 24 50	 mov	 DWORD PTR cc$[rsp], eax

; 1786 : 
; 1787 :     /* Release the I/O interrupt queue lock */
; 1788 :     release_lock(&sysblk.iointqlk);

  0020a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00211	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  00217	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170620
  0021e	48 8b c8	 mov	 rcx, rax
  00221	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1789 : 
; 1790 :     /* Display the condition code */
; 1791 :     if (dev->ccwtrace)

  00227	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0022f	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00235	c1 e8 0f	 shr	 eax, 15
  00238	83 e0 01	 and	 eax, 1
  0023b	85 c0		 test	 eax, eax
  0023d	0f 84 d4 00 00
	00		 je	 $LN7@test_subch

; 1792 :     {
; 1793 :         if (sysblk.traceFILE)

  00243	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0024a	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00252	74 18		 je	 SHORT $LN8@test_subch

; 1794 :             tf_1318( dev, cc );

  00254	0f b6 54 24 50	 movzx	 edx, BYTE PTR cc$[rsp]
  00259	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00261	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1318
  00267	e9 ab 00 00 00	 jmp	 $LN9@test_subch
$LN8@test_subch:

; 1795 :         else
; 1796 :             // "%1d:%04X CHAN: test I/O: cc=%d"
; 1797 :             WRMSG( HHC01318, "I", LCSS_DEVNUM, cc );

  0026c	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00275	74 12		 je	 SHORT $LN11@test_subch
  00277	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0027f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00283	89 44 24 54	 mov	 DWORD PTR tv178[rsp], eax
  00287	eb 08		 jmp	 SHORT $LN12@test_subch
$LN11@test_subch:
  00289	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv178[rsp], 0
$LN12@test_subch:
  00291	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0029a	74 14		 je	 SHORT $LN13@test_subch
  0029c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002a4	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  002a8	d1 f8		 sar	 eax, 1
  002aa	89 44 24 58	 mov	 DWORD PTR tv184[rsp], eax
  002ae	eb 08		 jmp	 SHORT $LN14@test_subch
$LN13@test_subch:
  002b0	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv184[rsp], 0
$LN14@test_subch:
  002b8	b9 01 00 00 00	 mov	 ecx, 1
  002bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002c3	8b 4c 24 50	 mov	 ecx, DWORD PTR cc$[rsp]
  002c7	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  002cb	8b 4c 24 54	 mov	 ecx, DWORD PTR tv178[rsp]
  002cf	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002d3	8b 4c 24 58	 mov	 ecx, DWORD PTR tv184[rsp]
  002d7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170624
  002e2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170625
  002ee	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002f3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f8	41 b9 03 00 00
	00		 mov	 r9d, 3
  002fe	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170626
  00305	ba 05 07 00 00	 mov	 edx, 1797		; 00000705H
  0030a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170627
  00311	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@test_subch:
$LN7@test_subch:

; 1798 :     }
; 1799 : 
; 1800 :     /* Release remaining locks */
; 1801 :     release_lock(&dev->lock);

  00317	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0031f	48 83 c0 38	 add	 rax, 56			; 00000038H
  00323	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170628
  0032a	48 8b c8	 mov	 rcx, rax
  0032d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1802 :     RELEASE_INTLOCK(regs);

  00333	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170629
  0033a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00342	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1803 : 
; 1804 :     /* Return the condition code */
; 1805 :     return (cc);

  00347	8b 44 24 50	 mov	 eax, DWORD PTR cc$[rsp]
$LN10@test_subch:

; 1806 : 
; 1807 : } /* end function test_subchan */

  0034b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0034f	c3		 ret	 0
test_subchan ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
cc$ = 80
tv158 = 84
tv164 = 88
ioint$ = 96
scsw$ = 104
irb$ = 112
__$ArrayPad$ = 176
regs$ = 208
dev$ = 216
ibyte$ = 224
testio	PROC

; 1241 : {

$LN22:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@testio:

; 1242 :     int     cc;                         /* Condition code            */
; 1243 :     IRB     irb;                        /* Interrupt request block   */
; 1244 :     IOINT*  ioint;                      /* -> I/O interrupt          */
; 1245 :     SCSW*   scsw;                       /* -> SCSW                   */
; 1246 : 
; 1247 :     UNREFERENCED(ibyte);

  00028	33 c0		 xor	 eax, eax
  0002a	85 c0		 test	 eax, eax
  0002c	75 fa		 jne	 SHORT $LN4@testio

; 1248 : 
; 1249 :     OBTAIN_INTLOCK(regs);

  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170429
  00035	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003d	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 1250 :     obtain_lock(&dev->lock);

  00042	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0004a	48 83 c0 38	 add	 rax, 56			; 00000038H
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170430
  00055	48 8b c8	 mov	 rcx, rax
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1251 : 
; 1252 :     /* Test device status and set condition code */
; 1253 :     if ((dev->busy
; 1254 : #if defined( OPTION_SHARED_DEVICES )
; 1255 :         && dev->shioactive == DEV_SYS_LOCAL
; 1256 : #endif // defined( OPTION_SHARED_DEVICES )
; 1257 :     ) || dev->startpending)

  0005e	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00066	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0006c	c1 e8 13	 shr	 eax, 19
  0006f	83 e0 01	 and	 eax, 1
  00072	85 c0		 test	 eax, eax
  00074	74 14		 je	 SHORT $LN8@testio
  00076	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0007e	81 b8 e4 05 00
	00 ff ff 00 00	 cmp	 DWORD PTR [rax+1508], 65535 ; 0000ffffH
  00088	74 18		 je	 SHORT $LN7@testio
$LN8@testio:
  0008a	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00092	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00098	c1 e8 19	 shr	 eax, 25
  0009b	83 e0 01	 and	 eax, 1
  0009e	85 c0		 test	 eax, eax
  000a0	74 0d		 je	 SHORT $LN5@testio
$LN7@testio:

; 1258 :     {
; 1259 :         /* Set condition code 2 for device busy */
; 1260 :         cc = 2;

  000a2	c7 44 24 50 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2

; 1261 :     }

  000aa	e9 23 01 00 00	 jmp	 $LN6@testio
$LN5@testio:

; 1262 :     else if (IOPENDING(dev))

  000af	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b7	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000bd	c1 e8 16	 shr	 eax, 22
  000c0	83 e0 01	 and	 eax, 1
  000c3	85 c0		 test	 eax, eax
  000c5	75 4c		 jne	 SHORT $LN11@testio
  000c7	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000cf	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000d5	c1 e8 17	 shr	 eax, 23
  000d8	83 e0 01	 and	 eax, 1
  000db	85 c0		 test	 eax, eax
  000dd	75 34		 jne	 SHORT $LN11@testio
  000df	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000e7	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000ed	c1 e8 18	 shr	 eax, 24
  000f0	83 e0 01	 and	 eax, 1
  000f3	85 c0		 test	 eax, eax
  000f5	75 1c		 jne	 SHORT $LN11@testio
  000f7	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ff	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00105	c1 e8 1b	 shr	 eax, 27
  00108	83 e0 01	 and	 eax, 1
  0010b	85 c0		 test	 eax, eax
  0010d	0f 84 b7 00 00
	00		 je	 $LN9@testio
$LN11@testio:

; 1263 :     {
; 1264 :         /* Issue TEST SUBCHANNEL */
; 1265 :         cc = test_subchan_locked (regs, dev, &irb, &ioint, &scsw);

  00113	48 8d 44 24 68	 lea	 rax, QWORD PTR scsw$[rsp]
  00118	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011d	4c 8d 4c 24 60	 lea	 r9, QWORD PTR ioint$[rsp]
  00122	4c 8d 44 24 70	 lea	 r8, QWORD PTR irb$[rsp]
  00127	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0012f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00137	e8 00 00 00 00	 call	 test_subchan_locked
  0013c	89 44 24 50	 mov	 DWORD PTR cc$[rsp], eax

; 1266 : 
; 1267 :         if (cc)         /* Status incomplete */

  00140	83 7c 24 50 00	 cmp	 DWORD PTR cc$[rsp], 0
  00145	74 0a		 je	 SHORT $LN12@testio

; 1268 :             cc = 2;

  00147	c7 44 24 50 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2
  0014f	eb 77		 jmp	 SHORT $LN13@testio
$LN12@testio:

; 1269 :         else            /* Status pending */
; 1270 :         {
; 1271 :             cc = 1;     /* CSW stored */

  00151	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1

; 1272 : 
; 1273 :             /* Obtain I/O interrupt queue lock */
; 1274 :             obtain_lock(&sysblk.iointqlk);

  00159	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00160	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  00166	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170440
  0016d	48 8b c8	 mov	 rcx, rax
  00170	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1275 : 
; 1276 :             /* Dequeue the interrupt */
; 1277 :             DEQUEUE_IO_INTERRUPT_QLOCKED(ioint);

  00176	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170441
  0017d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ioint$[rsp]
  00182	e8 00 00 00 00	 call	 Dequeue_IO_Interrupt_QLocked

; 1278 : 
; 1279 :             /* Store the channel status word at PSA+X'40' */
; 1280 :             store_scsw_as_csw(regs, &irb.scsw);

  00187	48 8d 54 24 70	 lea	 rdx, QWORD PTR irb$[rsp]
  0018c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 store_scsw_as_csw

; 1281 : 
; 1282 :             /* Cleanup after SCSW */
; 1283 :             subchannel_interrupt_queue_cleanup(dev);

  00199	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001a1	e8 00 00 00 00	 call	 subchannel_interrupt_queue_cleanup

; 1284 :             UPDATE_IC_IOPENDING_QLOCKED();

  001a6	e8 00 00 00 00	 call	 Update_IC_IOPENDING_QLocked

; 1285 : 
; 1286 :             /* Release I/O interrupt queue lock */
; 1287 :             release_lock(&sysblk.iointqlk);

  001ab	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001b2	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  001b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170442
  001bf	48 8b c8	 mov	 rcx, rax
  001c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN13@testio:

; 1288 :         }
; 1289 :     }

  001c8	eb 08		 jmp	 SHORT $LN10@testio
$LN9@testio:

; 1290 :     else
; 1291 :         cc = 0;         /* Available */

  001ca	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0
$LN10@testio:
$LN6@testio:

; 1292 : 
; 1293 :     if (dev->ccwtrace)

  001d2	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001da	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001e0	c1 e8 0f	 shr	 eax, 15
  001e3	83 e0 01	 and	 eax, 1
  001e6	85 c0		 test	 eax, eax
  001e8	0f 84 d4 00 00
	00		 je	 $LN14@testio

; 1294 :     {
; 1295 :         if (sysblk.traceFILE)

  001ee	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001f5	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  001fd	74 18		 je	 SHORT $LN15@testio

; 1296 :             tf_1318( dev, cc );

  001ff	0f b6 54 24 50	 movzx	 edx, BYTE PTR cc$[rsp]
  00204	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0020c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1318
  00212	e9 ab 00 00 00	 jmp	 $LN16@testio
$LN15@testio:

; 1297 :         else
; 1298 :             // "%1d:%04X CHAN: test I/O: cc=%d"
; 1299 :             WRMSG( HHC01318, "I", LCSS_DEVNUM, cc );

  00217	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00220	74 12		 je	 SHORT $LN18@testio
  00222	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0022a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0022e	89 44 24 54	 mov	 DWORD PTR tv158[rsp], eax
  00232	eb 08		 jmp	 SHORT $LN19@testio
$LN18@testio:
  00234	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv158[rsp], 0
$LN19@testio:
  0023c	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00245	74 14		 je	 SHORT $LN20@testio
  00247	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0024f	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00253	d1 f8		 sar	 eax, 1
  00255	89 44 24 58	 mov	 DWORD PTR tv164[rsp], eax
  00259	eb 08		 jmp	 SHORT $LN21@testio
$LN20@testio:
  0025b	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv164[rsp], 0
$LN21@testio:
  00263	b9 01 00 00 00	 mov	 ecx, 1
  00268	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0026e	8b 4c 24 50	 mov	 ecx, DWORD PTR cc$[rsp]
  00272	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00276	8b 4c 24 54	 mov	 ecx, DWORD PTR tv158[rsp]
  0027a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0027e	8b 4c 24 58	 mov	 ecx, DWORD PTR tv164[rsp]
  00282	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00286	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170446
  0028d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00292	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170447
  00299	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0029e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002a3	41 b9 03 00 00
	00		 mov	 r9d, 3
  002a9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170448
  002b0	ba 13 05 00 00	 mov	 edx, 1299		; 00000513H
  002b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170449
  002bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN16@testio:
$LN14@testio:

; 1300 :     }
; 1301 : 
; 1302 :     /* Complete unlock sequence */
; 1303 :     release_lock(&dev->lock);

  002c2	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002ca	48 83 c0 38	 add	 rax, 56			; 00000038H
  002ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170450
  002d5	48 8b c8	 mov	 rcx, rax
  002d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1304 :     RELEASE_INTLOCK(regs);

  002de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170451
  002e5	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ed	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1305 : 
; 1306 :     /* Return the condition code */
; 1307 :     return (cc);

  002f2	8b 44 24 50	 mov	 eax, DWORD PTR cc$[rsp]

; 1308 : 
; 1309 : } /* end function testio */

  002f6	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002fe	48 33 cc	 xor	 rcx, rsp
  00301	e8 00 00 00 00	 call	 __security_check_cookie
  00306	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0030d	c3		 ret	 0
testio	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
devcount$ = 0
cc$ = 4
dev$ = 8
regs$ = 32
chan$ = 40
testch	PROC

; 1195 : {

$LN13:
  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 1196 : DEVBLK *dev;                            /* -> Device control block   */
; 1197 : int     devcount = 0;                   /* Number of devices found   */

  0000e	c7 04 24 00 00
	00 00		 mov	 DWORD PTR devcount$[rsp], 0

; 1198 : int     cc = 0;                         /* Returned condition code   */

  00015	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR cc$[rsp], 0

; 1199 : 
; 1200 :     /* Scan devices on the channel */
; 1201 :     for (dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00024	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  0002b	48 89 44 24 08	 mov	 QWORD PTR dev$[rsp], rax
  00030	eb 0e		 jmp	 SHORT $LN4@testch
$LN2@testch:
  00032	48 8b 44 24 08	 mov	 rax, QWORD PTR dev$[rsp]
  00037	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0003b	48 89 44 24 08	 mov	 QWORD PTR dev$[rsp], rax
$LN4@testch:
  00040	48 83 7c 24 08
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00046	0f 84 e8 00 00
	00		 je	 $LN3@testch

; 1202 :     {
; 1203 :         /* Skip "devices" that don't actually exist */
; 1204 :         if (!IS_DEV(dev))

  0004c	48 8b 44 24 08	 mov	 rax, QWORD PTR dev$[rsp]
  00051	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  00055	74 28		 je	 SHORT $LN6@testch
  00057	48 8b 44 24 08	 mov	 rax, QWORD PTR dev$[rsp]
  0005c	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00063	83 e0 01	 and	 eax, 1
  00066	85 c0		 test	 eax, eax
  00068	75 17		 jne	 SHORT $LN5@testch
  0006a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00071	48 8b 80 c8 11
	00 00		 mov	 rax, QWORD PTR [rax+4552]
  00078	48 39 44 24 08	 cmp	 QWORD PTR dev$[rsp], rax
  0007d	74 02		 je	 SHORT $LN5@testch
$LN6@testch:

; 1205 :             continue;

  0007f	eb b1		 jmp	 SHORT $LN2@testch
$LN5@testch:

; 1206 : 
; 1207 :         /* Skip the device if not on specified channel */
; 1208 :         if ((dev->devnum & 0xFF00) != chan
; 1209 :          || (dev->pmcw.flag5 & PMCW5_V) == 0
; 1210 : #if defined(FEATURE_CHANNEL_SWITCHING)
; 1211 :          || regs->chanset != dev->chanset

  00081	48 8b 44 24 08	 mov	 rax, QWORD PTR dev$[rsp]
  00086	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0008a	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  0008f	0f b7 4c 24 28	 movzx	 ecx, WORD PTR chan$[rsp]
  00094	3b c1		 cmp	 eax, ecx
  00096	75 2c		 jne	 SHORT $LN8@testch
  00098	48 8b 44 24 08	 mov	 rax, QWORD PTR dev$[rsp]
  0009d	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  000a4	83 e0 01	 and	 eax, 1
  000a7	85 c0		 test	 eax, eax
  000a9	74 19		 je	 SHORT $LN8@testch
  000ab	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  000b0	0f b7 80 38 08
	00 00		 movzx	 eax, WORD PTR [rax+2104]
  000b7	48 8b 4c 24 08	 mov	 rcx, QWORD PTR dev$[rsp]
  000bc	0f b7 49 4c	 movzx	 ecx, WORD PTR [rcx+76]
  000c0	3b c1		 cmp	 eax, ecx
  000c2	74 05		 je	 SHORT $LN7@testch
$LN8@testch:

; 1212 : #endif /*defined(FEATURE_CHANNEL_SWITCHING)*/
; 1213 :                                           )
; 1214 :             continue;

  000c4	e9 69 ff ff ff	 jmp	 $LN2@testch
$LN7@testch:

; 1215 : 
; 1216 :         /* Increment device count on this channel */
; 1217 :         devcount++;

  000c9	8b 04 24	 mov	 eax, DWORD PTR devcount$[rsp]
  000cc	ff c0		 inc	 eax
  000ce	89 04 24	 mov	 DWORD PTR devcount$[rsp], eax

; 1218 : 
; 1219 :         /* Test for pending interrupt */
; 1220 :         if (IOPENDING(dev))

  000d1	48 8b 44 24 08	 mov	 rax, QWORD PTR dev$[rsp]
  000d6	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000dc	c1 e8 16	 shr	 eax, 22
  000df	83 e0 01	 and	 eax, 1
  000e2	85 c0		 test	 eax, eax
  000e4	75 3f		 jne	 SHORT $LN10@testch
  000e6	48 8b 44 24 08	 mov	 rax, QWORD PTR dev$[rsp]
  000eb	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000f1	c1 e8 17	 shr	 eax, 23
  000f4	83 e0 01	 and	 eax, 1
  000f7	85 c0		 test	 eax, eax
  000f9	75 2a		 jne	 SHORT $LN10@testch
  000fb	48 8b 44 24 08	 mov	 rax, QWORD PTR dev$[rsp]
  00100	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00106	c1 e8 18	 shr	 eax, 24
  00109	83 e0 01	 and	 eax, 1
  0010c	85 c0		 test	 eax, eax
  0010e	75 15		 jne	 SHORT $LN10@testch
  00110	48 8b 44 24 08	 mov	 rax, QWORD PTR dev$[rsp]
  00115	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0011b	c1 e8 1b	 shr	 eax, 27
  0011e	83 e0 01	 and	 eax, 1
  00121	85 c0		 test	 eax, eax
  00123	74 0a		 je	 SHORT $LN9@testch
$LN10@testch:

; 1221 :         {
; 1222 :             cc = 1;

  00125	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1

; 1223 :             break;

  0012d	eb 05		 jmp	 SHORT $LN3@testch
$LN9@testch:

; 1224 :         }
; 1225 :     }

  0012f	e9 fe fe ff ff	 jmp	 $LN2@testch
$LN3@testch:

; 1226 : 
; 1227 :     /* Set condition code 3 if no devices found on the channel */
; 1228 :     if (devcount == 0)

  00134	83 3c 24 00	 cmp	 DWORD PTR devcount$[rsp], 0
  00138	75 08		 jne	 SHORT $LN11@testch

; 1229 :         cc = 3;

  0013a	c7 44 24 04 03
	00 00 00	 mov	 DWORD PTR cc$[rsp], 3
$LN11@testch:

; 1230 : 
; 1231 :     return cc;

  00142	8b 44 24 04	 mov	 eax, DWORD PTR cc$[rsp]

; 1232 : 
; 1233 : } /* end function testch */

  00146	48 83 c4 18	 add	 rsp, 24
  0014a	c3		 ret	 0
testch	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
chanid$ = 32
devcount$ = 36
tv129 = 40
dev$ = 48
psa$ = 56
regs$ = 80
chan$ = 88
stchan_id PROC

; 1122 : {

$LN18:
  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1123 : U32     chanid;                         /* Channel identifier word   */
; 1124 : int     devcount = 0;                   /* #of devices on channel    */

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR devcount$[rsp], 0

; 1125 : DEVBLK *dev;                            /* -> Device control block   */
; 1126 : PSA_3XX *psa;                           /* -> Prefixed storage area  */
; 1127 : 
; 1128 :     /* Find a device on specified channel */
; 1129 :     for (dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001d	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  00024	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax
  00029	eb 0e		 jmp	 SHORT $LN4@stchan_id
$LN2@stchan_id:
  0002b	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00030	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00034	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax
$LN4@stchan_id:
  00039	48 83 7c 24 30
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0003f	0f 84 8e 00 00
	00		 je	 $LN3@stchan_id

; 1130 :     {
; 1131 :         /* Skip "devices" that don't actually exist */
; 1132 :         if (!IS_DEV(dev))

  00045	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0004a	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  0004e	74 28		 je	 SHORT $LN8@stchan_id
  00050	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00055	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0005c	83 e0 01	 and	 eax, 1
  0005f	85 c0		 test	 eax, eax
  00061	75 17		 jne	 SHORT $LN7@stchan_id
  00063	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006a	48 8b 80 c8 11
	00 00		 mov	 rax, QWORD PTR [rax+4552]
  00071	48 39 44 24 30	 cmp	 QWORD PTR dev$[rsp], rax
  00076	74 02		 je	 SHORT $LN7@stchan_id
$LN8@stchan_id:

; 1133 :             continue;

  00078	eb b1		 jmp	 SHORT $LN2@stchan_id
$LN7@stchan_id:

; 1134 : 
; 1135 :         /* Skip the device if not on specified channel */
; 1136 :         if ((dev->devnum & 0xFF00) != chan
; 1137 :          || (dev->pmcw.flag5 & PMCW5_V) == 0
; 1138 : #if defined(FEATURE_CHANNEL_SWITCHING)
; 1139 :          || regs->chanset != dev->chanset

  0007a	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0007f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00083	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00088	0f b7 4c 24 58	 movzx	 ecx, WORD PTR chan$[rsp]
  0008d	3b c1		 cmp	 eax, ecx
  0008f	75 2c		 jne	 SHORT $LN10@stchan_id
  00091	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00096	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0009d	83 e0 01	 and	 eax, 1
  000a0	85 c0		 test	 eax, eax
  000a2	74 19		 je	 SHORT $LN10@stchan_id
  000a4	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000a9	0f b7 80 38 08
	00 00		 movzx	 eax, WORD PTR [rax+2104]
  000b0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  000b5	0f b7 49 4c	 movzx	 ecx, WORD PTR [rcx+76]
  000b9	3b c1		 cmp	 eax, ecx
  000bb	74 05		 je	 SHORT $LN9@stchan_id
$LN10@stchan_id:

; 1140 : #endif /*defined(FEATURE_CHANNEL_SWITCHING)*/
; 1141 :                                             )
; 1142 :             continue;

  000bd	e9 69 ff ff ff	 jmp	 $LN2@stchan_id
$LN9@stchan_id:

; 1143 : 
; 1144 :         /* Found device on the channel */
; 1145 :         devcount++;

  000c2	8b 44 24 24	 mov	 eax, DWORD PTR devcount$[rsp]
  000c6	ff c0		 inc	 eax
  000c8	89 44 24 24	 mov	 DWORD PTR devcount$[rsp], eax

; 1146 :         break;

  000cc	eb 05		 jmp	 SHORT $LN3@stchan_id

; 1147 :     } /* end for(dev) */

  000ce	e9 58 ff ff ff	 jmp	 $LN2@stchan_id
$LN3@stchan_id:

; 1148 : 
; 1149 :     /* Exit with condition code 3 if no devices on channel */
; 1150 :     if (devcount == 0)

  000d3	83 7c 24 24 00	 cmp	 DWORD PTR devcount$[rsp], 0
  000d8	75 0a		 jne	 SHORT $LN11@stchan_id

; 1151 :         return 3;

  000da	b8 03 00 00 00	 mov	 eax, 3
  000df	e9 90 00 00 00	 jmp	 $LN1@stchan_id
$LN11@stchan_id:

; 1152 : 
; 1153 :     /* Construct the channel id word
; 1154 :      *
; 1155 :      * According to GA22-7000-4, Page 192, 2nd paragraph, channel 0 is a
; 1156 :      * Byte Multiplexor.. Return STIDC data accordingly.
; 1157 :      * ISW 20080313
; 1158 :      */
; 1159 :     if(!chan)

  000e4	0f b7 44 24 58	 movzx	 eax, WORD PTR chan$[rsp]
  000e9	85 c0		 test	 eax, eax
  000eb	75 0a		 jne	 SHORT $LN12@stchan_id

; 1160 :     {
; 1161 :         chanid = CHANNEL_MPX;

  000ed	c7 44 24 20 00
	00 00 10	 mov	 DWORD PTR chanid$[rsp], 268435456 ; 10000000H

; 1162 :     }

  000f5	eb 46		 jmp	 SHORT $LN13@stchan_id
$LN12@stchan_id:

; 1163 :     else
; 1164 :     {
; 1165 :         /* Translate channel type back to S/370 terms */
; 1166 :         switch (dev->chptype[0])

  000f7	b8 01 00 00 00	 mov	 eax, 1
  000fc	48 6b c0 00	 imul	 rax, rax, 0
  00100	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00105	0f b6 84 01 cc
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1484]
  0010d	88 44 24 28	 mov	 BYTE PTR tv129[rsp], al
  00111	80 7c 24 28 00	 cmp	 BYTE PTR tv129[rsp], 0
  00116	74 09		 je	 SHORT $LN14@stchan_id
  00118	80 7c 24 28 02	 cmp	 BYTE PTR tv129[rsp], 2
  0011d	74 0c		 je	 SHORT $LN15@stchan_id
  0011f	eb 14		 jmp	 SHORT $LN16@stchan_id
$LN14@stchan_id:

; 1167 :         {
; 1168 :             case CHP_TYPE_UNDEF:
; 1169 :                 chanid = CHANNEL_SEL;

  00121	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR chanid$[rsp], 0

; 1170 :                 break;

  00129	eb 12		 jmp	 SHORT $LN5@stchan_id
$LN15@stchan_id:

; 1171 :             case CHP_TYPE_BYTE:
; 1172 :                 chanid = CHANNEL_MPX;

  0012b	c7 44 24 20 00
	00 00 10	 mov	 DWORD PTR chanid$[rsp], 268435456 ; 10000000H

; 1173 :                 break;

  00133	eb 08		 jmp	 SHORT $LN5@stchan_id
$LN16@stchan_id:

; 1174 :             default:
; 1175 :                 chanid = CHANNEL_BMX;

  00135	c7 44 24 20 00
	00 00 20	 mov	 DWORD PTR chanid$[rsp], 536870912 ; 20000000H
$LN5@stchan_id:
$LN13@stchan_id:

; 1176 :                 break;
; 1177 :         }
; 1178 :     }
; 1179 : 
; 1180 :     /* Store the channel id word at PSA+X'A8' */
; 1181 :     psa = (PSA_3XX*)(regs->mainstor + regs->PX);

  0013d	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00142	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00145	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0014a	48 03 81 48 08
	00 00		 add	 rax, QWORD PTR [rcx+2120]
  00151	48 89 44 24 38	 mov	 QWORD PTR psa$[rsp], rax

; 1182 :     STORE_FW(psa->chanid, chanid);

  00156	8b 4c 24 20	 mov	 ecx, DWORD PTR chanid$[rsp]
  0015a	e8 00 00 00 00	 call	 _byteswap_ulong
  0015f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR psa$[rsp]
  00164	48 81 c1 a8 00
	00 00		 add	 rcx, 168		; 000000a8H
  0016b	8b d0		 mov	 edx, eax
  0016d	e8 00 00 00 00	 call	 store_fw_noswap

; 1183 : 
; 1184 :     /* Exit with condition code 0 indicating channel id stored */
; 1185 :     return 0;

  00172	33 c0		 xor	 eax, eax
$LN1@stchan_id:

; 1186 : 
; 1187 : } /* end function stchan_id */

  00174	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00178	c3		 ret	 0
stchan_id ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
dev$ = 0
flags$ = 8
chanstat$ = 9
opcode$ = 10
ccwfmt$ = 11
unitstat$ = 12
ps$ = 16
ccwkey$ = 20
tracethis$ = 21
idawfmt$ = 22
count$ = 24
addr$ = 28
chain$ = 32
ccwaddr$ = 36
ts$ = 40
ioerror$ = 44
firstccw$ = 45
residual$ = 48
sense$1 = 56
more$ = 64
idapmask$ = 68
ostailor_quiet$2 = 72
skip_ch9uc$3 = 73
cpu_tracing$4 = 74
mbaddr$ = 76
ticback$ = 80
ccw_tracing$5 = 84
iobuf$ = 88
bufpos$ = 96
skip_ccws$ = 100
prevccwaddr$ = 104
tracing_active$6 = 108
mbcount$ = 112
halt$7 = 116
ticaddr$ = 120
prefetch_remaining$ = 124
ccw$ = 128
cmdretry$ = 136
tv283 = 140
tv295 = 144
tv303 = 148
tv437 = 152
tv439 = 156
tv511 = 160
tv517 = 164
tv570 = 168
tv576 = 172
tv932 = 176
tv944 = 180
tv950 = 184
tv1224 = 188
tv1230 = 192
tv1318 = 196
tv1324 = 200
newsize$8 = 204
tv1473 = 208
tv1685 = 212
tv1693 = 216
tv1718 = 220
tv1722 = 224
tv1766 = 228
tv1813 = 232
tv1936 = 236
tv1949 = 240
tv1955 = 244
tv2108 = 248
tv2114 = 252
tv2326 = 256
tv2355 = 260
tv182 = 264
tv188 = 268
tv205 = 272
tv211 = 276
tv1987 = 280
tv1995 = 284
tv1999 = 288
tv2003 = 292
tv2015 = 296
tv2027 = 300
tv2031 = 304
tv2035 = 308
tv2039 = 312
tv2043 = 316
tv2047 = 320
tv2051 = 324
tv2055 = 328
tv2059 = 332
tv2063 = 336
tv2067 = 340
tv2071 = 344
tv2075 = 348
tv2079 = 352
tv2083 = 356
tv2087 = 360
tv2091 = 364
tv2095 = 368
tv2099 = 372
tv1942 = 376
tv1944 = 380
tv1979 = 384
tv1983 = 388
mbk$ = 392
iobufnew$9 = 400
$T10 = 408
tv2380 = 416
prefetch$ = 448
iobuf_initial$ = 8192
area$ = 77824
__$ArrayPad$ = 77888
arg$ = 82416
z900_execute_ccw_chain PROC

; 4380 : {

$LN328:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	53		 push	 rbx
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	41 57		 push	 r15
  00011	b8 a8 41 01 00	 mov	 eax, 82344		; 000141a8H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	48 2b e0	 sub	 rsp, rax
  0001e	48 8d ac 24 50
	11 00 00	 lea	 rbp, QWORD PTR [rsp+4432]
  00026	48 81 e5 00 f0
	ff ff		 and	 rbp, -4096		; fffffffffffff000H
  0002d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00034	48 33 c4	 xor	 rax, rsp
  00037	48 89 85 40 30
	01 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax

; 4381 : DEVBLK *dev = (DEVBLK*) arg;            /* Device Block pointer      */

  0003e	48 8b 84 24 f0
	41 01 00	 mov	 rax, QWORD PTR arg$[rsp]
  00046	48 89 45 00	 mov	 QWORD PTR dev$[rbp], rax

; 4382 : IOBUF  *iobuf;                          /* Pointer to I/O buffer     */
; 4383 : U32     ccwaddr = 0;                    /* Address of CCW            */

  0004a	c7 45 24 00 00
	00 00		 mov	 DWORD PTR ccwaddr$[rbp], 0

; 4384 : U32     ticaddr = 0;                    /* Previous CCW was a TIC    */

  00051	c7 45 78 00 00
	00 00		 mov	 DWORD PTR ticaddr$[rbp], 0

; 4385 : U16     ticback = 0;                    /* Backwards TIC counter     */

  00058	33 c0		 xor	 eax, eax
  0005a	66 89 45 50	 mov	 WORD PTR ticback$[rbp], ax

; 4386 : U16     idapmask = 0;                   /* IDA page size - 1         */

  0005e	33 c0		 xor	 eax, eax
  00060	66 89 45 44	 mov	 WORD PTR idapmask$[rbp], ax

; 4387 : BYTE    idawfmt = 0;                    /* IDAW format (1 or 2)      */

  00064	c6 45 16 00	 mov	 BYTE PTR idawfmt$[rbp], 0

; 4388 : BYTE    ccwfmt = 0;                     /* CCW format (0 or 1)       */

  00068	c6 45 0b 00	 mov	 BYTE PTR ccwfmt$[rbp], 0

; 4389 : BYTE    ccwkey = 0;                     /* Bits 0-3=key, 4-7=zero    */

  0006c	c6 45 14 00	 mov	 BYTE PTR ccwkey$[rbp], 0

; 4390 : BYTE    opcode;                         /* CCW operation code        */
; 4391 : BYTE    flags;                          /* CCW flags                 */
; 4392 : U32     addr;                           /* CCW data address          */
; 4393 : #ifdef FEATURE_CHANNEL_SUBSYSTEM
; 4394 : U32     mbaddr;                         /* Measure block address     */
; 4395 : MBK    *mbk;                            /* Measure block             */
; 4396 : U16     mbcount;                        /* Measure block count       */
; 4397 : #endif /*FEATURE_CHANNEL_SUBSYSTEM*/
; 4398 : U32     count;                          /* CCW byte count            */
; 4399 : BYTE   *ccw;                            /* CCW pointer               */
; 4400 : BYTE    unitstat;                       /* Unit status               */
; 4401 : BYTE    chanstat;                       /* Channel status            */
; 4402 : U32     residual = 0;                   /* Residual byte count       */

  00070	c7 45 30 00 00
	00 00		 mov	 DWORD PTR residual$[rbp], 0

; 4403 : BYTE    more;                           /* 1=Count exhausted         */
; 4404 : BYTE    chain = 1;                      /* 1=Chain to next CCW       */

  00077	c6 45 20 01	 mov	 BYTE PTR chain$[rbp], 1

; 4405 : BYTE    tracethis = 0;                  /* 1=Trace this CCW chain    */

  0007b	c6 45 15 00	 mov	 BYTE PTR tracethis$[rbp], 0

; 4406 : BYTE    ioerror = 0;                    /* 1=CCW I/O error           */

  0007f	c6 45 2c 00	 mov	 BYTE PTR ioerror$[rbp], 0

; 4407 : BYTE    firstccw = 1;                   /* 1=First CCW               */

  00083	c6 45 2d 01	 mov	 BYTE PTR firstccw$[rbp], 1

; 4408 : BYTE    area[64];                       /* Message area              */
; 4409 : u_int   bufpos = 0;                     /* Position in I/O buffer    */

  00087	c7 45 60 00 00
	00 00		 mov	 DWORD PTR bufpos$[rbp], 0

; 4410 : u_int   skip_ccws = 0;                  /* Skip ccws                 */

  0008e	c7 45 64 00 00
	00 00		 mov	 DWORD PTR skip_ccws$[rbp], 0

; 4411 : int     cmdretry = 255;                 /* Limit command retry       */

  00095	c7 85 88 00 00
	00 ff 00 00 00	 mov	 DWORD PTR cmdretry$[rbp], 255 ; 000000ffH

; 4412 : U32     prevccwaddr = 1;                /* Previous CCW address      */

  0009f	c7 45 68 01 00
	00 00		 mov	 DWORD PTR prevccwaddr$[rbp], 1

; 4413 : U32     prefetch_remaining;             /* Prefetch bytes remaining  */
; 4414 : 
; 4415 : u_int       ps = 0;                     /* Local prefetch sequence   */

  000a6	c7 45 10 00 00
	00 00		 mov	 DWORD PTR ps$[rbp], 0

; 4416 : u_int       ts;                         /* Test prefetch sequence    */
; 4417 : 
; 4418 : CACHE_ALIGN
; 4419 : PREFETCH    prefetch;                   /* Prefetch buffer           */
; 4420 : 
; 4421 : __ALIGN( IOBUF_ALIGN )
; 4422 : IOBUF iobuf_initial;                    /* Channel I/O buffer        */
; 4423 : 
; 4424 :     /* Initialize prefetch */
; 4425 :     memset(&prefetch, 0, sizeof(prefetch));

  000ad	48 8d 85 c0 01
	00 00		 lea	 rax, QWORD PTR prefetch$[rbp]
  000b4	48 8b f8	 mov	 rdi, rax
  000b7	33 c0		 xor	 eax, eax
  000b9	b9 10 1a 00 00	 mov	 ecx, 6672		; 00001a10H
  000be	f3 aa		 rep stosb

; 4426 : 
; 4427 :     /* Point to initial I/O buffer and initialize */
; 4428 :     iobuf = &iobuf_initial;

  000c0	48 8d 85 00 20
	00 00		 lea	 rax, QWORD PTR iobuf_initial$[rbp]
  000c7	48 89 45 58	 mov	 QWORD PTR iobuf$[rbp], rax

; 4429 :     iobuf_initialize(iobuf, sizeof(iobuf_initial.data));

  000cb	ba 00 00 01 00	 mov	 edx, 65536		; 00010000H
  000d0	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  000d4	e8 00 00 00 00	 call	 iobuf_initialize

; 4430 : 
; 4431 :     obtain_lock (&dev->lock);

  000d9	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  000dd	48 83 c0 38	 add	 rax, 56			; 00000038H
  000e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196539
  000e8	48 8b c8	 mov	 rcx, rax
  000eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4432 : 
; 4433 : #if defined( OPTION_SHARED_DEVICES )
; 4434 :     /* Wait for the device to become available */
; 4435 :     if (dev->shareable)

  000f1	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  000f5	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000fb	c1 e8 03	 shr	 eax, 3
  000fe	83 e0 01	 and	 eax, 1
  00101	85 c0		 test	 eax, eax
  00103	74 09		 je	 SHORT $LN22@z900_execu

; 4436 :     {
; 4437 :         shared_iowait( dev );

  00105	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00109	e8 00 00 00 00	 call	 shared_iowait
$LN22@z900_execu:

; 4438 :     }
; 4439 :     dev->shioactive = DEV_SYS_LOCAL;

  0010e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00112	c7 80 e4 05 00
	00 ff ff 00 00	 mov	 DWORD PTR [rax+1508], 65535 ; 0000ffffH

; 4440 : #endif // defined( OPTION_SHARED_DEVICES )
; 4441 : 
; 4442 :     set_subchannel_busy(dev);

  0011c	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00120	e8 00 00 00 00	 call	 set_subchannel_busy

; 4443 :     dev->startpending = 0;

  00125	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00129	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0012f	0f ba f0 19	 btr	 eax, 25
  00133	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00137	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4444 : 
; 4445 :     /* Increment excp count */
; 4446 :     dev->excps++;

  0013d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00141	48 8b 80 00 06
	00 00		 mov	 rax, QWORD PTR [rax+1536]
  00148	48 ff c0	 inc	 rax
  0014b	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0014f	48 89 81 00 06
	00 00		 mov	 QWORD PTR [rcx+1536], rax

; 4447 : 
; 4448 :     /* Indicate that we're started */
; 4449 :     dev->scsw.flag2 |= SCSW2_FC_START;

  00156	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0015a	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00161	83 c8 40	 or	 eax, 64			; 00000040H
  00164	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00168	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 4450 :     dev->scsw.flag2 &= ~SCSW2_AC_START;

  0016e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00172	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00179	83 e0 fb	 and	 eax, -5
  0017c	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00180	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 4451 : 
; 4452 :     /* Handle early clear or halt */
; 4453 :     if (dev->scsw.flag2 & (SCSW2_AC_CLEAR | SCSW2_AC_HALT))

  00186	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0018a	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00191	83 e0 03	 and	 eax, 3
  00194	85 c0		 test	 eax, eax
  00196	74 34		 je	 SHORT $LN23@z900_execu

; 4454 :     {
; 4455 :         release_lock(&dev->lock);

  00198	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0019c	48 83 c0 38	 add	 rax, 56			; 00000038H
  001a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196542
  001a7	48 8b c8	 mov	 rcx, rax
  001aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4456 :         if (dev->scsw.flag2 & SCSW2_AC_CLEAR)

  001b0	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  001b4	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  001bb	83 e0 01	 and	 eax, 1
  001be	85 c0		 test	 eax, eax
  001c0	74 05		 je	 SHORT $LN24@z900_execu

; 4457 :             goto execute_clear;

  001c2	e9 53 08 00 00	 jmp	 $execute_clear$329
$LN24@z900_execu:

; 4458 :         goto execute_halt;

  001c7	e9 38 09 00 00	 jmp	 $execute_halt$330
$LN23@z900_execu:

; 4459 :     }
; 4460 : 
; 4461 :     /* For hercules `resume' resume suspended state */
; 4462 :     if (dev->resumesuspended || dev->suspended ||

  001cc	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  001d0	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001d6	c1 e8 1a	 shr	 eax, 26
  001d9	83 e0 01	 and	 eax, 1
  001dc	85 c0		 test	 eax, eax
  001de	75 2a		 jne	 SHORT $LN26@z900_execu
  001e0	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  001e4	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001ea	c1 e8 15	 shr	 eax, 21
  001ed	83 e0 01	 and	 eax, 1
  001f0	85 c0		 test	 eax, eax
  001f2	75 16		 jne	 SHORT $LN26@z900_execu
  001f4	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  001f8	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  001ff	83 e0 08	 and	 eax, 8
  00202	85 c0		 test	 eax, eax
  00204	0f 84 08 03 00
	00		 je	 $LN25@z900_execu
$LN26@z900_execu:

; 4463 :         (dev->scsw.flag2 & SCSW2_AC_RESUM))
; 4464 :     {
; 4465 :         /* Restore CCW execution variables */
; 4466 :         ccwaddr = dev->ccwaddr;

  0020a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0020e	8b 80 80 02 00
	00		 mov	 eax, DWORD PTR [rax+640]
  00214	89 45 24	 mov	 DWORD PTR ccwaddr$[rbp], eax

; 4467 :         idapmask = dev->idapmask;

  00217	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0021b	0f b7 80 84 02
	00 00		 movzx	 eax, WORD PTR [rax+644]
  00222	66 89 45 44	 mov	 WORD PTR idapmask$[rbp], ax

; 4468 :         idawfmt = dev->idawfmt;

  00226	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0022a	0f b6 80 86 02
	00 00		 movzx	 eax, BYTE PTR [rax+646]
  00231	88 45 16	 mov	 BYTE PTR idawfmt$[rbp], al

; 4469 :         ccwfmt = dev->ccwfmt;

  00234	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00238	0f b6 80 87 02
	00 00		 movzx	 eax, BYTE PTR [rax+647]
  0023f	88 45 0b	 mov	 BYTE PTR ccwfmt$[rbp], al

; 4470 :         ccwkey = dev->ccwkey;

  00242	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00246	0f b6 80 88 02
	00 00		 movzx	 eax, BYTE PTR [rax+648]
  0024d	88 45 14	 mov	 BYTE PTR ccwkey$[rbp], al

; 4471 : 
; 4472 : 
; 4473 :         /* Turn the `suspended' bits off */
; 4474 :         dev->suspended =

  00250	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00254	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0025a	0f ba f0 1a	 btr	 eax, 26
  0025e	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00262	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
  00268	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0026c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00272	0f ba f0 15	 btr	 eax, 21
  00276	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0027a	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4475 :         dev->resumesuspended=0;
; 4476 : 
; 4477 : #if defined( OPTION_SHARED_DEVICES )
; 4478 :         /* Wait for the device to become available */
; 4479 :         shared_iowait( dev );

  00280	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00284	e8 00 00 00 00	 call	 shared_iowait

; 4480 :         dev->shioactive = DEV_SYS_LOCAL;

  00289	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0028d	c7 80 e4 05 00
	00 ff ff 00 00	 mov	 DWORD PTR [rax+1508], 65535 ; 0000ffffH

; 4481 : #endif // defined( OPTION_SHARED_DEVICES )
; 4482 : 
; 4483 :         set_device_busy(dev);

  00297	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0029b	e8 00 00 00 00	 call	 set_device_busy

; 4484 : 
; 4485 :         if (CCW_TRACING_ACTIVE( dev, tracethis ))

  002a0	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  002a4	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  002aa	c1 e8 0f	 shr	 eax, 15
  002ad	83 e0 01	 and	 eax, 1
  002b0	85 c0		 test	 eax, eax
  002b2	75 0c		 jne	 SHORT $LN28@z900_execu
  002b4	0f b6 45 15	 movzx	 eax, BYTE PTR tracethis$[rbp]
  002b8	85 c0		 test	 eax, eax
  002ba	0f 84 9a 01 00
	00		 je	 $LN27@z900_execu
$LN28@z900_execu:

; 4486 :         {
; 4487 :             if (dev->s370start)

  002c0	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  002c4	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  002ca	d1 e8		 shr	 eax, 1
  002cc	83 e0 01	 and	 eax, 1
  002cf	85 c0		 test	 eax, eax
  002d1	0f 84 c4 00 00
	00		 je	 $LN29@z900_execu

; 4488 :             {
; 4489 :                 if (sysblk.traceFILE)

  002d7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002de	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  002e6	74 0f		 je	 SHORT $LN31@z900_execu

; 4490 :                     tf_1321( dev );

  002e8	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  002ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1321
  002f2	e9 9f 00 00 00	 jmp	 $LN32@z900_execu
$LN31@z900_execu:

; 4491 :                 else
; 4492 :                     /* State successful conversion from synchronous
; 4493 :                      * to asynchronous for 370 mode.
; 4494 :                      */
; 4495 :                     // "%1d:%04X CHAN: start I/O S/370 conversion to asynchronous operation successful"
; 4496 :                     WRMSG( HHC01321, "I", LCSS_DEVNUM );

  002f7	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  002fc	74 10		 je	 SHORT $LN238@z900_execu
  002fe	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00302	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00306	89 85 08 01 00
	00		 mov	 DWORD PTR tv182[rbp], eax
  0030c	eb 0a		 jmp	 SHORT $LN239@z900_execu
$LN238@z900_execu:
  0030e	c7 85 08 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv182[rbp], 0
$LN239@z900_execu:
  00318	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  0031d	74 12		 je	 SHORT $LN240@z900_execu
  0031f	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00323	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00327	d1 f8		 sar	 eax, 1
  00329	89 85 0c 01 00
	00		 mov	 DWORD PTR tv188[rbp], eax
  0032f	eb 0a		 jmp	 SHORT $LN241@z900_execu
$LN240@z900_execu:
  00331	c7 85 0c 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv188[rbp], 0
$LN241@z900_execu:
  0033b	b9 01 00 00 00	 mov	 ecx, 1
  00340	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00346	8b 8d 08 01 00
	00		 mov	 ecx, DWORD PTR tv182[rbp]
  0034c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00350	8b 8d 0c 01 00
	00		 mov	 ecx, DWORD PTR tv188[rbp]
  00356	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0035a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196552
  00361	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00366	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196553
  0036d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00372	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00377	41 b9 03 00 00
	00		 mov	 r9d, 3
  0037d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196554
  00384	ba 90 11 00 00	 mov	 edx, 4496		; 00001190H
  00389	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196555
  00390	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN32@z900_execu:

; 4497 :             }

  00396	e9 bf 00 00 00	 jmp	 $LN30@z900_execu
$LN29@z900_execu:

; 4498 :             else
; 4499 :             {
; 4500 :                 if (sysblk.traceFILE)

  0039b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003a2	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  003aa	74 0f		 je	 SHORT $LN33@z900_execu

; 4501 :                     tf_1311( dev );

  003ac	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  003b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1311
  003b6	e9 9f 00 00 00	 jmp	 $LN34@z900_execu
$LN33@z900_execu:

; 4502 :                 else
; 4503 :                     /* Trace I/O resumption */
; 4504 :                     // "%1d:%04X CHAN: resumed"
; 4505 :                     WRMSG (HHC01311, "I", LCSS_DEVNUM );

  003bb	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  003c0	74 10		 je	 SHORT $LN242@z900_execu
  003c2	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  003c6	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003ca	89 85 10 01 00
	00		 mov	 DWORD PTR tv205[rbp], eax
  003d0	eb 0a		 jmp	 SHORT $LN243@z900_execu
$LN242@z900_execu:
  003d2	c7 85 10 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv205[rbp], 0
$LN243@z900_execu:
  003dc	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  003e1	74 12		 je	 SHORT $LN244@z900_execu
  003e3	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  003e7	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  003eb	d1 f8		 sar	 eax, 1
  003ed	89 85 14 01 00
	00		 mov	 DWORD PTR tv211[rbp], eax
  003f3	eb 0a		 jmp	 SHORT $LN245@z900_execu
$LN244@z900_execu:
  003f5	c7 85 14 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv211[rbp], 0
$LN245@z900_execu:
  003ff	b9 01 00 00 00	 mov	 ecx, 1
  00404	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0040a	8b 8d 10 01 00
	00		 mov	 ecx, DWORD PTR tv205[rbp]
  00410	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00414	8b 8d 14 01 00
	00		 mov	 ecx, DWORD PTR tv211[rbp]
  0041a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0041e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196558
  00425	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0042a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196559
  00431	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00436	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0043b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00441	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196560
  00448	ba 99 11 00 00	 mov	 edx, 4505		; 00001199H
  0044d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196561
  00454	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN34@z900_execu:
$LN30@z900_execu:
$LN27@z900_execu:

; 4506 :             }
; 4507 :         }
; 4508 : 
; 4509 :         /* Reset the suspended status in the SCSW */
; 4510 :         dev->scsw.flag2 &= ~SCSW2_AC_RESUM;

  0045a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0045e	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00465	83 e0 f7	 and	 eax, -9
  00468	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0046c	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 4511 :         dev->scsw.flag3 &= ~(SCSW3_AC_SUSP  |

  00472	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00476	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  0047d	83 e0 c6	 and	 eax, -58		; ffffffffffffffc6H
  00480	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00484	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 4512 :                              SCSW3_SC_ALERT |
; 4513 :                              SCSW3_SC_INTER |
; 4514 :                              SCSW3_SC_PEND);
; 4515 :         dev->scsw.flag3 |= (SCSW3_AC_SCHAC | SCSW3_AC_DEVAC);

  0048a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0048e	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00495	0d c0 00 00 00	 or	 eax, 192		; 000000c0H
  0049a	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0049e	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 4516 : 
; 4517 :         /* Call the i/o resume exit if not clearing */
; 4518 :         if (!(dev->scsw.flag2 & SCSW2_AC_CLEAR))

  004a4	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  004a8	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  004af	83 e0 01	 and	 eax, 1
  004b2	85 c0		 test	 eax, eax
  004b4	75 40		 jne	 SHORT $LN35@z900_execu

; 4519 :         {
; 4520 :             /* Don't execute resume exit if S/370 channel start */
; 4521 :             if (!dev->s370start &&

  004b6	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  004ba	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  004c0	d1 e8		 shr	 eax, 1
  004c2	83 e0 01	 and	 eax, 1
  004c5	85 c0		 test	 eax, eax
  004c7	75 24		 jne	 SHORT $LN36@z900_execu
  004c9	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  004cd	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  004d4	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  004d9	74 12		 je	 SHORT $LN36@z900_execu

; 4522 :                 dev->hnd->resume)
; 4523 :                 (dev->hnd->resume) (dev);

  004db	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  004df	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  004e6	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  004ea	ff 50 38	 call	 QWORD PTR [rax+56]
$LN36@z900_execu:

; 4524 : 
; 4525 :             /* Refetch the suspended CCW */
; 4526 :             ccwaddr -= 8;

  004ed	8b 45 24	 mov	 eax, DWORD PTR ccwaddr$[rbp]
  004f0	83 e8 08	 sub	 eax, 8
  004f3	89 45 24	 mov	 DWORD PTR ccwaddr$[rbp], eax
$LN35@z900_execu:

; 4527 :         }
; 4528 : 
; 4529 :         /* Reset S/370 channel SIO resume indicator */
; 4530 :         dev->s370start = 0;

  004f6	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  004fa	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00500	83 e0 fd	 and	 eax, -3			; fffffffdH
  00503	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00507	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4531 : 
; 4532 :         goto resume_suspend;

  0050d	e9 80 01 00 00	 jmp	 $resume_suspend$331
$LN25@z900_execu:

; 4533 :     }
; 4534 : 
; 4535 :     /* Hercules deviation; always zero the SCSW CCW address to start */
; 4536 :     store_fw(dev->scsw.ccwaddr, 0);

  00512	33 c9		 xor	 ecx, ecx
  00514	e8 00 00 00 00	 call	 _byteswap_ulong
  00519	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0051d	48 81 c1 0c 03
	00 00		 add	 rcx, 780		; 0000030cH
  00524	8b d0		 mov	 edx, eax
  00526	e8 00 00 00 00	 call	 store_fw_noswap

; 4537 : 
; 4538 :     /* Call the i/o start exit */
; 4539 :     if (dev->hnd->start)

  0052b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0052f	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00536	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0053b	74 42		 je	 SHORT $LN37@z900_execu

; 4540 :     {
; 4541 :         release_lock (&dev->lock);

  0053d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00541	48 83 c0 38	 add	 rax, 56			; 00000038H
  00545	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196565
  0054c	48 8b c8	 mov	 rcx, rax
  0054f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4542 :         (dev->hnd->start) (dev);

  00555	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00559	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00560	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00564	ff 50 28	 call	 QWORD PTR [rax+40]

; 4543 :         obtain_lock (&dev->lock);

  00567	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0056b	48 83 c0 38	 add	 rax, 56			; 00000038H
  0056f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196566
  00576	48 8b c8	 mov	 rcx, rax
  00579	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN37@z900_execu:

; 4544 :     }
; 4545 : 
; 4546 :     /* Extract the I/O parameters from the ORB */
; 4547 :     FETCH_FW(ccwaddr, dev->orb.ccwaddr);

  0057f	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00583	48 05 d4 02 00
	00		 add	 rax, 724		; 000002d4H
  00589	48 8b c8	 mov	 rcx, rax
  0058c	e8 00 00 00 00	 call	 fetch_fw_noswap
  00591	8b c8		 mov	 ecx, eax
  00593	e8 00 00 00 00	 call	 _byteswap_ulong
  00598	89 45 24	 mov	 DWORD PTR ccwaddr$[rbp], eax

; 4548 :     dev->ccwaddr = ccwaddr;

  0059b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0059f	8b 4d 24	 mov	 ecx, DWORD PTR ccwaddr$[rbp]
  005a2	89 88 80 02 00
	00		 mov	 DWORD PTR [rax+640], ecx

; 4549 :     dev->ccwfmt = ccwfmt = (dev->orb.flag5 & ORB5_F) ? 1 : 0;

  005a8	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  005ac	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  005b3	25 80 00 00 00	 and	 eax, 128		; 00000080H
  005b8	85 c0		 test	 eax, eax
  005ba	74 0c		 je	 SHORT $LN246@z900_execu
  005bc	c7 85 8c 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv283[rbp], 1
  005c6	eb 0a		 jmp	 SHORT $LN247@z900_execu
$LN246@z900_execu:
  005c8	c7 85 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv283[rbp], 0
$LN247@z900_execu:
  005d2	0f b6 85 8c 00
	00 00		 movzx	 eax, BYTE PTR tv283[rbp]
  005d9	88 45 0b	 mov	 BYTE PTR ccwfmt$[rbp], al
  005dc	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  005e0	0f b6 4d 0b	 movzx	 ecx, BYTE PTR ccwfmt$[rbp]
  005e4	88 88 87 02 00
	00		 mov	 BYTE PTR [rax+647], cl

; 4550 :     dev->ccwkey = ccwkey = dev->orb.flag4 & ORB4_KEY;

  005ea	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  005ee	0f b6 80 d0 02
	00 00		 movzx	 eax, BYTE PTR [rax+720]
  005f5	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  005fa	88 45 14	 mov	 BYTE PTR ccwkey$[rbp], al
  005fd	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00601	0f b6 4d 14	 movzx	 ecx, BYTE PTR ccwkey$[rbp]
  00605	88 88 88 02 00
	00		 mov	 BYTE PTR [rax+648], cl

; 4551 :     dev->idawfmt = idawfmt = (dev->orb.flag5 & ORB5_H) ? PF_IDAW2 : PF_IDAW1;

  0060b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0060f	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  00616	83 e0 02	 and	 eax, 2
  00619	85 c0		 test	 eax, eax
  0061b	74 0c		 je	 SHORT $LN248@z900_execu
  0061d	c7 85 90 00 00
	00 02 00 00 00	 mov	 DWORD PTR tv295[rbp], 2
  00627	eb 0a		 jmp	 SHORT $LN249@z900_execu
$LN248@z900_execu:
  00629	c7 85 90 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv295[rbp], 1
$LN249@z900_execu:
  00633	0f b6 85 90 00
	00 00		 movzx	 eax, BYTE PTR tv295[rbp]
  0063a	88 45 16	 mov	 BYTE PTR idawfmt$[rbp], al
  0063d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00641	0f b6 4d 16	 movzx	 ecx, BYTE PTR idawfmt$[rbp]
  00645	88 88 86 02 00
	00		 mov	 BYTE PTR [rax+646], cl

; 4552 : 
; 4553 :     /* Determine IDA page size */
; 4554 :     if (idawfmt == PF_IDAW2)

  0064b	0f b6 45 16	 movzx	 eax, BYTE PTR idawfmt$[rbp]
  0064f	83 f8 02	 cmp	 eax, 2
  00652	75 35		 jne	 SHORT $LN38@z900_execu

; 4555 :     {
; 4556 :         /* Page size is 2K or 4K depending on flag bit */
; 4557 :         idapmask = (dev->orb.flag5 & ORB5_T) ? STORAGE_KEY_2K_BYTEMASK

  00654	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00658	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  0065f	83 e0 01	 and	 eax, 1
  00662	85 c0		 test	 eax, eax
  00664	74 0c		 je	 SHORT $LN250@z900_execu
  00666	c7 85 94 00 00
	00 ff 07 00 00	 mov	 DWORD PTR tv303[rbp], 2047 ; 000007ffH
  00670	eb 0a		 jmp	 SHORT $LN251@z900_execu
$LN250@z900_execu:
  00672	c7 85 94 00 00
	00 ff 0f 00 00	 mov	 DWORD PTR tv303[rbp], 4095 ; 00000fffH
$LN251@z900_execu:
  0067c	0f b7 85 94 00
	00 00		 movzx	 eax, WORD PTR tv303[rbp]
  00683	66 89 45 44	 mov	 WORD PTR idapmask$[rbp], ax

; 4558 :                                              : STORAGE_KEY_4K_BYTEMASK;
; 4559 :     } else {

  00687	eb 09		 jmp	 SHORT $LN39@z900_execu
$LN38@z900_execu:

; 4560 :         /* Page size is always 2K for format-1 IDAW */
; 4561 :         idapmask = STORAGE_KEY_2K_BYTEMASK;

  00689	b8 ff 07 00 00	 mov	 eax, 2047		; 000007ffH
  0068e	66 89 45 44	 mov	 WORD PTR idapmask$[rbp], ax
$LN39@z900_execu:
$resume_suspend$331:

; 4562 :     }
; 4563 : 
; 4564 : 
; 4565 : resume_suspend:
; 4566 : 
; 4567 :     /* Turn off the start pending bit in the SCSW */
; 4568 :     dev->scsw.flag2 &= ~SCSW2_AC_START;

  00692	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00696	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  0069d	83 e0 fb	 and	 eax, -5
  006a0	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  006a4	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 4569 : 
; 4570 :     dev->chained = dev->prev_chained =

  006aa	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  006ae	c7 80 7c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+636], 0
  006b8	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  006bc	c6 80 7b 02 00
	00 00		 mov	 BYTE PTR [rax+635], 0
  006c3	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  006c7	c6 80 7a 02 00
	00 00		 mov	 BYTE PTR [rax+634], 0
  006ce	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  006d2	c6 80 79 02 00
	00 00		 mov	 BYTE PTR [rax+633], 0
  006d9	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  006dd	c6 80 78 02 00
	00 00		 mov	 BYTE PTR [rax+632], 0

; 4571 :     dev->code    = dev->prevcode     = dev->ccwseq = 0;
; 4572 : 
; 4573 : #if defined(_FEATURE_IO_ASSIST)
; 4574 :  #define _IOA_MBO sysblk.zpb[dev->pmcw.zone].mbo
; 4575 :  #define _IOA_MBM sysblk.zpb[dev->pmcw.zone].mbm
; 4576 :  #define _IOA_MBK sysblk.zpb[dev->pmcw.zone].mbk
; 4577 : #else /*defined(_FEATURE_IO_ASSIST)*/
; 4578 :  #define _IOA_MBO sysblk.mbo
; 4579 :  #define _IOA_MBM sysblk.mbm
; 4580 :  #define _IOA_MBK sysblk.mbk
; 4581 : #endif /*defined(_FEATURE_IO_ASSIST)*/
; 4582 : 
; 4583 : #ifdef FEATURE_CHANNEL_SUBSYSTEM
; 4584 :     /* Update the measurement block if applicable */
; 4585 :     if (_IOA_MBM && (dev->pmcw.flag5 & PMCW5_MM_MBU) &&

  006e4	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  006e8	0f b6 80 04 03
	00 00		 movzx	 eax, BYTE PTR [rax+772]
  006ef	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  006f3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006fa	83 bc 01 cc 0e
	00 00 00	 cmp	 DWORD PTR [rcx+rax+3788], 0
  00702	0f 84 9d 02 00
	00		 je	 $LN40@z900_execu
  00708	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0070c	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00713	83 e0 10	 and	 eax, 16
  00716	85 c0		 test	 eax, eax
  00718	0f 84 87 02 00
	00		 je	 $LN40@z900_execu
  0071e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00722	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00729	83 e0 03	 and	 eax, 3
  0072c	85 c0		 test	 eax, eax
  0072e	0f 85 71 02 00
	00		 jne	 $LN40@z900_execu

; 4586 :         !(dev->scsw.flag2 & (SCSW2_AC_CLEAR | SCSW2_AC_HALT)))
; 4587 :     {
; 4588 :         mbaddr = _IOA_MBO;

  00734	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00738	0f b6 80 04 03
	00 00		 movzx	 eax, BYTE PTR [rax+772]
  0073f	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  00743	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0074a	8b 84 01 c0 0e
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3776]
  00751	89 45 4c	 mov	 DWORD PTR mbaddr$[rbp], eax

; 4589 :         mbaddr += (dev->pmcw.mbi[0] << 8 | dev->pmcw.mbi[1]) << 5;

  00754	b8 01 00 00 00	 mov	 eax, 1
  00759	48 6b c0 00	 imul	 rax, rax, 0
  0075d	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00761	0f b6 84 01 f8
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+760]
  00769	c1 e0 08	 shl	 eax, 8
  0076c	b9 01 00 00 00	 mov	 ecx, 1
  00771	48 6b c9 01	 imul	 rcx, rcx, 1
  00775	48 8b 55 00	 mov	 rdx, QWORD PTR dev$[rbp]
  00779	0f b6 8c 0a f8
	02 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+760]
  00781	0b c1		 or	 eax, ecx
  00783	c1 e0 05	 shl	 eax, 5
  00786	8b 4d 4c	 mov	 ecx, DWORD PTR mbaddr$[rbp]
  00789	03 c8		 add	 ecx, eax
  0078b	8b c1		 mov	 eax, ecx
  0078d	89 45 4c	 mov	 DWORD PTR mbaddr$[rbp], eax

; 4590 :         if ( !CHADDRCHK(mbaddr, dev)
; 4591 :             && (((ARCH_DEP( get_dev_storage_key )( dev, mbaddr ) & STORKEY_KEY) == _IOA_MBK)

  00790	8b 45 4c	 mov	 eax, DWORD PTR mbaddr$[rbp]
  00793	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00797	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  0079e	0f 87 2d 01 00
	00		 ja	 $LN41@z900_execu
  007a4	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  007a8	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  007af	83 e0 10	 and	 eax, 16
  007b2	85 c0		 test	 eax, eax
  007b4	74 52		 je	 SHORT $LN43@z900_execu
  007b6	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  007ba	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  007c1	83 e0 20	 and	 eax, 32			; 00000020H
  007c4	85 c0		 test	 eax, eax
  007c6	74 17		 je	 SHORT $LN44@z900_execu
  007c8	8b 45 4c	 mov	 eax, DWORD PTR mbaddr$[rbp]
  007cb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  007d2	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  007d9	0f 82 f2 00 00
	00		 jb	 $LN41@z900_execu
$LN44@z900_execu:
  007df	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  007e3	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  007ea	83 e0 40	 and	 eax, 64			; 00000040H
  007ed	85 c0		 test	 eax, eax
  007ef	74 17		 je	 SHORT $LN45@z900_execu
  007f1	8b 45 4c	 mov	 eax, DWORD PTR mbaddr$[rbp]
  007f4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  007fb	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  00802	0f 83 c9 00 00
	00		 jae	 $LN41@z900_execu
$LN45@z900_execu:
$LN43@z900_execu:
  00808	8b 45 4c	 mov	 eax, DWORD PTR mbaddr$[rbp]
  0080b	8b d0		 mov	 edx, eax
  0080d	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00811	e8 00 00 00 00	 call	 z900_get_dev_storage_key
  00816	0f b6 c0	 movzx	 eax, al
  00819	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  0081e	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00822	0f b6 89 04 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+772]
  00829	48 6b c9 38	 imul	 rcx, rcx, 56		; 00000038H
  0082d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00834	0f b6 8c 0a c8
	0e 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+3784]
  0083c	3b c1		 cmp	 eax, ecx
  0083e	74 22		 je	 SHORT $LN46@z900_execu
  00840	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00844	0f b6 80 04 03
	00 00		 movzx	 eax, BYTE PTR [rax+772]
  0084b	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  0084f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00856	0f b6 84 01 c8
	0e 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3784]
  0085e	85 c0		 test	 eax, eax
  00860	75 6f		 jne	 SHORT $LN41@z900_execu
$LN46@z900_execu:

; 4592 :                 || (_IOA_MBK == 0)))
; 4593 :         {
; 4594 :             ARCH_DEP( or_dev_storage_key )( dev, mbaddr, (STORKEY_REF | STORKEY_CHANGE) );

  00862	8b 45 4c	 mov	 eax, DWORD PTR mbaddr$[rbp]
  00865	41 b0 06	 mov	 r8b, 6
  00868	8b d0		 mov	 edx, eax
  0086a	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0086e	e8 00 00 00 00	 call	 z900_or_dev_storage_key

; 4595 :             mbk = (MBK*)&dev->mainstor[mbaddr];

  00873	8b 45 4c	 mov	 eax, DWORD PTR mbaddr$[rbp]
  00876	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0087a	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00881	48 03 c8	 add	 rcx, rax
  00884	48 8b c1	 mov	 rax, rcx
  00887	48 89 85 88 01
	00 00		 mov	 QWORD PTR mbk$[rbp], rax

; 4596 :             FETCH_HW(mbcount,mbk->srcount);

  0088e	48 8b 85 88 01
	00 00		 mov	 rax, QWORD PTR mbk$[rbp]
  00895	48 8b c8	 mov	 rcx, rax
  00898	e8 00 00 00 00	 call	 fetch_hw_noswap
  0089d	0f b7 c8	 movzx	 ecx, ax
  008a0	e8 00 00 00 00	 call	 _byteswap_ushort
  008a5	66 89 45 70	 mov	 WORD PTR mbcount$[rbp], ax

; 4597 :             mbcount++;

  008a9	0f b7 45 70	 movzx	 eax, WORD PTR mbcount$[rbp]
  008ad	66 ff c0	 inc	 ax
  008b0	66 89 45 70	 mov	 WORD PTR mbcount$[rbp], ax

; 4598 :             STORE_HW(mbk->srcount,mbcount);

  008b4	0f b7 4d 70	 movzx	 ecx, WORD PTR mbcount$[rbp]
  008b8	e8 00 00 00 00	 call	 _byteswap_ushort
  008bd	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR mbk$[rbp]
  008c4	0f b7 d0	 movzx	 edx, ax
  008c7	e8 00 00 00 00	 call	 store_hw_noswap

; 4599 :         } else {

  008cc	e9 d4 00 00 00	 jmp	 $LN42@z900_execu
$LN41@z900_execu:

; 4600 :             /* Generate subchannel logout indicating program
; 4601 :                check or protection check, and set the subchannel
; 4602 :                measurement-block-update-enable to zero */
; 4603 :             dev->pmcw.flag5 &= ~PMCW5_MM_MBU;

  008d1	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  008d5	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  008dc	83 e0 ef	 and	 eax, -17
  008df	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  008e3	88 81 f1 02 00
	00		 mov	 BYTE PTR [rcx+753], al

; 4604 :             dev->esw.scl0 |= !CHADDRCHK(mbaddr, dev) ?

  008e9	8b 45 4c	 mov	 eax, DWORD PTR mbaddr$[rbp]
  008ec	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  008f0	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  008f7	77 68		 ja	 SHORT $LN256@z900_execu
  008f9	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  008fd	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  00904	83 e0 10	 and	 eax, 16
  00907	85 c0		 test	 eax, eax
  00909	74 4a		 je	 SHORT $LN255@z900_execu
  0090b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0090f	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00916	83 e0 20	 and	 eax, 32			; 00000020H
  00919	85 c0		 test	 eax, eax
  0091b	74 13		 je	 SHORT $LN252@z900_execu
  0091d	8b 45 4c	 mov	 eax, DWORD PTR mbaddr$[rbp]
  00920	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00927	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  0092e	72 31		 jb	 SHORT $LN254@z900_execu
$LN252@z900_execu:
  00930	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00934	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0093b	83 e0 40	 and	 eax, 64			; 00000040H
  0093e	85 c0		 test	 eax, eax
  00940	74 13		 je	 SHORT $LN253@z900_execu
  00942	8b 45 4c	 mov	 eax, DWORD PTR mbaddr$[rbp]
  00945	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0094c	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  00953	73 0c		 jae	 SHORT $LN256@z900_execu
$LN255@z900_execu:
$LN253@z900_execu:
  00955	c7 85 98 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv437[rbp], 1
  0095f	eb 0a		 jmp	 SHORT $LN257@z900_execu
$LN256@z900_execu:
$LN254@z900_execu:
  00961	c7 85 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv437[rbp], 0
$LN257@z900_execu:
  0096b	83 bd 98 00 00
	00 00		 cmp	 DWORD PTR tv437[rbp], 0
  00972	74 0c		 je	 SHORT $LN258@z900_execu
  00974	c7 85 9c 00 00
	00 08 00 00 00	 mov	 DWORD PTR tv439[rbp], 8
  0097e	eb 0a		 jmp	 SHORT $LN259@z900_execu
$LN258@z900_execu:
  00980	c7 85 9c 00 00
	00 20 00 00 00	 mov	 DWORD PTR tv439[rbp], 32 ; 00000020H
$LN259@z900_execu:
  0098a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0098e	0f b6 80 2c 03
	00 00		 movzx	 eax, BYTE PTR [rax+812]
  00995	0b 85 9c 00 00
	00		 or	 eax, DWORD PTR tv439[rbp]
  0099b	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0099f	88 81 2c 03 00
	00		 mov	 BYTE PTR [rcx+812], al
$LN42@z900_execu:
$LN40@z900_execu:

; 4605 :                                  SCL0_ESF_MBPTK : SCL0_ESF_MBPGK;
; 4606 :             /*INCOMPLETE*/
; 4607 :         }
; 4608 :     }
; 4609 : #endif /*FEATURE_CHANNEL_SUBSYSTEM*/
; 4610 : 
; 4611 :     release_lock (&dev->lock);

  009a5	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  009a9	48 83 c0 38	 add	 rax, 56			; 00000038H
  009ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196576
  009b4	48 8b c8	 mov	 rcx, rax
  009b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN327@z900_execu:
$LN326@z900_execu:
$LN325@z900_execu:
$LN2@z900_execu:

; 4612 : 
; 4613 :     /* Execute the CCW chain */
; 4614 :     /* On entry : No locks held */
; 4615 :     while ( chain )

  009bd	0f b6 45 20	 movzx	 eax, BYTE PTR chain$[rbp]
  009c1	85 c0		 test	 eax, eax
  009c3	0f 84 43 2a 00
	00		 je	 $LN3@z900_execu

; 4616 :     {
; 4617 :         /* Test for clear subchannel request or system shutdown */
; 4618 :         if (dev->scsw.flag2 & SCSW2_AC_CLEAR ||

  009c9	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  009cd	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  009d4	83 e0 01	 and	 eax, 1
  009d7	85 c0		 test	 eax, eax
  009d9	75 1b		 jne	 SHORT $LN48@z900_execu
  009db	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  009e2	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  009e8	c1 e8 0b	 shr	 eax, 11
  009eb	83 e0 01	 and	 eax, 1
  009ee	85 c0		 test	 eax, eax
  009f0	0f 84 91 00 00
	00		 je	 $LN47@z900_execu
$LN48@z900_execu:

; 4619 :             sysblk.shutdown)
; 4620 :         {
; 4621 : 
; 4622 :             /* No I/O delays are to be taken during clear operations */
; 4623 : 
; 4624 :             /* Call the i/o end exit */
; 4625 :             if (dev->hnd->end) (dev->hnd->end) (dev);

  009f6	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  009fa	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00a01	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00a06	74 12		 je	 SHORT $LN49@z900_execu
  00a08	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00a0c	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00a13	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00a17	ff 50 30	 call	 QWORD PTR [rax+48]
$LN49@z900_execu:
$execute_clear$329:

; 4626 : 
; 4627 : execute_clear:
; 4628 :             /* Get necessary locks */
; 4629 :             OBTAIN_INTLOCK(NULL);

  00a1a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196580
  00a21	33 c9		 xor	 ecx, ecx
  00a23	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 4630 :             obtain_lock(&dev->lock);

  00a28	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00a2c	48 83 c0 38	 add	 rax, 56			; 00000038H
  00a30	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196581
  00a37	48 8b c8	 mov	 rcx, rax
  00a3a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4631 : 
; 4632 :             /* Execute clear function */
; 4633 :             perform_clear_subchan(dev);

  00a40	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00a44	e8 00 00 00 00	 call	 perform_clear_subchan

; 4634 : 
; 4635 :             /* Release locks */
; 4636 :             release_lock(&dev->lock);

  00a49	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00a4d	48 83 c0 38	 add	 rax, 56			; 00000038H
  00a51	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196582
  00a58	48 8b c8	 mov	 rcx, rax
  00a5b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4637 :             RELEASE_INTLOCK(NULL);

  00a61	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196583
  00a68	33 c9		 xor	 ecx, ecx
  00a6a	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 4638 : 
; 4639 :             /* Return */
; 4640 :             return execute_ccw_chain_fast_return( iobuf, &iobuf_initial, NULL );

  00a6f	45 33 c0	 xor	 r8d, r8d
  00a72	48 8d 95 00 20
	00 00		 lea	 rdx, QWORD PTR iobuf_initial$[rbp]
  00a79	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  00a7d	e8 00 00 00 00	 call	 execute_ccw_chain_fast_return
  00a82	e9 6f 2d 00 00	 jmp	 $LN1@z900_execu
$LN47@z900_execu:

; 4641 : 
; 4642 :         } /* end perform clear subchannel */
; 4643 : 
; 4644 :         /* Test for halt subchannel request */
; 4645 :         if (dev->scsw.flag2 & SCSW2_AC_HALT)

  00a87	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00a8b	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00a92	83 e0 02	 and	 eax, 2
  00a95	85 c0		 test	 eax, eax
  00a97	0f 84 67 01 00
	00		 je	 $LN50@z900_execu
$LN6@z900_execu:

; 4646 :         {
; 4647 :             IODELAY(dev);

  00a9d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00aa4	83 b8 e0 13 00
	00 00		 cmp	 DWORD PTR [rax+5088], 0
  00aab	7e 2d		 jle	 SHORT $LN51@z900_execu
  00aad	b8 01 00 00 00	 mov	 eax, 1
  00ab2	48 6b c0 0a	 imul	 rax, rax, 10
  00ab6	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00aba	0f b6 84 01 6c
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1388]
  00ac2	83 f8 20	 cmp	 eax, 32			; 00000020H
  00ac5	75 13		 jne	 SHORT $LN51@z900_execu
  00ac7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00ace	8b 88 e0 13 00
	00		 mov	 ecx, DWORD PTR [rax+5088]
  00ad4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN51@z900_execu:
  00ada	33 c0		 xor	 eax, eax
  00adc	85 c0		 test	 eax, eax
  00ade	75 bd		 jne	 SHORT $LN6@z900_execu

; 4648 : 
; 4649 :             /* Call the i/o end exit */
; 4650 :             if (dev->hnd->end) (dev->hnd->end) (dev);

  00ae0	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00ae4	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00aeb	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00af0	74 12		 je	 SHORT $LN52@z900_execu
  00af2	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00af6	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00afd	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00b01	ff 50 30	 call	 QWORD PTR [rax+48]
$LN52@z900_execu:
$execute_halt$330:

; 4651 : 
; 4652 : execute_halt:
; 4653 :             perform_halt(dev);

  00b04	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00b08	e8 00 00 00 00	 call	 perform_halt

; 4654 : 
; 4655 :             if (tracethis)

  00b0d	0f b6 45 15	 movzx	 eax, BYTE PTR tracethis$[rbp]
  00b11	85 c0		 test	 eax, eax
  00b13	0f 84 d3 00 00
	00		 je	 $LN53@z900_execu

; 4656 :             {
; 4657 :                 if (dev->ccwtrace && sysblk.traceFILE)

  00b19	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00b1d	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00b23	c1 e8 0f	 shr	 eax, 15
  00b26	83 e0 01	 and	 eax, 1
  00b29	85 c0		 test	 eax, eax
  00b2b	74 20		 je	 SHORT $LN54@z900_execu
  00b2d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b34	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00b3c	74 0f		 je	 SHORT $LN54@z900_execu

; 4658 :                     tf_1309( dev );

  00b3e	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00b42	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1309
  00b48	e9 9f 00 00 00	 jmp	 $LN55@z900_execu
$LN54@z900_execu:

; 4659 :                 else
; 4660 :                     // "%1d:%04X CHAN: halt completed"
; 4661 :                     WRMSG( HHC01309, "I", LCSS_DEVNUM );

  00b4d	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  00b52	74 10		 je	 SHORT $LN260@z900_execu
  00b54	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00b58	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00b5c	89 85 a0 00 00
	00		 mov	 DWORD PTR tv511[rbp], eax
  00b62	eb 0a		 jmp	 SHORT $LN261@z900_execu
$LN260@z900_execu:
  00b64	c7 85 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv511[rbp], 0
$LN261@z900_execu:
  00b6e	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  00b73	74 12		 je	 SHORT $LN262@z900_execu
  00b75	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00b79	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00b7d	d1 f8		 sar	 eax, 1
  00b7f	89 85 a4 00 00
	00		 mov	 DWORD PTR tv517[rbp], eax
  00b85	eb 0a		 jmp	 SHORT $LN263@z900_execu
$LN262@z900_execu:
  00b87	c7 85 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv517[rbp], 0
$LN263@z900_execu:
  00b91	b9 01 00 00 00	 mov	 ecx, 1
  00b96	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b9c	8b 8d a0 00 00
	00		 mov	 ecx, DWORD PTR tv511[rbp]
  00ba2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00ba6	8b 8d a4 00 00
	00		 mov	 ecx, DWORD PTR tv517[rbp]
  00bac	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00bb0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196590
  00bb7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00bbc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196591
  00bc3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00bc8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00bcd	41 b9 03 00 00
	00		 mov	 r9d, 3
  00bd3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196592
  00bda	ba 35 12 00 00	 mov	 edx, 4661		; 00001235H
  00bdf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196593
  00be6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN55@z900_execu:
$LN53@z900_execu:

; 4662 :             }
; 4663 : 
; 4664 :             return execute_ccw_chain_fast_return( iobuf, &iobuf_initial, NULL );

  00bec	45 33 c0	 xor	 r8d, r8d
  00bef	48 8d 95 00 20
	00 00		 lea	 rdx, QWORD PTR iobuf_initial$[rbp]
  00bf6	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  00bfa	e8 00 00 00 00	 call	 execute_ccw_chain_fast_return
  00bff	e9 f2 2b 00 00	 jmp	 $LN1@z900_execu
$LN50@z900_execu:

; 4665 : 
; 4666 :         } /* end perform halt subchannel */
; 4667 : 
; 4668 :         /* Test for attention status from device */
; 4669 :         if (dev->scsw.flag3 & SCSW3_SC_ALERT)

  00c04	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00c08	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00c0f	83 e0 10	 and	 eax, 16
  00c12	85 c0		 test	 eax, eax
  00c14	0f 84 80 01 00
	00		 je	 $LN56@z900_execu
$LN9@z900_execu:

; 4670 :         {
; 4671 :             IODELAY(dev);

  00c1a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00c21	83 b8 e0 13 00
	00 00		 cmp	 DWORD PTR [rax+5088], 0
  00c28	7e 2d		 jle	 SHORT $LN57@z900_execu
  00c2a	b8 01 00 00 00	 mov	 eax, 1
  00c2f	48 6b c0 0a	 imul	 rax, rax, 10
  00c33	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00c37	0f b6 84 01 6c
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1388]
  00c3f	83 f8 20	 cmp	 eax, 32			; 00000020H
  00c42	75 13		 jne	 SHORT $LN57@z900_execu
  00c44	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00c4b	8b 88 e0 13 00
	00		 mov	 ecx, DWORD PTR [rax+5088]
  00c51	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN57@z900_execu:
  00c57	33 c0		 xor	 eax, eax
  00c59	85 c0		 test	 eax, eax
  00c5b	75 bd		 jne	 SHORT $LN9@z900_execu

; 4672 : 
; 4673 :             /* Call the i/o end exit */
; 4674 :             if (dev->hnd->end) (dev->hnd->end) (dev);

  00c5d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00c61	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00c68	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00c6d	74 12		 je	 SHORT $LN58@z900_execu
  00c6f	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00c73	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00c7a	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00c7e	ff 50 30	 call	 QWORD PTR [rax+48]
$LN58@z900_execu:

; 4675 : 
; 4676 :             /* Queue the pending interrupt and update status */
; 4677 :             queue_io_interrupt_and_update_status(dev,TRUE);

  00c81	ba 01 00 00 00	 mov	 edx, 1
  00c86	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00c8a	e8 00 00 00 00	 call	 queue_io_interrupt_and_update_status

; 4678 : 
; 4679 :             if (CCW_TRACING_ACTIVE( dev, tracethis ))

  00c8f	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00c93	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00c99	c1 e8 0f	 shr	 eax, 15
  00c9c	83 e0 01	 and	 eax, 1
  00c9f	85 c0		 test	 eax, eax
  00ca1	75 0c		 jne	 SHORT $LN60@z900_execu
  00ca3	0f b6 45 15	 movzx	 eax, BYTE PTR tracethis$[rbp]
  00ca7	85 c0		 test	 eax, eax
  00ca9	0f 84 d3 00 00
	00		 je	 $LN59@z900_execu
$LN60@z900_execu:

; 4680 :             {
; 4681 :                 if (dev->ccwtrace && sysblk.traceFILE)

  00caf	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00cb3	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00cb9	c1 e8 0f	 shr	 eax, 15
  00cbc	83 e0 01	 and	 eax, 1
  00cbf	85 c0		 test	 eax, eax
  00cc1	74 20		 je	 SHORT $LN61@z900_execu
  00cc3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00cca	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00cd2	74 0f		 je	 SHORT $LN61@z900_execu

; 4682 :                     tf_1307( dev );

  00cd4	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00cd8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1307
  00cde	e9 9f 00 00 00	 jmp	 $LN62@z900_execu
$LN61@z900_execu:

; 4683 :                 else
; 4684 :                     // "%1d:%04X CHAN: attention completed"
; 4685 :                     WRMSG( HHC01307, "I", LCSS_DEVNUM );

  00ce3	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  00ce8	74 10		 je	 SHORT $LN264@z900_execu
  00cea	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00cee	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00cf2	89 85 a8 00 00
	00		 mov	 DWORD PTR tv570[rbp], eax
  00cf8	eb 0a		 jmp	 SHORT $LN265@z900_execu
$LN264@z900_execu:
  00cfa	c7 85 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv570[rbp], 0
$LN265@z900_execu:
  00d04	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  00d09	74 12		 je	 SHORT $LN266@z900_execu
  00d0b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00d0f	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00d13	d1 f8		 sar	 eax, 1
  00d15	89 85 ac 00 00
	00		 mov	 DWORD PTR tv576[rbp], eax
  00d1b	eb 0a		 jmp	 SHORT $LN267@z900_execu
$LN266@z900_execu:
  00d1d	c7 85 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv576[rbp], 0
$LN267@z900_execu:
  00d27	b9 01 00 00 00	 mov	 ecx, 1
  00d2c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00d32	8b 8d a8 00 00
	00		 mov	 ecx, DWORD PTR tv570[rbp]
  00d38	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00d3c	8b 8d ac 00 00
	00		 mov	 ecx, DWORD PTR tv576[rbp]
  00d42	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00d46	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196601
  00d4d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00d52	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196602
  00d59	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00d5e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d63	41 b9 03 00 00
	00		 mov	 r9d, 3
  00d69	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196603
  00d70	ba 4d 12 00 00	 mov	 edx, 4685		; 0000124dH
  00d75	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196604
  00d7c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN62@z900_execu:
$LN59@z900_execu:

; 4686 :             }
; 4687 : 
; 4688 :             return execute_ccw_chain_fast_return( iobuf, &iobuf_initial, NULL );

  00d82	45 33 c0	 xor	 r8d, r8d
  00d85	48 8d 95 00 20
	00 00		 lea	 rdx, QWORD PTR iobuf_initial$[rbp]
  00d8c	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  00d90	e8 00 00 00 00	 call	 execute_ccw_chain_fast_return
  00d95	e9 5c 2a 00 00	 jmp	 $LN1@z900_execu
$LN56@z900_execu:

; 4689 : 
; 4690 :         } /* end attention processing */
; 4691 : 
; 4692 :         /* Clear the channel status and unit status, unless skipping
; 4693 :            to end of chain data */
; 4694 :         if (!skip_ccws)

  00d9a	83 7d 64 00	 cmp	 DWORD PTR skip_ccws$[rbp], 0
  00d9e	75 08		 jne	 SHORT $LN63@z900_execu

; 4695 :         {
; 4696 :             chanstat = 0;

  00da0	c6 45 09 00	 mov	 BYTE PTR chanstat$[rbp], 0

; 4697 :             unitstat = 0;

  00da4	c6 45 0c 00	 mov	 BYTE PTR unitstat$[rbp], 0
$LN63@z900_execu:

; 4698 :         }
; 4699 : 
; 4700 :         /* Fetch the next CCW */
; 4701 :         ARCH_DEP(fetch_ccw) (dev, ccwkey, ccwfmt, ccwaddr, &opcode,

  00da8	48 8d 45 09	 lea	 rax, QWORD PTR chanstat$[rbp]
  00dac	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00db1	48 8d 45 18	 lea	 rax, QWORD PTR count$[rbp]
  00db5	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00dba	48 8d 45 08	 lea	 rax, QWORD PTR flags$[rbp]
  00dbe	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00dc3	48 8d 45 1c	 lea	 rax, QWORD PTR addr$[rbp]
  00dc7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00dcc	48 8d 45 0a	 lea	 rax, QWORD PTR opcode$[rbp]
  00dd0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00dd5	44 8b 4d 24	 mov	 r9d, DWORD PTR ccwaddr$[rbp]
  00dd9	44 0f b6 45 0b	 movzx	 r8d, BYTE PTR ccwfmt$[rbp]
  00dde	0f b6 55 14	 movzx	 edx, BYTE PTR ccwkey$[rbp]
  00de2	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00de6	e8 00 00 00 00	 call	 z900_fetch_ccw

; 4702 :                              &addr, &flags, &count, &chanstat);
; 4703 : 
; 4704 :         /*************************************************************/
; 4705 :         /* NOTE: Order of process must not only match the Principles */
; 4706 :         /*       of Operations, but must also match the processing   */
; 4707 :         /*       order of real channels.                             */
; 4708 :         /*************************************************************/
; 4709 : 
; 4710 :         /* For an invalid CCW address in a TIC we must backup to
; 4711 :            TIC+8 */
; 4712 :         if(ticaddr && (chanstat & CSW_PROGC))

  00deb	83 7d 78 00	 cmp	 DWORD PTR ticaddr$[rbp], 0
  00def	74 14		 je	 SHORT $LN64@z900_execu
  00df1	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  00df5	83 e0 20	 and	 eax, 32			; 00000020H
  00df8	85 c0		 test	 eax, eax
  00dfa	74 09		 je	 SHORT $LN64@z900_execu

; 4713 :             ccwaddr = ticaddr-8;

  00dfc	8b 45 78	 mov	 eax, DWORD PTR ticaddr$[rbp]
  00dff	83 e8 08	 sub	 eax, 8
  00e02	89 45 24	 mov	 DWORD PTR ccwaddr$[rbp], eax
$LN64@z900_execu:

; 4714 : 
; 4715 :         /* Point to the CCW in main storage */
; 4716 :         ccw = dev->mainstor + ccwaddr;

  00e05	8b 45 24	 mov	 eax, DWORD PTR ccwaddr$[rbp]
  00e08	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00e0c	48 03 81 80 00
	00 00		 add	 rax, QWORD PTR [rcx+128]
  00e13	48 89 85 80 00
	00 00		 mov	 QWORD PTR ccw$[rbp], rax

; 4717 : 
; 4718 :         /* Increment to next CCW address */
; 4719 :         ccwaddr += 8;

  00e1a	8b 45 24	 mov	 eax, DWORD PTR ccwaddr$[rbp]
  00e1d	83 c0 08	 add	 eax, 8
  00e20	89 45 24	 mov	 DWORD PTR ccwaddr$[rbp], eax

; 4720 : 
; 4721 :         /* If prefetch, update prefetch table */
; 4722 :         if (prefetch.seq && (dev->chained & CCW_FLAGS_CD))

  00e23	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  00e2a	0f 84 93 00 00
	00		 je	 $LN65@z900_execu
  00e30	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00e34	0f b6 80 78 02
	00 00		 movzx	 eax, BYTE PTR [rax+632]
  00e3b	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00e40	85 c0		 test	 eax, eax
  00e42	74 7f		 je	 SHORT $LN65@z900_execu

; 4723 :         {
; 4724 :             ps = prefetch.seq++;

  00e44	8b 85 c0 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp]
  00e4a	89 45 10	 mov	 DWORD PTR ps$[rbp], eax
  00e4d	8b 85 c0 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp]
  00e53	ff c0		 inc	 eax
  00e55	89 85 c0 01 00
	00		 mov	 DWORD PTR prefetch$[rbp], eax

; 4725 :             if (prefetch.seq > PF_SIZE)

  00e5b	81 bd c0 01 00
	00 00 01 00 00	 cmp	 DWORD PTR prefetch$[rbp], 256 ; 00000100H
  00e65	76 05		 jbe	 SHORT $LN67@z900_execu

; 4726 :                 goto breakchain;

  00e67	e9 76 18 00 00	 jmp	 $breakchain$332
$LN67@z900_execu:

; 4727 :             prefetch.ccwaddr[ps] = ccwaddr;

  00e6c	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  00e6f	8b 4d 24	 mov	 ecx, DWORD PTR ccwaddr$[rbp]
  00e72	89 8c 85 d0 02
	00 00		 mov	 DWORD PTR prefetch$[rbp+rax*4+272], ecx

; 4728 :             prefetch.ccwflags[ps] = flags;

  00e79	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  00e7c	0f b6 4d 08	 movzx	 ecx, BYTE PTR flags$[rbp]
  00e80	88 8c 05 d0 12
	00 00		 mov	 BYTE PTR prefetch$[rbp+rax+4368], cl

; 4729 :             prefetch.ccwcount[ps] =

  00e87	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  00e8a	8b 4d 18	 mov	 ecx, DWORD PTR count$[rbp]
  00e8d	89 8c 85 d0 06
	00 00		 mov	 DWORD PTR prefetch$[rbp+rax*4+1296], ecx
  00e94	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  00e97	0f b7 4d 18	 movzx	 ecx, WORD PTR count$[rbp]
  00e9b	66 89 8c 45 d0
	13 00 00	 mov	 WORD PTR prefetch$[rbp+rax*2+4624], cx

; 4730 :             prefetch.datalen[ps] = count;
; 4731 :             prefetch.dataaddr[ps] = addr;

  00ea3	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  00ea6	8b 4d 1c	 mov	 ecx, DWORD PTR addr$[rbp]
  00ea9	48 89 8c c5 d0
	0a 00 00	 mov	 QWORD PTR prefetch$[rbp+rax*8+2320], rcx

; 4732 : 
; 4733 :             /* Exit if fetch_ccw detected channel program check */
; 4734 :             if (chanstat)

  00eb1	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  00eb5	85 c0		 test	 eax, eax
  00eb7	74 05		 je	 SHORT $LN68@z900_execu

; 4735 :                 goto prefetch;

  00eb9	e9 62 10 00 00	 jmp	 $prefetch$333
$LN68@z900_execu:

; 4736 :         }

  00ebe	e9 e8 00 00 00	 jmp	 $LN66@z900_execu
$LN65@z900_execu:

; 4737 :         else
; 4738 :         {
; 4739 :             /* Update the CCW address in the SCSW */
; 4740 :             STORE_FW(dev->scsw.ccwaddr,ccwaddr);

  00ec3	8b 4d 24	 mov	 ecx, DWORD PTR ccwaddr$[rbp]
  00ec6	e8 00 00 00 00	 call	 _byteswap_ulong
  00ecb	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00ecf	48 81 c1 0c 03
	00 00		 add	 rcx, 780		; 0000030cH
  00ed6	8b d0		 mov	 edx, eax
  00ed8	e8 00 00 00 00	 call	 store_fw_noswap

; 4741 : 
; 4742 :             /* Exit if fetch_ccw detected channel program check */
; 4743 :             if (chanstat != 0)

  00edd	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  00ee1	85 c0		 test	 eax, eax
  00ee3	74 05		 je	 SHORT $LN69@z900_execu

; 4744 :                 goto breakchain;

  00ee5	e9 f8 17 00 00	 jmp	 $breakchain$332
$LN69@z900_execu:

; 4745 : 
; 4746 :             /* Trace the CCW -- UNLESS ... it's a read type! For read
; 4747 :                type CCWs, we defer the tracing until AFTER the CCW has
; 4748 :                been executed and the data copied to storage (i.e. we
; 4749 :                don't trace the CCW until after BOTH the driver's CCW
; 4750 :                handler (dev->hnd->exec) and ARCH_DEP(copy_iobuf) have
; 4751 :                been called; see much further below).
; 4752 :             */
; 4753 :             if (1
; 4754 :                 && dev->ccwtrace
; 4755 :                 && !(0

  00eea	33 c0		 xor	 eax, eax
  00eec	83 f8 01	 cmp	 eax, 1
  00eef	0f 84 b6 00 00
	00		 je	 $LN70@z900_execu
  00ef5	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00ef9	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00eff	c1 e8 0f	 shr	 eax, 15
  00f02	83 e0 01	 and	 eax, 1
  00f05	85 c0		 test	 eax, eax
  00f07	0f 84 9e 00 00
	00		 je	 $LN70@z900_execu
  00f0d	33 c0		 xor	 eax, eax
  00f0f	85 c0		 test	 eax, eax
  00f11	0f 85 94 00 00
	00		 jne	 $LN70@z900_execu
  00f17	b8 01 00 00 00	 mov	 eax, 1
  00f1c	48 6b c0 00	 imul	 rax, rax, 0
  00f20	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR ccw$[rbp]
  00f27	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00f2b	83 e0 03	 and	 eax, 3
  00f2e	83 f8 02	 cmp	 eax, 2
  00f31	74 78		 je	 SHORT $LN70@z900_execu
  00f33	b8 01 00 00 00	 mov	 eax, 1
  00f38	48 6b c0 00	 imul	 rax, rax, 0
  00f3c	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR ccw$[rbp]
  00f43	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00f47	83 e0 0f	 and	 eax, 15
  00f4a	83 f8 0c	 cmp	 eax, 12
  00f4d	74 5c		 je	 SHORT $LN70@z900_execu
  00f4f	b8 01 00 00 00	 mov	 eax, 1
  00f54	48 6b c0 00	 imul	 rax, rax, 0
  00f58	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR ccw$[rbp]
  00f5f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00f63	83 e0 0f	 and	 eax, 15
  00f66	83 f8 04	 cmp	 eax, 4
  00f69	74 40		 je	 SHORT $LN70@z900_execu

; 4756 :                      || IS_CCW_READ  ( ccw[0] )
; 4757 :                      || IS_CCW_RDBACK( ccw[0] )
; 4758 :                      || IS_CCW_SENSE ( ccw[0] )
; 4759 :                     )
; 4760 :             )
; 4761 :                 DISPLAY_CCW( dev, ccw, addr, count, flags );

  00f6b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196613
  00f72	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00f77	c7 44 24 30 99
	12 00 00	 mov	 DWORD PTR [rsp+48], 4761 ; 00001299H
  00f7f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196614
  00f86	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00f8b	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  00f8f	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00f93	44 8b 4d 18	 mov	 r9d, DWORD PTR count$[rbp]
  00f97	44 8b 45 1c	 mov	 r8d, DWORD PTR addr$[rbp]
  00f9b	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR ccw$[rbp]
  00fa2	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00fa6	e8 00 00 00 00	 call	 _display_ccw
$LN70@z900_execu:
$LN66@z900_execu:

; 4762 :         }
; 4763 : 
; 4764 :         /* Channel program check if invalid Format-1 CCW             */
; 4765 :         /* SA22-7201-05:                                             */
; 4766 :         /*  pp. 15-23 -- 15-24, Channel_Command Word                 */
; 4767 :         /*  p. 15-25, Count                                          */
; 4768 :         /*  p. 16-25, Invalid Count, Format 1                        */
; 4769 :         if (ccwfmt == 1 &&                  /* Validate Format 1     */

  00fab	0f b6 45 0b	 movzx	 eax, BYTE PTR ccwfmt$[rbp]
  00faf	83 f8 01	 cmp	 eax, 1
  00fb2	75 3a		 jne	 SHORT $LN71@z900_execu
  00fb4	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  00fb8	83 f8 08	 cmp	 eax, 8
  00fbb	74 31		 je	 SHORT $LN71@z900_execu
  00fbd	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00fc1	0f b6 80 78 02
	00 00		 movzx	 eax, BYTE PTR [rax+632]
  00fc8	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00fcd	85 c0		 test	 eax, eax
  00fcf	74 1d		 je	 SHORT $LN71@z900_execu
  00fd1	83 7d 18 00	 cmp	 DWORD PTR count$[rbp], 0
  00fd5	75 17		 jne	 SHORT $LN71@z900_execu

; 4770 :             ((opcode != 0x08)              &&
; 4771 :              (dev->chained & CCW_FLAGS_CD) &&
; 4772 :              !count))
; 4773 :             {
; 4774 :                 chanstat = CSW_PROGC;

  00fd7	c6 45 09 20	 mov	 BYTE PTR chanstat$[rbp], 32 ; 00000020H

; 4775 :                 if (prefetch.seq)

  00fdb	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  00fe2	74 05		 je	 SHORT $LN72@z900_execu

; 4776 :                     goto prefetch;

  00fe4	e9 37 0f 00 00	 jmp	 $prefetch$333
$LN72@z900_execu:

; 4777 :                 goto breakchain;

  00fe9	e9 f4 16 00 00	 jmp	 $breakchain$332
$LN71@z900_execu:

; 4778 :             }
; 4779 : 
; 4780 :         /* Channel program check if invalid TIC opcode or invalid    */
; 4781 :         /* TIC Format-1 CCW                                          */
; 4782 :         /* SA22-7201-05:                                             */
; 4783 :         /*  p. 15-25, Figure 15-5. Command Code Assignment           */
; 4784 :         /*  p. 15-36, Figure 15-7. Command Codes and Flags           */
; 4785 :         /*  p. 15-37, Transfer in Channel                            */
; 4786 :         if (opcode == 0x08 ||               /* Validate TIC          */

  00fee	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  00ff2	83 f8 08	 cmp	 eax, 8
  00ff5	74 1c		 je	 SHORT $LN74@z900_execu
  00ff7	0f b6 45 0b	 movzx	 eax, BYTE PTR ccwfmt$[rbp]
  00ffb	85 c0		 test	 eax, eax
  00ffd	0f 85 04 01 00
	00		 jne	 $LN73@z900_execu
  01003	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  01007	83 e0 0f	 and	 eax, 15
  0100a	83 f8 08	 cmp	 eax, 8
  0100d	0f 85 f4 00 00
	00		 jne	 $LN73@z900_execu
$LN74@z900_execu:

; 4787 :             (ccwfmt == 0 &&
; 4788 :              ((opcode & 0x0F) == 0x08)))
; 4789 :         {
; 4790 :             if (ticaddr                  || /* No TIC-to-TIC         */
; 4791 :                 (addr & 0x03)            || /* Must be aligned DWORD */
; 4792 :                 (ccwfmt == 1 &&             /* Validate Format 1     */
; 4793 :                  (flags           ||
; 4794 :                   count))                ||

  01013	83 7d 78 00	 cmp	 DWORD PTR ticaddr$[rbp], 0
  01017	75 2c		 jne	 SHORT $LN76@z900_execu
  01019	8b 45 1c	 mov	 eax, DWORD PTR addr$[rbp]
  0101c	83 e0 03	 and	 eax, 3
  0101f	85 c0		 test	 eax, eax
  01021	75 22		 jne	 SHORT $LN76@z900_execu
  01023	0f b6 45 0b	 movzx	 eax, BYTE PTR ccwfmt$[rbp]
  01027	83 f8 01	 cmp	 eax, 1
  0102a	75 0e		 jne	 SHORT $LN77@z900_execu
  0102c	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  01030	85 c0		 test	 eax, eax
  01032	75 11		 jne	 SHORT $LN76@z900_execu
  01034	83 7d 18 00	 cmp	 DWORD PTR count$[rbp], 0
  01038	75 0b		 jne	 SHORT $LN76@z900_execu
$LN77@z900_execu:
  0103a	0f b7 45 50	 movzx	 eax, WORD PTR ticback$[rbp]
  0103e	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  01043	7e 30		 jle	 SHORT $LN75@z900_execu
$LN76@z900_execu:

; 4795 :                 ticback > 255               /* Exceeded TIC limit?   */
; 4796 :                 )
; 4797 :             {
; 4798 :                 chanstat = CSW_PROGC;

  01045	c6 45 09 20	 mov	 BYTE PTR chanstat$[rbp], 32 ; 00000020H

; 4799 :                 if (prefetch.seq)

  01049	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  01050	74 1e		 je	 SHORT $LN78@z900_execu

; 4800 :                 {
; 4801 :                     prefetch.ccwflags[ps] = 0;

  01052	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01055	c6 84 05 d0 12
	00 00 00	 mov	 BYTE PTR prefetch$[rbp+rax+4368], 0

; 4802 :                     prefetch.datalen[ps] = 0;

  0105d	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01060	c7 84 85 d0 06
	00 00 00 00 00
	00		 mov	 DWORD PTR prefetch$[rbp+rax*4+1296], 0

; 4803 :                     goto prefetch;

  0106b	e9 b0 0e 00 00	 jmp	 $prefetch$333
$LN78@z900_execu:

; 4804 :                 }
; 4805 :                 goto breakchain;

  01070	e9 6d 16 00 00	 jmp	 $breakchain$332
$LN75@z900_execu:

; 4806 :             }
; 4807 : 
; 4808 :             /* Reuse prefetch entry for next CCW */
; 4809 :             if (prefetch.seq)

  01075	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  0107c	74 59		 je	 SHORT $LN79@z900_execu

; 4810 :             {
; 4811 :                 prefetch.ccwaddr[ps] = 0;

  0107e	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01081	c7 84 85 d0 02
	00 00 00 00 00
	00		 mov	 DWORD PTR prefetch$[rbp+rax*4+272], 0

; 4812 :                 prefetch.ccwflags[ps] = 0;

  0108c	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  0108f	c6 84 05 d0 12
	00 00 00	 mov	 BYTE PTR prefetch$[rbp+rax+4368], 0

; 4813 :                 prefetch.ccwcount[ps] = 0;

  01097	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  0109a	33 c9		 xor	 ecx, ecx
  0109c	66 89 8c 45 d0
	13 00 00	 mov	 WORD PTR prefetch$[rbp+rax*2+4624], cx

; 4814 :                 prefetch.dataaddr[ps] = 0;

  010a4	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  010a7	48 c7 84 c5 d0
	0a 00 00 00 00
	00 00		 mov	 QWORD PTR prefetch$[rbp+rax*8+2320], 0

; 4815 :                 prefetch.datalen[ps] = 0;

  010b3	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  010b6	c7 84 85 d0 06
	00 00 00 00 00
	00		 mov	 DWORD PTR prefetch$[rbp+rax*4+1296], 0

; 4816 :                 ps--;

  010c1	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  010c4	ff c8		 dec	 eax
  010c6	89 45 10	 mov	 DWORD PTR ps$[rbp], eax

; 4817 :                 prefetch.seq--;

  010c9	8b 85 c0 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp]
  010cf	ff c8		 dec	 eax
  010d1	89 85 c0 01 00
	00		 mov	 DWORD PTR prefetch$[rbp], eax
$LN79@z900_execu:

; 4818 :             }
; 4819 : 
; 4820 :             /* Update backwards TIC counter */
; 4821 :             if (addr < ccwaddr)

  010d7	8b 45 24	 mov	 eax, DWORD PTR ccwaddr$[rbp]
  010da	39 45 1c	 cmp	 DWORD PTR addr$[rbp], eax
  010dd	73 0d		 jae	 SHORT $LN80@z900_execu

; 4822 :                 ticback++;

  010df	0f b7 45 50	 movzx	 eax, WORD PTR ticback$[rbp]
  010e3	66 ff c0	 inc	 ax
  010e6	66 89 45 50	 mov	 WORD PTR ticback$[rbp], ax
  010ea	eb 06		 jmp	 SHORT $LN81@z900_execu
$LN80@z900_execu:

; 4823 :             else
; 4824 :                 ticback = 0;

  010ec	33 c0		 xor	 eax, eax
  010ee	66 89 45 50	 mov	 WORD PTR ticback$[rbp], ax
$LN81@z900_execu:

; 4825 : 
; 4826 :             /* Set new CCW address (leaving the values of chained and
; 4827 :                code untouched to allow data-chaining through TIC)    */
; 4828 :             ticaddr = ccwaddr;

  010f2	8b 45 24	 mov	 eax, DWORD PTR ccwaddr$[rbp]
  010f5	89 45 78	 mov	 DWORD PTR ticaddr$[rbp], eax

; 4829 :             ccwaddr = addr;

  010f8	8b 45 1c	 mov	 eax, DWORD PTR addr$[rbp]
  010fb	89 45 24	 mov	 DWORD PTR ccwaddr$[rbp], eax

; 4830 :             chain = 1;

  010fe	c6 45 20 01	 mov	 BYTE PTR chain$[rbp], 1

; 4831 :             continue;

  01102	e9 b6 f8 ff ff	 jmp	 $LN2@z900_execu
$LN73@z900_execu:

; 4832 :         }
; 4833 :         ticaddr = 0;                    /* Reset the TIC-to-TIC flag */

  01107	c7 45 78 00 00
	00 00		 mov	 DWORD PTR ticaddr$[rbp], 0

; 4834 : 
; 4835 :         /* Reset TIC back counter if Read or Write CCW               */
; 4836 :         if (IS_CCW_WRITE(opcode) ||
; 4837 :             IS_CCW_READ(opcode)  ||

  0110e	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  01112	83 e0 03	 and	 eax, 3
  01115	83 f8 01	 cmp	 eax, 1
  01118	74 18		 je	 SHORT $LN83@z900_execu
  0111a	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  0111e	83 e0 03	 and	 eax, 3
  01121	83 f8 02	 cmp	 eax, 2
  01124	74 0c		 je	 SHORT $LN83@z900_execu
  01126	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  0112a	83 e0 0f	 and	 eax, 15
  0112d	83 f8 0c	 cmp	 eax, 12
  01130	75 06		 jne	 SHORT $LN82@z900_execu
$LN83@z900_execu:

; 4838 :             IS_CCW_RDBACK(opcode))
; 4839 :             ticback = 0;

  01132	33 c0		 xor	 eax, eax
  01134	66 89 45 50	 mov	 WORD PTR ticback$[rbp], ax
$LN82@z900_execu:

; 4840 : 
; 4841 :         /* At this point, the CCW now has "control" of the I/O       */
; 4842 :         /* operation (SA22-7201 p. 15-24, PCI). Signal I/O interrupt */
; 4843 :         /* if PCI flag is set                                        */
; 4844 :         if (flags & CCW_FLAGS_PCI)   /* -- Debug && !prefetch.seq -- */

  01138	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  0113c	83 e0 08	 and	 eax, 8
  0113f	85 c0		 test	 eax, eax
  01141	74 16		 je	 SHORT $LN84@z900_execu

; 4845 :         {
; 4846 :             ARCH_DEP(raise_pci) (dev, ccwkey, ccwfmt, ccwaddr);

  01143	44 8b 4d 24	 mov	 r9d, DWORD PTR ccwaddr$[rbp]
  01147	44 0f b6 45 0b	 movzx	 r8d, BYTE PTR ccwfmt$[rbp]
  0114c	0f b6 55 14	 movzx	 edx, BYTE PTR ccwkey$[rbp]
  01150	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01154	e8 00 00 00 00	 call	 z900_raise_pci
$LN84@z900_execu:

; 4847 :         }
; 4848 : 
; 4849 :         /* Validate basic CCW command                                */
; 4850 :         /* SA22-7201-05:                                             */
; 4851 :         /*  p. 15-25, Figure 15-5. Command Code Assignment           */
; 4852 :         /* Note: TIC validation not included as TIC has already been */
; 4853 :         /*       validated and processed.                            */
; 4854 :         if (!(dev->chained & CCW_FLAGS_CD) &&

  01159	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0115d	0f b6 80 78 02
	00 00		 movzx	 eax, BYTE PTR [rax+632]
  01164	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01169	85 c0		 test	 eax, eax
  0116b	75 5e		 jne	 SHORT $LN85@z900_execu
  0116d	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  01171	83 e0 0f	 and	 eax, 15
  01174	85 c0		 test	 eax, eax
  01176	74 3c		 je	 SHORT $LN86@z900_execu
  01178	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  0117c	83 e0 03	 and	 eax, 3
  0117f	83 f8 01	 cmp	 eax, 1
  01182	74 47		 je	 SHORT $LN85@z900_execu
  01184	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  01188	83 e0 03	 and	 eax, 3
  0118b	83 f8 02	 cmp	 eax, 2
  0118e	74 3b		 je	 SHORT $LN85@z900_execu
  01190	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  01194	83 e0 0f	 and	 eax, 15
  01197	83 f8 0c	 cmp	 eax, 12
  0119a	74 2f		 je	 SHORT $LN85@z900_execu
  0119c	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  011a0	83 e0 03	 and	 eax, 3
  011a3	83 f8 03	 cmp	 eax, 3
  011a6	74 23		 je	 SHORT $LN85@z900_execu
  011a8	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  011ac	83 e0 0f	 and	 eax, 15
  011af	83 f8 04	 cmp	 eax, 4
  011b2	74 17		 je	 SHORT $LN85@z900_execu
$LN86@z900_execu:

; 4855 :             !((opcode & 0x0F) != 0      &&
; 4856 :               (IS_CCW_WRITE(opcode)   ||
; 4857 :                IS_CCW_READ(opcode)    ||
; 4858 :                IS_CCW_RDBACK(opcode)  ||
; 4859 :                IS_CCW_CONTROL(opcode) ||
; 4860 :                IS_CCW_SENSE(opcode))))
; 4861 :         {
; 4862 :             chanstat = CSW_PROGC;

  011b4	c6 45 09 20	 mov	 BYTE PTR chanstat$[rbp], 32 ; 00000020H

; 4863 :             if (prefetch.seq)

  011b8	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  011bf	74 05		 je	 SHORT $LN87@z900_execu

; 4864 :                 goto prefetch;

  011c1	e9 5a 0d 00 00	 jmp	 $prefetch$333
$LN87@z900_execu:

; 4865 :             goto breakchain;

  011c6	e9 17 15 00 00	 jmp	 $breakchain$332
$LN85@z900_execu:

; 4866 :         }
; 4867 : 
; 4868 :         /* Validate chain data (CD) flag                             */
; 4869 :         /* SA22-7201-05:                                             */
; 4870 :         /*  p. 16-26, program check if suspend specified             */
; 4871 :         /*  p. 15-24, Chain-Data (CD) Flag                           */
; 4872 :         if (flags & CCW_FLAGS_CD)

  011cb	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  011cf	25 80 00 00 00	 and	 eax, 128		; 00000080H
  011d4	85 c0		 test	 eax, eax
  011d6	74 2c		 je	 SHORT $LN88@z900_execu

; 4873 :         {
; 4874 :             if (flags & CCW_FLAGS_SUSP)

  011d8	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  011dc	83 e0 02	 and	 eax, 2
  011df	85 c0		 test	 eax, eax
  011e1	74 17		 je	 SHORT $LN89@z900_execu

; 4875 :             {
; 4876 :                 chanstat = CSW_PROGC;

  011e3	c6 45 09 20	 mov	 BYTE PTR chanstat$[rbp], 32 ; 00000020H

; 4877 :                 if (prefetch.seq)

  011e7	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  011ee	74 05		 je	 SHORT $LN90@z900_execu

; 4878 :                     goto prefetch;

  011f0	e9 2b 0d 00 00	 jmp	 $prefetch$333
$LN90@z900_execu:

; 4879 :                 goto breakchain;

  011f5	e9 e8 14 00 00	 jmp	 $breakchain$332
$LN89@z900_execu:

; 4880 :             }
; 4881 : 
; 4882 :             /* Turn off suppress indicator bits for processing       */
; 4883 :             /* purposes as setting is ignored with CD.               */
; 4884 :             flags &= ~CCW_FLAGS_SLI;

  011fa	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  011fe	83 e0 df	 and	 eax, -33		; ffffffffffffffdfH
  01201	88 45 08	 mov	 BYTE PTR flags$[rbp], al
$LN88@z900_execu:

; 4885 :         }
; 4886 : 
; 4887 :         /* Validate command chain (CC) flag                          */
; 4888 :         /* SA22-7201-05:                                             */
; 4889 :         /*  p. 15-24, Chain-Command (CC) Flag                        */
; 4890 :         /*-------------------------------------------------------------
; 4891 :         //
; 4892 :         // Note: With CD check first, this test will always be false.
; 4893 :         //       Code left here in comment for documentation purposes.
; 4894 :         //
; 4895 :         // if (flags & (CCW_FLAGS_CC | CCW_FLAGS_CD) ==
; 4896 :         //             (CCW_FLAGS_CC | CCW_FLAGS_CD))
; 4897 :         //     flags &= ~CCW_FLAGS_CC;
; 4898 :         -------------------------------------------------------------*/
; 4899 : 
; 4900 :         /* Validate suppress length indication (SLI) flag            */
; 4901 :         /* SA22-7201-05:                                             */
; 4902 :         /*  p. 15-24, Supress-Length-Indication (SLI) Flag           */
; 4903 :         /*-------------------------------------------------------------
; 4904 :         //
; 4905 :         // Note: With CD check first, this test will always be false.
; 4906 :         //       Code left here in comment for documentation purposes.
; 4907 :         //
; 4908 :         // if (flags & (CCW_FLAGS_CD | CCW_FLAGS_SLI)) ==
; 4909 :         //             (CCW_FLAGS_CD | CCW_FLAGS_SLI)))
; 4910 :         //     flags &= ~CCW_FLAGS_SLI;
; 4911 :         -------------------------------------------------------------*/
; 4912 : 
; 4913 :         /* Validate skip flag                                        */
; 4914 :         /* SA22-7201-05:                                             */
; 4915 :         /*  p. 15-24, Skip (SKIP) Flag                               */
; 4916 :         /*-------------------------------------------------------------
; 4917 :         //
; 4918 :         // Note: Check against MIDAW down in MIDAW validation section.
; 4919 :         //       Code left here in comment for documentation purposes.
; 4920 :         //
; 4921 :         // if (flags & CCW_FLAGS_SKIP)
; 4922 :         // {}
; 4923 :         -------------------------------------------------------------*/
; 4924 : 
; 4925 :         /* Validate program controlled interruption (PCI) flag       */
; 4926 :         /* SA22-7201-05:                                             */
; 4927 :         /*  p. 15-24, Program Controlled Interruption (PCI) Flag     */
; 4928 :         /*-------------------------------------------------------------
; 4929 :         //
; 4930 :         // Note: No validation required.
; 4931 :         //       Code left here in comment for documentation purposes.
; 4932 :         //
; 4933 :         // if (flags & CCW_FLAGS_PCI)
; 4934 :         // {}
; 4935 :         -------------------------------------------------------------*/
; 4936 : 
; 4937 : #if !defined(FEATURE_MIDAW_FACILITY)
; 4938 :         /* Channel program check if MIDAW not installed */
; 4939 :         if (flags & CCW_FLAGS_MIDAW)
; 4940 :         {
; 4941 :             chanstat = CSW_PROGC;
; 4942 :             if (prefetch.seq)
; 4943 :                 goto prefetch;
; 4944 :             goto breakchain;
; 4945 :         }
; 4946 : #endif /*!defined(FEATURE_MIDAW_FACILITY)*/
; 4947 : 
; 4948 : #if defined(FEATURE_MIDAW_FACILITY)
; 4949 :         /* Channel program check if MIDAW not enabled in ORB, or     */
; 4950 :         /* with SKIP or IDA specified                                */
; 4951 :         if ((flags & CCW_FLAGS_MIDAW) &&

  01204	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  01208	83 e0 01	 and	 eax, 1
  0120b	85 c0		 test	 eax, eax
  0120d	74 34		 je	 SHORT $LN91@z900_execu
  0120f	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01213	0f b6 80 d3 02
	00 00		 movzx	 eax, BYTE PTR [rax+723]
  0121a	83 e0 40	 and	 eax, 64			; 00000040H
  0121d	85 c0		 test	 eax, eax
  0121f	74 0b		 je	 SHORT $LN92@z900_execu
  01221	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  01225	83 e0 14	 and	 eax, 20
  01228	85 c0		 test	 eax, eax
  0122a	74 17		 je	 SHORT $LN91@z900_execu
$LN92@z900_execu:

; 4952 :             ((dev->orb.flag7 & ORB7_D) == 0 ||
; 4953 :              (flags & (CCW_FLAGS_SKIP | CCW_FLAGS_IDA))))
; 4954 :         {
; 4955 :             chanstat = CSW_PROGC;

  0122c	c6 45 09 20	 mov	 BYTE PTR chanstat$[rbp], 32 ; 00000020H

; 4956 :             if (prefetch.seq)

  01230	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  01237	74 05		 je	 SHORT $LN93@z900_execu

; 4957 :                 goto prefetch;

  01239	e9 e2 0c 00 00	 jmp	 $prefetch$333
$LN93@z900_execu:

; 4958 :             goto breakchain;

  0123e	e9 9f 14 00 00	 jmp	 $breakchain$332
$LN91@z900_execu:

; 4959 :         }
; 4960 : #endif /*defined(FEATURE_MIDAW_FACILITY)*/
; 4961 : 
; 4962 :         /* Suspend supported prior to GA22-7000-10 for the S/370     */
; 4963 :         /* Suspend channel program if suspend flag is set */
; 4964 :         if (flags & CCW_FLAGS_SUSP)

  01243	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  01247	83 e0 02	 and	 eax, 2
  0124a	85 c0		 test	 eax, eax
  0124c	0f 84 2b 04 00
	00		 je	 $LN94@z900_execu

; 4965 :         {
; 4966 :             /* Channel program check if the ORB suspend control bit
; 4967 :                was zero, or if this is a data chained CCW */
; 4968 :             if ((dev->orb.flag4 & ORB4_S) == 0
; 4969 :                 || (dev->chained & CCW_FLAGS_CD))

  01252	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01256	0f b6 80 d0 02
	00 00		 movzx	 eax, BYTE PTR [rax+720]
  0125d	83 e0 08	 and	 eax, 8
  01260	85 c0		 test	 eax, eax
  01262	74 14		 je	 SHORT $LN96@z900_execu
  01264	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01268	0f b6 80 78 02
	00 00		 movzx	 eax, BYTE PTR [rax+632]
  0126f	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01274	85 c0		 test	 eax, eax
  01276	74 17		 je	 SHORT $LN95@z900_execu
$LN96@z900_execu:

; 4970 :             {
; 4971 :                 chanstat = CSW_PROGC;

  01278	c6 45 09 20	 mov	 BYTE PTR chanstat$[rbp], 32 ; 00000020H

; 4972 :                 if (prefetch.seq)

  0127c	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  01283	74 05		 je	 SHORT $LN97@z900_execu

; 4973 :                     goto prefetch;

  01285	e9 96 0c 00 00	 jmp	 $prefetch$333
$LN97@z900_execu:

; 4974 :                 goto breakchain;

  0128a	e9 53 14 00 00	 jmp	 $breakchain$332
$LN95@z900_execu:
$LN12@z900_execu:

; 4975 :             }
; 4976 : 
; 4977 :             IODELAY(dev);

  0128f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01296	83 b8 e0 13 00
	00 00		 cmp	 DWORD PTR [rax+5088], 0
  0129d	7e 2d		 jle	 SHORT $LN98@z900_execu
  0129f	b8 01 00 00 00	 mov	 eax, 1
  012a4	48 6b c0 0a	 imul	 rax, rax, 10
  012a8	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  012ac	0f b6 84 01 6c
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1388]
  012b4	83 f8 20	 cmp	 eax, 32			; 00000020H
  012b7	75 13		 jne	 SHORT $LN98@z900_execu
  012b9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  012c0	8b 88 e0 13 00
	00		 mov	 ecx, DWORD PTR [rax+5088]
  012c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN98@z900_execu:
  012cc	33 c0		 xor	 eax, eax
  012ce	85 c0		 test	 eax, eax
  012d0	75 bd		 jne	 SHORT $LN12@z900_execu

; 4978 : 
; 4979 :             /* If halt or clear, abort suspend operation */
; 4980 :             if (dev->scsw.flag2 & (SCSW2_AC_HALT | SCSW2_AC_CLEAR))

  012d2	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  012d6	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  012dd	83 e0 03	 and	 eax, 3
  012e0	85 c0		 test	 eax, eax
  012e2	74 1c		 je	 SHORT $LN99@z900_execu

; 4981 :             {
; 4982 :                 if (dev->scsw.flag2 & SCSW2_AC_HALT)

  012e4	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  012e8	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  012ef	83 e0 02	 and	 eax, 2
  012f2	85 c0		 test	 eax, eax
  012f4	74 05		 je	 SHORT $LN100@z900_execu

; 4983 :                     goto execute_halt;

  012f6	e9 09 f8 ff ff	 jmp	 $execute_halt$330
$LN100@z900_execu:

; 4984 :                 goto execute_clear;

  012fb	e9 1a f7 ff ff	 jmp	 $execute_clear$329
$LN99@z900_execu:

; 4985 :             }
; 4986 : 
; 4987 :             /* Call the i/o suspend exit */
; 4988 :             if (dev->hnd->suspend) (dev->hnd->suspend) (dev);

  01300	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01304	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0130b	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  01310	74 12		 je	 SHORT $LN101@z900_execu
  01312	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01316	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0131d	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01321	ff 50 40	 call	 QWORD PTR [rax+64]
$LN101@z900_execu:

; 4989 : 
; 4990 :             OBTAIN_INTLOCK(NULL);

  01324	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196646
  0132b	33 c9		 xor	 ecx, ecx
  0132d	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 4991 :             obtain_lock (&dev->lock);

  01332	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01336	48 83 c0 38	 add	 rax, 56			; 00000038H
  0133a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196647
  01341	48 8b c8	 mov	 rcx, rax
  01344	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4992 : 
; 4993 :             /* Suspend the device if not already resume pending */
; 4994 :             if (!(dev->scsw.flag2 & (SCSW2_AC_RESUM)))

  0134a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0134e	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  01355	83 e0 08	 and	 eax, 8
  01358	85 c0		 test	 eax, eax
  0135a	0f 85 f7 02 00
	00		 jne	 $LN102@z900_execu

; 4995 :             {
; 4996 :                 /* Clean up device and complete suspension exit */
; 4997 :                 clear_subchannel_busy(dev);

  01360	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01364	e8 00 00 00 00	 call	 clear_subchannel_busy

; 4998 : 
; 4999 :                 /* Set the subchannel status word to suspended       */
; 5000 :                 /* SA22-7201-05:                                     */
; 5001 :                 /*  p. 16-15, Subchannel-Active (Bit 24)             */
; 5002 :                 /*  pp. 16-15 -- 16-16, Device-Active (Bit 25)       */
; 5003 :                 /*  p. 16-16, Suspended (Bit 26)                     */
; 5004 :                 /*  p. 16-16, Alert Status (Bit 27)                  */
; 5005 :                 /*  p. 16-17, Intermediate Status (Bit 28)           */
; 5006 :                 /*  p. 16-18, Status-Pending (Bit 31)                */
; 5007 :                 dev->scsw.flag3 &= ~(SCSW3_AC_SCHAC |

  01369	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0136d	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  01374	25 3f ff ff ff	 and	 eax, -193		; ffffffffffffff3fH
  01379	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0137d	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 5008 :                                      SCSW3_AC_DEVAC);
; 5009 :                 dev->scsw.flag3 |= SCSW3_AC_SUSP;

  01383	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01387	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  0138e	83 c8 20	 or	 eax, 32			; 00000020H
  01391	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01395	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 5010 :                 /* Principles violation. Some operating systems use
; 5011 :                  * CLI to check for suspend, intermediate and pending
; 5012 :                  * status (x'29') instead of the Principles statement
; 5013 :                  * with alert status set (x'39'). This also appears to
; 5014 :                  * be consistent with older machines.
; 5015 :                  * FIXME: Place conformance in user configuration?
; 5016 :                  *        flag3 |= SCSW3_SC_ALERT;
; 5017 :                  */
; 5018 : 
; 5019 :                 dev->scsw.unitstat = 0;

  0139b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0139f	c6 80 10 03 00
	00 00		 mov	 BYTE PTR [rax+784], 0

; 5020 : 
; 5021 :                 if (flags & CCW_FLAGS_PCI)

  013a6	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  013aa	83 e0 08	 and	 eax, 8
  013ad	85 c0		 test	 eax, eax
  013af	74 3d		 je	 SHORT $LN103@z900_execu

; 5022 :                 {
; 5023 :                     dev->scsw.chanstat   = CSW_PCI;

  013b1	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  013b5	c6 80 11 03 00
	00 80		 mov	 BYTE PTR [rax+785], 128	; 00000080H

; 5024 :                     dev->scsw.flag3     |= SCSW3_SC_INTER   |

  013bc	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  013c0	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  013c7	83 c8 09	 or	 eax, 9
  013ca	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  013ce	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 5025 :                                            SCSW3_SC_PEND;
; 5026 :                     dev->pciscsw.flag3  &= ~SCSW3_SC_PEND;

  013d4	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  013d8	0f b6 80 17 03
	00 00		 movzx	 eax, BYTE PTR [rax+791]
  013df	83 e0 fe	 and	 eax, -2
  013e2	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  013e6	88 81 17 03 00
	00		 mov	 BYTE PTR [rcx+791], al

; 5027 :                 }

  013ec	eb 35		 jmp	 SHORT $LN104@z900_execu
$LN103@z900_execu:

; 5028 :                 else
; 5029 :                 {
; 5030 :                     dev->scsw.chanstat   = 0;

  013ee	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  013f2	c6 80 11 03 00
	00 00		 mov	 BYTE PTR [rax+785], 0

; 5031 :                     if (!(dev->scsw.flag1 & SCSW1_U))

  013f9	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  013fd	0f b6 80 09 03
	00 00		 movzx	 eax, BYTE PTR [rax+777]
  01404	83 e0 08	 and	 eax, 8
  01407	85 c0		 test	 eax, eax
  01409	75 18		 jne	 SHORT $LN105@z900_execu

; 5032 :                         dev->scsw.flag3 |= SCSW3_SC_INTER   |

  0140b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0140f	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  01416	83 c8 09	 or	 eax, 9
  01419	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0141d	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al
$LN105@z900_execu:
$LN104@z900_execu:

; 5033 :                                            SCSW3_SC_PEND;
; 5034 :                 }
; 5035 : 
; 5036 :                 STORE_HW(dev->scsw.count,count);

  01423	0f b7 4d 18	 movzx	 ecx, WORD PTR count$[rbp]
  01427	e8 00 00 00 00	 call	 _byteswap_ushort
  0142c	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01430	48 81 c1 12 03
	00 00		 add	 rcx, 786		; 00000312H
  01437	0f b7 d0	 movzx	 edx, ax
  0143a	e8 00 00 00 00	 call	 store_hw_noswap

; 5037 : 
; 5038 :                 /* Update local copy of ORB */
; 5039 :                 STORE_FW(dev->orb.ccwaddr, (ccwaddr-8));

  0143f	8b 45 24	 mov	 eax, DWORD PTR ccwaddr$[rbp]
  01442	83 e8 08	 sub	 eax, 8
  01445	8b c8		 mov	 ecx, eax
  01447	e8 00 00 00 00	 call	 _byteswap_ulong
  0144c	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01450	48 81 c1 d4 02
	00 00		 add	 rcx, 724		; 000002d4H
  01457	8b d0		 mov	 edx, eax
  01459	e8 00 00 00 00	 call	 store_fw_noswap

; 5040 : 
; 5041 :                 /* Preserve CCW execution variables for validation */
; 5042 :                 dev->ccwaddr = ccwaddr;

  0145e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01462	8b 4d 24	 mov	 ecx, DWORD PTR ccwaddr$[rbp]
  01465	89 88 80 02 00
	00		 mov	 DWORD PTR [rax+640], ecx

; 5043 :                 dev->idapmask = idapmask;

  0146b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0146f	0f b7 4d 44	 movzx	 ecx, WORD PTR idapmask$[rbp]
  01473	66 89 88 84 02
	00 00		 mov	 WORD PTR [rax+644], cx

; 5044 :                 dev->idawfmt = idawfmt;

  0147a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0147e	0f b6 4d 16	 movzx	 ecx, BYTE PTR idawfmt$[rbp]
  01482	88 88 86 02 00
	00		 mov	 BYTE PTR [rax+646], cl

; 5045 :                 dev->ccwfmt = ccwfmt;

  01488	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0148c	0f b6 4d 0b	 movzx	 ecx, BYTE PTR ccwfmt$[rbp]
  01490	88 88 87 02 00
	00		 mov	 BYTE PTR [rax+647], cl

; 5046 :                 dev->ccwkey = ccwkey;

  01496	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0149a	0f b6 4d 14	 movzx	 ecx, BYTE PTR ccwkey$[rbp]
  0149e	88 88 88 02 00
	00		 mov	 BYTE PTR [rax+648], cl

; 5047 : 
; 5048 :                 /* Turn on the "suspended" bit.  This enables remote
; 5049 :                  * systems to use the device while we're waiting
; 5050 :                  */
; 5051 :                 dev->suspended = 1;

  014a4	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  014a8	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  014ae	0f ba e8 15	 bts	 eax, 21
  014b2	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  014b6	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 5052 : 
; 5053 :                 /* Trace suspension point */
; 5054 :                 if (unlikely( CCW_TRACING_ACTIVE( dev, tracethis )))

  014bc	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  014c0	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  014c6	c1 e8 0f	 shr	 eax, 15
  014c9	83 e0 01	 and	 eax, 1
  014cc	85 c0		 test	 eax, eax
  014ce	75 14		 jne	 SHORT $LN268@z900_execu
  014d0	0f b6 45 15	 movzx	 eax, BYTE PTR tracethis$[rbp]
  014d4	85 c0		 test	 eax, eax
  014d6	75 0c		 jne	 SHORT $LN268@z900_execu
  014d8	c7 85 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv932[rbp], 0
  014e2	eb 0a		 jmp	 SHORT $LN271@z900_execu
$LN268@z900_execu:
  014e4	c7 85 b0 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv932[rbp], 1
$LN271@z900_execu:
  014ee	83 bd b0 00 00
	00 00		 cmp	 DWORD PTR tv932[rbp], 0
  014f5	0f 84 d3 00 00
	00		 je	 $LN106@z900_execu

; 5055 :                 {
; 5056 :                     if (dev->ccwtrace && sysblk.traceFILE)

  014fb	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  014ff	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01505	c1 e8 0f	 shr	 eax, 15
  01508	83 e0 01	 and	 eax, 1
  0150b	85 c0		 test	 eax, eax
  0150d	74 20		 je	 SHORT $LN107@z900_execu
  0150f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01516	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  0151e	74 0f		 je	 SHORT $LN107@z900_execu

; 5057 :                         tf_1310( dev );

  01520	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01524	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1310
  0152a	e9 9f 00 00 00	 jmp	 $LN108@z900_execu
$LN107@z900_execu:

; 5058 :                     else
; 5059 :                         // "%1d:%04X CHAN: suspended"
; 5060 :                         WRMSG( HHC01310, "I", LCSS_DEVNUM );

  0152f	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  01534	74 10		 je	 SHORT $LN272@z900_execu
  01536	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0153a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0153e	89 85 b4 00 00
	00		 mov	 DWORD PTR tv944[rbp], eax
  01544	eb 0a		 jmp	 SHORT $LN273@z900_execu
$LN272@z900_execu:
  01546	c7 85 b4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv944[rbp], 0
$LN273@z900_execu:
  01550	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  01555	74 12		 je	 SHORT $LN274@z900_execu
  01557	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0155b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0155f	d1 f8		 sar	 eax, 1
  01561	89 85 b8 00 00
	00		 mov	 DWORD PTR tv950[rbp], eax
  01567	eb 0a		 jmp	 SHORT $LN275@z900_execu
$LN274@z900_execu:
  01569	c7 85 b8 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv950[rbp], 0
$LN275@z900_execu:
  01573	b9 01 00 00 00	 mov	 ecx, 1
  01578	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0157e	8b 8d b4 00 00
	00		 mov	 ecx, DWORD PTR tv944[rbp]
  01584	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01588	8b 8d b8 00 00
	00		 mov	 ecx, DWORD PTR tv950[rbp]
  0158e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01592	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196655
  01599	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0159e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196656
  015a5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  015aa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  015af	41 b9 03 00 00
	00		 mov	 r9d, 3
  015b5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196657
  015bc	ba c4 13 00 00	 mov	 edx, 5060		; 000013c4H
  015c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196658
  015c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN108@z900_execu:
$LN106@z900_execu:

; 5061 :                 }
; 5062 : 
; 5063 :                 /* Present the interrupt and return */
; 5064 :                 if (dev->scsw.flag3 & SCSW3_SC_PEND)

  015ce	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  015d2	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  015d9	83 e0 01	 and	 eax, 1
  015dc	85 c0		 test	 eax, eax
  015de	74 0b		 je	 SHORT $LN109@z900_execu

; 5065 :                     queue_io_interrupt_and_update_status_locked(dev,FALSE);

  015e0	33 d2		 xor	 edx, edx
  015e2	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  015e6	e8 00 00 00 00	 call	 queue_io_interrupt_and_update_status_locked
$LN109@z900_execu:

; 5066 : 
; 5067 :                 release_lock(&dev->lock);

  015eb	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  015ef	48 83 c0 38	 add	 rax, 56			; 00000038H
  015f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196660
  015fa	48 8b c8	 mov	 rcx, rax
  015fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5068 :                 RELEASE_INTLOCK(NULL);

  01603	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196661
  0160a	33 c9		 xor	 ecx, ecx
  0160c	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 5069 : 
; 5070 :                 if (dev->scsw.flag2 & (SCSW2_AC_CLEAR | SCSW2_AC_HALT))

  01611	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01615	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  0161c	83 e0 03	 and	 eax, 3
  0161f	85 c0		 test	 eax, eax
  01621	74 1c		 je	 SHORT $LN110@z900_execu

; 5071 :                 {
; 5072 :                     if (dev->scsw.flag2 & SCSW2_AC_CLEAR)

  01623	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01627	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  0162e	83 e0 01	 and	 eax, 1
  01631	85 c0		 test	 eax, eax
  01633	74 05		 je	 SHORT $LN111@z900_execu

; 5073 :                         goto execute_clear;

  01635	e9 e0 f3 ff ff	 jmp	 $execute_clear$329
$LN111@z900_execu:

; 5074 :                     goto execute_halt;

  0163a	e9 c5 f4 ff ff	 jmp	 $execute_halt$330
$LN110@z900_execu:

; 5075 :                 }
; 5076 : 
; 5077 :                 return execute_ccw_chain_fast_return( iobuf, &iobuf_initial, NULL );

  0163f	45 33 c0	 xor	 r8d, r8d
  01642	48 8d 95 00 20
	00 00		 lea	 rdx, QWORD PTR iobuf_initial$[rbp]
  01649	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  0164d	e8 00 00 00 00	 call	 execute_ccw_chain_fast_return
  01652	e9 9f 21 00 00	 jmp	 $LN1@z900_execu
$LN102@z900_execu:

; 5078 :             }
; 5079 : 
; 5080 :             release_lock (&dev->lock);

  01657	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0165b	48 83 c0 38	 add	 rax, 56			; 00000038H
  0165f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196664
  01666	48 8b c8	 mov	 rcx, rax
  01669	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5081 :             RELEASE_INTLOCK(NULL);

  0166f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196665
  01676	33 c9		 xor	 ecx, ecx
  01678	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN94@z900_execu:

; 5082 : 
; 5083 :         } /* end if(CCW_FLAGS_SUSP) */
; 5084 : 
; 5085 :         /* Update current CCW opcode, unless data chaining */
; 5086 :         if (!(skip_ccws ||

  0167d	83 7d 64 00	 cmp	 DWORD PTR skip_ccws$[rbp], 0
  01681	75 51		 jne	 SHORT $LN112@z900_execu
  01683	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01687	0f b6 80 78 02
	00 00		 movzx	 eax, BYTE PTR [rax+632]
  0168e	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01693	85 c0		 test	 eax, eax
  01695	75 3d		 jne	 SHORT $LN112@z900_execu

; 5087 :               (dev->chained & CCW_FLAGS_CD)))
; 5088 :         {
; 5089 :             dev->prevcode = dev->code;

  01697	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0169b	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0169f	0f b6 89 7a 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+634]
  016a6	88 88 7b 02 00
	00		 mov	 BYTE PTR [rax+635], cl

; 5090 :             dev->code = opcode;

  016ac	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  016b0	0f b6 4d 0a	 movzx	 ecx, BYTE PTR opcode$[rbp]
  016b4	88 88 7a 02 00
	00		 mov	 BYTE PTR [rax+634], cl

; 5091 : 
; 5092 :             /* Allow the device handler to determine whether this is
; 5093 :                an immediate CCW (i.e. CONTROL with no data transfer) */
; 5094 :             dev->is_immed = IS_CCW_IMMEDIATE(dev, opcode);

  016ba	0f b6 55 0a	 movzx	 edx, BYTE PTR opcode$[rbp]
  016be	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  016c2	e8 00 00 00 00	 call	 IS_CCW_IMMEDIATE
  016c7	0f b6 c0	 movzx	 eax, al
  016ca	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  016ce	89 81 a0 02 00
	00		 mov	 DWORD PTR [rcx+672], eax
$LN112@z900_execu:

; 5095 : 
; 5096 :             /*-- TBD ------------------------------------------------*/
; 5097 :             /*                                                       */
; 5098 :             /*   Initiation and check of opcode with control unit    */
; 5099 :             /*   belongs here.                                       */
; 5100 :             /*                                                       */
; 5101 :             /*-------------------------------------------------------*/
; 5102 : 
; 5103 :         }
; 5104 : 
; 5105 :         /* If immediate, chain data and address are ignored */
; 5106 :         if (dev->is_immed)

  016d4	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  016d8	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  016df	74 2b		 je	 SHORT $LN113@z900_execu

; 5107 :         {
; 5108 :             flags &= ~CCW_FLAGS_CD;

  016e1	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  016e5	0f ba f0 07	 btr	 eax, 7
  016e9	88 45 08	 mov	 BYTE PTR flags$[rbp], al

; 5109 :             dev->chained &= ~CCW_FLAGS_CD;

  016ec	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  016f0	0f b6 80 78 02
	00 00		 movzx	 eax, BYTE PTR [rax+632]
  016f7	0f ba f0 07	 btr	 eax, 7
  016fb	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  016ff	88 81 78 02 00
	00		 mov	 BYTE PTR [rcx+632], al

; 5110 :             addr = 0;

  01705	c7 45 1c 00 00
	00 00		 mov	 DWORD PTR addr$[rbp], 0
$LN113@z900_execu:

; 5111 :         }
; 5112 : 
; 5113 :         /* Channel program check if CCW refers to invalid storage    */
; 5114 :         /* SA22-7201-05:                                             */
; 5115 :         /*  p. 15-24, Data Address                                   */
; 5116 :         /*  p. 15-25, Count                                          */
; 5117 :         /*  pp. 15-25 -- 15-27, Designation of Storage Area          */
; 5118 :         if ((count &&
; 5119 :              (!(flags & CCW_FLAGS_SKIP)) &&
; 5120 :              (((flags & CCW_FLAGS_IDA)   &&
; 5121 :                ((addr & 0x03) ||
; 5122 :                 CHADDRCHK(addr, dev)))                      ||
; 5123 : #if defined(FEATURE_MIDAW_FACILITY)
; 5124 :               ((flags & CCW_FLAGS_MIDAW) &&
; 5125 :                ((addr & 0x0F) ||
; 5126 :                 CHADDRCHK(addr, dev)))                      ||
; 5127 : #endif /*defined(FEATURE_MIDAW_FACILITY)*/
; 5128 :               (!(flags & (CCW_FLAGS_IDA | CCW_FLAGS_MIDAW))     &&
; 5129 :                ((ccwfmt == 0 &&
; 5130 :                  ((addr & ~0x00FFFFFF)                      ||
; 5131 :                   ((addr + (count - 1)) & ~0x00FFFFFF)      ||
; 5132 :                   CHADDRCHK((addr + (count - 1)), dev)))    ||
; 5133 : #if defined(FEATURE_CHANNEL_SUBSYSTEM)
; 5134 :                 (ccwfmt == 1 &&
; 5135 :                  ((addr & ~0x7FFFFFFF)                      ||
; 5136 :                   ((addr + count - 1) & ~0x7FFFFFFF)        ||
; 5137 :                   CHADDRCHK((addr + (count - 1)), dev)))        ||
; 5138 : #endif /*defined(FEATURE_CHANNEL_SUBSYSTEM)*/
; 5139 :                  CHADDRCHK(addr, dev)))))
; 5140 : #if defined(FEATURE_CHANNEL_SUBSYSTEM)
; 5141 :          || (!count &&

  0170c	83 7d 18 00	 cmp	 DWORD PTR count$[rbp], 0
  01710	0f 84 41 03 00
	00		 je	 $LN116@z900_execu
  01716	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  0171a	83 e0 10	 and	 eax, 16
  0171d	85 c0		 test	 eax, eax
  0171f	0f 85 32 03 00
	00		 jne	 $LN116@z900_execu
  01725	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  01729	83 e0 04	 and	 eax, 4
  0172c	85 c0		 test	 eax, eax
  0172e	0f 84 86 00 00
	00		 je	 $LN117@z900_execu
  01734	8b 45 1c	 mov	 eax, DWORD PTR addr$[rbp]
  01737	83 e0 03	 and	 eax, 3
  0173a	85 c0		 test	 eax, eax
  0173c	0f 85 31 03 00
	00		 jne	 $LN115@z900_execu
  01742	8b 45 1c	 mov	 eax, DWORD PTR addr$[rbp]
  01745	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01749	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  01750	0f 87 1d 03 00
	00		 ja	 $LN115@z900_execu
  01756	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0175a	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  01761	83 e0 10	 and	 eax, 16
  01764	85 c0		 test	 eax, eax
  01766	74 52		 je	 SHORT $LN118@z900_execu
  01768	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0176c	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  01773	83 e0 20	 and	 eax, 32			; 00000020H
  01776	85 c0		 test	 eax, eax
  01778	74 17		 je	 SHORT $LN119@z900_execu
  0177a	8b 45 1c	 mov	 eax, DWORD PTR addr$[rbp]
  0177d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01784	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  0178b	0f 82 e2 02 00
	00		 jb	 $LN115@z900_execu
$LN119@z900_execu:
  01791	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01795	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0179c	83 e0 40	 and	 eax, 64			; 00000040H
  0179f	85 c0		 test	 eax, eax
  017a1	74 17		 je	 SHORT $LN120@z900_execu
  017a3	8b 45 1c	 mov	 eax, DWORD PTR addr$[rbp]
  017a6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  017ad	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  017b4	0f 83 b9 02 00
	00		 jae	 $LN115@z900_execu
$LN120@z900_execu:
$LN118@z900_execu:
$LN117@z900_execu:
  017ba	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  017be	83 e0 01	 and	 eax, 1
  017c1	85 c0		 test	 eax, eax
  017c3	0f 84 86 00 00
	00		 je	 $LN121@z900_execu
  017c9	8b 45 1c	 mov	 eax, DWORD PTR addr$[rbp]
  017cc	83 e0 0f	 and	 eax, 15
  017cf	85 c0		 test	 eax, eax
  017d1	0f 85 9c 02 00
	00		 jne	 $LN115@z900_execu
  017d7	8b 45 1c	 mov	 eax, DWORD PTR addr$[rbp]
  017da	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  017de	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  017e5	0f 87 88 02 00
	00		 ja	 $LN115@z900_execu
  017eb	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  017ef	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  017f6	83 e0 10	 and	 eax, 16
  017f9	85 c0		 test	 eax, eax
  017fb	74 52		 je	 SHORT $LN122@z900_execu
  017fd	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01801	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  01808	83 e0 20	 and	 eax, 32			; 00000020H
  0180b	85 c0		 test	 eax, eax
  0180d	74 17		 je	 SHORT $LN123@z900_execu
  0180f	8b 45 1c	 mov	 eax, DWORD PTR addr$[rbp]
  01812	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01819	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  01820	0f 82 4d 02 00
	00		 jb	 $LN115@z900_execu
$LN123@z900_execu:
  01826	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0182a	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  01831	83 e0 40	 and	 eax, 64			; 00000040H
  01834	85 c0		 test	 eax, eax
  01836	74 17		 je	 SHORT $LN124@z900_execu
  01838	8b 45 1c	 mov	 eax, DWORD PTR addr$[rbp]
  0183b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01842	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  01849	0f 83 24 02 00
	00		 jae	 $LN115@z900_execu
$LN124@z900_execu:
$LN122@z900_execu:
$LN121@z900_execu:
  0184f	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  01853	83 e0 05	 and	 eax, 5
  01856	85 c0		 test	 eax, eax
  01858	0f 85 f9 01 00
	00		 jne	 $LN125@z900_execu
  0185e	0f b6 45 0b	 movzx	 eax, BYTE PTR ccwfmt$[rbp]
  01862	85 c0		 test	 eax, eax
  01864	0f 85 ba 00 00
	00		 jne	 $LN126@z900_execu
  0186a	8b 45 1c	 mov	 eax, DWORD PTR addr$[rbp]
  0186d	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  01872	85 c0		 test	 eax, eax
  01874	0f 85 f9 01 00
	00		 jne	 $LN115@z900_execu
  0187a	8b 45 1c	 mov	 eax, DWORD PTR addr$[rbp]
  0187d	8b 4d 18	 mov	 ecx, DWORD PTR count$[rbp]
  01880	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  01884	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  01889	85 c0		 test	 eax, eax
  0188b	0f 85 e2 01 00
	00		 jne	 $LN115@z900_execu
  01891	8b 45 1c	 mov	 eax, DWORD PTR addr$[rbp]
  01894	8b 4d 18	 mov	 ecx, DWORD PTR count$[rbp]
  01897	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  0189b	8b c0		 mov	 eax, eax
  0189d	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  018a1	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  018a8	0f 87 c5 01 00
	00		 ja	 $LN115@z900_execu
  018ae	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  018b2	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  018b9	83 e0 10	 and	 eax, 16
  018bc	85 c0		 test	 eax, eax
  018be	74 64		 je	 SHORT $LN127@z900_execu
  018c0	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  018c4	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  018cb	83 e0 20	 and	 eax, 32			; 00000020H
  018ce	85 c0		 test	 eax, eax
  018d0	74 20		 je	 SHORT $LN128@z900_execu
  018d2	8b 45 1c	 mov	 eax, DWORD PTR addr$[rbp]
  018d5	8b 4d 18	 mov	 ecx, DWORD PTR count$[rbp]
  018d8	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  018dc	8b c0		 mov	 eax, eax
  018de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  018e5	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  018ec	0f 82 81 01 00
	00		 jb	 $LN115@z900_execu
$LN128@z900_execu:
  018f2	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  018f6	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  018fd	83 e0 40	 and	 eax, 64			; 00000040H
  01900	85 c0		 test	 eax, eax
  01902	74 20		 je	 SHORT $LN129@z900_execu
  01904	8b 45 1c	 mov	 eax, DWORD PTR addr$[rbp]
  01907	8b 4d 18	 mov	 ecx, DWORD PTR count$[rbp]
  0190a	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  0190e	8b c0		 mov	 eax, eax
  01910	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01917	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  0191e	0f 83 4f 01 00
	00		 jae	 $LN115@z900_execu
$LN129@z900_execu:
$LN127@z900_execu:
$LN126@z900_execu:
  01924	0f b6 45 0b	 movzx	 eax, BYTE PTR ccwfmt$[rbp]
  01928	83 f8 01	 cmp	 eax, 1
  0192b	0f 85 ba 00 00
	00		 jne	 $LN130@z900_execu
  01931	8b 45 1c	 mov	 eax, DWORD PTR addr$[rbp]
  01934	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  01939	85 c0		 test	 eax, eax
  0193b	0f 85 32 01 00
	00		 jne	 $LN115@z900_execu
  01941	8b 45 1c	 mov	 eax, DWORD PTR addr$[rbp]
  01944	8b 4d 18	 mov	 ecx, DWORD PTR count$[rbp]
  01947	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  0194b	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  01950	85 c0		 test	 eax, eax
  01952	0f 85 1b 01 00
	00		 jne	 $LN115@z900_execu
  01958	8b 45 1c	 mov	 eax, DWORD PTR addr$[rbp]
  0195b	8b 4d 18	 mov	 ecx, DWORD PTR count$[rbp]
  0195e	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  01962	8b c0		 mov	 eax, eax
  01964	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01968	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  0196f	0f 87 fe 00 00
	00		 ja	 $LN115@z900_execu
  01975	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01979	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  01980	83 e0 10	 and	 eax, 16
  01983	85 c0		 test	 eax, eax
  01985	74 64		 je	 SHORT $LN131@z900_execu
  01987	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0198b	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  01992	83 e0 20	 and	 eax, 32			; 00000020H
  01995	85 c0		 test	 eax, eax
  01997	74 20		 je	 SHORT $LN132@z900_execu
  01999	8b 45 1c	 mov	 eax, DWORD PTR addr$[rbp]
  0199c	8b 4d 18	 mov	 ecx, DWORD PTR count$[rbp]
  0199f	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  019a3	8b c0		 mov	 eax, eax
  019a5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  019ac	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  019b3	0f 82 ba 00 00
	00		 jb	 $LN115@z900_execu
$LN132@z900_execu:
  019b9	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  019bd	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  019c4	83 e0 40	 and	 eax, 64			; 00000040H
  019c7	85 c0		 test	 eax, eax
  019c9	74 20		 je	 SHORT $LN133@z900_execu
  019cb	8b 45 1c	 mov	 eax, DWORD PTR addr$[rbp]
  019ce	8b 4d 18	 mov	 ecx, DWORD PTR count$[rbp]
  019d1	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  019d5	8b c0		 mov	 eax, eax
  019d7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  019de	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  019e5	0f 83 88 00 00
	00		 jae	 $LN115@z900_execu
$LN133@z900_execu:
$LN131@z900_execu:
$LN130@z900_execu:
  019eb	8b 45 1c	 mov	 eax, DWORD PTR addr$[rbp]
  019ee	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  019f2	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  019f9	77 78		 ja	 SHORT $LN115@z900_execu
  019fb	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  019ff	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  01a06	83 e0 10	 and	 eax, 16
  01a09	85 c0		 test	 eax, eax
  01a0b	74 4a		 je	 SHORT $LN134@z900_execu
  01a0d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01a11	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  01a18	83 e0 20	 and	 eax, 32			; 00000020H
  01a1b	85 c0		 test	 eax, eax
  01a1d	74 13		 je	 SHORT $LN135@z900_execu
  01a1f	8b 45 1c	 mov	 eax, DWORD PTR addr$[rbp]
  01a22	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01a29	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  01a30	72 41		 jb	 SHORT $LN115@z900_execu
$LN135@z900_execu:
  01a32	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01a36	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  01a3d	83 e0 40	 and	 eax, 64			; 00000040H
  01a40	85 c0		 test	 eax, eax
  01a42	74 13		 je	 SHORT $LN136@z900_execu
  01a44	8b 45 1c	 mov	 eax, DWORD PTR addr$[rbp]
  01a47	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01a4e	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  01a55	73 1c		 jae	 SHORT $LN115@z900_execu
$LN136@z900_execu:
$LN134@z900_execu:
$LN125@z900_execu:
$LN116@z900_execu:
  01a57	83 7d 18 00	 cmp	 DWORD PTR count$[rbp], 0
  01a5b	75 2d		 jne	 SHORT $LN114@z900_execu
  01a5d	0f b6 45 0b	 movzx	 eax, BYTE PTR ccwfmt$[rbp]
  01a61	83 f8 01	 cmp	 eax, 1
  01a64	75 24		 jne	 SHORT $LN114@z900_execu
  01a66	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  01a6a	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01a6f	85 c0		 test	 eax, eax
  01a71	74 17		 je	 SHORT $LN114@z900_execu
$LN115@z900_execu:

; 5142 :              (ccwfmt == 1 && (flags & CCW_FLAGS_CD)))
; 5143 : #endif /*defined(FEATURE_CHANNEL_SUBSYSTEM)*/
; 5144 :             )
; 5145 :         {
; 5146 :             chanstat = CSW_PROGC;

  01a73	c6 45 09 20	 mov	 BYTE PTR chanstat$[rbp], 32 ; 00000020H

; 5147 :             if (prefetch.seq)

  01a77	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  01a7e	74 05		 je	 SHORT $LN137@z900_execu

; 5148 :                 goto prefetch;

  01a80	e9 9b 04 00 00	 jmp	 $prefetch$333
$LN137@z900_execu:

; 5149 :             goto breakchain;

  01a85	e9 58 0c 00 00	 jmp	 $breakchain$332
$LN114@z900_execu:

; 5150 :         }
; 5151 : 
; 5152 :         /* Suspend and reschedule I/O at this point if SIO and CPU   */
; 5153 :         /* not yet released; if IDA specified, first IDA must be     */
; 5154 :         /* verified before suspend and reschedule.                   */
; 5155 :         if (dev->s370start)

  01a8a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01a8e	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01a94	d1 e8		 shr	 eax, 1
  01a96	83 e0 01	 and	 eax, 1
  01a99	85 c0		 test	 eax, eax
  01a9b	0f 84 c3 01 00
	00		 je	 $LN138@z900_execu

; 5156 :         {
; 5157 :             /* Note: dev->s370start is reset in resume processing;
; 5158 :              *       dev->suspended is NOT set as it is not the intent
; 5159 :              *       to permit another system to update the device.
; 5160 :              */
; 5161 : 
; 5162 :             /* Acquire device lock */
; 5163 :             obtain_lock(&dev->lock);

  01aa1	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01aa5	48 83 c0 38	 add	 rax, 56			; 00000038H
  01aa9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196693
  01ab0	48 8b c8	 mov	 rcx, rax
  01ab3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 5164 : 
; 5165 :             /* State converting from SIO synchronous to asynchronous */
; 5166 :             if (CCW_TRACING_ACTIVE( dev, tracethis ))

  01ab9	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01abd	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01ac3	c1 e8 0f	 shr	 eax, 15
  01ac6	83 e0 01	 and	 eax, 1
  01ac9	85 c0		 test	 eax, eax
  01acb	75 0c		 jne	 SHORT $LN140@z900_execu
  01acd	0f b6 45 15	 movzx	 eax, BYTE PTR tracethis$[rbp]
  01ad1	85 c0		 test	 eax, eax
  01ad3	0f 84 d3 00 00
	00		 je	 $LN139@z900_execu
$LN140@z900_execu:

; 5167 :             {
; 5168 :                 if (dev->ccwtrace && sysblk.traceFILE)

  01ad9	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01add	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01ae3	c1 e8 0f	 shr	 eax, 15
  01ae6	83 e0 01	 and	 eax, 1
  01ae9	85 c0		 test	 eax, eax
  01aeb	74 20		 je	 SHORT $LN141@z900_execu
  01aed	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01af4	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  01afc	74 0f		 je	 SHORT $LN141@z900_execu

; 5169 :                     tf_1320( dev );

  01afe	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01b02	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1320
  01b08	e9 9f 00 00 00	 jmp	 $LN142@z900_execu
$LN141@z900_execu:

; 5170 :                 else
; 5171 :                     // "%1d:%04X CHAN: start I/O S/370 conversion to asynchronous operation started"
; 5172 :                     WRMSG( HHC01320, "I", LCSS_DEVNUM );

  01b0d	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  01b12	74 10		 je	 SHORT $LN276@z900_execu
  01b14	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01b18	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01b1c	89 85 bc 00 00
	00		 mov	 DWORD PTR tv1224[rbp], eax
  01b22	eb 0a		 jmp	 SHORT $LN277@z900_execu
$LN276@z900_execu:
  01b24	c7 85 bc 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1224[rbp], 0
$LN277@z900_execu:
  01b2e	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  01b33	74 12		 je	 SHORT $LN278@z900_execu
  01b35	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01b39	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01b3d	d1 f8		 sar	 eax, 1
  01b3f	89 85 c0 00 00
	00		 mov	 DWORD PTR tv1230[rbp], eax
  01b45	eb 0a		 jmp	 SHORT $LN279@z900_execu
$LN278@z900_execu:
  01b47	c7 85 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1230[rbp], 0
$LN279@z900_execu:
  01b51	b9 01 00 00 00	 mov	 ecx, 1
  01b56	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01b5c	8b 8d bc 00 00
	00		 mov	 ecx, DWORD PTR tv1224[rbp]
  01b62	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01b66	8b 8d c0 00 00
	00		 mov	 ecx, DWORD PTR tv1230[rbp]
  01b6c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01b70	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196698
  01b77	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01b7c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196699
  01b83	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01b88	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01b8d	41 b9 03 00 00
	00		 mov	 r9d, 3
  01b93	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196700
  01b9a	ba 34 14 00 00	 mov	 edx, 5172		; 00001434H
  01b9f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196701
  01ba6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN142@z900_execu:
$LN139@z900_execu:

; 5173 :             }
; 5174 : 
; 5175 :             /* Update local copy of ORB */
; 5176 :             STORE_FW(dev->orb.ccwaddr, (ccwaddr-8));

  01bac	8b 45 24	 mov	 eax, DWORD PTR ccwaddr$[rbp]
  01baf	83 e8 08	 sub	 eax, 8
  01bb2	8b c8		 mov	 ecx, eax
  01bb4	e8 00 00 00 00	 call	 _byteswap_ulong
  01bb9	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01bbd	48 81 c1 d4 02
	00 00		 add	 rcx, 724		; 000002d4H
  01bc4	8b d0		 mov	 edx, eax
  01bc6	e8 00 00 00 00	 call	 store_fw_noswap

; 5177 : 
; 5178 :             /* Preserve CCW execution variables for validation */
; 5179 :             dev->ccwaddr = ccwaddr;

  01bcb	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01bcf	8b 4d 24	 mov	 ecx, DWORD PTR ccwaddr$[rbp]
  01bd2	89 88 80 02 00
	00		 mov	 DWORD PTR [rax+640], ecx

; 5180 :             dev->idapmask = idapmask;

  01bd8	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01bdc	0f b7 4d 44	 movzx	 ecx, WORD PTR idapmask$[rbp]
  01be0	66 89 88 84 02
	00 00		 mov	 WORD PTR [rax+644], cx

; 5181 :             dev->idawfmt = idawfmt;

  01be7	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01beb	0f b6 4d 16	 movzx	 ecx, BYTE PTR idawfmt$[rbp]
  01bef	88 88 86 02 00
	00		 mov	 BYTE PTR [rax+646], cl

; 5182 :             dev->ccwfmt = ccwfmt;

  01bf5	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01bf9	0f b6 4d 0b	 movzx	 ecx, BYTE PTR ccwfmt$[rbp]
  01bfd	88 88 87 02 00
	00		 mov	 BYTE PTR [rax+647], cl

; 5183 :             dev->ccwkey = ccwkey;

  01c03	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01c07	0f b6 4d 14	 movzx	 ecx, BYTE PTR ccwkey$[rbp]
  01c0b	88 88 88 02 00
	00		 mov	 BYTE PTR [rax+648], cl

; 5184 : 
; 5185 :             /* Set the resume pending flag and signal the subchannel;
; 5186 :              * NULL is used for the requeue regs as the execution of
; 5187 :              * the I/O is no longer attached to a specific processor.
; 5188 :              */
; 5189 :             dev->scsw.flag2 |= SCSW2_AC_RESUM;

  01c11	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01c15	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  01c1c	83 c8 08	 or	 eax, 8
  01c1f	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01c23	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 5190 :             schedule_ioq(NULL, dev);

  01c29	48 8b 55 00	 mov	 rdx, QWORD PTR dev$[rbp]
  01c2d	33 c9		 xor	 ecx, ecx
  01c2f	e8 00 00 00 00	 call	 schedule_ioq

; 5191 : 
; 5192 :             /* Leave device as busy, unlock device and return */
; 5193 :             release_lock(&dev->lock);

  01c34	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01c38	48 83 c0 38	 add	 rax, 56			; 00000038H
  01c3c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196702
  01c43	48 8b c8	 mov	 rcx, rax
  01c46	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5194 :             return execute_ccw_chain_fast_return( iobuf, &iobuf_initial, NULL );

  01c4c	45 33 c0	 xor	 r8d, r8d
  01c4f	48 8d 95 00 20
	00 00		 lea	 rdx, QWORD PTR iobuf_initial$[rbp]
  01c56	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  01c5a	e8 00 00 00 00	 call	 execute_ccw_chain_fast_return
  01c5f	e9 92 1b 00 00	 jmp	 $LN1@z900_execu
$LN138@z900_execu:

; 5195 :         }
; 5196 : 
; 5197 :         /* Handle initial status settings on first non-immediate CCW */
; 5198 :         /* to the device                                             */
; 5199 :         if (firstccw && !dev->is_immed)

  01c64	0f b6 45 2d	 movzx	 eax, BYTE PTR firstccw$[rbp]
  01c68	85 c0		 test	 eax, eax
  01c6a	0f 84 bd 01 00
	00		 je	 $LN143@z900_execu
  01c70	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01c74	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  01c7b	0f 85 ac 01 00
	00		 jne	 $LN143@z900_execu

; 5200 :         {
; 5201 :             /* Reset first CCW indication as we're starting the      */
; 5202 :             /* subchannel                                            */
; 5203 :             firstccw = 0;

  01c81	c6 45 2d 00	 mov	 BYTE PTR firstccw$[rbp], 0

; 5204 : 
; 5205 :             /* Subchannel and device are now active, set bits in     */
; 5206 :             /* SCSW                                                  */
; 5207 :             /* SA22-7201-05:                                         */
; 5208 :             /*  p. 16-14, Subchannel-Active                          */
; 5209 :             /*  pp. 16-14 -- 16-15, Device-Active                    */
; 5210 :             dev->scsw.flag3 |= (SCSW3_AC_SCHAC | SCSW3_AC_DEVAC);

  01c85	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01c89	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  01c90	0d c0 00 00 00	 or	 eax, 192		; 000000c0H
  01c95	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01c99	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 5211 : 
; 5212 :             /* Process Initial-Status-Interruption Request           */
; 5213 :             /* SA22-7201-05:                                         */
; 5214 :             /*  p. 16-11, Zero Condition Code                        */
; 5215 :             if (dev->scsw.flag1 & SCSW1_I)

  01c9f	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01ca3	0f b6 80 09 03
	00 00		 movzx	 eax, BYTE PTR [rax+777]
  01caa	83 e0 20	 and	 eax, 32			; 00000020H
  01cad	85 c0		 test	 eax, eax
  01caf	0f 84 78 01 00
	00		 je	 $LN144@z900_execu

; 5216 :             {
; 5217 :                 obtain_lock (&dev->lock);

  01cb5	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01cb9	48 83 c0 38	 add	 rax, 56			; 00000038H
  01cbd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196705
  01cc4	48 8b c8	 mov	 rcx, rax
  01cc7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 5218 : 
; 5219 :                 /* Update the CCW address in the SCSW */
; 5220 :                 STORE_FW(dev->scsw.ccwaddr,ccwaddr);

  01ccd	8b 4d 24	 mov	 ecx, DWORD PTR ccwaddr$[rbp]
  01cd0	e8 00 00 00 00	 call	 _byteswap_ulong
  01cd5	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01cd9	48 81 c1 0c 03
	00 00		 add	 rcx, 780		; 0000030cH
  01ce0	8b d0		 mov	 edx, eax
  01ce2	e8 00 00 00 00	 call	 store_fw_noswap

; 5221 : 
; 5222 :                 /* Set the zero condition-code flag in the SCSW */
; 5223 :                 dev->scsw.flag1 |= SCSW1_Z;

  01ce7	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01ceb	0f b6 80 09 03
	00 00		 movzx	 eax, BYTE PTR [rax+777]
  01cf2	83 c8 04	 or	 eax, 4
  01cf5	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01cf9	88 81 09 03 00
	00		 mov	 BYTE PTR [rcx+777], al

; 5224 : 
; 5225 :                 /* Set intermediate status in the SCSW */
; 5226 :                 dev->scsw.flag3 |= (SCSW3_SC_INTER | SCSW3_SC_PEND);

  01cff	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01d03	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  01d0a	83 c8 09	 or	 eax, 9
  01d0d	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01d11	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 5227 : 
; 5228 :                 /* Queue the interrupt and update interrupt status */
; 5229 :                 release_lock(&dev->lock);

  01d17	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01d1b	48 83 c0 38	 add	 rax, 56			; 00000038H
  01d1f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196706
  01d26	48 8b c8	 mov	 rcx, rax
  01d29	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5230 :                 queue_io_interrupt_and_update_status(dev,FALSE);

  01d2f	33 d2		 xor	 edx, edx
  01d31	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01d35	e8 00 00 00 00	 call	 queue_io_interrupt_and_update_status

; 5231 : 
; 5232 :                 if (CCW_TRACING_ACTIVE( dev, tracethis ))

  01d3a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01d3e	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01d44	c1 e8 0f	 shr	 eax, 15
  01d47	83 e0 01	 and	 eax, 1
  01d4a	85 c0		 test	 eax, eax
  01d4c	75 0c		 jne	 SHORT $LN146@z900_execu
  01d4e	0f b6 45 15	 movzx	 eax, BYTE PTR tracethis$[rbp]
  01d52	85 c0		 test	 eax, eax
  01d54	0f 84 d3 00 00
	00		 je	 $LN145@z900_execu
$LN146@z900_execu:

; 5233 :                 {
; 5234 :                     if (dev->ccwtrace && sysblk.traceFILE)

  01d5a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01d5e	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01d64	c1 e8 0f	 shr	 eax, 15
  01d67	83 e0 01	 and	 eax, 1
  01d6a	85 c0		 test	 eax, eax
  01d6c	74 20		 je	 SHORT $LN147@z900_execu
  01d6e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01d75	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  01d7d	74 0f		 je	 SHORT $LN147@z900_execu

; 5235 :                         tf_1306( dev );

  01d7f	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01d83	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1306
  01d89	e9 9f 00 00 00	 jmp	 $LN148@z900_execu
$LN147@z900_execu:

; 5236 :                     else
; 5237 :                         // "%1d:%04X CHAN: initial status interrupt"
; 5238 :                         WRMSG( HHC01306, "I", LCSS_DEVNUM );

  01d8e	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  01d93	74 10		 je	 SHORT $LN280@z900_execu
  01d95	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01d99	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01d9d	89 85 c4 00 00
	00		 mov	 DWORD PTR tv1318[rbp], eax
  01da3	eb 0a		 jmp	 SHORT $LN281@z900_execu
$LN280@z900_execu:
  01da5	c7 85 c4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1318[rbp], 0
$LN281@z900_execu:
  01daf	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  01db4	74 12		 je	 SHORT $LN282@z900_execu
  01db6	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01dba	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01dbe	d1 f8		 sar	 eax, 1
  01dc0	89 85 c8 00 00
	00		 mov	 DWORD PTR tv1324[rbp], eax
  01dc6	eb 0a		 jmp	 SHORT $LN283@z900_execu
$LN282@z900_execu:
  01dc8	c7 85 c8 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1324[rbp], 0
$LN283@z900_execu:
  01dd2	b9 01 00 00 00	 mov	 ecx, 1
  01dd7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01ddd	8b 8d c4 00 00
	00		 mov	 ecx, DWORD PTR tv1318[rbp]
  01de3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01de7	8b 8d c8 00 00
	00		 mov	 ecx, DWORD PTR tv1324[rbp]
  01ded	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01df1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196711
  01df8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01dfd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196712
  01e04	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01e09	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01e0e	41 b9 03 00 00
	00		 mov	 r9d, 3
  01e14	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196713
  01e1b	ba 76 14 00 00	 mov	 edx, 5238		; 00001476H
  01e20	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196714
  01e27	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN148@z900_execu:
$LN145@z900_execu:
$LN144@z900_execu:
$LN143@z900_execu:

; 5239 :                 }
; 5240 :             }
; 5241 :         }
; 5242 : 
; 5243 :         /* For WRITE and non-immediate CONTROL operations,
; 5244 :            copy data from main storage into channel buffer */
; 5245 :         if (!skip_ccws &&

  01e2d	83 7d 64 00	 cmp	 DWORD PTR skip_ccws$[rbp], 0
  01e31	0f 85 83 03 00
	00		 jne	 $LN149@z900_execu
  01e37	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  01e3e	75 3b		 jne	 SHORT $LN150@z900_execu
  01e40	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01e44	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  01e4b	0f 85 69 03 00
	00		 jne	 $LN149@z900_execu
  01e51	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01e55	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  01e5c	83 e0 03	 and	 eax, 3
  01e5f	83 f8 01	 cmp	 eax, 1
  01e62	74 17		 je	 SHORT $LN151@z900_execu
  01e64	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01e68	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  01e6f	83 e0 03	 and	 eax, 3
  01e72	83 f8 03	 cmp	 eax, 3
  01e75	0f 85 3f 03 00
	00		 jne	 $LN149@z900_execu
$LN151@z900_execu:
$LN150@z900_execu:

; 5246 :             (prefetch.seq ||
; 5247 :              (!dev->is_immed                 &&
; 5248 :               (IS_CCW_WRITE(dev->code)  ||
; 5249 :                IS_CCW_CONTROL(dev->code)))))
; 5250 :         {
; 5251 :             /* Clear prefetch sequence table and I/O buffer if first
; 5252 :                entry */
; 5253 :             if (!prefetch.seq)

  01e7b	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  01e82	0f 85 98 00 00
	00		 jne	 $LN152@z900_execu

; 5254 :             {
; 5255 :                 clear_io_buffer(iobuf->data, iobuf->size);

  01e88	48 8b 45 58	 mov	 rax, QWORD PTR iobuf$[rbp]
  01e8c	8b 00		 mov	 eax, DWORD PTR [rax]
  01e8e	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  01e92	48 81 c1 00 10
	00 00		 add	 rcx, 4096		; 00001000H
  01e99	8b d0		 mov	 edx, eax
  01e9b	e8 00 00 00 00	 call	 __clear_io_buffer

; 5256 :                 clear_io_buffer(&prefetch, sizeof(prefetch));

  01ea0	ba 10 1a 00 00	 mov	 edx, 6672		; 00001a10H
  01ea5	48 8d 8d c0 01
	00 00		 lea	 rcx, QWORD PTR prefetch$[rbp]
  01eac	e8 00 00 00 00	 call	 __clear_io_buffer

; 5257 :                 ps = 0;

  01eb1	c7 45 10 00 00
	00 00		 mov	 DWORD PTR ps$[rbp], 0

; 5258 :                 prefetch.seq = 1;

  01eb8	c7 85 c0 01 00
	00 01 00 00 00	 mov	 DWORD PTR prefetch$[rbp], 1

; 5259 :                 prefetch.prevcode = dev->prevcode;

  01ec2	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01ec6	0f b6 80 7b 02
	00 00		 movzx	 eax, BYTE PTR [rax+635]
  01ecd	88 85 cc 01 00
	00		 mov	 BYTE PTR prefetch$[rbp+12], al

; 5260 :                 prefetch.opcode = dev->code;

  01ed3	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01ed7	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  01ede	88 85 cd 01 00
	00		 mov	 BYTE PTR prefetch$[rbp+13], al

; 5261 :                 prefetch.ccwaddr[ps] = ccwaddr;

  01ee4	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01ee7	8b 4d 24	 mov	 ecx, DWORD PTR ccwaddr$[rbp]
  01eea	89 8c 85 d0 02
	00 00		 mov	 DWORD PTR prefetch$[rbp+rax*4+272], ecx

; 5262 :                 prefetch.ccwflags[ps] = flags;

  01ef1	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01ef4	0f b6 4d 08	 movzx	 ecx, BYTE PTR flags$[rbp]
  01ef8	88 8c 05 d0 12
	00 00		 mov	 BYTE PTR prefetch$[rbp+rax+4368], cl

; 5263 :                 prefetch.ccwcount[ps] = count;

  01eff	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01f02	0f b7 4d 18	 movzx	 ecx, WORD PTR count$[rbp]
  01f06	66 89 8c 45 d0
	13 00 00	 mov	 WORD PTR prefetch$[rbp+rax*2+4624], cx

; 5264 :                 prefetch.chanstat[ps] = chanstat;

  01f0e	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01f11	0f b6 4d 09	 movzx	 ecx, BYTE PTR chanstat$[rbp]
  01f15	88 8c 05 d0 01
	00 00		 mov	 BYTE PTR prefetch$[rbp+rax+16], cl

; 5265 :                 chanstat = 0;

  01f1c	c6 45 09 00	 mov	 BYTE PTR chanstat$[rbp], 0
$LN152@z900_execu:
$prefetch$333:

; 5266 :             }
; 5267 : prefetch:
; 5268 :             /* Finish prefetch table entry initialization */
; 5269 :             if (opcode == 0x08 ||

  01f20	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  01f24	83 f8 08	 cmp	 eax, 8
  01f27	74 14		 je	 SHORT $LN155@z900_execu
  01f29	0f b6 45 0b	 movzx	 eax, BYTE PTR ccwfmt$[rbp]
  01f2d	85 c0		 test	 eax, eax
  01f2f	75 26		 jne	 SHORT $LN153@z900_execu
  01f31	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  01f35	83 e0 0f	 and	 eax, 15
  01f38	83 f8 08	 cmp	 eax, 8
  01f3b	75 1a		 jne	 SHORT $LN153@z900_execu
$LN155@z900_execu:

; 5270 :                 (ccwfmt == 0 && ((opcode & 0x0f) == 0x08)))
; 5271 :             {
; 5272 :                 prefetch.ccwflags[ps] = 0;

  01f3d	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01f40	c6 84 05 d0 12
	00 00 00	 mov	 BYTE PTR prefetch$[rbp+rax+4368], 0

; 5273 :                 prefetch.ccwcount[ps] = 0;

  01f48	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01f4b	33 c9		 xor	 ecx, ecx
  01f4d	66 89 8c 45 d0
	13 00 00	 mov	 WORD PTR prefetch$[rbp+rax*2+4624], cx

; 5274 :             }

  01f55	eb 24		 jmp	 SHORT $LN154@z900_execu
$LN153@z900_execu:

; 5275 :             else
; 5276 :             {
; 5277 :                 prefetch.ccwflags[ps] = flags & ~(CCW_FLAGS_SKIP |

  01f57	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  01f5b	83 e0 ed	 and	 eax, -19
  01f5e	8b 4d 10	 mov	 ecx, DWORD PTR ps$[rbp]
  01f61	88 84 0d d0 12
	00 00		 mov	 BYTE PTR prefetch$[rbp+rcx+4368], al

; 5278 :                                                   CCW_FLAGS_SUSP);
; 5279 :                 prefetch.reqcount += count;

  01f68	8b 45 18	 mov	 eax, DWORD PTR count$[rbp]
  01f6b	8b 8d c8 01 00
	00		 mov	 ecx, DWORD PTR prefetch$[rbp+8]
  01f71	03 c8		 add	 ecx, eax
  01f73	8b c1		 mov	 eax, ecx
  01f75	89 85 c8 01 00
	00		 mov	 DWORD PTR prefetch$[rbp+8], eax
$LN154@z900_execu:

; 5280 :             }
; 5281 : 
; 5282 :             /* Copy address to prefetch table */
; 5283 :             prefetch.dataaddr[ps] = addr;

  01f7b	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01f7e	8b 4d 1c	 mov	 ecx, DWORD PTR addr$[rbp]
  01f81	48 89 8c c5 d0
	0a 00 00	 mov	 QWORD PTR prefetch$[rbp+rax*8+2320], rcx

; 5284 : 
; 5285 :             /* Ignore additional checks if error */
; 5286 :             if (chanstat)

  01f89	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  01f8d	85 c0		 test	 eax, eax
  01f8f	74 17		 je	 SHORT $LN156@z900_execu

; 5287 :             {
; 5288 :                 prefetch.chanstat[ps] = chanstat;

  01f91	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01f94	0f b6 4d 09	 movzx	 ecx, BYTE PTR chanstat$[rbp]
  01f98	88 8c 05 d0 01
	00 00		 mov	 BYTE PTR prefetch$[rbp+rax+16], cl

; 5289 :                 chanstat = 0;

  01f9f	c6 45 09 00	 mov	 BYTE PTR chanstat$[rbp], 0

; 5290 :             }

  01fa3	e9 36 01 00 00	 jmp	 $LN157@z900_execu
$LN156@z900_execu:

; 5291 : 
; 5292 :             /* Don't copy if immediate and zero count */
; 5293 :             else if (dev->is_immed && !count);

  01fa8	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01fac	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  01fb3	74 0b		 je	 SHORT $LN158@z900_execu
  01fb5	83 7d 18 00	 cmp	 DWORD PTR count$[rbp], 0
  01fb9	75 05		 jne	 SHORT $LN158@z900_execu
  01fbb	e9 1e 01 00 00	 jmp	 $LN159@z900_execu
$LN158@z900_execu:

; 5294 : 
; 5295 :             /* Otherwise, copy data into channel buffer */
; 5296 :             else
; 5297 :             {
; 5298 :                 U32 newsize = bufpos + count;

  01fc0	8b 45 18	 mov	 eax, DWORD PTR count$[rbp]
  01fc3	8b 4d 60	 mov	 ecx, DWORD PTR bufpos$[rbp]
  01fc6	03 c8		 add	 ecx, eax
  01fc8	8b c1		 mov	 eax, ecx
  01fca	89 85 cc 00 00
	00		 mov	 DWORD PTR newsize$8[rbp], eax

; 5299 : 
; 5300 :                 prefetch.datalen[ps] = count;

  01fd0	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01fd3	8b 4d 18	 mov	 ecx, DWORD PTR count$[rbp]
  01fd6	89 8c 85 d0 06
	00 00		 mov	 DWORD PTR prefetch$[rbp+rax*4+1296], ecx

; 5301 : 
; 5302 :                 /* Extend buffer if overflow */
; 5303 :                 if (newsize > iobuf->size)

  01fdd	48 8b 45 58	 mov	 rax, QWORD PTR iobuf$[rbp]
  01fe1	8b 00		 mov	 eax, DWORD PTR [rax]
  01fe3	39 85 cc 00 00
	00		 cmp	 DWORD PTR newsize$8[rbp], eax
  01fe9	76 38		 jbe	 SHORT $LN160@z900_execu

; 5304 :                 {
; 5305 :                     IOBUF *iobufnew;
; 5306 : 
; 5307 :                     iobufnew = iobuf_reallocate(iobuf, newsize);

  01feb	8b 95 cc 00 00
	00		 mov	 edx, DWORD PTR newsize$8[rbp]
  01ff1	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  01ff5	e8 00 00 00 00	 call	 iobuf_reallocate
  01ffa	48 89 85 90 01
	00 00		 mov	 QWORD PTR iobufnew$9[rbp], rax

; 5308 : 
; 5309 :                     /* If new I/O buffer allocation failed, force a
; 5310 :                      * Channel Data Check (CDC). Otherwise, set the
; 5311 :                      * iobuf pointer to the new I/O buffer space.
; 5312 :                      */
; 5313 :                     if (iobufnew == NULL)

  02001	48 83 bd 90 01
	00 00 00	 cmp	 QWORD PTR iobufnew$9[rbp], 0
  02009	75 0d		 jne	 SHORT $LN161@z900_execu

; 5314 :                         prefetch.chanstat[ps] = CSW_CDC;

  0200b	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  0200e	c6 84 05 d0 01
	00 00 08	 mov	 BYTE PTR prefetch$[rbp+rax+16], 8
  02016	eb 0b		 jmp	 SHORT $LN162@z900_execu
$LN161@z900_execu:

; 5315 :                     else
; 5316 :                         iobuf = iobufnew;

  02018	48 8b 85 90 01
	00 00		 mov	 rax, QWORD PTR iobufnew$9[rbp]
  0201f	48 89 45 58	 mov	 QWORD PTR iobuf$[rbp], rax
$LN162@z900_execu:
$LN160@z900_execu:

; 5317 :                 }
; 5318 : 
; 5319 :                 /* If no errors, prefetch data to I/O buffer */
; 5320 :                 if (!prefetch.chanstat[ps])

  02023	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  02026	0f b6 84 05 d0
	01 00 00	 movzx	 eax, BYTE PTR prefetch$[rbp+rax+16]
  0202e	85 c0		 test	 eax, eax
  02030	0f 85 a8 00 00
	00		 jne	 $LN163@z900_execu

; 5321 :                 {
; 5322 :                     ARCH_DEP(copy_iobuf) (dev, ccw, dev->code, flags, addr,

  02036	8b 45 60	 mov	 eax, DWORD PTR bufpos$[rbp]
  02039	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  0203d	48 8d 84 01 00
	10 00 00	 lea	 rax, QWORD PTR [rcx+rax+4096]
  02045	48 8d 8d c0 01
	00 00		 lea	 rcx, QWORD PTR prefetch$[rbp]
  0204c	48 89 4c 24 70	 mov	 QWORD PTR [rsp+112], rcx
  02051	48 8d 4d 30	 lea	 rcx, QWORD PTR residual$[rbp]
  02055	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  0205a	48 8d 4d 09	 lea	 rcx, QWORD PTR chanstat$[rbp]
  0205e	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  02063	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  02067	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0206b	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  02070	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  02074	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  02078	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0207d	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  02082	0f b7 45 44	 movzx	 eax, WORD PTR idapmask$[rbp]
  02086	66 89 44 24 40	 mov	 WORD PTR [rsp+64], ax
  0208b	0f b6 45 16	 movzx	 eax, BYTE PTR idawfmt$[rbp]
  0208f	88 44 24 38	 mov	 BYTE PTR [rsp+56], al
  02093	0f b6 45 14	 movzx	 eax, BYTE PTR ccwkey$[rbp]
  02097	88 44 24 30	 mov	 BYTE PTR [rsp+48], al
  0209b	8b 45 18	 mov	 eax, DWORD PTR count$[rbp]
  0209e	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  020a2	8b 45 1c	 mov	 eax, DWORD PTR addr$[rbp]
  020a5	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  020a9	44 0f b6 4d 08	 movzx	 r9d, BYTE PTR flags$[rbp]
  020ae	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  020b2	44 0f b6 80 7a
	02 00 00	 movzx	 r8d, BYTE PTR [rax+634]
  020ba	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR ccw$[rbp]
  020c1	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  020c5	e8 00 00 00 00	 call	 z900_copy_iobuf

; 5323 :                                           count, ccwkey,
; 5324 :                                           idawfmt, idapmask,
; 5325 :                                           iobuf->data + bufpos,
; 5326 :                                           iobuf->start, iobuf->end,
; 5327 :                                           &chanstat, &residual, &prefetch);
; 5328 : 
; 5329 :                     /* Update local copy of prefetch sequence entry */
; 5330 :                     ps = prefetch.seq - 1;

  020ca	8b 85 c0 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp]
  020d0	ff c8		 dec	 eax
  020d2	89 45 10	 mov	 DWORD PTR ps$[rbp], eax

; 5331 : 
; 5332 :                     /* Update number of bytes in channel buffer */
; 5333 :                     bufpos = prefetch.pos;

  020d5	8b 85 c4 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp+4]
  020db	89 45 60	 mov	 DWORD PTR bufpos$[rbp], eax
$LN163@z900_execu:
$LN159@z900_execu:
$LN157@z900_execu:

; 5334 :                 }
; 5335 :             }
; 5336 : 
; 5337 :             /* If the device handler has requested merging of data
; 5338 :                chained write CCWs, then collect the data from the
; 5339 :                chained-data CCWs in the sequence before passing buffer
; 5340 :                to device handler */
; 5341 : 
; 5342 :             /* Note: This test is commented out as we prefetch the data;
; 5343 :                      chain data, therefore, must always be handled.
; 5344 : 
; 5345 :             if ((dev->orb.flag5 & ORB5_P) ||
; 5346 :                 dev->cdwmerge)                                        */
; 5347 :             {
; 5348 :                 if (dev->code != 0x08 &&
; 5349 :                     !(ccwfmt == 0 && ((dev->code & 0x0F) == 0x08)) &&

  020de	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  020e2	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  020e9	83 f8 08	 cmp	 eax, 8
  020ec	74 65		 je	 SHORT $LN164@z900_execu
  020ee	0f b6 45 0b	 movzx	 eax, BYTE PTR ccwfmt$[rbp]
  020f2	85 c0		 test	 eax, eax
  020f4	75 13		 jne	 SHORT $LN165@z900_execu
  020f6	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  020fa	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  02101	83 e0 0f	 and	 eax, 15
  02104	83 f8 08	 cmp	 eax, 8
  02107	74 4a		 je	 SHORT $LN164@z900_execu
$LN165@z900_execu:
  02109	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  0210d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  02112	85 c0		 test	 eax, eax
  02114	74 3d		 je	 SHORT $LN164@z900_execu

; 5350 :                     flags & CCW_FLAGS_CD)
; 5351 :                 {
; 5352 :                     /* If this is the first CCW in the data chain,
; 5353 :                        then save the chaining flags from the
; 5354 :                        previous CCW */
; 5355 :                     if ((dev->chained & CCW_FLAGS_CD) == 0)

  02116	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0211a	0f b6 80 78 02
	00 00		 movzx	 eax, BYTE PTR [rax+632]
  02121	25 80 00 00 00	 and	 eax, 128		; 00000080H
  02126	85 c0		 test	 eax, eax
  02128	75 15		 jne	 SHORT $LN166@z900_execu

; 5356 :                         dev->prev_chained = dev->chained;

  0212a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0212e	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02132	0f b6 89 78 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+632]
  02139	88 88 79 02 00
	00		 mov	 BYTE PTR [rax+633], cl
$LN166@z900_execu:

; 5357 : 
; 5358 :                     /* Process next CCW in data chain */
; 5359 :                     dev->chained = CCW_FLAGS_CD;

  0213f	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02143	c6 80 78 02 00
	00 80		 mov	 BYTE PTR [rax+632], 128	; 00000080H

; 5360 :                     chain = 1;

  0214a	c6 45 20 01	 mov	 BYTE PTR chain$[rbp], 1

; 5361 :                     continue;

  0214e	e9 6a e8 ff ff	 jmp	 $LN325@z900_execu
$LN164@z900_execu:

; 5362 :                 }
; 5363 : 
; 5364 :                 /* If this is the last CCW in the data chain, then
; 5365 :                    restore the chaining flags from the previous
; 5366 :                    CCW */
; 5367 :                 if (dev->chained & CCW_FLAGS_CD)

  02153	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02157	0f b6 80 78 02
	00 00		 movzx	 eax, BYTE PTR [rax+632]
  0215e	25 80 00 00 00	 and	 eax, 128		; 00000080H
  02163	85 c0		 test	 eax, eax
  02165	74 15		 je	 SHORT $LN167@z900_execu

; 5368 :                     dev->chained = dev->prev_chained;

  02167	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0216b	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0216f	0f b6 89 79 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+633]
  02176	88 88 78 02 00
	00		 mov	 BYTE PTR [rax+632], cl
$LN167@z900_execu:

; 5369 : 
; 5370 :             } /* end if(dev->cdwmerge) */
; 5371 : 
; 5372 :             /* Reset pointers */
; 5373 :             ccwaddr = prefetch.ccwaddr[0];

  0217c	b8 04 00 00 00	 mov	 eax, 4
  02181	48 6b c0 00	 imul	 rax, rax, 0
  02185	8b 84 05 d0 02
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax+272]
  0218c	89 45 24	 mov	 DWORD PTR ccwaddr$[rbp], eax

; 5374 :             dev->prevcode = prefetch.prevcode;

  0218f	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02193	0f b6 8d cc 01
	00 00		 movzx	 ecx, BYTE PTR prefetch$[rbp+12]
  0219a	88 88 7b 02 00
	00		 mov	 BYTE PTR [rax+635], cl

; 5375 :             dev->code = prefetch.opcode;

  021a0	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  021a4	0f b6 8d cd 01
	00 00		 movzx	 ecx, BYTE PTR prefetch$[rbp+13]
  021ab	88 88 7a 02 00
	00		 mov	 BYTE PTR [rax+634], cl

; 5376 :             count = prefetch.reqcount;

  021b1	8b 85 c8 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp+8]
  021b7	89 45 18	 mov	 DWORD PTR count$[rbp], eax
$LN149@z900_execu:

; 5377 : 
; 5378 :         }   /* End prefetch */
; 5379 : 
; 5380 :         /* Set chaining flag */
; 5381 :         chain = ( flags & (CCW_FLAGS_CD | CCW_FLAGS_CC) ) ? 1 : 0;

  021ba	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  021be	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  021c3	85 c0		 test	 eax, eax
  021c5	74 0c		 je	 SHORT $LN284@z900_execu
  021c7	c7 85 d0 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv1473[rbp], 1
  021d1	eb 0a		 jmp	 SHORT $LN285@z900_execu
$LN284@z900_execu:
  021d3	c7 85 d0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1473[rbp], 0
$LN285@z900_execu:
  021dd	0f b6 85 d0 00
	00 00		 movzx	 eax, BYTE PTR tv1473[rbp]
  021e4	88 45 20	 mov	 BYTE PTR chain$[rbp], al

; 5382 : 
; 5383 :         /* If first in sequence, begin execution and channel data
; 5384 :            transfer */
; 5385 :         if (!skip_ccws)

  021e7	83 7d 64 00	 cmp	 DWORD PTR skip_ccws$[rbp], 0
  021eb	0f 85 35 04 00
	00		 jne	 $LN168@z900_execu

; 5386 :         {
; 5387 :             /* Initialize residual byte count */
; 5388 :             residual = count;

  021f1	8b 45 18	 mov	 eax, DWORD PTR count$[rbp]
  021f4	89 45 30	 mov	 DWORD PTR residual$[rbp], eax

; 5389 :             more = bufpos = unitstat = chanstat = 0;

  021f7	c6 45 09 00	 mov	 BYTE PTR chanstat$[rbp], 0
  021fb	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  021ff	88 45 0c	 mov	 BYTE PTR unitstat$[rbp], al
  02202	0f b6 45 0c	 movzx	 eax, BYTE PTR unitstat$[rbp]
  02206	89 45 60	 mov	 DWORD PTR bufpos$[rbp], eax
  02209	0f b6 45 60	 movzx	 eax, BYTE PTR bufpos$[rbp]
  0220d	88 45 40	 mov	 BYTE PTR more$[rbp], al

; 5390 : 
; 5391 :             /* Pass the CCW to the device handler for execution */
; 5392 :             dev->iobuf.length = iobuf->size;

  02210	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02214	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  02218	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0221a	89 88 a8 02 00
	00		 mov	 DWORD PTR [rax+680], ecx

; 5393 :             dev->iobuf.data = iobuf->data;

  02220	48 8b 45 58	 mov	 rax, QWORD PTR iobuf$[rbp]
  02224	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  0222a	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0222e	48 89 81 b0 02
	00 00		 mov	 QWORD PTR [rcx+688], rax

; 5394 :             (dev->hnd->exec) (dev, dev->code, flags, dev->chained,

  02235	48 8b 45 58	 mov	 rax, QWORD PTR iobuf$[rbp]
  02239	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  0223f	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02243	48 8b 89 90 02
	00 00		 mov	 rcx, QWORD PTR [rcx+656]
  0224a	48 89 8d a0 01
	00 00		 mov	 QWORD PTR tv2380[rbp], rcx
  02251	48 8d 55 30	 lea	 rdx, QWORD PTR residual$[rbp]
  02255	48 89 54 24 50	 mov	 QWORD PTR [rsp+80], rdx
  0225a	48 8d 55 0c	 lea	 rdx, QWORD PTR unitstat$[rbp]
  0225e	48 89 54 24 48	 mov	 QWORD PTR [rsp+72], rdx
  02263	48 8d 55 40	 lea	 rdx, QWORD PTR more$[rbp]
  02267	48 89 54 24 40	 mov	 QWORD PTR [rsp+64], rdx
  0226c	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  02271	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02275	8b 80 7c 02 00
	00		 mov	 eax, DWORD PTR [rax+636]
  0227b	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0227f	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02283	0f b6 80 7b 02
	00 00		 movzx	 eax, BYTE PTR [rax+635]
  0228a	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0228e	8b 45 18	 mov	 eax, DWORD PTR count$[rbp]
  02291	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  02295	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02299	44 0f b6 88 78
	02 00 00	 movzx	 r9d, BYTE PTR [rax+632]
  022a1	44 0f b6 45 08	 movzx	 r8d, BYTE PTR flags$[rbp]
  022a6	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  022aa	0f b6 90 7a 02
	00 00		 movzx	 edx, BYTE PTR [rax+634]
  022b1	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  022b5	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR tv2380[rbp]
  022bc	ff 50 08	 call	 QWORD PTR [rax+8]

; 5395 :                               count, dev->prevcode, dev->ccwseq,
; 5396 :                               iobuf->data,
; 5397 :                               &more, &unitstat, &residual);
; 5398 :             dev->iobuf.length = 0;

  022bf	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  022c3	c7 80 a8 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+680], 0

; 5399 :             dev->iobuf.data   = 0;

  022cd	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  022d1	48 c7 80 b0 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+688], 0

; 5400 : 
; 5401 :             /* Check for Command Retry (suggested by Jim Pierson) */
; 5402 :             if ( --cmdretry && unitstat == ( CSW_CE | CSW_DE | CSW_UC | CSW_SM ) )

  022dc	8b 85 88 00 00
	00		 mov	 eax, DWORD PTR cmdretry$[rbp]
  022e2	ff c8		 dec	 eax
  022e4	89 85 88 00 00
	00		 mov	 DWORD PTR cmdretry$[rbp], eax
  022ea	83 bd 88 00 00
	00 00		 cmp	 DWORD PTR cmdretry$[rbp], 0
  022f1	74 41		 je	 SHORT $LN169@z900_execu
  022f3	0f b6 45 0c	 movzx	 eax, BYTE PTR unitstat$[rbp]
  022f7	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  022fa	75 38		 jne	 SHORT $LN169@z900_execu

; 5403 :             {
; 5404 :                 chain    = 1;

  022fc	c6 45 20 01	 mov	 BYTE PTR chain$[rbp], 1

; 5405 :                 if (prefetch.seq)

  02300	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  02307	74 1d		 je	 SHORT $LN170@z900_execu

; 5406 :                 {
; 5407 :                     ccwaddr = prefetch.ccwaddr[0];

  02309	b8 04 00 00 00	 mov	 eax, 4
  0230e	48 6b c0 00	 imul	 rax, rax, 0
  02312	8b 84 05 d0 02
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax+272]
  02319	89 45 24	 mov	 DWORD PTR ccwaddr$[rbp], eax

; 5408 :                     prefetch.seq = 0;

  0231c	c7 85 c0 01 00
	00 00 00 00 00	 mov	 DWORD PTR prefetch$[rbp], 0
$LN170@z900_execu:

; 5409 :                 }
; 5410 :                 ccwaddr -= 8;   /* (retry same ccw again) */

  02326	8b 45 24	 mov	 eax, DWORD PTR ccwaddr$[rbp]
  02329	83 e8 08	 sub	 eax, 8
  0232c	89 45 24	 mov	 DWORD PTR ccwaddr$[rbp], eax

; 5411 :                 continue;

  0232f	e9 89 e6 ff ff	 jmp	 $LN326@z900_execu
$LN169@z900_execu:

; 5412 :             }
; 5413 : 
; 5414 :             /* Handle command reject with no data transfer */
; 5415 :             if (residual == count &&
; 5416 :                 (unitstat & CSW_UC) &&

  02334	8b 45 18	 mov	 eax, DWORD PTR count$[rbp]
  02337	39 45 30	 cmp	 DWORD PTR residual$[rbp], eax
  0233a	75 5d		 jne	 SHORT $LN171@z900_execu
  0233c	0f b6 45 0c	 movzx	 eax, BYTE PTR unitstat$[rbp]
  02340	83 e0 02	 and	 eax, 2
  02343	85 c0		 test	 eax, eax
  02345	74 52		 je	 SHORT $LN171@z900_execu
  02347	b8 01 00 00 00	 mov	 eax, 1
  0234c	48 6b c0 00	 imul	 rax, rax, 0
  02350	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02354	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  0235c	25 80 00 00 00	 and	 eax, 128		; 00000080H
  02361	85 c0		 test	 eax, eax
  02363	74 34		 je	 SHORT $LN171@z900_execu

; 5417 :                 (dev->sense[0] & SENSE_CR))
; 5418 :             {
; 5419 :                 residual = 0;

  02365	c7 45 30 00 00
	00 00		 mov	 DWORD PTR residual$[rbp], 0

; 5420 :                 if (prefetch.seq)

  0236c	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  02373	74 1a		 je	 SHORT $LN173@z900_execu

; 5421 :                 {
; 5422 :                     ps = 0;

  02375	c7 45 10 00 00
	00 00		 mov	 DWORD PTR ps$[rbp], 0

; 5423 :                     ccwaddr = prefetch.ccwaddr[0];

  0237c	b8 04 00 00 00	 mov	 eax, 4
  02381	48 6b c0 00	 imul	 rax, rax, 0
  02385	8b 84 05 d0 02
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax+272]
  0238c	89 45 24	 mov	 DWORD PTR ccwaddr$[rbp], eax
$LN173@z900_execu:

; 5424 :                 }
; 5425 : 
; 5426 :                 goto breakchain;

  0238f	e9 4e 03 00 00	 jmp	 $breakchain$332

; 5427 :             }

  02394	e9 8d 02 00 00	 jmp	 $LN172@z900_execu
$LN171@z900_execu:

; 5428 : 
; 5429 :             /* Handle prefetch (write) conditions */
; 5430 :             else if (prefetch.seq)

  02399	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  023a0	0f 84 4d 01 00
	00		 je	 $LN174@z900_execu

; 5431 :             {
; 5432 :                 /* Set prefetch remaining byte count */
; 5433 :                 prefetch_remaining = count - residual;

  023a6	8b 45 30	 mov	 eax, DWORD PTR residual$[rbp]
  023a9	8b 4d 18	 mov	 ecx, DWORD PTR count$[rbp]
  023ac	2b c8		 sub	 ecx, eax
  023ae	8b c1		 mov	 eax, ecx
  023b0	89 45 7c	 mov	 DWORD PTR prefetch_remaining$[rbp], eax

; 5434 : 
; 5435 :                 /* Determine prefetched CCW limit and raise requested
; 5436 :                    PCI interrupts */
; 5437 :                 for (ps = ts = 0,

  023b3	c7 45 28 00 00
	00 00		 mov	 DWORD PTR ts$[rbp], 0
  023ba	8b 45 28	 mov	 eax, DWORD PTR ts$[rbp]
  023bd	89 45 10	 mov	 DWORD PTR ps$[rbp], eax
  023c0	c7 45 68 01 00
	00 00		 mov	 DWORD PTR prevccwaddr$[rbp], 1
  023c7	eb 08		 jmp	 SHORT $LN15@z900_execu
$LN13@z900_execu:

; 5440 :                      ts++)

  023c9	8b 45 28	 mov	 eax, DWORD PTR ts$[rbp]
  023cc	ff c0		 inc	 eax
  023ce	89 45 28	 mov	 DWORD PTR ts$[rbp], eax
$LN15@z900_execu:

; 5438 :                         prevccwaddr = 1;
; 5439 :                      ts < prefetch.seq;

  023d1	8b 85 c0 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp]
  023d7	39 45 28	 cmp	 DWORD PTR ts$[rbp], eax
  023da	0f 83 f3 00 00
	00		 jae	 $LN14@z900_execu

; 5441 :                 {
; 5442 :                     /* Set clean index not affected by loop completion
; 5443 :                        */
; 5444 :                     ps = ts;

  023e0	8b 45 28	 mov	 eax, DWORD PTR ts$[rbp]
  023e3	89 45 10	 mov	 DWORD PTR ps$[rbp], eax

; 5445 : 
; 5446 :                     /* ccwaddr and flags match each CCW encountered */
; 5447 :                     if (prevccwaddr != prefetch.ccwaddr[ps])

  023e6	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  023e9	8b 84 85 d0 02
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax*4+272]
  023f0	39 45 68	 cmp	 DWORD PTR prevccwaddr$[rbp], eax
  023f3	74 50		 je	 SHORT $LN176@z900_execu

; 5448 :                     {
; 5449 :                         flags = prefetch.ccwflags[ps];

  023f5	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  023f8	0f b6 84 05 d0
	12 00 00	 movzx	 eax, BYTE PTR prefetch$[rbp+rax+4368]
  02400	88 45 08	 mov	 BYTE PTR flags$[rbp], al

; 5450 :                         prevccwaddr = prefetch.ccwaddr[ps];

  02403	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  02406	8b 84 85 d0 02
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax*4+272]
  0240d	89 45 68	 mov	 DWORD PTR prevccwaddr$[rbp], eax

; 5451 :                         residual = count = prefetch.ccwcount[ps];

  02410	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  02413	0f b7 84 45 d0
	13 00 00	 movzx	 eax, WORD PTR prefetch$[rbp+rax*2+4624]
  0241b	89 45 18	 mov	 DWORD PTR count$[rbp], eax
  0241e	8b 45 18	 mov	 eax, DWORD PTR count$[rbp]
  02421	89 45 30	 mov	 DWORD PTR residual$[rbp], eax

; 5452 : 
; 5453 :                         /* Raise PCI interrupt */
; 5454 :                         if (flags & CCW_FLAGS_PCI)

  02424	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  02428	83 e0 08	 and	 eax, 8
  0242b	85 c0		 test	 eax, eax
  0242d	74 16		 je	 SHORT $LN177@z900_execu

; 5455 :                             ARCH_DEP(raise_pci) (dev, ccwkey, ccwfmt,

  0242f	44 8b 4d 68	 mov	 r9d, DWORD PTR prevccwaddr$[rbp]
  02433	44 0f b6 45 0b	 movzx	 r8d, BYTE PTR ccwfmt$[rbp]
  02438	0f b6 55 14	 movzx	 edx, BYTE PTR ccwkey$[rbp]
  0243c	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02440	e8 00 00 00 00	 call	 z900_raise_pci
$LN177@z900_execu:
$LN176@z900_execu:

; 5456 :                                                  prevccwaddr);
; 5457 :                     }
; 5458 : 
; 5459 :                     /* Adjust counts */
; 5460 :                     if (prefetch.datalen[ps])

  02445	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  02448	83 bc 85 d0 06
	00 00 00	 cmp	 DWORD PTR prefetch$[rbp+rax*4+1296], 0
  02450	74 5a		 je	 SHORT $LN178@z900_execu

; 5461 :                     {
; 5462 :                         if (residual >= prefetch.datalen[ps])

  02452	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  02455	8b 84 85 d0 06
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax*4+1296]
  0245c	39 45 30	 cmp	 DWORD PTR residual$[rbp], eax
  0245f	72 16		 jb	 SHORT $LN179@z900_execu

; 5463 :                             residual -= prefetch.datalen[ps];

  02461	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  02464	8b 84 85 d0 06
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax*4+1296]
  0246b	8b 4d 30	 mov	 ecx, DWORD PTR residual$[rbp]
  0246e	2b c8		 sub	 ecx, eax
  02470	8b c1		 mov	 eax, ecx
  02472	89 45 30	 mov	 DWORD PTR residual$[rbp], eax
  02475	eb 07		 jmp	 SHORT $LN180@z900_execu
$LN179@z900_execu:

; 5464 :                         else
; 5465 :                             residual = 0;

  02477	c7 45 30 00 00
	00 00		 mov	 DWORD PTR residual$[rbp], 0
$LN180@z900_execu:

; 5466 : 
; 5467 :                         if (prefetch_remaining >= prefetch.datalen[ps])

  0247e	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  02481	8b 84 85 d0 06
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax*4+1296]
  02488	39 45 7c	 cmp	 DWORD PTR prefetch_remaining$[rbp], eax
  0248b	72 16		 jb	 SHORT $LN181@z900_execu

; 5468 :                             prefetch_remaining -= prefetch.datalen[ps];

  0248d	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  02490	8b 84 85 d0 06
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax*4+1296]
  02497	8b 4d 7c	 mov	 ecx, DWORD PTR prefetch_remaining$[rbp]
  0249a	2b c8		 sub	 ecx, eax
  0249c	8b c1		 mov	 eax, ecx
  0249e	89 45 7c	 mov	 DWORD PTR prefetch_remaining$[rbp], eax
  024a1	eb 09		 jmp	 SHORT $LN182@z900_execu
$LN181@z900_execu:

; 5469 :                         else
; 5470 :                         {
; 5471 :                             prefetch_remaining = 0;

  024a3	c7 45 7c 00 00
	00 00		 mov	 DWORD PTR prefetch_remaining$[rbp], 0

; 5472 :                             break;

  024aa	eb 27		 jmp	 SHORT $LN14@z900_execu
$LN182@z900_execu:
$LN178@z900_execu:

; 5473 :                         }
; 5474 :                     }
; 5475 : 
; 5476 :                     /* Check for prefetch replay completed */
; 5477 :                     if (prefetch.chanstat[ps] ||

  024ac	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  024af	0f b6 84 05 d0
	01 00 00	 movzx	 eax, BYTE PTR prefetch$[rbp+rax+16]
  024b7	85 c0		 test	 eax, eax
  024b9	75 11		 jne	 SHORT $LN184@z900_execu
  024bb	83 7d 7c 00	 cmp	 DWORD PTR prefetch_remaining$[rbp], 0
  024bf	75 0d		 jne	 SHORT $LN183@z900_execu
  024c1	8b 85 c0 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp]
  024c7	39 45 10	 cmp	 DWORD PTR ps$[rbp], eax
  024ca	72 02		 jb	 SHORT $LN183@z900_execu
$LN184@z900_execu:

; 5478 :                         (!prefetch_remaining &&
; 5479 :                          (ps >= prefetch.seq)))
; 5480 :                         break;

  024cc	eb 05		 jmp	 SHORT $LN14@z900_execu
$LN183@z900_execu:

; 5481 : 
; 5482 :                 }

  024ce	e9 f6 fe ff ff	 jmp	 $LN13@z900_execu
$LN14@z900_execu:

; 5483 : 
; 5484 :                 /* Update SCSW CCW address and channel status */
; 5485 :                 ccwaddr  = prefetch.ccwaddr[ps];

  024d3	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  024d6	8b 84 85 d0 02
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax*4+272]
  024dd	89 45 24	 mov	 DWORD PTR ccwaddr$[rbp], eax

; 5486 :                 chanstat = prefetch.chanstat[ps];

  024e0	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  024e3	0f b6 84 05 d0
	01 00 00	 movzx	 eax, BYTE PTR prefetch$[rbp+rax+16]
  024eb	88 45 09	 mov	 BYTE PTR chanstat$[rbp], al

; 5487 : 
; 5488 :             } /* End prefetch status update */

  024ee	e9 33 01 00 00	 jmp	 $LN175@z900_execu
$LN174@z900_execu:

; 5489 : 
; 5490 : 
; 5491 :             /* For READ, SENSE, and READ BACKWARD operations, copy data
; 5492 :                from channel buffer to main storage, unless SKIP is set
; 5493 :             */
; 5494 :             else if (1
; 5495 :                 && !dev->is_immed
; 5496 :                 && !skip_ccws
; 5497 :                 && !(flags & CCW_FLAGS_SKIP)
; 5498 :                 && (0

  024f3	33 c0		 xor	 eax, eax
  024f5	83 f8 01	 cmp	 eax, 1
  024f8	0f 84 28 01 00
	00		 je	 $LN185@z900_execu
  024fe	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02502	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  02509	0f 85 17 01 00
	00		 jne	 $LN185@z900_execu
  0250f	83 7d 64 00	 cmp	 DWORD PTR skip_ccws$[rbp], 0
  02513	0f 85 0d 01 00
	00		 jne	 $LN185@z900_execu
  02519	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  0251d	83 e0 10	 and	 eax, 16
  02520	85 c0		 test	 eax, eax
  02522	0f 85 fe 00 00
	00		 jne	 $LN185@z900_execu
  02528	33 c0		 xor	 eax, eax
  0252a	85 c0		 test	 eax, eax
  0252c	75 3d		 jne	 SHORT $LN186@z900_execu
  0252e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02532	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  02539	83 e0 03	 and	 eax, 3
  0253c	83 f8 02	 cmp	 eax, 2
  0253f	74 2a		 je	 SHORT $LN186@z900_execu
  02541	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02545	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  0254c	83 e0 0f	 and	 eax, 15
  0254f	83 f8 04	 cmp	 eax, 4
  02552	74 17		 je	 SHORT $LN186@z900_execu
  02554	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02558	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  0255f	83 e0 0f	 and	 eax, 15
  02562	83 f8 0c	 cmp	 eax, 12
  02565	0f 85 bb 00 00
	00		 jne	 $LN185@z900_execu
$LN186@z900_execu:

; 5499 :                     || IS_CCW_READ(   dev->code )
; 5500 :                     || IS_CCW_SENSE(  dev->code )
; 5501 :                     || IS_CCW_RDBACK( dev->code )
; 5502 :                    )
; 5503 :             )
; 5504 :             {
; 5505 :                 /* Copy data from I/O buffer to main storage */
; 5506 :                 ARCH_DEP(copy_iobuf) (dev, ccw, dev->code, flags, addr,

  0256b	48 8b 45 58	 mov	 rax, QWORD PTR iobuf$[rbp]
  0256f	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  02575	8b 4d 30	 mov	 ecx, DWORD PTR residual$[rbp]
  02578	8b 55 18	 mov	 edx, DWORD PTR count$[rbp]
  0257b	2b d1		 sub	 edx, ecx
  0257d	8b ca		 mov	 ecx, edx
  0257f	48 8d 95 c0 01
	00 00		 lea	 rdx, QWORD PTR prefetch$[rbp]
  02586	48 89 54 24 70	 mov	 QWORD PTR [rsp+112], rdx
  0258b	48 8d 55 30	 lea	 rdx, QWORD PTR residual$[rbp]
  0258f	48 89 54 24 68	 mov	 QWORD PTR [rsp+104], rdx
  02594	48 8d 55 09	 lea	 rdx, QWORD PTR chanstat$[rbp]
  02598	48 89 54 24 60	 mov	 QWORD PTR [rsp+96], rdx
  0259d	48 8b 55 58	 mov	 rdx, QWORD PTR iobuf$[rbp]
  025a1	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  025a5	48 89 54 24 58	 mov	 QWORD PTR [rsp+88], rdx
  025aa	48 8b 55 58	 mov	 rdx, QWORD PTR iobuf$[rbp]
  025ae	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  025b2	48 89 54 24 50	 mov	 QWORD PTR [rsp+80], rdx
  025b7	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  025bc	0f b7 45 44	 movzx	 eax, WORD PTR idapmask$[rbp]
  025c0	66 89 44 24 40	 mov	 WORD PTR [rsp+64], ax
  025c5	0f b6 45 16	 movzx	 eax, BYTE PTR idawfmt$[rbp]
  025c9	88 44 24 38	 mov	 BYTE PTR [rsp+56], al
  025cd	0f b6 45 14	 movzx	 eax, BYTE PTR ccwkey$[rbp]
  025d1	88 44 24 30	 mov	 BYTE PTR [rsp+48], al
  025d5	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  025d9	8b 45 1c	 mov	 eax, DWORD PTR addr$[rbp]
  025dc	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  025e0	44 0f b6 4d 08	 movzx	 r9d, BYTE PTR flags$[rbp]
  025e5	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  025e9	44 0f b6 80 7a
	02 00 00	 movzx	 r8d, BYTE PTR [rax+634]
  025f1	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR ccw$[rbp]
  025f8	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  025fc	e8 00 00 00 00	 call	 z900_copy_iobuf

; 5507 :                                       count - residual, ccwkey,
; 5508 :                                       idawfmt, idapmask,
; 5509 :                                       iobuf->data,
; 5510 :                                       iobuf->start, iobuf->end,
; 5511 :                                       &chanstat, &residual, &prefetch);
; 5512 : 
; 5513 :                 /* Update number of bytes in channel buffer */
; 5514 :                 bufpos = prefetch.pos;

  02601	8b 85 c4 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp+4]
  02607	89 45 60	 mov	 DWORD PTR bufpos$[rbp], eax

; 5515 : 
; 5516 :                 /* If error during copy, skip remaining CD CCWs */
; 5517 :                 if (chanstat && (flags & CCW_FLAGS_CD))

  0260a	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  0260e	85 c0		 test	 eax, eax
  02610	74 14		 je	 SHORT $LN187@z900_execu
  02612	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  02616	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0261b	85 c0		 test	 eax, eax
  0261d	74 07		 je	 SHORT $LN187@z900_execu

; 5518 :                     skip_ccws = 1;

  0261f	c7 45 64 01 00
	00 00		 mov	 DWORD PTR skip_ccws$[rbp], 1
$LN187@z900_execu:
$LN185@z900_execu:
$LN175@z900_execu:
$LN172@z900_execu:
$LN168@z900_execu:

; 5519 :             }
; 5520 :         }
; 5521 : 
; 5522 :         /* Check for incorrect length */
; 5523 :         if ((residual || more)
; 5524 :             && !(chanstat & ~(CSW_PCI | CSW_IL)))

  02626	83 7d 30 00	 cmp	 DWORD PTR residual$[rbp], 0
  0262a	75 0c		 jne	 SHORT $LN189@z900_execu
  0262c	0f b6 45 40	 movzx	 eax, BYTE PTR more$[rbp]
  02630	85 c0		 test	 eax, eax
  02632	0f 84 aa 00 00
	00		 je	 $LN188@z900_execu
$LN189@z900_execu:
  02638	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  0263c	25 3f ff ff ff	 and	 eax, -193		; ffffffffffffff3fH
  02641	85 c0		 test	 eax, eax
  02643	0f 85 99 00 00
	00		 jne	 $LN188@z900_execu

; 5525 :         {
; 5526 :             /* Set incorrect length status if not suppressed         */
; 5527 :             /* SA22-7201-05:                                         */
; 5528 :             /*  pp. 16-24 -- 16-25, Incorrect Length                 */
; 5529 :             /* GA22-7000-10:                                         */
; 5530 :             /*  p. 13-70, Incorrect Length                           */
; 5531 :             /*
; 5532 : 
; 5533 :             The SLI bit in the CCW ALWAYS suppresses incorrect length,
; 5534 :             regardless of Format-0 or Format-1 and regardless of whether
; 5535 :             the CCW is an immediate operation or not and regardless of
; 5536 :             whether the count field is zero or not (i.e. regardless of
; 5537 :             whether there is a residual or not).
; 5538 : 
; 5539 :             Incorrect length is also NEVER indicated for an immediate
; 5540 :             operation if the count field is zero, REGARDLESS of the
; 5541 :             SLI bit setting. This however only pertains to Format-1
; 5542 :             CCWs as only Format-1 CCWs may contain a length field of
; 5543 :             zero. The length field for a Format-0 CCW must always have
; 5544 :             a non-zero value from 1 to 65,535.
; 5545 : 
; 5546 :             So we only need to check for possible incorrect length
; 5547 :             if we have a residual.
; 5548 : 
; 5549 :             BUT... when:
; 5550 : 
; 5551 :                 a)  the CCW is an IMMEDIATE operation, and
; 5552 :                 b)  SLI bit NOT set (is zero), and
; 5553 :                 c)  the count field (residual) is non-zero,
; 5554 : 
; 5555 :             Then:
; 5556 : 
; 5557 :               Format-0:  Incorrect length is always SUPPRESSED.
; 5558 : 
; 5559 :               Format-1:  Incorrect length is always INDICATED...
; 5560 :                          UNLESS Incorrect-Length-Suppression Mode
; 5561 :                          is requested via the ORB 'L' flag!
; 5562 : 
; 5563 :                          That is to say, without the 'L' flag, Incor-
; 5564 :                          rect Length errors WILL occur for Format-1
; 5565 :                          immediate operations when there's a residual.
; 5566 : 
; 5567 :                          The ORB 'L' flag however, SUPPRESSES Incorrect
; 5568 :                          Length error for Format-1 immediate operations
; 5569 :                          causing them to behave the same as Format-0.
; 5570 :             */
; 5571 :             if (((residual && !(flags & CCW_FLAGS_SLI)) ||
; 5572 :                  ((more || (residual && prefetch.seq)) &&
; 5573 :                   !(flags & (CCW_FLAGS_CD | CCW_FLAGS_SLI))))
; 5574 : 
; 5575 :                 && !(dev->is_immed && (flags & CCW_FLAGS_CC))  /* DSF Debug */
; 5576 : 
; 5577 :                 && (0

  02649	83 7d 30 00	 cmp	 DWORD PTR residual$[rbp], 0
  0264d	74 0b		 je	 SHORT $LN192@z900_execu
  0264f	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  02653	83 e0 20	 and	 eax, 32			; 00000020H
  02656	85 c0		 test	 eax, eax
  02658	74 24		 je	 SHORT $LN191@z900_execu
$LN192@z900_execu:
  0265a	0f b6 45 40	 movzx	 eax, BYTE PTR more$[rbp]
  0265e	85 c0		 test	 eax, eax
  02660	75 0f		 jne	 SHORT $LN193@z900_execu
  02662	83 7d 30 00	 cmp	 DWORD PTR residual$[rbp], 0
  02666	74 7a		 je	 SHORT $LN190@z900_execu
  02668	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  0266f	74 71		 je	 SHORT $LN190@z900_execu
$LN193@z900_execu:
  02671	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  02675	25 a0 00 00 00	 and	 eax, 160		; 000000a0H
  0267a	85 c0		 test	 eax, eax
  0267c	75 64		 jne	 SHORT $LN190@z900_execu
$LN191@z900_execu:
  0267e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02682	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  02689	74 0b		 je	 SHORT $LN194@z900_execu
  0268b	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  0268f	83 e0 40	 and	 eax, 64			; 00000040H
  02692	85 c0		 test	 eax, eax
  02694	75 4c		 jne	 SHORT $LN190@z900_execu
$LN194@z900_execu:
  02696	33 c0		 xor	 eax, eax
  02698	85 c0		 test	 eax, eax
  0269a	75 3c		 jne	 SHORT $LN195@z900_execu
  0269c	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  026a0	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  026a7	74 2f		 je	 SHORT $LN195@z900_execu
  026a9	33 c0		 xor	 eax, eax
  026ab	83 f8 01	 cmp	 eax, 1
  026ae	74 32		 je	 SHORT $LN190@z900_execu
  026b0	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  026b4	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  026bb	25 80 00 00 00	 and	 eax, 128		; 00000080H
  026c0	85 c0		 test	 eax, eax
  026c2	74 1e		 je	 SHORT $LN190@z900_execu
  026c4	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  026c8	0f b6 80 d3 02
	00 00		 movzx	 eax, BYTE PTR [rax+723]
  026cf	25 80 00 00 00	 and	 eax, 128		; 00000080H
  026d4	85 c0		 test	 eax, eax
  026d6	75 0a		 jne	 SHORT $LN190@z900_execu
$LN195@z900_execu:

; 5578 :                     || !dev->is_immed
; 5579 : #if defined( FEATURE_INCORRECT_LENGTH_INDICATION_SUPPRESSION )
; 5580 : 
; 5581 :                     /* Immediate operation. If Format-1 WITHOUT the
; 5582 :                        ORB 'L' flag, then Incorrect Length. Otherwise
; 5583 :                        if Format-0, or Format-1 WITH Incorrect Length
; 5584 :                        Suppresion enabled, then IL is NOT indicated
; 5585 :                        (i.e. is SUPPRESSED).
; 5586 :                     */
; 5587 :                     || (1
; 5588 :                         &&  (dev->orb.flag5 & ORB5_F)
; 5589 :                         && !(dev->orb.flag7 & ORB7_L)
; 5590 :                        )
; 5591 : #endif /* defined( FEATURE_INCORRECT_LENGTH_INDICATION_SUPPRESSION ) */
; 5592 :                    )
; 5593 :             )
; 5594 :                 chanstat |= CSW_IL;

  026d8	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  026dc	83 c8 40	 or	 eax, 64			; 00000040H
  026df	88 45 09	 mov	 BYTE PTR chanstat$[rbp], al
$LN190@z900_execu:
$LN188@z900_execu:
$breakchain$332:

; 5595 :         }
; 5596 : 
; 5597 : breakchain:
; 5598 : 
; 5599 :         if (unlikely((chanstat & (CSW_PROGC | CSW_PROTC | CSW_CDC |

  026e2	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  026e6	83 e0 3f	 and	 eax, 63			; 0000003fH
  026e9	85 c0		 test	 eax, eax
  026eb	75 30		 jne	 SHORT $LN287@z900_execu
  026ed	0f b6 45 0c	 movzx	 eax, BYTE PTR unitstat$[rbp]
  026f1	83 e0 02	 and	 eax, 2
  026f4	85 c0		 test	 eax, eax
  026f6	74 19		 je	 SHORT $LN286@z900_execu
  026f8	b8 01 00 00 00	 mov	 eax, 1
  026fd	48 6b c0 00	 imul	 rax, rax, 0
  02701	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02705	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  0270d	85 c0		 test	 eax, eax
  0270f	75 0c		 jne	 SHORT $LN287@z900_execu
$LN286@z900_execu:
  02711	c7 85 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1685[rbp], 0
  0271b	eb 0a		 jmp	 SHORT $LN291@z900_execu
$LN287@z900_execu:
  0271d	c7 85 d4 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv1685[rbp], 1
$LN291@z900_execu:
  02727	83 bd d4 00 00
	00 00		 cmp	 DWORD PTR tv1685[rbp], 0
  0272e	0f 84 dd 02 00
	00		 je	 $LN196@z900_execu

; 5600 :                                   CSW_CCC   | CSW_ICC   | CSW_CHC))
; 5601 :                   || ((unitstat & CSW_UC) && dev->sense[0])))
; 5602 :         {
; 5603 : 
; 5604 :             BYTE  tracing_active  = CCW_TRACING_ACTIVE( dev, tracethis );

  02734	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02738	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0273e	c1 e8 0f	 shr	 eax, 15
  02741	83 e0 01	 and	 eax, 1
  02744	85 c0		 test	 eax, eax
  02746	75 14		 jne	 SHORT $LN292@z900_execu
  02748	0f b6 45 15	 movzx	 eax, BYTE PTR tracethis$[rbp]
  0274c	85 c0		 test	 eax, eax
  0274e	75 0c		 jne	 SHORT $LN292@z900_execu
  02750	c7 85 d8 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1693[rbp], 0
  0275a	eb 0a		 jmp	 SHORT $LN293@z900_execu
$LN292@z900_execu:
  0275c	c7 85 d8 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv1693[rbp], 1
$LN293@z900_execu:
  02766	0f b6 85 d8 00
	00 00		 movzx	 eax, BYTE PTR tv1693[rbp]
  0276d	88 45 6c	 mov	 BYTE PTR tracing_active$6[rbp], al

; 5605 :             BYTE  cpu_tracing     = CPU_STEPPING_OR_TRACING_ALL;

  02770	b8 08 00 00 00	 mov	 eax, 8
  02775	48 6b c0 00	 imul	 rax, rax, 0
  02779	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  02780	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  02789	75 32		 jne	 SHORT $LN294@z900_execu
  0278b	b8 08 00 00 00	 mov	 eax, 8
  02790	48 6b c0 01	 imul	 rax, rax, 1
  02794	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0279b	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  027a4	75 17		 jne	 SHORT $LN294@z900_execu
  027a6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  027ad	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  027b3	c1 e8 0a	 shr	 eax, 10
  027b6	83 e0 01	 and	 eax, 1
  027b9	85 c0		 test	 eax, eax
  027bb	75 4e		 jne	 SHORT $LN296@z900_execu
$LN294@z900_execu:
  027bd	b8 08 00 00 00	 mov	 eax, 8
  027c2	48 6b c0 00	 imul	 rax, rax, 0
  027c6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  027cd	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  027d6	75 27		 jne	 SHORT $LN295@z900_execu
  027d8	b8 08 00 00 00	 mov	 eax, 8
  027dd	48 6b c0 01	 imul	 rax, rax, 1
  027e1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  027e8	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  027f1	75 0c		 jne	 SHORT $LN295@z900_execu
  027f3	e8 00 00 00 00	 call	 insttrace_all
  027f8	0f b6 c0	 movzx	 eax, al
  027fb	85 c0		 test	 eax, eax
  027fd	75 0c		 jne	 SHORT $LN296@z900_execu
$LN295@z900_execu:
  027ff	c7 85 dc 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1718[rbp], 0
  02809	eb 0a		 jmp	 SHORT $LN297@z900_execu
$LN296@z900_execu:
  0280b	c7 85 dc 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv1718[rbp], 1
$LN297@z900_execu:
  02815	0f b6 85 dc 00
	00 00		 movzx	 eax, BYTE PTR tv1718[rbp]
  0281c	88 45 4a	 mov	 BYTE PTR cpu_tracing$4[rbp], al

; 5606 :             BYTE  ostailor_quiet  = (sysblk.pgminttr == 0);

  0281f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  02826	48 83 b8 48 13
	00 00 00	 cmp	 QWORD PTR [rax+4936], 0
  0282e	75 0c		 jne	 SHORT $LN298@z900_execu
  02830	c7 85 e0 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv1722[rbp], 1
  0283a	eb 0a		 jmp	 SHORT $LN299@z900_execu
$LN298@z900_execu:
  0283c	c7 85 e0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1722[rbp], 0
$LN299@z900_execu:
  02846	0f b6 85 e0 00
	00 00		 movzx	 eax, BYTE PTR tv1722[rbp]
  0284d	88 45 48	 mov	 BYTE PTR ostailor_quiet$2[rbp], al

; 5607 :             BYTE  ccw_tracing     = dev->ccwtrace;

  02850	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02854	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0285a	c1 e8 0f	 shr	 eax, 15
  0285d	83 e0 01	 and	 eax, 1
  02860	88 45 54	 mov	 BYTE PTR ccw_tracing$5[rbp], al

; 5608 :             BYTE  skip_ch9uc      = SKIP_CH9UC( dev, chanstat, unitstat );

  02863	33 c0		 xor	 eax, eax
  02865	83 f8 01	 cmp	 eax, 1
  02868	0f 84 e3 00 00
	00		 je	 $LN300@z900_execu
  0286e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02872	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  02878	c1 e8 0f	 shr	 eax, 15
  0287b	83 e0 01	 and	 eax, 1
  0287e	85 c0		 test	 eax, eax
  02880	0f 85 cb 00 00
	00		 jne	 $LN300@z900_execu
  02886	b8 08 00 00 00	 mov	 eax, 8
  0288b	48 6b c0 00	 imul	 rax, rax, 0
  0288f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  02896	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  0289f	75 32		 jne	 SHORT $LN301@z900_execu
  028a1	b8 08 00 00 00	 mov	 eax, 8
  028a6	48 6b c0 01	 imul	 rax, rax, 1
  028aa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  028b1	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  028ba	75 17		 jne	 SHORT $LN301@z900_execu
  028bc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  028c3	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  028c9	c1 e8 0a	 shr	 eax, 10
  028cc	83 e0 01	 and	 eax, 1
  028cf	85 c0		 test	 eax, eax
  028d1	75 7e		 jne	 SHORT $LN303@z900_execu
$LN301@z900_execu:
  028d3	b8 08 00 00 00	 mov	 eax, 8
  028d8	48 6b c0 00	 imul	 rax, rax, 0
  028dc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  028e3	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  028ec	75 27		 jne	 SHORT $LN302@z900_execu
  028ee	b8 08 00 00 00	 mov	 eax, 8
  028f3	48 6b c0 01	 imul	 rax, rax, 1
  028f7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  028fe	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  02907	75 0c		 jne	 SHORT $LN302@z900_execu
  02909	e8 00 00 00 00	 call	 insttrace_all
  0290e	0f b6 c0	 movzx	 eax, al
  02911	85 c0		 test	 eax, eax
  02913	75 3c		 jne	 SHORT $LN303@z900_execu
$LN302@z900_execu:
  02915	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0291c	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  02922	c1 e8 19	 shr	 eax, 25
  02925	83 e0 01	 and	 eax, 1
  02928	85 c0		 test	 eax, eax
  0292a	74 25		 je	 SHORT $LN300@z900_execu
  0292c	44 0f b6 45 0c	 movzx	 r8d, BYTE PTR unitstat$[rbp]
  02931	0f b6 55 09	 movzx	 edx, BYTE PTR chanstat$[rbp]
  02935	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02939	e8 00 00 00 00	 call	 is_ch9oflow
  0293e	0f b6 c0	 movzx	 eax, al
  02941	85 c0		 test	 eax, eax
  02943	74 0c		 je	 SHORT $LN300@z900_execu
  02945	c7 85 e4 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv1766[rbp], 1
  0294f	eb 0a		 jmp	 SHORT $LN304@z900_execu
$LN300@z900_execu:
$LN303@z900_execu:
  02951	c7 85 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1766[rbp], 0
$LN304@z900_execu:
  0295b	0f b6 85 e4 00
	00 00		 movzx	 eax, BYTE PTR tv1766[rbp]
  02962	88 45 49	 mov	 BYTE PTR skip_ch9uc$3[rbp], al

; 5609 : 
; 5610 :             /* Trace the CCW if not already done */
; 5611 :             if (1
; 5612 :                 && !tracing_active
; 5613 :                 && (0
; 5614 :                     || cpu_tracing
; 5615 :                     || !ostailor_quiet
; 5616 :                     || ccw_tracing
; 5617 :                    )
; 5618 :                 && !skip_ch9uc

  02965	33 c0		 xor	 eax, eax
  02967	83 f8 01	 cmp	 eax, 1
  0296a	74 72		 je	 SHORT $LN198@z900_execu
  0296c	0f b6 45 6c	 movzx	 eax, BYTE PTR tracing_active$6[rbp]
  02970	85 c0		 test	 eax, eax
  02972	75 6a		 jne	 SHORT $LN198@z900_execu
  02974	33 c0		 xor	 eax, eax
  02976	85 c0		 test	 eax, eax
  02978	75 18		 jne	 SHORT $LN199@z900_execu
  0297a	0f b6 45 4a	 movzx	 eax, BYTE PTR cpu_tracing$4[rbp]
  0297e	85 c0		 test	 eax, eax
  02980	75 10		 jne	 SHORT $LN199@z900_execu
  02982	0f b6 45 48	 movzx	 eax, BYTE PTR ostailor_quiet$2[rbp]
  02986	85 c0		 test	 eax, eax
  02988	74 08		 je	 SHORT $LN199@z900_execu
  0298a	0f b6 45 54	 movzx	 eax, BYTE PTR ccw_tracing$5[rbp]
  0298e	85 c0		 test	 eax, eax
  02990	74 4c		 je	 SHORT $LN198@z900_execu
$LN199@z900_execu:
  02992	0f b6 45 49	 movzx	 eax, BYTE PTR skip_ch9uc$3[rbp]
  02996	85 c0		 test	 eax, eax
  02998	75 44		 jne	 SHORT $LN198@z900_execu

; 5619 :             )
; 5620 :             {
; 5621 :                 ioerror = 1;

  0299a	c6 45 2c 01	 mov	 BYTE PTR ioerror$[rbp], 1

; 5622 :                 DISPLAY_CCW (dev, ccw, addr, count, flags);

  0299e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196766
  029a5	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  029aa	c7 44 24 30 f6
	15 00 00	 mov	 DWORD PTR [rsp+48], 5622 ; 000015f6H
  029b2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196767
  029b9	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  029be	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  029c2	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  029c6	44 8b 4d 18	 mov	 r9d, DWORD PTR count$[rbp]
  029ca	44 8b 45 1c	 mov	 r8d, DWORD PTR addr$[rbp]
  029ce	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR ccw$[rbp]
  029d5	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  029d9	e8 00 00 00 00	 call	 _display_ccw
$LN198@z900_execu:

; 5623 :             }
; 5624 : 
; 5625 :             /* Activate tracing for this CCW chain only
; 5626 :                if any trace is already active */
; 5627 :             if (0
; 5628 :                 || ccw_tracing
; 5629 :                 || cpu_tracing
; 5630 :                 || (1

  029de	33 c0		 xor	 eax, eax
  029e0	85 c0		 test	 eax, eax
  029e2	75 27		 jne	 SHORT $LN201@z900_execu
  029e4	0f b6 45 54	 movzx	 eax, BYTE PTR ccw_tracing$5[rbp]
  029e8	85 c0		 test	 eax, eax
  029ea	75 1f		 jne	 SHORT $LN201@z900_execu
  029ec	0f b6 45 4a	 movzx	 eax, BYTE PTR cpu_tracing$4[rbp]
  029f0	85 c0		 test	 eax, eax
  029f2	75 17		 jne	 SHORT $LN201@z900_execu
  029f4	33 c0		 xor	 eax, eax
  029f6	83 f8 01	 cmp	 eax, 1
  029f9	74 14		 je	 SHORT $LN200@z900_execu
  029fb	0f b6 45 48	 movzx	 eax, BYTE PTR ostailor_quiet$2[rbp]
  029ff	85 c0		 test	 eax, eax
  02a01	75 0c		 jne	 SHORT $LN200@z900_execu
  02a03	0f b6 45 49	 movzx	 eax, BYTE PTR skip_ch9uc$3[rbp]
  02a07	85 c0		 test	 eax, eax
  02a09	75 04		 jne	 SHORT $LN200@z900_execu
$LN201@z900_execu:

; 5631 :                     && !ostailor_quiet
; 5632 :                     && !skip_ch9uc
; 5633 :                    )
; 5634 :             )
; 5635 :             {
; 5636 :                 tracethis = 1;

  02a0b	c6 45 15 01	 mov	 BYTE PTR tracethis$[rbp], 1
$LN200@z900_execu:

; 5637 :             }
; 5638 :         }

  02a0f	eb 04		 jmp	 SHORT $LN197@z900_execu
$LN196@z900_execu:

; 5639 :         else
; 5640 :             ioerror = 0;

  02a11	c6 45 2c 00	 mov	 BYTE PTR ioerror$[rbp], 0
$LN197@z900_execu:

; 5641 : 
; 5642 :         /* Trace the results of CCW execution */
; 5643 :         if (unlikely( CCW_TRACING_ACTIVE( dev, tracethis )))

  02a15	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02a19	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  02a1f	c1 e8 0f	 shr	 eax, 15
  02a22	83 e0 01	 and	 eax, 1
  02a25	85 c0		 test	 eax, eax
  02a27	75 14		 jne	 SHORT $LN305@z900_execu
  02a29	0f b6 45 15	 movzx	 eax, BYTE PTR tracethis$[rbp]
  02a2d	85 c0		 test	 eax, eax
  02a2f	75 0c		 jne	 SHORT $LN305@z900_execu
  02a31	c7 85 e8 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1813[rbp], 0
  02a3b	eb 0a		 jmp	 SHORT $LN308@z900_execu
$LN305@z900_execu:
  02a3d	c7 85 e8 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv1813[rbp], 1
$LN308@z900_execu:
  02a47	83 bd e8 00 00
	00 00		 cmp	 DWORD PTR tv1813[rbp], 0
  02a4e	0f 84 bd 08 00
	00		 je	 $LN202@z900_execu

; 5644 :         {
; 5645 : #if DEBUG_PREFETCH
; 5646 :             if (!prefetch.seq)
; 5647 :             {
; 5648 :                 char msgbuf[133];
; 5649 :                 MSGBUF( msgbuf, "flags=%2.2X count=%d (%4.4X) "
; 5650 :                                 "residual=%d (%4.4X) "
; 5651 :                                 "more=%d "
; 5652 :                                 "bufpos=%d",
; 5653 :                                 flags,
; 5654 :                                 count, count,
; 5655 :                                 residual, residual,
; 5656 :                                 more, bufpos );
; 5657 :                 WRMSG( HHC01392, "D", msgbuf );
; 5658 :             }
; 5659 : #endif
; 5660 : 
; 5661 :             /* Display prefetch data */
; 5662 :             if (prefetch.seq)

  02a54	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  02a5b	0f 84 56 01 00
	00		 je	 $LN203@z900_execu

; 5663 :             {
; 5664 :                 /* Display prefetch table */
; 5665 :                 DISPLAY_PREFETCH(&prefetch, ps, count, residual, more);
; 5666 : 
; 5667 :                 /* Loop through prefetch table for CCW/IDAW display */
; 5668 :                 for (ts = 0, prevccwaddr = 1;

  02a61	c7 45 28 00 00
	00 00		 mov	 DWORD PTR ts$[rbp], 0
  02a68	c7 45 68 01 00
	00 00		 mov	 DWORD PTR prevccwaddr$[rbp], 1
  02a6f	eb 08		 jmp	 SHORT $LN18@z900_execu
$LN16@z900_execu:

; 5670 :                      ts++)

  02a71	8b 45 28	 mov	 eax, DWORD PTR ts$[rbp]
  02a74	ff c0		 inc	 eax
  02a76	89 45 28	 mov	 DWORD PTR ts$[rbp], eax
$LN18@z900_execu:

; 5669 :                      ts < ps && ts < prefetch.seq;

  02a79	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  02a7c	39 45 28	 cmp	 DWORD PTR ts$[rbp], eax
  02a7f	0f 83 02 01 00
	00		 jae	 $LN17@z900_execu
  02a85	8b 85 c0 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp]
  02a8b	39 45 28	 cmp	 DWORD PTR ts$[rbp], eax
  02a8e	0f 83 f3 00 00
	00		 jae	 $LN17@z900_execu

; 5671 :                 {
; 5672 :                     if (prevccwaddr != prefetch.ccwaddr[ts])

  02a94	8b 45 28	 mov	 eax, DWORD PTR ts$[rbp]
  02a97	8b 84 85 d0 02
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax*4+272]
  02a9e	39 45 68	 cmp	 DWORD PTR prevccwaddr$[rbp], eax
  02aa1	74 75		 je	 SHORT $LN204@z900_execu

; 5673 :                     {
; 5674 :                         prevccwaddr = prefetch.ccwaddr[ts];

  02aa3	8b 45 28	 mov	 eax, DWORD PTR ts$[rbp]
  02aa6	8b 84 85 d0 02
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax*4+272]
  02aad	89 45 68	 mov	 DWORD PTR prevccwaddr$[rbp], eax

; 5675 :                         if (ts)

  02ab0	83 7d 28 00	 cmp	 DWORD PTR ts$[rbp], 0
  02ab4	74 62		 je	 SHORT $LN205@z900_execu

; 5676 :                         {
; 5677 :                             /* Display CCW */
; 5678 :                             DISPLAY_CCW (dev,

  02ab6	8b 45 28	 mov	 eax, DWORD PTR ts$[rbp]
  02ab9	8b 4d 28	 mov	 ecx, DWORD PTR ts$[rbp]
  02abc	8b 55 28	 mov	 edx, DWORD PTR ts$[rbp]
  02abf	8b 94 95 d0 02
	00 00		 mov	 edx, DWORD PTR prefetch$[rbp+rdx*4+272]
  02ac6	83 ea 08	 sub	 edx, 8
  02ac9	8b d2		 mov	 edx, edx
  02acb	48 8b 7d 00	 mov	 rdi, QWORD PTR dev$[rbp]
  02acf	48 03 97 80 00
	00 00		 add	 rdx, QWORD PTR [rdi+128]
  02ad6	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:$SG196774
  02add	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  02ae2	c7 44 24 30 33
	16 00 00	 mov	 DWORD PTR [rsp+48], 5683 ; 00001633H
  02aea	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:$SG196775
  02af1	48 89 7c 24 28	 mov	 QWORD PTR [rsp+40], rdi
  02af6	0f b6 7d 08	 movzx	 edi, BYTE PTR flags$[rbp]
  02afa	40 88 7c 24 20	 mov	 BYTE PTR [rsp+32], dil
  02aff	44 8b 8c 85 d0
	06 00 00	 mov	 r9d, DWORD PTR prefetch$[rbp+rax*4+1296]
  02b07	44 8b 84 cd d0
	0a 00 00	 mov	 r8d, DWORD PTR prefetch$[rbp+rcx*8+2320]
  02b0f	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02b13	e8 00 00 00 00	 call	 _display_ccw
$LN205@z900_execu:
$LN204@z900_execu:

; 5679 :                                          dev->mainstor +
; 5680 :                                            (prefetch.ccwaddr[ts] - 8),
; 5681 :                                          prefetch.dataaddr[ts],
; 5682 :                                          prefetch.datalen[ts],
; 5683 :                                          flags);
; 5684 : 
; 5685 :                         }
; 5686 :                     }
; 5687 :                     if (prefetch.idawtype[ts])

  02b18	8b 45 28	 mov	 eax, DWORD PTR ts$[rbp]
  02b1b	0f b6 84 05 d0
	19 00 00	 movzx	 eax, BYTE PTR prefetch$[rbp+rax+6160]
  02b23	85 c0		 test	 eax, eax
  02b25	74 5b		 je	 SHORT $LN206@z900_execu

; 5688 :                         DISPLAY_IDAW(dev,

  02b27	8b 45 28	 mov	 eax, DWORD PTR ts$[rbp]
  02b2a	8b 4d 28	 mov	 ecx, DWORD PTR ts$[rbp]
  02b2d	8b 55 28	 mov	 edx, DWORD PTR ts$[rbp]
  02b30	8b 7d 28	 mov	 edi, DWORD PTR ts$[rbp]
  02b33	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196777
  02b3a	4c 89 44 24 38	 mov	 QWORD PTR [rsp+56], r8
  02b3f	c7 44 24 30 3c
	16 00 00	 mov	 DWORD PTR [rsp+48], 5692 ; 0000163cH
  02b47	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196778
  02b4e	4c 89 44 24 28	 mov	 QWORD PTR [rsp+40], r8
  02b53	0f b7 84 85 d0
	06 00 00	 movzx	 eax, WORD PTR prefetch$[rbp+rax*4+1296]
  02b5b	66 89 44 24 20	 mov	 WORD PTR [rsp+32], ax
  02b60	4c 8b 8c cd d0
	0a 00 00	 mov	 r9, QWORD PTR prefetch$[rbp+rcx*8+2320]
  02b68	44 0f b6 84 15
	d0 1a 00 00	 movzx	 r8d, BYTE PTR prefetch$[rbp+rdx+6416]
  02b71	0f b6 94 3d d0
	19 00 00	 movzx	 edx, BYTE PTR prefetch$[rbp+rdi+6160]
  02b79	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02b7d	e8 00 00 00 00	 call	 _display_idaw
$LN206@z900_execu:

; 5689 :                                      prefetch.idawtype[ts],
; 5690 :                                      prefetch.idawflag[ts],
; 5691 :                                      prefetch.dataaddr[ts],
; 5692 :                                      prefetch.datalen[ts]);
; 5693 :                 }

  02b82	e9 ea fe ff ff	 jmp	 $LN16@z900_execu
$LN17@z900_execu:

; 5694 : 
; 5695 :                 /* Don't display data area on status */
; 5696 :                 area[0] = 0x00;

  02b87	b8 01 00 00 00	 mov	 eax, 1
  02b8c	48 6b c0 00	 imul	 rax, rax, 0
  02b90	48 89 85 98 01
	00 00		 mov	 QWORD PTR $T10[rbp], rax
  02b97	48 83 bd 98 01
	00 00 40	 cmp	 QWORD PTR $T10[rbp], 64	; 00000040H
  02b9f	73 02		 jae	 SHORT $LN309@z900_execu
  02ba1	eb 05		 jmp	 SHORT $LN310@z900_execu
$LN309@z900_execu:
  02ba3	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN310@z900_execu:
  02ba8	48 8b 85 98 01
	00 00		 mov	 rax, QWORD PTR $T10[rbp]
  02baf	c6 84 05 00 30
	01 00 00	 mov	 BYTE PTR area$[rbp+rax], 0
$LN203@z900_execu:

; 5697 :             }
; 5698 : 
; 5699 :             /* Trace the read type CCW, UNLESS... the IDA/MIDA flag
; 5700 :                is on. When the IDA/MIDA flag is on for read type CCWs,
; 5701 :                the copy_iobuf function traces the CCW before it traces
; 5702 :                the IDA/MIDA.
; 5703 :             */
; 5704 :             if (1
; 5705 :                 && !(flags & CCW_FLAGS_IDA)
; 5706 :                 && !(flags & CCW_FLAGS_MIDAW)

  02bb7	33 c0		 xor	 eax, eax
  02bb9	83 f8 01	 cmp	 eax, 1
  02bbc	74 5e		 je	 SHORT $LN207@z900_execu
  02bbe	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  02bc2	83 e0 04	 and	 eax, 4
  02bc5	85 c0		 test	 eax, eax
  02bc7	75 53		 jne	 SHORT $LN207@z900_execu
  02bc9	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  02bcd	83 e0 01	 and	 eax, 1
  02bd0	85 c0		 test	 eax, eax
  02bd2	75 48		 jne	 SHORT $LN207@z900_execu

; 5707 :             )
; 5708 :             {
; 5709 :                 /* If we're tracing due to an I/O error, then the CCW
; 5710 :                    has already been traced further above, so we DON'T
; 5711 :                    want to do it here again!
; 5712 :                 */
; 5713 :                 if (!ioerror)

  02bd4	0f b6 45 2c	 movzx	 eax, BYTE PTR ioerror$[rbp]
  02bd8	85 c0		 test	 eax, eax
  02bda	75 40		 jne	 SHORT $LN208@z900_execu

; 5714 :                     DISPLAY_CCW( dev, ccw, addr, count, flags );

  02bdc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196781
  02be3	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  02be8	c7 44 24 30 52
	16 00 00	 mov	 DWORD PTR [rsp+48], 5714 ; 00001652H
  02bf0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196782
  02bf7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  02bfc	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  02c00	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  02c04	44 8b 4d 18	 mov	 r9d, DWORD PTR count$[rbp]
  02c08	44 8b 45 1c	 mov	 r8d, DWORD PTR addr$[rbp]
  02c0c	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR ccw$[rbp]
  02c13	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02c17	e8 00 00 00 00	 call	 _display_ccw
$LN208@z900_execu:
$LN207@z900_execu:

; 5715 :             }
; 5716 : 
; 5717 :             ioerror = 0; // (reset flag)

  02c1c	c6 45 2c 00	 mov	 BYTE PTR ioerror$[rbp], 0

; 5718 : 
; 5719 :             /* Display status and residual byte count */
; 5720 : 
; 5721 :             if (dev->ccwtrace && sysblk.traceFILE)

  02c20	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02c24	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  02c2a	c1 e8 0f	 shr	 eax, 15
  02c2d	83 e0 01	 and	 eax, 1
  02c30	85 c0		 test	 eax, eax
  02c32	74 62		 je	 SHORT $LN209@z900_execu
  02c34	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  02c3b	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  02c43	74 51		 je	 SHORT $LN209@z900_execu

; 5722 :                 tf_1312( dev, unitstat, chanstat, (BYTE) MIN( count, 16 ), residual, iobuf->data );

  02c45	83 7d 18 10	 cmp	 DWORD PTR count$[rbp], 16
  02c49	73 0b		 jae	 SHORT $LN311@z900_execu
  02c4b	8b 45 18	 mov	 eax, DWORD PTR count$[rbp]
  02c4e	89 85 ec 00 00
	00		 mov	 DWORD PTR tv1936[rbp], eax
  02c54	eb 0a		 jmp	 SHORT $LN312@z900_execu
$LN311@z900_execu:
  02c56	c7 85 ec 00 00
	00 10 00 00 00	 mov	 DWORD PTR tv1936[rbp], 16
$LN312@z900_execu:
  02c60	48 8b 45 58	 mov	 rax, QWORD PTR iobuf$[rbp]
  02c64	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  02c6a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  02c6f	8b 45 30	 mov	 eax, DWORD PTR residual$[rbp]
  02c72	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  02c76	44 0f b6 8d ec
	00 00 00	 movzx	 r9d, BYTE PTR tv1936[rbp]
  02c7e	44 0f b6 45 09	 movzx	 r8d, BYTE PTR chanstat$[rbp]
  02c83	0f b6 55 0c	 movzx	 edx, BYTE PTR unitstat$[rbp]
  02c87	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02c8b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1312
  02c91	e9 ce 00 00 00	 jmp	 $LN210@z900_execu
$LN209@z900_execu:

; 5723 :             else
; 5724 :                 // "%1d:%04X CHAN: stat %2.2X%2.2X, count %4.4X"
; 5725 :                 WRMSG( HHC01312, "I", LCSS_DEVNUM,

  02c96	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  02c9b	74 10		 je	 SHORT $LN313@z900_execu
  02c9d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02ca1	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  02ca5	89 85 f0 00 00
	00		 mov	 DWORD PTR tv1949[rbp], eax
  02cab	eb 0a		 jmp	 SHORT $LN314@z900_execu
$LN313@z900_execu:
  02cad	c7 85 f0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1949[rbp], 0
$LN314@z900_execu:
  02cb7	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  02cbc	74 12		 je	 SHORT $LN315@z900_execu
  02cbe	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02cc2	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  02cc6	d1 f8		 sar	 eax, 1
  02cc8	89 85 f4 00 00
	00		 mov	 DWORD PTR tv1955[rbp], eax
  02cce	eb 0a		 jmp	 SHORT $LN316@z900_execu
$LN315@z900_execu:
  02cd0	c7 85 f4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1955[rbp], 0
$LN316@z900_execu:
  02cda	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  02cde	89 85 78 01 00
	00		 mov	 DWORD PTR tv1942[rbp], eax
  02ce4	0f b6 4d 0c	 movzx	 ecx, BYTE PTR unitstat$[rbp]
  02ce8	89 8d 7c 01 00
	00		 mov	 DWORD PTR tv1944[rbp], ecx
  02cee	b9 01 00 00 00	 mov	 ecx, 1
  02cf3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02cf9	8b 4d 30	 mov	 ecx, DWORD PTR residual$[rbp]
  02cfc	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  02d00	8b 8d 78 01 00
	00		 mov	 ecx, DWORD PTR tv1942[rbp]
  02d06	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  02d0a	8b 8d 7c 01 00
	00		 mov	 ecx, DWORD PTR tv1944[rbp]
  02d10	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  02d14	8b 8d f0 00 00
	00		 mov	 ecx, DWORD PTR tv1949[rbp]
  02d1a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  02d1e	8b 8d f4 00 00
	00		 mov	 ecx, DWORD PTR tv1955[rbp]
  02d24	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  02d28	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196785
  02d2f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  02d34	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196786
  02d3b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02d40	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02d45	41 b9 03 00 00
	00		 mov	 r9d, 3
  02d4b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196787
  02d52	ba 5e 16 00 00	 mov	 edx, 5726		; 0000165eH
  02d57	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196788
  02d5e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN210@z900_execu:

; 5726 :                     unitstat, chanstat, residual );
; 5727 : 
; 5728 :             /* Display sense bytes if unit check is indicated */
; 5729 :             if (unitstat & CSW_UC)

  02d64	0f b6 45 0c	 movzx	 eax, BYTE PTR unitstat$[rbp]
  02d68	83 e0 02	 and	 eax, 2
  02d6b	85 c0		 test	 eax, eax
  02d6d	0f 84 9e 05 00
	00		 je	 $LN211@z900_execu

; 5730 :             {
; 5731 :                 if (dev->ccwtrace && sysblk.traceFILE)

  02d73	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02d77	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  02d7d	c1 e8 0f	 shr	 eax, 15
  02d80	83 e0 01	 and	 eax, 1
  02d83	85 c0		 test	 eax, eax
  02d85	74 20		 je	 SHORT $LN212@z900_execu
  02d87	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  02d8e	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  02d96	74 0f		 je	 SHORT $LN212@z900_execu

; 5732 :                     tf_1313( dev );

  02d98	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02d9c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1313
  02da2	e9 6a 05 00 00	 jmp	 $LN213@z900_execu
$LN212@z900_execu:

; 5733 :                 else
; 5734 :                 {
; 5735 :                     register BYTE* sense = dev->sense;

  02da7	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02dab	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  02db1	48 89 45 38	 mov	 QWORD PTR sense$1[rbp], rax

; 5736 : 
; 5737 :                     // "%1d:%04X CHAN: sense %2.2X%2.2X%2.2X%2.2X ...
; 5738 :                     WRMSG( HHC01313, "I", LCSS_DEVNUM,

  02db5	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  02dba	74 10		 je	 SHORT $LN317@z900_execu
  02dbc	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02dc0	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  02dc4	89 85 f8 00 00
	00		 mov	 DWORD PTR tv2108[rbp], eax
  02dca	eb 0a		 jmp	 SHORT $LN318@z900_execu
$LN317@z900_execu:
  02dcc	c7 85 f8 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv2108[rbp], 0
$LN318@z900_execu:
  02dd6	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  02ddb	74 12		 je	 SHORT $LN319@z900_execu
  02ddd	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02de1	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  02de5	d1 f8		 sar	 eax, 1
  02de7	89 85 fc 00 00
	00		 mov	 DWORD PTR tv2114[rbp], eax
  02ded	eb 0a		 jmp	 SHORT $LN320@z900_execu
$LN319@z900_execu:
  02def	c7 85 fc 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv2114[rbp], 0
$LN320@z900_execu:
  02df9	b8 01 00 00 00	 mov	 eax, 1
  02dfe	48 6b c0 1f	 imul	 rax, rax, 31
  02e02	48 8b 4d 38	 mov	 rcx, QWORD PTR sense$1[rbp]
  02e06	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02e0a	89 85 80 01 00
	00		 mov	 DWORD PTR tv1979[rbp], eax
  02e10	b9 01 00 00 00	 mov	 ecx, 1
  02e15	48 6b c9 1e	 imul	 rcx, rcx, 30
  02e19	48 8b 55 38	 mov	 rdx, QWORD PTR sense$1[rbp]
  02e1d	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  02e21	89 8d 84 01 00
	00		 mov	 DWORD PTR tv1983[rbp], ecx
  02e27	ba 01 00 00 00	 mov	 edx, 1
  02e2c	48 6b d2 1d	 imul	 rdx, rdx, 29
  02e30	48 8b 7d 38	 mov	 rdi, QWORD PTR sense$1[rbp]
  02e34	0f b6 14 17	 movzx	 edx, BYTE PTR [rdi+rdx]
  02e38	89 95 18 01 00
	00		 mov	 DWORD PTR tv1987[rbp], edx
  02e3e	bf 01 00 00 00	 mov	 edi, 1
  02e43	48 6b ff 1c	 imul	 rdi, rdi, 28
  02e47	4c 8b 45 38	 mov	 r8, QWORD PTR sense$1[rbp]
  02e4b	41 0f b6 3c 38	 movzx	 edi, BYTE PTR [r8+rdi]
  02e50	41 b8 01 00 00
	00		 mov	 r8d, 1
  02e56	4d 6b c0 1b	 imul	 r8, r8, 27
  02e5a	4c 8b 4d 38	 mov	 r9, QWORD PTR sense$1[rbp]
  02e5e	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  02e63	44 89 85 1c 01
	00 00		 mov	 DWORD PTR tv1995[rbp], r8d
  02e6a	41 b9 01 00 00
	00		 mov	 r9d, 1
  02e70	4d 6b c9 1a	 imul	 r9, r9, 26
  02e74	4c 8b 55 38	 mov	 r10, QWORD PTR sense$1[rbp]
  02e78	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  02e7d	44 89 8d 20 01
	00 00		 mov	 DWORD PTR tv1999[rbp], r9d
  02e84	41 ba 01 00 00
	00		 mov	 r10d, 1
  02e8a	4d 6b d2 19	 imul	 r10, r10, 25
  02e8e	4c 8b 5d 38	 mov	 r11, QWORD PTR sense$1[rbp]
  02e92	47 0f b6 14 13	 movzx	 r10d, BYTE PTR [r11+r10]
  02e97	44 89 95 24 01
	00 00		 mov	 DWORD PTR tv2003[rbp], r10d
  02e9e	41 bb 01 00 00
	00		 mov	 r11d, 1
  02ea4	4d 6b db 18	 imul	 r11, r11, 24
  02ea8	48 8b 5d 38	 mov	 rbx, QWORD PTR sense$1[rbp]
  02eac	42 0f b6 1c 1b	 movzx	 ebx, BYTE PTR [rbx+r11]
  02eb1	41 bb 01 00 00
	00		 mov	 r11d, 1
  02eb7	4d 6b db 17	 imul	 r11, r11, 23
  02ebb	48 8b 75 38	 mov	 rsi, QWORD PTR sense$1[rbp]
  02ebf	42 0f b6 34 1e	 movzx	 esi, BYTE PTR [rsi+r11]
  02ec4	41 bb 01 00 00
	00		 mov	 r11d, 1
  02eca	4d 6b db 16	 imul	 r11, r11, 22
  02ece	4c 8b 75 38	 mov	 r14, QWORD PTR sense$1[rbp]
  02ed2	47 0f b6 1c 1e	 movzx	 r11d, BYTE PTR [r14+r11]
  02ed7	44 89 9d 28 01
	00 00		 mov	 DWORD PTR tv2015[rbp], r11d
  02ede	41 be 01 00 00
	00		 mov	 r14d, 1
  02ee4	4d 6b f6 15	 imul	 r14, r14, 21
  02ee8	4c 8b 7d 38	 mov	 r15, QWORD PTR sense$1[rbp]
  02eec	47 0f b6 34 37	 movzx	 r14d, BYTE PTR [r15+r14]
  02ef1	41 bf 01 00 00
	00		 mov	 r15d, 1
  02ef7	4d 6b ff 14	 imul	 r15, r15, 20
  02efb	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  02eff	47 0f b6 3c 3c	 movzx	 r15d, BYTE PTR [r12+r15]
  02f04	41 bc 01 00 00
	00		 mov	 r12d, 1
  02f0a	4d 6b e4 13	 imul	 r12, r12, 19
  02f0e	4c 8b 6d 38	 mov	 r13, QWORD PTR sense$1[rbp]
  02f12	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02f17	44 89 a5 2c 01
	00 00		 mov	 DWORD PTR tv2027[rbp], r12d
  02f1e	41 bd 01 00 00
	00		 mov	 r13d, 1
  02f24	4d 6b ed 12	 imul	 r13, r13, 18
  02f28	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  02f2c	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02f31	44 89 a5 30 01
	00 00		 mov	 DWORD PTR tv2031[rbp], r12d
  02f38	41 bd 01 00 00
	00		 mov	 r13d, 1
  02f3e	4d 6b ed 11	 imul	 r13, r13, 17
  02f42	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  02f46	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02f4b	44 89 a5 34 01
	00 00		 mov	 DWORD PTR tv2035[rbp], r12d
  02f52	41 bd 01 00 00
	00		 mov	 r13d, 1
  02f58	4d 6b ed 10	 imul	 r13, r13, 16
  02f5c	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  02f60	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02f65	44 89 a5 38 01
	00 00		 mov	 DWORD PTR tv2039[rbp], r12d
  02f6c	41 bd 01 00 00
	00		 mov	 r13d, 1
  02f72	4d 6b ed 0f	 imul	 r13, r13, 15
  02f76	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  02f7a	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02f7f	44 89 a5 3c 01
	00 00		 mov	 DWORD PTR tv2043[rbp], r12d
  02f86	41 bd 01 00 00
	00		 mov	 r13d, 1
  02f8c	4d 6b ed 0e	 imul	 r13, r13, 14
  02f90	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  02f94	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02f99	44 89 a5 40 01
	00 00		 mov	 DWORD PTR tv2047[rbp], r12d
  02fa0	41 bd 01 00 00
	00		 mov	 r13d, 1
  02fa6	4d 6b ed 0d	 imul	 r13, r13, 13
  02faa	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  02fae	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02fb3	44 89 a5 44 01
	00 00		 mov	 DWORD PTR tv2051[rbp], r12d
  02fba	41 bd 01 00 00
	00		 mov	 r13d, 1
  02fc0	4d 6b ed 0c	 imul	 r13, r13, 12
  02fc4	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  02fc8	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02fcd	44 89 a5 48 01
	00 00		 mov	 DWORD PTR tv2055[rbp], r12d
  02fd4	41 bd 01 00 00
	00		 mov	 r13d, 1
  02fda	4d 6b ed 0b	 imul	 r13, r13, 11
  02fde	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  02fe2	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02fe7	44 89 a5 4c 01
	00 00		 mov	 DWORD PTR tv2059[rbp], r12d
  02fee	41 bd 01 00 00
	00		 mov	 r13d, 1
  02ff4	4d 6b ed 0a	 imul	 r13, r13, 10
  02ff8	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  02ffc	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  03001	44 89 a5 50 01
	00 00		 mov	 DWORD PTR tv2063[rbp], r12d
  03008	41 bd 01 00 00
	00		 mov	 r13d, 1
  0300e	4d 6b ed 09	 imul	 r13, r13, 9
  03012	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  03016	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  0301b	44 89 a5 54 01
	00 00		 mov	 DWORD PTR tv2067[rbp], r12d
  03022	41 bd 01 00 00
	00		 mov	 r13d, 1
  03028	4d 6b ed 08	 imul	 r13, r13, 8
  0302c	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  03030	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  03035	44 89 a5 58 01
	00 00		 mov	 DWORD PTR tv2071[rbp], r12d
  0303c	41 bd 01 00 00
	00		 mov	 r13d, 1
  03042	4d 6b ed 07	 imul	 r13, r13, 7
  03046	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  0304a	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  0304f	44 89 a5 5c 01
	00 00		 mov	 DWORD PTR tv2075[rbp], r12d
  03056	41 bd 01 00 00
	00		 mov	 r13d, 1
  0305c	4d 6b ed 06	 imul	 r13, r13, 6
  03060	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  03064	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  03069	44 89 a5 60 01
	00 00		 mov	 DWORD PTR tv2079[rbp], r12d
  03070	41 bd 01 00 00
	00		 mov	 r13d, 1
  03076	4d 6b ed 05	 imul	 r13, r13, 5
  0307a	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  0307e	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  03083	44 89 a5 64 01
	00 00		 mov	 DWORD PTR tv2083[rbp], r12d
  0308a	41 bd 01 00 00
	00		 mov	 r13d, 1
  03090	4d 6b ed 04	 imul	 r13, r13, 4
  03094	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  03098	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  0309d	44 89 a5 68 01
	00 00		 mov	 DWORD PTR tv2087[rbp], r12d
  030a4	41 bd 01 00 00
	00		 mov	 r13d, 1
  030aa	4d 6b ed 03	 imul	 r13, r13, 3
  030ae	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  030b2	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  030b7	44 89 a5 6c 01
	00 00		 mov	 DWORD PTR tv2091[rbp], r12d
  030be	41 bd 01 00 00
	00		 mov	 r13d, 1
  030c4	4d 6b ed 02	 imul	 r13, r13, 2
  030c8	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  030cc	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  030d1	44 89 a5 70 01
	00 00		 mov	 DWORD PTR tv2095[rbp], r12d
  030d8	41 bd 01 00 00
	00		 mov	 r13d, 1
  030de	4d 6b ed 01	 imul	 r13, r13, 1
  030e2	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  030e6	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  030eb	44 89 a5 74 01
	00 00		 mov	 DWORD PTR tv2099[rbp], r12d
  030f2	41 bd 01 00 00
	00		 mov	 r13d, 1
  030f8	4d 6b ed 00	 imul	 r13, r13, 0
  030fc	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  03100	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  03105	b9 01 00 00 00	 mov	 ecx, 1
  0310a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  03110	8b 8d 80 01 00
	00		 mov	 ecx, DWORD PTR tv1979[rbp]
  03116	89 8c 24 40 01
	00 00		 mov	 DWORD PTR [rsp+320], ecx
  0311d	8b 8d 84 01 00
	00		 mov	 ecx, DWORD PTR tv1983[rbp]
  03123	89 8c 24 38 01
	00 00		 mov	 DWORD PTR [rsp+312], ecx
  0312a	8b 8d 18 01 00
	00		 mov	 ecx, DWORD PTR tv1987[rbp]
  03130	89 8c 24 30 01
	00 00		 mov	 DWORD PTR [rsp+304], ecx
  03137	89 bc 24 28 01
	00 00		 mov	 DWORD PTR [rsp+296], edi
  0313e	8b 8d 1c 01 00
	00		 mov	 ecx, DWORD PTR tv1995[rbp]
  03144	89 8c 24 20 01
	00 00		 mov	 DWORD PTR [rsp+288], ecx
  0314b	8b 8d 20 01 00
	00		 mov	 ecx, DWORD PTR tv1999[rbp]
  03151	89 8c 24 18 01
	00 00		 mov	 DWORD PTR [rsp+280], ecx
  03158	8b 8d 24 01 00
	00		 mov	 ecx, DWORD PTR tv2003[rbp]
  0315e	89 8c 24 10 01
	00 00		 mov	 DWORD PTR [rsp+272], ecx
  03165	89 9c 24 08 01
	00 00		 mov	 DWORD PTR [rsp+264], ebx
  0316c	89 b4 24 00 01
	00 00		 mov	 DWORD PTR [rsp+256], esi
  03173	8b 8d 28 01 00
	00		 mov	 ecx, DWORD PTR tv2015[rbp]
  03179	89 8c 24 f8 00
	00 00		 mov	 DWORD PTR [rsp+248], ecx
  03180	44 89 b4 24 f0
	00 00 00	 mov	 DWORD PTR [rsp+240], r14d
  03188	44 89 bc 24 e8
	00 00 00	 mov	 DWORD PTR [rsp+232], r15d
  03190	8b 8d 2c 01 00
	00		 mov	 ecx, DWORD PTR tv2027[rbp]
  03196	89 8c 24 e0 00
	00 00		 mov	 DWORD PTR [rsp+224], ecx
  0319d	8b 8d 30 01 00
	00		 mov	 ecx, DWORD PTR tv2031[rbp]
  031a3	89 8c 24 d8 00
	00 00		 mov	 DWORD PTR [rsp+216], ecx
  031aa	8b 8d 34 01 00
	00		 mov	 ecx, DWORD PTR tv2035[rbp]
  031b0	89 8c 24 d0 00
	00 00		 mov	 DWORD PTR [rsp+208], ecx
  031b7	8b 8d 38 01 00
	00		 mov	 ecx, DWORD PTR tv2039[rbp]
  031bd	89 8c 24 c8 00
	00 00		 mov	 DWORD PTR [rsp+200], ecx
  031c4	8b 8d 3c 01 00
	00		 mov	 ecx, DWORD PTR tv2043[rbp]
  031ca	89 8c 24 c0 00
	00 00		 mov	 DWORD PTR [rsp+192], ecx
  031d1	8b 8d 40 01 00
	00		 mov	 ecx, DWORD PTR tv2047[rbp]
  031d7	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR [rsp+184], ecx
  031de	8b 8d 44 01 00
	00		 mov	 ecx, DWORD PTR tv2051[rbp]
  031e4	89 8c 24 b0 00
	00 00		 mov	 DWORD PTR [rsp+176], ecx
  031eb	8b 8d 48 01 00
	00		 mov	 ecx, DWORD PTR tv2055[rbp]
  031f1	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR [rsp+168], ecx
  031f8	8b 8d 4c 01 00
	00		 mov	 ecx, DWORD PTR tv2059[rbp]
  031fe	89 8c 24 a0 00
	00 00		 mov	 DWORD PTR [rsp+160], ecx
  03205	8b 8d 50 01 00
	00		 mov	 ecx, DWORD PTR tv2063[rbp]
  0320b	89 8c 24 98 00
	00 00		 mov	 DWORD PTR [rsp+152], ecx
  03212	8b 8d 54 01 00
	00		 mov	 ecx, DWORD PTR tv2067[rbp]
  03218	89 8c 24 90 00
	00 00		 mov	 DWORD PTR [rsp+144], ecx
  0321f	8b 8d 58 01 00
	00		 mov	 ecx, DWORD PTR tv2071[rbp]
  03225	89 8c 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], ecx
  0322c	8b 8d 5c 01 00
	00		 mov	 ecx, DWORD PTR tv2075[rbp]
  03232	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  03239	8b 8d 60 01 00
	00		 mov	 ecx, DWORD PTR tv2079[rbp]
  0323f	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  03243	8b 8d 64 01 00
	00		 mov	 ecx, DWORD PTR tv2083[rbp]
  03249	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  0324d	8b 8d 68 01 00
	00		 mov	 ecx, DWORD PTR tv2087[rbp]
  03253	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  03257	8b 8d 6c 01 00
	00		 mov	 ecx, DWORD PTR tv2091[rbp]
  0325d	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  03261	8b 8d 70 01 00
	00		 mov	 ecx, DWORD PTR tv2095[rbp]
  03267	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0326b	8b 8d 74 01 00
	00		 mov	 ecx, DWORD PTR tv2099[rbp]
  03271	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  03275	44 89 64 24 48	 mov	 DWORD PTR [rsp+72], r12d
  0327a	8b 8d f8 00 00
	00		 mov	 ecx, DWORD PTR tv2108[rbp]
  03280	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  03284	8b 8d fc 00 00
	00		 mov	 ecx, DWORD PTR tv2114[rbp]
  0328a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0328e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196792
  03295	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0329a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196793
  032a1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  032a6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  032ab	41 b9 03 00 00
	00		 mov	 r9d, 3
  032b1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196794
  032b8	ba 72 16 00 00	 mov	 edx, 5746		; 00001672H
  032bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196795
  032c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 5739 :                             sense[ 0], sense[ 1], sense[ 2], sense[ 3],
; 5740 :                             sense[ 4], sense[ 5], sense[ 6], sense[ 7],
; 5741 :                             sense[ 8], sense[ 9], sense[10], sense[11],
; 5742 :                             sense[12], sense[13], sense[14], sense[15],
; 5743 :                             sense[16], sense[17], sense[18], sense[19],
; 5744 :                             sense[20], sense[21], sense[22], sense[23],
; 5745 :                             sense[24], sense[25], sense[26], sense[27],
; 5746 :                             sense[28], sense[29], sense[30], sense[31] );
; 5747 : 
; 5748 :                     if (sense[0] != 0 || sense[1] != 0)

  032ca	b8 01 00 00 00	 mov	 eax, 1
  032cf	48 6b c0 00	 imul	 rax, rax, 0
  032d3	48 8b 4d 38	 mov	 rcx, QWORD PTR sense$1[rbp]
  032d7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  032db	85 c0		 test	 eax, eax
  032dd	75 15		 jne	 SHORT $LN215@z900_execu
  032df	b8 01 00 00 00	 mov	 eax, 1
  032e4	48 6b c0 01	 imul	 rax, rax, 1
  032e8	48 8b 4d 38	 mov	 rcx, QWORD PTR sense$1[rbp]
  032ec	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  032f0	85 c0		 test	 eax, eax
  032f2	74 1d		 je	 SHORT $LN214@z900_execu
$LN215@z900_execu:

; 5749 :                         DISPLAY_SENSE( dev );

  032f4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196798
  032fb	41 b8 75 16 00
	00		 mov	 r8d, 5749		; 00001675H
  03301	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196799
  03308	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0330c	e8 00 00 00 00	 call	 _display_sense
$LN214@z900_execu:
$LN213@z900_execu:
$LN211@z900_execu:
$LN202@z900_execu:

; 5750 :                 }
; 5751 :             }
; 5752 :         }
; 5753 : 
; 5754 :         /* Terminate the channel program if any unusual status */
; 5755 :         if (chanstat != 0
; 5756 :             || (unitstat & ~CSW_SM) != (CSW_CE | CSW_DE))

  03311	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  03315	85 c0		 test	 eax, eax
  03317	75 0c		 jne	 SHORT $LN218@z900_execu
  03319	0f b6 45 0c	 movzx	 eax, BYTE PTR unitstat$[rbp]
  0331d	83 e0 bf	 and	 eax, -65		; ffffffffffffffbfH
  03320	83 f8 0c	 cmp	 eax, 12
  03323	74 49		 je	 SHORT $LN216@z900_execu
$LN218@z900_execu:

; 5757 :         {
; 5758 :             if (firstccw && !dev->is_immed && (dev->scsw.flag1 & SCSW1_I))

  03325	0f b6 45 2d	 movzx	 eax, BYTE PTR firstccw$[rbp]
  03329	85 c0		 test	 eax, eax
  0332b	74 3b		 je	 SHORT $LN219@z900_execu
  0332d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03331	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  03338	75 2e		 jne	 SHORT $LN219@z900_execu
  0333a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0333e	0f b6 80 09 03
	00 00		 movzx	 eax, BYTE PTR [rax+777]
  03345	83 e0 20	 and	 eax, 32			; 00000020H
  03348	85 c0		 test	 eax, eax
  0334a	74 1c		 je	 SHORT $LN219@z900_execu

; 5759 :             {
; 5760 :                 /* Set the zero condition-code flag in the SCSW */
; 5761 :                 dev->scsw.flag1 |= SCSW1_Z;

  0334c	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03350	0f b6 80 09 03
	00 00		 movzx	 eax, BYTE PTR [rax+777]
  03357	83 c8 04	 or	 eax, 4
  0335a	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0335e	88 81 09 03 00
	00		 mov	 BYTE PTR [rcx+777], al

; 5762 :                 firstccw = 0;

  03364	c6 45 2d 00	 mov	 BYTE PTR firstccw$[rbp], 0
$LN219@z900_execu:

; 5763 :             }
; 5764 :             chain = 0;

  03368	c6 45 20 00	 mov	 BYTE PTR chain$[rbp], 0

; 5765 :         }

  0336c	eb 15		 jmp	 SHORT $LN217@z900_execu
$LN216@z900_execu:

; 5766 : 
; 5767 :         /* Increment CCW address if device returned status modifier  */
; 5768 :         /* SA22-7201-05:                                             */
; 5769 :         /*  p. 15-30, Command Chaining                               */
; 5770 :         else if ((unitstat & (CSW_DE | CSW_SM)) == (CSW_DE | CSW_SM))

  0336e	0f b6 45 0c	 movzx	 eax, BYTE PTR unitstat$[rbp]
  03372	83 e0 44	 and	 eax, 68			; 00000044H
  03375	83 f8 44	 cmp	 eax, 68			; 00000044H
  03378	75 09		 jne	 SHORT $LN220@z900_execu

; 5771 :             ccwaddr += 8;

  0337a	8b 45 24	 mov	 eax, DWORD PTR ccwaddr$[rbp]
  0337d	83 c0 08	 add	 eax, 8
  03380	89 45 24	 mov	 DWORD PTR ccwaddr$[rbp], eax
$LN220@z900_execu:
$LN217@z900_execu:

; 5772 : 
; 5773 :         /* Update the chaining flags */
; 5774 :         dev->chained = flags & (CCW_FLAGS_CD | CCW_FLAGS_CC);

  03383	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  03387	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  0338c	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  03390	88 81 78 02 00
	00		 mov	 BYTE PTR [rcx+632], al

; 5775 : 
; 5776 :         /* Update the CCW sequence number unless data chained */
; 5777 :         if ((flags & CCW_FLAGS_CD) == 0)

  03396	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  0339a	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0339f	85 c0		 test	 eax, eax
  033a1	75 4e		 jne	 SHORT $LN221@z900_execu

; 5778 :         {
; 5779 :             dev->ccwseq++;

  033a3	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  033a7	8b 80 7c 02 00
	00		 mov	 eax, DWORD PTR [rax+636]
  033ad	ff c0		 inc	 eax
  033af	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  033b3	89 81 7c 02 00
	00		 mov	 DWORD PTR [rcx+636], eax

; 5780 : 
; 5781 :             /* Reset prefetch table and master skip data */
; 5782 :             dev->is_immed =

  033b9	c7 45 60 00 00
	00 00		 mov	 DWORD PTR bufpos$[rbp], 0
  033c0	8b 45 60	 mov	 eax, DWORD PTR bufpos$[rbp]
  033c3	89 85 c4 01 00
	00		 mov	 DWORD PTR prefetch$[rbp+4], eax
  033c9	8b 85 c4 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp+4]
  033cf	89 85 c0 01 00
	00		 mov	 DWORD PTR prefetch$[rbp], eax
  033d5	8b 85 c0 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp]
  033db	89 45 10	 mov	 DWORD PTR ps$[rbp], eax
  033de	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  033e1	89 45 64	 mov	 DWORD PTR skip_ccws$[rbp], eax
  033e4	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  033e8	8b 4d 64	 mov	 ecx, DWORD PTR skip_ccws$[rbp]
  033eb	89 88 a0 02 00
	00		 mov	 DWORD PTR [rax+672], ecx
$LN221@z900_execu:

; 5783 :             skip_ccws =
; 5784 :             ps =
; 5785 :             prefetch.seq =
; 5786 :             prefetch.pos =
; 5787 :             bufpos = 0;
; 5788 :         }
; 5789 : 
; 5790 :         /* If Halt or Clear Pending, restart chaining to reset */
; 5791 :         if (dev->scsw.flag2 & (SCSW2_AC_HALT | SCSW2_AC_CLEAR))

  033f1	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  033f5	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  033fc	83 e0 03	 and	 eax, 3
  033ff	85 c0		 test	 eax, eax
  03401	74 04		 je	 SHORT $LN222@z900_execu

; 5792 :             chain = 1;

  03403	c6 45 20 01	 mov	 BYTE PTR chain$[rbp], 1
$LN222@z900_execu:

; 5793 : 
; 5794 :     } /* end while(chain) */

  03407	e9 b1 d5 ff ff	 jmp	 $LN327@z900_execu
$LN3@z900_execu:
$LN21@z900_execu:

; 5795 : 
; 5796 :     IODELAY(dev);

  0340c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  03413	83 b8 e0 13 00
	00 00		 cmp	 DWORD PTR [rax+5088], 0
  0341a	7e 2d		 jle	 SHORT $LN223@z900_execu
  0341c	b8 01 00 00 00	 mov	 eax, 1
  03421	48 6b c0 0a	 imul	 rax, rax, 10
  03425	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  03429	0f b6 84 01 6c
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1388]
  03431	83 f8 20	 cmp	 eax, 32			; 00000020H
  03434	75 13		 jne	 SHORT $LN223@z900_execu
  03436	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0343d	8b 88 e0 13 00
	00		 mov	 ecx, DWORD PTR [rax+5088]
  03443	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN223@z900_execu:
  03449	33 c0		 xor	 eax, eax
  0344b	85 c0		 test	 eax, eax
  0344d	75 bd		 jne	 SHORT $LN21@z900_execu

; 5797 : 
; 5798 :     /* Call the i/o end exit */
; 5799 :     if (dev->hnd->end) (dev->hnd->end) (dev);

  0344f	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03453	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0345a	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  0345f	74 12		 je	 SHORT $LN224@z900_execu
  03461	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03465	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0346c	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  03470	ff 50 30	 call	 QWORD PTR [rax+48]
$LN224@z900_execu:

; 5800 : 
; 5801 :     /* If we're shutting down, skip final sequence and just exit now */
; 5802 :     if (sysblk.shutdown)

  03473	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0347a	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  03480	c1 e8 0b	 shr	 eax, 11
  03483	83 e0 01	 and	 eax, 1
  03486	85 c0		 test	 eax, eax
  03488	74 18		 je	 SHORT $LN225@z900_execu

; 5803 :         return execute_ccw_chain_fast_return( iobuf, &iobuf_initial, NULL );

  0348a	45 33 c0	 xor	 r8d, r8d
  0348d	48 8d 95 00 20
	00 00		 lea	 rdx, QWORD PTR iobuf_initial$[rbp]
  03494	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  03498	e8 00 00 00 00	 call	 execute_ccw_chain_fast_return
  0349d	e9 54 03 00 00	 jmp	 $LN1@z900_execu
$LN225@z900_execu:

; 5804 : 
; 5805 :     /* Final sequence MUST be performed with INTLOCK held to prevent
; 5806 :        I/O instructions (such as test_subchan) from proceeding before
; 5807 :        we can set our flags properly and queue the actual I/O interrupt.
; 5808 :     */
; 5809 :     OBTAIN_INTLOCK(NULL);

  034a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196810
  034a9	33 c9		 xor	 ecx, ecx
  034ab	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 5810 :     obtain_lock(&dev->lock);

  034b0	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  034b4	48 83 c0 38	 add	 rax, 56			; 00000038H
  034b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196811
  034bf	48 8b c8	 mov	 rcx, rax
  034c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 5811 : 
; 5812 :     /* Complete the subchannel status word */
; 5813 :     dev->scsw.flag3 &= ~(SCSW3_AC_SCHAC | SCSW3_AC_DEVAC | SCSW3_SC_INTER);

  034c8	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  034cc	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  034d3	25 37 ff ff ff	 and	 eax, -201		; ffffffffffffff37H
  034d8	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  034dc	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 5814 :     dev->scsw.flag3 |= (SCSW3_SC_PRI | SCSW3_SC_SEC | SCSW3_SC_PEND);

  034e2	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  034e6	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  034ed	83 c8 07	 or	 eax, 7
  034f0	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  034f4	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 5815 :     STORE_FW(dev->scsw.ccwaddr,ccwaddr);

  034fa	8b 4d 24	 mov	 ecx, DWORD PTR ccwaddr$[rbp]
  034fd	e8 00 00 00 00	 call	 _byteswap_ulong
  03502	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  03506	48 81 c1 0c 03
	00 00		 add	 rcx, 780		; 0000030cH
  0350d	8b d0		 mov	 edx, eax
  0350f	e8 00 00 00 00	 call	 store_fw_noswap

; 5816 :     dev->scsw.unitstat = unitstat;

  03514	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03518	0f b6 4d 0c	 movzx	 ecx, BYTE PTR unitstat$[rbp]
  0351c	88 88 10 03 00
	00		 mov	 BYTE PTR [rax+784], cl

; 5817 :     dev->scsw.chanstat = chanstat;

  03522	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03526	0f b6 4d 09	 movzx	 ecx, BYTE PTR chanstat$[rbp]
  0352a	88 88 11 03 00
	00		 mov	 BYTE PTR [rax+785], cl

; 5818 :     STORE_HW(dev->scsw.count,residual);

  03530	0f b7 4d 30	 movzx	 ecx, WORD PTR residual$[rbp]
  03534	e8 00 00 00 00	 call	 _byteswap_ushort
  03539	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0353d	48 81 c1 12 03
	00 00		 add	 rcx, 786		; 00000312H
  03544	0f b7 d0	 movzx	 edx, ax
  03547	e8 00 00 00 00	 call	 store_hw_noswap

; 5819 : 
; 5820 :     /* Set alert status if terminated by any unusual condition */
; 5821 :     if (chanstat != 0 || unitstat != (CSW_CE | CSW_DE))

  0354c	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  03550	85 c0		 test	 eax, eax
  03552	75 09		 jne	 SHORT $LN227@z900_execu
  03554	0f b6 45 0c	 movzx	 eax, BYTE PTR unitstat$[rbp]
  03558	83 f8 0c	 cmp	 eax, 12
  0355b	74 18		 je	 SHORT $LN226@z900_execu
$LN227@z900_execu:

; 5822 :         dev->scsw.flag3 |= SCSW3_SC_ALERT;

  0355d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03561	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  03568	83 c8 10	 or	 eax, 16
  0356b	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0356f	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al
$LN226@z900_execu:

; 5823 : 
; 5824 :     /* Clear the Extended Status Word (ESW) and set LPUM in Word 0,
; 5825 :        defaulting to a Format-1 ESW if no other action taken */
; 5826 :     memset (&dev->esw, 0,sizeof(ESW));

  03575	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03579	48 05 2c 03 00
	00		 add	 rax, 812		; 0000032cH
  0357f	48 8b f8	 mov	 rdi, rax
  03582	33 c0		 xor	 eax, eax
  03584	b9 14 00 00 00	 mov	 ecx, 20
  03589	f3 aa		 rep stosb

; 5827 :     dev->esw.lpum = 0x80;

  0358b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0358f	c6 80 2d 03 00
	00 80		 mov	 BYTE PTR [rax+813], 128	; 00000080H

; 5828 : 
; 5829 :     /* Format-0 if CDC, CCC OR IFCC */
; 5830 :     if (chanstat & (CSW_CDC | CSW_CCC | CSW_ICC))

  03596	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  0359a	83 e0 0e	 and	 eax, 14
  0359d	85 c0		 test	 eax, eax
  0359f	0f 84 8b 00 00
	00		 je	 $LN228@z900_execu

; 5831 :     {
; 5832 :         /* SA22-7201-5:                                              */
; 5833 :         /*  p. 16-34, Field Validity Flags (FVF)                     */
; 5834 :         /*  p. 16-34 -- 16-35, Termination Code                      */
; 5835 :         /*  p. 16-35 -- 16-36, Sequence Code (SC)                    */
; 5836 :         /*                                                           */
; 5837 :         /*  TBD: Further refinement needed as only CDC is even close */
; 5838 :         /*       to being properly implemented.                      */
; 5839 :         dev->esw.scl2 = 0x78;   /* FVF: LPUM, termination code,      */

  035a5	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  035a9	c6 80 2e 03 00
	00 78		 mov	 BYTE PTR [rax+814], 120	; 00000078H

; 5840 :                                 /*      sequence code and device     */
; 5841 :                                 /*      status valid                 */
; 5842 :         /* Set data direction */
; 5843 :         if (!dev->is_immed)

  035b0	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  035b4	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  035bb	75 68		 jne	 SHORT $LN229@z900_execu

; 5844 :         {
; 5845 :             if (prefetch.seq)

  035bd	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  035c4	74 1a		 je	 SHORT $LN230@z900_execu

; 5846 :                 dev->esw.scl2 |= 0x02;  /* Write operation */

  035c6	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  035ca	0f b6 80 2e 03
	00 00		 movzx	 eax, BYTE PTR [rax+814]
  035d1	83 c8 02	 or	 eax, 2
  035d4	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  035d8	88 81 2e 03 00
	00		 mov	 BYTE PTR [rcx+814], al
  035de	eb 45		 jmp	 SHORT $LN231@z900_execu
$LN230@z900_execu:

; 5847 :             else if (IS_CCW_RDBACK(dev->code))

  035e0	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  035e4	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  035eb	83 e0 0f	 and	 eax, 15
  035ee	83 f8 0c	 cmp	 eax, 12
  035f1	75 1a		 jne	 SHORT $LN232@z900_execu

; 5848 :                 dev->esw.scl2 |= 0x03;  /* Read backward */

  035f3	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  035f7	0f b6 80 2e 03
	00 00		 movzx	 eax, BYTE PTR [rax+814]
  035fe	83 c8 03	 or	 eax, 3
  03601	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  03605	88 81 2e 03 00
	00		 mov	 BYTE PTR [rcx+814], al
  0360b	eb 18		 jmp	 SHORT $LN233@z900_execu
$LN232@z900_execu:

; 5849 :             else
; 5850 :                 dev->esw.scl2 |= 0x01;  /* Read */

  0360d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03611	0f b6 80 2e 03
	00 00		 movzx	 eax, BYTE PTR [rax+814]
  03618	83 c8 01	 or	 eax, 1
  0361b	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0361f	88 81 2e 03 00
	00		 mov	 BYTE PTR [rcx+814], al
$LN233@z900_execu:
$LN231@z900_execu:
$LN229@z900_execu:

; 5851 :         }
; 5852 :         dev->esw.scl3 = 0x45;   /* Bits 24-25: Termination Code      */

  03625	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03629	c6 80 2f 03 00
	00 45		 mov	 BYTE PTR [rax+815], 69	; 00000045H
$LN228@z900_execu:

; 5853 :                                 /* Bits 29-31: Sequence Code         */
; 5854 :     }
; 5855 : 
; 5856 :     /* Clear the extended control word */
; 5857 :     memset (dev->ecw, 0, sizeof(dev->ecw));

  03630	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03634	48 05 40 03 00
	00		 add	 rax, 832		; 00000340H
  0363a	48 8b f8	 mov	 rdi, rax
  0363d	33 c0		 xor	 eax, eax
  0363f	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  03644	f3 aa		 rep stosb

; 5858 : 
; 5859 :     /* Return sense information if PMCW allows concurrent sense */
; 5860 :     if ((unitstat & CSW_UC) && (dev->pmcw.flag27 & PMCW27_S))

  03646	0f b6 45 0c	 movzx	 eax, BYTE PTR unitstat$[rbp]
  0364a	83 e0 02	 and	 eax, 2
  0364d	85 c0		 test	 eax, eax
  0364f	0f 84 de 00 00
	00		 je	 $LN234@z900_execu
  03655	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03659	0f b6 80 07 03
	00 00		 movzx	 eax, BYTE PTR [rax+775]
  03660	83 e0 01	 and	 eax, 1
  03663	85 c0		 test	 eax, eax
  03665	0f 84 c8 00 00
	00		 je	 $LN234@z900_execu

; 5861 :     {
; 5862 :         dev->scsw.flag1 |= SCSW1_E;

  0366b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0366f	0f b6 80 09 03
	00 00		 movzx	 eax, BYTE PTR [rax+777]
  03676	83 c8 02	 or	 eax, 2
  03679	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0367d	88 81 09 03 00
	00		 mov	 BYTE PTR [rcx+777], al

; 5863 :         dev->esw.erw0 |= ERW0_S;

  03683	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03687	0f b6 80 30 03
	00 00		 movzx	 eax, BYTE PTR [rax+816]
  0368e	83 c8 01	 or	 eax, 1
  03691	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  03695	88 81 30 03 00
	00		 mov	 BYTE PTR [rcx+816], al

; 5864 :         dev->esw.erw1 = (BYTE)((dev->numsense < (int)sizeof(dev->ecw)) ?

  0369b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0369f	83 b8 60 03 00
	00 20		 cmp	 DWORD PTR [rax+864], 32	; 00000020H
  036a6	73 12		 jae	 SHORT $LN321@z900_execu
  036a8	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  036ac	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  036b2	89 85 00 01 00
	00		 mov	 DWORD PTR tv2326[rbp], eax
  036b8	eb 0a		 jmp	 SHORT $LN322@z900_execu
$LN321@z900_execu:
  036ba	c7 85 00 01 00
	00 20 00 00 00	 mov	 DWORD PTR tv2326[rbp], 32 ; 00000020H
$LN322@z900_execu:
  036c4	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  036c8	0f b6 8d 00 01
	00 00		 movzx	 ecx, BYTE PTR tv2326[rbp]
  036cf	88 88 31 03 00
	00		 mov	 BYTE PTR [rax+817], cl

; 5865 :                         dev->numsense : (int)sizeof(dev->ecw));
; 5866 :         memcpy (dev->ecw, dev->sense, dev->esw.erw1 & ERW1_SCNT);

  036d5	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  036d9	0f b6 80 31 03
	00 00		 movzx	 eax, BYTE PTR [rax+817]
  036e0	83 e0 3f	 and	 eax, 63			; 0000003fH
  036e3	48 98		 cdqe
  036e5	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  036e9	48 81 c1 64 03
	00 00		 add	 rcx, 868		; 00000364H
  036f0	48 8b 55 00	 mov	 rdx, QWORD PTR dev$[rbp]
  036f4	48 81 c2 40 03
	00 00		 add	 rdx, 832		; 00000340H
  036fb	48 8b fa	 mov	 rdi, rdx
  036fe	48 8b f1	 mov	 rsi, rcx
  03701	48 8b c8	 mov	 rcx, rax
  03704	f3 a4		 rep movsb

; 5867 :         memset (dev->sense, 0, sizeof(dev->sense));

  03706	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0370a	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  03710	48 8b f8	 mov	 rdi, rax
  03713	33 c0		 xor	 eax, eax
  03715	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0371a	f3 aa		 rep stosb

; 5868 :         dev->sns_pending = 0;

  0371c	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03720	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  03726	83 e0 fb	 and	 eax, -5			; fffffffbH
  03729	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0372d	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax
$LN234@z900_execu:

; 5869 :     }
; 5870 : 
; 5871 :     /* Late notification. If halt or clear in process, go clear the  */
; 5872 :     /* mess.                                                         */
; 5873 :     if (dev->scsw.flag2 & (SCSW2_AC_HALT | SCSW2_AC_CLEAR))

  03733	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03737	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  0373e	83 e0 03	 and	 eax, 3
  03741	85 c0		 test	 eax, eax
  03743	74 6a		 je	 SHORT $LN235@z900_execu

; 5874 :     {
; 5875 :         U8 halt = (dev->scsw.flag2 & SCSW2_AC_HALT) ? TRUE : FALSE;

  03745	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03749	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  03750	83 e0 02	 and	 eax, 2
  03753	85 c0		 test	 eax, eax
  03755	74 0c		 je	 SHORT $LN323@z900_execu
  03757	c7 85 04 01 00
	00 01 00 00 00	 mov	 DWORD PTR tv2355[rbp], 1
  03761	eb 0a		 jmp	 SHORT $LN324@z900_execu
$LN323@z900_execu:
  03763	c7 85 04 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv2355[rbp], 0
$LN324@z900_execu:
  0376d	0f b6 85 04 01
	00 00		 movzx	 eax, BYTE PTR tv2355[rbp]
  03774	88 45 74	 mov	 BYTE PTR halt$7[rbp], al

; 5876 :         release_lock(&dev->lock);

  03777	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0377b	48 83 c0 38	 add	 rax, 56			; 00000038H
  0377f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196822
  03786	48 8b c8	 mov	 rcx, rax
  03789	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5877 :         RELEASE_INTLOCK(NULL);

  0378f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196823
  03796	33 c9		 xor	 ecx, ecx
  03798	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 5878 :         if (halt)

  0379d	0f b6 45 74	 movzx	 eax, BYTE PTR halt$7[rbp]
  037a1	85 c0		 test	 eax, eax
  037a3	74 05		 je	 SHORT $LN236@z900_execu

; 5879 :             goto execute_halt;

  037a5	e9 5a d3 ff ff	 jmp	 $execute_halt$330
$LN236@z900_execu:

; 5880 :         goto execute_clear;

  037aa	e9 6b d2 ff ff	 jmp	 $execute_clear$329
$LN235@z900_execu:

; 5881 :     }
; 5882 : 
; 5883 :     /* Present the interrupt and return */
; 5884 :     queue_io_interrupt_and_update_status_locked( dev, TRUE );

  037af	ba 01 00 00 00	 mov	 edx, 1
  037b4	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  037b8	e8 00 00 00 00	 call	 queue_io_interrupt_and_update_status_locked

; 5885 :     release_lock( &dev->lock );

  037bd	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  037c1	48 83 c0 38	 add	 rax, 56			; 00000038H
  037c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196825
  037cc	48 8b c8	 mov	 rcx, rax
  037cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5886 :     RELEASE_INTLOCK( NULL );

  037d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196826
  037dc	33 c9		 xor	 ecx, ecx
  037de	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 5887 :     return execute_ccw_chain_fast_return( iobuf, &iobuf_initial, NULL );

  037e3	45 33 c0	 xor	 r8d, r8d
  037e6	48 8d 95 00 20
	00 00		 lea	 rdx, QWORD PTR iobuf_initial$[rbp]
  037ed	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  037f1	e8 00 00 00 00	 call	 execute_ccw_chain_fast_return
$LN1@z900_execu:
$LN237@z900_execu:

; 5888 : 
; 5889 : } /* end function execute_ccw_chain */

  037f6	48 8b 8d 40 30
	01 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  037fd	48 33 cc	 xor	 rcx, rsp
  03800	e8 00 00 00 00	 call	 __security_check_cookie
  03805	48 81 c4 a8 41
	01 00		 add	 rsp, 82344		; 000141a8H
  0380c	41 5f		 pop	 r15
  0380e	41 5e		 pop	 r14
  03810	41 5d		 pop	 r13
  03812	41 5c		 pop	 r12
  03814	5f		 pop	 rdi
  03815	5e		 pop	 rsi
  03816	5b		 pop	 rbx
  03817	5d		 pop	 rbp
  03818	c3		 ret	 0
z900_execute_ccw_chain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
dev$ = 0
flags$ = 8
chanstat$ = 9
opcode$ = 10
ccwfmt$ = 11
unitstat$ = 12
ps$ = 16
ccwkey$ = 20
tracethis$ = 21
idawfmt$ = 22
count$ = 24
chain$ = 28
ccwaddr$ = 32
addr$ = 36
ts$ = 40
ioerror$ = 44
firstccw$ = 45
residual$ = 48
sense$1 = 56
more$ = 64
idapmask$ = 68
ostailor_quiet$2 = 72
skip_ch9uc$3 = 73
cpu_tracing$4 = 74
mbaddr$ = 76
ticback$ = 80
ccw_tracing$5 = 84
iobuf$ = 88
bufpos$ = 96
skip_ccws$ = 100
prevccwaddr$ = 104
tracing_active$6 = 108
mbcount$ = 112
halt$7 = 116
ticaddr$ = 120
prefetch_remaining$ = 124
ccw$ = 128
cmdretry$ = 136
tv283 = 140
tv295 = 144
tv303 = 148
tv437 = 152
tv439 = 156
tv511 = 160
tv517 = 164
tv570 = 168
tv576 = 172
tv925 = 176
tv937 = 180
tv943 = 184
tv1191 = 188
tv1197 = 192
tv1285 = 196
tv1291 = 200
newsize$8 = 204
tv1440 = 208
tv1652 = 212
tv1660 = 216
tv1685 = 220
tv1689 = 224
tv1733 = 228
tv1780 = 232
tv1903 = 236
tv1916 = 240
tv1922 = 244
tv2075 = 248
tv2081 = 252
tv2293 = 256
tv2322 = 260
tv182 = 264
tv188 = 268
tv205 = 272
tv211 = 276
tv1954 = 280
tv1962 = 284
tv1966 = 288
tv1970 = 292
tv1982 = 296
tv1994 = 300
tv1998 = 304
tv2002 = 308
tv2006 = 312
tv2010 = 316
tv2014 = 320
tv2018 = 324
tv2022 = 328
tv2026 = 332
tv2030 = 336
tv2034 = 340
tv2038 = 344
tv2042 = 348
tv2046 = 352
tv2050 = 356
tv2054 = 360
tv2058 = 364
tv2062 = 368
tv2066 = 372
tv1909 = 376
tv1911 = 380
tv1946 = 384
tv1950 = 388
mbk$ = 392
iobufnew$9 = 400
$T10 = 408
tv2347 = 416
prefetch$ = 448
iobuf_initial$ = 8192
area$ = 77824
__$ArrayPad$ = 77888
arg$ = 82416
s390_execute_ccw_chain PROC

; 4380 : {

$LN323:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	53		 push	 rbx
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	41 57		 push	 r15
  00011	b8 a8 41 01 00	 mov	 eax, 82344		; 000141a8H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	48 2b e0	 sub	 rsp, rax
  0001e	48 8d ac 24 50
	11 00 00	 lea	 rbp, QWORD PTR [rsp+4432]
  00026	48 81 e5 00 f0
	ff ff		 and	 rbp, -4096		; fffffffffffff000H
  0002d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00034	48 33 c4	 xor	 rax, rsp
  00037	48 89 85 40 30
	01 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax

; 4381 : DEVBLK *dev = (DEVBLK*) arg;            /* Device Block pointer      */

  0003e	48 8b 84 24 f0
	41 01 00	 mov	 rax, QWORD PTR arg$[rsp]
  00046	48 89 45 00	 mov	 QWORD PTR dev$[rbp], rax

; 4382 : IOBUF  *iobuf;                          /* Pointer to I/O buffer     */
; 4383 : U32     ccwaddr = 0;                    /* Address of CCW            */

  0004a	c7 45 20 00 00
	00 00		 mov	 DWORD PTR ccwaddr$[rbp], 0

; 4384 : U32     ticaddr = 0;                    /* Previous CCW was a TIC    */

  00051	c7 45 78 00 00
	00 00		 mov	 DWORD PTR ticaddr$[rbp], 0

; 4385 : U16     ticback = 0;                    /* Backwards TIC counter     */

  00058	33 c0		 xor	 eax, eax
  0005a	66 89 45 50	 mov	 WORD PTR ticback$[rbp], ax

; 4386 : U16     idapmask = 0;                   /* IDA page size - 1         */

  0005e	33 c0		 xor	 eax, eax
  00060	66 89 45 44	 mov	 WORD PTR idapmask$[rbp], ax

; 4387 : BYTE    idawfmt = 0;                    /* IDAW format (1 or 2)      */

  00064	c6 45 16 00	 mov	 BYTE PTR idawfmt$[rbp], 0

; 4388 : BYTE    ccwfmt = 0;                     /* CCW format (0 or 1)       */

  00068	c6 45 0b 00	 mov	 BYTE PTR ccwfmt$[rbp], 0

; 4389 : BYTE    ccwkey = 0;                     /* Bits 0-3=key, 4-7=zero    */

  0006c	c6 45 14 00	 mov	 BYTE PTR ccwkey$[rbp], 0

; 4390 : BYTE    opcode;                         /* CCW operation code        */
; 4391 : BYTE    flags;                          /* CCW flags                 */
; 4392 : U32     addr;                           /* CCW data address          */
; 4393 : #ifdef FEATURE_CHANNEL_SUBSYSTEM
; 4394 : U32     mbaddr;                         /* Measure block address     */
; 4395 : MBK    *mbk;                            /* Measure block             */
; 4396 : U16     mbcount;                        /* Measure block count       */
; 4397 : #endif /*FEATURE_CHANNEL_SUBSYSTEM*/
; 4398 : U32     count;                          /* CCW byte count            */
; 4399 : BYTE   *ccw;                            /* CCW pointer               */
; 4400 : BYTE    unitstat;                       /* Unit status               */
; 4401 : BYTE    chanstat;                       /* Channel status            */
; 4402 : U32     residual = 0;                   /* Residual byte count       */

  00070	c7 45 30 00 00
	00 00		 mov	 DWORD PTR residual$[rbp], 0

; 4403 : BYTE    more;                           /* 1=Count exhausted         */
; 4404 : BYTE    chain = 1;                      /* 1=Chain to next CCW       */

  00077	c6 45 1c 01	 mov	 BYTE PTR chain$[rbp], 1

; 4405 : BYTE    tracethis = 0;                  /* 1=Trace this CCW chain    */

  0007b	c6 45 15 00	 mov	 BYTE PTR tracethis$[rbp], 0

; 4406 : BYTE    ioerror = 0;                    /* 1=CCW I/O error           */

  0007f	c6 45 2c 00	 mov	 BYTE PTR ioerror$[rbp], 0

; 4407 : BYTE    firstccw = 1;                   /* 1=First CCW               */

  00083	c6 45 2d 01	 mov	 BYTE PTR firstccw$[rbp], 1

; 4408 : BYTE    area[64];                       /* Message area              */
; 4409 : u_int   bufpos = 0;                     /* Position in I/O buffer    */

  00087	c7 45 60 00 00
	00 00		 mov	 DWORD PTR bufpos$[rbp], 0

; 4410 : u_int   skip_ccws = 0;                  /* Skip ccws                 */

  0008e	c7 45 64 00 00
	00 00		 mov	 DWORD PTR skip_ccws$[rbp], 0

; 4411 : int     cmdretry = 255;                 /* Limit command retry       */

  00095	c7 85 88 00 00
	00 ff 00 00 00	 mov	 DWORD PTR cmdretry$[rbp], 255 ; 000000ffH

; 4412 : U32     prevccwaddr = 1;                /* Previous CCW address      */

  0009f	c7 45 68 01 00
	00 00		 mov	 DWORD PTR prevccwaddr$[rbp], 1

; 4413 : U32     prefetch_remaining;             /* Prefetch bytes remaining  */
; 4414 : 
; 4415 : u_int       ps = 0;                     /* Local prefetch sequence   */

  000a6	c7 45 10 00 00
	00 00		 mov	 DWORD PTR ps$[rbp], 0

; 4416 : u_int       ts;                         /* Test prefetch sequence    */
; 4417 : 
; 4418 : CACHE_ALIGN
; 4419 : PREFETCH    prefetch;                   /* Prefetch buffer           */
; 4420 : 
; 4421 : __ALIGN( IOBUF_ALIGN )
; 4422 : IOBUF iobuf_initial;                    /* Channel I/O buffer        */
; 4423 : 
; 4424 :     /* Initialize prefetch */
; 4425 :     memset(&prefetch, 0, sizeof(prefetch));

  000ad	48 8d 85 c0 01
	00 00		 lea	 rax, QWORD PTR prefetch$[rbp]
  000b4	48 8b f8	 mov	 rdi, rax
  000b7	33 c0		 xor	 eax, eax
  000b9	b9 10 1a 00 00	 mov	 ecx, 6672		; 00001a10H
  000be	f3 aa		 rep stosb

; 4426 : 
; 4427 :     /* Point to initial I/O buffer and initialize */
; 4428 :     iobuf = &iobuf_initial;

  000c0	48 8d 85 00 20
	00 00		 lea	 rax, QWORD PTR iobuf_initial$[rbp]
  000c7	48 89 45 58	 mov	 QWORD PTR iobuf$[rbp], rax

; 4429 :     iobuf_initialize(iobuf, sizeof(iobuf_initial.data));

  000cb	ba 00 00 01 00	 mov	 edx, 65536		; 00010000H
  000d0	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  000d4	e8 00 00 00 00	 call	 iobuf_initialize

; 4430 : 
; 4431 :     obtain_lock (&dev->lock);

  000d9	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  000dd	48 83 c0 38	 add	 rax, 56			; 00000038H
  000e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182532
  000e8	48 8b c8	 mov	 rcx, rax
  000eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4432 : 
; 4433 : #if defined( OPTION_SHARED_DEVICES )
; 4434 :     /* Wait for the device to become available */
; 4435 :     if (dev->shareable)

  000f1	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  000f5	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000fb	c1 e8 03	 shr	 eax, 3
  000fe	83 e0 01	 and	 eax, 1
  00101	85 c0		 test	 eax, eax
  00103	74 09		 je	 SHORT $LN22@s390_execu

; 4436 :     {
; 4437 :         shared_iowait( dev );

  00105	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00109	e8 00 00 00 00	 call	 shared_iowait
$LN22@s390_execu:

; 4438 :     }
; 4439 :     dev->shioactive = DEV_SYS_LOCAL;

  0010e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00112	c7 80 e4 05 00
	00 ff ff 00 00	 mov	 DWORD PTR [rax+1508], 65535 ; 0000ffffH

; 4440 : #endif // defined( OPTION_SHARED_DEVICES )
; 4441 : 
; 4442 :     set_subchannel_busy(dev);

  0011c	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00120	e8 00 00 00 00	 call	 set_subchannel_busy

; 4443 :     dev->startpending = 0;

  00125	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00129	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0012f	0f ba f0 19	 btr	 eax, 25
  00133	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00137	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4444 : 
; 4445 :     /* Increment excp count */
; 4446 :     dev->excps++;

  0013d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00141	48 8b 80 00 06
	00 00		 mov	 rax, QWORD PTR [rax+1536]
  00148	48 ff c0	 inc	 rax
  0014b	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0014f	48 89 81 00 06
	00 00		 mov	 QWORD PTR [rcx+1536], rax

; 4447 : 
; 4448 :     /* Indicate that we're started */
; 4449 :     dev->scsw.flag2 |= SCSW2_FC_START;

  00156	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0015a	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00161	83 c8 40	 or	 eax, 64			; 00000040H
  00164	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00168	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 4450 :     dev->scsw.flag2 &= ~SCSW2_AC_START;

  0016e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00172	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00179	83 e0 fb	 and	 eax, -5
  0017c	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00180	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 4451 : 
; 4452 :     /* Handle early clear or halt */
; 4453 :     if (dev->scsw.flag2 & (SCSW2_AC_CLEAR | SCSW2_AC_HALT))

  00186	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0018a	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00191	83 e0 03	 and	 eax, 3
  00194	85 c0		 test	 eax, eax
  00196	74 34		 je	 SHORT $LN23@s390_execu

; 4454 :     {
; 4455 :         release_lock(&dev->lock);

  00198	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0019c	48 83 c0 38	 add	 rax, 56			; 00000038H
  001a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182535
  001a7	48 8b c8	 mov	 rcx, rax
  001aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4456 :         if (dev->scsw.flag2 & SCSW2_AC_CLEAR)

  001b0	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  001b4	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  001bb	83 e0 01	 and	 eax, 1
  001be	85 c0		 test	 eax, eax
  001c0	74 05		 je	 SHORT $LN24@s390_execu

; 4457 :             goto execute_clear;

  001c2	e9 53 08 00 00	 jmp	 $execute_clear$324
$LN24@s390_execu:

; 4458 :         goto execute_halt;

  001c7	e9 38 09 00 00	 jmp	 $execute_halt$325
$LN23@s390_execu:

; 4459 :     }
; 4460 : 
; 4461 :     /* For hercules `resume' resume suspended state */
; 4462 :     if (dev->resumesuspended || dev->suspended ||

  001cc	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  001d0	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001d6	c1 e8 1a	 shr	 eax, 26
  001d9	83 e0 01	 and	 eax, 1
  001dc	85 c0		 test	 eax, eax
  001de	75 2a		 jne	 SHORT $LN26@s390_execu
  001e0	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  001e4	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001ea	c1 e8 15	 shr	 eax, 21
  001ed	83 e0 01	 and	 eax, 1
  001f0	85 c0		 test	 eax, eax
  001f2	75 16		 jne	 SHORT $LN26@s390_execu
  001f4	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  001f8	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  001ff	83 e0 08	 and	 eax, 8
  00202	85 c0		 test	 eax, eax
  00204	0f 84 08 03 00
	00		 je	 $LN25@s390_execu
$LN26@s390_execu:

; 4463 :         (dev->scsw.flag2 & SCSW2_AC_RESUM))
; 4464 :     {
; 4465 :         /* Restore CCW execution variables */
; 4466 :         ccwaddr = dev->ccwaddr;

  0020a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0020e	8b 80 80 02 00
	00		 mov	 eax, DWORD PTR [rax+640]
  00214	89 45 20	 mov	 DWORD PTR ccwaddr$[rbp], eax

; 4467 :         idapmask = dev->idapmask;

  00217	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0021b	0f b7 80 84 02
	00 00		 movzx	 eax, WORD PTR [rax+644]
  00222	66 89 45 44	 mov	 WORD PTR idapmask$[rbp], ax

; 4468 :         idawfmt = dev->idawfmt;

  00226	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0022a	0f b6 80 86 02
	00 00		 movzx	 eax, BYTE PTR [rax+646]
  00231	88 45 16	 mov	 BYTE PTR idawfmt$[rbp], al

; 4469 :         ccwfmt = dev->ccwfmt;

  00234	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00238	0f b6 80 87 02
	00 00		 movzx	 eax, BYTE PTR [rax+647]
  0023f	88 45 0b	 mov	 BYTE PTR ccwfmt$[rbp], al

; 4470 :         ccwkey = dev->ccwkey;

  00242	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00246	0f b6 80 88 02
	00 00		 movzx	 eax, BYTE PTR [rax+648]
  0024d	88 45 14	 mov	 BYTE PTR ccwkey$[rbp], al

; 4471 : 
; 4472 : 
; 4473 :         /* Turn the `suspended' bits off */
; 4474 :         dev->suspended =

  00250	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00254	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0025a	0f ba f0 1a	 btr	 eax, 26
  0025e	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00262	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
  00268	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0026c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00272	0f ba f0 15	 btr	 eax, 21
  00276	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0027a	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4475 :         dev->resumesuspended=0;
; 4476 : 
; 4477 : #if defined( OPTION_SHARED_DEVICES )
; 4478 :         /* Wait for the device to become available */
; 4479 :         shared_iowait( dev );

  00280	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00284	e8 00 00 00 00	 call	 shared_iowait

; 4480 :         dev->shioactive = DEV_SYS_LOCAL;

  00289	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0028d	c7 80 e4 05 00
	00 ff ff 00 00	 mov	 DWORD PTR [rax+1508], 65535 ; 0000ffffH

; 4481 : #endif // defined( OPTION_SHARED_DEVICES )
; 4482 : 
; 4483 :         set_device_busy(dev);

  00297	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0029b	e8 00 00 00 00	 call	 set_device_busy

; 4484 : 
; 4485 :         if (CCW_TRACING_ACTIVE( dev, tracethis ))

  002a0	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  002a4	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  002aa	c1 e8 0f	 shr	 eax, 15
  002ad	83 e0 01	 and	 eax, 1
  002b0	85 c0		 test	 eax, eax
  002b2	75 0c		 jne	 SHORT $LN28@s390_execu
  002b4	0f b6 45 15	 movzx	 eax, BYTE PTR tracethis$[rbp]
  002b8	85 c0		 test	 eax, eax
  002ba	0f 84 9a 01 00
	00		 je	 $LN27@s390_execu
$LN28@s390_execu:

; 4486 :         {
; 4487 :             if (dev->s370start)

  002c0	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  002c4	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  002ca	d1 e8		 shr	 eax, 1
  002cc	83 e0 01	 and	 eax, 1
  002cf	85 c0		 test	 eax, eax
  002d1	0f 84 c4 00 00
	00		 je	 $LN29@s390_execu

; 4488 :             {
; 4489 :                 if (sysblk.traceFILE)

  002d7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002de	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  002e6	74 0f		 je	 SHORT $LN31@s390_execu

; 4490 :                     tf_1321( dev );

  002e8	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  002ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1321
  002f2	e9 9f 00 00 00	 jmp	 $LN32@s390_execu
$LN31@s390_execu:

; 4491 :                 else
; 4492 :                     /* State successful conversion from synchronous
; 4493 :                      * to asynchronous for 370 mode.
; 4494 :                      */
; 4495 :                     // "%1d:%04X CHAN: start I/O S/370 conversion to asynchronous operation successful"
; 4496 :                     WRMSG( HHC01321, "I", LCSS_DEVNUM );

  002f7	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  002fc	74 10		 je	 SHORT $LN233@s390_execu
  002fe	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00302	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00306	89 85 08 01 00
	00		 mov	 DWORD PTR tv182[rbp], eax
  0030c	eb 0a		 jmp	 SHORT $LN234@s390_execu
$LN233@s390_execu:
  0030e	c7 85 08 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv182[rbp], 0
$LN234@s390_execu:
  00318	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  0031d	74 12		 je	 SHORT $LN235@s390_execu
  0031f	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00323	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00327	d1 f8		 sar	 eax, 1
  00329	89 85 0c 01 00
	00		 mov	 DWORD PTR tv188[rbp], eax
  0032f	eb 0a		 jmp	 SHORT $LN236@s390_execu
$LN235@s390_execu:
  00331	c7 85 0c 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv188[rbp], 0
$LN236@s390_execu:
  0033b	b9 01 00 00 00	 mov	 ecx, 1
  00340	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00346	8b 8d 08 01 00
	00		 mov	 ecx, DWORD PTR tv182[rbp]
  0034c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00350	8b 8d 0c 01 00
	00		 mov	 ecx, DWORD PTR tv188[rbp]
  00356	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0035a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182545
  00361	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00366	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182546
  0036d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00372	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00377	41 b9 03 00 00
	00		 mov	 r9d, 3
  0037d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG182547
  00384	ba 90 11 00 00	 mov	 edx, 4496		; 00001190H
  00389	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182548
  00390	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN32@s390_execu:

; 4497 :             }

  00396	e9 bf 00 00 00	 jmp	 $LN30@s390_execu
$LN29@s390_execu:

; 4498 :             else
; 4499 :             {
; 4500 :                 if (sysblk.traceFILE)

  0039b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003a2	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  003aa	74 0f		 je	 SHORT $LN33@s390_execu

; 4501 :                     tf_1311( dev );

  003ac	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  003b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1311
  003b6	e9 9f 00 00 00	 jmp	 $LN34@s390_execu
$LN33@s390_execu:

; 4502 :                 else
; 4503 :                     /* Trace I/O resumption */
; 4504 :                     // "%1d:%04X CHAN: resumed"
; 4505 :                     WRMSG (HHC01311, "I", LCSS_DEVNUM );

  003bb	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  003c0	74 10		 je	 SHORT $LN237@s390_execu
  003c2	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  003c6	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003ca	89 85 10 01 00
	00		 mov	 DWORD PTR tv205[rbp], eax
  003d0	eb 0a		 jmp	 SHORT $LN238@s390_execu
$LN237@s390_execu:
  003d2	c7 85 10 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv205[rbp], 0
$LN238@s390_execu:
  003dc	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  003e1	74 12		 je	 SHORT $LN239@s390_execu
  003e3	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  003e7	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  003eb	d1 f8		 sar	 eax, 1
  003ed	89 85 14 01 00
	00		 mov	 DWORD PTR tv211[rbp], eax
  003f3	eb 0a		 jmp	 SHORT $LN240@s390_execu
$LN239@s390_execu:
  003f5	c7 85 14 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv211[rbp], 0
$LN240@s390_execu:
  003ff	b9 01 00 00 00	 mov	 ecx, 1
  00404	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0040a	8b 8d 10 01 00
	00		 mov	 ecx, DWORD PTR tv205[rbp]
  00410	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00414	8b 8d 14 01 00
	00		 mov	 ecx, DWORD PTR tv211[rbp]
  0041a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0041e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182551
  00425	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0042a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182552
  00431	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00436	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0043b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00441	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG182553
  00448	ba 99 11 00 00	 mov	 edx, 4505		; 00001199H
  0044d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182554
  00454	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN34@s390_execu:
$LN30@s390_execu:
$LN27@s390_execu:

; 4506 :             }
; 4507 :         }
; 4508 : 
; 4509 :         /* Reset the suspended status in the SCSW */
; 4510 :         dev->scsw.flag2 &= ~SCSW2_AC_RESUM;

  0045a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0045e	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00465	83 e0 f7	 and	 eax, -9
  00468	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0046c	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 4511 :         dev->scsw.flag3 &= ~(SCSW3_AC_SUSP  |

  00472	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00476	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  0047d	83 e0 c6	 and	 eax, -58		; ffffffffffffffc6H
  00480	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00484	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 4512 :                              SCSW3_SC_ALERT |
; 4513 :                              SCSW3_SC_INTER |
; 4514 :                              SCSW3_SC_PEND);
; 4515 :         dev->scsw.flag3 |= (SCSW3_AC_SCHAC | SCSW3_AC_DEVAC);

  0048a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0048e	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00495	0d c0 00 00 00	 or	 eax, 192		; 000000c0H
  0049a	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0049e	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 4516 : 
; 4517 :         /* Call the i/o resume exit if not clearing */
; 4518 :         if (!(dev->scsw.flag2 & SCSW2_AC_CLEAR))

  004a4	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  004a8	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  004af	83 e0 01	 and	 eax, 1
  004b2	85 c0		 test	 eax, eax
  004b4	75 40		 jne	 SHORT $LN35@s390_execu

; 4519 :         {
; 4520 :             /* Don't execute resume exit if S/370 channel start */
; 4521 :             if (!dev->s370start &&

  004b6	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  004ba	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  004c0	d1 e8		 shr	 eax, 1
  004c2	83 e0 01	 and	 eax, 1
  004c5	85 c0		 test	 eax, eax
  004c7	75 24		 jne	 SHORT $LN36@s390_execu
  004c9	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  004cd	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  004d4	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  004d9	74 12		 je	 SHORT $LN36@s390_execu

; 4522 :                 dev->hnd->resume)
; 4523 :                 (dev->hnd->resume) (dev);

  004db	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  004df	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  004e6	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  004ea	ff 50 38	 call	 QWORD PTR [rax+56]
$LN36@s390_execu:

; 4524 : 
; 4525 :             /* Refetch the suspended CCW */
; 4526 :             ccwaddr -= 8;

  004ed	8b 45 20	 mov	 eax, DWORD PTR ccwaddr$[rbp]
  004f0	83 e8 08	 sub	 eax, 8
  004f3	89 45 20	 mov	 DWORD PTR ccwaddr$[rbp], eax
$LN35@s390_execu:

; 4527 :         }
; 4528 : 
; 4529 :         /* Reset S/370 channel SIO resume indicator */
; 4530 :         dev->s370start = 0;

  004f6	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  004fa	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00500	83 e0 fd	 and	 eax, -3			; fffffffdH
  00503	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00507	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4531 : 
; 4532 :         goto resume_suspend;

  0050d	e9 80 01 00 00	 jmp	 $resume_suspend$326
$LN25@s390_execu:

; 4533 :     }
; 4534 : 
; 4535 :     /* Hercules deviation; always zero the SCSW CCW address to start */
; 4536 :     store_fw(dev->scsw.ccwaddr, 0);

  00512	33 c9		 xor	 ecx, ecx
  00514	e8 00 00 00 00	 call	 _byteswap_ulong
  00519	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0051d	48 81 c1 0c 03
	00 00		 add	 rcx, 780		; 0000030cH
  00524	8b d0		 mov	 edx, eax
  00526	e8 00 00 00 00	 call	 store_fw_noswap

; 4537 : 
; 4538 :     /* Call the i/o start exit */
; 4539 :     if (dev->hnd->start)

  0052b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0052f	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00536	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0053b	74 42		 je	 SHORT $LN37@s390_execu

; 4540 :     {
; 4541 :         release_lock (&dev->lock);

  0053d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00541	48 83 c0 38	 add	 rax, 56			; 00000038H
  00545	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182558
  0054c	48 8b c8	 mov	 rcx, rax
  0054f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4542 :         (dev->hnd->start) (dev);

  00555	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00559	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00560	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00564	ff 50 28	 call	 QWORD PTR [rax+40]

; 4543 :         obtain_lock (&dev->lock);

  00567	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0056b	48 83 c0 38	 add	 rax, 56			; 00000038H
  0056f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182559
  00576	48 8b c8	 mov	 rcx, rax
  00579	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN37@s390_execu:

; 4544 :     }
; 4545 : 
; 4546 :     /* Extract the I/O parameters from the ORB */
; 4547 :     FETCH_FW(ccwaddr, dev->orb.ccwaddr);

  0057f	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00583	48 05 d4 02 00
	00		 add	 rax, 724		; 000002d4H
  00589	48 8b c8	 mov	 rcx, rax
  0058c	e8 00 00 00 00	 call	 fetch_fw_noswap
  00591	8b c8		 mov	 ecx, eax
  00593	e8 00 00 00 00	 call	 _byteswap_ulong
  00598	89 45 20	 mov	 DWORD PTR ccwaddr$[rbp], eax

; 4548 :     dev->ccwaddr = ccwaddr;

  0059b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0059f	8b 4d 20	 mov	 ecx, DWORD PTR ccwaddr$[rbp]
  005a2	89 88 80 02 00
	00		 mov	 DWORD PTR [rax+640], ecx

; 4549 :     dev->ccwfmt = ccwfmt = (dev->orb.flag5 & ORB5_F) ? 1 : 0;

  005a8	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  005ac	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  005b3	25 80 00 00 00	 and	 eax, 128		; 00000080H
  005b8	85 c0		 test	 eax, eax
  005ba	74 0c		 je	 SHORT $LN241@s390_execu
  005bc	c7 85 8c 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv283[rbp], 1
  005c6	eb 0a		 jmp	 SHORT $LN242@s390_execu
$LN241@s390_execu:
  005c8	c7 85 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv283[rbp], 0
$LN242@s390_execu:
  005d2	0f b6 85 8c 00
	00 00		 movzx	 eax, BYTE PTR tv283[rbp]
  005d9	88 45 0b	 mov	 BYTE PTR ccwfmt$[rbp], al
  005dc	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  005e0	0f b6 4d 0b	 movzx	 ecx, BYTE PTR ccwfmt$[rbp]
  005e4	88 88 87 02 00
	00		 mov	 BYTE PTR [rax+647], cl

; 4550 :     dev->ccwkey = ccwkey = dev->orb.flag4 & ORB4_KEY;

  005ea	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  005ee	0f b6 80 d0 02
	00 00		 movzx	 eax, BYTE PTR [rax+720]
  005f5	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  005fa	88 45 14	 mov	 BYTE PTR ccwkey$[rbp], al
  005fd	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00601	0f b6 4d 14	 movzx	 ecx, BYTE PTR ccwkey$[rbp]
  00605	88 88 88 02 00
	00		 mov	 BYTE PTR [rax+648], cl

; 4551 :     dev->idawfmt = idawfmt = (dev->orb.flag5 & ORB5_H) ? PF_IDAW2 : PF_IDAW1;

  0060b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0060f	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  00616	83 e0 02	 and	 eax, 2
  00619	85 c0		 test	 eax, eax
  0061b	74 0c		 je	 SHORT $LN243@s390_execu
  0061d	c7 85 90 00 00
	00 02 00 00 00	 mov	 DWORD PTR tv295[rbp], 2
  00627	eb 0a		 jmp	 SHORT $LN244@s390_execu
$LN243@s390_execu:
  00629	c7 85 90 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv295[rbp], 1
$LN244@s390_execu:
  00633	0f b6 85 90 00
	00 00		 movzx	 eax, BYTE PTR tv295[rbp]
  0063a	88 45 16	 mov	 BYTE PTR idawfmt$[rbp], al
  0063d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00641	0f b6 4d 16	 movzx	 ecx, BYTE PTR idawfmt$[rbp]
  00645	88 88 86 02 00
	00		 mov	 BYTE PTR [rax+646], cl

; 4552 : 
; 4553 :     /* Determine IDA page size */
; 4554 :     if (idawfmt == PF_IDAW2)

  0064b	0f b6 45 16	 movzx	 eax, BYTE PTR idawfmt$[rbp]
  0064f	83 f8 02	 cmp	 eax, 2
  00652	75 35		 jne	 SHORT $LN38@s390_execu

; 4555 :     {
; 4556 :         /* Page size is 2K or 4K depending on flag bit */
; 4557 :         idapmask = (dev->orb.flag5 & ORB5_T) ? STORAGE_KEY_2K_BYTEMASK

  00654	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00658	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  0065f	83 e0 01	 and	 eax, 1
  00662	85 c0		 test	 eax, eax
  00664	74 0c		 je	 SHORT $LN245@s390_execu
  00666	c7 85 94 00 00
	00 ff 07 00 00	 mov	 DWORD PTR tv303[rbp], 2047 ; 000007ffH
  00670	eb 0a		 jmp	 SHORT $LN246@s390_execu
$LN245@s390_execu:
  00672	c7 85 94 00 00
	00 ff 0f 00 00	 mov	 DWORD PTR tv303[rbp], 4095 ; 00000fffH
$LN246@s390_execu:
  0067c	0f b7 85 94 00
	00 00		 movzx	 eax, WORD PTR tv303[rbp]
  00683	66 89 45 44	 mov	 WORD PTR idapmask$[rbp], ax

; 4558 :                                              : STORAGE_KEY_4K_BYTEMASK;
; 4559 :     } else {

  00687	eb 09		 jmp	 SHORT $LN39@s390_execu
$LN38@s390_execu:

; 4560 :         /* Page size is always 2K for format-1 IDAW */
; 4561 :         idapmask = STORAGE_KEY_2K_BYTEMASK;

  00689	b8 ff 07 00 00	 mov	 eax, 2047		; 000007ffH
  0068e	66 89 45 44	 mov	 WORD PTR idapmask$[rbp], ax
$LN39@s390_execu:
$resume_suspend$326:

; 4562 :     }
; 4563 : 
; 4564 : 
; 4565 : resume_suspend:
; 4566 : 
; 4567 :     /* Turn off the start pending bit in the SCSW */
; 4568 :     dev->scsw.flag2 &= ~SCSW2_AC_START;

  00692	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00696	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  0069d	83 e0 fb	 and	 eax, -5
  006a0	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  006a4	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 4569 : 
; 4570 :     dev->chained = dev->prev_chained =

  006aa	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  006ae	c7 80 7c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+636], 0
  006b8	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  006bc	c6 80 7b 02 00
	00 00		 mov	 BYTE PTR [rax+635], 0
  006c3	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  006c7	c6 80 7a 02 00
	00 00		 mov	 BYTE PTR [rax+634], 0
  006ce	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  006d2	c6 80 79 02 00
	00 00		 mov	 BYTE PTR [rax+633], 0
  006d9	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  006dd	c6 80 78 02 00
	00 00		 mov	 BYTE PTR [rax+632], 0

; 4571 :     dev->code    = dev->prevcode     = dev->ccwseq = 0;
; 4572 : 
; 4573 : #if defined(_FEATURE_IO_ASSIST)
; 4574 :  #define _IOA_MBO sysblk.zpb[dev->pmcw.zone].mbo
; 4575 :  #define _IOA_MBM sysblk.zpb[dev->pmcw.zone].mbm
; 4576 :  #define _IOA_MBK sysblk.zpb[dev->pmcw.zone].mbk
; 4577 : #else /*defined(_FEATURE_IO_ASSIST)*/
; 4578 :  #define _IOA_MBO sysblk.mbo
; 4579 :  #define _IOA_MBM sysblk.mbm
; 4580 :  #define _IOA_MBK sysblk.mbk
; 4581 : #endif /*defined(_FEATURE_IO_ASSIST)*/
; 4582 : 
; 4583 : #ifdef FEATURE_CHANNEL_SUBSYSTEM
; 4584 :     /* Update the measurement block if applicable */
; 4585 :     if (_IOA_MBM && (dev->pmcw.flag5 & PMCW5_MM_MBU) &&

  006e4	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  006e8	0f b6 80 04 03
	00 00		 movzx	 eax, BYTE PTR [rax+772]
  006ef	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  006f3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006fa	83 bc 01 cc 0e
	00 00 00	 cmp	 DWORD PTR [rcx+rax+3788], 0
  00702	0f 84 9d 02 00
	00		 je	 $LN40@s390_execu
  00708	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0070c	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00713	83 e0 10	 and	 eax, 16
  00716	85 c0		 test	 eax, eax
  00718	0f 84 87 02 00
	00		 je	 $LN40@s390_execu
  0071e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00722	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00729	83 e0 03	 and	 eax, 3
  0072c	85 c0		 test	 eax, eax
  0072e	0f 85 71 02 00
	00		 jne	 $LN40@s390_execu

; 4586 :         !(dev->scsw.flag2 & (SCSW2_AC_CLEAR | SCSW2_AC_HALT)))
; 4587 :     {
; 4588 :         mbaddr = _IOA_MBO;

  00734	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00738	0f b6 80 04 03
	00 00		 movzx	 eax, BYTE PTR [rax+772]
  0073f	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  00743	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0074a	8b 84 01 c0 0e
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3776]
  00751	89 45 4c	 mov	 DWORD PTR mbaddr$[rbp], eax

; 4589 :         mbaddr += (dev->pmcw.mbi[0] << 8 | dev->pmcw.mbi[1]) << 5;

  00754	b8 01 00 00 00	 mov	 eax, 1
  00759	48 6b c0 00	 imul	 rax, rax, 0
  0075d	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00761	0f b6 84 01 f8
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+760]
  00769	c1 e0 08	 shl	 eax, 8
  0076c	b9 01 00 00 00	 mov	 ecx, 1
  00771	48 6b c9 01	 imul	 rcx, rcx, 1
  00775	48 8b 55 00	 mov	 rdx, QWORD PTR dev$[rbp]
  00779	0f b6 8c 0a f8
	02 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+760]
  00781	0b c1		 or	 eax, ecx
  00783	c1 e0 05	 shl	 eax, 5
  00786	8b 4d 4c	 mov	 ecx, DWORD PTR mbaddr$[rbp]
  00789	03 c8		 add	 ecx, eax
  0078b	8b c1		 mov	 eax, ecx
  0078d	89 45 4c	 mov	 DWORD PTR mbaddr$[rbp], eax

; 4590 :         if ( !CHADDRCHK(mbaddr, dev)
; 4591 :             && (((ARCH_DEP( get_dev_storage_key )( dev, mbaddr ) & STORKEY_KEY) == _IOA_MBK)

  00790	8b 45 4c	 mov	 eax, DWORD PTR mbaddr$[rbp]
  00793	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00797	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  0079e	0f 87 2d 01 00
	00		 ja	 $LN41@s390_execu
  007a4	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  007a8	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  007af	83 e0 10	 and	 eax, 16
  007b2	85 c0		 test	 eax, eax
  007b4	74 52		 je	 SHORT $LN43@s390_execu
  007b6	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  007ba	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  007c1	83 e0 20	 and	 eax, 32			; 00000020H
  007c4	85 c0		 test	 eax, eax
  007c6	74 17		 je	 SHORT $LN44@s390_execu
  007c8	8b 45 4c	 mov	 eax, DWORD PTR mbaddr$[rbp]
  007cb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  007d2	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  007d9	0f 82 f2 00 00
	00		 jb	 $LN41@s390_execu
$LN44@s390_execu:
  007df	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  007e3	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  007ea	83 e0 40	 and	 eax, 64			; 00000040H
  007ed	85 c0		 test	 eax, eax
  007ef	74 17		 je	 SHORT $LN45@s390_execu
  007f1	8b 45 4c	 mov	 eax, DWORD PTR mbaddr$[rbp]
  007f4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  007fb	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  00802	0f 83 c9 00 00
	00		 jae	 $LN41@s390_execu
$LN45@s390_execu:
$LN43@s390_execu:
  00808	8b 45 4c	 mov	 eax, DWORD PTR mbaddr$[rbp]
  0080b	8b d0		 mov	 edx, eax
  0080d	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00811	e8 00 00 00 00	 call	 s390_get_dev_storage_key
  00816	0f b6 c0	 movzx	 eax, al
  00819	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  0081e	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00822	0f b6 89 04 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+772]
  00829	48 6b c9 38	 imul	 rcx, rcx, 56		; 00000038H
  0082d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00834	0f b6 8c 0a c8
	0e 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+3784]
  0083c	3b c1		 cmp	 eax, ecx
  0083e	74 22		 je	 SHORT $LN46@s390_execu
  00840	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00844	0f b6 80 04 03
	00 00		 movzx	 eax, BYTE PTR [rax+772]
  0084b	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  0084f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00856	0f b6 84 01 c8
	0e 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3784]
  0085e	85 c0		 test	 eax, eax
  00860	75 6f		 jne	 SHORT $LN41@s390_execu
$LN46@s390_execu:

; 4592 :                 || (_IOA_MBK == 0)))
; 4593 :         {
; 4594 :             ARCH_DEP( or_dev_storage_key )( dev, mbaddr, (STORKEY_REF | STORKEY_CHANGE) );

  00862	8b 45 4c	 mov	 eax, DWORD PTR mbaddr$[rbp]
  00865	41 b0 06	 mov	 r8b, 6
  00868	8b d0		 mov	 edx, eax
  0086a	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0086e	e8 00 00 00 00	 call	 s390_or_dev_storage_key

; 4595 :             mbk = (MBK*)&dev->mainstor[mbaddr];

  00873	8b 45 4c	 mov	 eax, DWORD PTR mbaddr$[rbp]
  00876	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0087a	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00881	48 03 c8	 add	 rcx, rax
  00884	48 8b c1	 mov	 rax, rcx
  00887	48 89 85 88 01
	00 00		 mov	 QWORD PTR mbk$[rbp], rax

; 4596 :             FETCH_HW(mbcount,mbk->srcount);

  0088e	48 8b 85 88 01
	00 00		 mov	 rax, QWORD PTR mbk$[rbp]
  00895	48 8b c8	 mov	 rcx, rax
  00898	e8 00 00 00 00	 call	 fetch_hw_noswap
  0089d	0f b7 c8	 movzx	 ecx, ax
  008a0	e8 00 00 00 00	 call	 _byteswap_ushort
  008a5	66 89 45 70	 mov	 WORD PTR mbcount$[rbp], ax

; 4597 :             mbcount++;

  008a9	0f b7 45 70	 movzx	 eax, WORD PTR mbcount$[rbp]
  008ad	66 ff c0	 inc	 ax
  008b0	66 89 45 70	 mov	 WORD PTR mbcount$[rbp], ax

; 4598 :             STORE_HW(mbk->srcount,mbcount);

  008b4	0f b7 4d 70	 movzx	 ecx, WORD PTR mbcount$[rbp]
  008b8	e8 00 00 00 00	 call	 _byteswap_ushort
  008bd	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR mbk$[rbp]
  008c4	0f b7 d0	 movzx	 edx, ax
  008c7	e8 00 00 00 00	 call	 store_hw_noswap

; 4599 :         } else {

  008cc	e9 d4 00 00 00	 jmp	 $LN42@s390_execu
$LN41@s390_execu:

; 4600 :             /* Generate subchannel logout indicating program
; 4601 :                check or protection check, and set the subchannel
; 4602 :                measurement-block-update-enable to zero */
; 4603 :             dev->pmcw.flag5 &= ~PMCW5_MM_MBU;

  008d1	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  008d5	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  008dc	83 e0 ef	 and	 eax, -17
  008df	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  008e3	88 81 f1 02 00
	00		 mov	 BYTE PTR [rcx+753], al

; 4604 :             dev->esw.scl0 |= !CHADDRCHK(mbaddr, dev) ?

  008e9	8b 45 4c	 mov	 eax, DWORD PTR mbaddr$[rbp]
  008ec	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  008f0	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  008f7	77 68		 ja	 SHORT $LN251@s390_execu
  008f9	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  008fd	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  00904	83 e0 10	 and	 eax, 16
  00907	85 c0		 test	 eax, eax
  00909	74 4a		 je	 SHORT $LN250@s390_execu
  0090b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0090f	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00916	83 e0 20	 and	 eax, 32			; 00000020H
  00919	85 c0		 test	 eax, eax
  0091b	74 13		 je	 SHORT $LN247@s390_execu
  0091d	8b 45 4c	 mov	 eax, DWORD PTR mbaddr$[rbp]
  00920	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00927	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  0092e	72 31		 jb	 SHORT $LN249@s390_execu
$LN247@s390_execu:
  00930	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00934	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0093b	83 e0 40	 and	 eax, 64			; 00000040H
  0093e	85 c0		 test	 eax, eax
  00940	74 13		 je	 SHORT $LN248@s390_execu
  00942	8b 45 4c	 mov	 eax, DWORD PTR mbaddr$[rbp]
  00945	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0094c	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  00953	73 0c		 jae	 SHORT $LN251@s390_execu
$LN250@s390_execu:
$LN248@s390_execu:
  00955	c7 85 98 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv437[rbp], 1
  0095f	eb 0a		 jmp	 SHORT $LN252@s390_execu
$LN251@s390_execu:
$LN249@s390_execu:
  00961	c7 85 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv437[rbp], 0
$LN252@s390_execu:
  0096b	83 bd 98 00 00
	00 00		 cmp	 DWORD PTR tv437[rbp], 0
  00972	74 0c		 je	 SHORT $LN253@s390_execu
  00974	c7 85 9c 00 00
	00 08 00 00 00	 mov	 DWORD PTR tv439[rbp], 8
  0097e	eb 0a		 jmp	 SHORT $LN254@s390_execu
$LN253@s390_execu:
  00980	c7 85 9c 00 00
	00 20 00 00 00	 mov	 DWORD PTR tv439[rbp], 32 ; 00000020H
$LN254@s390_execu:
  0098a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0098e	0f b6 80 2c 03
	00 00		 movzx	 eax, BYTE PTR [rax+812]
  00995	0b 85 9c 00 00
	00		 or	 eax, DWORD PTR tv439[rbp]
  0099b	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0099f	88 81 2c 03 00
	00		 mov	 BYTE PTR [rcx+812], al
$LN42@s390_execu:
$LN40@s390_execu:

; 4605 :                                  SCL0_ESF_MBPTK : SCL0_ESF_MBPGK;
; 4606 :             /*INCOMPLETE*/
; 4607 :         }
; 4608 :     }
; 4609 : #endif /*FEATURE_CHANNEL_SUBSYSTEM*/
; 4610 : 
; 4611 :     release_lock (&dev->lock);

  009a5	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  009a9	48 83 c0 38	 add	 rax, 56			; 00000038H
  009ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182569
  009b4	48 8b c8	 mov	 rcx, rax
  009b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN322@s390_execu:
$LN321@s390_execu:
$LN320@s390_execu:
$LN2@s390_execu:

; 4612 : 
; 4613 :     /* Execute the CCW chain */
; 4614 :     /* On entry : No locks held */
; 4615 :     while ( chain )

  009bd	0f b6 45 1c	 movzx	 eax, BYTE PTR chain$[rbp]
  009c1	85 c0		 test	 eax, eax
  009c3	0f 84 91 29 00
	00		 je	 $LN3@s390_execu

; 4616 :     {
; 4617 :         /* Test for clear subchannel request or system shutdown */
; 4618 :         if (dev->scsw.flag2 & SCSW2_AC_CLEAR ||

  009c9	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  009cd	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  009d4	83 e0 01	 and	 eax, 1
  009d7	85 c0		 test	 eax, eax
  009d9	75 1b		 jne	 SHORT $LN48@s390_execu
  009db	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  009e2	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  009e8	c1 e8 0b	 shr	 eax, 11
  009eb	83 e0 01	 and	 eax, 1
  009ee	85 c0		 test	 eax, eax
  009f0	0f 84 91 00 00
	00		 je	 $LN47@s390_execu
$LN48@s390_execu:

; 4619 :             sysblk.shutdown)
; 4620 :         {
; 4621 : 
; 4622 :             /* No I/O delays are to be taken during clear operations */
; 4623 : 
; 4624 :             /* Call the i/o end exit */
; 4625 :             if (dev->hnd->end) (dev->hnd->end) (dev);

  009f6	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  009fa	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00a01	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00a06	74 12		 je	 SHORT $LN49@s390_execu
  00a08	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00a0c	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00a13	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00a17	ff 50 30	 call	 QWORD PTR [rax+48]
$LN49@s390_execu:
$execute_clear$324:

; 4626 : 
; 4627 : execute_clear:
; 4628 :             /* Get necessary locks */
; 4629 :             OBTAIN_INTLOCK(NULL);

  00a1a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182573
  00a21	33 c9		 xor	 ecx, ecx
  00a23	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 4630 :             obtain_lock(&dev->lock);

  00a28	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00a2c	48 83 c0 38	 add	 rax, 56			; 00000038H
  00a30	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182574
  00a37	48 8b c8	 mov	 rcx, rax
  00a3a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4631 : 
; 4632 :             /* Execute clear function */
; 4633 :             perform_clear_subchan(dev);

  00a40	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00a44	e8 00 00 00 00	 call	 perform_clear_subchan

; 4634 : 
; 4635 :             /* Release locks */
; 4636 :             release_lock(&dev->lock);

  00a49	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00a4d	48 83 c0 38	 add	 rax, 56			; 00000038H
  00a51	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182575
  00a58	48 8b c8	 mov	 rcx, rax
  00a5b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4637 :             RELEASE_INTLOCK(NULL);

  00a61	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182576
  00a68	33 c9		 xor	 ecx, ecx
  00a6a	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 4638 : 
; 4639 :             /* Return */
; 4640 :             return execute_ccw_chain_fast_return( iobuf, &iobuf_initial, NULL );

  00a6f	45 33 c0	 xor	 r8d, r8d
  00a72	48 8d 95 00 20
	00 00		 lea	 rdx, QWORD PTR iobuf_initial$[rbp]
  00a79	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  00a7d	e8 00 00 00 00	 call	 execute_ccw_chain_fast_return
  00a82	e9 bd 2c 00 00	 jmp	 $LN1@s390_execu
$LN47@s390_execu:

; 4641 : 
; 4642 :         } /* end perform clear subchannel */
; 4643 : 
; 4644 :         /* Test for halt subchannel request */
; 4645 :         if (dev->scsw.flag2 & SCSW2_AC_HALT)

  00a87	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00a8b	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00a92	83 e0 02	 and	 eax, 2
  00a95	85 c0		 test	 eax, eax
  00a97	0f 84 67 01 00
	00		 je	 $LN50@s390_execu
$LN6@s390_execu:

; 4646 :         {
; 4647 :             IODELAY(dev);

  00a9d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00aa4	83 b8 e0 13 00
	00 00		 cmp	 DWORD PTR [rax+5088], 0
  00aab	7e 2d		 jle	 SHORT $LN51@s390_execu
  00aad	b8 01 00 00 00	 mov	 eax, 1
  00ab2	48 6b c0 0a	 imul	 rax, rax, 10
  00ab6	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00aba	0f b6 84 01 6c
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1388]
  00ac2	83 f8 20	 cmp	 eax, 32			; 00000020H
  00ac5	75 13		 jne	 SHORT $LN51@s390_execu
  00ac7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00ace	8b 88 e0 13 00
	00		 mov	 ecx, DWORD PTR [rax+5088]
  00ad4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN51@s390_execu:
  00ada	33 c0		 xor	 eax, eax
  00adc	85 c0		 test	 eax, eax
  00ade	75 bd		 jne	 SHORT $LN6@s390_execu

; 4648 : 
; 4649 :             /* Call the i/o end exit */
; 4650 :             if (dev->hnd->end) (dev->hnd->end) (dev);

  00ae0	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00ae4	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00aeb	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00af0	74 12		 je	 SHORT $LN52@s390_execu
  00af2	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00af6	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00afd	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00b01	ff 50 30	 call	 QWORD PTR [rax+48]
$LN52@s390_execu:
$execute_halt$325:

; 4651 : 
; 4652 : execute_halt:
; 4653 :             perform_halt(dev);

  00b04	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00b08	e8 00 00 00 00	 call	 perform_halt

; 4654 : 
; 4655 :             if (tracethis)

  00b0d	0f b6 45 15	 movzx	 eax, BYTE PTR tracethis$[rbp]
  00b11	85 c0		 test	 eax, eax
  00b13	0f 84 d3 00 00
	00		 je	 $LN53@s390_execu

; 4656 :             {
; 4657 :                 if (dev->ccwtrace && sysblk.traceFILE)

  00b19	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00b1d	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00b23	c1 e8 0f	 shr	 eax, 15
  00b26	83 e0 01	 and	 eax, 1
  00b29	85 c0		 test	 eax, eax
  00b2b	74 20		 je	 SHORT $LN54@s390_execu
  00b2d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b34	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00b3c	74 0f		 je	 SHORT $LN54@s390_execu

; 4658 :                     tf_1309( dev );

  00b3e	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00b42	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1309
  00b48	e9 9f 00 00 00	 jmp	 $LN55@s390_execu
$LN54@s390_execu:

; 4659 :                 else
; 4660 :                     // "%1d:%04X CHAN: halt completed"
; 4661 :                     WRMSG( HHC01309, "I", LCSS_DEVNUM );

  00b4d	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  00b52	74 10		 je	 SHORT $LN255@s390_execu
  00b54	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00b58	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00b5c	89 85 a0 00 00
	00		 mov	 DWORD PTR tv511[rbp], eax
  00b62	eb 0a		 jmp	 SHORT $LN256@s390_execu
$LN255@s390_execu:
  00b64	c7 85 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv511[rbp], 0
$LN256@s390_execu:
  00b6e	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  00b73	74 12		 je	 SHORT $LN257@s390_execu
  00b75	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00b79	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00b7d	d1 f8		 sar	 eax, 1
  00b7f	89 85 a4 00 00
	00		 mov	 DWORD PTR tv517[rbp], eax
  00b85	eb 0a		 jmp	 SHORT $LN258@s390_execu
$LN257@s390_execu:
  00b87	c7 85 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv517[rbp], 0
$LN258@s390_execu:
  00b91	b9 01 00 00 00	 mov	 ecx, 1
  00b96	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b9c	8b 8d a0 00 00
	00		 mov	 ecx, DWORD PTR tv511[rbp]
  00ba2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00ba6	8b 8d a4 00 00
	00		 mov	 ecx, DWORD PTR tv517[rbp]
  00bac	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00bb0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182583
  00bb7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00bbc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182584
  00bc3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00bc8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00bcd	41 b9 03 00 00
	00		 mov	 r9d, 3
  00bd3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG182585
  00bda	ba 35 12 00 00	 mov	 edx, 4661		; 00001235H
  00bdf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182586
  00be6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN55@s390_execu:
$LN53@s390_execu:

; 4662 :             }
; 4663 : 
; 4664 :             return execute_ccw_chain_fast_return( iobuf, &iobuf_initial, NULL );

  00bec	45 33 c0	 xor	 r8d, r8d
  00bef	48 8d 95 00 20
	00 00		 lea	 rdx, QWORD PTR iobuf_initial$[rbp]
  00bf6	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  00bfa	e8 00 00 00 00	 call	 execute_ccw_chain_fast_return
  00bff	e9 40 2b 00 00	 jmp	 $LN1@s390_execu
$LN50@s390_execu:

; 4665 : 
; 4666 :         } /* end perform halt subchannel */
; 4667 : 
; 4668 :         /* Test for attention status from device */
; 4669 :         if (dev->scsw.flag3 & SCSW3_SC_ALERT)

  00c04	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00c08	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00c0f	83 e0 10	 and	 eax, 16
  00c12	85 c0		 test	 eax, eax
  00c14	0f 84 80 01 00
	00		 je	 $LN56@s390_execu
$LN9@s390_execu:

; 4670 :         {
; 4671 :             IODELAY(dev);

  00c1a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00c21	83 b8 e0 13 00
	00 00		 cmp	 DWORD PTR [rax+5088], 0
  00c28	7e 2d		 jle	 SHORT $LN57@s390_execu
  00c2a	b8 01 00 00 00	 mov	 eax, 1
  00c2f	48 6b c0 0a	 imul	 rax, rax, 10
  00c33	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00c37	0f b6 84 01 6c
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1388]
  00c3f	83 f8 20	 cmp	 eax, 32			; 00000020H
  00c42	75 13		 jne	 SHORT $LN57@s390_execu
  00c44	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00c4b	8b 88 e0 13 00
	00		 mov	 ecx, DWORD PTR [rax+5088]
  00c51	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN57@s390_execu:
  00c57	33 c0		 xor	 eax, eax
  00c59	85 c0		 test	 eax, eax
  00c5b	75 bd		 jne	 SHORT $LN9@s390_execu

; 4672 : 
; 4673 :             /* Call the i/o end exit */
; 4674 :             if (dev->hnd->end) (dev->hnd->end) (dev);

  00c5d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00c61	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00c68	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00c6d	74 12		 je	 SHORT $LN58@s390_execu
  00c6f	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00c73	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00c7a	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00c7e	ff 50 30	 call	 QWORD PTR [rax+48]
$LN58@s390_execu:

; 4675 : 
; 4676 :             /* Queue the pending interrupt and update status */
; 4677 :             queue_io_interrupt_and_update_status(dev,TRUE);

  00c81	ba 01 00 00 00	 mov	 edx, 1
  00c86	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00c8a	e8 00 00 00 00	 call	 queue_io_interrupt_and_update_status

; 4678 : 
; 4679 :             if (CCW_TRACING_ACTIVE( dev, tracethis ))

  00c8f	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00c93	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00c99	c1 e8 0f	 shr	 eax, 15
  00c9c	83 e0 01	 and	 eax, 1
  00c9f	85 c0		 test	 eax, eax
  00ca1	75 0c		 jne	 SHORT $LN60@s390_execu
  00ca3	0f b6 45 15	 movzx	 eax, BYTE PTR tracethis$[rbp]
  00ca7	85 c0		 test	 eax, eax
  00ca9	0f 84 d3 00 00
	00		 je	 $LN59@s390_execu
$LN60@s390_execu:

; 4680 :             {
; 4681 :                 if (dev->ccwtrace && sysblk.traceFILE)

  00caf	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00cb3	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00cb9	c1 e8 0f	 shr	 eax, 15
  00cbc	83 e0 01	 and	 eax, 1
  00cbf	85 c0		 test	 eax, eax
  00cc1	74 20		 je	 SHORT $LN61@s390_execu
  00cc3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00cca	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00cd2	74 0f		 je	 SHORT $LN61@s390_execu

; 4682 :                     tf_1307( dev );

  00cd4	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00cd8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1307
  00cde	e9 9f 00 00 00	 jmp	 $LN62@s390_execu
$LN61@s390_execu:

; 4683 :                 else
; 4684 :                     // "%1d:%04X CHAN: attention completed"
; 4685 :                     WRMSG( HHC01307, "I", LCSS_DEVNUM );

  00ce3	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  00ce8	74 10		 je	 SHORT $LN259@s390_execu
  00cea	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00cee	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00cf2	89 85 a8 00 00
	00		 mov	 DWORD PTR tv570[rbp], eax
  00cf8	eb 0a		 jmp	 SHORT $LN260@s390_execu
$LN259@s390_execu:
  00cfa	c7 85 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv570[rbp], 0
$LN260@s390_execu:
  00d04	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  00d09	74 12		 je	 SHORT $LN261@s390_execu
  00d0b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00d0f	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00d13	d1 f8		 sar	 eax, 1
  00d15	89 85 ac 00 00
	00		 mov	 DWORD PTR tv576[rbp], eax
  00d1b	eb 0a		 jmp	 SHORT $LN262@s390_execu
$LN261@s390_execu:
  00d1d	c7 85 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv576[rbp], 0
$LN262@s390_execu:
  00d27	b9 01 00 00 00	 mov	 ecx, 1
  00d2c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00d32	8b 8d a8 00 00
	00		 mov	 ecx, DWORD PTR tv570[rbp]
  00d38	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00d3c	8b 8d ac 00 00
	00		 mov	 ecx, DWORD PTR tv576[rbp]
  00d42	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00d46	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182594
  00d4d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00d52	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182595
  00d59	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00d5e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d63	41 b9 03 00 00
	00		 mov	 r9d, 3
  00d69	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG182596
  00d70	ba 4d 12 00 00	 mov	 edx, 4685		; 0000124dH
  00d75	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182597
  00d7c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN62@s390_execu:
$LN59@s390_execu:

; 4686 :             }
; 4687 : 
; 4688 :             return execute_ccw_chain_fast_return( iobuf, &iobuf_initial, NULL );

  00d82	45 33 c0	 xor	 r8d, r8d
  00d85	48 8d 95 00 20
	00 00		 lea	 rdx, QWORD PTR iobuf_initial$[rbp]
  00d8c	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  00d90	e8 00 00 00 00	 call	 execute_ccw_chain_fast_return
  00d95	e9 aa 29 00 00	 jmp	 $LN1@s390_execu
$LN56@s390_execu:

; 4689 : 
; 4690 :         } /* end attention processing */
; 4691 : 
; 4692 :         /* Clear the channel status and unit status, unless skipping
; 4693 :            to end of chain data */
; 4694 :         if (!skip_ccws)

  00d9a	83 7d 64 00	 cmp	 DWORD PTR skip_ccws$[rbp], 0
  00d9e	75 08		 jne	 SHORT $LN63@s390_execu

; 4695 :         {
; 4696 :             chanstat = 0;

  00da0	c6 45 09 00	 mov	 BYTE PTR chanstat$[rbp], 0

; 4697 :             unitstat = 0;

  00da4	c6 45 0c 00	 mov	 BYTE PTR unitstat$[rbp], 0
$LN63@s390_execu:

; 4698 :         }
; 4699 : 
; 4700 :         /* Fetch the next CCW */
; 4701 :         ARCH_DEP(fetch_ccw) (dev, ccwkey, ccwfmt, ccwaddr, &opcode,

  00da8	48 8d 45 09	 lea	 rax, QWORD PTR chanstat$[rbp]
  00dac	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00db1	48 8d 45 18	 lea	 rax, QWORD PTR count$[rbp]
  00db5	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00dba	48 8d 45 08	 lea	 rax, QWORD PTR flags$[rbp]
  00dbe	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00dc3	48 8d 45 24	 lea	 rax, QWORD PTR addr$[rbp]
  00dc7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00dcc	48 8d 45 0a	 lea	 rax, QWORD PTR opcode$[rbp]
  00dd0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00dd5	44 8b 4d 20	 mov	 r9d, DWORD PTR ccwaddr$[rbp]
  00dd9	44 0f b6 45 0b	 movzx	 r8d, BYTE PTR ccwfmt$[rbp]
  00dde	0f b6 55 14	 movzx	 edx, BYTE PTR ccwkey$[rbp]
  00de2	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00de6	e8 00 00 00 00	 call	 s390_fetch_ccw

; 4702 :                              &addr, &flags, &count, &chanstat);
; 4703 : 
; 4704 :         /*************************************************************/
; 4705 :         /* NOTE: Order of process must not only match the Principles */
; 4706 :         /*       of Operations, but must also match the processing   */
; 4707 :         /*       order of real channels.                             */
; 4708 :         /*************************************************************/
; 4709 : 
; 4710 :         /* For an invalid CCW address in a TIC we must backup to
; 4711 :            TIC+8 */
; 4712 :         if(ticaddr && (chanstat & CSW_PROGC))

  00deb	83 7d 78 00	 cmp	 DWORD PTR ticaddr$[rbp], 0
  00def	74 14		 je	 SHORT $LN64@s390_execu
  00df1	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  00df5	83 e0 20	 and	 eax, 32			; 00000020H
  00df8	85 c0		 test	 eax, eax
  00dfa	74 09		 je	 SHORT $LN64@s390_execu

; 4713 :             ccwaddr = ticaddr-8;

  00dfc	8b 45 78	 mov	 eax, DWORD PTR ticaddr$[rbp]
  00dff	83 e8 08	 sub	 eax, 8
  00e02	89 45 20	 mov	 DWORD PTR ccwaddr$[rbp], eax
$LN64@s390_execu:

; 4714 : 
; 4715 :         /* Point to the CCW in main storage */
; 4716 :         ccw = dev->mainstor + ccwaddr;

  00e05	8b 45 20	 mov	 eax, DWORD PTR ccwaddr$[rbp]
  00e08	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00e0c	48 03 81 80 00
	00 00		 add	 rax, QWORD PTR [rcx+128]
  00e13	48 89 85 80 00
	00 00		 mov	 QWORD PTR ccw$[rbp], rax

; 4717 : 
; 4718 :         /* Increment to next CCW address */
; 4719 :         ccwaddr += 8;

  00e1a	8b 45 20	 mov	 eax, DWORD PTR ccwaddr$[rbp]
  00e1d	83 c0 08	 add	 eax, 8
  00e20	89 45 20	 mov	 DWORD PTR ccwaddr$[rbp], eax

; 4720 : 
; 4721 :         /* If prefetch, update prefetch table */
; 4722 :         if (prefetch.seq && (dev->chained & CCW_FLAGS_CD))

  00e23	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  00e2a	0f 84 93 00 00
	00		 je	 $LN65@s390_execu
  00e30	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00e34	0f b6 80 78 02
	00 00		 movzx	 eax, BYTE PTR [rax+632]
  00e3b	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00e40	85 c0		 test	 eax, eax
  00e42	74 7f		 je	 SHORT $LN65@s390_execu

; 4723 :         {
; 4724 :             ps = prefetch.seq++;

  00e44	8b 85 c0 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp]
  00e4a	89 45 10	 mov	 DWORD PTR ps$[rbp], eax
  00e4d	8b 85 c0 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp]
  00e53	ff c0		 inc	 eax
  00e55	89 85 c0 01 00
	00		 mov	 DWORD PTR prefetch$[rbp], eax

; 4725 :             if (prefetch.seq > PF_SIZE)

  00e5b	81 bd c0 01 00
	00 00 01 00 00	 cmp	 DWORD PTR prefetch$[rbp], 256 ; 00000100H
  00e65	76 05		 jbe	 SHORT $LN67@s390_execu

; 4726 :                 goto breakchain;

  00e67	e9 c4 17 00 00	 jmp	 $breakchain$327
$LN67@s390_execu:

; 4727 :             prefetch.ccwaddr[ps] = ccwaddr;

  00e6c	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  00e6f	8b 4d 20	 mov	 ecx, DWORD PTR ccwaddr$[rbp]
  00e72	89 8c 85 d0 02
	00 00		 mov	 DWORD PTR prefetch$[rbp+rax*4+272], ecx

; 4728 :             prefetch.ccwflags[ps] = flags;

  00e79	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  00e7c	0f b6 4d 08	 movzx	 ecx, BYTE PTR flags$[rbp]
  00e80	88 8c 05 d0 12
	00 00		 mov	 BYTE PTR prefetch$[rbp+rax+4368], cl

; 4729 :             prefetch.ccwcount[ps] =

  00e87	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  00e8a	8b 4d 18	 mov	 ecx, DWORD PTR count$[rbp]
  00e8d	89 8c 85 d0 06
	00 00		 mov	 DWORD PTR prefetch$[rbp+rax*4+1296], ecx
  00e94	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  00e97	0f b7 4d 18	 movzx	 ecx, WORD PTR count$[rbp]
  00e9b	66 89 8c 45 d0
	13 00 00	 mov	 WORD PTR prefetch$[rbp+rax*2+4624], cx

; 4730 :             prefetch.datalen[ps] = count;
; 4731 :             prefetch.dataaddr[ps] = addr;

  00ea3	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  00ea6	8b 4d 24	 mov	 ecx, DWORD PTR addr$[rbp]
  00ea9	48 89 8c c5 d0
	0a 00 00	 mov	 QWORD PTR prefetch$[rbp+rax*8+2320], rcx

; 4732 : 
; 4733 :             /* Exit if fetch_ccw detected channel program check */
; 4734 :             if (chanstat)

  00eb1	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  00eb5	85 c0		 test	 eax, eax
  00eb7	74 05		 je	 SHORT $LN68@s390_execu

; 4735 :                 goto prefetch;

  00eb9	e9 b0 0f 00 00	 jmp	 $prefetch$328
$LN68@s390_execu:

; 4736 :         }

  00ebe	e9 e8 00 00 00	 jmp	 $LN66@s390_execu
$LN65@s390_execu:

; 4737 :         else
; 4738 :         {
; 4739 :             /* Update the CCW address in the SCSW */
; 4740 :             STORE_FW(dev->scsw.ccwaddr,ccwaddr);

  00ec3	8b 4d 20	 mov	 ecx, DWORD PTR ccwaddr$[rbp]
  00ec6	e8 00 00 00 00	 call	 _byteswap_ulong
  00ecb	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00ecf	48 81 c1 0c 03
	00 00		 add	 rcx, 780		; 0000030cH
  00ed6	8b d0		 mov	 edx, eax
  00ed8	e8 00 00 00 00	 call	 store_fw_noswap

; 4741 : 
; 4742 :             /* Exit if fetch_ccw detected channel program check */
; 4743 :             if (chanstat != 0)

  00edd	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  00ee1	85 c0		 test	 eax, eax
  00ee3	74 05		 je	 SHORT $LN69@s390_execu

; 4744 :                 goto breakchain;

  00ee5	e9 46 17 00 00	 jmp	 $breakchain$327
$LN69@s390_execu:

; 4745 : 
; 4746 :             /* Trace the CCW -- UNLESS ... it's a read type! For read
; 4747 :                type CCWs, we defer the tracing until AFTER the CCW has
; 4748 :                been executed and the data copied to storage (i.e. we
; 4749 :                don't trace the CCW until after BOTH the driver's CCW
; 4750 :                handler (dev->hnd->exec) and ARCH_DEP(copy_iobuf) have
; 4751 :                been called; see much further below).
; 4752 :             */
; 4753 :             if (1
; 4754 :                 && dev->ccwtrace
; 4755 :                 && !(0

  00eea	33 c0		 xor	 eax, eax
  00eec	83 f8 01	 cmp	 eax, 1
  00eef	0f 84 b6 00 00
	00		 je	 $LN70@s390_execu
  00ef5	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00ef9	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00eff	c1 e8 0f	 shr	 eax, 15
  00f02	83 e0 01	 and	 eax, 1
  00f05	85 c0		 test	 eax, eax
  00f07	0f 84 9e 00 00
	00		 je	 $LN70@s390_execu
  00f0d	33 c0		 xor	 eax, eax
  00f0f	85 c0		 test	 eax, eax
  00f11	0f 85 94 00 00
	00		 jne	 $LN70@s390_execu
  00f17	b8 01 00 00 00	 mov	 eax, 1
  00f1c	48 6b c0 00	 imul	 rax, rax, 0
  00f20	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR ccw$[rbp]
  00f27	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00f2b	83 e0 03	 and	 eax, 3
  00f2e	83 f8 02	 cmp	 eax, 2
  00f31	74 78		 je	 SHORT $LN70@s390_execu
  00f33	b8 01 00 00 00	 mov	 eax, 1
  00f38	48 6b c0 00	 imul	 rax, rax, 0
  00f3c	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR ccw$[rbp]
  00f43	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00f47	83 e0 0f	 and	 eax, 15
  00f4a	83 f8 0c	 cmp	 eax, 12
  00f4d	74 5c		 je	 SHORT $LN70@s390_execu
  00f4f	b8 01 00 00 00	 mov	 eax, 1
  00f54	48 6b c0 00	 imul	 rax, rax, 0
  00f58	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR ccw$[rbp]
  00f5f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00f63	83 e0 0f	 and	 eax, 15
  00f66	83 f8 04	 cmp	 eax, 4
  00f69	74 40		 je	 SHORT $LN70@s390_execu

; 4756 :                      || IS_CCW_READ  ( ccw[0] )
; 4757 :                      || IS_CCW_RDBACK( ccw[0] )
; 4758 :                      || IS_CCW_SENSE ( ccw[0] )
; 4759 :                     )
; 4760 :             )
; 4761 :                 DISPLAY_CCW( dev, ccw, addr, count, flags );

  00f6b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG182606
  00f72	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00f77	c7 44 24 30 99
	12 00 00	 mov	 DWORD PTR [rsp+48], 4761 ; 00001299H
  00f7f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG182607
  00f86	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00f8b	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  00f8f	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00f93	44 8b 4d 18	 mov	 r9d, DWORD PTR count$[rbp]
  00f97	44 8b 45 24	 mov	 r8d, DWORD PTR addr$[rbp]
  00f9b	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR ccw$[rbp]
  00fa2	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00fa6	e8 00 00 00 00	 call	 _display_ccw
$LN70@s390_execu:
$LN66@s390_execu:

; 4762 :         }
; 4763 : 
; 4764 :         /* Channel program check if invalid Format-1 CCW             */
; 4765 :         /* SA22-7201-05:                                             */
; 4766 :         /*  pp. 15-23 -- 15-24, Channel_Command Word                 */
; 4767 :         /*  p. 15-25, Count                                          */
; 4768 :         /*  p. 16-25, Invalid Count, Format 1                        */
; 4769 :         if (ccwfmt == 1 &&                  /* Validate Format 1     */

  00fab	0f b6 45 0b	 movzx	 eax, BYTE PTR ccwfmt$[rbp]
  00faf	83 f8 01	 cmp	 eax, 1
  00fb2	75 3a		 jne	 SHORT $LN71@s390_execu
  00fb4	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  00fb8	83 f8 08	 cmp	 eax, 8
  00fbb	74 31		 je	 SHORT $LN71@s390_execu
  00fbd	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00fc1	0f b6 80 78 02
	00 00		 movzx	 eax, BYTE PTR [rax+632]
  00fc8	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00fcd	85 c0		 test	 eax, eax
  00fcf	74 1d		 je	 SHORT $LN71@s390_execu
  00fd1	83 7d 18 00	 cmp	 DWORD PTR count$[rbp], 0
  00fd5	75 17		 jne	 SHORT $LN71@s390_execu

; 4770 :             ((opcode != 0x08)              &&
; 4771 :              (dev->chained & CCW_FLAGS_CD) &&
; 4772 :              !count))
; 4773 :             {
; 4774 :                 chanstat = CSW_PROGC;

  00fd7	c6 45 09 20	 mov	 BYTE PTR chanstat$[rbp], 32 ; 00000020H

; 4775 :                 if (prefetch.seq)

  00fdb	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  00fe2	74 05		 je	 SHORT $LN72@s390_execu

; 4776 :                     goto prefetch;

  00fe4	e9 85 0e 00 00	 jmp	 $prefetch$328
$LN72@s390_execu:

; 4777 :                 goto breakchain;

  00fe9	e9 42 16 00 00	 jmp	 $breakchain$327
$LN71@s390_execu:

; 4778 :             }
; 4779 : 
; 4780 :         /* Channel program check if invalid TIC opcode or invalid    */
; 4781 :         /* TIC Format-1 CCW                                          */
; 4782 :         /* SA22-7201-05:                                             */
; 4783 :         /*  p. 15-25, Figure 15-5. Command Code Assignment           */
; 4784 :         /*  p. 15-36, Figure 15-7. Command Codes and Flags           */
; 4785 :         /*  p. 15-37, Transfer in Channel                            */
; 4786 :         if (opcode == 0x08 ||               /* Validate TIC          */

  00fee	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  00ff2	83 f8 08	 cmp	 eax, 8
  00ff5	74 1c		 je	 SHORT $LN74@s390_execu
  00ff7	0f b6 45 0b	 movzx	 eax, BYTE PTR ccwfmt$[rbp]
  00ffb	85 c0		 test	 eax, eax
  00ffd	0f 85 04 01 00
	00		 jne	 $LN73@s390_execu
  01003	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  01007	83 e0 0f	 and	 eax, 15
  0100a	83 f8 08	 cmp	 eax, 8
  0100d	0f 85 f4 00 00
	00		 jne	 $LN73@s390_execu
$LN74@s390_execu:

; 4787 :             (ccwfmt == 0 &&
; 4788 :              ((opcode & 0x0F) == 0x08)))
; 4789 :         {
; 4790 :             if (ticaddr                  || /* No TIC-to-TIC         */
; 4791 :                 (addr & 0x03)            || /* Must be aligned DWORD */
; 4792 :                 (ccwfmt == 1 &&             /* Validate Format 1     */
; 4793 :                  (flags           ||
; 4794 :                   count))                ||

  01013	83 7d 78 00	 cmp	 DWORD PTR ticaddr$[rbp], 0
  01017	75 2c		 jne	 SHORT $LN76@s390_execu
  01019	8b 45 24	 mov	 eax, DWORD PTR addr$[rbp]
  0101c	83 e0 03	 and	 eax, 3
  0101f	85 c0		 test	 eax, eax
  01021	75 22		 jne	 SHORT $LN76@s390_execu
  01023	0f b6 45 0b	 movzx	 eax, BYTE PTR ccwfmt$[rbp]
  01027	83 f8 01	 cmp	 eax, 1
  0102a	75 0e		 jne	 SHORT $LN77@s390_execu
  0102c	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  01030	85 c0		 test	 eax, eax
  01032	75 11		 jne	 SHORT $LN76@s390_execu
  01034	83 7d 18 00	 cmp	 DWORD PTR count$[rbp], 0
  01038	75 0b		 jne	 SHORT $LN76@s390_execu
$LN77@s390_execu:
  0103a	0f b7 45 50	 movzx	 eax, WORD PTR ticback$[rbp]
  0103e	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  01043	7e 30		 jle	 SHORT $LN75@s390_execu
$LN76@s390_execu:

; 4795 :                 ticback > 255               /* Exceeded TIC limit?   */
; 4796 :                 )
; 4797 :             {
; 4798 :                 chanstat = CSW_PROGC;

  01045	c6 45 09 20	 mov	 BYTE PTR chanstat$[rbp], 32 ; 00000020H

; 4799 :                 if (prefetch.seq)

  01049	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  01050	74 1e		 je	 SHORT $LN78@s390_execu

; 4800 :                 {
; 4801 :                     prefetch.ccwflags[ps] = 0;

  01052	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01055	c6 84 05 d0 12
	00 00 00	 mov	 BYTE PTR prefetch$[rbp+rax+4368], 0

; 4802 :                     prefetch.datalen[ps] = 0;

  0105d	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01060	c7 84 85 d0 06
	00 00 00 00 00
	00		 mov	 DWORD PTR prefetch$[rbp+rax*4+1296], 0

; 4803 :                     goto prefetch;

  0106b	e9 fe 0d 00 00	 jmp	 $prefetch$328
$LN78@s390_execu:

; 4804 :                 }
; 4805 :                 goto breakchain;

  01070	e9 bb 15 00 00	 jmp	 $breakchain$327
$LN75@s390_execu:

; 4806 :             }
; 4807 : 
; 4808 :             /* Reuse prefetch entry for next CCW */
; 4809 :             if (prefetch.seq)

  01075	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  0107c	74 59		 je	 SHORT $LN79@s390_execu

; 4810 :             {
; 4811 :                 prefetch.ccwaddr[ps] = 0;

  0107e	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01081	c7 84 85 d0 02
	00 00 00 00 00
	00		 mov	 DWORD PTR prefetch$[rbp+rax*4+272], 0

; 4812 :                 prefetch.ccwflags[ps] = 0;

  0108c	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  0108f	c6 84 05 d0 12
	00 00 00	 mov	 BYTE PTR prefetch$[rbp+rax+4368], 0

; 4813 :                 prefetch.ccwcount[ps] = 0;

  01097	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  0109a	33 c9		 xor	 ecx, ecx
  0109c	66 89 8c 45 d0
	13 00 00	 mov	 WORD PTR prefetch$[rbp+rax*2+4624], cx

; 4814 :                 prefetch.dataaddr[ps] = 0;

  010a4	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  010a7	48 c7 84 c5 d0
	0a 00 00 00 00
	00 00		 mov	 QWORD PTR prefetch$[rbp+rax*8+2320], 0

; 4815 :                 prefetch.datalen[ps] = 0;

  010b3	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  010b6	c7 84 85 d0 06
	00 00 00 00 00
	00		 mov	 DWORD PTR prefetch$[rbp+rax*4+1296], 0

; 4816 :                 ps--;

  010c1	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  010c4	ff c8		 dec	 eax
  010c6	89 45 10	 mov	 DWORD PTR ps$[rbp], eax

; 4817 :                 prefetch.seq--;

  010c9	8b 85 c0 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp]
  010cf	ff c8		 dec	 eax
  010d1	89 85 c0 01 00
	00		 mov	 DWORD PTR prefetch$[rbp], eax
$LN79@s390_execu:

; 4818 :             }
; 4819 : 
; 4820 :             /* Update backwards TIC counter */
; 4821 :             if (addr < ccwaddr)

  010d7	8b 45 20	 mov	 eax, DWORD PTR ccwaddr$[rbp]
  010da	39 45 24	 cmp	 DWORD PTR addr$[rbp], eax
  010dd	73 0d		 jae	 SHORT $LN80@s390_execu

; 4822 :                 ticback++;

  010df	0f b7 45 50	 movzx	 eax, WORD PTR ticback$[rbp]
  010e3	66 ff c0	 inc	 ax
  010e6	66 89 45 50	 mov	 WORD PTR ticback$[rbp], ax
  010ea	eb 06		 jmp	 SHORT $LN81@s390_execu
$LN80@s390_execu:

; 4823 :             else
; 4824 :                 ticback = 0;

  010ec	33 c0		 xor	 eax, eax
  010ee	66 89 45 50	 mov	 WORD PTR ticback$[rbp], ax
$LN81@s390_execu:

; 4825 : 
; 4826 :             /* Set new CCW address (leaving the values of chained and
; 4827 :                code untouched to allow data-chaining through TIC)    */
; 4828 :             ticaddr = ccwaddr;

  010f2	8b 45 20	 mov	 eax, DWORD PTR ccwaddr$[rbp]
  010f5	89 45 78	 mov	 DWORD PTR ticaddr$[rbp], eax

; 4829 :             ccwaddr = addr;

  010f8	8b 45 24	 mov	 eax, DWORD PTR addr$[rbp]
  010fb	89 45 20	 mov	 DWORD PTR ccwaddr$[rbp], eax

; 4830 :             chain = 1;

  010fe	c6 45 1c 01	 mov	 BYTE PTR chain$[rbp], 1

; 4831 :             continue;

  01102	e9 b6 f8 ff ff	 jmp	 $LN2@s390_execu
$LN73@s390_execu:

; 4832 :         }
; 4833 :         ticaddr = 0;                    /* Reset the TIC-to-TIC flag */

  01107	c7 45 78 00 00
	00 00		 mov	 DWORD PTR ticaddr$[rbp], 0

; 4834 : 
; 4835 :         /* Reset TIC back counter if Read or Write CCW               */
; 4836 :         if (IS_CCW_WRITE(opcode) ||
; 4837 :             IS_CCW_READ(opcode)  ||

  0110e	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  01112	83 e0 03	 and	 eax, 3
  01115	83 f8 01	 cmp	 eax, 1
  01118	74 18		 je	 SHORT $LN83@s390_execu
  0111a	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  0111e	83 e0 03	 and	 eax, 3
  01121	83 f8 02	 cmp	 eax, 2
  01124	74 0c		 je	 SHORT $LN83@s390_execu
  01126	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  0112a	83 e0 0f	 and	 eax, 15
  0112d	83 f8 0c	 cmp	 eax, 12
  01130	75 06		 jne	 SHORT $LN82@s390_execu
$LN83@s390_execu:

; 4838 :             IS_CCW_RDBACK(opcode))
; 4839 :             ticback = 0;

  01132	33 c0		 xor	 eax, eax
  01134	66 89 45 50	 mov	 WORD PTR ticback$[rbp], ax
$LN82@s390_execu:

; 4840 : 
; 4841 :         /* At this point, the CCW now has "control" of the I/O       */
; 4842 :         /* operation (SA22-7201 p. 15-24, PCI). Signal I/O interrupt */
; 4843 :         /* if PCI flag is set                                        */
; 4844 :         if (flags & CCW_FLAGS_PCI)   /* -- Debug && !prefetch.seq -- */

  01138	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  0113c	83 e0 08	 and	 eax, 8
  0113f	85 c0		 test	 eax, eax
  01141	74 16		 je	 SHORT $LN84@s390_execu

; 4845 :         {
; 4846 :             ARCH_DEP(raise_pci) (dev, ccwkey, ccwfmt, ccwaddr);

  01143	44 8b 4d 20	 mov	 r9d, DWORD PTR ccwaddr$[rbp]
  01147	44 0f b6 45 0b	 movzx	 r8d, BYTE PTR ccwfmt$[rbp]
  0114c	0f b6 55 14	 movzx	 edx, BYTE PTR ccwkey$[rbp]
  01150	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01154	e8 00 00 00 00	 call	 s390_raise_pci
$LN84@s390_execu:

; 4847 :         }
; 4848 : 
; 4849 :         /* Validate basic CCW command                                */
; 4850 :         /* SA22-7201-05:                                             */
; 4851 :         /*  p. 15-25, Figure 15-5. Command Code Assignment           */
; 4852 :         /* Note: TIC validation not included as TIC has already been */
; 4853 :         /*       validated and processed.                            */
; 4854 :         if (!(dev->chained & CCW_FLAGS_CD) &&

  01159	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0115d	0f b6 80 78 02
	00 00		 movzx	 eax, BYTE PTR [rax+632]
  01164	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01169	85 c0		 test	 eax, eax
  0116b	75 5e		 jne	 SHORT $LN85@s390_execu
  0116d	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  01171	83 e0 0f	 and	 eax, 15
  01174	85 c0		 test	 eax, eax
  01176	74 3c		 je	 SHORT $LN86@s390_execu
  01178	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  0117c	83 e0 03	 and	 eax, 3
  0117f	83 f8 01	 cmp	 eax, 1
  01182	74 47		 je	 SHORT $LN85@s390_execu
  01184	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  01188	83 e0 03	 and	 eax, 3
  0118b	83 f8 02	 cmp	 eax, 2
  0118e	74 3b		 je	 SHORT $LN85@s390_execu
  01190	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  01194	83 e0 0f	 and	 eax, 15
  01197	83 f8 0c	 cmp	 eax, 12
  0119a	74 2f		 je	 SHORT $LN85@s390_execu
  0119c	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  011a0	83 e0 03	 and	 eax, 3
  011a3	83 f8 03	 cmp	 eax, 3
  011a6	74 23		 je	 SHORT $LN85@s390_execu
  011a8	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  011ac	83 e0 0f	 and	 eax, 15
  011af	83 f8 04	 cmp	 eax, 4
  011b2	74 17		 je	 SHORT $LN85@s390_execu
$LN86@s390_execu:

; 4855 :             !((opcode & 0x0F) != 0      &&
; 4856 :               (IS_CCW_WRITE(opcode)   ||
; 4857 :                IS_CCW_READ(opcode)    ||
; 4858 :                IS_CCW_RDBACK(opcode)  ||
; 4859 :                IS_CCW_CONTROL(opcode) ||
; 4860 :                IS_CCW_SENSE(opcode))))
; 4861 :         {
; 4862 :             chanstat = CSW_PROGC;

  011b4	c6 45 09 20	 mov	 BYTE PTR chanstat$[rbp], 32 ; 00000020H

; 4863 :             if (prefetch.seq)

  011b8	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  011bf	74 05		 je	 SHORT $LN87@s390_execu

; 4864 :                 goto prefetch;

  011c1	e9 a8 0c 00 00	 jmp	 $prefetch$328
$LN87@s390_execu:

; 4865 :             goto breakchain;

  011c6	e9 65 14 00 00	 jmp	 $breakchain$327
$LN85@s390_execu:

; 4866 :         }
; 4867 : 
; 4868 :         /* Validate chain data (CD) flag                             */
; 4869 :         /* SA22-7201-05:                                             */
; 4870 :         /*  p. 16-26, program check if suspend specified             */
; 4871 :         /*  p. 15-24, Chain-Data (CD) Flag                           */
; 4872 :         if (flags & CCW_FLAGS_CD)

  011cb	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  011cf	25 80 00 00 00	 and	 eax, 128		; 00000080H
  011d4	85 c0		 test	 eax, eax
  011d6	74 2c		 je	 SHORT $LN88@s390_execu

; 4873 :         {
; 4874 :             if (flags & CCW_FLAGS_SUSP)

  011d8	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  011dc	83 e0 02	 and	 eax, 2
  011df	85 c0		 test	 eax, eax
  011e1	74 17		 je	 SHORT $LN89@s390_execu

; 4875 :             {
; 4876 :                 chanstat = CSW_PROGC;

  011e3	c6 45 09 20	 mov	 BYTE PTR chanstat$[rbp], 32 ; 00000020H

; 4877 :                 if (prefetch.seq)

  011e7	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  011ee	74 05		 je	 SHORT $LN90@s390_execu

; 4878 :                     goto prefetch;

  011f0	e9 79 0c 00 00	 jmp	 $prefetch$328
$LN90@s390_execu:

; 4879 :                 goto breakchain;

  011f5	e9 36 14 00 00	 jmp	 $breakchain$327
$LN89@s390_execu:

; 4880 :             }
; 4881 : 
; 4882 :             /* Turn off suppress indicator bits for processing       */
; 4883 :             /* purposes as setting is ignored with CD.               */
; 4884 :             flags &= ~CCW_FLAGS_SLI;

  011fa	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  011fe	83 e0 df	 and	 eax, -33		; ffffffffffffffdfH
  01201	88 45 08	 mov	 BYTE PTR flags$[rbp], al
$LN88@s390_execu:

; 4885 :         }
; 4886 : 
; 4887 :         /* Validate command chain (CC) flag                          */
; 4888 :         /* SA22-7201-05:                                             */
; 4889 :         /*  p. 15-24, Chain-Command (CC) Flag                        */
; 4890 :         /*-------------------------------------------------------------
; 4891 :         //
; 4892 :         // Note: With CD check first, this test will always be false.
; 4893 :         //       Code left here in comment for documentation purposes.
; 4894 :         //
; 4895 :         // if (flags & (CCW_FLAGS_CC | CCW_FLAGS_CD) ==
; 4896 :         //             (CCW_FLAGS_CC | CCW_FLAGS_CD))
; 4897 :         //     flags &= ~CCW_FLAGS_CC;
; 4898 :         -------------------------------------------------------------*/
; 4899 : 
; 4900 :         /* Validate suppress length indication (SLI) flag            */
; 4901 :         /* SA22-7201-05:                                             */
; 4902 :         /*  p. 15-24, Supress-Length-Indication (SLI) Flag           */
; 4903 :         /*-------------------------------------------------------------
; 4904 :         //
; 4905 :         // Note: With CD check first, this test will always be false.
; 4906 :         //       Code left here in comment for documentation purposes.
; 4907 :         //
; 4908 :         // if (flags & (CCW_FLAGS_CD | CCW_FLAGS_SLI)) ==
; 4909 :         //             (CCW_FLAGS_CD | CCW_FLAGS_SLI)))
; 4910 :         //     flags &= ~CCW_FLAGS_SLI;
; 4911 :         -------------------------------------------------------------*/
; 4912 : 
; 4913 :         /* Validate skip flag                                        */
; 4914 :         /* SA22-7201-05:                                             */
; 4915 :         /*  p. 15-24, Skip (SKIP) Flag                               */
; 4916 :         /*-------------------------------------------------------------
; 4917 :         //
; 4918 :         // Note: Check against MIDAW down in MIDAW validation section.
; 4919 :         //       Code left here in comment for documentation purposes.
; 4920 :         //
; 4921 :         // if (flags & CCW_FLAGS_SKIP)
; 4922 :         // {}
; 4923 :         -------------------------------------------------------------*/
; 4924 : 
; 4925 :         /* Validate program controlled interruption (PCI) flag       */
; 4926 :         /* SA22-7201-05:                                             */
; 4927 :         /*  p. 15-24, Program Controlled Interruption (PCI) Flag     */
; 4928 :         /*-------------------------------------------------------------
; 4929 :         //
; 4930 :         // Note: No validation required.
; 4931 :         //       Code left here in comment for documentation purposes.
; 4932 :         //
; 4933 :         // if (flags & CCW_FLAGS_PCI)
; 4934 :         // {}
; 4935 :         -------------------------------------------------------------*/
; 4936 : 
; 4937 : #if !defined(FEATURE_MIDAW_FACILITY)
; 4938 :         /* Channel program check if MIDAW not installed */
; 4939 :         if (flags & CCW_FLAGS_MIDAW)

  01204	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  01208	83 e0 01	 and	 eax, 1
  0120b	85 c0		 test	 eax, eax
  0120d	74 17		 je	 SHORT $LN91@s390_execu

; 4940 :         {
; 4941 :             chanstat = CSW_PROGC;

  0120f	c6 45 09 20	 mov	 BYTE PTR chanstat$[rbp], 32 ; 00000020H

; 4942 :             if (prefetch.seq)

  01213	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  0121a	74 05		 je	 SHORT $LN92@s390_execu

; 4943 :                 goto prefetch;

  0121c	e9 4d 0c 00 00	 jmp	 $prefetch$328
$LN92@s390_execu:

; 4944 :             goto breakchain;

  01221	e9 0a 14 00 00	 jmp	 $breakchain$327
$LN91@s390_execu:

; 4945 :         }
; 4946 : #endif /*!defined(FEATURE_MIDAW_FACILITY)*/
; 4947 : 
; 4948 : #if defined(FEATURE_MIDAW_FACILITY)
; 4949 :         /* Channel program check if MIDAW not enabled in ORB, or     */
; 4950 :         /* with SKIP or IDA specified                                */
; 4951 :         if ((flags & CCW_FLAGS_MIDAW) &&
; 4952 :             ((dev->orb.flag7 & ORB7_D) == 0 ||
; 4953 :              (flags & (CCW_FLAGS_SKIP | CCW_FLAGS_IDA))))
; 4954 :         {
; 4955 :             chanstat = CSW_PROGC;
; 4956 :             if (prefetch.seq)
; 4957 :                 goto prefetch;
; 4958 :             goto breakchain;
; 4959 :         }
; 4960 : #endif /*defined(FEATURE_MIDAW_FACILITY)*/
; 4961 : 
; 4962 :         /* Suspend supported prior to GA22-7000-10 for the S/370     */
; 4963 :         /* Suspend channel program if suspend flag is set */
; 4964 :         if (flags & CCW_FLAGS_SUSP)

  01226	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  0122a	83 e0 02	 and	 eax, 2
  0122d	85 c0		 test	 eax, eax
  0122f	0f 84 2b 04 00
	00		 je	 $LN93@s390_execu

; 4965 :         {
; 4966 :             /* Channel program check if the ORB suspend control bit
; 4967 :                was zero, or if this is a data chained CCW */
; 4968 :             if ((dev->orb.flag4 & ORB4_S) == 0
; 4969 :                 || (dev->chained & CCW_FLAGS_CD))

  01235	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01239	0f b6 80 d0 02
	00 00		 movzx	 eax, BYTE PTR [rax+720]
  01240	83 e0 08	 and	 eax, 8
  01243	85 c0		 test	 eax, eax
  01245	74 14		 je	 SHORT $LN95@s390_execu
  01247	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0124b	0f b6 80 78 02
	00 00		 movzx	 eax, BYTE PTR [rax+632]
  01252	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01257	85 c0		 test	 eax, eax
  01259	74 17		 je	 SHORT $LN94@s390_execu
$LN95@s390_execu:

; 4970 :             {
; 4971 :                 chanstat = CSW_PROGC;

  0125b	c6 45 09 20	 mov	 BYTE PTR chanstat$[rbp], 32 ; 00000020H

; 4972 :                 if (prefetch.seq)

  0125f	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  01266	74 05		 je	 SHORT $LN96@s390_execu

; 4973 :                     goto prefetch;

  01268	e9 01 0c 00 00	 jmp	 $prefetch$328
$LN96@s390_execu:

; 4974 :                 goto breakchain;

  0126d	e9 be 13 00 00	 jmp	 $breakchain$327
$LN94@s390_execu:
$LN12@s390_execu:

; 4975 :             }
; 4976 : 
; 4977 :             IODELAY(dev);

  01272	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01279	83 b8 e0 13 00
	00 00		 cmp	 DWORD PTR [rax+5088], 0
  01280	7e 2d		 jle	 SHORT $LN97@s390_execu
  01282	b8 01 00 00 00	 mov	 eax, 1
  01287	48 6b c0 0a	 imul	 rax, rax, 10
  0128b	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0128f	0f b6 84 01 6c
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1388]
  01297	83 f8 20	 cmp	 eax, 32			; 00000020H
  0129a	75 13		 jne	 SHORT $LN97@s390_execu
  0129c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  012a3	8b 88 e0 13 00
	00		 mov	 ecx, DWORD PTR [rax+5088]
  012a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN97@s390_execu:
  012af	33 c0		 xor	 eax, eax
  012b1	85 c0		 test	 eax, eax
  012b3	75 bd		 jne	 SHORT $LN12@s390_execu

; 4978 : 
; 4979 :             /* If halt or clear, abort suspend operation */
; 4980 :             if (dev->scsw.flag2 & (SCSW2_AC_HALT | SCSW2_AC_CLEAR))

  012b5	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  012b9	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  012c0	83 e0 03	 and	 eax, 3
  012c3	85 c0		 test	 eax, eax
  012c5	74 1c		 je	 SHORT $LN98@s390_execu

; 4981 :             {
; 4982 :                 if (dev->scsw.flag2 & SCSW2_AC_HALT)

  012c7	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  012cb	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  012d2	83 e0 02	 and	 eax, 2
  012d5	85 c0		 test	 eax, eax
  012d7	74 05		 je	 SHORT $LN99@s390_execu

; 4983 :                     goto execute_halt;

  012d9	e9 26 f8 ff ff	 jmp	 $execute_halt$325
$LN99@s390_execu:

; 4984 :                 goto execute_clear;

  012de	e9 37 f7 ff ff	 jmp	 $execute_clear$324
$LN98@s390_execu:

; 4985 :             }
; 4986 : 
; 4987 :             /* Call the i/o suspend exit */
; 4988 :             if (dev->hnd->suspend) (dev->hnd->suspend) (dev);

  012e3	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  012e7	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  012ee	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  012f3	74 12		 je	 SHORT $LN100@s390_execu
  012f5	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  012f9	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  01300	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01304	ff 50 40	 call	 QWORD PTR [rax+64]
$LN100@s390_execu:

; 4989 : 
; 4990 :             OBTAIN_INTLOCK(NULL);

  01307	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182638
  0130e	33 c9		 xor	 ecx, ecx
  01310	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 4991 :             obtain_lock (&dev->lock);

  01315	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01319	48 83 c0 38	 add	 rax, 56			; 00000038H
  0131d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182639
  01324	48 8b c8	 mov	 rcx, rax
  01327	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4992 : 
; 4993 :             /* Suspend the device if not already resume pending */
; 4994 :             if (!(dev->scsw.flag2 & (SCSW2_AC_RESUM)))

  0132d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01331	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  01338	83 e0 08	 and	 eax, 8
  0133b	85 c0		 test	 eax, eax
  0133d	0f 85 f7 02 00
	00		 jne	 $LN101@s390_execu

; 4995 :             {
; 4996 :                 /* Clean up device and complete suspension exit */
; 4997 :                 clear_subchannel_busy(dev);

  01343	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01347	e8 00 00 00 00	 call	 clear_subchannel_busy

; 4998 : 
; 4999 :                 /* Set the subchannel status word to suspended       */
; 5000 :                 /* SA22-7201-05:                                     */
; 5001 :                 /*  p. 16-15, Subchannel-Active (Bit 24)             */
; 5002 :                 /*  pp. 16-15 -- 16-16, Device-Active (Bit 25)       */
; 5003 :                 /*  p. 16-16, Suspended (Bit 26)                     */
; 5004 :                 /*  p. 16-16, Alert Status (Bit 27)                  */
; 5005 :                 /*  p. 16-17, Intermediate Status (Bit 28)           */
; 5006 :                 /*  p. 16-18, Status-Pending (Bit 31)                */
; 5007 :                 dev->scsw.flag3 &= ~(SCSW3_AC_SCHAC |

  0134c	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01350	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  01357	25 3f ff ff ff	 and	 eax, -193		; ffffffffffffff3fH
  0135c	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01360	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 5008 :                                      SCSW3_AC_DEVAC);
; 5009 :                 dev->scsw.flag3 |= SCSW3_AC_SUSP;

  01366	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0136a	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  01371	83 c8 20	 or	 eax, 32			; 00000020H
  01374	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01378	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 5010 :                 /* Principles violation. Some operating systems use
; 5011 :                  * CLI to check for suspend, intermediate and pending
; 5012 :                  * status (x'29') instead of the Principles statement
; 5013 :                  * with alert status set (x'39'). This also appears to
; 5014 :                  * be consistent with older machines.
; 5015 :                  * FIXME: Place conformance in user configuration?
; 5016 :                  *        flag3 |= SCSW3_SC_ALERT;
; 5017 :                  */
; 5018 : 
; 5019 :                 dev->scsw.unitstat = 0;

  0137e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01382	c6 80 10 03 00
	00 00		 mov	 BYTE PTR [rax+784], 0

; 5020 : 
; 5021 :                 if (flags & CCW_FLAGS_PCI)

  01389	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  0138d	83 e0 08	 and	 eax, 8
  01390	85 c0		 test	 eax, eax
  01392	74 3d		 je	 SHORT $LN102@s390_execu

; 5022 :                 {
; 5023 :                     dev->scsw.chanstat   = CSW_PCI;

  01394	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01398	c6 80 11 03 00
	00 80		 mov	 BYTE PTR [rax+785], 128	; 00000080H

; 5024 :                     dev->scsw.flag3     |= SCSW3_SC_INTER   |

  0139f	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  013a3	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  013aa	83 c8 09	 or	 eax, 9
  013ad	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  013b1	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 5025 :                                            SCSW3_SC_PEND;
; 5026 :                     dev->pciscsw.flag3  &= ~SCSW3_SC_PEND;

  013b7	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  013bb	0f b6 80 17 03
	00 00		 movzx	 eax, BYTE PTR [rax+791]
  013c2	83 e0 fe	 and	 eax, -2
  013c5	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  013c9	88 81 17 03 00
	00		 mov	 BYTE PTR [rcx+791], al

; 5027 :                 }

  013cf	eb 35		 jmp	 SHORT $LN103@s390_execu
$LN102@s390_execu:

; 5028 :                 else
; 5029 :                 {
; 5030 :                     dev->scsw.chanstat   = 0;

  013d1	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  013d5	c6 80 11 03 00
	00 00		 mov	 BYTE PTR [rax+785], 0

; 5031 :                     if (!(dev->scsw.flag1 & SCSW1_U))

  013dc	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  013e0	0f b6 80 09 03
	00 00		 movzx	 eax, BYTE PTR [rax+777]
  013e7	83 e0 08	 and	 eax, 8
  013ea	85 c0		 test	 eax, eax
  013ec	75 18		 jne	 SHORT $LN104@s390_execu

; 5032 :                         dev->scsw.flag3 |= SCSW3_SC_INTER   |

  013ee	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  013f2	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  013f9	83 c8 09	 or	 eax, 9
  013fc	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01400	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al
$LN104@s390_execu:
$LN103@s390_execu:

; 5033 :                                            SCSW3_SC_PEND;
; 5034 :                 }
; 5035 : 
; 5036 :                 STORE_HW(dev->scsw.count,count);

  01406	0f b7 4d 18	 movzx	 ecx, WORD PTR count$[rbp]
  0140a	e8 00 00 00 00	 call	 _byteswap_ushort
  0140f	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01413	48 81 c1 12 03
	00 00		 add	 rcx, 786		; 00000312H
  0141a	0f b7 d0	 movzx	 edx, ax
  0141d	e8 00 00 00 00	 call	 store_hw_noswap

; 5037 : 
; 5038 :                 /* Update local copy of ORB */
; 5039 :                 STORE_FW(dev->orb.ccwaddr, (ccwaddr-8));

  01422	8b 45 20	 mov	 eax, DWORD PTR ccwaddr$[rbp]
  01425	83 e8 08	 sub	 eax, 8
  01428	8b c8		 mov	 ecx, eax
  0142a	e8 00 00 00 00	 call	 _byteswap_ulong
  0142f	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01433	48 81 c1 d4 02
	00 00		 add	 rcx, 724		; 000002d4H
  0143a	8b d0		 mov	 edx, eax
  0143c	e8 00 00 00 00	 call	 store_fw_noswap

; 5040 : 
; 5041 :                 /* Preserve CCW execution variables for validation */
; 5042 :                 dev->ccwaddr = ccwaddr;

  01441	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01445	8b 4d 20	 mov	 ecx, DWORD PTR ccwaddr$[rbp]
  01448	89 88 80 02 00
	00		 mov	 DWORD PTR [rax+640], ecx

; 5043 :                 dev->idapmask = idapmask;

  0144e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01452	0f b7 4d 44	 movzx	 ecx, WORD PTR idapmask$[rbp]
  01456	66 89 88 84 02
	00 00		 mov	 WORD PTR [rax+644], cx

; 5044 :                 dev->idawfmt = idawfmt;

  0145d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01461	0f b6 4d 16	 movzx	 ecx, BYTE PTR idawfmt$[rbp]
  01465	88 88 86 02 00
	00		 mov	 BYTE PTR [rax+646], cl

; 5045 :                 dev->ccwfmt = ccwfmt;

  0146b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0146f	0f b6 4d 0b	 movzx	 ecx, BYTE PTR ccwfmt$[rbp]
  01473	88 88 87 02 00
	00		 mov	 BYTE PTR [rax+647], cl

; 5046 :                 dev->ccwkey = ccwkey;

  01479	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0147d	0f b6 4d 14	 movzx	 ecx, BYTE PTR ccwkey$[rbp]
  01481	88 88 88 02 00
	00		 mov	 BYTE PTR [rax+648], cl

; 5047 : 
; 5048 :                 /* Turn on the "suspended" bit.  This enables remote
; 5049 :                  * systems to use the device while we're waiting
; 5050 :                  */
; 5051 :                 dev->suspended = 1;

  01487	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0148b	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01491	0f ba e8 15	 bts	 eax, 21
  01495	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01499	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 5052 : 
; 5053 :                 /* Trace suspension point */
; 5054 :                 if (unlikely( CCW_TRACING_ACTIVE( dev, tracethis )))

  0149f	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  014a3	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  014a9	c1 e8 0f	 shr	 eax, 15
  014ac	83 e0 01	 and	 eax, 1
  014af	85 c0		 test	 eax, eax
  014b1	75 14		 jne	 SHORT $LN263@s390_execu
  014b3	0f b6 45 15	 movzx	 eax, BYTE PTR tracethis$[rbp]
  014b7	85 c0		 test	 eax, eax
  014b9	75 0c		 jne	 SHORT $LN263@s390_execu
  014bb	c7 85 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv925[rbp], 0
  014c5	eb 0a		 jmp	 SHORT $LN266@s390_execu
$LN263@s390_execu:
  014c7	c7 85 b0 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv925[rbp], 1
$LN266@s390_execu:
  014d1	83 bd b0 00 00
	00 00		 cmp	 DWORD PTR tv925[rbp], 0
  014d8	0f 84 d3 00 00
	00		 je	 $LN105@s390_execu

; 5055 :                 {
; 5056 :                     if (dev->ccwtrace && sysblk.traceFILE)

  014de	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  014e2	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  014e8	c1 e8 0f	 shr	 eax, 15
  014eb	83 e0 01	 and	 eax, 1
  014ee	85 c0		 test	 eax, eax
  014f0	74 20		 je	 SHORT $LN106@s390_execu
  014f2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  014f9	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  01501	74 0f		 je	 SHORT $LN106@s390_execu

; 5057 :                         tf_1310( dev );

  01503	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01507	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1310
  0150d	e9 9f 00 00 00	 jmp	 $LN107@s390_execu
$LN106@s390_execu:

; 5058 :                     else
; 5059 :                         // "%1d:%04X CHAN: suspended"
; 5060 :                         WRMSG( HHC01310, "I", LCSS_DEVNUM );

  01512	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  01517	74 10		 je	 SHORT $LN267@s390_execu
  01519	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0151d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01521	89 85 b4 00 00
	00		 mov	 DWORD PTR tv937[rbp], eax
  01527	eb 0a		 jmp	 SHORT $LN268@s390_execu
$LN267@s390_execu:
  01529	c7 85 b4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv937[rbp], 0
$LN268@s390_execu:
  01533	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  01538	74 12		 je	 SHORT $LN269@s390_execu
  0153a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0153e	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01542	d1 f8		 sar	 eax, 1
  01544	89 85 b8 00 00
	00		 mov	 DWORD PTR tv943[rbp], eax
  0154a	eb 0a		 jmp	 SHORT $LN270@s390_execu
$LN269@s390_execu:
  0154c	c7 85 b8 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv943[rbp], 0
$LN270@s390_execu:
  01556	b9 01 00 00 00	 mov	 ecx, 1
  0155b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01561	8b 8d b4 00 00
	00		 mov	 ecx, DWORD PTR tv937[rbp]
  01567	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0156b	8b 8d b8 00 00
	00		 mov	 ecx, DWORD PTR tv943[rbp]
  01571	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01575	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182647
  0157c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01581	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182648
  01588	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0158d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01592	41 b9 03 00 00
	00		 mov	 r9d, 3
  01598	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG182649
  0159f	ba c4 13 00 00	 mov	 edx, 5060		; 000013c4H
  015a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182650
  015ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN107@s390_execu:
$LN105@s390_execu:

; 5061 :                 }
; 5062 : 
; 5063 :                 /* Present the interrupt and return */
; 5064 :                 if (dev->scsw.flag3 & SCSW3_SC_PEND)

  015b1	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  015b5	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  015bc	83 e0 01	 and	 eax, 1
  015bf	85 c0		 test	 eax, eax
  015c1	74 0b		 je	 SHORT $LN108@s390_execu

; 5065 :                     queue_io_interrupt_and_update_status_locked(dev,FALSE);

  015c3	33 d2		 xor	 edx, edx
  015c5	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  015c9	e8 00 00 00 00	 call	 queue_io_interrupt_and_update_status_locked
$LN108@s390_execu:

; 5066 : 
; 5067 :                 release_lock(&dev->lock);

  015ce	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  015d2	48 83 c0 38	 add	 rax, 56			; 00000038H
  015d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182652
  015dd	48 8b c8	 mov	 rcx, rax
  015e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5068 :                 RELEASE_INTLOCK(NULL);

  015e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182653
  015ed	33 c9		 xor	 ecx, ecx
  015ef	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 5069 : 
; 5070 :                 if (dev->scsw.flag2 & (SCSW2_AC_CLEAR | SCSW2_AC_HALT))

  015f4	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  015f8	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  015ff	83 e0 03	 and	 eax, 3
  01602	85 c0		 test	 eax, eax
  01604	74 1c		 je	 SHORT $LN109@s390_execu

; 5071 :                 {
; 5072 :                     if (dev->scsw.flag2 & SCSW2_AC_CLEAR)

  01606	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0160a	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  01611	83 e0 01	 and	 eax, 1
  01614	85 c0		 test	 eax, eax
  01616	74 05		 je	 SHORT $LN110@s390_execu

; 5073 :                         goto execute_clear;

  01618	e9 fd f3 ff ff	 jmp	 $execute_clear$324
$LN110@s390_execu:

; 5074 :                     goto execute_halt;

  0161d	e9 e2 f4 ff ff	 jmp	 $execute_halt$325
$LN109@s390_execu:

; 5075 :                 }
; 5076 : 
; 5077 :                 return execute_ccw_chain_fast_return( iobuf, &iobuf_initial, NULL );

  01622	45 33 c0	 xor	 r8d, r8d
  01625	48 8d 95 00 20
	00 00		 lea	 rdx, QWORD PTR iobuf_initial$[rbp]
  0162c	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  01630	e8 00 00 00 00	 call	 execute_ccw_chain_fast_return
  01635	e9 0a 21 00 00	 jmp	 $LN1@s390_execu
$LN101@s390_execu:

; 5078 :             }
; 5079 : 
; 5080 :             release_lock (&dev->lock);

  0163a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0163e	48 83 c0 38	 add	 rax, 56			; 00000038H
  01642	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182656
  01649	48 8b c8	 mov	 rcx, rax
  0164c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5081 :             RELEASE_INTLOCK(NULL);

  01652	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182657
  01659	33 c9		 xor	 ecx, ecx
  0165b	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN93@s390_execu:

; 5082 : 
; 5083 :         } /* end if(CCW_FLAGS_SUSP) */
; 5084 : 
; 5085 :         /* Update current CCW opcode, unless data chaining */
; 5086 :         if (!(skip_ccws ||

  01660	83 7d 64 00	 cmp	 DWORD PTR skip_ccws$[rbp], 0
  01664	75 51		 jne	 SHORT $LN111@s390_execu
  01666	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0166a	0f b6 80 78 02
	00 00		 movzx	 eax, BYTE PTR [rax+632]
  01671	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01676	85 c0		 test	 eax, eax
  01678	75 3d		 jne	 SHORT $LN111@s390_execu

; 5087 :               (dev->chained & CCW_FLAGS_CD)))
; 5088 :         {
; 5089 :             dev->prevcode = dev->code;

  0167a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0167e	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01682	0f b6 89 7a 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+634]
  01689	88 88 7b 02 00
	00		 mov	 BYTE PTR [rax+635], cl

; 5090 :             dev->code = opcode;

  0168f	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01693	0f b6 4d 0a	 movzx	 ecx, BYTE PTR opcode$[rbp]
  01697	88 88 7a 02 00
	00		 mov	 BYTE PTR [rax+634], cl

; 5091 : 
; 5092 :             /* Allow the device handler to determine whether this is
; 5093 :                an immediate CCW (i.e. CONTROL with no data transfer) */
; 5094 :             dev->is_immed = IS_CCW_IMMEDIATE(dev, opcode);

  0169d	0f b6 55 0a	 movzx	 edx, BYTE PTR opcode$[rbp]
  016a1	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  016a5	e8 00 00 00 00	 call	 IS_CCW_IMMEDIATE
  016aa	0f b6 c0	 movzx	 eax, al
  016ad	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  016b1	89 81 a0 02 00
	00		 mov	 DWORD PTR [rcx+672], eax
$LN111@s390_execu:

; 5095 : 
; 5096 :             /*-- TBD ------------------------------------------------*/
; 5097 :             /*                                                       */
; 5098 :             /*   Initiation and check of opcode with control unit    */
; 5099 :             /*   belongs here.                                       */
; 5100 :             /*                                                       */
; 5101 :             /*-------------------------------------------------------*/
; 5102 : 
; 5103 :         }
; 5104 : 
; 5105 :         /* If immediate, chain data and address are ignored */
; 5106 :         if (dev->is_immed)

  016b7	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  016bb	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  016c2	74 2b		 je	 SHORT $LN112@s390_execu

; 5107 :         {
; 5108 :             flags &= ~CCW_FLAGS_CD;

  016c4	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  016c8	0f ba f0 07	 btr	 eax, 7
  016cc	88 45 08	 mov	 BYTE PTR flags$[rbp], al

; 5109 :             dev->chained &= ~CCW_FLAGS_CD;

  016cf	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  016d3	0f b6 80 78 02
	00 00		 movzx	 eax, BYTE PTR [rax+632]
  016da	0f ba f0 07	 btr	 eax, 7
  016de	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  016e2	88 81 78 02 00
	00		 mov	 BYTE PTR [rcx+632], al

; 5110 :             addr = 0;

  016e8	c7 45 24 00 00
	00 00		 mov	 DWORD PTR addr$[rbp], 0
$LN112@s390_execu:

; 5111 :         }
; 5112 : 
; 5113 :         /* Channel program check if CCW refers to invalid storage    */
; 5114 :         /* SA22-7201-05:                                             */
; 5115 :         /*  p. 15-24, Data Address                                   */
; 5116 :         /*  p. 15-25, Count                                          */
; 5117 :         /*  pp. 15-25 -- 15-27, Designation of Storage Area          */
; 5118 :         if ((count &&
; 5119 :              (!(flags & CCW_FLAGS_SKIP)) &&
; 5120 :              (((flags & CCW_FLAGS_IDA)   &&
; 5121 :                ((addr & 0x03) ||
; 5122 :                 CHADDRCHK(addr, dev)))                      ||
; 5123 : #if defined(FEATURE_MIDAW_FACILITY)
; 5124 :               ((flags & CCW_FLAGS_MIDAW) &&
; 5125 :                ((addr & 0x0F) ||
; 5126 :                 CHADDRCHK(addr, dev)))                      ||
; 5127 : #endif /*defined(FEATURE_MIDAW_FACILITY)*/
; 5128 :               (!(flags & (CCW_FLAGS_IDA | CCW_FLAGS_MIDAW))     &&
; 5129 :                ((ccwfmt == 0 &&
; 5130 :                  ((addr & ~0x00FFFFFF)                      ||
; 5131 :                   ((addr + (count - 1)) & ~0x00FFFFFF)      ||
; 5132 :                   CHADDRCHK((addr + (count - 1)), dev)))    ||
; 5133 : #if defined(FEATURE_CHANNEL_SUBSYSTEM)
; 5134 :                 (ccwfmt == 1 &&
; 5135 :                  ((addr & ~0x7FFFFFFF)                      ||
; 5136 :                   ((addr + count - 1) & ~0x7FFFFFFF)        ||
; 5137 :                   CHADDRCHK((addr + (count - 1)), dev)))        ||
; 5138 : #endif /*defined(FEATURE_CHANNEL_SUBSYSTEM)*/
; 5139 :                  CHADDRCHK(addr, dev)))))
; 5140 : #if defined(FEATURE_CHANNEL_SUBSYSTEM)
; 5141 :          || (!count &&

  016ef	83 7d 18 00	 cmp	 DWORD PTR count$[rbp], 0
  016f3	0f 84 ac 02 00
	00		 je	 $LN115@s390_execu
  016f9	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  016fd	83 e0 10	 and	 eax, 16
  01700	85 c0		 test	 eax, eax
  01702	0f 85 9d 02 00
	00		 jne	 $LN115@s390_execu
  01708	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  0170c	83 e0 04	 and	 eax, 4
  0170f	85 c0		 test	 eax, eax
  01711	0f 84 86 00 00
	00		 je	 $LN116@s390_execu
  01717	8b 45 24	 mov	 eax, DWORD PTR addr$[rbp]
  0171a	83 e0 03	 and	 eax, 3
  0171d	85 c0		 test	 eax, eax
  0171f	0f 85 9c 02 00
	00		 jne	 $LN114@s390_execu
  01725	8b 45 24	 mov	 eax, DWORD PTR addr$[rbp]
  01728	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0172c	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  01733	0f 87 88 02 00
	00		 ja	 $LN114@s390_execu
  01739	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0173d	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  01744	83 e0 10	 and	 eax, 16
  01747	85 c0		 test	 eax, eax
  01749	74 52		 je	 SHORT $LN117@s390_execu
  0174b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0174f	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  01756	83 e0 20	 and	 eax, 32			; 00000020H
  01759	85 c0		 test	 eax, eax
  0175b	74 17		 je	 SHORT $LN118@s390_execu
  0175d	8b 45 24	 mov	 eax, DWORD PTR addr$[rbp]
  01760	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01767	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  0176e	0f 82 4d 02 00
	00		 jb	 $LN114@s390_execu
$LN118@s390_execu:
  01774	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01778	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0177f	83 e0 40	 and	 eax, 64			; 00000040H
  01782	85 c0		 test	 eax, eax
  01784	74 17		 je	 SHORT $LN119@s390_execu
  01786	8b 45 24	 mov	 eax, DWORD PTR addr$[rbp]
  01789	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01790	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  01797	0f 83 24 02 00
	00		 jae	 $LN114@s390_execu
$LN119@s390_execu:
$LN117@s390_execu:
$LN116@s390_execu:
  0179d	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  017a1	83 e0 05	 and	 eax, 5
  017a4	85 c0		 test	 eax, eax
  017a6	0f 85 f9 01 00
	00		 jne	 $LN120@s390_execu
  017ac	0f b6 45 0b	 movzx	 eax, BYTE PTR ccwfmt$[rbp]
  017b0	85 c0		 test	 eax, eax
  017b2	0f 85 ba 00 00
	00		 jne	 $LN121@s390_execu
  017b8	8b 45 24	 mov	 eax, DWORD PTR addr$[rbp]
  017bb	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  017c0	85 c0		 test	 eax, eax
  017c2	0f 85 f9 01 00
	00		 jne	 $LN114@s390_execu
  017c8	8b 45 24	 mov	 eax, DWORD PTR addr$[rbp]
  017cb	8b 4d 18	 mov	 ecx, DWORD PTR count$[rbp]
  017ce	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  017d2	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  017d7	85 c0		 test	 eax, eax
  017d9	0f 85 e2 01 00
	00		 jne	 $LN114@s390_execu
  017df	8b 45 24	 mov	 eax, DWORD PTR addr$[rbp]
  017e2	8b 4d 18	 mov	 ecx, DWORD PTR count$[rbp]
  017e5	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  017e9	8b c0		 mov	 eax, eax
  017eb	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  017ef	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  017f6	0f 87 c5 01 00
	00		 ja	 $LN114@s390_execu
  017fc	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01800	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  01807	83 e0 10	 and	 eax, 16
  0180a	85 c0		 test	 eax, eax
  0180c	74 64		 je	 SHORT $LN122@s390_execu
  0180e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01812	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  01819	83 e0 20	 and	 eax, 32			; 00000020H
  0181c	85 c0		 test	 eax, eax
  0181e	74 20		 je	 SHORT $LN123@s390_execu
  01820	8b 45 24	 mov	 eax, DWORD PTR addr$[rbp]
  01823	8b 4d 18	 mov	 ecx, DWORD PTR count$[rbp]
  01826	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  0182a	8b c0		 mov	 eax, eax
  0182c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01833	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  0183a	0f 82 81 01 00
	00		 jb	 $LN114@s390_execu
$LN123@s390_execu:
  01840	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01844	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0184b	83 e0 40	 and	 eax, 64			; 00000040H
  0184e	85 c0		 test	 eax, eax
  01850	74 20		 je	 SHORT $LN124@s390_execu
  01852	8b 45 24	 mov	 eax, DWORD PTR addr$[rbp]
  01855	8b 4d 18	 mov	 ecx, DWORD PTR count$[rbp]
  01858	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  0185c	8b c0		 mov	 eax, eax
  0185e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01865	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  0186c	0f 83 4f 01 00
	00		 jae	 $LN114@s390_execu
$LN124@s390_execu:
$LN122@s390_execu:
$LN121@s390_execu:
  01872	0f b6 45 0b	 movzx	 eax, BYTE PTR ccwfmt$[rbp]
  01876	83 f8 01	 cmp	 eax, 1
  01879	0f 85 ba 00 00
	00		 jne	 $LN125@s390_execu
  0187f	8b 45 24	 mov	 eax, DWORD PTR addr$[rbp]
  01882	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  01887	85 c0		 test	 eax, eax
  01889	0f 85 32 01 00
	00		 jne	 $LN114@s390_execu
  0188f	8b 45 24	 mov	 eax, DWORD PTR addr$[rbp]
  01892	8b 4d 18	 mov	 ecx, DWORD PTR count$[rbp]
  01895	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  01899	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0189e	85 c0		 test	 eax, eax
  018a0	0f 85 1b 01 00
	00		 jne	 $LN114@s390_execu
  018a6	8b 45 24	 mov	 eax, DWORD PTR addr$[rbp]
  018a9	8b 4d 18	 mov	 ecx, DWORD PTR count$[rbp]
  018ac	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  018b0	8b c0		 mov	 eax, eax
  018b2	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  018b6	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  018bd	0f 87 fe 00 00
	00		 ja	 $LN114@s390_execu
  018c3	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  018c7	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  018ce	83 e0 10	 and	 eax, 16
  018d1	85 c0		 test	 eax, eax
  018d3	74 64		 je	 SHORT $LN126@s390_execu
  018d5	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  018d9	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  018e0	83 e0 20	 and	 eax, 32			; 00000020H
  018e3	85 c0		 test	 eax, eax
  018e5	74 20		 je	 SHORT $LN127@s390_execu
  018e7	8b 45 24	 mov	 eax, DWORD PTR addr$[rbp]
  018ea	8b 4d 18	 mov	 ecx, DWORD PTR count$[rbp]
  018ed	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  018f1	8b c0		 mov	 eax, eax
  018f3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  018fa	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  01901	0f 82 ba 00 00
	00		 jb	 $LN114@s390_execu
$LN127@s390_execu:
  01907	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0190b	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  01912	83 e0 40	 and	 eax, 64			; 00000040H
  01915	85 c0		 test	 eax, eax
  01917	74 20		 je	 SHORT $LN128@s390_execu
  01919	8b 45 24	 mov	 eax, DWORD PTR addr$[rbp]
  0191c	8b 4d 18	 mov	 ecx, DWORD PTR count$[rbp]
  0191f	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  01923	8b c0		 mov	 eax, eax
  01925	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0192c	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  01933	0f 83 88 00 00
	00		 jae	 $LN114@s390_execu
$LN128@s390_execu:
$LN126@s390_execu:
$LN125@s390_execu:
  01939	8b 45 24	 mov	 eax, DWORD PTR addr$[rbp]
  0193c	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01940	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  01947	77 78		 ja	 SHORT $LN114@s390_execu
  01949	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0194d	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  01954	83 e0 10	 and	 eax, 16
  01957	85 c0		 test	 eax, eax
  01959	74 4a		 je	 SHORT $LN129@s390_execu
  0195b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0195f	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  01966	83 e0 20	 and	 eax, 32			; 00000020H
  01969	85 c0		 test	 eax, eax
  0196b	74 13		 je	 SHORT $LN130@s390_execu
  0196d	8b 45 24	 mov	 eax, DWORD PTR addr$[rbp]
  01970	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01977	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  0197e	72 41		 jb	 SHORT $LN114@s390_execu
$LN130@s390_execu:
  01980	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01984	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0198b	83 e0 40	 and	 eax, 64			; 00000040H
  0198e	85 c0		 test	 eax, eax
  01990	74 13		 je	 SHORT $LN131@s390_execu
  01992	8b 45 24	 mov	 eax, DWORD PTR addr$[rbp]
  01995	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0199c	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  019a3	73 1c		 jae	 SHORT $LN114@s390_execu
$LN131@s390_execu:
$LN129@s390_execu:
$LN120@s390_execu:
$LN115@s390_execu:
  019a5	83 7d 18 00	 cmp	 DWORD PTR count$[rbp], 0
  019a9	75 2d		 jne	 SHORT $LN113@s390_execu
  019ab	0f b6 45 0b	 movzx	 eax, BYTE PTR ccwfmt$[rbp]
  019af	83 f8 01	 cmp	 eax, 1
  019b2	75 24		 jne	 SHORT $LN113@s390_execu
  019b4	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  019b8	25 80 00 00 00	 and	 eax, 128		; 00000080H
  019bd	85 c0		 test	 eax, eax
  019bf	74 17		 je	 SHORT $LN113@s390_execu
$LN114@s390_execu:

; 5142 :              (ccwfmt == 1 && (flags & CCW_FLAGS_CD)))
; 5143 : #endif /*defined(FEATURE_CHANNEL_SUBSYSTEM)*/
; 5144 :             )
; 5145 :         {
; 5146 :             chanstat = CSW_PROGC;

  019c1	c6 45 09 20	 mov	 BYTE PTR chanstat$[rbp], 32 ; 00000020H

; 5147 :             if (prefetch.seq)

  019c5	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  019cc	74 05		 je	 SHORT $LN132@s390_execu

; 5148 :                 goto prefetch;

  019ce	e9 9b 04 00 00	 jmp	 $prefetch$328
$LN132@s390_execu:

; 5149 :             goto breakchain;

  019d3	e9 58 0c 00 00	 jmp	 $breakchain$327
$LN113@s390_execu:

; 5150 :         }
; 5151 : 
; 5152 :         /* Suspend and reschedule I/O at this point if SIO and CPU   */
; 5153 :         /* not yet released; if IDA specified, first IDA must be     */
; 5154 :         /* verified before suspend and reschedule.                   */
; 5155 :         if (dev->s370start)

  019d8	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  019dc	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  019e2	d1 e8		 shr	 eax, 1
  019e4	83 e0 01	 and	 eax, 1
  019e7	85 c0		 test	 eax, eax
  019e9	0f 84 c3 01 00
	00		 je	 $LN133@s390_execu

; 5156 :         {
; 5157 :             /* Note: dev->s370start is reset in resume processing;
; 5158 :              *       dev->suspended is NOT set as it is not the intent
; 5159 :              *       to permit another system to update the device.
; 5160 :              */
; 5161 : 
; 5162 :             /* Acquire device lock */
; 5163 :             obtain_lock(&dev->lock);

  019ef	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  019f3	48 83 c0 38	 add	 rax, 56			; 00000038H
  019f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182681
  019fe	48 8b c8	 mov	 rcx, rax
  01a01	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 5164 : 
; 5165 :             /* State converting from SIO synchronous to asynchronous */
; 5166 :             if (CCW_TRACING_ACTIVE( dev, tracethis ))

  01a07	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01a0b	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01a11	c1 e8 0f	 shr	 eax, 15
  01a14	83 e0 01	 and	 eax, 1
  01a17	85 c0		 test	 eax, eax
  01a19	75 0c		 jne	 SHORT $LN135@s390_execu
  01a1b	0f b6 45 15	 movzx	 eax, BYTE PTR tracethis$[rbp]
  01a1f	85 c0		 test	 eax, eax
  01a21	0f 84 d3 00 00
	00		 je	 $LN134@s390_execu
$LN135@s390_execu:

; 5167 :             {
; 5168 :                 if (dev->ccwtrace && sysblk.traceFILE)

  01a27	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01a2b	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01a31	c1 e8 0f	 shr	 eax, 15
  01a34	83 e0 01	 and	 eax, 1
  01a37	85 c0		 test	 eax, eax
  01a39	74 20		 je	 SHORT $LN136@s390_execu
  01a3b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01a42	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  01a4a	74 0f		 je	 SHORT $LN136@s390_execu

; 5169 :                     tf_1320( dev );

  01a4c	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01a50	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1320
  01a56	e9 9f 00 00 00	 jmp	 $LN137@s390_execu
$LN136@s390_execu:

; 5170 :                 else
; 5171 :                     // "%1d:%04X CHAN: start I/O S/370 conversion to asynchronous operation started"
; 5172 :                     WRMSG( HHC01320, "I", LCSS_DEVNUM );

  01a5b	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  01a60	74 10		 je	 SHORT $LN271@s390_execu
  01a62	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01a66	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01a6a	89 85 bc 00 00
	00		 mov	 DWORD PTR tv1191[rbp], eax
  01a70	eb 0a		 jmp	 SHORT $LN272@s390_execu
$LN271@s390_execu:
  01a72	c7 85 bc 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1191[rbp], 0
$LN272@s390_execu:
  01a7c	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  01a81	74 12		 je	 SHORT $LN273@s390_execu
  01a83	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01a87	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01a8b	d1 f8		 sar	 eax, 1
  01a8d	89 85 c0 00 00
	00		 mov	 DWORD PTR tv1197[rbp], eax
  01a93	eb 0a		 jmp	 SHORT $LN274@s390_execu
$LN273@s390_execu:
  01a95	c7 85 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1197[rbp], 0
$LN274@s390_execu:
  01a9f	b9 01 00 00 00	 mov	 ecx, 1
  01aa4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01aaa	8b 8d bc 00 00
	00		 mov	 ecx, DWORD PTR tv1191[rbp]
  01ab0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01ab4	8b 8d c0 00 00
	00		 mov	 ecx, DWORD PTR tv1197[rbp]
  01aba	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01abe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182686
  01ac5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01aca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182687
  01ad1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01ad6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01adb	41 b9 03 00 00
	00		 mov	 r9d, 3
  01ae1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG182688
  01ae8	ba 34 14 00 00	 mov	 edx, 5172		; 00001434H
  01aed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182689
  01af4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN137@s390_execu:
$LN134@s390_execu:

; 5173 :             }
; 5174 : 
; 5175 :             /* Update local copy of ORB */
; 5176 :             STORE_FW(dev->orb.ccwaddr, (ccwaddr-8));

  01afa	8b 45 20	 mov	 eax, DWORD PTR ccwaddr$[rbp]
  01afd	83 e8 08	 sub	 eax, 8
  01b00	8b c8		 mov	 ecx, eax
  01b02	e8 00 00 00 00	 call	 _byteswap_ulong
  01b07	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01b0b	48 81 c1 d4 02
	00 00		 add	 rcx, 724		; 000002d4H
  01b12	8b d0		 mov	 edx, eax
  01b14	e8 00 00 00 00	 call	 store_fw_noswap

; 5177 : 
; 5178 :             /* Preserve CCW execution variables for validation */
; 5179 :             dev->ccwaddr = ccwaddr;

  01b19	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01b1d	8b 4d 20	 mov	 ecx, DWORD PTR ccwaddr$[rbp]
  01b20	89 88 80 02 00
	00		 mov	 DWORD PTR [rax+640], ecx

; 5180 :             dev->idapmask = idapmask;

  01b26	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01b2a	0f b7 4d 44	 movzx	 ecx, WORD PTR idapmask$[rbp]
  01b2e	66 89 88 84 02
	00 00		 mov	 WORD PTR [rax+644], cx

; 5181 :             dev->idawfmt = idawfmt;

  01b35	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01b39	0f b6 4d 16	 movzx	 ecx, BYTE PTR idawfmt$[rbp]
  01b3d	88 88 86 02 00
	00		 mov	 BYTE PTR [rax+646], cl

; 5182 :             dev->ccwfmt = ccwfmt;

  01b43	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01b47	0f b6 4d 0b	 movzx	 ecx, BYTE PTR ccwfmt$[rbp]
  01b4b	88 88 87 02 00
	00		 mov	 BYTE PTR [rax+647], cl

; 5183 :             dev->ccwkey = ccwkey;

  01b51	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01b55	0f b6 4d 14	 movzx	 ecx, BYTE PTR ccwkey$[rbp]
  01b59	88 88 88 02 00
	00		 mov	 BYTE PTR [rax+648], cl

; 5184 : 
; 5185 :             /* Set the resume pending flag and signal the subchannel;
; 5186 :              * NULL is used for the requeue regs as the execution of
; 5187 :              * the I/O is no longer attached to a specific processor.
; 5188 :              */
; 5189 :             dev->scsw.flag2 |= SCSW2_AC_RESUM;

  01b5f	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01b63	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  01b6a	83 c8 08	 or	 eax, 8
  01b6d	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01b71	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 5190 :             schedule_ioq(NULL, dev);

  01b77	48 8b 55 00	 mov	 rdx, QWORD PTR dev$[rbp]
  01b7b	33 c9		 xor	 ecx, ecx
  01b7d	e8 00 00 00 00	 call	 schedule_ioq

; 5191 : 
; 5192 :             /* Leave device as busy, unlock device and return */
; 5193 :             release_lock(&dev->lock);

  01b82	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01b86	48 83 c0 38	 add	 rax, 56			; 00000038H
  01b8a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182690
  01b91	48 8b c8	 mov	 rcx, rax
  01b94	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5194 :             return execute_ccw_chain_fast_return( iobuf, &iobuf_initial, NULL );

  01b9a	45 33 c0	 xor	 r8d, r8d
  01b9d	48 8d 95 00 20
	00 00		 lea	 rdx, QWORD PTR iobuf_initial$[rbp]
  01ba4	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  01ba8	e8 00 00 00 00	 call	 execute_ccw_chain_fast_return
  01bad	e9 92 1b 00 00	 jmp	 $LN1@s390_execu
$LN133@s390_execu:

; 5195 :         }
; 5196 : 
; 5197 :         /* Handle initial status settings on first non-immediate CCW */
; 5198 :         /* to the device                                             */
; 5199 :         if (firstccw && !dev->is_immed)

  01bb2	0f b6 45 2d	 movzx	 eax, BYTE PTR firstccw$[rbp]
  01bb6	85 c0		 test	 eax, eax
  01bb8	0f 84 bd 01 00
	00		 je	 $LN138@s390_execu
  01bbe	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01bc2	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  01bc9	0f 85 ac 01 00
	00		 jne	 $LN138@s390_execu

; 5200 :         {
; 5201 :             /* Reset first CCW indication as we're starting the      */
; 5202 :             /* subchannel                                            */
; 5203 :             firstccw = 0;

  01bcf	c6 45 2d 00	 mov	 BYTE PTR firstccw$[rbp], 0

; 5204 : 
; 5205 :             /* Subchannel and device are now active, set bits in     */
; 5206 :             /* SCSW                                                  */
; 5207 :             /* SA22-7201-05:                                         */
; 5208 :             /*  p. 16-14, Subchannel-Active                          */
; 5209 :             /*  pp. 16-14 -- 16-15, Device-Active                    */
; 5210 :             dev->scsw.flag3 |= (SCSW3_AC_SCHAC | SCSW3_AC_DEVAC);

  01bd3	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01bd7	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  01bde	0d c0 00 00 00	 or	 eax, 192		; 000000c0H
  01be3	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01be7	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 5211 : 
; 5212 :             /* Process Initial-Status-Interruption Request           */
; 5213 :             /* SA22-7201-05:                                         */
; 5214 :             /*  p. 16-11, Zero Condition Code                        */
; 5215 :             if (dev->scsw.flag1 & SCSW1_I)

  01bed	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01bf1	0f b6 80 09 03
	00 00		 movzx	 eax, BYTE PTR [rax+777]
  01bf8	83 e0 20	 and	 eax, 32			; 00000020H
  01bfb	85 c0		 test	 eax, eax
  01bfd	0f 84 78 01 00
	00		 je	 $LN139@s390_execu

; 5216 :             {
; 5217 :                 obtain_lock (&dev->lock);

  01c03	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01c07	48 83 c0 38	 add	 rax, 56			; 00000038H
  01c0b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182693
  01c12	48 8b c8	 mov	 rcx, rax
  01c15	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 5218 : 
; 5219 :                 /* Update the CCW address in the SCSW */
; 5220 :                 STORE_FW(dev->scsw.ccwaddr,ccwaddr);

  01c1b	8b 4d 20	 mov	 ecx, DWORD PTR ccwaddr$[rbp]
  01c1e	e8 00 00 00 00	 call	 _byteswap_ulong
  01c23	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01c27	48 81 c1 0c 03
	00 00		 add	 rcx, 780		; 0000030cH
  01c2e	8b d0		 mov	 edx, eax
  01c30	e8 00 00 00 00	 call	 store_fw_noswap

; 5221 : 
; 5222 :                 /* Set the zero condition-code flag in the SCSW */
; 5223 :                 dev->scsw.flag1 |= SCSW1_Z;

  01c35	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01c39	0f b6 80 09 03
	00 00		 movzx	 eax, BYTE PTR [rax+777]
  01c40	83 c8 04	 or	 eax, 4
  01c43	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01c47	88 81 09 03 00
	00		 mov	 BYTE PTR [rcx+777], al

; 5224 : 
; 5225 :                 /* Set intermediate status in the SCSW */
; 5226 :                 dev->scsw.flag3 |= (SCSW3_SC_INTER | SCSW3_SC_PEND);

  01c4d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01c51	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  01c58	83 c8 09	 or	 eax, 9
  01c5b	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01c5f	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 5227 : 
; 5228 :                 /* Queue the interrupt and update interrupt status */
; 5229 :                 release_lock(&dev->lock);

  01c65	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01c69	48 83 c0 38	 add	 rax, 56			; 00000038H
  01c6d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182694
  01c74	48 8b c8	 mov	 rcx, rax
  01c77	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5230 :                 queue_io_interrupt_and_update_status(dev,FALSE);

  01c7d	33 d2		 xor	 edx, edx
  01c7f	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01c83	e8 00 00 00 00	 call	 queue_io_interrupt_and_update_status

; 5231 : 
; 5232 :                 if (CCW_TRACING_ACTIVE( dev, tracethis ))

  01c88	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01c8c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01c92	c1 e8 0f	 shr	 eax, 15
  01c95	83 e0 01	 and	 eax, 1
  01c98	85 c0		 test	 eax, eax
  01c9a	75 0c		 jne	 SHORT $LN141@s390_execu
  01c9c	0f b6 45 15	 movzx	 eax, BYTE PTR tracethis$[rbp]
  01ca0	85 c0		 test	 eax, eax
  01ca2	0f 84 d3 00 00
	00		 je	 $LN140@s390_execu
$LN141@s390_execu:

; 5233 :                 {
; 5234 :                     if (dev->ccwtrace && sysblk.traceFILE)

  01ca8	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01cac	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01cb2	c1 e8 0f	 shr	 eax, 15
  01cb5	83 e0 01	 and	 eax, 1
  01cb8	85 c0		 test	 eax, eax
  01cba	74 20		 je	 SHORT $LN142@s390_execu
  01cbc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01cc3	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  01ccb	74 0f		 je	 SHORT $LN142@s390_execu

; 5235 :                         tf_1306( dev );

  01ccd	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01cd1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1306
  01cd7	e9 9f 00 00 00	 jmp	 $LN143@s390_execu
$LN142@s390_execu:

; 5236 :                     else
; 5237 :                         // "%1d:%04X CHAN: initial status interrupt"
; 5238 :                         WRMSG( HHC01306, "I", LCSS_DEVNUM );

  01cdc	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  01ce1	74 10		 je	 SHORT $LN275@s390_execu
  01ce3	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01ce7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01ceb	89 85 c4 00 00
	00		 mov	 DWORD PTR tv1285[rbp], eax
  01cf1	eb 0a		 jmp	 SHORT $LN276@s390_execu
$LN275@s390_execu:
  01cf3	c7 85 c4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1285[rbp], 0
$LN276@s390_execu:
  01cfd	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  01d02	74 12		 je	 SHORT $LN277@s390_execu
  01d04	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01d08	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01d0c	d1 f8		 sar	 eax, 1
  01d0e	89 85 c8 00 00
	00		 mov	 DWORD PTR tv1291[rbp], eax
  01d14	eb 0a		 jmp	 SHORT $LN278@s390_execu
$LN277@s390_execu:
  01d16	c7 85 c8 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1291[rbp], 0
$LN278@s390_execu:
  01d20	b9 01 00 00 00	 mov	 ecx, 1
  01d25	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01d2b	8b 8d c4 00 00
	00		 mov	 ecx, DWORD PTR tv1285[rbp]
  01d31	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01d35	8b 8d c8 00 00
	00		 mov	 ecx, DWORD PTR tv1291[rbp]
  01d3b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01d3f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182699
  01d46	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01d4b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182700
  01d52	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01d57	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01d5c	41 b9 03 00 00
	00		 mov	 r9d, 3
  01d62	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG182701
  01d69	ba 76 14 00 00	 mov	 edx, 5238		; 00001476H
  01d6e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182702
  01d75	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN143@s390_execu:
$LN140@s390_execu:
$LN139@s390_execu:
$LN138@s390_execu:

; 5239 :                 }
; 5240 :             }
; 5241 :         }
; 5242 : 
; 5243 :         /* For WRITE and non-immediate CONTROL operations,
; 5244 :            copy data from main storage into channel buffer */
; 5245 :         if (!skip_ccws &&

  01d7b	83 7d 64 00	 cmp	 DWORD PTR skip_ccws$[rbp], 0
  01d7f	0f 85 83 03 00
	00		 jne	 $LN144@s390_execu
  01d85	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  01d8c	75 3b		 jne	 SHORT $LN145@s390_execu
  01d8e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01d92	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  01d99	0f 85 69 03 00
	00		 jne	 $LN144@s390_execu
  01d9f	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01da3	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  01daa	83 e0 03	 and	 eax, 3
  01dad	83 f8 01	 cmp	 eax, 1
  01db0	74 17		 je	 SHORT $LN146@s390_execu
  01db2	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01db6	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  01dbd	83 e0 03	 and	 eax, 3
  01dc0	83 f8 03	 cmp	 eax, 3
  01dc3	0f 85 3f 03 00
	00		 jne	 $LN144@s390_execu
$LN146@s390_execu:
$LN145@s390_execu:

; 5246 :             (prefetch.seq ||
; 5247 :              (!dev->is_immed                 &&
; 5248 :               (IS_CCW_WRITE(dev->code)  ||
; 5249 :                IS_CCW_CONTROL(dev->code)))))
; 5250 :         {
; 5251 :             /* Clear prefetch sequence table and I/O buffer if first
; 5252 :                entry */
; 5253 :             if (!prefetch.seq)

  01dc9	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  01dd0	0f 85 98 00 00
	00		 jne	 $LN147@s390_execu

; 5254 :             {
; 5255 :                 clear_io_buffer(iobuf->data, iobuf->size);

  01dd6	48 8b 45 58	 mov	 rax, QWORD PTR iobuf$[rbp]
  01dda	8b 00		 mov	 eax, DWORD PTR [rax]
  01ddc	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  01de0	48 81 c1 00 10
	00 00		 add	 rcx, 4096		; 00001000H
  01de7	8b d0		 mov	 edx, eax
  01de9	e8 00 00 00 00	 call	 __clear_io_buffer

; 5256 :                 clear_io_buffer(&prefetch, sizeof(prefetch));

  01dee	ba 10 1a 00 00	 mov	 edx, 6672		; 00001a10H
  01df3	48 8d 8d c0 01
	00 00		 lea	 rcx, QWORD PTR prefetch$[rbp]
  01dfa	e8 00 00 00 00	 call	 __clear_io_buffer

; 5257 :                 ps = 0;

  01dff	c7 45 10 00 00
	00 00		 mov	 DWORD PTR ps$[rbp], 0

; 5258 :                 prefetch.seq = 1;

  01e06	c7 85 c0 01 00
	00 01 00 00 00	 mov	 DWORD PTR prefetch$[rbp], 1

; 5259 :                 prefetch.prevcode = dev->prevcode;

  01e10	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01e14	0f b6 80 7b 02
	00 00		 movzx	 eax, BYTE PTR [rax+635]
  01e1b	88 85 cc 01 00
	00		 mov	 BYTE PTR prefetch$[rbp+12], al

; 5260 :                 prefetch.opcode = dev->code;

  01e21	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01e25	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  01e2c	88 85 cd 01 00
	00		 mov	 BYTE PTR prefetch$[rbp+13], al

; 5261 :                 prefetch.ccwaddr[ps] = ccwaddr;

  01e32	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01e35	8b 4d 20	 mov	 ecx, DWORD PTR ccwaddr$[rbp]
  01e38	89 8c 85 d0 02
	00 00		 mov	 DWORD PTR prefetch$[rbp+rax*4+272], ecx

; 5262 :                 prefetch.ccwflags[ps] = flags;

  01e3f	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01e42	0f b6 4d 08	 movzx	 ecx, BYTE PTR flags$[rbp]
  01e46	88 8c 05 d0 12
	00 00		 mov	 BYTE PTR prefetch$[rbp+rax+4368], cl

; 5263 :                 prefetch.ccwcount[ps] = count;

  01e4d	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01e50	0f b7 4d 18	 movzx	 ecx, WORD PTR count$[rbp]
  01e54	66 89 8c 45 d0
	13 00 00	 mov	 WORD PTR prefetch$[rbp+rax*2+4624], cx

; 5264 :                 prefetch.chanstat[ps] = chanstat;

  01e5c	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01e5f	0f b6 4d 09	 movzx	 ecx, BYTE PTR chanstat$[rbp]
  01e63	88 8c 05 d0 01
	00 00		 mov	 BYTE PTR prefetch$[rbp+rax+16], cl

; 5265 :                 chanstat = 0;

  01e6a	c6 45 09 00	 mov	 BYTE PTR chanstat$[rbp], 0
$LN147@s390_execu:
$prefetch$328:

; 5266 :             }
; 5267 : prefetch:
; 5268 :             /* Finish prefetch table entry initialization */
; 5269 :             if (opcode == 0x08 ||

  01e6e	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  01e72	83 f8 08	 cmp	 eax, 8
  01e75	74 14		 je	 SHORT $LN150@s390_execu
  01e77	0f b6 45 0b	 movzx	 eax, BYTE PTR ccwfmt$[rbp]
  01e7b	85 c0		 test	 eax, eax
  01e7d	75 26		 jne	 SHORT $LN148@s390_execu
  01e7f	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  01e83	83 e0 0f	 and	 eax, 15
  01e86	83 f8 08	 cmp	 eax, 8
  01e89	75 1a		 jne	 SHORT $LN148@s390_execu
$LN150@s390_execu:

; 5270 :                 (ccwfmt == 0 && ((opcode & 0x0f) == 0x08)))
; 5271 :             {
; 5272 :                 prefetch.ccwflags[ps] = 0;

  01e8b	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01e8e	c6 84 05 d0 12
	00 00 00	 mov	 BYTE PTR prefetch$[rbp+rax+4368], 0

; 5273 :                 prefetch.ccwcount[ps] = 0;

  01e96	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01e99	33 c9		 xor	 ecx, ecx
  01e9b	66 89 8c 45 d0
	13 00 00	 mov	 WORD PTR prefetch$[rbp+rax*2+4624], cx

; 5274 :             }

  01ea3	eb 24		 jmp	 SHORT $LN149@s390_execu
$LN148@s390_execu:

; 5275 :             else
; 5276 :             {
; 5277 :                 prefetch.ccwflags[ps] = flags & ~(CCW_FLAGS_SKIP |

  01ea5	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  01ea9	83 e0 ed	 and	 eax, -19
  01eac	8b 4d 10	 mov	 ecx, DWORD PTR ps$[rbp]
  01eaf	88 84 0d d0 12
	00 00		 mov	 BYTE PTR prefetch$[rbp+rcx+4368], al

; 5278 :                                                   CCW_FLAGS_SUSP);
; 5279 :                 prefetch.reqcount += count;

  01eb6	8b 45 18	 mov	 eax, DWORD PTR count$[rbp]
  01eb9	8b 8d c8 01 00
	00		 mov	 ecx, DWORD PTR prefetch$[rbp+8]
  01ebf	03 c8		 add	 ecx, eax
  01ec1	8b c1		 mov	 eax, ecx
  01ec3	89 85 c8 01 00
	00		 mov	 DWORD PTR prefetch$[rbp+8], eax
$LN149@s390_execu:

; 5280 :             }
; 5281 : 
; 5282 :             /* Copy address to prefetch table */
; 5283 :             prefetch.dataaddr[ps] = addr;

  01ec9	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01ecc	8b 4d 24	 mov	 ecx, DWORD PTR addr$[rbp]
  01ecf	48 89 8c c5 d0
	0a 00 00	 mov	 QWORD PTR prefetch$[rbp+rax*8+2320], rcx

; 5284 : 
; 5285 :             /* Ignore additional checks if error */
; 5286 :             if (chanstat)

  01ed7	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  01edb	85 c0		 test	 eax, eax
  01edd	74 17		 je	 SHORT $LN151@s390_execu

; 5287 :             {
; 5288 :                 prefetch.chanstat[ps] = chanstat;

  01edf	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01ee2	0f b6 4d 09	 movzx	 ecx, BYTE PTR chanstat$[rbp]
  01ee6	88 8c 05 d0 01
	00 00		 mov	 BYTE PTR prefetch$[rbp+rax+16], cl

; 5289 :                 chanstat = 0;

  01eed	c6 45 09 00	 mov	 BYTE PTR chanstat$[rbp], 0

; 5290 :             }

  01ef1	e9 36 01 00 00	 jmp	 $LN152@s390_execu
$LN151@s390_execu:

; 5291 : 
; 5292 :             /* Don't copy if immediate and zero count */
; 5293 :             else if (dev->is_immed && !count);

  01ef6	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01efa	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  01f01	74 0b		 je	 SHORT $LN153@s390_execu
  01f03	83 7d 18 00	 cmp	 DWORD PTR count$[rbp], 0
  01f07	75 05		 jne	 SHORT $LN153@s390_execu
  01f09	e9 1e 01 00 00	 jmp	 $LN154@s390_execu
$LN153@s390_execu:

; 5294 : 
; 5295 :             /* Otherwise, copy data into channel buffer */
; 5296 :             else
; 5297 :             {
; 5298 :                 U32 newsize = bufpos + count;

  01f0e	8b 45 18	 mov	 eax, DWORD PTR count$[rbp]
  01f11	8b 4d 60	 mov	 ecx, DWORD PTR bufpos$[rbp]
  01f14	03 c8		 add	 ecx, eax
  01f16	8b c1		 mov	 eax, ecx
  01f18	89 85 cc 00 00
	00		 mov	 DWORD PTR newsize$8[rbp], eax

; 5299 : 
; 5300 :                 prefetch.datalen[ps] = count;

  01f1e	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01f21	8b 4d 18	 mov	 ecx, DWORD PTR count$[rbp]
  01f24	89 8c 85 d0 06
	00 00		 mov	 DWORD PTR prefetch$[rbp+rax*4+1296], ecx

; 5301 : 
; 5302 :                 /* Extend buffer if overflow */
; 5303 :                 if (newsize > iobuf->size)

  01f2b	48 8b 45 58	 mov	 rax, QWORD PTR iobuf$[rbp]
  01f2f	8b 00		 mov	 eax, DWORD PTR [rax]
  01f31	39 85 cc 00 00
	00		 cmp	 DWORD PTR newsize$8[rbp], eax
  01f37	76 38		 jbe	 SHORT $LN155@s390_execu

; 5304 :                 {
; 5305 :                     IOBUF *iobufnew;
; 5306 : 
; 5307 :                     iobufnew = iobuf_reallocate(iobuf, newsize);

  01f39	8b 95 cc 00 00
	00		 mov	 edx, DWORD PTR newsize$8[rbp]
  01f3f	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  01f43	e8 00 00 00 00	 call	 iobuf_reallocate
  01f48	48 89 85 90 01
	00 00		 mov	 QWORD PTR iobufnew$9[rbp], rax

; 5308 : 
; 5309 :                     /* If new I/O buffer allocation failed, force a
; 5310 :                      * Channel Data Check (CDC). Otherwise, set the
; 5311 :                      * iobuf pointer to the new I/O buffer space.
; 5312 :                      */
; 5313 :                     if (iobufnew == NULL)

  01f4f	48 83 bd 90 01
	00 00 00	 cmp	 QWORD PTR iobufnew$9[rbp], 0
  01f57	75 0d		 jne	 SHORT $LN156@s390_execu

; 5314 :                         prefetch.chanstat[ps] = CSW_CDC;

  01f59	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01f5c	c6 84 05 d0 01
	00 00 08	 mov	 BYTE PTR prefetch$[rbp+rax+16], 8
  01f64	eb 0b		 jmp	 SHORT $LN157@s390_execu
$LN156@s390_execu:

; 5315 :                     else
; 5316 :                         iobuf = iobufnew;

  01f66	48 8b 85 90 01
	00 00		 mov	 rax, QWORD PTR iobufnew$9[rbp]
  01f6d	48 89 45 58	 mov	 QWORD PTR iobuf$[rbp], rax
$LN157@s390_execu:
$LN155@s390_execu:

; 5317 :                 }
; 5318 : 
; 5319 :                 /* If no errors, prefetch data to I/O buffer */
; 5320 :                 if (!prefetch.chanstat[ps])

  01f71	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01f74	0f b6 84 05 d0
	01 00 00	 movzx	 eax, BYTE PTR prefetch$[rbp+rax+16]
  01f7c	85 c0		 test	 eax, eax
  01f7e	0f 85 a8 00 00
	00		 jne	 $LN158@s390_execu

; 5321 :                 {
; 5322 :                     ARCH_DEP(copy_iobuf) (dev, ccw, dev->code, flags, addr,

  01f84	8b 45 60	 mov	 eax, DWORD PTR bufpos$[rbp]
  01f87	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  01f8b	48 8d 84 01 00
	10 00 00	 lea	 rax, QWORD PTR [rcx+rax+4096]
  01f93	48 8d 8d c0 01
	00 00		 lea	 rcx, QWORD PTR prefetch$[rbp]
  01f9a	48 89 4c 24 70	 mov	 QWORD PTR [rsp+112], rcx
  01f9f	48 8d 4d 30	 lea	 rcx, QWORD PTR residual$[rbp]
  01fa3	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  01fa8	48 8d 4d 09	 lea	 rcx, QWORD PTR chanstat$[rbp]
  01fac	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  01fb1	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  01fb5	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  01fb9	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01fbe	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  01fc2	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  01fc6	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01fcb	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  01fd0	0f b7 45 44	 movzx	 eax, WORD PTR idapmask$[rbp]
  01fd4	66 89 44 24 40	 mov	 WORD PTR [rsp+64], ax
  01fd9	0f b6 45 16	 movzx	 eax, BYTE PTR idawfmt$[rbp]
  01fdd	88 44 24 38	 mov	 BYTE PTR [rsp+56], al
  01fe1	0f b6 45 14	 movzx	 eax, BYTE PTR ccwkey$[rbp]
  01fe5	88 44 24 30	 mov	 BYTE PTR [rsp+48], al
  01fe9	8b 45 18	 mov	 eax, DWORD PTR count$[rbp]
  01fec	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  01ff0	8b 45 24	 mov	 eax, DWORD PTR addr$[rbp]
  01ff3	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  01ff7	44 0f b6 4d 08	 movzx	 r9d, BYTE PTR flags$[rbp]
  01ffc	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02000	44 0f b6 80 7a
	02 00 00	 movzx	 r8d, BYTE PTR [rax+634]
  02008	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR ccw$[rbp]
  0200f	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02013	e8 00 00 00 00	 call	 s390_copy_iobuf

; 5323 :                                           count, ccwkey,
; 5324 :                                           idawfmt, idapmask,
; 5325 :                                           iobuf->data + bufpos,
; 5326 :                                           iobuf->start, iobuf->end,
; 5327 :                                           &chanstat, &residual, &prefetch);
; 5328 : 
; 5329 :                     /* Update local copy of prefetch sequence entry */
; 5330 :                     ps = prefetch.seq - 1;

  02018	8b 85 c0 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp]
  0201e	ff c8		 dec	 eax
  02020	89 45 10	 mov	 DWORD PTR ps$[rbp], eax

; 5331 : 
; 5332 :                     /* Update number of bytes in channel buffer */
; 5333 :                     bufpos = prefetch.pos;

  02023	8b 85 c4 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp+4]
  02029	89 45 60	 mov	 DWORD PTR bufpos$[rbp], eax
$LN158@s390_execu:
$LN154@s390_execu:
$LN152@s390_execu:

; 5334 :                 }
; 5335 :             }
; 5336 : 
; 5337 :             /* If the device handler has requested merging of data
; 5338 :                chained write CCWs, then collect the data from the
; 5339 :                chained-data CCWs in the sequence before passing buffer
; 5340 :                to device handler */
; 5341 : 
; 5342 :             /* Note: This test is commented out as we prefetch the data;
; 5343 :                      chain data, therefore, must always be handled.
; 5344 : 
; 5345 :             if ((dev->orb.flag5 & ORB5_P) ||
; 5346 :                 dev->cdwmerge)                                        */
; 5347 :             {
; 5348 :                 if (dev->code != 0x08 &&
; 5349 :                     !(ccwfmt == 0 && ((dev->code & 0x0F) == 0x08)) &&

  0202c	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02030	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  02037	83 f8 08	 cmp	 eax, 8
  0203a	74 65		 je	 SHORT $LN159@s390_execu
  0203c	0f b6 45 0b	 movzx	 eax, BYTE PTR ccwfmt$[rbp]
  02040	85 c0		 test	 eax, eax
  02042	75 13		 jne	 SHORT $LN160@s390_execu
  02044	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02048	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  0204f	83 e0 0f	 and	 eax, 15
  02052	83 f8 08	 cmp	 eax, 8
  02055	74 4a		 je	 SHORT $LN159@s390_execu
$LN160@s390_execu:
  02057	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  0205b	25 80 00 00 00	 and	 eax, 128		; 00000080H
  02060	85 c0		 test	 eax, eax
  02062	74 3d		 je	 SHORT $LN159@s390_execu

; 5350 :                     flags & CCW_FLAGS_CD)
; 5351 :                 {
; 5352 :                     /* If this is the first CCW in the data chain,
; 5353 :                        then save the chaining flags from the
; 5354 :                        previous CCW */
; 5355 :                     if ((dev->chained & CCW_FLAGS_CD) == 0)

  02064	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02068	0f b6 80 78 02
	00 00		 movzx	 eax, BYTE PTR [rax+632]
  0206f	25 80 00 00 00	 and	 eax, 128		; 00000080H
  02074	85 c0		 test	 eax, eax
  02076	75 15		 jne	 SHORT $LN161@s390_execu

; 5356 :                         dev->prev_chained = dev->chained;

  02078	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0207c	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02080	0f b6 89 78 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+632]
  02087	88 88 79 02 00
	00		 mov	 BYTE PTR [rax+633], cl
$LN161@s390_execu:

; 5357 : 
; 5358 :                     /* Process next CCW in data chain */
; 5359 :                     dev->chained = CCW_FLAGS_CD;

  0208d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02091	c6 80 78 02 00
	00 80		 mov	 BYTE PTR [rax+632], 128	; 00000080H

; 5360 :                     chain = 1;

  02098	c6 45 1c 01	 mov	 BYTE PTR chain$[rbp], 1

; 5361 :                     continue;

  0209c	e9 1c e9 ff ff	 jmp	 $LN320@s390_execu
$LN159@s390_execu:

; 5362 :                 }
; 5363 : 
; 5364 :                 /* If this is the last CCW in the data chain, then
; 5365 :                    restore the chaining flags from the previous
; 5366 :                    CCW */
; 5367 :                 if (dev->chained & CCW_FLAGS_CD)

  020a1	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  020a5	0f b6 80 78 02
	00 00		 movzx	 eax, BYTE PTR [rax+632]
  020ac	25 80 00 00 00	 and	 eax, 128		; 00000080H
  020b1	85 c0		 test	 eax, eax
  020b3	74 15		 je	 SHORT $LN162@s390_execu

; 5368 :                     dev->chained = dev->prev_chained;

  020b5	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  020b9	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  020bd	0f b6 89 79 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+633]
  020c4	88 88 78 02 00
	00		 mov	 BYTE PTR [rax+632], cl
$LN162@s390_execu:

; 5369 : 
; 5370 :             } /* end if(dev->cdwmerge) */
; 5371 : 
; 5372 :             /* Reset pointers */
; 5373 :             ccwaddr = prefetch.ccwaddr[0];

  020ca	b8 04 00 00 00	 mov	 eax, 4
  020cf	48 6b c0 00	 imul	 rax, rax, 0
  020d3	8b 84 05 d0 02
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax+272]
  020da	89 45 20	 mov	 DWORD PTR ccwaddr$[rbp], eax

; 5374 :             dev->prevcode = prefetch.prevcode;

  020dd	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  020e1	0f b6 8d cc 01
	00 00		 movzx	 ecx, BYTE PTR prefetch$[rbp+12]
  020e8	88 88 7b 02 00
	00		 mov	 BYTE PTR [rax+635], cl

; 5375 :             dev->code = prefetch.opcode;

  020ee	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  020f2	0f b6 8d cd 01
	00 00		 movzx	 ecx, BYTE PTR prefetch$[rbp+13]
  020f9	88 88 7a 02 00
	00		 mov	 BYTE PTR [rax+634], cl

; 5376 :             count = prefetch.reqcount;

  020ff	8b 85 c8 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp+8]
  02105	89 45 18	 mov	 DWORD PTR count$[rbp], eax
$LN144@s390_execu:

; 5377 : 
; 5378 :         }   /* End prefetch */
; 5379 : 
; 5380 :         /* Set chaining flag */
; 5381 :         chain = ( flags & (CCW_FLAGS_CD | CCW_FLAGS_CC) ) ? 1 : 0;

  02108	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  0210c	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  02111	85 c0		 test	 eax, eax
  02113	74 0c		 je	 SHORT $LN279@s390_execu
  02115	c7 85 d0 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv1440[rbp], 1
  0211f	eb 0a		 jmp	 SHORT $LN280@s390_execu
$LN279@s390_execu:
  02121	c7 85 d0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1440[rbp], 0
$LN280@s390_execu:
  0212b	0f b6 85 d0 00
	00 00		 movzx	 eax, BYTE PTR tv1440[rbp]
  02132	88 45 1c	 mov	 BYTE PTR chain$[rbp], al

; 5382 : 
; 5383 :         /* If first in sequence, begin execution and channel data
; 5384 :            transfer */
; 5385 :         if (!skip_ccws)

  02135	83 7d 64 00	 cmp	 DWORD PTR skip_ccws$[rbp], 0
  02139	0f 85 35 04 00
	00		 jne	 $LN163@s390_execu

; 5386 :         {
; 5387 :             /* Initialize residual byte count */
; 5388 :             residual = count;

  0213f	8b 45 18	 mov	 eax, DWORD PTR count$[rbp]
  02142	89 45 30	 mov	 DWORD PTR residual$[rbp], eax

; 5389 :             more = bufpos = unitstat = chanstat = 0;

  02145	c6 45 09 00	 mov	 BYTE PTR chanstat$[rbp], 0
  02149	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  0214d	88 45 0c	 mov	 BYTE PTR unitstat$[rbp], al
  02150	0f b6 45 0c	 movzx	 eax, BYTE PTR unitstat$[rbp]
  02154	89 45 60	 mov	 DWORD PTR bufpos$[rbp], eax
  02157	0f b6 45 60	 movzx	 eax, BYTE PTR bufpos$[rbp]
  0215b	88 45 40	 mov	 BYTE PTR more$[rbp], al

; 5390 : 
; 5391 :             /* Pass the CCW to the device handler for execution */
; 5392 :             dev->iobuf.length = iobuf->size;

  0215e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02162	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  02166	8b 09		 mov	 ecx, DWORD PTR [rcx]
  02168	89 88 a8 02 00
	00		 mov	 DWORD PTR [rax+680], ecx

; 5393 :             dev->iobuf.data = iobuf->data;

  0216e	48 8b 45 58	 mov	 rax, QWORD PTR iobuf$[rbp]
  02172	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  02178	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0217c	48 89 81 b0 02
	00 00		 mov	 QWORD PTR [rcx+688], rax

; 5394 :             (dev->hnd->exec) (dev, dev->code, flags, dev->chained,

  02183	48 8b 45 58	 mov	 rax, QWORD PTR iobuf$[rbp]
  02187	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  0218d	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02191	48 8b 89 90 02
	00 00		 mov	 rcx, QWORD PTR [rcx+656]
  02198	48 89 8d a0 01
	00 00		 mov	 QWORD PTR tv2347[rbp], rcx
  0219f	48 8d 55 30	 lea	 rdx, QWORD PTR residual$[rbp]
  021a3	48 89 54 24 50	 mov	 QWORD PTR [rsp+80], rdx
  021a8	48 8d 55 0c	 lea	 rdx, QWORD PTR unitstat$[rbp]
  021ac	48 89 54 24 48	 mov	 QWORD PTR [rsp+72], rdx
  021b1	48 8d 55 40	 lea	 rdx, QWORD PTR more$[rbp]
  021b5	48 89 54 24 40	 mov	 QWORD PTR [rsp+64], rdx
  021ba	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  021bf	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  021c3	8b 80 7c 02 00
	00		 mov	 eax, DWORD PTR [rax+636]
  021c9	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  021cd	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  021d1	0f b6 80 7b 02
	00 00		 movzx	 eax, BYTE PTR [rax+635]
  021d8	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  021dc	8b 45 18	 mov	 eax, DWORD PTR count$[rbp]
  021df	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  021e3	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  021e7	44 0f b6 88 78
	02 00 00	 movzx	 r9d, BYTE PTR [rax+632]
  021ef	44 0f b6 45 08	 movzx	 r8d, BYTE PTR flags$[rbp]
  021f4	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  021f8	0f b6 90 7a 02
	00 00		 movzx	 edx, BYTE PTR [rax+634]
  021ff	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02203	48 8b 85 a0 01
	00 00		 mov	 rax, QWORD PTR tv2347[rbp]
  0220a	ff 50 08	 call	 QWORD PTR [rax+8]

; 5395 :                               count, dev->prevcode, dev->ccwseq,
; 5396 :                               iobuf->data,
; 5397 :                               &more, &unitstat, &residual);
; 5398 :             dev->iobuf.length = 0;

  0220d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02211	c7 80 a8 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+680], 0

; 5399 :             dev->iobuf.data   = 0;

  0221b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0221f	48 c7 80 b0 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+688], 0

; 5400 : 
; 5401 :             /* Check for Command Retry (suggested by Jim Pierson) */
; 5402 :             if ( --cmdretry && unitstat == ( CSW_CE | CSW_DE | CSW_UC | CSW_SM ) )

  0222a	8b 85 88 00 00
	00		 mov	 eax, DWORD PTR cmdretry$[rbp]
  02230	ff c8		 dec	 eax
  02232	89 85 88 00 00
	00		 mov	 DWORD PTR cmdretry$[rbp], eax
  02238	83 bd 88 00 00
	00 00		 cmp	 DWORD PTR cmdretry$[rbp], 0
  0223f	74 41		 je	 SHORT $LN164@s390_execu
  02241	0f b6 45 0c	 movzx	 eax, BYTE PTR unitstat$[rbp]
  02245	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  02248	75 38		 jne	 SHORT $LN164@s390_execu

; 5403 :             {
; 5404 :                 chain    = 1;

  0224a	c6 45 1c 01	 mov	 BYTE PTR chain$[rbp], 1

; 5405 :                 if (prefetch.seq)

  0224e	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  02255	74 1d		 je	 SHORT $LN165@s390_execu

; 5406 :                 {
; 5407 :                     ccwaddr = prefetch.ccwaddr[0];

  02257	b8 04 00 00 00	 mov	 eax, 4
  0225c	48 6b c0 00	 imul	 rax, rax, 0
  02260	8b 84 05 d0 02
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax+272]
  02267	89 45 20	 mov	 DWORD PTR ccwaddr$[rbp], eax

; 5408 :                     prefetch.seq = 0;

  0226a	c7 85 c0 01 00
	00 00 00 00 00	 mov	 DWORD PTR prefetch$[rbp], 0
$LN165@s390_execu:

; 5409 :                 }
; 5410 :                 ccwaddr -= 8;   /* (retry same ccw again) */

  02274	8b 45 20	 mov	 eax, DWORD PTR ccwaddr$[rbp]
  02277	83 e8 08	 sub	 eax, 8
  0227a	89 45 20	 mov	 DWORD PTR ccwaddr$[rbp], eax

; 5411 :                 continue;

  0227d	e9 3b e7 ff ff	 jmp	 $LN321@s390_execu
$LN164@s390_execu:

; 5412 :             }
; 5413 : 
; 5414 :             /* Handle command reject with no data transfer */
; 5415 :             if (residual == count &&
; 5416 :                 (unitstat & CSW_UC) &&

  02282	8b 45 18	 mov	 eax, DWORD PTR count$[rbp]
  02285	39 45 30	 cmp	 DWORD PTR residual$[rbp], eax
  02288	75 5d		 jne	 SHORT $LN166@s390_execu
  0228a	0f b6 45 0c	 movzx	 eax, BYTE PTR unitstat$[rbp]
  0228e	83 e0 02	 and	 eax, 2
  02291	85 c0		 test	 eax, eax
  02293	74 52		 je	 SHORT $LN166@s390_execu
  02295	b8 01 00 00 00	 mov	 eax, 1
  0229a	48 6b c0 00	 imul	 rax, rax, 0
  0229e	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  022a2	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  022aa	25 80 00 00 00	 and	 eax, 128		; 00000080H
  022af	85 c0		 test	 eax, eax
  022b1	74 34		 je	 SHORT $LN166@s390_execu

; 5417 :                 (dev->sense[0] & SENSE_CR))
; 5418 :             {
; 5419 :                 residual = 0;

  022b3	c7 45 30 00 00
	00 00		 mov	 DWORD PTR residual$[rbp], 0

; 5420 :                 if (prefetch.seq)

  022ba	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  022c1	74 1a		 je	 SHORT $LN168@s390_execu

; 5421 :                 {
; 5422 :                     ps = 0;

  022c3	c7 45 10 00 00
	00 00		 mov	 DWORD PTR ps$[rbp], 0

; 5423 :                     ccwaddr = prefetch.ccwaddr[0];

  022ca	b8 04 00 00 00	 mov	 eax, 4
  022cf	48 6b c0 00	 imul	 rax, rax, 0
  022d3	8b 84 05 d0 02
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax+272]
  022da	89 45 20	 mov	 DWORD PTR ccwaddr$[rbp], eax
$LN168@s390_execu:

; 5424 :                 }
; 5425 : 
; 5426 :                 goto breakchain;

  022dd	e9 4e 03 00 00	 jmp	 $breakchain$327

; 5427 :             }

  022e2	e9 8d 02 00 00	 jmp	 $LN167@s390_execu
$LN166@s390_execu:

; 5428 : 
; 5429 :             /* Handle prefetch (write) conditions */
; 5430 :             else if (prefetch.seq)

  022e7	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  022ee	0f 84 4d 01 00
	00		 je	 $LN169@s390_execu

; 5431 :             {
; 5432 :                 /* Set prefetch remaining byte count */
; 5433 :                 prefetch_remaining = count - residual;

  022f4	8b 45 30	 mov	 eax, DWORD PTR residual$[rbp]
  022f7	8b 4d 18	 mov	 ecx, DWORD PTR count$[rbp]
  022fa	2b c8		 sub	 ecx, eax
  022fc	8b c1		 mov	 eax, ecx
  022fe	89 45 7c	 mov	 DWORD PTR prefetch_remaining$[rbp], eax

; 5434 : 
; 5435 :                 /* Determine prefetched CCW limit and raise requested
; 5436 :                    PCI interrupts */
; 5437 :                 for (ps = ts = 0,

  02301	c7 45 28 00 00
	00 00		 mov	 DWORD PTR ts$[rbp], 0
  02308	8b 45 28	 mov	 eax, DWORD PTR ts$[rbp]
  0230b	89 45 10	 mov	 DWORD PTR ps$[rbp], eax
  0230e	c7 45 68 01 00
	00 00		 mov	 DWORD PTR prevccwaddr$[rbp], 1
  02315	eb 08		 jmp	 SHORT $LN15@s390_execu
$LN13@s390_execu:

; 5440 :                      ts++)

  02317	8b 45 28	 mov	 eax, DWORD PTR ts$[rbp]
  0231a	ff c0		 inc	 eax
  0231c	89 45 28	 mov	 DWORD PTR ts$[rbp], eax
$LN15@s390_execu:

; 5438 :                         prevccwaddr = 1;
; 5439 :                      ts < prefetch.seq;

  0231f	8b 85 c0 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp]
  02325	39 45 28	 cmp	 DWORD PTR ts$[rbp], eax
  02328	0f 83 f3 00 00
	00		 jae	 $LN14@s390_execu

; 5441 :                 {
; 5442 :                     /* Set clean index not affected by loop completion
; 5443 :                        */
; 5444 :                     ps = ts;

  0232e	8b 45 28	 mov	 eax, DWORD PTR ts$[rbp]
  02331	89 45 10	 mov	 DWORD PTR ps$[rbp], eax

; 5445 : 
; 5446 :                     /* ccwaddr and flags match each CCW encountered */
; 5447 :                     if (prevccwaddr != prefetch.ccwaddr[ps])

  02334	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  02337	8b 84 85 d0 02
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax*4+272]
  0233e	39 45 68	 cmp	 DWORD PTR prevccwaddr$[rbp], eax
  02341	74 50		 je	 SHORT $LN171@s390_execu

; 5448 :                     {
; 5449 :                         flags = prefetch.ccwflags[ps];

  02343	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  02346	0f b6 84 05 d0
	12 00 00	 movzx	 eax, BYTE PTR prefetch$[rbp+rax+4368]
  0234e	88 45 08	 mov	 BYTE PTR flags$[rbp], al

; 5450 :                         prevccwaddr = prefetch.ccwaddr[ps];

  02351	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  02354	8b 84 85 d0 02
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax*4+272]
  0235b	89 45 68	 mov	 DWORD PTR prevccwaddr$[rbp], eax

; 5451 :                         residual = count = prefetch.ccwcount[ps];

  0235e	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  02361	0f b7 84 45 d0
	13 00 00	 movzx	 eax, WORD PTR prefetch$[rbp+rax*2+4624]
  02369	89 45 18	 mov	 DWORD PTR count$[rbp], eax
  0236c	8b 45 18	 mov	 eax, DWORD PTR count$[rbp]
  0236f	89 45 30	 mov	 DWORD PTR residual$[rbp], eax

; 5452 : 
; 5453 :                         /* Raise PCI interrupt */
; 5454 :                         if (flags & CCW_FLAGS_PCI)

  02372	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  02376	83 e0 08	 and	 eax, 8
  02379	85 c0		 test	 eax, eax
  0237b	74 16		 je	 SHORT $LN172@s390_execu

; 5455 :                             ARCH_DEP(raise_pci) (dev, ccwkey, ccwfmt,

  0237d	44 8b 4d 68	 mov	 r9d, DWORD PTR prevccwaddr$[rbp]
  02381	44 0f b6 45 0b	 movzx	 r8d, BYTE PTR ccwfmt$[rbp]
  02386	0f b6 55 14	 movzx	 edx, BYTE PTR ccwkey$[rbp]
  0238a	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0238e	e8 00 00 00 00	 call	 s390_raise_pci
$LN172@s390_execu:
$LN171@s390_execu:

; 5456 :                                                  prevccwaddr);
; 5457 :                     }
; 5458 : 
; 5459 :                     /* Adjust counts */
; 5460 :                     if (prefetch.datalen[ps])

  02393	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  02396	83 bc 85 d0 06
	00 00 00	 cmp	 DWORD PTR prefetch$[rbp+rax*4+1296], 0
  0239e	74 5a		 je	 SHORT $LN173@s390_execu

; 5461 :                     {
; 5462 :                         if (residual >= prefetch.datalen[ps])

  023a0	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  023a3	8b 84 85 d0 06
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax*4+1296]
  023aa	39 45 30	 cmp	 DWORD PTR residual$[rbp], eax
  023ad	72 16		 jb	 SHORT $LN174@s390_execu

; 5463 :                             residual -= prefetch.datalen[ps];

  023af	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  023b2	8b 84 85 d0 06
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax*4+1296]
  023b9	8b 4d 30	 mov	 ecx, DWORD PTR residual$[rbp]
  023bc	2b c8		 sub	 ecx, eax
  023be	8b c1		 mov	 eax, ecx
  023c0	89 45 30	 mov	 DWORD PTR residual$[rbp], eax
  023c3	eb 07		 jmp	 SHORT $LN175@s390_execu
$LN174@s390_execu:

; 5464 :                         else
; 5465 :                             residual = 0;

  023c5	c7 45 30 00 00
	00 00		 mov	 DWORD PTR residual$[rbp], 0
$LN175@s390_execu:

; 5466 : 
; 5467 :                         if (prefetch_remaining >= prefetch.datalen[ps])

  023cc	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  023cf	8b 84 85 d0 06
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax*4+1296]
  023d6	39 45 7c	 cmp	 DWORD PTR prefetch_remaining$[rbp], eax
  023d9	72 16		 jb	 SHORT $LN176@s390_execu

; 5468 :                             prefetch_remaining -= prefetch.datalen[ps];

  023db	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  023de	8b 84 85 d0 06
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax*4+1296]
  023e5	8b 4d 7c	 mov	 ecx, DWORD PTR prefetch_remaining$[rbp]
  023e8	2b c8		 sub	 ecx, eax
  023ea	8b c1		 mov	 eax, ecx
  023ec	89 45 7c	 mov	 DWORD PTR prefetch_remaining$[rbp], eax
  023ef	eb 09		 jmp	 SHORT $LN177@s390_execu
$LN176@s390_execu:

; 5469 :                         else
; 5470 :                         {
; 5471 :                             prefetch_remaining = 0;

  023f1	c7 45 7c 00 00
	00 00		 mov	 DWORD PTR prefetch_remaining$[rbp], 0

; 5472 :                             break;

  023f8	eb 27		 jmp	 SHORT $LN14@s390_execu
$LN177@s390_execu:
$LN173@s390_execu:

; 5473 :                         }
; 5474 :                     }
; 5475 : 
; 5476 :                     /* Check for prefetch replay completed */
; 5477 :                     if (prefetch.chanstat[ps] ||

  023fa	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  023fd	0f b6 84 05 d0
	01 00 00	 movzx	 eax, BYTE PTR prefetch$[rbp+rax+16]
  02405	85 c0		 test	 eax, eax
  02407	75 11		 jne	 SHORT $LN179@s390_execu
  02409	83 7d 7c 00	 cmp	 DWORD PTR prefetch_remaining$[rbp], 0
  0240d	75 0d		 jne	 SHORT $LN178@s390_execu
  0240f	8b 85 c0 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp]
  02415	39 45 10	 cmp	 DWORD PTR ps$[rbp], eax
  02418	72 02		 jb	 SHORT $LN178@s390_execu
$LN179@s390_execu:

; 5478 :                         (!prefetch_remaining &&
; 5479 :                          (ps >= prefetch.seq)))
; 5480 :                         break;

  0241a	eb 05		 jmp	 SHORT $LN14@s390_execu
$LN178@s390_execu:

; 5481 : 
; 5482 :                 }

  0241c	e9 f6 fe ff ff	 jmp	 $LN13@s390_execu
$LN14@s390_execu:

; 5483 : 
; 5484 :                 /* Update SCSW CCW address and channel status */
; 5485 :                 ccwaddr  = prefetch.ccwaddr[ps];

  02421	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  02424	8b 84 85 d0 02
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax*4+272]
  0242b	89 45 20	 mov	 DWORD PTR ccwaddr$[rbp], eax

; 5486 :                 chanstat = prefetch.chanstat[ps];

  0242e	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  02431	0f b6 84 05 d0
	01 00 00	 movzx	 eax, BYTE PTR prefetch$[rbp+rax+16]
  02439	88 45 09	 mov	 BYTE PTR chanstat$[rbp], al

; 5487 : 
; 5488 :             } /* End prefetch status update */

  0243c	e9 33 01 00 00	 jmp	 $LN170@s390_execu
$LN169@s390_execu:

; 5489 : 
; 5490 : 
; 5491 :             /* For READ, SENSE, and READ BACKWARD operations, copy data
; 5492 :                from channel buffer to main storage, unless SKIP is set
; 5493 :             */
; 5494 :             else if (1
; 5495 :                 && !dev->is_immed
; 5496 :                 && !skip_ccws
; 5497 :                 && !(flags & CCW_FLAGS_SKIP)
; 5498 :                 && (0

  02441	33 c0		 xor	 eax, eax
  02443	83 f8 01	 cmp	 eax, 1
  02446	0f 84 28 01 00
	00		 je	 $LN180@s390_execu
  0244c	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02450	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  02457	0f 85 17 01 00
	00		 jne	 $LN180@s390_execu
  0245d	83 7d 64 00	 cmp	 DWORD PTR skip_ccws$[rbp], 0
  02461	0f 85 0d 01 00
	00		 jne	 $LN180@s390_execu
  02467	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  0246b	83 e0 10	 and	 eax, 16
  0246e	85 c0		 test	 eax, eax
  02470	0f 85 fe 00 00
	00		 jne	 $LN180@s390_execu
  02476	33 c0		 xor	 eax, eax
  02478	85 c0		 test	 eax, eax
  0247a	75 3d		 jne	 SHORT $LN181@s390_execu
  0247c	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02480	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  02487	83 e0 03	 and	 eax, 3
  0248a	83 f8 02	 cmp	 eax, 2
  0248d	74 2a		 je	 SHORT $LN181@s390_execu
  0248f	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02493	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  0249a	83 e0 0f	 and	 eax, 15
  0249d	83 f8 04	 cmp	 eax, 4
  024a0	74 17		 je	 SHORT $LN181@s390_execu
  024a2	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  024a6	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  024ad	83 e0 0f	 and	 eax, 15
  024b0	83 f8 0c	 cmp	 eax, 12
  024b3	0f 85 bb 00 00
	00		 jne	 $LN180@s390_execu
$LN181@s390_execu:

; 5499 :                     || IS_CCW_READ(   dev->code )
; 5500 :                     || IS_CCW_SENSE(  dev->code )
; 5501 :                     || IS_CCW_RDBACK( dev->code )
; 5502 :                    )
; 5503 :             )
; 5504 :             {
; 5505 :                 /* Copy data from I/O buffer to main storage */
; 5506 :                 ARCH_DEP(copy_iobuf) (dev, ccw, dev->code, flags, addr,

  024b9	48 8b 45 58	 mov	 rax, QWORD PTR iobuf$[rbp]
  024bd	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  024c3	8b 4d 30	 mov	 ecx, DWORD PTR residual$[rbp]
  024c6	8b 55 18	 mov	 edx, DWORD PTR count$[rbp]
  024c9	2b d1		 sub	 edx, ecx
  024cb	8b ca		 mov	 ecx, edx
  024cd	48 8d 95 c0 01
	00 00		 lea	 rdx, QWORD PTR prefetch$[rbp]
  024d4	48 89 54 24 70	 mov	 QWORD PTR [rsp+112], rdx
  024d9	48 8d 55 30	 lea	 rdx, QWORD PTR residual$[rbp]
  024dd	48 89 54 24 68	 mov	 QWORD PTR [rsp+104], rdx
  024e2	48 8d 55 09	 lea	 rdx, QWORD PTR chanstat$[rbp]
  024e6	48 89 54 24 60	 mov	 QWORD PTR [rsp+96], rdx
  024eb	48 8b 55 58	 mov	 rdx, QWORD PTR iobuf$[rbp]
  024ef	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  024f3	48 89 54 24 58	 mov	 QWORD PTR [rsp+88], rdx
  024f8	48 8b 55 58	 mov	 rdx, QWORD PTR iobuf$[rbp]
  024fc	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  02500	48 89 54 24 50	 mov	 QWORD PTR [rsp+80], rdx
  02505	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0250a	0f b7 45 44	 movzx	 eax, WORD PTR idapmask$[rbp]
  0250e	66 89 44 24 40	 mov	 WORD PTR [rsp+64], ax
  02513	0f b6 45 16	 movzx	 eax, BYTE PTR idawfmt$[rbp]
  02517	88 44 24 38	 mov	 BYTE PTR [rsp+56], al
  0251b	0f b6 45 14	 movzx	 eax, BYTE PTR ccwkey$[rbp]
  0251f	88 44 24 30	 mov	 BYTE PTR [rsp+48], al
  02523	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  02527	8b 45 24	 mov	 eax, DWORD PTR addr$[rbp]
  0252a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0252e	44 0f b6 4d 08	 movzx	 r9d, BYTE PTR flags$[rbp]
  02533	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02537	44 0f b6 80 7a
	02 00 00	 movzx	 r8d, BYTE PTR [rax+634]
  0253f	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR ccw$[rbp]
  02546	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0254a	e8 00 00 00 00	 call	 s390_copy_iobuf

; 5507 :                                       count - residual, ccwkey,
; 5508 :                                       idawfmt, idapmask,
; 5509 :                                       iobuf->data,
; 5510 :                                       iobuf->start, iobuf->end,
; 5511 :                                       &chanstat, &residual, &prefetch);
; 5512 : 
; 5513 :                 /* Update number of bytes in channel buffer */
; 5514 :                 bufpos = prefetch.pos;

  0254f	8b 85 c4 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp+4]
  02555	89 45 60	 mov	 DWORD PTR bufpos$[rbp], eax

; 5515 : 
; 5516 :                 /* If error during copy, skip remaining CD CCWs */
; 5517 :                 if (chanstat && (flags & CCW_FLAGS_CD))

  02558	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  0255c	85 c0		 test	 eax, eax
  0255e	74 14		 je	 SHORT $LN182@s390_execu
  02560	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  02564	25 80 00 00 00	 and	 eax, 128		; 00000080H
  02569	85 c0		 test	 eax, eax
  0256b	74 07		 je	 SHORT $LN182@s390_execu

; 5518 :                     skip_ccws = 1;

  0256d	c7 45 64 01 00
	00 00		 mov	 DWORD PTR skip_ccws$[rbp], 1
$LN182@s390_execu:
$LN180@s390_execu:
$LN170@s390_execu:
$LN167@s390_execu:
$LN163@s390_execu:

; 5519 :             }
; 5520 :         }
; 5521 : 
; 5522 :         /* Check for incorrect length */
; 5523 :         if ((residual || more)
; 5524 :             && !(chanstat & ~(CSW_PCI | CSW_IL)))

  02574	83 7d 30 00	 cmp	 DWORD PTR residual$[rbp], 0
  02578	75 0c		 jne	 SHORT $LN184@s390_execu
  0257a	0f b6 45 40	 movzx	 eax, BYTE PTR more$[rbp]
  0257e	85 c0		 test	 eax, eax
  02580	0f 84 aa 00 00
	00		 je	 $LN183@s390_execu
$LN184@s390_execu:
  02586	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  0258a	25 3f ff ff ff	 and	 eax, -193		; ffffffffffffff3fH
  0258f	85 c0		 test	 eax, eax
  02591	0f 85 99 00 00
	00		 jne	 $LN183@s390_execu

; 5525 :         {
; 5526 :             /* Set incorrect length status if not suppressed         */
; 5527 :             /* SA22-7201-05:                                         */
; 5528 :             /*  pp. 16-24 -- 16-25, Incorrect Length                 */
; 5529 :             /* GA22-7000-10:                                         */
; 5530 :             /*  p. 13-70, Incorrect Length                           */
; 5531 :             /*
; 5532 : 
; 5533 :             The SLI bit in the CCW ALWAYS suppresses incorrect length,
; 5534 :             regardless of Format-0 or Format-1 and regardless of whether
; 5535 :             the CCW is an immediate operation or not and regardless of
; 5536 :             whether the count field is zero or not (i.e. regardless of
; 5537 :             whether there is a residual or not).
; 5538 : 
; 5539 :             Incorrect length is also NEVER indicated for an immediate
; 5540 :             operation if the count field is zero, REGARDLESS of the
; 5541 :             SLI bit setting. This however only pertains to Format-1
; 5542 :             CCWs as only Format-1 CCWs may contain a length field of
; 5543 :             zero. The length field for a Format-0 CCW must always have
; 5544 :             a non-zero value from 1 to 65,535.
; 5545 : 
; 5546 :             So we only need to check for possible incorrect length
; 5547 :             if we have a residual.
; 5548 : 
; 5549 :             BUT... when:
; 5550 : 
; 5551 :                 a)  the CCW is an IMMEDIATE operation, and
; 5552 :                 b)  SLI bit NOT set (is zero), and
; 5553 :                 c)  the count field (residual) is non-zero,
; 5554 : 
; 5555 :             Then:
; 5556 : 
; 5557 :               Format-0:  Incorrect length is always SUPPRESSED.
; 5558 : 
; 5559 :               Format-1:  Incorrect length is always INDICATED...
; 5560 :                          UNLESS Incorrect-Length-Suppression Mode
; 5561 :                          is requested via the ORB 'L' flag!
; 5562 : 
; 5563 :                          That is to say, without the 'L' flag, Incor-
; 5564 :                          rect Length errors WILL occur for Format-1
; 5565 :                          immediate operations when there's a residual.
; 5566 : 
; 5567 :                          The ORB 'L' flag however, SUPPRESSES Incorrect
; 5568 :                          Length error for Format-1 immediate operations
; 5569 :                          causing them to behave the same as Format-0.
; 5570 :             */
; 5571 :             if (((residual && !(flags & CCW_FLAGS_SLI)) ||
; 5572 :                  ((more || (residual && prefetch.seq)) &&
; 5573 :                   !(flags & (CCW_FLAGS_CD | CCW_FLAGS_SLI))))
; 5574 : 
; 5575 :                 && !(dev->is_immed && (flags & CCW_FLAGS_CC))  /* DSF Debug */
; 5576 : 
; 5577 :                 && (0

  02597	83 7d 30 00	 cmp	 DWORD PTR residual$[rbp], 0
  0259b	74 0b		 je	 SHORT $LN187@s390_execu
  0259d	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  025a1	83 e0 20	 and	 eax, 32			; 00000020H
  025a4	85 c0		 test	 eax, eax
  025a6	74 24		 je	 SHORT $LN186@s390_execu
$LN187@s390_execu:
  025a8	0f b6 45 40	 movzx	 eax, BYTE PTR more$[rbp]
  025ac	85 c0		 test	 eax, eax
  025ae	75 0f		 jne	 SHORT $LN188@s390_execu
  025b0	83 7d 30 00	 cmp	 DWORD PTR residual$[rbp], 0
  025b4	74 7a		 je	 SHORT $LN185@s390_execu
  025b6	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  025bd	74 71		 je	 SHORT $LN185@s390_execu
$LN188@s390_execu:
  025bf	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  025c3	25 a0 00 00 00	 and	 eax, 160		; 000000a0H
  025c8	85 c0		 test	 eax, eax
  025ca	75 64		 jne	 SHORT $LN185@s390_execu
$LN186@s390_execu:
  025cc	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  025d0	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  025d7	74 0b		 je	 SHORT $LN189@s390_execu
  025d9	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  025dd	83 e0 40	 and	 eax, 64			; 00000040H
  025e0	85 c0		 test	 eax, eax
  025e2	75 4c		 jne	 SHORT $LN185@s390_execu
$LN189@s390_execu:
  025e4	33 c0		 xor	 eax, eax
  025e6	85 c0		 test	 eax, eax
  025e8	75 3c		 jne	 SHORT $LN190@s390_execu
  025ea	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  025ee	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  025f5	74 2f		 je	 SHORT $LN190@s390_execu
  025f7	33 c0		 xor	 eax, eax
  025f9	83 f8 01	 cmp	 eax, 1
  025fc	74 32		 je	 SHORT $LN185@s390_execu
  025fe	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02602	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  02609	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0260e	85 c0		 test	 eax, eax
  02610	74 1e		 je	 SHORT $LN185@s390_execu
  02612	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02616	0f b6 80 d3 02
	00 00		 movzx	 eax, BYTE PTR [rax+723]
  0261d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  02622	85 c0		 test	 eax, eax
  02624	75 0a		 jne	 SHORT $LN185@s390_execu
$LN190@s390_execu:

; 5578 :                     || !dev->is_immed
; 5579 : #if defined( FEATURE_INCORRECT_LENGTH_INDICATION_SUPPRESSION )
; 5580 : 
; 5581 :                     /* Immediate operation. If Format-1 WITHOUT the
; 5582 :                        ORB 'L' flag, then Incorrect Length. Otherwise
; 5583 :                        if Format-0, or Format-1 WITH Incorrect Length
; 5584 :                        Suppresion enabled, then IL is NOT indicated
; 5585 :                        (i.e. is SUPPRESSED).
; 5586 :                     */
; 5587 :                     || (1
; 5588 :                         &&  (dev->orb.flag5 & ORB5_F)
; 5589 :                         && !(dev->orb.flag7 & ORB7_L)
; 5590 :                        )
; 5591 : #endif /* defined( FEATURE_INCORRECT_LENGTH_INDICATION_SUPPRESSION ) */
; 5592 :                    )
; 5593 :             )
; 5594 :                 chanstat |= CSW_IL;

  02626	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  0262a	83 c8 40	 or	 eax, 64			; 00000040H
  0262d	88 45 09	 mov	 BYTE PTR chanstat$[rbp], al
$LN185@s390_execu:
$LN183@s390_execu:
$breakchain$327:

; 5595 :         }
; 5596 : 
; 5597 : breakchain:
; 5598 : 
; 5599 :         if (unlikely((chanstat & (CSW_PROGC | CSW_PROTC | CSW_CDC |

  02630	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  02634	83 e0 3f	 and	 eax, 63			; 0000003fH
  02637	85 c0		 test	 eax, eax
  02639	75 30		 jne	 SHORT $LN282@s390_execu
  0263b	0f b6 45 0c	 movzx	 eax, BYTE PTR unitstat$[rbp]
  0263f	83 e0 02	 and	 eax, 2
  02642	85 c0		 test	 eax, eax
  02644	74 19		 je	 SHORT $LN281@s390_execu
  02646	b8 01 00 00 00	 mov	 eax, 1
  0264b	48 6b c0 00	 imul	 rax, rax, 0
  0264f	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02653	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  0265b	85 c0		 test	 eax, eax
  0265d	75 0c		 jne	 SHORT $LN282@s390_execu
$LN281@s390_execu:
  0265f	c7 85 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1652[rbp], 0
  02669	eb 0a		 jmp	 SHORT $LN286@s390_execu
$LN282@s390_execu:
  0266b	c7 85 d4 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv1652[rbp], 1
$LN286@s390_execu:
  02675	83 bd d4 00 00
	00 00		 cmp	 DWORD PTR tv1652[rbp], 0
  0267c	0f 84 dd 02 00
	00		 je	 $LN191@s390_execu

; 5600 :                                   CSW_CCC   | CSW_ICC   | CSW_CHC))
; 5601 :                   || ((unitstat & CSW_UC) && dev->sense[0])))
; 5602 :         {
; 5603 : 
; 5604 :             BYTE  tracing_active  = CCW_TRACING_ACTIVE( dev, tracethis );

  02682	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02686	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0268c	c1 e8 0f	 shr	 eax, 15
  0268f	83 e0 01	 and	 eax, 1
  02692	85 c0		 test	 eax, eax
  02694	75 14		 jne	 SHORT $LN287@s390_execu
  02696	0f b6 45 15	 movzx	 eax, BYTE PTR tracethis$[rbp]
  0269a	85 c0		 test	 eax, eax
  0269c	75 0c		 jne	 SHORT $LN287@s390_execu
  0269e	c7 85 d8 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1660[rbp], 0
  026a8	eb 0a		 jmp	 SHORT $LN288@s390_execu
$LN287@s390_execu:
  026aa	c7 85 d8 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv1660[rbp], 1
$LN288@s390_execu:
  026b4	0f b6 85 d8 00
	00 00		 movzx	 eax, BYTE PTR tv1660[rbp]
  026bb	88 45 6c	 mov	 BYTE PTR tracing_active$6[rbp], al

; 5605 :             BYTE  cpu_tracing     = CPU_STEPPING_OR_TRACING_ALL;

  026be	b8 08 00 00 00	 mov	 eax, 8
  026c3	48 6b c0 00	 imul	 rax, rax, 0
  026c7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  026ce	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  026d7	75 32		 jne	 SHORT $LN289@s390_execu
  026d9	b8 08 00 00 00	 mov	 eax, 8
  026de	48 6b c0 01	 imul	 rax, rax, 1
  026e2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  026e9	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  026f2	75 17		 jne	 SHORT $LN289@s390_execu
  026f4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  026fb	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  02701	c1 e8 0a	 shr	 eax, 10
  02704	83 e0 01	 and	 eax, 1
  02707	85 c0		 test	 eax, eax
  02709	75 4e		 jne	 SHORT $LN291@s390_execu
$LN289@s390_execu:
  0270b	b8 08 00 00 00	 mov	 eax, 8
  02710	48 6b c0 00	 imul	 rax, rax, 0
  02714	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0271b	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  02724	75 27		 jne	 SHORT $LN290@s390_execu
  02726	b8 08 00 00 00	 mov	 eax, 8
  0272b	48 6b c0 01	 imul	 rax, rax, 1
  0272f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  02736	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  0273f	75 0c		 jne	 SHORT $LN290@s390_execu
  02741	e8 00 00 00 00	 call	 insttrace_all
  02746	0f b6 c0	 movzx	 eax, al
  02749	85 c0		 test	 eax, eax
  0274b	75 0c		 jne	 SHORT $LN291@s390_execu
$LN290@s390_execu:
  0274d	c7 85 dc 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1685[rbp], 0
  02757	eb 0a		 jmp	 SHORT $LN292@s390_execu
$LN291@s390_execu:
  02759	c7 85 dc 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv1685[rbp], 1
$LN292@s390_execu:
  02763	0f b6 85 dc 00
	00 00		 movzx	 eax, BYTE PTR tv1685[rbp]
  0276a	88 45 4a	 mov	 BYTE PTR cpu_tracing$4[rbp], al

; 5606 :             BYTE  ostailor_quiet  = (sysblk.pgminttr == 0);

  0276d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  02774	48 83 b8 48 13
	00 00 00	 cmp	 QWORD PTR [rax+4936], 0
  0277c	75 0c		 jne	 SHORT $LN293@s390_execu
  0277e	c7 85 e0 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv1689[rbp], 1
  02788	eb 0a		 jmp	 SHORT $LN294@s390_execu
$LN293@s390_execu:
  0278a	c7 85 e0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1689[rbp], 0
$LN294@s390_execu:
  02794	0f b6 85 e0 00
	00 00		 movzx	 eax, BYTE PTR tv1689[rbp]
  0279b	88 45 48	 mov	 BYTE PTR ostailor_quiet$2[rbp], al

; 5607 :             BYTE  ccw_tracing     = dev->ccwtrace;

  0279e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  027a2	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  027a8	c1 e8 0f	 shr	 eax, 15
  027ab	83 e0 01	 and	 eax, 1
  027ae	88 45 54	 mov	 BYTE PTR ccw_tracing$5[rbp], al

; 5608 :             BYTE  skip_ch9uc      = SKIP_CH9UC( dev, chanstat, unitstat );

  027b1	33 c0		 xor	 eax, eax
  027b3	83 f8 01	 cmp	 eax, 1
  027b6	0f 84 e3 00 00
	00		 je	 $LN295@s390_execu
  027bc	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  027c0	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  027c6	c1 e8 0f	 shr	 eax, 15
  027c9	83 e0 01	 and	 eax, 1
  027cc	85 c0		 test	 eax, eax
  027ce	0f 85 cb 00 00
	00		 jne	 $LN295@s390_execu
  027d4	b8 08 00 00 00	 mov	 eax, 8
  027d9	48 6b c0 00	 imul	 rax, rax, 0
  027dd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  027e4	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  027ed	75 32		 jne	 SHORT $LN296@s390_execu
  027ef	b8 08 00 00 00	 mov	 eax, 8
  027f4	48 6b c0 01	 imul	 rax, rax, 1
  027f8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  027ff	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  02808	75 17		 jne	 SHORT $LN296@s390_execu
  0280a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  02811	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  02817	c1 e8 0a	 shr	 eax, 10
  0281a	83 e0 01	 and	 eax, 1
  0281d	85 c0		 test	 eax, eax
  0281f	75 7e		 jne	 SHORT $LN298@s390_execu
$LN296@s390_execu:
  02821	b8 08 00 00 00	 mov	 eax, 8
  02826	48 6b c0 00	 imul	 rax, rax, 0
  0282a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  02831	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  0283a	75 27		 jne	 SHORT $LN297@s390_execu
  0283c	b8 08 00 00 00	 mov	 eax, 8
  02841	48 6b c0 01	 imul	 rax, rax, 1
  02845	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0284c	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  02855	75 0c		 jne	 SHORT $LN297@s390_execu
  02857	e8 00 00 00 00	 call	 insttrace_all
  0285c	0f b6 c0	 movzx	 eax, al
  0285f	85 c0		 test	 eax, eax
  02861	75 3c		 jne	 SHORT $LN298@s390_execu
$LN297@s390_execu:
  02863	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0286a	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  02870	c1 e8 19	 shr	 eax, 25
  02873	83 e0 01	 and	 eax, 1
  02876	85 c0		 test	 eax, eax
  02878	74 25		 je	 SHORT $LN295@s390_execu
  0287a	44 0f b6 45 0c	 movzx	 r8d, BYTE PTR unitstat$[rbp]
  0287f	0f b6 55 09	 movzx	 edx, BYTE PTR chanstat$[rbp]
  02883	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02887	e8 00 00 00 00	 call	 is_ch9oflow
  0288c	0f b6 c0	 movzx	 eax, al
  0288f	85 c0		 test	 eax, eax
  02891	74 0c		 je	 SHORT $LN295@s390_execu
  02893	c7 85 e4 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv1733[rbp], 1
  0289d	eb 0a		 jmp	 SHORT $LN299@s390_execu
$LN295@s390_execu:
$LN298@s390_execu:
  0289f	c7 85 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1733[rbp], 0
$LN299@s390_execu:
  028a9	0f b6 85 e4 00
	00 00		 movzx	 eax, BYTE PTR tv1733[rbp]
  028b0	88 45 49	 mov	 BYTE PTR skip_ch9uc$3[rbp], al

; 5609 : 
; 5610 :             /* Trace the CCW if not already done */
; 5611 :             if (1
; 5612 :                 && !tracing_active
; 5613 :                 && (0
; 5614 :                     || cpu_tracing
; 5615 :                     || !ostailor_quiet
; 5616 :                     || ccw_tracing
; 5617 :                    )
; 5618 :                 && !skip_ch9uc

  028b3	33 c0		 xor	 eax, eax
  028b5	83 f8 01	 cmp	 eax, 1
  028b8	74 72		 je	 SHORT $LN193@s390_execu
  028ba	0f b6 45 6c	 movzx	 eax, BYTE PTR tracing_active$6[rbp]
  028be	85 c0		 test	 eax, eax
  028c0	75 6a		 jne	 SHORT $LN193@s390_execu
  028c2	33 c0		 xor	 eax, eax
  028c4	85 c0		 test	 eax, eax
  028c6	75 18		 jne	 SHORT $LN194@s390_execu
  028c8	0f b6 45 4a	 movzx	 eax, BYTE PTR cpu_tracing$4[rbp]
  028cc	85 c0		 test	 eax, eax
  028ce	75 10		 jne	 SHORT $LN194@s390_execu
  028d0	0f b6 45 48	 movzx	 eax, BYTE PTR ostailor_quiet$2[rbp]
  028d4	85 c0		 test	 eax, eax
  028d6	74 08		 je	 SHORT $LN194@s390_execu
  028d8	0f b6 45 54	 movzx	 eax, BYTE PTR ccw_tracing$5[rbp]
  028dc	85 c0		 test	 eax, eax
  028de	74 4c		 je	 SHORT $LN193@s390_execu
$LN194@s390_execu:
  028e0	0f b6 45 49	 movzx	 eax, BYTE PTR skip_ch9uc$3[rbp]
  028e4	85 c0		 test	 eax, eax
  028e6	75 44		 jne	 SHORT $LN193@s390_execu

; 5619 :             )
; 5620 :             {
; 5621 :                 ioerror = 1;

  028e8	c6 45 2c 01	 mov	 BYTE PTR ioerror$[rbp], 1

; 5622 :                 DISPLAY_CCW (dev, ccw, addr, count, flags);

  028ec	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG182754
  028f3	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  028f8	c7 44 24 30 f6
	15 00 00	 mov	 DWORD PTR [rsp+48], 5622 ; 000015f6H
  02900	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG182755
  02907	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0290c	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  02910	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  02914	44 8b 4d 18	 mov	 r9d, DWORD PTR count$[rbp]
  02918	44 8b 45 24	 mov	 r8d, DWORD PTR addr$[rbp]
  0291c	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR ccw$[rbp]
  02923	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02927	e8 00 00 00 00	 call	 _display_ccw
$LN193@s390_execu:

; 5623 :             }
; 5624 : 
; 5625 :             /* Activate tracing for this CCW chain only
; 5626 :                if any trace is already active */
; 5627 :             if (0
; 5628 :                 || ccw_tracing
; 5629 :                 || cpu_tracing
; 5630 :                 || (1

  0292c	33 c0		 xor	 eax, eax
  0292e	85 c0		 test	 eax, eax
  02930	75 27		 jne	 SHORT $LN196@s390_execu
  02932	0f b6 45 54	 movzx	 eax, BYTE PTR ccw_tracing$5[rbp]
  02936	85 c0		 test	 eax, eax
  02938	75 1f		 jne	 SHORT $LN196@s390_execu
  0293a	0f b6 45 4a	 movzx	 eax, BYTE PTR cpu_tracing$4[rbp]
  0293e	85 c0		 test	 eax, eax
  02940	75 17		 jne	 SHORT $LN196@s390_execu
  02942	33 c0		 xor	 eax, eax
  02944	83 f8 01	 cmp	 eax, 1
  02947	74 14		 je	 SHORT $LN195@s390_execu
  02949	0f b6 45 48	 movzx	 eax, BYTE PTR ostailor_quiet$2[rbp]
  0294d	85 c0		 test	 eax, eax
  0294f	75 0c		 jne	 SHORT $LN195@s390_execu
  02951	0f b6 45 49	 movzx	 eax, BYTE PTR skip_ch9uc$3[rbp]
  02955	85 c0		 test	 eax, eax
  02957	75 04		 jne	 SHORT $LN195@s390_execu
$LN196@s390_execu:

; 5631 :                     && !ostailor_quiet
; 5632 :                     && !skip_ch9uc
; 5633 :                    )
; 5634 :             )
; 5635 :             {
; 5636 :                 tracethis = 1;

  02959	c6 45 15 01	 mov	 BYTE PTR tracethis$[rbp], 1
$LN195@s390_execu:

; 5637 :             }
; 5638 :         }

  0295d	eb 04		 jmp	 SHORT $LN192@s390_execu
$LN191@s390_execu:

; 5639 :         else
; 5640 :             ioerror = 0;

  0295f	c6 45 2c 00	 mov	 BYTE PTR ioerror$[rbp], 0
$LN192@s390_execu:

; 5641 : 
; 5642 :         /* Trace the results of CCW execution */
; 5643 :         if (unlikely( CCW_TRACING_ACTIVE( dev, tracethis )))

  02963	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02967	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0296d	c1 e8 0f	 shr	 eax, 15
  02970	83 e0 01	 and	 eax, 1
  02973	85 c0		 test	 eax, eax
  02975	75 14		 jne	 SHORT $LN300@s390_execu
  02977	0f b6 45 15	 movzx	 eax, BYTE PTR tracethis$[rbp]
  0297b	85 c0		 test	 eax, eax
  0297d	75 0c		 jne	 SHORT $LN300@s390_execu
  0297f	c7 85 e8 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1780[rbp], 0
  02989	eb 0a		 jmp	 SHORT $LN303@s390_execu
$LN300@s390_execu:
  0298b	c7 85 e8 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv1780[rbp], 1
$LN303@s390_execu:
  02995	83 bd e8 00 00
	00 00		 cmp	 DWORD PTR tv1780[rbp], 0
  0299c	0f 84 bd 08 00
	00		 je	 $LN197@s390_execu

; 5644 :         {
; 5645 : #if DEBUG_PREFETCH
; 5646 :             if (!prefetch.seq)
; 5647 :             {
; 5648 :                 char msgbuf[133];
; 5649 :                 MSGBUF( msgbuf, "flags=%2.2X count=%d (%4.4X) "
; 5650 :                                 "residual=%d (%4.4X) "
; 5651 :                                 "more=%d "
; 5652 :                                 "bufpos=%d",
; 5653 :                                 flags,
; 5654 :                                 count, count,
; 5655 :                                 residual, residual,
; 5656 :                                 more, bufpos );
; 5657 :                 WRMSG( HHC01392, "D", msgbuf );
; 5658 :             }
; 5659 : #endif
; 5660 : 
; 5661 :             /* Display prefetch data */
; 5662 :             if (prefetch.seq)

  029a2	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  029a9	0f 84 56 01 00
	00		 je	 $LN198@s390_execu

; 5663 :             {
; 5664 :                 /* Display prefetch table */
; 5665 :                 DISPLAY_PREFETCH(&prefetch, ps, count, residual, more);
; 5666 : 
; 5667 :                 /* Loop through prefetch table for CCW/IDAW display */
; 5668 :                 for (ts = 0, prevccwaddr = 1;

  029af	c7 45 28 00 00
	00 00		 mov	 DWORD PTR ts$[rbp], 0
  029b6	c7 45 68 01 00
	00 00		 mov	 DWORD PTR prevccwaddr$[rbp], 1
  029bd	eb 08		 jmp	 SHORT $LN18@s390_execu
$LN16@s390_execu:

; 5670 :                      ts++)

  029bf	8b 45 28	 mov	 eax, DWORD PTR ts$[rbp]
  029c2	ff c0		 inc	 eax
  029c4	89 45 28	 mov	 DWORD PTR ts$[rbp], eax
$LN18@s390_execu:

; 5669 :                      ts < ps && ts < prefetch.seq;

  029c7	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  029ca	39 45 28	 cmp	 DWORD PTR ts$[rbp], eax
  029cd	0f 83 02 01 00
	00		 jae	 $LN17@s390_execu
  029d3	8b 85 c0 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp]
  029d9	39 45 28	 cmp	 DWORD PTR ts$[rbp], eax
  029dc	0f 83 f3 00 00
	00		 jae	 $LN17@s390_execu

; 5671 :                 {
; 5672 :                     if (prevccwaddr != prefetch.ccwaddr[ts])

  029e2	8b 45 28	 mov	 eax, DWORD PTR ts$[rbp]
  029e5	8b 84 85 d0 02
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax*4+272]
  029ec	39 45 68	 cmp	 DWORD PTR prevccwaddr$[rbp], eax
  029ef	74 75		 je	 SHORT $LN199@s390_execu

; 5673 :                     {
; 5674 :                         prevccwaddr = prefetch.ccwaddr[ts];

  029f1	8b 45 28	 mov	 eax, DWORD PTR ts$[rbp]
  029f4	8b 84 85 d0 02
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax*4+272]
  029fb	89 45 68	 mov	 DWORD PTR prevccwaddr$[rbp], eax

; 5675 :                         if (ts)

  029fe	83 7d 28 00	 cmp	 DWORD PTR ts$[rbp], 0
  02a02	74 62		 je	 SHORT $LN200@s390_execu

; 5676 :                         {
; 5677 :                             /* Display CCW */
; 5678 :                             DISPLAY_CCW (dev,

  02a04	8b 45 28	 mov	 eax, DWORD PTR ts$[rbp]
  02a07	8b 4d 28	 mov	 ecx, DWORD PTR ts$[rbp]
  02a0a	8b 55 28	 mov	 edx, DWORD PTR ts$[rbp]
  02a0d	8b 94 95 d0 02
	00 00		 mov	 edx, DWORD PTR prefetch$[rbp+rdx*4+272]
  02a14	83 ea 08	 sub	 edx, 8
  02a17	8b d2		 mov	 edx, edx
  02a19	48 8b 7d 00	 mov	 rdi, QWORD PTR dev$[rbp]
  02a1d	48 03 97 80 00
	00 00		 add	 rdx, QWORD PTR [rdi+128]
  02a24	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:$SG182762
  02a2b	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  02a30	c7 44 24 30 33
	16 00 00	 mov	 DWORD PTR [rsp+48], 5683 ; 00001633H
  02a38	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:$SG182763
  02a3f	48 89 7c 24 28	 mov	 QWORD PTR [rsp+40], rdi
  02a44	0f b6 7d 08	 movzx	 edi, BYTE PTR flags$[rbp]
  02a48	40 88 7c 24 20	 mov	 BYTE PTR [rsp+32], dil
  02a4d	44 8b 8c 85 d0
	06 00 00	 mov	 r9d, DWORD PTR prefetch$[rbp+rax*4+1296]
  02a55	44 8b 84 cd d0
	0a 00 00	 mov	 r8d, DWORD PTR prefetch$[rbp+rcx*8+2320]
  02a5d	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02a61	e8 00 00 00 00	 call	 _display_ccw
$LN200@s390_execu:
$LN199@s390_execu:

; 5679 :                                          dev->mainstor +
; 5680 :                                            (prefetch.ccwaddr[ts] - 8),
; 5681 :                                          prefetch.dataaddr[ts],
; 5682 :                                          prefetch.datalen[ts],
; 5683 :                                          flags);
; 5684 : 
; 5685 :                         }
; 5686 :                     }
; 5687 :                     if (prefetch.idawtype[ts])

  02a66	8b 45 28	 mov	 eax, DWORD PTR ts$[rbp]
  02a69	0f b6 84 05 d0
	19 00 00	 movzx	 eax, BYTE PTR prefetch$[rbp+rax+6160]
  02a71	85 c0		 test	 eax, eax
  02a73	74 5b		 je	 SHORT $LN201@s390_execu

; 5688 :                         DISPLAY_IDAW(dev,

  02a75	8b 45 28	 mov	 eax, DWORD PTR ts$[rbp]
  02a78	8b 4d 28	 mov	 ecx, DWORD PTR ts$[rbp]
  02a7b	8b 55 28	 mov	 edx, DWORD PTR ts$[rbp]
  02a7e	8b 7d 28	 mov	 edi, DWORD PTR ts$[rbp]
  02a81	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG182765
  02a88	4c 89 44 24 38	 mov	 QWORD PTR [rsp+56], r8
  02a8d	c7 44 24 30 3c
	16 00 00	 mov	 DWORD PTR [rsp+48], 5692 ; 0000163cH
  02a95	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG182766
  02a9c	4c 89 44 24 28	 mov	 QWORD PTR [rsp+40], r8
  02aa1	0f b7 84 85 d0
	06 00 00	 movzx	 eax, WORD PTR prefetch$[rbp+rax*4+1296]
  02aa9	66 89 44 24 20	 mov	 WORD PTR [rsp+32], ax
  02aae	4c 8b 8c cd d0
	0a 00 00	 mov	 r9, QWORD PTR prefetch$[rbp+rcx*8+2320]
  02ab6	44 0f b6 84 15
	d0 1a 00 00	 movzx	 r8d, BYTE PTR prefetch$[rbp+rdx+6416]
  02abf	0f b6 94 3d d0
	19 00 00	 movzx	 edx, BYTE PTR prefetch$[rbp+rdi+6160]
  02ac7	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02acb	e8 00 00 00 00	 call	 _display_idaw
$LN201@s390_execu:

; 5689 :                                      prefetch.idawtype[ts],
; 5690 :                                      prefetch.idawflag[ts],
; 5691 :                                      prefetch.dataaddr[ts],
; 5692 :                                      prefetch.datalen[ts]);
; 5693 :                 }

  02ad0	e9 ea fe ff ff	 jmp	 $LN16@s390_execu
$LN17@s390_execu:

; 5694 : 
; 5695 :                 /* Don't display data area on status */
; 5696 :                 area[0] = 0x00;

  02ad5	b8 01 00 00 00	 mov	 eax, 1
  02ada	48 6b c0 00	 imul	 rax, rax, 0
  02ade	48 89 85 98 01
	00 00		 mov	 QWORD PTR $T10[rbp], rax
  02ae5	48 83 bd 98 01
	00 00 40	 cmp	 QWORD PTR $T10[rbp], 64	; 00000040H
  02aed	73 02		 jae	 SHORT $LN304@s390_execu
  02aef	eb 05		 jmp	 SHORT $LN305@s390_execu
$LN304@s390_execu:
  02af1	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN305@s390_execu:
  02af6	48 8b 85 98 01
	00 00		 mov	 rax, QWORD PTR $T10[rbp]
  02afd	c6 84 05 00 30
	01 00 00	 mov	 BYTE PTR area$[rbp+rax], 0
$LN198@s390_execu:

; 5697 :             }
; 5698 : 
; 5699 :             /* Trace the read type CCW, UNLESS... the IDA/MIDA flag
; 5700 :                is on. When the IDA/MIDA flag is on for read type CCWs,
; 5701 :                the copy_iobuf function traces the CCW before it traces
; 5702 :                the IDA/MIDA.
; 5703 :             */
; 5704 :             if (1
; 5705 :                 && !(flags & CCW_FLAGS_IDA)
; 5706 :                 && !(flags & CCW_FLAGS_MIDAW)

  02b05	33 c0		 xor	 eax, eax
  02b07	83 f8 01	 cmp	 eax, 1
  02b0a	74 5e		 je	 SHORT $LN202@s390_execu
  02b0c	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  02b10	83 e0 04	 and	 eax, 4
  02b13	85 c0		 test	 eax, eax
  02b15	75 53		 jne	 SHORT $LN202@s390_execu
  02b17	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  02b1b	83 e0 01	 and	 eax, 1
  02b1e	85 c0		 test	 eax, eax
  02b20	75 48		 jne	 SHORT $LN202@s390_execu

; 5707 :             )
; 5708 :             {
; 5709 :                 /* If we're tracing due to an I/O error, then the CCW
; 5710 :                    has already been traced further above, so we DON'T
; 5711 :                    want to do it here again!
; 5712 :                 */
; 5713 :                 if (!ioerror)

  02b22	0f b6 45 2c	 movzx	 eax, BYTE PTR ioerror$[rbp]
  02b26	85 c0		 test	 eax, eax
  02b28	75 40		 jne	 SHORT $LN203@s390_execu

; 5714 :                     DISPLAY_CCW( dev, ccw, addr, count, flags );

  02b2a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG182769
  02b31	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  02b36	c7 44 24 30 52
	16 00 00	 mov	 DWORD PTR [rsp+48], 5714 ; 00001652H
  02b3e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG182770
  02b45	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  02b4a	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  02b4e	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  02b52	44 8b 4d 18	 mov	 r9d, DWORD PTR count$[rbp]
  02b56	44 8b 45 24	 mov	 r8d, DWORD PTR addr$[rbp]
  02b5a	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR ccw$[rbp]
  02b61	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02b65	e8 00 00 00 00	 call	 _display_ccw
$LN203@s390_execu:
$LN202@s390_execu:

; 5715 :             }
; 5716 : 
; 5717 :             ioerror = 0; // (reset flag)

  02b6a	c6 45 2c 00	 mov	 BYTE PTR ioerror$[rbp], 0

; 5718 : 
; 5719 :             /* Display status and residual byte count */
; 5720 : 
; 5721 :             if (dev->ccwtrace && sysblk.traceFILE)

  02b6e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02b72	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  02b78	c1 e8 0f	 shr	 eax, 15
  02b7b	83 e0 01	 and	 eax, 1
  02b7e	85 c0		 test	 eax, eax
  02b80	74 62		 je	 SHORT $LN204@s390_execu
  02b82	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  02b89	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  02b91	74 51		 je	 SHORT $LN204@s390_execu

; 5722 :                 tf_1312( dev, unitstat, chanstat, (BYTE) MIN( count, 16 ), residual, iobuf->data );

  02b93	83 7d 18 10	 cmp	 DWORD PTR count$[rbp], 16
  02b97	73 0b		 jae	 SHORT $LN306@s390_execu
  02b99	8b 45 18	 mov	 eax, DWORD PTR count$[rbp]
  02b9c	89 85 ec 00 00
	00		 mov	 DWORD PTR tv1903[rbp], eax
  02ba2	eb 0a		 jmp	 SHORT $LN307@s390_execu
$LN306@s390_execu:
  02ba4	c7 85 ec 00 00
	00 10 00 00 00	 mov	 DWORD PTR tv1903[rbp], 16
$LN307@s390_execu:
  02bae	48 8b 45 58	 mov	 rax, QWORD PTR iobuf$[rbp]
  02bb2	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  02bb8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  02bbd	8b 45 30	 mov	 eax, DWORD PTR residual$[rbp]
  02bc0	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  02bc4	44 0f b6 8d ec
	00 00 00	 movzx	 r9d, BYTE PTR tv1903[rbp]
  02bcc	44 0f b6 45 09	 movzx	 r8d, BYTE PTR chanstat$[rbp]
  02bd1	0f b6 55 0c	 movzx	 edx, BYTE PTR unitstat$[rbp]
  02bd5	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02bd9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1312
  02bdf	e9 ce 00 00 00	 jmp	 $LN205@s390_execu
$LN204@s390_execu:

; 5723 :             else
; 5724 :                 // "%1d:%04X CHAN: stat %2.2X%2.2X, count %4.4X"
; 5725 :                 WRMSG( HHC01312, "I", LCSS_DEVNUM,

  02be4	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  02be9	74 10		 je	 SHORT $LN308@s390_execu
  02beb	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02bef	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  02bf3	89 85 f0 00 00
	00		 mov	 DWORD PTR tv1916[rbp], eax
  02bf9	eb 0a		 jmp	 SHORT $LN309@s390_execu
$LN308@s390_execu:
  02bfb	c7 85 f0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1916[rbp], 0
$LN309@s390_execu:
  02c05	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  02c0a	74 12		 je	 SHORT $LN310@s390_execu
  02c0c	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02c10	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  02c14	d1 f8		 sar	 eax, 1
  02c16	89 85 f4 00 00
	00		 mov	 DWORD PTR tv1922[rbp], eax
  02c1c	eb 0a		 jmp	 SHORT $LN311@s390_execu
$LN310@s390_execu:
  02c1e	c7 85 f4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1922[rbp], 0
$LN311@s390_execu:
  02c28	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  02c2c	89 85 78 01 00
	00		 mov	 DWORD PTR tv1909[rbp], eax
  02c32	0f b6 4d 0c	 movzx	 ecx, BYTE PTR unitstat$[rbp]
  02c36	89 8d 7c 01 00
	00		 mov	 DWORD PTR tv1911[rbp], ecx
  02c3c	b9 01 00 00 00	 mov	 ecx, 1
  02c41	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02c47	8b 4d 30	 mov	 ecx, DWORD PTR residual$[rbp]
  02c4a	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  02c4e	8b 8d 78 01 00
	00		 mov	 ecx, DWORD PTR tv1909[rbp]
  02c54	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  02c58	8b 8d 7c 01 00
	00		 mov	 ecx, DWORD PTR tv1911[rbp]
  02c5e	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  02c62	8b 8d f0 00 00
	00		 mov	 ecx, DWORD PTR tv1916[rbp]
  02c68	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  02c6c	8b 8d f4 00 00
	00		 mov	 ecx, DWORD PTR tv1922[rbp]
  02c72	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  02c76	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182773
  02c7d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  02c82	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182774
  02c89	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02c8e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02c93	41 b9 03 00 00
	00		 mov	 r9d, 3
  02c99	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG182775
  02ca0	ba 5e 16 00 00	 mov	 edx, 5726		; 0000165eH
  02ca5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182776
  02cac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN205@s390_execu:

; 5726 :                     unitstat, chanstat, residual );
; 5727 : 
; 5728 :             /* Display sense bytes if unit check is indicated */
; 5729 :             if (unitstat & CSW_UC)

  02cb2	0f b6 45 0c	 movzx	 eax, BYTE PTR unitstat$[rbp]
  02cb6	83 e0 02	 and	 eax, 2
  02cb9	85 c0		 test	 eax, eax
  02cbb	0f 84 9e 05 00
	00		 je	 $LN206@s390_execu

; 5730 :             {
; 5731 :                 if (dev->ccwtrace && sysblk.traceFILE)

  02cc1	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02cc5	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  02ccb	c1 e8 0f	 shr	 eax, 15
  02cce	83 e0 01	 and	 eax, 1
  02cd1	85 c0		 test	 eax, eax
  02cd3	74 20		 je	 SHORT $LN207@s390_execu
  02cd5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  02cdc	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  02ce4	74 0f		 je	 SHORT $LN207@s390_execu

; 5732 :                     tf_1313( dev );

  02ce6	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02cea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1313
  02cf0	e9 6a 05 00 00	 jmp	 $LN208@s390_execu
$LN207@s390_execu:

; 5733 :                 else
; 5734 :                 {
; 5735 :                     register BYTE* sense = dev->sense;

  02cf5	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02cf9	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  02cff	48 89 45 38	 mov	 QWORD PTR sense$1[rbp], rax

; 5736 : 
; 5737 :                     // "%1d:%04X CHAN: sense %2.2X%2.2X%2.2X%2.2X ...
; 5738 :                     WRMSG( HHC01313, "I", LCSS_DEVNUM,

  02d03	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  02d08	74 10		 je	 SHORT $LN312@s390_execu
  02d0a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02d0e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  02d12	89 85 f8 00 00
	00		 mov	 DWORD PTR tv2075[rbp], eax
  02d18	eb 0a		 jmp	 SHORT $LN313@s390_execu
$LN312@s390_execu:
  02d1a	c7 85 f8 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv2075[rbp], 0
$LN313@s390_execu:
  02d24	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  02d29	74 12		 je	 SHORT $LN314@s390_execu
  02d2b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02d2f	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  02d33	d1 f8		 sar	 eax, 1
  02d35	89 85 fc 00 00
	00		 mov	 DWORD PTR tv2081[rbp], eax
  02d3b	eb 0a		 jmp	 SHORT $LN315@s390_execu
$LN314@s390_execu:
  02d3d	c7 85 fc 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv2081[rbp], 0
$LN315@s390_execu:
  02d47	b8 01 00 00 00	 mov	 eax, 1
  02d4c	48 6b c0 1f	 imul	 rax, rax, 31
  02d50	48 8b 4d 38	 mov	 rcx, QWORD PTR sense$1[rbp]
  02d54	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02d58	89 85 80 01 00
	00		 mov	 DWORD PTR tv1946[rbp], eax
  02d5e	b9 01 00 00 00	 mov	 ecx, 1
  02d63	48 6b c9 1e	 imul	 rcx, rcx, 30
  02d67	48 8b 55 38	 mov	 rdx, QWORD PTR sense$1[rbp]
  02d6b	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  02d6f	89 8d 84 01 00
	00		 mov	 DWORD PTR tv1950[rbp], ecx
  02d75	ba 01 00 00 00	 mov	 edx, 1
  02d7a	48 6b d2 1d	 imul	 rdx, rdx, 29
  02d7e	48 8b 7d 38	 mov	 rdi, QWORD PTR sense$1[rbp]
  02d82	0f b6 14 17	 movzx	 edx, BYTE PTR [rdi+rdx]
  02d86	89 95 18 01 00
	00		 mov	 DWORD PTR tv1954[rbp], edx
  02d8c	bf 01 00 00 00	 mov	 edi, 1
  02d91	48 6b ff 1c	 imul	 rdi, rdi, 28
  02d95	4c 8b 45 38	 mov	 r8, QWORD PTR sense$1[rbp]
  02d99	41 0f b6 3c 38	 movzx	 edi, BYTE PTR [r8+rdi]
  02d9e	41 b8 01 00 00
	00		 mov	 r8d, 1
  02da4	4d 6b c0 1b	 imul	 r8, r8, 27
  02da8	4c 8b 4d 38	 mov	 r9, QWORD PTR sense$1[rbp]
  02dac	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  02db1	44 89 85 1c 01
	00 00		 mov	 DWORD PTR tv1962[rbp], r8d
  02db8	41 b9 01 00 00
	00		 mov	 r9d, 1
  02dbe	4d 6b c9 1a	 imul	 r9, r9, 26
  02dc2	4c 8b 55 38	 mov	 r10, QWORD PTR sense$1[rbp]
  02dc6	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  02dcb	44 89 8d 20 01
	00 00		 mov	 DWORD PTR tv1966[rbp], r9d
  02dd2	41 ba 01 00 00
	00		 mov	 r10d, 1
  02dd8	4d 6b d2 19	 imul	 r10, r10, 25
  02ddc	4c 8b 5d 38	 mov	 r11, QWORD PTR sense$1[rbp]
  02de0	47 0f b6 14 13	 movzx	 r10d, BYTE PTR [r11+r10]
  02de5	44 89 95 24 01
	00 00		 mov	 DWORD PTR tv1970[rbp], r10d
  02dec	41 bb 01 00 00
	00		 mov	 r11d, 1
  02df2	4d 6b db 18	 imul	 r11, r11, 24
  02df6	48 8b 5d 38	 mov	 rbx, QWORD PTR sense$1[rbp]
  02dfa	42 0f b6 1c 1b	 movzx	 ebx, BYTE PTR [rbx+r11]
  02dff	41 bb 01 00 00
	00		 mov	 r11d, 1
  02e05	4d 6b db 17	 imul	 r11, r11, 23
  02e09	48 8b 75 38	 mov	 rsi, QWORD PTR sense$1[rbp]
  02e0d	42 0f b6 34 1e	 movzx	 esi, BYTE PTR [rsi+r11]
  02e12	41 bb 01 00 00
	00		 mov	 r11d, 1
  02e18	4d 6b db 16	 imul	 r11, r11, 22
  02e1c	4c 8b 75 38	 mov	 r14, QWORD PTR sense$1[rbp]
  02e20	47 0f b6 1c 1e	 movzx	 r11d, BYTE PTR [r14+r11]
  02e25	44 89 9d 28 01
	00 00		 mov	 DWORD PTR tv1982[rbp], r11d
  02e2c	41 be 01 00 00
	00		 mov	 r14d, 1
  02e32	4d 6b f6 15	 imul	 r14, r14, 21
  02e36	4c 8b 7d 38	 mov	 r15, QWORD PTR sense$1[rbp]
  02e3a	47 0f b6 34 37	 movzx	 r14d, BYTE PTR [r15+r14]
  02e3f	41 bf 01 00 00
	00		 mov	 r15d, 1
  02e45	4d 6b ff 14	 imul	 r15, r15, 20
  02e49	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  02e4d	47 0f b6 3c 3c	 movzx	 r15d, BYTE PTR [r12+r15]
  02e52	41 bc 01 00 00
	00		 mov	 r12d, 1
  02e58	4d 6b e4 13	 imul	 r12, r12, 19
  02e5c	4c 8b 6d 38	 mov	 r13, QWORD PTR sense$1[rbp]
  02e60	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02e65	44 89 a5 2c 01
	00 00		 mov	 DWORD PTR tv1994[rbp], r12d
  02e6c	41 bd 01 00 00
	00		 mov	 r13d, 1
  02e72	4d 6b ed 12	 imul	 r13, r13, 18
  02e76	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  02e7a	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02e7f	44 89 a5 30 01
	00 00		 mov	 DWORD PTR tv1998[rbp], r12d
  02e86	41 bd 01 00 00
	00		 mov	 r13d, 1
  02e8c	4d 6b ed 11	 imul	 r13, r13, 17
  02e90	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  02e94	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02e99	44 89 a5 34 01
	00 00		 mov	 DWORD PTR tv2002[rbp], r12d
  02ea0	41 bd 01 00 00
	00		 mov	 r13d, 1
  02ea6	4d 6b ed 10	 imul	 r13, r13, 16
  02eaa	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  02eae	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02eb3	44 89 a5 38 01
	00 00		 mov	 DWORD PTR tv2006[rbp], r12d
  02eba	41 bd 01 00 00
	00		 mov	 r13d, 1
  02ec0	4d 6b ed 0f	 imul	 r13, r13, 15
  02ec4	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  02ec8	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02ecd	44 89 a5 3c 01
	00 00		 mov	 DWORD PTR tv2010[rbp], r12d
  02ed4	41 bd 01 00 00
	00		 mov	 r13d, 1
  02eda	4d 6b ed 0e	 imul	 r13, r13, 14
  02ede	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  02ee2	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02ee7	44 89 a5 40 01
	00 00		 mov	 DWORD PTR tv2014[rbp], r12d
  02eee	41 bd 01 00 00
	00		 mov	 r13d, 1
  02ef4	4d 6b ed 0d	 imul	 r13, r13, 13
  02ef8	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  02efc	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02f01	44 89 a5 44 01
	00 00		 mov	 DWORD PTR tv2018[rbp], r12d
  02f08	41 bd 01 00 00
	00		 mov	 r13d, 1
  02f0e	4d 6b ed 0c	 imul	 r13, r13, 12
  02f12	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  02f16	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02f1b	44 89 a5 48 01
	00 00		 mov	 DWORD PTR tv2022[rbp], r12d
  02f22	41 bd 01 00 00
	00		 mov	 r13d, 1
  02f28	4d 6b ed 0b	 imul	 r13, r13, 11
  02f2c	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  02f30	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02f35	44 89 a5 4c 01
	00 00		 mov	 DWORD PTR tv2026[rbp], r12d
  02f3c	41 bd 01 00 00
	00		 mov	 r13d, 1
  02f42	4d 6b ed 0a	 imul	 r13, r13, 10
  02f46	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  02f4a	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02f4f	44 89 a5 50 01
	00 00		 mov	 DWORD PTR tv2030[rbp], r12d
  02f56	41 bd 01 00 00
	00		 mov	 r13d, 1
  02f5c	4d 6b ed 09	 imul	 r13, r13, 9
  02f60	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  02f64	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02f69	44 89 a5 54 01
	00 00		 mov	 DWORD PTR tv2034[rbp], r12d
  02f70	41 bd 01 00 00
	00		 mov	 r13d, 1
  02f76	4d 6b ed 08	 imul	 r13, r13, 8
  02f7a	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  02f7e	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02f83	44 89 a5 58 01
	00 00		 mov	 DWORD PTR tv2038[rbp], r12d
  02f8a	41 bd 01 00 00
	00		 mov	 r13d, 1
  02f90	4d 6b ed 07	 imul	 r13, r13, 7
  02f94	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  02f98	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02f9d	44 89 a5 5c 01
	00 00		 mov	 DWORD PTR tv2042[rbp], r12d
  02fa4	41 bd 01 00 00
	00		 mov	 r13d, 1
  02faa	4d 6b ed 06	 imul	 r13, r13, 6
  02fae	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  02fb2	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02fb7	44 89 a5 60 01
	00 00		 mov	 DWORD PTR tv2046[rbp], r12d
  02fbe	41 bd 01 00 00
	00		 mov	 r13d, 1
  02fc4	4d 6b ed 05	 imul	 r13, r13, 5
  02fc8	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  02fcc	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02fd1	44 89 a5 64 01
	00 00		 mov	 DWORD PTR tv2050[rbp], r12d
  02fd8	41 bd 01 00 00
	00		 mov	 r13d, 1
  02fde	4d 6b ed 04	 imul	 r13, r13, 4
  02fe2	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  02fe6	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02feb	44 89 a5 68 01
	00 00		 mov	 DWORD PTR tv2054[rbp], r12d
  02ff2	41 bd 01 00 00
	00		 mov	 r13d, 1
  02ff8	4d 6b ed 03	 imul	 r13, r13, 3
  02ffc	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  03000	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  03005	44 89 a5 6c 01
	00 00		 mov	 DWORD PTR tv2058[rbp], r12d
  0300c	41 bd 01 00 00
	00		 mov	 r13d, 1
  03012	4d 6b ed 02	 imul	 r13, r13, 2
  03016	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  0301a	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  0301f	44 89 a5 70 01
	00 00		 mov	 DWORD PTR tv2062[rbp], r12d
  03026	41 bd 01 00 00
	00		 mov	 r13d, 1
  0302c	4d 6b ed 01	 imul	 r13, r13, 1
  03030	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  03034	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  03039	44 89 a5 74 01
	00 00		 mov	 DWORD PTR tv2066[rbp], r12d
  03040	41 bd 01 00 00
	00		 mov	 r13d, 1
  03046	4d 6b ed 00	 imul	 r13, r13, 0
  0304a	4c 8b 65 38	 mov	 r12, QWORD PTR sense$1[rbp]
  0304e	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  03053	b9 01 00 00 00	 mov	 ecx, 1
  03058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0305e	8b 8d 80 01 00
	00		 mov	 ecx, DWORD PTR tv1946[rbp]
  03064	89 8c 24 40 01
	00 00		 mov	 DWORD PTR [rsp+320], ecx
  0306b	8b 8d 84 01 00
	00		 mov	 ecx, DWORD PTR tv1950[rbp]
  03071	89 8c 24 38 01
	00 00		 mov	 DWORD PTR [rsp+312], ecx
  03078	8b 8d 18 01 00
	00		 mov	 ecx, DWORD PTR tv1954[rbp]
  0307e	89 8c 24 30 01
	00 00		 mov	 DWORD PTR [rsp+304], ecx
  03085	89 bc 24 28 01
	00 00		 mov	 DWORD PTR [rsp+296], edi
  0308c	8b 8d 1c 01 00
	00		 mov	 ecx, DWORD PTR tv1962[rbp]
  03092	89 8c 24 20 01
	00 00		 mov	 DWORD PTR [rsp+288], ecx
  03099	8b 8d 20 01 00
	00		 mov	 ecx, DWORD PTR tv1966[rbp]
  0309f	89 8c 24 18 01
	00 00		 mov	 DWORD PTR [rsp+280], ecx
  030a6	8b 8d 24 01 00
	00		 mov	 ecx, DWORD PTR tv1970[rbp]
  030ac	89 8c 24 10 01
	00 00		 mov	 DWORD PTR [rsp+272], ecx
  030b3	89 9c 24 08 01
	00 00		 mov	 DWORD PTR [rsp+264], ebx
  030ba	89 b4 24 00 01
	00 00		 mov	 DWORD PTR [rsp+256], esi
  030c1	8b 8d 28 01 00
	00		 mov	 ecx, DWORD PTR tv1982[rbp]
  030c7	89 8c 24 f8 00
	00 00		 mov	 DWORD PTR [rsp+248], ecx
  030ce	44 89 b4 24 f0
	00 00 00	 mov	 DWORD PTR [rsp+240], r14d
  030d6	44 89 bc 24 e8
	00 00 00	 mov	 DWORD PTR [rsp+232], r15d
  030de	8b 8d 2c 01 00
	00		 mov	 ecx, DWORD PTR tv1994[rbp]
  030e4	89 8c 24 e0 00
	00 00		 mov	 DWORD PTR [rsp+224], ecx
  030eb	8b 8d 30 01 00
	00		 mov	 ecx, DWORD PTR tv1998[rbp]
  030f1	89 8c 24 d8 00
	00 00		 mov	 DWORD PTR [rsp+216], ecx
  030f8	8b 8d 34 01 00
	00		 mov	 ecx, DWORD PTR tv2002[rbp]
  030fe	89 8c 24 d0 00
	00 00		 mov	 DWORD PTR [rsp+208], ecx
  03105	8b 8d 38 01 00
	00		 mov	 ecx, DWORD PTR tv2006[rbp]
  0310b	89 8c 24 c8 00
	00 00		 mov	 DWORD PTR [rsp+200], ecx
  03112	8b 8d 3c 01 00
	00		 mov	 ecx, DWORD PTR tv2010[rbp]
  03118	89 8c 24 c0 00
	00 00		 mov	 DWORD PTR [rsp+192], ecx
  0311f	8b 8d 40 01 00
	00		 mov	 ecx, DWORD PTR tv2014[rbp]
  03125	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR [rsp+184], ecx
  0312c	8b 8d 44 01 00
	00		 mov	 ecx, DWORD PTR tv2018[rbp]
  03132	89 8c 24 b0 00
	00 00		 mov	 DWORD PTR [rsp+176], ecx
  03139	8b 8d 48 01 00
	00		 mov	 ecx, DWORD PTR tv2022[rbp]
  0313f	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR [rsp+168], ecx
  03146	8b 8d 4c 01 00
	00		 mov	 ecx, DWORD PTR tv2026[rbp]
  0314c	89 8c 24 a0 00
	00 00		 mov	 DWORD PTR [rsp+160], ecx
  03153	8b 8d 50 01 00
	00		 mov	 ecx, DWORD PTR tv2030[rbp]
  03159	89 8c 24 98 00
	00 00		 mov	 DWORD PTR [rsp+152], ecx
  03160	8b 8d 54 01 00
	00		 mov	 ecx, DWORD PTR tv2034[rbp]
  03166	89 8c 24 90 00
	00 00		 mov	 DWORD PTR [rsp+144], ecx
  0316d	8b 8d 58 01 00
	00		 mov	 ecx, DWORD PTR tv2038[rbp]
  03173	89 8c 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], ecx
  0317a	8b 8d 5c 01 00
	00		 mov	 ecx, DWORD PTR tv2042[rbp]
  03180	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  03187	8b 8d 60 01 00
	00		 mov	 ecx, DWORD PTR tv2046[rbp]
  0318d	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  03191	8b 8d 64 01 00
	00		 mov	 ecx, DWORD PTR tv2050[rbp]
  03197	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  0319b	8b 8d 68 01 00
	00		 mov	 ecx, DWORD PTR tv2054[rbp]
  031a1	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  031a5	8b 8d 6c 01 00
	00		 mov	 ecx, DWORD PTR tv2058[rbp]
  031ab	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  031af	8b 8d 70 01 00
	00		 mov	 ecx, DWORD PTR tv2062[rbp]
  031b5	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  031b9	8b 8d 74 01 00
	00		 mov	 ecx, DWORD PTR tv2066[rbp]
  031bf	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  031c3	44 89 64 24 48	 mov	 DWORD PTR [rsp+72], r12d
  031c8	8b 8d f8 00 00
	00		 mov	 ecx, DWORD PTR tv2075[rbp]
  031ce	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  031d2	8b 8d fc 00 00
	00		 mov	 ecx, DWORD PTR tv2081[rbp]
  031d8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  031dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182780
  031e3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  031e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182781
  031ef	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  031f4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  031f9	41 b9 03 00 00
	00		 mov	 r9d, 3
  031ff	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG182782
  03206	ba 72 16 00 00	 mov	 edx, 5746		; 00001672H
  0320b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182783
  03212	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 5739 :                             sense[ 0], sense[ 1], sense[ 2], sense[ 3],
; 5740 :                             sense[ 4], sense[ 5], sense[ 6], sense[ 7],
; 5741 :                             sense[ 8], sense[ 9], sense[10], sense[11],
; 5742 :                             sense[12], sense[13], sense[14], sense[15],
; 5743 :                             sense[16], sense[17], sense[18], sense[19],
; 5744 :                             sense[20], sense[21], sense[22], sense[23],
; 5745 :                             sense[24], sense[25], sense[26], sense[27],
; 5746 :                             sense[28], sense[29], sense[30], sense[31] );
; 5747 : 
; 5748 :                     if (sense[0] != 0 || sense[1] != 0)

  03218	b8 01 00 00 00	 mov	 eax, 1
  0321d	48 6b c0 00	 imul	 rax, rax, 0
  03221	48 8b 4d 38	 mov	 rcx, QWORD PTR sense$1[rbp]
  03225	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  03229	85 c0		 test	 eax, eax
  0322b	75 15		 jne	 SHORT $LN210@s390_execu
  0322d	b8 01 00 00 00	 mov	 eax, 1
  03232	48 6b c0 01	 imul	 rax, rax, 1
  03236	48 8b 4d 38	 mov	 rcx, QWORD PTR sense$1[rbp]
  0323a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0323e	85 c0		 test	 eax, eax
  03240	74 1d		 je	 SHORT $LN209@s390_execu
$LN210@s390_execu:

; 5749 :                         DISPLAY_SENSE( dev );

  03242	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG182786
  03249	41 b8 75 16 00
	00		 mov	 r8d, 5749		; 00001675H
  0324f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182787
  03256	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0325a	e8 00 00 00 00	 call	 _display_sense
$LN209@s390_execu:
$LN208@s390_execu:
$LN206@s390_execu:
$LN197@s390_execu:

; 5750 :                 }
; 5751 :             }
; 5752 :         }
; 5753 : 
; 5754 :         /* Terminate the channel program if any unusual status */
; 5755 :         if (chanstat != 0
; 5756 :             || (unitstat & ~CSW_SM) != (CSW_CE | CSW_DE))

  0325f	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  03263	85 c0		 test	 eax, eax
  03265	75 0c		 jne	 SHORT $LN213@s390_execu
  03267	0f b6 45 0c	 movzx	 eax, BYTE PTR unitstat$[rbp]
  0326b	83 e0 bf	 and	 eax, -65		; ffffffffffffffbfH
  0326e	83 f8 0c	 cmp	 eax, 12
  03271	74 49		 je	 SHORT $LN211@s390_execu
$LN213@s390_execu:

; 5757 :         {
; 5758 :             if (firstccw && !dev->is_immed && (dev->scsw.flag1 & SCSW1_I))

  03273	0f b6 45 2d	 movzx	 eax, BYTE PTR firstccw$[rbp]
  03277	85 c0		 test	 eax, eax
  03279	74 3b		 je	 SHORT $LN214@s390_execu
  0327b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0327f	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  03286	75 2e		 jne	 SHORT $LN214@s390_execu
  03288	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0328c	0f b6 80 09 03
	00 00		 movzx	 eax, BYTE PTR [rax+777]
  03293	83 e0 20	 and	 eax, 32			; 00000020H
  03296	85 c0		 test	 eax, eax
  03298	74 1c		 je	 SHORT $LN214@s390_execu

; 5759 :             {
; 5760 :                 /* Set the zero condition-code flag in the SCSW */
; 5761 :                 dev->scsw.flag1 |= SCSW1_Z;

  0329a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0329e	0f b6 80 09 03
	00 00		 movzx	 eax, BYTE PTR [rax+777]
  032a5	83 c8 04	 or	 eax, 4
  032a8	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  032ac	88 81 09 03 00
	00		 mov	 BYTE PTR [rcx+777], al

; 5762 :                 firstccw = 0;

  032b2	c6 45 2d 00	 mov	 BYTE PTR firstccw$[rbp], 0
$LN214@s390_execu:

; 5763 :             }
; 5764 :             chain = 0;

  032b6	c6 45 1c 00	 mov	 BYTE PTR chain$[rbp], 0

; 5765 :         }

  032ba	eb 15		 jmp	 SHORT $LN212@s390_execu
$LN211@s390_execu:

; 5766 : 
; 5767 :         /* Increment CCW address if device returned status modifier  */
; 5768 :         /* SA22-7201-05:                                             */
; 5769 :         /*  p. 15-30, Command Chaining                               */
; 5770 :         else if ((unitstat & (CSW_DE | CSW_SM)) == (CSW_DE | CSW_SM))

  032bc	0f b6 45 0c	 movzx	 eax, BYTE PTR unitstat$[rbp]
  032c0	83 e0 44	 and	 eax, 68			; 00000044H
  032c3	83 f8 44	 cmp	 eax, 68			; 00000044H
  032c6	75 09		 jne	 SHORT $LN215@s390_execu

; 5771 :             ccwaddr += 8;

  032c8	8b 45 20	 mov	 eax, DWORD PTR ccwaddr$[rbp]
  032cb	83 c0 08	 add	 eax, 8
  032ce	89 45 20	 mov	 DWORD PTR ccwaddr$[rbp], eax
$LN215@s390_execu:
$LN212@s390_execu:

; 5772 : 
; 5773 :         /* Update the chaining flags */
; 5774 :         dev->chained = flags & (CCW_FLAGS_CD | CCW_FLAGS_CC);

  032d1	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  032d5	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  032da	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  032de	88 81 78 02 00
	00		 mov	 BYTE PTR [rcx+632], al

; 5775 : 
; 5776 :         /* Update the CCW sequence number unless data chained */
; 5777 :         if ((flags & CCW_FLAGS_CD) == 0)

  032e4	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  032e8	25 80 00 00 00	 and	 eax, 128		; 00000080H
  032ed	85 c0		 test	 eax, eax
  032ef	75 4e		 jne	 SHORT $LN216@s390_execu

; 5778 :         {
; 5779 :             dev->ccwseq++;

  032f1	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  032f5	8b 80 7c 02 00
	00		 mov	 eax, DWORD PTR [rax+636]
  032fb	ff c0		 inc	 eax
  032fd	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  03301	89 81 7c 02 00
	00		 mov	 DWORD PTR [rcx+636], eax

; 5780 : 
; 5781 :             /* Reset prefetch table and master skip data */
; 5782 :             dev->is_immed =

  03307	c7 45 60 00 00
	00 00		 mov	 DWORD PTR bufpos$[rbp], 0
  0330e	8b 45 60	 mov	 eax, DWORD PTR bufpos$[rbp]
  03311	89 85 c4 01 00
	00		 mov	 DWORD PTR prefetch$[rbp+4], eax
  03317	8b 85 c4 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp+4]
  0331d	89 85 c0 01 00
	00		 mov	 DWORD PTR prefetch$[rbp], eax
  03323	8b 85 c0 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp]
  03329	89 45 10	 mov	 DWORD PTR ps$[rbp], eax
  0332c	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  0332f	89 45 64	 mov	 DWORD PTR skip_ccws$[rbp], eax
  03332	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03336	8b 4d 64	 mov	 ecx, DWORD PTR skip_ccws$[rbp]
  03339	89 88 a0 02 00
	00		 mov	 DWORD PTR [rax+672], ecx
$LN216@s390_execu:

; 5783 :             skip_ccws =
; 5784 :             ps =
; 5785 :             prefetch.seq =
; 5786 :             prefetch.pos =
; 5787 :             bufpos = 0;
; 5788 :         }
; 5789 : 
; 5790 :         /* If Halt or Clear Pending, restart chaining to reset */
; 5791 :         if (dev->scsw.flag2 & (SCSW2_AC_HALT | SCSW2_AC_CLEAR))

  0333f	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03343	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  0334a	83 e0 03	 and	 eax, 3
  0334d	85 c0		 test	 eax, eax
  0334f	74 04		 je	 SHORT $LN217@s390_execu

; 5792 :             chain = 1;

  03351	c6 45 1c 01	 mov	 BYTE PTR chain$[rbp], 1
$LN217@s390_execu:

; 5793 : 
; 5794 :     } /* end while(chain) */

  03355	e9 63 d6 ff ff	 jmp	 $LN322@s390_execu
$LN3@s390_execu:
$LN21@s390_execu:

; 5795 : 
; 5796 :     IODELAY(dev);

  0335a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  03361	83 b8 e0 13 00
	00 00		 cmp	 DWORD PTR [rax+5088], 0
  03368	7e 2d		 jle	 SHORT $LN218@s390_execu
  0336a	b8 01 00 00 00	 mov	 eax, 1
  0336f	48 6b c0 0a	 imul	 rax, rax, 10
  03373	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  03377	0f b6 84 01 6c
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1388]
  0337f	83 f8 20	 cmp	 eax, 32			; 00000020H
  03382	75 13		 jne	 SHORT $LN218@s390_execu
  03384	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0338b	8b 88 e0 13 00
	00		 mov	 ecx, DWORD PTR [rax+5088]
  03391	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN218@s390_execu:
  03397	33 c0		 xor	 eax, eax
  03399	85 c0		 test	 eax, eax
  0339b	75 bd		 jne	 SHORT $LN21@s390_execu

; 5797 : 
; 5798 :     /* Call the i/o end exit */
; 5799 :     if (dev->hnd->end) (dev->hnd->end) (dev);

  0339d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  033a1	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  033a8	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  033ad	74 12		 je	 SHORT $LN219@s390_execu
  033af	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  033b3	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  033ba	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  033be	ff 50 30	 call	 QWORD PTR [rax+48]
$LN219@s390_execu:

; 5800 : 
; 5801 :     /* If we're shutting down, skip final sequence and just exit now */
; 5802 :     if (sysblk.shutdown)

  033c1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  033c8	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  033ce	c1 e8 0b	 shr	 eax, 11
  033d1	83 e0 01	 and	 eax, 1
  033d4	85 c0		 test	 eax, eax
  033d6	74 18		 je	 SHORT $LN220@s390_execu

; 5803 :         return execute_ccw_chain_fast_return( iobuf, &iobuf_initial, NULL );

  033d8	45 33 c0	 xor	 r8d, r8d
  033db	48 8d 95 00 20
	00 00		 lea	 rdx, QWORD PTR iobuf_initial$[rbp]
  033e2	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  033e6	e8 00 00 00 00	 call	 execute_ccw_chain_fast_return
  033eb	e9 54 03 00 00	 jmp	 $LN1@s390_execu
$LN220@s390_execu:

; 5804 : 
; 5805 :     /* Final sequence MUST be performed with INTLOCK held to prevent
; 5806 :        I/O instructions (such as test_subchan) from proceeding before
; 5807 :        we can set our flags properly and queue the actual I/O interrupt.
; 5808 :     */
; 5809 :     OBTAIN_INTLOCK(NULL);

  033f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182798
  033f7	33 c9		 xor	 ecx, ecx
  033f9	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 5810 :     obtain_lock(&dev->lock);

  033fe	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03402	48 83 c0 38	 add	 rax, 56			; 00000038H
  03406	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182799
  0340d	48 8b c8	 mov	 rcx, rax
  03410	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 5811 : 
; 5812 :     /* Complete the subchannel status word */
; 5813 :     dev->scsw.flag3 &= ~(SCSW3_AC_SCHAC | SCSW3_AC_DEVAC | SCSW3_SC_INTER);

  03416	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0341a	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  03421	25 37 ff ff ff	 and	 eax, -201		; ffffffffffffff37H
  03426	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0342a	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 5814 :     dev->scsw.flag3 |= (SCSW3_SC_PRI | SCSW3_SC_SEC | SCSW3_SC_PEND);

  03430	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03434	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  0343b	83 c8 07	 or	 eax, 7
  0343e	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  03442	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 5815 :     STORE_FW(dev->scsw.ccwaddr,ccwaddr);

  03448	8b 4d 20	 mov	 ecx, DWORD PTR ccwaddr$[rbp]
  0344b	e8 00 00 00 00	 call	 _byteswap_ulong
  03450	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  03454	48 81 c1 0c 03
	00 00		 add	 rcx, 780		; 0000030cH
  0345b	8b d0		 mov	 edx, eax
  0345d	e8 00 00 00 00	 call	 store_fw_noswap

; 5816 :     dev->scsw.unitstat = unitstat;

  03462	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03466	0f b6 4d 0c	 movzx	 ecx, BYTE PTR unitstat$[rbp]
  0346a	88 88 10 03 00
	00		 mov	 BYTE PTR [rax+784], cl

; 5817 :     dev->scsw.chanstat = chanstat;

  03470	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03474	0f b6 4d 09	 movzx	 ecx, BYTE PTR chanstat$[rbp]
  03478	88 88 11 03 00
	00		 mov	 BYTE PTR [rax+785], cl

; 5818 :     STORE_HW(dev->scsw.count,residual);

  0347e	0f b7 4d 30	 movzx	 ecx, WORD PTR residual$[rbp]
  03482	e8 00 00 00 00	 call	 _byteswap_ushort
  03487	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0348b	48 81 c1 12 03
	00 00		 add	 rcx, 786		; 00000312H
  03492	0f b7 d0	 movzx	 edx, ax
  03495	e8 00 00 00 00	 call	 store_hw_noswap

; 5819 : 
; 5820 :     /* Set alert status if terminated by any unusual condition */
; 5821 :     if (chanstat != 0 || unitstat != (CSW_CE | CSW_DE))

  0349a	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  0349e	85 c0		 test	 eax, eax
  034a0	75 09		 jne	 SHORT $LN222@s390_execu
  034a2	0f b6 45 0c	 movzx	 eax, BYTE PTR unitstat$[rbp]
  034a6	83 f8 0c	 cmp	 eax, 12
  034a9	74 18		 je	 SHORT $LN221@s390_execu
$LN222@s390_execu:

; 5822 :         dev->scsw.flag3 |= SCSW3_SC_ALERT;

  034ab	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  034af	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  034b6	83 c8 10	 or	 eax, 16
  034b9	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  034bd	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al
$LN221@s390_execu:

; 5823 : 
; 5824 :     /* Clear the Extended Status Word (ESW) and set LPUM in Word 0,
; 5825 :        defaulting to a Format-1 ESW if no other action taken */
; 5826 :     memset (&dev->esw, 0,sizeof(ESW));

  034c3	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  034c7	48 05 2c 03 00
	00		 add	 rax, 812		; 0000032cH
  034cd	48 8b f8	 mov	 rdi, rax
  034d0	33 c0		 xor	 eax, eax
  034d2	b9 14 00 00 00	 mov	 ecx, 20
  034d7	f3 aa		 rep stosb

; 5827 :     dev->esw.lpum = 0x80;

  034d9	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  034dd	c6 80 2d 03 00
	00 80		 mov	 BYTE PTR [rax+813], 128	; 00000080H

; 5828 : 
; 5829 :     /* Format-0 if CDC, CCC OR IFCC */
; 5830 :     if (chanstat & (CSW_CDC | CSW_CCC | CSW_ICC))

  034e4	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  034e8	83 e0 0e	 and	 eax, 14
  034eb	85 c0		 test	 eax, eax
  034ed	0f 84 8b 00 00
	00		 je	 $LN223@s390_execu

; 5831 :     {
; 5832 :         /* SA22-7201-5:                                              */
; 5833 :         /*  p. 16-34, Field Validity Flags (FVF)                     */
; 5834 :         /*  p. 16-34 -- 16-35, Termination Code                      */
; 5835 :         /*  p. 16-35 -- 16-36, Sequence Code (SC)                    */
; 5836 :         /*                                                           */
; 5837 :         /*  TBD: Further refinement needed as only CDC is even close */
; 5838 :         /*       to being properly implemented.                      */
; 5839 :         dev->esw.scl2 = 0x78;   /* FVF: LPUM, termination code,      */

  034f3	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  034f7	c6 80 2e 03 00
	00 78		 mov	 BYTE PTR [rax+814], 120	; 00000078H

; 5840 :                                 /*      sequence code and device     */
; 5841 :                                 /*      status valid                 */
; 5842 :         /* Set data direction */
; 5843 :         if (!dev->is_immed)

  034fe	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03502	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  03509	75 68		 jne	 SHORT $LN224@s390_execu

; 5844 :         {
; 5845 :             if (prefetch.seq)

  0350b	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  03512	74 1a		 je	 SHORT $LN225@s390_execu

; 5846 :                 dev->esw.scl2 |= 0x02;  /* Write operation */

  03514	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03518	0f b6 80 2e 03
	00 00		 movzx	 eax, BYTE PTR [rax+814]
  0351f	83 c8 02	 or	 eax, 2
  03522	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  03526	88 81 2e 03 00
	00		 mov	 BYTE PTR [rcx+814], al
  0352c	eb 45		 jmp	 SHORT $LN226@s390_execu
$LN225@s390_execu:

; 5847 :             else if (IS_CCW_RDBACK(dev->code))

  0352e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03532	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  03539	83 e0 0f	 and	 eax, 15
  0353c	83 f8 0c	 cmp	 eax, 12
  0353f	75 1a		 jne	 SHORT $LN227@s390_execu

; 5848 :                 dev->esw.scl2 |= 0x03;  /* Read backward */

  03541	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03545	0f b6 80 2e 03
	00 00		 movzx	 eax, BYTE PTR [rax+814]
  0354c	83 c8 03	 or	 eax, 3
  0354f	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  03553	88 81 2e 03 00
	00		 mov	 BYTE PTR [rcx+814], al
  03559	eb 18		 jmp	 SHORT $LN228@s390_execu
$LN227@s390_execu:

; 5849 :             else
; 5850 :                 dev->esw.scl2 |= 0x01;  /* Read */

  0355b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0355f	0f b6 80 2e 03
	00 00		 movzx	 eax, BYTE PTR [rax+814]
  03566	83 c8 01	 or	 eax, 1
  03569	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0356d	88 81 2e 03 00
	00		 mov	 BYTE PTR [rcx+814], al
$LN228@s390_execu:
$LN226@s390_execu:
$LN224@s390_execu:

; 5851 :         }
; 5852 :         dev->esw.scl3 = 0x45;   /* Bits 24-25: Termination Code      */

  03573	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03577	c6 80 2f 03 00
	00 45		 mov	 BYTE PTR [rax+815], 69	; 00000045H
$LN223@s390_execu:

; 5853 :                                 /* Bits 29-31: Sequence Code         */
; 5854 :     }
; 5855 : 
; 5856 :     /* Clear the extended control word */
; 5857 :     memset (dev->ecw, 0, sizeof(dev->ecw));

  0357e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03582	48 05 40 03 00
	00		 add	 rax, 832		; 00000340H
  03588	48 8b f8	 mov	 rdi, rax
  0358b	33 c0		 xor	 eax, eax
  0358d	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  03592	f3 aa		 rep stosb

; 5858 : 
; 5859 :     /* Return sense information if PMCW allows concurrent sense */
; 5860 :     if ((unitstat & CSW_UC) && (dev->pmcw.flag27 & PMCW27_S))

  03594	0f b6 45 0c	 movzx	 eax, BYTE PTR unitstat$[rbp]
  03598	83 e0 02	 and	 eax, 2
  0359b	85 c0		 test	 eax, eax
  0359d	0f 84 de 00 00
	00		 je	 $LN229@s390_execu
  035a3	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  035a7	0f b6 80 07 03
	00 00		 movzx	 eax, BYTE PTR [rax+775]
  035ae	83 e0 01	 and	 eax, 1
  035b1	85 c0		 test	 eax, eax
  035b3	0f 84 c8 00 00
	00		 je	 $LN229@s390_execu

; 5861 :     {
; 5862 :         dev->scsw.flag1 |= SCSW1_E;

  035b9	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  035bd	0f b6 80 09 03
	00 00		 movzx	 eax, BYTE PTR [rax+777]
  035c4	83 c8 02	 or	 eax, 2
  035c7	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  035cb	88 81 09 03 00
	00		 mov	 BYTE PTR [rcx+777], al

; 5863 :         dev->esw.erw0 |= ERW0_S;

  035d1	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  035d5	0f b6 80 30 03
	00 00		 movzx	 eax, BYTE PTR [rax+816]
  035dc	83 c8 01	 or	 eax, 1
  035df	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  035e3	88 81 30 03 00
	00		 mov	 BYTE PTR [rcx+816], al

; 5864 :         dev->esw.erw1 = (BYTE)((dev->numsense < (int)sizeof(dev->ecw)) ?

  035e9	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  035ed	83 b8 60 03 00
	00 20		 cmp	 DWORD PTR [rax+864], 32	; 00000020H
  035f4	73 12		 jae	 SHORT $LN316@s390_execu
  035f6	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  035fa	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  03600	89 85 00 01 00
	00		 mov	 DWORD PTR tv2293[rbp], eax
  03606	eb 0a		 jmp	 SHORT $LN317@s390_execu
$LN316@s390_execu:
  03608	c7 85 00 01 00
	00 20 00 00 00	 mov	 DWORD PTR tv2293[rbp], 32 ; 00000020H
$LN317@s390_execu:
  03612	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03616	0f b6 8d 00 01
	00 00		 movzx	 ecx, BYTE PTR tv2293[rbp]
  0361d	88 88 31 03 00
	00		 mov	 BYTE PTR [rax+817], cl

; 5865 :                         dev->numsense : (int)sizeof(dev->ecw));
; 5866 :         memcpy (dev->ecw, dev->sense, dev->esw.erw1 & ERW1_SCNT);

  03623	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03627	0f b6 80 31 03
	00 00		 movzx	 eax, BYTE PTR [rax+817]
  0362e	83 e0 3f	 and	 eax, 63			; 0000003fH
  03631	48 98		 cdqe
  03633	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  03637	48 81 c1 64 03
	00 00		 add	 rcx, 868		; 00000364H
  0363e	48 8b 55 00	 mov	 rdx, QWORD PTR dev$[rbp]
  03642	48 81 c2 40 03
	00 00		 add	 rdx, 832		; 00000340H
  03649	48 8b fa	 mov	 rdi, rdx
  0364c	48 8b f1	 mov	 rsi, rcx
  0364f	48 8b c8	 mov	 rcx, rax
  03652	f3 a4		 rep movsb

; 5867 :         memset (dev->sense, 0, sizeof(dev->sense));

  03654	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03658	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  0365e	48 8b f8	 mov	 rdi, rax
  03661	33 c0		 xor	 eax, eax
  03663	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  03668	f3 aa		 rep stosb

; 5868 :         dev->sns_pending = 0;

  0366a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0366e	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  03674	83 e0 fb	 and	 eax, -5			; fffffffbH
  03677	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0367b	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax
$LN229@s390_execu:

; 5869 :     }
; 5870 : 
; 5871 :     /* Late notification. If halt or clear in process, go clear the  */
; 5872 :     /* mess.                                                         */
; 5873 :     if (dev->scsw.flag2 & (SCSW2_AC_HALT | SCSW2_AC_CLEAR))

  03681	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03685	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  0368c	83 e0 03	 and	 eax, 3
  0368f	85 c0		 test	 eax, eax
  03691	74 6a		 je	 SHORT $LN230@s390_execu

; 5874 :     {
; 5875 :         U8 halt = (dev->scsw.flag2 & SCSW2_AC_HALT) ? TRUE : FALSE;

  03693	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03697	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  0369e	83 e0 02	 and	 eax, 2
  036a1	85 c0		 test	 eax, eax
  036a3	74 0c		 je	 SHORT $LN318@s390_execu
  036a5	c7 85 04 01 00
	00 01 00 00 00	 mov	 DWORD PTR tv2322[rbp], 1
  036af	eb 0a		 jmp	 SHORT $LN319@s390_execu
$LN318@s390_execu:
  036b1	c7 85 04 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv2322[rbp], 0
$LN319@s390_execu:
  036bb	0f b6 85 04 01
	00 00		 movzx	 eax, BYTE PTR tv2322[rbp]
  036c2	88 45 74	 mov	 BYTE PTR halt$7[rbp], al

; 5876 :         release_lock(&dev->lock);

  036c5	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  036c9	48 83 c0 38	 add	 rax, 56			; 00000038H
  036cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182810
  036d4	48 8b c8	 mov	 rcx, rax
  036d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5877 :         RELEASE_INTLOCK(NULL);

  036dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182811
  036e4	33 c9		 xor	 ecx, ecx
  036e6	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 5878 :         if (halt)

  036eb	0f b6 45 74	 movzx	 eax, BYTE PTR halt$7[rbp]
  036ef	85 c0		 test	 eax, eax
  036f1	74 05		 je	 SHORT $LN231@s390_execu

; 5879 :             goto execute_halt;

  036f3	e9 0c d4 ff ff	 jmp	 $execute_halt$325
$LN231@s390_execu:

; 5880 :         goto execute_clear;

  036f8	e9 1d d3 ff ff	 jmp	 $execute_clear$324
$LN230@s390_execu:

; 5881 :     }
; 5882 : 
; 5883 :     /* Present the interrupt and return */
; 5884 :     queue_io_interrupt_and_update_status_locked( dev, TRUE );

  036fd	ba 01 00 00 00	 mov	 edx, 1
  03702	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  03706	e8 00 00 00 00	 call	 queue_io_interrupt_and_update_status_locked

; 5885 :     release_lock( &dev->lock );

  0370b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0370f	48 83 c0 38	 add	 rax, 56			; 00000038H
  03713	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182813
  0371a	48 8b c8	 mov	 rcx, rax
  0371d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5886 :     RELEASE_INTLOCK( NULL );

  03723	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182814
  0372a	33 c9		 xor	 ecx, ecx
  0372c	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 5887 :     return execute_ccw_chain_fast_return( iobuf, &iobuf_initial, NULL );

  03731	45 33 c0	 xor	 r8d, r8d
  03734	48 8d 95 00 20
	00 00		 lea	 rdx, QWORD PTR iobuf_initial$[rbp]
  0373b	48 8b 4d 58	 mov	 rcx, QWORD PTR iobuf$[rbp]
  0373f	e8 00 00 00 00	 call	 execute_ccw_chain_fast_return
$LN1@s390_execu:
$LN232@s390_execu:

; 5888 : 
; 5889 : } /* end function execute_ccw_chain */

  03744	48 8b 8d 40 30
	01 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  0374b	48 33 cc	 xor	 rcx, rsp
  0374e	e8 00 00 00 00	 call	 __security_check_cookie
  03753	48 81 c4 a8 41
	01 00		 add	 rsp, 82344		; 000141a8H
  0375a	41 5f		 pop	 r15
  0375c	41 5e		 pop	 r14
  0375e	41 5d		 pop	 r13
  03760	41 5c		 pop	 r12
  03762	5f		 pop	 rdi
  03763	5e		 pop	 rsi
  03764	5b		 pop	 rbx
  03765	5d		 pop	 rbp
  03766	c3		 ret	 0
s390_execute_ccw_chain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
dev$ = 0
flags$ = 8
chanstat$ = 9
opcode$ = 10
unitstat$ = 11
ccwfmt$ = 12
ps$ = 16
ccwkey$ = 20
tracethis$ = 21
idawfmt$ = 22
chain$ = 23
ccwaddr$ = 24
count$ = 28
ts$ = 32
ioerror$ = 36
firstccw$ = 37
residual$ = 40
addr$ = 44
sense$1 = 48
more$ = 56
idapmask$ = 60
skip_ch9uc$2 = 64
ostailor_quiet$3 = 65
ccw_tracing$4 = 66
cpu_tracing$5 = 67
ticback$ = 68
iobuf$ = 72
bufpos$ = 80
skip_ccws$ = 84
tracing_active$6 = 88
prevccwaddr$ = 92
halt$7 = 96
ticaddr$ = 100
prefetch_remaining$ = 104
ccw$ = 112
cmdretry$ = 120
tv283 = 124
tv295 = 128
tv303 = 132
tv382 = 136
tv388 = 140
tv441 = 144
tv447 = 148
tv796 = 152
tv808 = 156
tv814 = 160
tv963 = 164
tv969 = 168
tv1057 = 172
tv1063 = 176
newsize$8 = 180
tv1212 = 184
tv1415 = 188
tv1423 = 192
tv1448 = 196
tv1452 = 200
tv1496 = 204
tv1543 = 208
tv1634 = 212
tv1647 = 216
tv1653 = 220
tv1806 = 224
tv1812 = 228
tv2024 = 232
tv2053 = 236
tv182 = 240
tv188 = 244
tv205 = 248
tv211 = 252
tv1685 = 256
tv1693 = 260
tv1697 = 264
tv1701 = 268
tv1713 = 272
tv1725 = 276
tv1729 = 280
tv1733 = 284
tv1737 = 288
tv1741 = 292
tv1745 = 296
tv1749 = 300
tv1753 = 304
tv1757 = 308
tv1761 = 312
tv1765 = 316
tv1769 = 320
tv1773 = 324
tv1777 = 328
tv1781 = 332
tv1785 = 336
tv1789 = 340
tv1793 = 344
tv1797 = 348
tv1640 = 352
tv1642 = 356
tv1677 = 360
tv1681 = 364
iobufnew$9 = 368
$T10 = 376
tv2078 = 384
prefetch$ = 448
iobuf_initial$ = 8192
area$ = 77824
__$ArrayPad$ = 77888
arg$ = 82416
s370_execute_ccw_chain PROC

; 4380 : {

$LN294:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	53		 push	 rbx
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	41 57		 push	 r15
  00011	b8 a8 41 01 00	 mov	 eax, 82344		; 000141a8H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	48 2b e0	 sub	 rsp, rax
  0001e	48 8d ac 24 50
	11 00 00	 lea	 rbp, QWORD PTR [rsp+4432]
  00026	48 81 e5 00 f0
	ff ff		 and	 rbp, -4096		; fffffffffffff000H
  0002d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00034	48 33 c4	 xor	 rax, rsp
  00037	48 89 85 40 30
	01 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax

; 4381 : DEVBLK *dev = (DEVBLK*) arg;            /* Device Block pointer      */

  0003e	48 8b 84 24 f0
	41 01 00	 mov	 rax, QWORD PTR arg$[rsp]
  00046	48 89 45 00	 mov	 QWORD PTR dev$[rbp], rax

; 4382 : IOBUF  *iobuf;                          /* Pointer to I/O buffer     */
; 4383 : U32     ccwaddr = 0;                    /* Address of CCW            */

  0004a	c7 45 18 00 00
	00 00		 mov	 DWORD PTR ccwaddr$[rbp], 0

; 4384 : U32     ticaddr = 0;                    /* Previous CCW was a TIC    */

  00051	c7 45 64 00 00
	00 00		 mov	 DWORD PTR ticaddr$[rbp], 0

; 4385 : U16     ticback = 0;                    /* Backwards TIC counter     */

  00058	33 c0		 xor	 eax, eax
  0005a	66 89 45 44	 mov	 WORD PTR ticback$[rbp], ax

; 4386 : U16     idapmask = 0;                   /* IDA page size - 1         */

  0005e	33 c0		 xor	 eax, eax
  00060	66 89 45 3c	 mov	 WORD PTR idapmask$[rbp], ax

; 4387 : BYTE    idawfmt = 0;                    /* IDAW format (1 or 2)      */

  00064	c6 45 16 00	 mov	 BYTE PTR idawfmt$[rbp], 0

; 4388 : BYTE    ccwfmt = 0;                     /* CCW format (0 or 1)       */

  00068	c6 45 0c 00	 mov	 BYTE PTR ccwfmt$[rbp], 0

; 4389 : BYTE    ccwkey = 0;                     /* Bits 0-3=key, 4-7=zero    */

  0006c	c6 45 14 00	 mov	 BYTE PTR ccwkey$[rbp], 0

; 4390 : BYTE    opcode;                         /* CCW operation code        */
; 4391 : BYTE    flags;                          /* CCW flags                 */
; 4392 : U32     addr;                           /* CCW data address          */
; 4393 : #ifdef FEATURE_CHANNEL_SUBSYSTEM
; 4394 : U32     mbaddr;                         /* Measure block address     */
; 4395 : MBK    *mbk;                            /* Measure block             */
; 4396 : U16     mbcount;                        /* Measure block count       */
; 4397 : #endif /*FEATURE_CHANNEL_SUBSYSTEM*/
; 4398 : U32     count;                          /* CCW byte count            */
; 4399 : BYTE   *ccw;                            /* CCW pointer               */
; 4400 : BYTE    unitstat;                       /* Unit status               */
; 4401 : BYTE    chanstat;                       /* Channel status            */
; 4402 : U32     residual = 0;                   /* Residual byte count       */

  00070	c7 45 28 00 00
	00 00		 mov	 DWORD PTR residual$[rbp], 0

; 4403 : BYTE    more;                           /* 1=Count exhausted         */
; 4404 : BYTE    chain = 1;                      /* 1=Chain to next CCW       */

  00077	c6 45 17 01	 mov	 BYTE PTR chain$[rbp], 1

; 4405 : BYTE    tracethis = 0;                  /* 1=Trace this CCW chain    */

  0007b	c6 45 15 00	 mov	 BYTE PTR tracethis$[rbp], 0

; 4406 : BYTE    ioerror = 0;                    /* 1=CCW I/O error           */

  0007f	c6 45 24 00	 mov	 BYTE PTR ioerror$[rbp], 0

; 4407 : BYTE    firstccw = 1;                   /* 1=First CCW               */

  00083	c6 45 25 01	 mov	 BYTE PTR firstccw$[rbp], 1

; 4408 : BYTE    area[64];                       /* Message area              */
; 4409 : u_int   bufpos = 0;                     /* Position in I/O buffer    */

  00087	c7 45 50 00 00
	00 00		 mov	 DWORD PTR bufpos$[rbp], 0

; 4410 : u_int   skip_ccws = 0;                  /* Skip ccws                 */

  0008e	c7 45 54 00 00
	00 00		 mov	 DWORD PTR skip_ccws$[rbp], 0

; 4411 : int     cmdretry = 255;                 /* Limit command retry       */

  00095	c7 45 78 ff 00
	00 00		 mov	 DWORD PTR cmdretry$[rbp], 255 ; 000000ffH

; 4412 : U32     prevccwaddr = 1;                /* Previous CCW address      */

  0009c	c7 45 5c 01 00
	00 00		 mov	 DWORD PTR prevccwaddr$[rbp], 1

; 4413 : U32     prefetch_remaining;             /* Prefetch bytes remaining  */
; 4414 : 
; 4415 : u_int       ps = 0;                     /* Local prefetch sequence   */

  000a3	c7 45 10 00 00
	00 00		 mov	 DWORD PTR ps$[rbp], 0

; 4416 : u_int       ts;                         /* Test prefetch sequence    */
; 4417 : 
; 4418 : CACHE_ALIGN
; 4419 : PREFETCH    prefetch;                   /* Prefetch buffer           */
; 4420 : 
; 4421 : __ALIGN( IOBUF_ALIGN )
; 4422 : IOBUF iobuf_initial;                    /* Channel I/O buffer        */
; 4423 : 
; 4424 :     /* Initialize prefetch */
; 4425 :     memset(&prefetch, 0, sizeof(prefetch));

  000aa	48 8d 85 c0 01
	00 00		 lea	 rax, QWORD PTR prefetch$[rbp]
  000b1	48 8b f8	 mov	 rdi, rax
  000b4	33 c0		 xor	 eax, eax
  000b6	b9 10 1a 00 00	 mov	 ecx, 6672		; 00001a10H
  000bb	f3 aa		 rep stosb

; 4426 : 
; 4427 :     /* Point to initial I/O buffer and initialize */
; 4428 :     iobuf = &iobuf_initial;

  000bd	48 8d 85 00 20
	00 00		 lea	 rax, QWORD PTR iobuf_initial$[rbp]
  000c4	48 89 45 48	 mov	 QWORD PTR iobuf$[rbp], rax

; 4429 :     iobuf_initialize(iobuf, sizeof(iobuf_initial.data));

  000c8	ba 00 00 01 00	 mov	 edx, 65536		; 00010000H
  000cd	48 8b 4d 48	 mov	 rcx, QWORD PTR iobuf$[rbp]
  000d1	e8 00 00 00 00	 call	 iobuf_initialize

; 4430 : 
; 4431 :     obtain_lock (&dev->lock);

  000d6	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  000da	48 83 c0 38	 add	 rax, 56			; 00000038H
  000de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171533
  000e5	48 8b c8	 mov	 rcx, rax
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4432 : 
; 4433 : #if defined( OPTION_SHARED_DEVICES )
; 4434 :     /* Wait for the device to become available */
; 4435 :     if (dev->shareable)

  000ee	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  000f2	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000f8	c1 e8 03	 shr	 eax, 3
  000fb	83 e0 01	 and	 eax, 1
  000fe	85 c0		 test	 eax, eax
  00100	74 09		 je	 SHORT $LN22@s370_execu

; 4436 :     {
; 4437 :         shared_iowait( dev );

  00102	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00106	e8 00 00 00 00	 call	 shared_iowait
$LN22@s370_execu:

; 4438 :     }
; 4439 :     dev->shioactive = DEV_SYS_LOCAL;

  0010b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0010f	c7 80 e4 05 00
	00 ff ff 00 00	 mov	 DWORD PTR [rax+1508], 65535 ; 0000ffffH

; 4440 : #endif // defined( OPTION_SHARED_DEVICES )
; 4441 : 
; 4442 :     set_subchannel_busy(dev);

  00119	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0011d	e8 00 00 00 00	 call	 set_subchannel_busy

; 4443 :     dev->startpending = 0;

  00122	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00126	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0012c	0f ba f0 19	 btr	 eax, 25
  00130	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00134	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4444 : 
; 4445 :     /* Increment excp count */
; 4446 :     dev->excps++;

  0013a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0013e	48 8b 80 00 06
	00 00		 mov	 rax, QWORD PTR [rax+1536]
  00145	48 ff c0	 inc	 rax
  00148	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0014c	48 89 81 00 06
	00 00		 mov	 QWORD PTR [rcx+1536], rax

; 4447 : 
; 4448 :     /* Indicate that we're started */
; 4449 :     dev->scsw.flag2 |= SCSW2_FC_START;

  00153	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00157	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  0015e	83 c8 40	 or	 eax, 64			; 00000040H
  00161	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00165	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 4450 :     dev->scsw.flag2 &= ~SCSW2_AC_START;

  0016b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0016f	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00176	83 e0 fb	 and	 eax, -5
  00179	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0017d	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 4451 : 
; 4452 :     /* Handle early clear or halt */
; 4453 :     if (dev->scsw.flag2 & (SCSW2_AC_CLEAR | SCSW2_AC_HALT))

  00183	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00187	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  0018e	83 e0 03	 and	 eax, 3
  00191	85 c0		 test	 eax, eax
  00193	74 34		 je	 SHORT $LN23@s370_execu

; 4454 :     {
; 4455 :         release_lock(&dev->lock);

  00195	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00199	48 83 c0 38	 add	 rax, 56			; 00000038H
  0019d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171536
  001a4	48 8b c8	 mov	 rcx, rax
  001a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4456 :         if (dev->scsw.flag2 & SCSW2_AC_CLEAR)

  001ad	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  001b1	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  001b8	83 e0 01	 and	 eax, 1
  001bb	85 c0		 test	 eax, eax
  001bd	74 05		 je	 SHORT $LN24@s370_execu

; 4457 :             goto execute_clear;

  001bf	e9 89 05 00 00	 jmp	 $execute_clear$295
$LN24@s370_execu:

; 4458 :         goto execute_halt;

  001c4	e9 6e 06 00 00	 jmp	 $execute_halt$296
$LN23@s370_execu:

; 4459 :     }
; 4460 : 
; 4461 :     /* For hercules `resume' resume suspended state */
; 4462 :     if (dev->resumesuspended || dev->suspended ||

  001c9	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  001cd	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001d3	c1 e8 1a	 shr	 eax, 26
  001d6	83 e0 01	 and	 eax, 1
  001d9	85 c0		 test	 eax, eax
  001db	75 2a		 jne	 SHORT $LN26@s370_execu
  001dd	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  001e1	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001e7	c1 e8 15	 shr	 eax, 21
  001ea	83 e0 01	 and	 eax, 1
  001ed	85 c0		 test	 eax, eax
  001ef	75 16		 jne	 SHORT $LN26@s370_execu
  001f1	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  001f5	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  001fc	83 e0 08	 and	 eax, 8
  001ff	85 c0		 test	 eax, eax
  00201	0f 84 08 03 00
	00		 je	 $LN25@s370_execu
$LN26@s370_execu:

; 4463 :         (dev->scsw.flag2 & SCSW2_AC_RESUM))
; 4464 :     {
; 4465 :         /* Restore CCW execution variables */
; 4466 :         ccwaddr = dev->ccwaddr;

  00207	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0020b	8b 80 80 02 00
	00		 mov	 eax, DWORD PTR [rax+640]
  00211	89 45 18	 mov	 DWORD PTR ccwaddr$[rbp], eax

; 4467 :         idapmask = dev->idapmask;

  00214	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00218	0f b7 80 84 02
	00 00		 movzx	 eax, WORD PTR [rax+644]
  0021f	66 89 45 3c	 mov	 WORD PTR idapmask$[rbp], ax

; 4468 :         idawfmt = dev->idawfmt;

  00223	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00227	0f b6 80 86 02
	00 00		 movzx	 eax, BYTE PTR [rax+646]
  0022e	88 45 16	 mov	 BYTE PTR idawfmt$[rbp], al

; 4469 :         ccwfmt = dev->ccwfmt;

  00231	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00235	0f b6 80 87 02
	00 00		 movzx	 eax, BYTE PTR [rax+647]
  0023c	88 45 0c	 mov	 BYTE PTR ccwfmt$[rbp], al

; 4470 :         ccwkey = dev->ccwkey;

  0023f	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00243	0f b6 80 88 02
	00 00		 movzx	 eax, BYTE PTR [rax+648]
  0024a	88 45 14	 mov	 BYTE PTR ccwkey$[rbp], al

; 4471 : 
; 4472 : 
; 4473 :         /* Turn the `suspended' bits off */
; 4474 :         dev->suspended =

  0024d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00251	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00257	0f ba f0 1a	 btr	 eax, 26
  0025b	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0025f	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
  00265	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00269	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0026f	0f ba f0 15	 btr	 eax, 21
  00273	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00277	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4475 :         dev->resumesuspended=0;
; 4476 : 
; 4477 : #if defined( OPTION_SHARED_DEVICES )
; 4478 :         /* Wait for the device to become available */
; 4479 :         shared_iowait( dev );

  0027d	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00281	e8 00 00 00 00	 call	 shared_iowait

; 4480 :         dev->shioactive = DEV_SYS_LOCAL;

  00286	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0028a	c7 80 e4 05 00
	00 ff ff 00 00	 mov	 DWORD PTR [rax+1508], 65535 ; 0000ffffH

; 4481 : #endif // defined( OPTION_SHARED_DEVICES )
; 4482 : 
; 4483 :         set_device_busy(dev);

  00294	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00298	e8 00 00 00 00	 call	 set_device_busy

; 4484 : 
; 4485 :         if (CCW_TRACING_ACTIVE( dev, tracethis ))

  0029d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  002a1	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  002a7	c1 e8 0f	 shr	 eax, 15
  002aa	83 e0 01	 and	 eax, 1
  002ad	85 c0		 test	 eax, eax
  002af	75 0c		 jne	 SHORT $LN28@s370_execu
  002b1	0f b6 45 15	 movzx	 eax, BYTE PTR tracethis$[rbp]
  002b5	85 c0		 test	 eax, eax
  002b7	0f 84 9a 01 00
	00		 je	 $LN27@s370_execu
$LN28@s370_execu:

; 4486 :         {
; 4487 :             if (dev->s370start)

  002bd	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  002c1	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  002c7	d1 e8		 shr	 eax, 1
  002c9	83 e0 01	 and	 eax, 1
  002cc	85 c0		 test	 eax, eax
  002ce	0f 84 c4 00 00
	00		 je	 $LN29@s370_execu

; 4488 :             {
; 4489 :                 if (sysblk.traceFILE)

  002d4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002db	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  002e3	74 0f		 je	 SHORT $LN31@s370_execu

; 4490 :                     tf_1321( dev );

  002e5	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  002e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1321
  002ef	e9 9f 00 00 00	 jmp	 $LN32@s370_execu
$LN31@s370_execu:

; 4491 :                 else
; 4492 :                     /* State successful conversion from synchronous
; 4493 :                      * to asynchronous for 370 mode.
; 4494 :                      */
; 4495 :                     // "%1d:%04X CHAN: start I/O S/370 conversion to asynchronous operation successful"
; 4496 :                     WRMSG( HHC01321, "I", LCSS_DEVNUM );

  002f4	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  002f9	74 10		 je	 SHORT $LN212@s370_execu
  002fb	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  002ff	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00303	89 85 f0 00 00
	00		 mov	 DWORD PTR tv182[rbp], eax
  00309	eb 0a		 jmp	 SHORT $LN213@s370_execu
$LN212@s370_execu:
  0030b	c7 85 f0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv182[rbp], 0
$LN213@s370_execu:
  00315	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  0031a	74 12		 je	 SHORT $LN214@s370_execu
  0031c	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00320	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00324	d1 f8		 sar	 eax, 1
  00326	89 85 f4 00 00
	00		 mov	 DWORD PTR tv188[rbp], eax
  0032c	eb 0a		 jmp	 SHORT $LN215@s370_execu
$LN214@s370_execu:
  0032e	c7 85 f4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv188[rbp], 0
$LN215@s370_execu:
  00338	b9 01 00 00 00	 mov	 ecx, 1
  0033d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00343	8b 8d f0 00 00
	00		 mov	 ecx, DWORD PTR tv182[rbp]
  00349	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0034d	8b 8d f4 00 00
	00		 mov	 ecx, DWORD PTR tv188[rbp]
  00353	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00357	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171546
  0035e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00363	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171547
  0036a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0036f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00374	41 b9 03 00 00
	00		 mov	 r9d, 3
  0037a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171548
  00381	ba 90 11 00 00	 mov	 edx, 4496		; 00001190H
  00386	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171549
  0038d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN32@s370_execu:

; 4497 :             }

  00393	e9 bf 00 00 00	 jmp	 $LN30@s370_execu
$LN29@s370_execu:

; 4498 :             else
; 4499 :             {
; 4500 :                 if (sysblk.traceFILE)

  00398	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0039f	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  003a7	74 0f		 je	 SHORT $LN33@s370_execu

; 4501 :                     tf_1311( dev );

  003a9	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  003ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1311
  003b3	e9 9f 00 00 00	 jmp	 $LN34@s370_execu
$LN33@s370_execu:

; 4502 :                 else
; 4503 :                     /* Trace I/O resumption */
; 4504 :                     // "%1d:%04X CHAN: resumed"
; 4505 :                     WRMSG (HHC01311, "I", LCSS_DEVNUM );

  003b8	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  003bd	74 10		 je	 SHORT $LN216@s370_execu
  003bf	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  003c3	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003c7	89 85 f8 00 00
	00		 mov	 DWORD PTR tv205[rbp], eax
  003cd	eb 0a		 jmp	 SHORT $LN217@s370_execu
$LN216@s370_execu:
  003cf	c7 85 f8 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv205[rbp], 0
$LN217@s370_execu:
  003d9	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  003de	74 12		 je	 SHORT $LN218@s370_execu
  003e0	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  003e4	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  003e8	d1 f8		 sar	 eax, 1
  003ea	89 85 fc 00 00
	00		 mov	 DWORD PTR tv211[rbp], eax
  003f0	eb 0a		 jmp	 SHORT $LN219@s370_execu
$LN218@s370_execu:
  003f2	c7 85 fc 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv211[rbp], 0
$LN219@s370_execu:
  003fc	b9 01 00 00 00	 mov	 ecx, 1
  00401	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00407	8b 8d f8 00 00
	00		 mov	 ecx, DWORD PTR tv205[rbp]
  0040d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00411	8b 8d fc 00 00
	00		 mov	 ecx, DWORD PTR tv211[rbp]
  00417	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0041b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171552
  00422	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00427	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171553
  0042e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00433	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00438	41 b9 03 00 00
	00		 mov	 r9d, 3
  0043e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171554
  00445	ba 99 11 00 00	 mov	 edx, 4505		; 00001199H
  0044a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171555
  00451	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN34@s370_execu:
$LN30@s370_execu:
$LN27@s370_execu:

; 4506 :             }
; 4507 :         }
; 4508 : 
; 4509 :         /* Reset the suspended status in the SCSW */
; 4510 :         dev->scsw.flag2 &= ~SCSW2_AC_RESUM;

  00457	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0045b	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00462	83 e0 f7	 and	 eax, -9
  00465	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00469	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 4511 :         dev->scsw.flag3 &= ~(SCSW3_AC_SUSP  |

  0046f	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00473	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  0047a	83 e0 c6	 and	 eax, -58		; ffffffffffffffc6H
  0047d	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00481	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 4512 :                              SCSW3_SC_ALERT |
; 4513 :                              SCSW3_SC_INTER |
; 4514 :                              SCSW3_SC_PEND);
; 4515 :         dev->scsw.flag3 |= (SCSW3_AC_SCHAC | SCSW3_AC_DEVAC);

  00487	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0048b	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00492	0d c0 00 00 00	 or	 eax, 192		; 000000c0H
  00497	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0049b	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 4516 : 
; 4517 :         /* Call the i/o resume exit if not clearing */
; 4518 :         if (!(dev->scsw.flag2 & SCSW2_AC_CLEAR))

  004a1	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  004a5	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  004ac	83 e0 01	 and	 eax, 1
  004af	85 c0		 test	 eax, eax
  004b1	75 40		 jne	 SHORT $LN35@s370_execu

; 4519 :         {
; 4520 :             /* Don't execute resume exit if S/370 channel start */
; 4521 :             if (!dev->s370start &&

  004b3	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  004b7	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  004bd	d1 e8		 shr	 eax, 1
  004bf	83 e0 01	 and	 eax, 1
  004c2	85 c0		 test	 eax, eax
  004c4	75 24		 jne	 SHORT $LN36@s370_execu
  004c6	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  004ca	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  004d1	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  004d6	74 12		 je	 SHORT $LN36@s370_execu

; 4522 :                 dev->hnd->resume)
; 4523 :                 (dev->hnd->resume) (dev);

  004d8	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  004dc	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  004e3	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  004e7	ff 50 38	 call	 QWORD PTR [rax+56]
$LN36@s370_execu:

; 4524 : 
; 4525 :             /* Refetch the suspended CCW */
; 4526 :             ccwaddr -= 8;

  004ea	8b 45 18	 mov	 eax, DWORD PTR ccwaddr$[rbp]
  004ed	83 e8 08	 sub	 eax, 8
  004f0	89 45 18	 mov	 DWORD PTR ccwaddr$[rbp], eax
$LN35@s370_execu:

; 4527 :         }
; 4528 : 
; 4529 :         /* Reset S/370 channel SIO resume indicator */
; 4530 :         dev->s370start = 0;

  004f3	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  004f7	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  004fd	83 e0 fd	 and	 eax, -3			; fffffffdH
  00500	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00504	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4531 : 
; 4532 :         goto resume_suspend;

  0050a	e9 77 01 00 00	 jmp	 $resume_suspend$297
$LN25@s370_execu:

; 4533 :     }
; 4534 : 
; 4535 :     /* Hercules deviation; always zero the SCSW CCW address to start */
; 4536 :     store_fw(dev->scsw.ccwaddr, 0);

  0050f	33 c9		 xor	 ecx, ecx
  00511	e8 00 00 00 00	 call	 _byteswap_ulong
  00516	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0051a	48 81 c1 0c 03
	00 00		 add	 rcx, 780		; 0000030cH
  00521	8b d0		 mov	 edx, eax
  00523	e8 00 00 00 00	 call	 store_fw_noswap

; 4537 : 
; 4538 :     /* Call the i/o start exit */
; 4539 :     if (dev->hnd->start)

  00528	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0052c	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00533	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00538	74 42		 je	 SHORT $LN37@s370_execu

; 4540 :     {
; 4541 :         release_lock (&dev->lock);

  0053a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0053e	48 83 c0 38	 add	 rax, 56			; 00000038H
  00542	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171559
  00549	48 8b c8	 mov	 rcx, rax
  0054c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4542 :         (dev->hnd->start) (dev);

  00552	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00556	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0055d	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00561	ff 50 28	 call	 QWORD PTR [rax+40]

; 4543 :         obtain_lock (&dev->lock);

  00564	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00568	48 83 c0 38	 add	 rax, 56			; 00000038H
  0056c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171560
  00573	48 8b c8	 mov	 rcx, rax
  00576	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN37@s370_execu:

; 4544 :     }
; 4545 : 
; 4546 :     /* Extract the I/O parameters from the ORB */
; 4547 :     FETCH_FW(ccwaddr, dev->orb.ccwaddr);

  0057c	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00580	48 05 d4 02 00
	00		 add	 rax, 724		; 000002d4H
  00586	48 8b c8	 mov	 rcx, rax
  00589	e8 00 00 00 00	 call	 fetch_fw_noswap
  0058e	8b c8		 mov	 ecx, eax
  00590	e8 00 00 00 00	 call	 _byteswap_ulong
  00595	89 45 18	 mov	 DWORD PTR ccwaddr$[rbp], eax

; 4548 :     dev->ccwaddr = ccwaddr;

  00598	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0059c	8b 4d 18	 mov	 ecx, DWORD PTR ccwaddr$[rbp]
  0059f	89 88 80 02 00
	00		 mov	 DWORD PTR [rax+640], ecx

; 4549 :     dev->ccwfmt = ccwfmt = (dev->orb.flag5 & ORB5_F) ? 1 : 0;

  005a5	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  005a9	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  005b0	25 80 00 00 00	 and	 eax, 128		; 00000080H
  005b5	85 c0		 test	 eax, eax
  005b7	74 09		 je	 SHORT $LN220@s370_execu
  005b9	c7 45 7c 01 00
	00 00		 mov	 DWORD PTR tv283[rbp], 1
  005c0	eb 07		 jmp	 SHORT $LN221@s370_execu
$LN220@s370_execu:
  005c2	c7 45 7c 00 00
	00 00		 mov	 DWORD PTR tv283[rbp], 0
$LN221@s370_execu:
  005c9	0f b6 45 7c	 movzx	 eax, BYTE PTR tv283[rbp]
  005cd	88 45 0c	 mov	 BYTE PTR ccwfmt$[rbp], al
  005d0	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  005d4	0f b6 4d 0c	 movzx	 ecx, BYTE PTR ccwfmt$[rbp]
  005d8	88 88 87 02 00
	00		 mov	 BYTE PTR [rax+647], cl

; 4550 :     dev->ccwkey = ccwkey = dev->orb.flag4 & ORB4_KEY;

  005de	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  005e2	0f b6 80 d0 02
	00 00		 movzx	 eax, BYTE PTR [rax+720]
  005e9	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  005ee	88 45 14	 mov	 BYTE PTR ccwkey$[rbp], al
  005f1	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  005f5	0f b6 4d 14	 movzx	 ecx, BYTE PTR ccwkey$[rbp]
  005f9	88 88 88 02 00
	00		 mov	 BYTE PTR [rax+648], cl

; 4551 :     dev->idawfmt = idawfmt = (dev->orb.flag5 & ORB5_H) ? PF_IDAW2 : PF_IDAW1;

  005ff	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00603	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  0060a	83 e0 02	 and	 eax, 2
  0060d	85 c0		 test	 eax, eax
  0060f	74 0c		 je	 SHORT $LN222@s370_execu
  00611	c7 85 80 00 00
	00 02 00 00 00	 mov	 DWORD PTR tv295[rbp], 2
  0061b	eb 0a		 jmp	 SHORT $LN223@s370_execu
$LN222@s370_execu:
  0061d	c7 85 80 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv295[rbp], 1
$LN223@s370_execu:
  00627	0f b6 85 80 00
	00 00		 movzx	 eax, BYTE PTR tv295[rbp]
  0062e	88 45 16	 mov	 BYTE PTR idawfmt$[rbp], al
  00631	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00635	0f b6 4d 16	 movzx	 ecx, BYTE PTR idawfmt$[rbp]
  00639	88 88 86 02 00
	00		 mov	 BYTE PTR [rax+646], cl

; 4552 : 
; 4553 :     /* Determine IDA page size */
; 4554 :     if (idawfmt == PF_IDAW2)

  0063f	0f b6 45 16	 movzx	 eax, BYTE PTR idawfmt$[rbp]
  00643	83 f8 02	 cmp	 eax, 2
  00646	75 35		 jne	 SHORT $LN38@s370_execu

; 4555 :     {
; 4556 :         /* Page size is 2K or 4K depending on flag bit */
; 4557 :         idapmask = (dev->orb.flag5 & ORB5_T) ? STORAGE_KEY_2K_BYTEMASK

  00648	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0064c	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  00653	83 e0 01	 and	 eax, 1
  00656	85 c0		 test	 eax, eax
  00658	74 0c		 je	 SHORT $LN224@s370_execu
  0065a	c7 85 84 00 00
	00 ff 07 00 00	 mov	 DWORD PTR tv303[rbp], 2047 ; 000007ffH
  00664	eb 0a		 jmp	 SHORT $LN225@s370_execu
$LN224@s370_execu:
  00666	c7 85 84 00 00
	00 ff 0f 00 00	 mov	 DWORD PTR tv303[rbp], 4095 ; 00000fffH
$LN225@s370_execu:
  00670	0f b7 85 84 00
	00 00		 movzx	 eax, WORD PTR tv303[rbp]
  00677	66 89 45 3c	 mov	 WORD PTR idapmask$[rbp], ax

; 4558 :                                              : STORAGE_KEY_4K_BYTEMASK;
; 4559 :     } else {

  0067b	eb 09		 jmp	 SHORT $LN39@s370_execu
$LN38@s370_execu:

; 4560 :         /* Page size is always 2K for format-1 IDAW */
; 4561 :         idapmask = STORAGE_KEY_2K_BYTEMASK;

  0067d	b8 ff 07 00 00	 mov	 eax, 2047		; 000007ffH
  00682	66 89 45 3c	 mov	 WORD PTR idapmask$[rbp], ax
$LN39@s370_execu:
$resume_suspend$297:

; 4562 :     }
; 4563 : 
; 4564 : 
; 4565 : resume_suspend:
; 4566 : 
; 4567 :     /* Turn off the start pending bit in the SCSW */
; 4568 :     dev->scsw.flag2 &= ~SCSW2_AC_START;

  00686	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0068a	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00691	83 e0 fb	 and	 eax, -5
  00694	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00698	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 4569 : 
; 4570 :     dev->chained = dev->prev_chained =

  0069e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  006a2	c7 80 7c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+636], 0
  006ac	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  006b0	c6 80 7b 02 00
	00 00		 mov	 BYTE PTR [rax+635], 0
  006b7	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  006bb	c6 80 7a 02 00
	00 00		 mov	 BYTE PTR [rax+634], 0
  006c2	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  006c6	c6 80 79 02 00
	00 00		 mov	 BYTE PTR [rax+633], 0
  006cd	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  006d1	c6 80 78 02 00
	00 00		 mov	 BYTE PTR [rax+632], 0

; 4571 :     dev->code    = dev->prevcode     = dev->ccwseq = 0;
; 4572 : 
; 4573 : #if defined(_FEATURE_IO_ASSIST)
; 4574 :  #define _IOA_MBO sysblk.zpb[dev->pmcw.zone].mbo
; 4575 :  #define _IOA_MBM sysblk.zpb[dev->pmcw.zone].mbm
; 4576 :  #define _IOA_MBK sysblk.zpb[dev->pmcw.zone].mbk
; 4577 : #else /*defined(_FEATURE_IO_ASSIST)*/
; 4578 :  #define _IOA_MBO sysblk.mbo
; 4579 :  #define _IOA_MBM sysblk.mbm
; 4580 :  #define _IOA_MBK sysblk.mbk
; 4581 : #endif /*defined(_FEATURE_IO_ASSIST)*/
; 4582 : 
; 4583 : #ifdef FEATURE_CHANNEL_SUBSYSTEM
; 4584 :     /* Update the measurement block if applicable */
; 4585 :     if (_IOA_MBM && (dev->pmcw.flag5 & PMCW5_MM_MBU) &&
; 4586 :         !(dev->scsw.flag2 & (SCSW2_AC_CLEAR | SCSW2_AC_HALT)))
; 4587 :     {
; 4588 :         mbaddr = _IOA_MBO;
; 4589 :         mbaddr += (dev->pmcw.mbi[0] << 8 | dev->pmcw.mbi[1]) << 5;
; 4590 :         if ( !CHADDRCHK(mbaddr, dev)
; 4591 :             && (((ARCH_DEP( get_dev_storage_key )( dev, mbaddr ) & STORKEY_KEY) == _IOA_MBK)
; 4592 :                 || (_IOA_MBK == 0)))
; 4593 :         {
; 4594 :             ARCH_DEP( or_dev_storage_key )( dev, mbaddr, (STORKEY_REF | STORKEY_CHANGE) );
; 4595 :             mbk = (MBK*)&dev->mainstor[mbaddr];
; 4596 :             FETCH_HW(mbcount,mbk->srcount);
; 4597 :             mbcount++;
; 4598 :             STORE_HW(mbk->srcount,mbcount);
; 4599 :         } else {
; 4600 :             /* Generate subchannel logout indicating program
; 4601 :                check or protection check, and set the subchannel
; 4602 :                measurement-block-update-enable to zero */
; 4603 :             dev->pmcw.flag5 &= ~PMCW5_MM_MBU;
; 4604 :             dev->esw.scl0 |= !CHADDRCHK(mbaddr, dev) ?
; 4605 :                                  SCL0_ESF_MBPTK : SCL0_ESF_MBPGK;
; 4606 :             /*INCOMPLETE*/
; 4607 :         }
; 4608 :     }
; 4609 : #endif /*FEATURE_CHANNEL_SUBSYSTEM*/
; 4610 : 
; 4611 :     release_lock (&dev->lock);

  006d8	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  006dc	48 83 c0 38	 add	 rax, 56			; 00000038H
  006e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171563
  006e7	48 8b c8	 mov	 rcx, rax
  006ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN293@s370_execu:
$LN292@s370_execu:
$LN291@s370_execu:
$LN2@s370_execu:

; 4612 : 
; 4613 :     /* Execute the CCW chain */
; 4614 :     /* On entry : No locks held */
; 4615 :     while ( chain )

  006f0	0f b6 45 17	 movzx	 eax, BYTE PTR chain$[rbp]
  006f4	85 c0		 test	 eax, eax
  006f6	0f 84 fd 26 00
	00		 je	 $LN3@s370_execu

; 4616 :     {
; 4617 :         /* Test for clear subchannel request or system shutdown */
; 4618 :         if (dev->scsw.flag2 & SCSW2_AC_CLEAR ||

  006fc	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00700	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00707	83 e0 01	 and	 eax, 1
  0070a	85 c0		 test	 eax, eax
  0070c	75 1b		 jne	 SHORT $LN41@s370_execu
  0070e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00715	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0071b	c1 e8 0b	 shr	 eax, 11
  0071e	83 e0 01	 and	 eax, 1
  00721	85 c0		 test	 eax, eax
  00723	0f 84 91 00 00
	00		 je	 $LN40@s370_execu
$LN41@s370_execu:

; 4619 :             sysblk.shutdown)
; 4620 :         {
; 4621 : 
; 4622 :             /* No I/O delays are to be taken during clear operations */
; 4623 : 
; 4624 :             /* Call the i/o end exit */
; 4625 :             if (dev->hnd->end) (dev->hnd->end) (dev);

  00729	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0072d	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00734	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00739	74 12		 je	 SHORT $LN42@s370_execu
  0073b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0073f	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00746	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0074a	ff 50 30	 call	 QWORD PTR [rax+48]
$LN42@s370_execu:
$execute_clear$295:

; 4626 : 
; 4627 : execute_clear:
; 4628 :             /* Get necessary locks */
; 4629 :             OBTAIN_INTLOCK(NULL);

  0074d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171567
  00754	33 c9		 xor	 ecx, ecx
  00756	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 4630 :             obtain_lock(&dev->lock);

  0075b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0075f	48 83 c0 38	 add	 rax, 56			; 00000038H
  00763	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171568
  0076a	48 8b c8	 mov	 rcx, rax
  0076d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4631 : 
; 4632 :             /* Execute clear function */
; 4633 :             perform_clear_subchan(dev);

  00773	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00777	e8 00 00 00 00	 call	 perform_clear_subchan

; 4634 : 
; 4635 :             /* Release locks */
; 4636 :             release_lock(&dev->lock);

  0077c	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00780	48 83 c0 38	 add	 rax, 56			; 00000038H
  00784	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171569
  0078b	48 8b c8	 mov	 rcx, rax
  0078e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4637 :             RELEASE_INTLOCK(NULL);

  00794	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171570
  0079b	33 c9		 xor	 ecx, ecx
  0079d	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 4638 : 
; 4639 :             /* Return */
; 4640 :             return execute_ccw_chain_fast_return( iobuf, &iobuf_initial, NULL );

  007a2	45 33 c0	 xor	 r8d, r8d
  007a5	48 8d 95 00 20
	00 00		 lea	 rdx, QWORD PTR iobuf_initial$[rbp]
  007ac	48 8b 4d 48	 mov	 rcx, QWORD PTR iobuf$[rbp]
  007b0	e8 00 00 00 00	 call	 execute_ccw_chain_fast_return
  007b5	e9 29 2a 00 00	 jmp	 $LN1@s370_execu
$LN40@s370_execu:

; 4641 : 
; 4642 :         } /* end perform clear subchannel */
; 4643 : 
; 4644 :         /* Test for halt subchannel request */
; 4645 :         if (dev->scsw.flag2 & SCSW2_AC_HALT)

  007ba	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  007be	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  007c5	83 e0 02	 and	 eax, 2
  007c8	85 c0		 test	 eax, eax
  007ca	0f 84 67 01 00
	00		 je	 $LN43@s370_execu
$LN6@s370_execu:

; 4646 :         {
; 4647 :             IODELAY(dev);

  007d0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007d7	83 b8 e0 13 00
	00 00		 cmp	 DWORD PTR [rax+5088], 0
  007de	7e 2d		 jle	 SHORT $LN44@s370_execu
  007e0	b8 01 00 00 00	 mov	 eax, 1
  007e5	48 6b c0 0a	 imul	 rax, rax, 10
  007e9	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  007ed	0f b6 84 01 6c
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1388]
  007f5	83 f8 20	 cmp	 eax, 32			; 00000020H
  007f8	75 13		 jne	 SHORT $LN44@s370_execu
  007fa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00801	8b 88 e0 13 00
	00		 mov	 ecx, DWORD PTR [rax+5088]
  00807	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN44@s370_execu:
  0080d	33 c0		 xor	 eax, eax
  0080f	85 c0		 test	 eax, eax
  00811	75 bd		 jne	 SHORT $LN6@s370_execu

; 4648 : 
; 4649 :             /* Call the i/o end exit */
; 4650 :             if (dev->hnd->end) (dev->hnd->end) (dev);

  00813	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00817	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0081e	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00823	74 12		 je	 SHORT $LN45@s370_execu
  00825	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00829	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00830	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00834	ff 50 30	 call	 QWORD PTR [rax+48]
$LN45@s370_execu:
$execute_halt$296:

; 4651 : 
; 4652 : execute_halt:
; 4653 :             perform_halt(dev);

  00837	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0083b	e8 00 00 00 00	 call	 perform_halt

; 4654 : 
; 4655 :             if (tracethis)

  00840	0f b6 45 15	 movzx	 eax, BYTE PTR tracethis$[rbp]
  00844	85 c0		 test	 eax, eax
  00846	0f 84 d3 00 00
	00		 je	 $LN46@s370_execu

; 4656 :             {
; 4657 :                 if (dev->ccwtrace && sysblk.traceFILE)

  0084c	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00850	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00856	c1 e8 0f	 shr	 eax, 15
  00859	83 e0 01	 and	 eax, 1
  0085c	85 c0		 test	 eax, eax
  0085e	74 20		 je	 SHORT $LN47@s370_execu
  00860	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00867	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  0086f	74 0f		 je	 SHORT $LN47@s370_execu

; 4658 :                     tf_1309( dev );

  00871	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00875	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1309
  0087b	e9 9f 00 00 00	 jmp	 $LN48@s370_execu
$LN47@s370_execu:

; 4659 :                 else
; 4660 :                     // "%1d:%04X CHAN: halt completed"
; 4661 :                     WRMSG( HHC01309, "I", LCSS_DEVNUM );

  00880	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  00885	74 10		 je	 SHORT $LN226@s370_execu
  00887	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0088b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0088f	89 85 88 00 00
	00		 mov	 DWORD PTR tv382[rbp], eax
  00895	eb 0a		 jmp	 SHORT $LN227@s370_execu
$LN226@s370_execu:
  00897	c7 85 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv382[rbp], 0
$LN227@s370_execu:
  008a1	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  008a6	74 12		 je	 SHORT $LN228@s370_execu
  008a8	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  008ac	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  008b0	d1 f8		 sar	 eax, 1
  008b2	89 85 8c 00 00
	00		 mov	 DWORD PTR tv388[rbp], eax
  008b8	eb 0a		 jmp	 SHORT $LN229@s370_execu
$LN228@s370_execu:
  008ba	c7 85 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv388[rbp], 0
$LN229@s370_execu:
  008c4	b9 01 00 00 00	 mov	 ecx, 1
  008c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  008cf	8b 8d 88 00 00
	00		 mov	 ecx, DWORD PTR tv382[rbp]
  008d5	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  008d9	8b 8d 8c 00 00
	00		 mov	 ecx, DWORD PTR tv388[rbp]
  008df	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  008e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171577
  008ea	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171578
  008f6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008fb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00900	41 b9 03 00 00
	00		 mov	 r9d, 3
  00906	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171579
  0090d	ba 35 12 00 00	 mov	 edx, 4661		; 00001235H
  00912	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171580
  00919	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN48@s370_execu:
$LN46@s370_execu:

; 4662 :             }
; 4663 : 
; 4664 :             return execute_ccw_chain_fast_return( iobuf, &iobuf_initial, NULL );

  0091f	45 33 c0	 xor	 r8d, r8d
  00922	48 8d 95 00 20
	00 00		 lea	 rdx, QWORD PTR iobuf_initial$[rbp]
  00929	48 8b 4d 48	 mov	 rcx, QWORD PTR iobuf$[rbp]
  0092d	e8 00 00 00 00	 call	 execute_ccw_chain_fast_return
  00932	e9 ac 28 00 00	 jmp	 $LN1@s370_execu
$LN43@s370_execu:

; 4665 : 
; 4666 :         } /* end perform halt subchannel */
; 4667 : 
; 4668 :         /* Test for attention status from device */
; 4669 :         if (dev->scsw.flag3 & SCSW3_SC_ALERT)

  00937	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0093b	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00942	83 e0 10	 and	 eax, 16
  00945	85 c0		 test	 eax, eax
  00947	0f 84 80 01 00
	00		 je	 $LN49@s370_execu
$LN9@s370_execu:

; 4670 :         {
; 4671 :             IODELAY(dev);

  0094d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00954	83 b8 e0 13 00
	00 00		 cmp	 DWORD PTR [rax+5088], 0
  0095b	7e 2d		 jle	 SHORT $LN50@s370_execu
  0095d	b8 01 00 00 00	 mov	 eax, 1
  00962	48 6b c0 0a	 imul	 rax, rax, 10
  00966	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0096a	0f b6 84 01 6c
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1388]
  00972	83 f8 20	 cmp	 eax, 32			; 00000020H
  00975	75 13		 jne	 SHORT $LN50@s370_execu
  00977	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0097e	8b 88 e0 13 00
	00		 mov	 ecx, DWORD PTR [rax+5088]
  00984	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN50@s370_execu:
  0098a	33 c0		 xor	 eax, eax
  0098c	85 c0		 test	 eax, eax
  0098e	75 bd		 jne	 SHORT $LN9@s370_execu

; 4672 : 
; 4673 :             /* Call the i/o end exit */
; 4674 :             if (dev->hnd->end) (dev->hnd->end) (dev);

  00990	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00994	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0099b	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  009a0	74 12		 je	 SHORT $LN51@s370_execu
  009a2	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  009a6	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  009ad	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  009b1	ff 50 30	 call	 QWORD PTR [rax+48]
$LN51@s370_execu:

; 4675 : 
; 4676 :             /* Queue the pending interrupt and update status */
; 4677 :             queue_io_interrupt_and_update_status(dev,TRUE);

  009b4	ba 01 00 00 00	 mov	 edx, 1
  009b9	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  009bd	e8 00 00 00 00	 call	 queue_io_interrupt_and_update_status

; 4678 : 
; 4679 :             if (CCW_TRACING_ACTIVE( dev, tracethis ))

  009c2	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  009c6	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  009cc	c1 e8 0f	 shr	 eax, 15
  009cf	83 e0 01	 and	 eax, 1
  009d2	85 c0		 test	 eax, eax
  009d4	75 0c		 jne	 SHORT $LN53@s370_execu
  009d6	0f b6 45 15	 movzx	 eax, BYTE PTR tracethis$[rbp]
  009da	85 c0		 test	 eax, eax
  009dc	0f 84 d3 00 00
	00		 je	 $LN52@s370_execu
$LN53@s370_execu:

; 4680 :             {
; 4681 :                 if (dev->ccwtrace && sysblk.traceFILE)

  009e2	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  009e6	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  009ec	c1 e8 0f	 shr	 eax, 15
  009ef	83 e0 01	 and	 eax, 1
  009f2	85 c0		 test	 eax, eax
  009f4	74 20		 je	 SHORT $LN54@s370_execu
  009f6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  009fd	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00a05	74 0f		 je	 SHORT $LN54@s370_execu

; 4682 :                     tf_1307( dev );

  00a07	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00a0b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1307
  00a11	e9 9f 00 00 00	 jmp	 $LN55@s370_execu
$LN54@s370_execu:

; 4683 :                 else
; 4684 :                     // "%1d:%04X CHAN: attention completed"
; 4685 :                     WRMSG( HHC01307, "I", LCSS_DEVNUM );

  00a16	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  00a1b	74 10		 je	 SHORT $LN230@s370_execu
  00a1d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00a21	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00a25	89 85 90 00 00
	00		 mov	 DWORD PTR tv441[rbp], eax
  00a2b	eb 0a		 jmp	 SHORT $LN231@s370_execu
$LN230@s370_execu:
  00a2d	c7 85 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv441[rbp], 0
$LN231@s370_execu:
  00a37	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  00a3c	74 12		 je	 SHORT $LN232@s370_execu
  00a3e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00a42	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00a46	d1 f8		 sar	 eax, 1
  00a48	89 85 94 00 00
	00		 mov	 DWORD PTR tv447[rbp], eax
  00a4e	eb 0a		 jmp	 SHORT $LN233@s370_execu
$LN232@s370_execu:
  00a50	c7 85 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv447[rbp], 0
$LN233@s370_execu:
  00a5a	b9 01 00 00 00	 mov	 ecx, 1
  00a5f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a65	8b 8d 90 00 00
	00		 mov	 ecx, DWORD PTR tv441[rbp]
  00a6b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a6f	8b 8d 94 00 00
	00		 mov	 ecx, DWORD PTR tv447[rbp]
  00a75	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00a79	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171588
  00a80	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a85	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171589
  00a8c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a91	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a96	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a9c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171590
  00aa3	ba 4d 12 00 00	 mov	 edx, 4685		; 0000124dH
  00aa8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171591
  00aaf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN55@s370_execu:
$LN52@s370_execu:

; 4686 :             }
; 4687 : 
; 4688 :             return execute_ccw_chain_fast_return( iobuf, &iobuf_initial, NULL );

  00ab5	45 33 c0	 xor	 r8d, r8d
  00ab8	48 8d 95 00 20
	00 00		 lea	 rdx, QWORD PTR iobuf_initial$[rbp]
  00abf	48 8b 4d 48	 mov	 rcx, QWORD PTR iobuf$[rbp]
  00ac3	e8 00 00 00 00	 call	 execute_ccw_chain_fast_return
  00ac8	e9 16 27 00 00	 jmp	 $LN1@s370_execu
$LN49@s370_execu:

; 4689 : 
; 4690 :         } /* end attention processing */
; 4691 : 
; 4692 :         /* Clear the channel status and unit status, unless skipping
; 4693 :            to end of chain data */
; 4694 :         if (!skip_ccws)

  00acd	83 7d 54 00	 cmp	 DWORD PTR skip_ccws$[rbp], 0
  00ad1	75 08		 jne	 SHORT $LN56@s370_execu

; 4695 :         {
; 4696 :             chanstat = 0;

  00ad3	c6 45 09 00	 mov	 BYTE PTR chanstat$[rbp], 0

; 4697 :             unitstat = 0;

  00ad7	c6 45 0b 00	 mov	 BYTE PTR unitstat$[rbp], 0
$LN56@s370_execu:

; 4698 :         }
; 4699 : 
; 4700 :         /* Fetch the next CCW */
; 4701 :         ARCH_DEP(fetch_ccw) (dev, ccwkey, ccwfmt, ccwaddr, &opcode,

  00adb	48 8d 45 09	 lea	 rax, QWORD PTR chanstat$[rbp]
  00adf	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00ae4	48 8d 45 1c	 lea	 rax, QWORD PTR count$[rbp]
  00ae8	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00aed	48 8d 45 08	 lea	 rax, QWORD PTR flags$[rbp]
  00af1	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00af6	48 8d 45 2c	 lea	 rax, QWORD PTR addr$[rbp]
  00afa	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00aff	48 8d 45 0a	 lea	 rax, QWORD PTR opcode$[rbp]
  00b03	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b08	44 8b 4d 18	 mov	 r9d, DWORD PTR ccwaddr$[rbp]
  00b0c	44 0f b6 45 0c	 movzx	 r8d, BYTE PTR ccwfmt$[rbp]
  00b11	0f b6 55 14	 movzx	 edx, BYTE PTR ccwkey$[rbp]
  00b15	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00b19	e8 00 00 00 00	 call	 s370_fetch_ccw

; 4702 :                              &addr, &flags, &count, &chanstat);
; 4703 : 
; 4704 :         /*************************************************************/
; 4705 :         /* NOTE: Order of process must not only match the Principles */
; 4706 :         /*       of Operations, but must also match the processing   */
; 4707 :         /*       order of real channels.                             */
; 4708 :         /*************************************************************/
; 4709 : 
; 4710 :         /* For an invalid CCW address in a TIC we must backup to
; 4711 :            TIC+8 */
; 4712 :         if(ticaddr && (chanstat & CSW_PROGC))

  00b1e	83 7d 64 00	 cmp	 DWORD PTR ticaddr$[rbp], 0
  00b22	74 14		 je	 SHORT $LN57@s370_execu
  00b24	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  00b28	83 e0 20	 and	 eax, 32			; 00000020H
  00b2b	85 c0		 test	 eax, eax
  00b2d	74 09		 je	 SHORT $LN57@s370_execu

; 4713 :             ccwaddr = ticaddr-8;

  00b2f	8b 45 64	 mov	 eax, DWORD PTR ticaddr$[rbp]
  00b32	83 e8 08	 sub	 eax, 8
  00b35	89 45 18	 mov	 DWORD PTR ccwaddr$[rbp], eax
$LN57@s370_execu:

; 4714 : 
; 4715 :         /* Point to the CCW in main storage */
; 4716 :         ccw = dev->mainstor + ccwaddr;

  00b38	8b 45 18	 mov	 eax, DWORD PTR ccwaddr$[rbp]
  00b3b	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00b3f	48 03 81 80 00
	00 00		 add	 rax, QWORD PTR [rcx+128]
  00b46	48 89 45 70	 mov	 QWORD PTR ccw$[rbp], rax

; 4717 : 
; 4718 :         /* Increment to next CCW address */
; 4719 :         ccwaddr += 8;

  00b4a	8b 45 18	 mov	 eax, DWORD PTR ccwaddr$[rbp]
  00b4d	83 c0 08	 add	 eax, 8
  00b50	89 45 18	 mov	 DWORD PTR ccwaddr$[rbp], eax

; 4720 : 
; 4721 :         /* If prefetch, update prefetch table */
; 4722 :         if (prefetch.seq && (dev->chained & CCW_FLAGS_CD))

  00b53	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  00b5a	0f 84 93 00 00
	00		 je	 $LN58@s370_execu
  00b60	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00b64	0f b6 80 78 02
	00 00		 movzx	 eax, BYTE PTR [rax+632]
  00b6b	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00b70	85 c0		 test	 eax, eax
  00b72	74 7f		 je	 SHORT $LN58@s370_execu

; 4723 :         {
; 4724 :             ps = prefetch.seq++;

  00b74	8b 85 c0 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp]
  00b7a	89 45 10	 mov	 DWORD PTR ps$[rbp], eax
  00b7d	8b 85 c0 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp]
  00b83	ff c0		 inc	 eax
  00b85	89 85 c0 01 00
	00		 mov	 DWORD PTR prefetch$[rbp], eax

; 4725 :             if (prefetch.seq > PF_SIZE)

  00b8b	81 bd c0 01 00
	00 00 01 00 00	 cmp	 DWORD PTR prefetch$[rbp], 256 ; 00000100H
  00b95	76 05		 jbe	 SHORT $LN60@s370_execu

; 4726 :                 goto breakchain;

  00b97	e9 39 15 00 00	 jmp	 $breakchain$298
$LN60@s370_execu:

; 4727 :             prefetch.ccwaddr[ps] = ccwaddr;

  00b9c	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  00b9f	8b 4d 18	 mov	 ecx, DWORD PTR ccwaddr$[rbp]
  00ba2	89 8c 85 d0 02
	00 00		 mov	 DWORD PTR prefetch$[rbp+rax*4+272], ecx

; 4728 :             prefetch.ccwflags[ps] = flags;

  00ba9	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  00bac	0f b6 4d 08	 movzx	 ecx, BYTE PTR flags$[rbp]
  00bb0	88 8c 05 d0 12
	00 00		 mov	 BYTE PTR prefetch$[rbp+rax+4368], cl

; 4729 :             prefetch.ccwcount[ps] =

  00bb7	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  00bba	8b 4d 1c	 mov	 ecx, DWORD PTR count$[rbp]
  00bbd	89 8c 85 d0 06
	00 00		 mov	 DWORD PTR prefetch$[rbp+rax*4+1296], ecx
  00bc4	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  00bc7	0f b7 4d 1c	 movzx	 ecx, WORD PTR count$[rbp]
  00bcb	66 89 8c 45 d0
	13 00 00	 mov	 WORD PTR prefetch$[rbp+rax*2+4624], cx

; 4730 :             prefetch.datalen[ps] = count;
; 4731 :             prefetch.dataaddr[ps] = addr;

  00bd3	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  00bd6	8b 4d 2c	 mov	 ecx, DWORD PTR addr$[rbp]
  00bd9	48 89 8c c5 d0
	0a 00 00	 mov	 QWORD PTR prefetch$[rbp+rax*8+2320], rcx

; 4732 : 
; 4733 :             /* Exit if fetch_ccw detected channel program check */
; 4734 :             if (chanstat)

  00be1	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  00be5	85 c0		 test	 eax, eax
  00be7	74 05		 je	 SHORT $LN61@s370_execu

; 4735 :                 goto prefetch;

  00be9	e9 6b 0d 00 00	 jmp	 $prefetch$299
$LN61@s370_execu:

; 4736 :         }

  00bee	e9 dc 00 00 00	 jmp	 $LN59@s370_execu
$LN58@s370_execu:

; 4737 :         else
; 4738 :         {
; 4739 :             /* Update the CCW address in the SCSW */
; 4740 :             STORE_FW(dev->scsw.ccwaddr,ccwaddr);

  00bf3	8b 4d 18	 mov	 ecx, DWORD PTR ccwaddr$[rbp]
  00bf6	e8 00 00 00 00	 call	 _byteswap_ulong
  00bfb	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00bff	48 81 c1 0c 03
	00 00		 add	 rcx, 780		; 0000030cH
  00c06	8b d0		 mov	 edx, eax
  00c08	e8 00 00 00 00	 call	 store_fw_noswap

; 4741 : 
; 4742 :             /* Exit if fetch_ccw detected channel program check */
; 4743 :             if (chanstat != 0)

  00c0d	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  00c11	85 c0		 test	 eax, eax
  00c13	74 05		 je	 SHORT $LN62@s370_execu

; 4744 :                 goto breakchain;

  00c15	e9 bb 14 00 00	 jmp	 $breakchain$298
$LN62@s370_execu:

; 4745 : 
; 4746 :             /* Trace the CCW -- UNLESS ... it's a read type! For read
; 4747 :                type CCWs, we defer the tracing until AFTER the CCW has
; 4748 :                been executed and the data copied to storage (i.e. we
; 4749 :                don't trace the CCW until after BOTH the driver's CCW
; 4750 :                handler (dev->hnd->exec) and ARCH_DEP(copy_iobuf) have
; 4751 :                been called; see much further below).
; 4752 :             */
; 4753 :             if (1
; 4754 :                 && dev->ccwtrace
; 4755 :                 && !(0

  00c1a	33 c0		 xor	 eax, eax
  00c1c	83 f8 01	 cmp	 eax, 1
  00c1f	0f 84 aa 00 00
	00		 je	 $LN63@s370_execu
  00c25	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00c29	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00c2f	c1 e8 0f	 shr	 eax, 15
  00c32	83 e0 01	 and	 eax, 1
  00c35	85 c0		 test	 eax, eax
  00c37	0f 84 92 00 00
	00		 je	 $LN63@s370_execu
  00c3d	33 c0		 xor	 eax, eax
  00c3f	85 c0		 test	 eax, eax
  00c41	0f 85 88 00 00
	00		 jne	 $LN63@s370_execu
  00c47	b8 01 00 00 00	 mov	 eax, 1
  00c4c	48 6b c0 00	 imul	 rax, rax, 0
  00c50	48 8b 4d 70	 mov	 rcx, QWORD PTR ccw$[rbp]
  00c54	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00c58	83 e0 03	 and	 eax, 3
  00c5b	83 f8 02	 cmp	 eax, 2
  00c5e	74 6f		 je	 SHORT $LN63@s370_execu
  00c60	b8 01 00 00 00	 mov	 eax, 1
  00c65	48 6b c0 00	 imul	 rax, rax, 0
  00c69	48 8b 4d 70	 mov	 rcx, QWORD PTR ccw$[rbp]
  00c6d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00c71	83 e0 0f	 and	 eax, 15
  00c74	83 f8 0c	 cmp	 eax, 12
  00c77	74 56		 je	 SHORT $LN63@s370_execu
  00c79	b8 01 00 00 00	 mov	 eax, 1
  00c7e	48 6b c0 00	 imul	 rax, rax, 0
  00c82	48 8b 4d 70	 mov	 rcx, QWORD PTR ccw$[rbp]
  00c86	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00c8a	83 e0 0f	 and	 eax, 15
  00c8d	83 f8 04	 cmp	 eax, 4
  00c90	74 3d		 je	 SHORT $LN63@s370_execu

; 4756 :                      || IS_CCW_READ  ( ccw[0] )
; 4757 :                      || IS_CCW_RDBACK( ccw[0] )
; 4758 :                      || IS_CCW_SENSE ( ccw[0] )
; 4759 :                     )
; 4760 :             )
; 4761 :                 DISPLAY_CCW( dev, ccw, addr, count, flags );

  00c92	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171600
  00c99	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00c9e	c7 44 24 30 99
	12 00 00	 mov	 DWORD PTR [rsp+48], 4761 ; 00001299H
  00ca6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171601
  00cad	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00cb2	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  00cb6	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00cba	44 8b 4d 1c	 mov	 r9d, DWORD PTR count$[rbp]
  00cbe	44 8b 45 2c	 mov	 r8d, DWORD PTR addr$[rbp]
  00cc2	48 8b 55 70	 mov	 rdx, QWORD PTR ccw$[rbp]
  00cc6	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00cca	e8 00 00 00 00	 call	 _display_ccw
$LN63@s370_execu:
$LN59@s370_execu:

; 4762 :         }
; 4763 : 
; 4764 :         /* Channel program check if invalid Format-1 CCW             */
; 4765 :         /* SA22-7201-05:                                             */
; 4766 :         /*  pp. 15-23 -- 15-24, Channel_Command Word                 */
; 4767 :         /*  p. 15-25, Count                                          */
; 4768 :         /*  p. 16-25, Invalid Count, Format 1                        */
; 4769 :         if (ccwfmt == 1 &&                  /* Validate Format 1     */

  00ccf	0f b6 45 0c	 movzx	 eax, BYTE PTR ccwfmt$[rbp]
  00cd3	83 f8 01	 cmp	 eax, 1
  00cd6	75 3a		 jne	 SHORT $LN64@s370_execu
  00cd8	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  00cdc	83 f8 08	 cmp	 eax, 8
  00cdf	74 31		 je	 SHORT $LN64@s370_execu
  00ce1	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00ce5	0f b6 80 78 02
	00 00		 movzx	 eax, BYTE PTR [rax+632]
  00cec	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00cf1	85 c0		 test	 eax, eax
  00cf3	74 1d		 je	 SHORT $LN64@s370_execu
  00cf5	83 7d 1c 00	 cmp	 DWORD PTR count$[rbp], 0
  00cf9	75 17		 jne	 SHORT $LN64@s370_execu

; 4770 :             ((opcode != 0x08)              &&
; 4771 :              (dev->chained & CCW_FLAGS_CD) &&
; 4772 :              !count))
; 4773 :             {
; 4774 :                 chanstat = CSW_PROGC;

  00cfb	c6 45 09 20	 mov	 BYTE PTR chanstat$[rbp], 32 ; 00000020H

; 4775 :                 if (prefetch.seq)

  00cff	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  00d06	74 05		 je	 SHORT $LN65@s370_execu

; 4776 :                     goto prefetch;

  00d08	e9 4c 0c 00 00	 jmp	 $prefetch$299
$LN65@s370_execu:

; 4777 :                 goto breakchain;

  00d0d	e9 c3 13 00 00	 jmp	 $breakchain$298
$LN64@s370_execu:

; 4778 :             }
; 4779 : 
; 4780 :         /* Channel program check if invalid TIC opcode or invalid    */
; 4781 :         /* TIC Format-1 CCW                                          */
; 4782 :         /* SA22-7201-05:                                             */
; 4783 :         /*  p. 15-25, Figure 15-5. Command Code Assignment           */
; 4784 :         /*  p. 15-36, Figure 15-7. Command Codes and Flags           */
; 4785 :         /*  p. 15-37, Transfer in Channel                            */
; 4786 :         if (opcode == 0x08 ||               /* Validate TIC          */

  00d12	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  00d16	83 f8 08	 cmp	 eax, 8
  00d19	74 1c		 je	 SHORT $LN67@s370_execu
  00d1b	0f b6 45 0c	 movzx	 eax, BYTE PTR ccwfmt$[rbp]
  00d1f	85 c0		 test	 eax, eax
  00d21	0f 85 04 01 00
	00		 jne	 $LN66@s370_execu
  00d27	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  00d2b	83 e0 0f	 and	 eax, 15
  00d2e	83 f8 08	 cmp	 eax, 8
  00d31	0f 85 f4 00 00
	00		 jne	 $LN66@s370_execu
$LN67@s370_execu:

; 4787 :             (ccwfmt == 0 &&
; 4788 :              ((opcode & 0x0F) == 0x08)))
; 4789 :         {
; 4790 :             if (ticaddr                  || /* No TIC-to-TIC         */
; 4791 :                 (addr & 0x03)            || /* Must be aligned DWORD */
; 4792 :                 (ccwfmt == 1 &&             /* Validate Format 1     */
; 4793 :                  (flags           ||
; 4794 :                   count))                ||

  00d37	83 7d 64 00	 cmp	 DWORD PTR ticaddr$[rbp], 0
  00d3b	75 2c		 jne	 SHORT $LN69@s370_execu
  00d3d	8b 45 2c	 mov	 eax, DWORD PTR addr$[rbp]
  00d40	83 e0 03	 and	 eax, 3
  00d43	85 c0		 test	 eax, eax
  00d45	75 22		 jne	 SHORT $LN69@s370_execu
  00d47	0f b6 45 0c	 movzx	 eax, BYTE PTR ccwfmt$[rbp]
  00d4b	83 f8 01	 cmp	 eax, 1
  00d4e	75 0e		 jne	 SHORT $LN70@s370_execu
  00d50	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  00d54	85 c0		 test	 eax, eax
  00d56	75 11		 jne	 SHORT $LN69@s370_execu
  00d58	83 7d 1c 00	 cmp	 DWORD PTR count$[rbp], 0
  00d5c	75 0b		 jne	 SHORT $LN69@s370_execu
$LN70@s370_execu:
  00d5e	0f b7 45 44	 movzx	 eax, WORD PTR ticback$[rbp]
  00d62	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00d67	7e 30		 jle	 SHORT $LN68@s370_execu
$LN69@s370_execu:

; 4795 :                 ticback > 255               /* Exceeded TIC limit?   */
; 4796 :                 )
; 4797 :             {
; 4798 :                 chanstat = CSW_PROGC;

  00d69	c6 45 09 20	 mov	 BYTE PTR chanstat$[rbp], 32 ; 00000020H

; 4799 :                 if (prefetch.seq)

  00d6d	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  00d74	74 1e		 je	 SHORT $LN71@s370_execu

; 4800 :                 {
; 4801 :                     prefetch.ccwflags[ps] = 0;

  00d76	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  00d79	c6 84 05 d0 12
	00 00 00	 mov	 BYTE PTR prefetch$[rbp+rax+4368], 0

; 4802 :                     prefetch.datalen[ps] = 0;

  00d81	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  00d84	c7 84 85 d0 06
	00 00 00 00 00
	00		 mov	 DWORD PTR prefetch$[rbp+rax*4+1296], 0

; 4803 :                     goto prefetch;

  00d8f	e9 c5 0b 00 00	 jmp	 $prefetch$299
$LN71@s370_execu:

; 4804 :                 }
; 4805 :                 goto breakchain;

  00d94	e9 3c 13 00 00	 jmp	 $breakchain$298
$LN68@s370_execu:

; 4806 :             }
; 4807 : 
; 4808 :             /* Reuse prefetch entry for next CCW */
; 4809 :             if (prefetch.seq)

  00d99	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  00da0	74 59		 je	 SHORT $LN72@s370_execu

; 4810 :             {
; 4811 :                 prefetch.ccwaddr[ps] = 0;

  00da2	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  00da5	c7 84 85 d0 02
	00 00 00 00 00
	00		 mov	 DWORD PTR prefetch$[rbp+rax*4+272], 0

; 4812 :                 prefetch.ccwflags[ps] = 0;

  00db0	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  00db3	c6 84 05 d0 12
	00 00 00	 mov	 BYTE PTR prefetch$[rbp+rax+4368], 0

; 4813 :                 prefetch.ccwcount[ps] = 0;

  00dbb	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  00dbe	33 c9		 xor	 ecx, ecx
  00dc0	66 89 8c 45 d0
	13 00 00	 mov	 WORD PTR prefetch$[rbp+rax*2+4624], cx

; 4814 :                 prefetch.dataaddr[ps] = 0;

  00dc8	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  00dcb	48 c7 84 c5 d0
	0a 00 00 00 00
	00 00		 mov	 QWORD PTR prefetch$[rbp+rax*8+2320], 0

; 4815 :                 prefetch.datalen[ps] = 0;

  00dd7	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  00dda	c7 84 85 d0 06
	00 00 00 00 00
	00		 mov	 DWORD PTR prefetch$[rbp+rax*4+1296], 0

; 4816 :                 ps--;

  00de5	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  00de8	ff c8		 dec	 eax
  00dea	89 45 10	 mov	 DWORD PTR ps$[rbp], eax

; 4817 :                 prefetch.seq--;

  00ded	8b 85 c0 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp]
  00df3	ff c8		 dec	 eax
  00df5	89 85 c0 01 00
	00		 mov	 DWORD PTR prefetch$[rbp], eax
$LN72@s370_execu:

; 4818 :             }
; 4819 : 
; 4820 :             /* Update backwards TIC counter */
; 4821 :             if (addr < ccwaddr)

  00dfb	8b 45 18	 mov	 eax, DWORD PTR ccwaddr$[rbp]
  00dfe	39 45 2c	 cmp	 DWORD PTR addr$[rbp], eax
  00e01	73 0d		 jae	 SHORT $LN73@s370_execu

; 4822 :                 ticback++;

  00e03	0f b7 45 44	 movzx	 eax, WORD PTR ticback$[rbp]
  00e07	66 ff c0	 inc	 ax
  00e0a	66 89 45 44	 mov	 WORD PTR ticback$[rbp], ax
  00e0e	eb 06		 jmp	 SHORT $LN74@s370_execu
$LN73@s370_execu:

; 4823 :             else
; 4824 :                 ticback = 0;

  00e10	33 c0		 xor	 eax, eax
  00e12	66 89 45 44	 mov	 WORD PTR ticback$[rbp], ax
$LN74@s370_execu:

; 4825 : 
; 4826 :             /* Set new CCW address (leaving the values of chained and
; 4827 :                code untouched to allow data-chaining through TIC)    */
; 4828 :             ticaddr = ccwaddr;

  00e16	8b 45 18	 mov	 eax, DWORD PTR ccwaddr$[rbp]
  00e19	89 45 64	 mov	 DWORD PTR ticaddr$[rbp], eax

; 4829 :             ccwaddr = addr;

  00e1c	8b 45 2c	 mov	 eax, DWORD PTR addr$[rbp]
  00e1f	89 45 18	 mov	 DWORD PTR ccwaddr$[rbp], eax

; 4830 :             chain = 1;

  00e22	c6 45 17 01	 mov	 BYTE PTR chain$[rbp], 1

; 4831 :             continue;

  00e26	e9 c5 f8 ff ff	 jmp	 $LN2@s370_execu
$LN66@s370_execu:

; 4832 :         }
; 4833 :         ticaddr = 0;                    /* Reset the TIC-to-TIC flag */

  00e2b	c7 45 64 00 00
	00 00		 mov	 DWORD PTR ticaddr$[rbp], 0

; 4834 : 
; 4835 :         /* Reset TIC back counter if Read or Write CCW               */
; 4836 :         if (IS_CCW_WRITE(opcode) ||
; 4837 :             IS_CCW_READ(opcode)  ||

  00e32	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  00e36	83 e0 03	 and	 eax, 3
  00e39	83 f8 01	 cmp	 eax, 1
  00e3c	74 18		 je	 SHORT $LN76@s370_execu
  00e3e	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  00e42	83 e0 03	 and	 eax, 3
  00e45	83 f8 02	 cmp	 eax, 2
  00e48	74 0c		 je	 SHORT $LN76@s370_execu
  00e4a	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  00e4e	83 e0 0f	 and	 eax, 15
  00e51	83 f8 0c	 cmp	 eax, 12
  00e54	75 06		 jne	 SHORT $LN75@s370_execu
$LN76@s370_execu:

; 4838 :             IS_CCW_RDBACK(opcode))
; 4839 :             ticback = 0;

  00e56	33 c0		 xor	 eax, eax
  00e58	66 89 45 44	 mov	 WORD PTR ticback$[rbp], ax
$LN75@s370_execu:

; 4840 : 
; 4841 :         /* At this point, the CCW now has "control" of the I/O       */
; 4842 :         /* operation (SA22-7201 p. 15-24, PCI). Signal I/O interrupt */
; 4843 :         /* if PCI flag is set                                        */
; 4844 :         if (flags & CCW_FLAGS_PCI)   /* -- Debug && !prefetch.seq -- */

  00e5c	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  00e60	83 e0 08	 and	 eax, 8
  00e63	85 c0		 test	 eax, eax
  00e65	74 16		 je	 SHORT $LN77@s370_execu

; 4845 :         {
; 4846 :             ARCH_DEP(raise_pci) (dev, ccwkey, ccwfmt, ccwaddr);

  00e67	44 8b 4d 18	 mov	 r9d, DWORD PTR ccwaddr$[rbp]
  00e6b	44 0f b6 45 0c	 movzx	 r8d, BYTE PTR ccwfmt$[rbp]
  00e70	0f b6 55 14	 movzx	 edx, BYTE PTR ccwkey$[rbp]
  00e74	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00e78	e8 00 00 00 00	 call	 s370_raise_pci
$LN77@s370_execu:

; 4847 :         }
; 4848 : 
; 4849 :         /* Validate basic CCW command                                */
; 4850 :         /* SA22-7201-05:                                             */
; 4851 :         /*  p. 15-25, Figure 15-5. Command Code Assignment           */
; 4852 :         /* Note: TIC validation not included as TIC has already been */
; 4853 :         /*       validated and processed.                            */
; 4854 :         if (!(dev->chained & CCW_FLAGS_CD) &&

  00e7d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00e81	0f b6 80 78 02
	00 00		 movzx	 eax, BYTE PTR [rax+632]
  00e88	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00e8d	85 c0		 test	 eax, eax
  00e8f	75 5e		 jne	 SHORT $LN78@s370_execu
  00e91	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  00e95	83 e0 0f	 and	 eax, 15
  00e98	85 c0		 test	 eax, eax
  00e9a	74 3c		 je	 SHORT $LN79@s370_execu
  00e9c	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  00ea0	83 e0 03	 and	 eax, 3
  00ea3	83 f8 01	 cmp	 eax, 1
  00ea6	74 47		 je	 SHORT $LN78@s370_execu
  00ea8	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  00eac	83 e0 03	 and	 eax, 3
  00eaf	83 f8 02	 cmp	 eax, 2
  00eb2	74 3b		 je	 SHORT $LN78@s370_execu
  00eb4	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  00eb8	83 e0 0f	 and	 eax, 15
  00ebb	83 f8 0c	 cmp	 eax, 12
  00ebe	74 2f		 je	 SHORT $LN78@s370_execu
  00ec0	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  00ec4	83 e0 03	 and	 eax, 3
  00ec7	83 f8 03	 cmp	 eax, 3
  00eca	74 23		 je	 SHORT $LN78@s370_execu
  00ecc	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  00ed0	83 e0 0f	 and	 eax, 15
  00ed3	83 f8 04	 cmp	 eax, 4
  00ed6	74 17		 je	 SHORT $LN78@s370_execu
$LN79@s370_execu:

; 4855 :             !((opcode & 0x0F) != 0      &&
; 4856 :               (IS_CCW_WRITE(opcode)   ||
; 4857 :                IS_CCW_READ(opcode)    ||
; 4858 :                IS_CCW_RDBACK(opcode)  ||
; 4859 :                IS_CCW_CONTROL(opcode) ||
; 4860 :                IS_CCW_SENSE(opcode))))
; 4861 :         {
; 4862 :             chanstat = CSW_PROGC;

  00ed8	c6 45 09 20	 mov	 BYTE PTR chanstat$[rbp], 32 ; 00000020H

; 4863 :             if (prefetch.seq)

  00edc	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  00ee3	74 05		 je	 SHORT $LN80@s370_execu

; 4864 :                 goto prefetch;

  00ee5	e9 6f 0a 00 00	 jmp	 $prefetch$299
$LN80@s370_execu:

; 4865 :             goto breakchain;

  00eea	e9 e6 11 00 00	 jmp	 $breakchain$298
$LN78@s370_execu:

; 4866 :         }
; 4867 : 
; 4868 :         /* Validate chain data (CD) flag                             */
; 4869 :         /* SA22-7201-05:                                             */
; 4870 :         /*  p. 16-26, program check if suspend specified             */
; 4871 :         /*  p. 15-24, Chain-Data (CD) Flag                           */
; 4872 :         if (flags & CCW_FLAGS_CD)

  00eef	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  00ef3	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00ef8	85 c0		 test	 eax, eax
  00efa	74 2c		 je	 SHORT $LN81@s370_execu

; 4873 :         {
; 4874 :             if (flags & CCW_FLAGS_SUSP)

  00efc	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  00f00	83 e0 02	 and	 eax, 2
  00f03	85 c0		 test	 eax, eax
  00f05	74 17		 je	 SHORT $LN82@s370_execu

; 4875 :             {
; 4876 :                 chanstat = CSW_PROGC;

  00f07	c6 45 09 20	 mov	 BYTE PTR chanstat$[rbp], 32 ; 00000020H

; 4877 :                 if (prefetch.seq)

  00f0b	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  00f12	74 05		 je	 SHORT $LN83@s370_execu

; 4878 :                     goto prefetch;

  00f14	e9 40 0a 00 00	 jmp	 $prefetch$299
$LN83@s370_execu:

; 4879 :                 goto breakchain;

  00f19	e9 b7 11 00 00	 jmp	 $breakchain$298
$LN82@s370_execu:

; 4880 :             }
; 4881 : 
; 4882 :             /* Turn off suppress indicator bits for processing       */
; 4883 :             /* purposes as setting is ignored with CD.               */
; 4884 :             flags &= ~CCW_FLAGS_SLI;

  00f1e	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  00f22	83 e0 df	 and	 eax, -33		; ffffffffffffffdfH
  00f25	88 45 08	 mov	 BYTE PTR flags$[rbp], al
$LN81@s370_execu:

; 4885 :         }
; 4886 : 
; 4887 :         /* Validate command chain (CC) flag                          */
; 4888 :         /* SA22-7201-05:                                             */
; 4889 :         /*  p. 15-24, Chain-Command (CC) Flag                        */
; 4890 :         /*-------------------------------------------------------------
; 4891 :         //
; 4892 :         // Note: With CD check first, this test will always be false.
; 4893 :         //       Code left here in comment for documentation purposes.
; 4894 :         //
; 4895 :         // if (flags & (CCW_FLAGS_CC | CCW_FLAGS_CD) ==
; 4896 :         //             (CCW_FLAGS_CC | CCW_FLAGS_CD))
; 4897 :         //     flags &= ~CCW_FLAGS_CC;
; 4898 :         -------------------------------------------------------------*/
; 4899 : 
; 4900 :         /* Validate suppress length indication (SLI) flag            */
; 4901 :         /* SA22-7201-05:                                             */
; 4902 :         /*  p. 15-24, Supress-Length-Indication (SLI) Flag           */
; 4903 :         /*-------------------------------------------------------------
; 4904 :         //
; 4905 :         // Note: With CD check first, this test will always be false.
; 4906 :         //       Code left here in comment for documentation purposes.
; 4907 :         //
; 4908 :         // if (flags & (CCW_FLAGS_CD | CCW_FLAGS_SLI)) ==
; 4909 :         //             (CCW_FLAGS_CD | CCW_FLAGS_SLI)))
; 4910 :         //     flags &= ~CCW_FLAGS_SLI;
; 4911 :         -------------------------------------------------------------*/
; 4912 : 
; 4913 :         /* Validate skip flag                                        */
; 4914 :         /* SA22-7201-05:                                             */
; 4915 :         /*  p. 15-24, Skip (SKIP) Flag                               */
; 4916 :         /*-------------------------------------------------------------
; 4917 :         //
; 4918 :         // Note: Check against MIDAW down in MIDAW validation section.
; 4919 :         //       Code left here in comment for documentation purposes.
; 4920 :         //
; 4921 :         // if (flags & CCW_FLAGS_SKIP)
; 4922 :         // {}
; 4923 :         -------------------------------------------------------------*/
; 4924 : 
; 4925 :         /* Validate program controlled interruption (PCI) flag       */
; 4926 :         /* SA22-7201-05:                                             */
; 4927 :         /*  p. 15-24, Program Controlled Interruption (PCI) Flag     */
; 4928 :         /*-------------------------------------------------------------
; 4929 :         //
; 4930 :         // Note: No validation required.
; 4931 :         //       Code left here in comment for documentation purposes.
; 4932 :         //
; 4933 :         // if (flags & CCW_FLAGS_PCI)
; 4934 :         // {}
; 4935 :         -------------------------------------------------------------*/
; 4936 : 
; 4937 : #if !defined(FEATURE_MIDAW_FACILITY)
; 4938 :         /* Channel program check if MIDAW not installed */
; 4939 :         if (flags & CCW_FLAGS_MIDAW)

  00f28	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  00f2c	83 e0 01	 and	 eax, 1
  00f2f	85 c0		 test	 eax, eax
  00f31	74 17		 je	 SHORT $LN84@s370_execu

; 4940 :         {
; 4941 :             chanstat = CSW_PROGC;

  00f33	c6 45 09 20	 mov	 BYTE PTR chanstat$[rbp], 32 ; 00000020H

; 4942 :             if (prefetch.seq)

  00f37	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  00f3e	74 05		 je	 SHORT $LN85@s370_execu

; 4943 :                 goto prefetch;

  00f40	e9 14 0a 00 00	 jmp	 $prefetch$299
$LN85@s370_execu:

; 4944 :             goto breakchain;

  00f45	e9 8b 11 00 00	 jmp	 $breakchain$298
$LN84@s370_execu:

; 4945 :         }
; 4946 : #endif /*!defined(FEATURE_MIDAW_FACILITY)*/
; 4947 : 
; 4948 : #if defined(FEATURE_MIDAW_FACILITY)
; 4949 :         /* Channel program check if MIDAW not enabled in ORB, or     */
; 4950 :         /* with SKIP or IDA specified                                */
; 4951 :         if ((flags & CCW_FLAGS_MIDAW) &&
; 4952 :             ((dev->orb.flag7 & ORB7_D) == 0 ||
; 4953 :              (flags & (CCW_FLAGS_SKIP | CCW_FLAGS_IDA))))
; 4954 :         {
; 4955 :             chanstat = CSW_PROGC;
; 4956 :             if (prefetch.seq)
; 4957 :                 goto prefetch;
; 4958 :             goto breakchain;
; 4959 :         }
; 4960 : #endif /*defined(FEATURE_MIDAW_FACILITY)*/
; 4961 : 
; 4962 :         /* Suspend supported prior to GA22-7000-10 for the S/370     */
; 4963 :         /* Suspend channel program if suspend flag is set */
; 4964 :         if (flags & CCW_FLAGS_SUSP)

  00f4a	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  00f4e	83 e0 02	 and	 eax, 2
  00f51	85 c0		 test	 eax, eax
  00f53	0f 84 2b 04 00
	00		 je	 $LN86@s370_execu

; 4965 :         {
; 4966 :             /* Channel program check if the ORB suspend control bit
; 4967 :                was zero, or if this is a data chained CCW */
; 4968 :             if ((dev->orb.flag4 & ORB4_S) == 0
; 4969 :                 || (dev->chained & CCW_FLAGS_CD))

  00f59	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00f5d	0f b6 80 d0 02
	00 00		 movzx	 eax, BYTE PTR [rax+720]
  00f64	83 e0 08	 and	 eax, 8
  00f67	85 c0		 test	 eax, eax
  00f69	74 14		 je	 SHORT $LN88@s370_execu
  00f6b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00f6f	0f b6 80 78 02
	00 00		 movzx	 eax, BYTE PTR [rax+632]
  00f76	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00f7b	85 c0		 test	 eax, eax
  00f7d	74 17		 je	 SHORT $LN87@s370_execu
$LN88@s370_execu:

; 4970 :             {
; 4971 :                 chanstat = CSW_PROGC;

  00f7f	c6 45 09 20	 mov	 BYTE PTR chanstat$[rbp], 32 ; 00000020H

; 4972 :                 if (prefetch.seq)

  00f83	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  00f8a	74 05		 je	 SHORT $LN89@s370_execu

; 4973 :                     goto prefetch;

  00f8c	e9 c8 09 00 00	 jmp	 $prefetch$299
$LN89@s370_execu:

; 4974 :                 goto breakchain;

  00f91	e9 3f 11 00 00	 jmp	 $breakchain$298
$LN87@s370_execu:
$LN12@s370_execu:

; 4975 :             }
; 4976 : 
; 4977 :             IODELAY(dev);

  00f96	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00f9d	83 b8 e0 13 00
	00 00		 cmp	 DWORD PTR [rax+5088], 0
  00fa4	7e 2d		 jle	 SHORT $LN90@s370_execu
  00fa6	b8 01 00 00 00	 mov	 eax, 1
  00fab	48 6b c0 0a	 imul	 rax, rax, 10
  00faf	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  00fb3	0f b6 84 01 6c
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1388]
  00fbb	83 f8 20	 cmp	 eax, 32			; 00000020H
  00fbe	75 13		 jne	 SHORT $LN90@s370_execu
  00fc0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00fc7	8b 88 e0 13 00
	00		 mov	 ecx, DWORD PTR [rax+5088]
  00fcd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN90@s370_execu:
  00fd3	33 c0		 xor	 eax, eax
  00fd5	85 c0		 test	 eax, eax
  00fd7	75 bd		 jne	 SHORT $LN12@s370_execu

; 4978 : 
; 4979 :             /* If halt or clear, abort suspend operation */
; 4980 :             if (dev->scsw.flag2 & (SCSW2_AC_HALT | SCSW2_AC_CLEAR))

  00fd9	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00fdd	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00fe4	83 e0 03	 and	 eax, 3
  00fe7	85 c0		 test	 eax, eax
  00fe9	74 1c		 je	 SHORT $LN91@s370_execu

; 4981 :             {
; 4982 :                 if (dev->scsw.flag2 & SCSW2_AC_HALT)

  00feb	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  00fef	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00ff6	83 e0 02	 and	 eax, 2
  00ff9	85 c0		 test	 eax, eax
  00ffb	74 05		 je	 SHORT $LN92@s370_execu

; 4983 :                     goto execute_halt;

  00ffd	e9 35 f8 ff ff	 jmp	 $execute_halt$296
$LN92@s370_execu:

; 4984 :                 goto execute_clear;

  01002	e9 46 f7 ff ff	 jmp	 $execute_clear$295
$LN91@s370_execu:

; 4985 :             }
; 4986 : 
; 4987 :             /* Call the i/o suspend exit */
; 4988 :             if (dev->hnd->suspend) (dev->hnd->suspend) (dev);

  01007	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0100b	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  01012	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  01017	74 12		 je	 SHORT $LN93@s370_execu
  01019	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0101d	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  01024	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01028	ff 50 40	 call	 QWORD PTR [rax+64]
$LN93@s370_execu:

; 4989 : 
; 4990 :             OBTAIN_INTLOCK(NULL);

  0102b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171632
  01032	33 c9		 xor	 ecx, ecx
  01034	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 4991 :             obtain_lock (&dev->lock);

  01039	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0103d	48 83 c0 38	 add	 rax, 56			; 00000038H
  01041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171633
  01048	48 8b c8	 mov	 rcx, rax
  0104b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4992 : 
; 4993 :             /* Suspend the device if not already resume pending */
; 4994 :             if (!(dev->scsw.flag2 & (SCSW2_AC_RESUM)))

  01051	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01055	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  0105c	83 e0 08	 and	 eax, 8
  0105f	85 c0		 test	 eax, eax
  01061	0f 85 f7 02 00
	00		 jne	 $LN94@s370_execu

; 4995 :             {
; 4996 :                 /* Clean up device and complete suspension exit */
; 4997 :                 clear_subchannel_busy(dev);

  01067	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0106b	e8 00 00 00 00	 call	 clear_subchannel_busy

; 4998 : 
; 4999 :                 /* Set the subchannel status word to suspended       */
; 5000 :                 /* SA22-7201-05:                                     */
; 5001 :                 /*  p. 16-15, Subchannel-Active (Bit 24)             */
; 5002 :                 /*  pp. 16-15 -- 16-16, Device-Active (Bit 25)       */
; 5003 :                 /*  p. 16-16, Suspended (Bit 26)                     */
; 5004 :                 /*  p. 16-16, Alert Status (Bit 27)                  */
; 5005 :                 /*  p. 16-17, Intermediate Status (Bit 28)           */
; 5006 :                 /*  p. 16-18, Status-Pending (Bit 31)                */
; 5007 :                 dev->scsw.flag3 &= ~(SCSW3_AC_SCHAC |

  01070	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01074	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  0107b	25 3f ff ff ff	 and	 eax, -193		; ffffffffffffff3fH
  01080	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01084	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 5008 :                                      SCSW3_AC_DEVAC);
; 5009 :                 dev->scsw.flag3 |= SCSW3_AC_SUSP;

  0108a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0108e	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  01095	83 c8 20	 or	 eax, 32			; 00000020H
  01098	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0109c	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 5010 :                 /* Principles violation. Some operating systems use
; 5011 :                  * CLI to check for suspend, intermediate and pending
; 5012 :                  * status (x'29') instead of the Principles statement
; 5013 :                  * with alert status set (x'39'). This also appears to
; 5014 :                  * be consistent with older machines.
; 5015 :                  * FIXME: Place conformance in user configuration?
; 5016 :                  *        flag3 |= SCSW3_SC_ALERT;
; 5017 :                  */
; 5018 : 
; 5019 :                 dev->scsw.unitstat = 0;

  010a2	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  010a6	c6 80 10 03 00
	00 00		 mov	 BYTE PTR [rax+784], 0

; 5020 : 
; 5021 :                 if (flags & CCW_FLAGS_PCI)

  010ad	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  010b1	83 e0 08	 and	 eax, 8
  010b4	85 c0		 test	 eax, eax
  010b6	74 3d		 je	 SHORT $LN95@s370_execu

; 5022 :                 {
; 5023 :                     dev->scsw.chanstat   = CSW_PCI;

  010b8	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  010bc	c6 80 11 03 00
	00 80		 mov	 BYTE PTR [rax+785], 128	; 00000080H

; 5024 :                     dev->scsw.flag3     |= SCSW3_SC_INTER   |

  010c3	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  010c7	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  010ce	83 c8 09	 or	 eax, 9
  010d1	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  010d5	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 5025 :                                            SCSW3_SC_PEND;
; 5026 :                     dev->pciscsw.flag3  &= ~SCSW3_SC_PEND;

  010db	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  010df	0f b6 80 17 03
	00 00		 movzx	 eax, BYTE PTR [rax+791]
  010e6	83 e0 fe	 and	 eax, -2
  010e9	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  010ed	88 81 17 03 00
	00		 mov	 BYTE PTR [rcx+791], al

; 5027 :                 }

  010f3	eb 35		 jmp	 SHORT $LN96@s370_execu
$LN95@s370_execu:

; 5028 :                 else
; 5029 :                 {
; 5030 :                     dev->scsw.chanstat   = 0;

  010f5	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  010f9	c6 80 11 03 00
	00 00		 mov	 BYTE PTR [rax+785], 0

; 5031 :                     if (!(dev->scsw.flag1 & SCSW1_U))

  01100	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01104	0f b6 80 09 03
	00 00		 movzx	 eax, BYTE PTR [rax+777]
  0110b	83 e0 08	 and	 eax, 8
  0110e	85 c0		 test	 eax, eax
  01110	75 18		 jne	 SHORT $LN97@s370_execu

; 5032 :                         dev->scsw.flag3 |= SCSW3_SC_INTER   |

  01112	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01116	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  0111d	83 c8 09	 or	 eax, 9
  01120	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01124	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al
$LN97@s370_execu:
$LN96@s370_execu:

; 5033 :                                            SCSW3_SC_PEND;
; 5034 :                 }
; 5035 : 
; 5036 :                 STORE_HW(dev->scsw.count,count);

  0112a	0f b7 4d 1c	 movzx	 ecx, WORD PTR count$[rbp]
  0112e	e8 00 00 00 00	 call	 _byteswap_ushort
  01133	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01137	48 81 c1 12 03
	00 00		 add	 rcx, 786		; 00000312H
  0113e	0f b7 d0	 movzx	 edx, ax
  01141	e8 00 00 00 00	 call	 store_hw_noswap

; 5037 : 
; 5038 :                 /* Update local copy of ORB */
; 5039 :                 STORE_FW(dev->orb.ccwaddr, (ccwaddr-8));

  01146	8b 45 18	 mov	 eax, DWORD PTR ccwaddr$[rbp]
  01149	83 e8 08	 sub	 eax, 8
  0114c	8b c8		 mov	 ecx, eax
  0114e	e8 00 00 00 00	 call	 _byteswap_ulong
  01153	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01157	48 81 c1 d4 02
	00 00		 add	 rcx, 724		; 000002d4H
  0115e	8b d0		 mov	 edx, eax
  01160	e8 00 00 00 00	 call	 store_fw_noswap

; 5040 : 
; 5041 :                 /* Preserve CCW execution variables for validation */
; 5042 :                 dev->ccwaddr = ccwaddr;

  01165	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01169	8b 4d 18	 mov	 ecx, DWORD PTR ccwaddr$[rbp]
  0116c	89 88 80 02 00
	00		 mov	 DWORD PTR [rax+640], ecx

; 5043 :                 dev->idapmask = idapmask;

  01172	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01176	0f b7 4d 3c	 movzx	 ecx, WORD PTR idapmask$[rbp]
  0117a	66 89 88 84 02
	00 00		 mov	 WORD PTR [rax+644], cx

; 5044 :                 dev->idawfmt = idawfmt;

  01181	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01185	0f b6 4d 16	 movzx	 ecx, BYTE PTR idawfmt$[rbp]
  01189	88 88 86 02 00
	00		 mov	 BYTE PTR [rax+646], cl

; 5045 :                 dev->ccwfmt = ccwfmt;

  0118f	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01193	0f b6 4d 0c	 movzx	 ecx, BYTE PTR ccwfmt$[rbp]
  01197	88 88 87 02 00
	00		 mov	 BYTE PTR [rax+647], cl

; 5046 :                 dev->ccwkey = ccwkey;

  0119d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  011a1	0f b6 4d 14	 movzx	 ecx, BYTE PTR ccwkey$[rbp]
  011a5	88 88 88 02 00
	00		 mov	 BYTE PTR [rax+648], cl

; 5047 : 
; 5048 :                 /* Turn on the "suspended" bit.  This enables remote
; 5049 :                  * systems to use the device while we're waiting
; 5050 :                  */
; 5051 :                 dev->suspended = 1;

  011ab	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  011af	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  011b5	0f ba e8 15	 bts	 eax, 21
  011b9	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  011bd	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 5052 : 
; 5053 :                 /* Trace suspension point */
; 5054 :                 if (unlikely( CCW_TRACING_ACTIVE( dev, tracethis )))

  011c3	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  011c7	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  011cd	c1 e8 0f	 shr	 eax, 15
  011d0	83 e0 01	 and	 eax, 1
  011d3	85 c0		 test	 eax, eax
  011d5	75 14		 jne	 SHORT $LN234@s370_execu
  011d7	0f b6 45 15	 movzx	 eax, BYTE PTR tracethis$[rbp]
  011db	85 c0		 test	 eax, eax
  011dd	75 0c		 jne	 SHORT $LN234@s370_execu
  011df	c7 85 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv796[rbp], 0
  011e9	eb 0a		 jmp	 SHORT $LN237@s370_execu
$LN234@s370_execu:
  011eb	c7 85 98 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv796[rbp], 1
$LN237@s370_execu:
  011f5	83 bd 98 00 00
	00 00		 cmp	 DWORD PTR tv796[rbp], 0
  011fc	0f 84 d3 00 00
	00		 je	 $LN98@s370_execu

; 5055 :                 {
; 5056 :                     if (dev->ccwtrace && sysblk.traceFILE)

  01202	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01206	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0120c	c1 e8 0f	 shr	 eax, 15
  0120f	83 e0 01	 and	 eax, 1
  01212	85 c0		 test	 eax, eax
  01214	74 20		 je	 SHORT $LN99@s370_execu
  01216	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0121d	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  01225	74 0f		 je	 SHORT $LN99@s370_execu

; 5057 :                         tf_1310( dev );

  01227	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0122b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1310
  01231	e9 9f 00 00 00	 jmp	 $LN100@s370_execu
$LN99@s370_execu:

; 5058 :                     else
; 5059 :                         // "%1d:%04X CHAN: suspended"
; 5060 :                         WRMSG( HHC01310, "I", LCSS_DEVNUM );

  01236	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  0123b	74 10		 je	 SHORT $LN238@s370_execu
  0123d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01241	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01245	89 85 9c 00 00
	00		 mov	 DWORD PTR tv808[rbp], eax
  0124b	eb 0a		 jmp	 SHORT $LN239@s370_execu
$LN238@s370_execu:
  0124d	c7 85 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv808[rbp], 0
$LN239@s370_execu:
  01257	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  0125c	74 12		 je	 SHORT $LN240@s370_execu
  0125e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01262	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01266	d1 f8		 sar	 eax, 1
  01268	89 85 a0 00 00
	00		 mov	 DWORD PTR tv814[rbp], eax
  0126e	eb 0a		 jmp	 SHORT $LN241@s370_execu
$LN240@s370_execu:
  01270	c7 85 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv814[rbp], 0
$LN241@s370_execu:
  0127a	b9 01 00 00 00	 mov	 ecx, 1
  0127f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01285	8b 8d 9c 00 00
	00		 mov	 ecx, DWORD PTR tv808[rbp]
  0128b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0128f	8b 8d a0 00 00
	00		 mov	 ecx, DWORD PTR tv814[rbp]
  01295	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01299	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171641
  012a0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  012a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171642
  012ac	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  012b1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  012b6	41 b9 03 00 00
	00		 mov	 r9d, 3
  012bc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171643
  012c3	ba c4 13 00 00	 mov	 edx, 5060		; 000013c4H
  012c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171644
  012cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN100@s370_execu:
$LN98@s370_execu:

; 5061 :                 }
; 5062 : 
; 5063 :                 /* Present the interrupt and return */
; 5064 :                 if (dev->scsw.flag3 & SCSW3_SC_PEND)

  012d5	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  012d9	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  012e0	83 e0 01	 and	 eax, 1
  012e3	85 c0		 test	 eax, eax
  012e5	74 0b		 je	 SHORT $LN101@s370_execu

; 5065 :                     queue_io_interrupt_and_update_status_locked(dev,FALSE);

  012e7	33 d2		 xor	 edx, edx
  012e9	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  012ed	e8 00 00 00 00	 call	 queue_io_interrupt_and_update_status_locked
$LN101@s370_execu:

; 5066 : 
; 5067 :                 release_lock(&dev->lock);

  012f2	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  012f6	48 83 c0 38	 add	 rax, 56			; 00000038H
  012fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171646
  01301	48 8b c8	 mov	 rcx, rax
  01304	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5068 :                 RELEASE_INTLOCK(NULL);

  0130a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171647
  01311	33 c9		 xor	 ecx, ecx
  01313	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 5069 : 
; 5070 :                 if (dev->scsw.flag2 & (SCSW2_AC_CLEAR | SCSW2_AC_HALT))

  01318	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0131c	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  01323	83 e0 03	 and	 eax, 3
  01326	85 c0		 test	 eax, eax
  01328	74 1c		 je	 SHORT $LN102@s370_execu

; 5071 :                 {
; 5072 :                     if (dev->scsw.flag2 & SCSW2_AC_CLEAR)

  0132a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0132e	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  01335	83 e0 01	 and	 eax, 1
  01338	85 c0		 test	 eax, eax
  0133a	74 05		 je	 SHORT $LN103@s370_execu

; 5073 :                         goto execute_clear;

  0133c	e9 0c f4 ff ff	 jmp	 $execute_clear$295
$LN103@s370_execu:

; 5074 :                     goto execute_halt;

  01341	e9 f1 f4 ff ff	 jmp	 $execute_halt$296
$LN102@s370_execu:

; 5075 :                 }
; 5076 : 
; 5077 :                 return execute_ccw_chain_fast_return( iobuf, &iobuf_initial, NULL );

  01346	45 33 c0	 xor	 r8d, r8d
  01349	48 8d 95 00 20
	00 00		 lea	 rdx, QWORD PTR iobuf_initial$[rbp]
  01350	48 8b 4d 48	 mov	 rcx, QWORD PTR iobuf$[rbp]
  01354	e8 00 00 00 00	 call	 execute_ccw_chain_fast_return
  01359	e9 85 1e 00 00	 jmp	 $LN1@s370_execu
$LN94@s370_execu:

; 5078 :             }
; 5079 : 
; 5080 :             release_lock (&dev->lock);

  0135e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01362	48 83 c0 38	 add	 rax, 56			; 00000038H
  01366	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171650
  0136d	48 8b c8	 mov	 rcx, rax
  01370	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5081 :             RELEASE_INTLOCK(NULL);

  01376	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171651
  0137d	33 c9		 xor	 ecx, ecx
  0137f	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN86@s370_execu:

; 5082 : 
; 5083 :         } /* end if(CCW_FLAGS_SUSP) */
; 5084 : 
; 5085 :         /* Update current CCW opcode, unless data chaining */
; 5086 :         if (!(skip_ccws ||

  01384	83 7d 54 00	 cmp	 DWORD PTR skip_ccws$[rbp], 0
  01388	75 51		 jne	 SHORT $LN104@s370_execu
  0138a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0138e	0f b6 80 78 02
	00 00		 movzx	 eax, BYTE PTR [rax+632]
  01395	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0139a	85 c0		 test	 eax, eax
  0139c	75 3d		 jne	 SHORT $LN104@s370_execu

; 5087 :               (dev->chained & CCW_FLAGS_CD)))
; 5088 :         {
; 5089 :             dev->prevcode = dev->code;

  0139e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  013a2	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  013a6	0f b6 89 7a 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+634]
  013ad	88 88 7b 02 00
	00		 mov	 BYTE PTR [rax+635], cl

; 5090 :             dev->code = opcode;

  013b3	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  013b7	0f b6 4d 0a	 movzx	 ecx, BYTE PTR opcode$[rbp]
  013bb	88 88 7a 02 00
	00		 mov	 BYTE PTR [rax+634], cl

; 5091 : 
; 5092 :             /* Allow the device handler to determine whether this is
; 5093 :                an immediate CCW (i.e. CONTROL with no data transfer) */
; 5094 :             dev->is_immed = IS_CCW_IMMEDIATE(dev, opcode);

  013c1	0f b6 55 0a	 movzx	 edx, BYTE PTR opcode$[rbp]
  013c5	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  013c9	e8 00 00 00 00	 call	 IS_CCW_IMMEDIATE
  013ce	0f b6 c0	 movzx	 eax, al
  013d1	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  013d5	89 81 a0 02 00
	00		 mov	 DWORD PTR [rcx+672], eax
$LN104@s370_execu:

; 5095 : 
; 5096 :             /*-- TBD ------------------------------------------------*/
; 5097 :             /*                                                       */
; 5098 :             /*   Initiation and check of opcode with control unit    */
; 5099 :             /*   belongs here.                                       */
; 5100 :             /*                                                       */
; 5101 :             /*-------------------------------------------------------*/
; 5102 : 
; 5103 :         }
; 5104 : 
; 5105 :         /* If immediate, chain data and address are ignored */
; 5106 :         if (dev->is_immed)

  013db	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  013df	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  013e6	74 2b		 je	 SHORT $LN105@s370_execu

; 5107 :         {
; 5108 :             flags &= ~CCW_FLAGS_CD;

  013e8	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  013ec	0f ba f0 07	 btr	 eax, 7
  013f0	88 45 08	 mov	 BYTE PTR flags$[rbp], al

; 5109 :             dev->chained &= ~CCW_FLAGS_CD;

  013f3	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  013f7	0f b6 80 78 02
	00 00		 movzx	 eax, BYTE PTR [rax+632]
  013fe	0f ba f0 07	 btr	 eax, 7
  01402	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01406	88 81 78 02 00
	00		 mov	 BYTE PTR [rcx+632], al

; 5110 :             addr = 0;

  0140c	c7 45 2c 00 00
	00 00		 mov	 DWORD PTR addr$[rbp], 0
$LN105@s370_execu:

; 5111 :         }
; 5112 : 
; 5113 :         /* Channel program check if CCW refers to invalid storage    */
; 5114 :         /* SA22-7201-05:                                             */
; 5115 :         /*  p. 15-24, Data Address                                   */
; 5116 :         /*  p. 15-25, Count                                          */
; 5117 :         /*  pp. 15-25 -- 15-27, Designation of Storage Area          */
; 5118 :         if ((count &&
; 5119 :              (!(flags & CCW_FLAGS_SKIP)) &&

  01413	83 7d 1c 00	 cmp	 DWORD PTR count$[rbp], 0
  01417	0f 84 a6 00 00
	00		 je	 $LN106@s370_execu
  0141d	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  01421	83 e0 10	 and	 eax, 16
  01424	85 c0		 test	 eax, eax
  01426	0f 85 97 00 00
	00		 jne	 $LN106@s370_execu
  0142c	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  01430	83 e0 04	 and	 eax, 4
  01433	85 c0		 test	 eax, eax
  01435	74 1a		 je	 SHORT $LN108@s370_execu
  01437	8b 45 2c	 mov	 eax, DWORD PTR addr$[rbp]
  0143a	83 e0 03	 and	 eax, 3
  0143d	85 c0		 test	 eax, eax
  0143f	75 6b		 jne	 SHORT $LN107@s370_execu
  01441	8b 45 2c	 mov	 eax, DWORD PTR addr$[rbp]
  01444	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01448	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  0144f	77 5b		 ja	 SHORT $LN107@s370_execu
$LN108@s370_execu:
  01451	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  01455	83 e0 05	 and	 eax, 5
  01458	85 c0		 test	 eax, eax
  0145a	75 67		 jne	 SHORT $LN106@s370_execu
  0145c	0f b6 45 0c	 movzx	 eax, BYTE PTR ccwfmt$[rbp]
  01460	85 c0		 test	 eax, eax
  01462	75 38		 jne	 SHORT $LN110@s370_execu
  01464	8b 45 2c	 mov	 eax, DWORD PTR addr$[rbp]
  01467	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  0146c	85 c0		 test	 eax, eax
  0146e	75 3c		 jne	 SHORT $LN109@s370_execu
  01470	8b 45 2c	 mov	 eax, DWORD PTR addr$[rbp]
  01473	8b 4d 1c	 mov	 ecx, DWORD PTR count$[rbp]
  01476	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  0147a	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  0147f	85 c0		 test	 eax, eax
  01481	75 29		 jne	 SHORT $LN109@s370_execu
  01483	8b 45 2c	 mov	 eax, DWORD PTR addr$[rbp]
  01486	8b 4d 1c	 mov	 ecx, DWORD PTR count$[rbp]
  01489	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  0148d	8b c0		 mov	 eax, eax
  0148f	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01493	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  0149a	77 10		 ja	 SHORT $LN109@s370_execu
$LN110@s370_execu:
  0149c	8b 45 2c	 mov	 eax, DWORD PTR addr$[rbp]
  0149f	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  014a3	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  014aa	76 17		 jbe	 SHORT $LN106@s370_execu
$LN109@s370_execu:
$LN107@s370_execu:

; 5120 :              (((flags & CCW_FLAGS_IDA)   &&
; 5121 :                ((addr & 0x03) ||
; 5122 :                 CHADDRCHK(addr, dev)))                      ||
; 5123 : #if defined(FEATURE_MIDAW_FACILITY)
; 5124 :               ((flags & CCW_FLAGS_MIDAW) &&
; 5125 :                ((addr & 0x0F) ||
; 5126 :                 CHADDRCHK(addr, dev)))                      ||
; 5127 : #endif /*defined(FEATURE_MIDAW_FACILITY)*/
; 5128 :               (!(flags & (CCW_FLAGS_IDA | CCW_FLAGS_MIDAW))     &&
; 5129 :                ((ccwfmt == 0 &&
; 5130 :                  ((addr & ~0x00FFFFFF)                      ||
; 5131 :                   ((addr + (count - 1)) & ~0x00FFFFFF)      ||
; 5132 :                   CHADDRCHK((addr + (count - 1)), dev)))    ||
; 5133 : #if defined(FEATURE_CHANNEL_SUBSYSTEM)
; 5134 :                 (ccwfmt == 1 &&
; 5135 :                  ((addr & ~0x7FFFFFFF)                      ||
; 5136 :                   ((addr + count - 1) & ~0x7FFFFFFF)        ||
; 5137 :                   CHADDRCHK((addr + (count - 1)), dev)))        ||
; 5138 : #endif /*defined(FEATURE_CHANNEL_SUBSYSTEM)*/
; 5139 :                  CHADDRCHK(addr, dev)))))
; 5140 : #if defined(FEATURE_CHANNEL_SUBSYSTEM)
; 5141 :          || (!count &&
; 5142 :              (ccwfmt == 1 && (flags & CCW_FLAGS_CD)))
; 5143 : #endif /*defined(FEATURE_CHANNEL_SUBSYSTEM)*/
; 5144 :             )
; 5145 :         {
; 5146 :             chanstat = CSW_PROGC;

  014ac	c6 45 09 20	 mov	 BYTE PTR chanstat$[rbp], 32 ; 00000020H

; 5147 :             if (prefetch.seq)

  014b0	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  014b7	74 05		 je	 SHORT $LN111@s370_execu

; 5148 :                 goto prefetch;

  014b9	e9 9b 04 00 00	 jmp	 $prefetch$299
$LN111@s370_execu:

; 5149 :             goto breakchain;

  014be	e9 12 0c 00 00	 jmp	 $breakchain$298
$LN106@s370_execu:

; 5150 :         }
; 5151 : 
; 5152 :         /* Suspend and reschedule I/O at this point if SIO and CPU   */
; 5153 :         /* not yet released; if IDA specified, first IDA must be     */
; 5154 :         /* verified before suspend and reschedule.                   */
; 5155 :         if (dev->s370start)

  014c3	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  014c7	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  014cd	d1 e8		 shr	 eax, 1
  014cf	83 e0 01	 and	 eax, 1
  014d2	85 c0		 test	 eax, eax
  014d4	0f 84 c3 01 00
	00		 je	 $LN112@s370_execu

; 5156 :         {
; 5157 :             /* Note: dev->s370start is reset in resume processing;
; 5158 :              *       dev->suspended is NOT set as it is not the intent
; 5159 :              *       to permit another system to update the device.
; 5160 :              */
; 5161 : 
; 5162 :             /* Acquire device lock */
; 5163 :             obtain_lock(&dev->lock);

  014da	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  014de	48 83 c0 38	 add	 rax, 56			; 00000038H
  014e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171661
  014e9	48 8b c8	 mov	 rcx, rax
  014ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 5164 : 
; 5165 :             /* State converting from SIO synchronous to asynchronous */
; 5166 :             if (CCW_TRACING_ACTIVE( dev, tracethis ))

  014f2	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  014f6	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  014fc	c1 e8 0f	 shr	 eax, 15
  014ff	83 e0 01	 and	 eax, 1
  01502	85 c0		 test	 eax, eax
  01504	75 0c		 jne	 SHORT $LN114@s370_execu
  01506	0f b6 45 15	 movzx	 eax, BYTE PTR tracethis$[rbp]
  0150a	85 c0		 test	 eax, eax
  0150c	0f 84 d3 00 00
	00		 je	 $LN113@s370_execu
$LN114@s370_execu:

; 5167 :             {
; 5168 :                 if (dev->ccwtrace && sysblk.traceFILE)

  01512	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01516	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0151c	c1 e8 0f	 shr	 eax, 15
  0151f	83 e0 01	 and	 eax, 1
  01522	85 c0		 test	 eax, eax
  01524	74 20		 je	 SHORT $LN115@s370_execu
  01526	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0152d	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  01535	74 0f		 je	 SHORT $LN115@s370_execu

; 5169 :                     tf_1320( dev );

  01537	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0153b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1320
  01541	e9 9f 00 00 00	 jmp	 $LN116@s370_execu
$LN115@s370_execu:

; 5170 :                 else
; 5171 :                     // "%1d:%04X CHAN: start I/O S/370 conversion to asynchronous operation started"
; 5172 :                     WRMSG( HHC01320, "I", LCSS_DEVNUM );

  01546	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  0154b	74 10		 je	 SHORT $LN242@s370_execu
  0154d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01551	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01555	89 85 a4 00 00
	00		 mov	 DWORD PTR tv963[rbp], eax
  0155b	eb 0a		 jmp	 SHORT $LN243@s370_execu
$LN242@s370_execu:
  0155d	c7 85 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv963[rbp], 0
$LN243@s370_execu:
  01567	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  0156c	74 12		 je	 SHORT $LN244@s370_execu
  0156e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01572	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01576	d1 f8		 sar	 eax, 1
  01578	89 85 a8 00 00
	00		 mov	 DWORD PTR tv969[rbp], eax
  0157e	eb 0a		 jmp	 SHORT $LN245@s370_execu
$LN244@s370_execu:
  01580	c7 85 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv969[rbp], 0
$LN245@s370_execu:
  0158a	b9 01 00 00 00	 mov	 ecx, 1
  0158f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01595	8b 8d a4 00 00
	00		 mov	 ecx, DWORD PTR tv963[rbp]
  0159b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0159f	8b 8d a8 00 00
	00		 mov	 ecx, DWORD PTR tv969[rbp]
  015a5	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  015a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171666
  015b0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  015b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171667
  015bc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  015c1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  015c6	41 b9 03 00 00
	00		 mov	 r9d, 3
  015cc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171668
  015d3	ba 34 14 00 00	 mov	 edx, 5172		; 00001434H
  015d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171669
  015df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN116@s370_execu:
$LN113@s370_execu:

; 5173 :             }
; 5174 : 
; 5175 :             /* Update local copy of ORB */
; 5176 :             STORE_FW(dev->orb.ccwaddr, (ccwaddr-8));

  015e5	8b 45 18	 mov	 eax, DWORD PTR ccwaddr$[rbp]
  015e8	83 e8 08	 sub	 eax, 8
  015eb	8b c8		 mov	 ecx, eax
  015ed	e8 00 00 00 00	 call	 _byteswap_ulong
  015f2	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  015f6	48 81 c1 d4 02
	00 00		 add	 rcx, 724		; 000002d4H
  015fd	8b d0		 mov	 edx, eax
  015ff	e8 00 00 00 00	 call	 store_fw_noswap

; 5177 : 
; 5178 :             /* Preserve CCW execution variables for validation */
; 5179 :             dev->ccwaddr = ccwaddr;

  01604	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01608	8b 4d 18	 mov	 ecx, DWORD PTR ccwaddr$[rbp]
  0160b	89 88 80 02 00
	00		 mov	 DWORD PTR [rax+640], ecx

; 5180 :             dev->idapmask = idapmask;

  01611	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01615	0f b7 4d 3c	 movzx	 ecx, WORD PTR idapmask$[rbp]
  01619	66 89 88 84 02
	00 00		 mov	 WORD PTR [rax+644], cx

; 5181 :             dev->idawfmt = idawfmt;

  01620	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01624	0f b6 4d 16	 movzx	 ecx, BYTE PTR idawfmt$[rbp]
  01628	88 88 86 02 00
	00		 mov	 BYTE PTR [rax+646], cl

; 5182 :             dev->ccwfmt = ccwfmt;

  0162e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01632	0f b6 4d 0c	 movzx	 ecx, BYTE PTR ccwfmt$[rbp]
  01636	88 88 87 02 00
	00		 mov	 BYTE PTR [rax+647], cl

; 5183 :             dev->ccwkey = ccwkey;

  0163c	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01640	0f b6 4d 14	 movzx	 ecx, BYTE PTR ccwkey$[rbp]
  01644	88 88 88 02 00
	00		 mov	 BYTE PTR [rax+648], cl

; 5184 : 
; 5185 :             /* Set the resume pending flag and signal the subchannel;
; 5186 :              * NULL is used for the requeue regs as the execution of
; 5187 :              * the I/O is no longer attached to a specific processor.
; 5188 :              */
; 5189 :             dev->scsw.flag2 |= SCSW2_AC_RESUM;

  0164a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0164e	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  01655	83 c8 08	 or	 eax, 8
  01658	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0165c	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 5190 :             schedule_ioq(NULL, dev);

  01662	48 8b 55 00	 mov	 rdx, QWORD PTR dev$[rbp]
  01666	33 c9		 xor	 ecx, ecx
  01668	e8 00 00 00 00	 call	 schedule_ioq

; 5191 : 
; 5192 :             /* Leave device as busy, unlock device and return */
; 5193 :             release_lock(&dev->lock);

  0166d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01671	48 83 c0 38	 add	 rax, 56			; 00000038H
  01675	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171670
  0167c	48 8b c8	 mov	 rcx, rax
  0167f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5194 :             return execute_ccw_chain_fast_return( iobuf, &iobuf_initial, NULL );

  01685	45 33 c0	 xor	 r8d, r8d
  01688	48 8d 95 00 20
	00 00		 lea	 rdx, QWORD PTR iobuf_initial$[rbp]
  0168f	48 8b 4d 48	 mov	 rcx, QWORD PTR iobuf$[rbp]
  01693	e8 00 00 00 00	 call	 execute_ccw_chain_fast_return
  01698	e9 46 1b 00 00	 jmp	 $LN1@s370_execu
$LN112@s370_execu:

; 5195 :         }
; 5196 : 
; 5197 :         /* Handle initial status settings on first non-immediate CCW */
; 5198 :         /* to the device                                             */
; 5199 :         if (firstccw && !dev->is_immed)

  0169d	0f b6 45 25	 movzx	 eax, BYTE PTR firstccw$[rbp]
  016a1	85 c0		 test	 eax, eax
  016a3	0f 84 bd 01 00
	00		 je	 $LN117@s370_execu
  016a9	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  016ad	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  016b4	0f 85 ac 01 00
	00		 jne	 $LN117@s370_execu

; 5200 :         {
; 5201 :             /* Reset first CCW indication as we're starting the      */
; 5202 :             /* subchannel                                            */
; 5203 :             firstccw = 0;

  016ba	c6 45 25 00	 mov	 BYTE PTR firstccw$[rbp], 0

; 5204 : 
; 5205 :             /* Subchannel and device are now active, set bits in     */
; 5206 :             /* SCSW                                                  */
; 5207 :             /* SA22-7201-05:                                         */
; 5208 :             /*  p. 16-14, Subchannel-Active                          */
; 5209 :             /*  pp. 16-14 -- 16-15, Device-Active                    */
; 5210 :             dev->scsw.flag3 |= (SCSW3_AC_SCHAC | SCSW3_AC_DEVAC);

  016be	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  016c2	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  016c9	0d c0 00 00 00	 or	 eax, 192		; 000000c0H
  016ce	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  016d2	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 5211 : 
; 5212 :             /* Process Initial-Status-Interruption Request           */
; 5213 :             /* SA22-7201-05:                                         */
; 5214 :             /*  p. 16-11, Zero Condition Code                        */
; 5215 :             if (dev->scsw.flag1 & SCSW1_I)

  016d8	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  016dc	0f b6 80 09 03
	00 00		 movzx	 eax, BYTE PTR [rax+777]
  016e3	83 e0 20	 and	 eax, 32			; 00000020H
  016e6	85 c0		 test	 eax, eax
  016e8	0f 84 78 01 00
	00		 je	 $LN118@s370_execu

; 5216 :             {
; 5217 :                 obtain_lock (&dev->lock);

  016ee	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  016f2	48 83 c0 38	 add	 rax, 56			; 00000038H
  016f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171673
  016fd	48 8b c8	 mov	 rcx, rax
  01700	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 5218 : 
; 5219 :                 /* Update the CCW address in the SCSW */
; 5220 :                 STORE_FW(dev->scsw.ccwaddr,ccwaddr);

  01706	8b 4d 18	 mov	 ecx, DWORD PTR ccwaddr$[rbp]
  01709	e8 00 00 00 00	 call	 _byteswap_ulong
  0170e	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01712	48 81 c1 0c 03
	00 00		 add	 rcx, 780		; 0000030cH
  01719	8b d0		 mov	 edx, eax
  0171b	e8 00 00 00 00	 call	 store_fw_noswap

; 5221 : 
; 5222 :                 /* Set the zero condition-code flag in the SCSW */
; 5223 :                 dev->scsw.flag1 |= SCSW1_Z;

  01720	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01724	0f b6 80 09 03
	00 00		 movzx	 eax, BYTE PTR [rax+777]
  0172b	83 c8 04	 or	 eax, 4
  0172e	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01732	88 81 09 03 00
	00		 mov	 BYTE PTR [rcx+777], al

; 5224 : 
; 5225 :                 /* Set intermediate status in the SCSW */
; 5226 :                 dev->scsw.flag3 |= (SCSW3_SC_INTER | SCSW3_SC_PEND);

  01738	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0173c	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  01743	83 c8 09	 or	 eax, 9
  01746	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0174a	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 5227 : 
; 5228 :                 /* Queue the interrupt and update interrupt status */
; 5229 :                 release_lock(&dev->lock);

  01750	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01754	48 83 c0 38	 add	 rax, 56			; 00000038H
  01758	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171674
  0175f	48 8b c8	 mov	 rcx, rax
  01762	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5230 :                 queue_io_interrupt_and_update_status(dev,FALSE);

  01768	33 d2		 xor	 edx, edx
  0176a	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0176e	e8 00 00 00 00	 call	 queue_io_interrupt_and_update_status

; 5231 : 
; 5232 :                 if (CCW_TRACING_ACTIVE( dev, tracethis ))

  01773	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01777	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0177d	c1 e8 0f	 shr	 eax, 15
  01780	83 e0 01	 and	 eax, 1
  01783	85 c0		 test	 eax, eax
  01785	75 0c		 jne	 SHORT $LN120@s370_execu
  01787	0f b6 45 15	 movzx	 eax, BYTE PTR tracethis$[rbp]
  0178b	85 c0		 test	 eax, eax
  0178d	0f 84 d3 00 00
	00		 je	 $LN119@s370_execu
$LN120@s370_execu:

; 5233 :                 {
; 5234 :                     if (dev->ccwtrace && sysblk.traceFILE)

  01793	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01797	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0179d	c1 e8 0f	 shr	 eax, 15
  017a0	83 e0 01	 and	 eax, 1
  017a3	85 c0		 test	 eax, eax
  017a5	74 20		 je	 SHORT $LN121@s370_execu
  017a7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  017ae	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  017b6	74 0f		 je	 SHORT $LN121@s370_execu

; 5235 :                         tf_1306( dev );

  017b8	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  017bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1306
  017c2	e9 9f 00 00 00	 jmp	 $LN122@s370_execu
$LN121@s370_execu:

; 5236 :                     else
; 5237 :                         // "%1d:%04X CHAN: initial status interrupt"
; 5238 :                         WRMSG( HHC01306, "I", LCSS_DEVNUM );

  017c7	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  017cc	74 10		 je	 SHORT $LN246@s370_execu
  017ce	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  017d2	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  017d6	89 85 ac 00 00
	00		 mov	 DWORD PTR tv1057[rbp], eax
  017dc	eb 0a		 jmp	 SHORT $LN247@s370_execu
$LN246@s370_execu:
  017de	c7 85 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1057[rbp], 0
$LN247@s370_execu:
  017e8	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  017ed	74 12		 je	 SHORT $LN248@s370_execu
  017ef	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  017f3	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  017f7	d1 f8		 sar	 eax, 1
  017f9	89 85 b0 00 00
	00		 mov	 DWORD PTR tv1063[rbp], eax
  017ff	eb 0a		 jmp	 SHORT $LN249@s370_execu
$LN248@s370_execu:
  01801	c7 85 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1063[rbp], 0
$LN249@s370_execu:
  0180b	b9 01 00 00 00	 mov	 ecx, 1
  01810	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01816	8b 8d ac 00 00
	00		 mov	 ecx, DWORD PTR tv1057[rbp]
  0181c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01820	8b 8d b0 00 00
	00		 mov	 ecx, DWORD PTR tv1063[rbp]
  01826	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0182a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171679
  01831	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01836	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171680
  0183d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01842	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01847	41 b9 03 00 00
	00		 mov	 r9d, 3
  0184d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171681
  01854	ba 76 14 00 00	 mov	 edx, 5238		; 00001476H
  01859	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171682
  01860	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN122@s370_execu:
$LN119@s370_execu:
$LN118@s370_execu:
$LN117@s370_execu:

; 5239 :                 }
; 5240 :             }
; 5241 :         }
; 5242 : 
; 5243 :         /* For WRITE and non-immediate CONTROL operations,
; 5244 :            copy data from main storage into channel buffer */
; 5245 :         if (!skip_ccws &&

  01866	83 7d 54 00	 cmp	 DWORD PTR skip_ccws$[rbp], 0
  0186a	0f 85 80 03 00
	00		 jne	 $LN123@s370_execu
  01870	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  01877	75 3b		 jne	 SHORT $LN124@s370_execu
  01879	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0187d	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  01884	0f 85 66 03 00
	00		 jne	 $LN123@s370_execu
  0188a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0188e	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  01895	83 e0 03	 and	 eax, 3
  01898	83 f8 01	 cmp	 eax, 1
  0189b	74 17		 je	 SHORT $LN125@s370_execu
  0189d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  018a1	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  018a8	83 e0 03	 and	 eax, 3
  018ab	83 f8 03	 cmp	 eax, 3
  018ae	0f 85 3c 03 00
	00		 jne	 $LN123@s370_execu
$LN125@s370_execu:
$LN124@s370_execu:

; 5246 :             (prefetch.seq ||
; 5247 :              (!dev->is_immed                 &&
; 5248 :               (IS_CCW_WRITE(dev->code)  ||
; 5249 :                IS_CCW_CONTROL(dev->code)))))
; 5250 :         {
; 5251 :             /* Clear prefetch sequence table and I/O buffer if first
; 5252 :                entry */
; 5253 :             if (!prefetch.seq)

  018b4	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  018bb	0f 85 98 00 00
	00		 jne	 $LN126@s370_execu

; 5254 :             {
; 5255 :                 clear_io_buffer(iobuf->data, iobuf->size);

  018c1	48 8b 45 48	 mov	 rax, QWORD PTR iobuf$[rbp]
  018c5	8b 00		 mov	 eax, DWORD PTR [rax]
  018c7	48 8b 4d 48	 mov	 rcx, QWORD PTR iobuf$[rbp]
  018cb	48 81 c1 00 10
	00 00		 add	 rcx, 4096		; 00001000H
  018d2	8b d0		 mov	 edx, eax
  018d4	e8 00 00 00 00	 call	 __clear_io_buffer

; 5256 :                 clear_io_buffer(&prefetch, sizeof(prefetch));

  018d9	ba 10 1a 00 00	 mov	 edx, 6672		; 00001a10H
  018de	48 8d 8d c0 01
	00 00		 lea	 rcx, QWORD PTR prefetch$[rbp]
  018e5	e8 00 00 00 00	 call	 __clear_io_buffer

; 5257 :                 ps = 0;

  018ea	c7 45 10 00 00
	00 00		 mov	 DWORD PTR ps$[rbp], 0

; 5258 :                 prefetch.seq = 1;

  018f1	c7 85 c0 01 00
	00 01 00 00 00	 mov	 DWORD PTR prefetch$[rbp], 1

; 5259 :                 prefetch.prevcode = dev->prevcode;

  018fb	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  018ff	0f b6 80 7b 02
	00 00		 movzx	 eax, BYTE PTR [rax+635]
  01906	88 85 cc 01 00
	00		 mov	 BYTE PTR prefetch$[rbp+12], al

; 5260 :                 prefetch.opcode = dev->code;

  0190c	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01910	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  01917	88 85 cd 01 00
	00		 mov	 BYTE PTR prefetch$[rbp+13], al

; 5261 :                 prefetch.ccwaddr[ps] = ccwaddr;

  0191d	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01920	8b 4d 18	 mov	 ecx, DWORD PTR ccwaddr$[rbp]
  01923	89 8c 85 d0 02
	00 00		 mov	 DWORD PTR prefetch$[rbp+rax*4+272], ecx

; 5262 :                 prefetch.ccwflags[ps] = flags;

  0192a	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  0192d	0f b6 4d 08	 movzx	 ecx, BYTE PTR flags$[rbp]
  01931	88 8c 05 d0 12
	00 00		 mov	 BYTE PTR prefetch$[rbp+rax+4368], cl

; 5263 :                 prefetch.ccwcount[ps] = count;

  01938	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  0193b	0f b7 4d 1c	 movzx	 ecx, WORD PTR count$[rbp]
  0193f	66 89 8c 45 d0
	13 00 00	 mov	 WORD PTR prefetch$[rbp+rax*2+4624], cx

; 5264 :                 prefetch.chanstat[ps] = chanstat;

  01947	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  0194a	0f b6 4d 09	 movzx	 ecx, BYTE PTR chanstat$[rbp]
  0194e	88 8c 05 d0 01
	00 00		 mov	 BYTE PTR prefetch$[rbp+rax+16], cl

; 5265 :                 chanstat = 0;

  01955	c6 45 09 00	 mov	 BYTE PTR chanstat$[rbp], 0
$LN126@s370_execu:
$prefetch$299:

; 5266 :             }
; 5267 : prefetch:
; 5268 :             /* Finish prefetch table entry initialization */
; 5269 :             if (opcode == 0x08 ||

  01959	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  0195d	83 f8 08	 cmp	 eax, 8
  01960	74 14		 je	 SHORT $LN129@s370_execu
  01962	0f b6 45 0c	 movzx	 eax, BYTE PTR ccwfmt$[rbp]
  01966	85 c0		 test	 eax, eax
  01968	75 26		 jne	 SHORT $LN127@s370_execu
  0196a	0f b6 45 0a	 movzx	 eax, BYTE PTR opcode$[rbp]
  0196e	83 e0 0f	 and	 eax, 15
  01971	83 f8 08	 cmp	 eax, 8
  01974	75 1a		 jne	 SHORT $LN127@s370_execu
$LN129@s370_execu:

; 5270 :                 (ccwfmt == 0 && ((opcode & 0x0f) == 0x08)))
; 5271 :             {
; 5272 :                 prefetch.ccwflags[ps] = 0;

  01976	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01979	c6 84 05 d0 12
	00 00 00	 mov	 BYTE PTR prefetch$[rbp+rax+4368], 0

; 5273 :                 prefetch.ccwcount[ps] = 0;

  01981	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01984	33 c9		 xor	 ecx, ecx
  01986	66 89 8c 45 d0
	13 00 00	 mov	 WORD PTR prefetch$[rbp+rax*2+4624], cx

; 5274 :             }

  0198e	eb 24		 jmp	 SHORT $LN128@s370_execu
$LN127@s370_execu:

; 5275 :             else
; 5276 :             {
; 5277 :                 prefetch.ccwflags[ps] = flags & ~(CCW_FLAGS_SKIP |

  01990	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  01994	83 e0 ed	 and	 eax, -19
  01997	8b 4d 10	 mov	 ecx, DWORD PTR ps$[rbp]
  0199a	88 84 0d d0 12
	00 00		 mov	 BYTE PTR prefetch$[rbp+rcx+4368], al

; 5278 :                                                   CCW_FLAGS_SUSP);
; 5279 :                 prefetch.reqcount += count;

  019a1	8b 45 1c	 mov	 eax, DWORD PTR count$[rbp]
  019a4	8b 8d c8 01 00
	00		 mov	 ecx, DWORD PTR prefetch$[rbp+8]
  019aa	03 c8		 add	 ecx, eax
  019ac	8b c1		 mov	 eax, ecx
  019ae	89 85 c8 01 00
	00		 mov	 DWORD PTR prefetch$[rbp+8], eax
$LN128@s370_execu:

; 5280 :             }
; 5281 : 
; 5282 :             /* Copy address to prefetch table */
; 5283 :             prefetch.dataaddr[ps] = addr;

  019b4	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  019b7	8b 4d 2c	 mov	 ecx, DWORD PTR addr$[rbp]
  019ba	48 89 8c c5 d0
	0a 00 00	 mov	 QWORD PTR prefetch$[rbp+rax*8+2320], rcx

; 5284 : 
; 5285 :             /* Ignore additional checks if error */
; 5286 :             if (chanstat)

  019c2	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  019c6	85 c0		 test	 eax, eax
  019c8	74 17		 je	 SHORT $LN130@s370_execu

; 5287 :             {
; 5288 :                 prefetch.chanstat[ps] = chanstat;

  019ca	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  019cd	0f b6 4d 09	 movzx	 ecx, BYTE PTR chanstat$[rbp]
  019d1	88 8c 05 d0 01
	00 00		 mov	 BYTE PTR prefetch$[rbp+rax+16], cl

; 5289 :                 chanstat = 0;

  019d8	c6 45 09 00	 mov	 BYTE PTR chanstat$[rbp], 0

; 5290 :             }

  019dc	e9 33 01 00 00	 jmp	 $LN131@s370_execu
$LN130@s370_execu:

; 5291 : 
; 5292 :             /* Don't copy if immediate and zero count */
; 5293 :             else if (dev->is_immed && !count);

  019e1	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  019e5	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  019ec	74 0b		 je	 SHORT $LN132@s370_execu
  019ee	83 7d 1c 00	 cmp	 DWORD PTR count$[rbp], 0
  019f2	75 05		 jne	 SHORT $LN132@s370_execu
  019f4	e9 1b 01 00 00	 jmp	 $LN133@s370_execu
$LN132@s370_execu:

; 5294 : 
; 5295 :             /* Otherwise, copy data into channel buffer */
; 5296 :             else
; 5297 :             {
; 5298 :                 U32 newsize = bufpos + count;

  019f9	8b 45 1c	 mov	 eax, DWORD PTR count$[rbp]
  019fc	8b 4d 50	 mov	 ecx, DWORD PTR bufpos$[rbp]
  019ff	03 c8		 add	 ecx, eax
  01a01	8b c1		 mov	 eax, ecx
  01a03	89 85 b4 00 00
	00		 mov	 DWORD PTR newsize$8[rbp], eax

; 5299 : 
; 5300 :                 prefetch.datalen[ps] = count;

  01a09	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01a0c	8b 4d 1c	 mov	 ecx, DWORD PTR count$[rbp]
  01a0f	89 8c 85 d0 06
	00 00		 mov	 DWORD PTR prefetch$[rbp+rax*4+1296], ecx

; 5301 : 
; 5302 :                 /* Extend buffer if overflow */
; 5303 :                 if (newsize > iobuf->size)

  01a16	48 8b 45 48	 mov	 rax, QWORD PTR iobuf$[rbp]
  01a1a	8b 00		 mov	 eax, DWORD PTR [rax]
  01a1c	39 85 b4 00 00
	00		 cmp	 DWORD PTR newsize$8[rbp], eax
  01a22	76 38		 jbe	 SHORT $LN134@s370_execu

; 5304 :                 {
; 5305 :                     IOBUF *iobufnew;
; 5306 : 
; 5307 :                     iobufnew = iobuf_reallocate(iobuf, newsize);

  01a24	8b 95 b4 00 00
	00		 mov	 edx, DWORD PTR newsize$8[rbp]
  01a2a	48 8b 4d 48	 mov	 rcx, QWORD PTR iobuf$[rbp]
  01a2e	e8 00 00 00 00	 call	 iobuf_reallocate
  01a33	48 89 85 70 01
	00 00		 mov	 QWORD PTR iobufnew$9[rbp], rax

; 5308 : 
; 5309 :                     /* If new I/O buffer allocation failed, force a
; 5310 :                      * Channel Data Check (CDC). Otherwise, set the
; 5311 :                      * iobuf pointer to the new I/O buffer space.
; 5312 :                      */
; 5313 :                     if (iobufnew == NULL)

  01a3a	48 83 bd 70 01
	00 00 00	 cmp	 QWORD PTR iobufnew$9[rbp], 0
  01a42	75 0d		 jne	 SHORT $LN135@s370_execu

; 5314 :                         prefetch.chanstat[ps] = CSW_CDC;

  01a44	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01a47	c6 84 05 d0 01
	00 00 08	 mov	 BYTE PTR prefetch$[rbp+rax+16], 8
  01a4f	eb 0b		 jmp	 SHORT $LN136@s370_execu
$LN135@s370_execu:

; 5315 :                     else
; 5316 :                         iobuf = iobufnew;

  01a51	48 8b 85 70 01
	00 00		 mov	 rax, QWORD PTR iobufnew$9[rbp]
  01a58	48 89 45 48	 mov	 QWORD PTR iobuf$[rbp], rax
$LN136@s370_execu:
$LN134@s370_execu:

; 5317 :                 }
; 5318 : 
; 5319 :                 /* If no errors, prefetch data to I/O buffer */
; 5320 :                 if (!prefetch.chanstat[ps])

  01a5c	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01a5f	0f b6 84 05 d0
	01 00 00	 movzx	 eax, BYTE PTR prefetch$[rbp+rax+16]
  01a67	85 c0		 test	 eax, eax
  01a69	0f 85 a5 00 00
	00		 jne	 $LN137@s370_execu

; 5321 :                 {
; 5322 :                     ARCH_DEP(copy_iobuf) (dev, ccw, dev->code, flags, addr,

  01a6f	8b 45 50	 mov	 eax, DWORD PTR bufpos$[rbp]
  01a72	48 8b 4d 48	 mov	 rcx, QWORD PTR iobuf$[rbp]
  01a76	48 8d 84 01 00
	10 00 00	 lea	 rax, QWORD PTR [rcx+rax+4096]
  01a7e	48 8d 8d c0 01
	00 00		 lea	 rcx, QWORD PTR prefetch$[rbp]
  01a85	48 89 4c 24 70	 mov	 QWORD PTR [rsp+112], rcx
  01a8a	48 8d 4d 28	 lea	 rcx, QWORD PTR residual$[rbp]
  01a8e	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  01a93	48 8d 4d 09	 lea	 rcx, QWORD PTR chanstat$[rbp]
  01a97	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  01a9c	48 8b 4d 48	 mov	 rcx, QWORD PTR iobuf$[rbp]
  01aa0	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  01aa4	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01aa9	48 8b 4d 48	 mov	 rcx, QWORD PTR iobuf$[rbp]
  01aad	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  01ab1	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01ab6	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  01abb	0f b7 45 3c	 movzx	 eax, WORD PTR idapmask$[rbp]
  01abf	66 89 44 24 40	 mov	 WORD PTR [rsp+64], ax
  01ac4	0f b6 45 16	 movzx	 eax, BYTE PTR idawfmt$[rbp]
  01ac8	88 44 24 38	 mov	 BYTE PTR [rsp+56], al
  01acc	0f b6 45 14	 movzx	 eax, BYTE PTR ccwkey$[rbp]
  01ad0	88 44 24 30	 mov	 BYTE PTR [rsp+48], al
  01ad4	8b 45 1c	 mov	 eax, DWORD PTR count$[rbp]
  01ad7	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  01adb	8b 45 2c	 mov	 eax, DWORD PTR addr$[rbp]
  01ade	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  01ae2	44 0f b6 4d 08	 movzx	 r9d, BYTE PTR flags$[rbp]
  01ae7	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01aeb	44 0f b6 80 7a
	02 00 00	 movzx	 r8d, BYTE PTR [rax+634]
  01af3	48 8b 55 70	 mov	 rdx, QWORD PTR ccw$[rbp]
  01af7	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01afb	e8 00 00 00 00	 call	 s370_copy_iobuf

; 5323 :                                           count, ccwkey,
; 5324 :                                           idawfmt, idapmask,
; 5325 :                                           iobuf->data + bufpos,
; 5326 :                                           iobuf->start, iobuf->end,
; 5327 :                                           &chanstat, &residual, &prefetch);
; 5328 : 
; 5329 :                     /* Update local copy of prefetch sequence entry */
; 5330 :                     ps = prefetch.seq - 1;

  01b00	8b 85 c0 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp]
  01b06	ff c8		 dec	 eax
  01b08	89 45 10	 mov	 DWORD PTR ps$[rbp], eax

; 5331 : 
; 5332 :                     /* Update number of bytes in channel buffer */
; 5333 :                     bufpos = prefetch.pos;

  01b0b	8b 85 c4 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp+4]
  01b11	89 45 50	 mov	 DWORD PTR bufpos$[rbp], eax
$LN137@s370_execu:
$LN133@s370_execu:
$LN131@s370_execu:

; 5334 :                 }
; 5335 :             }
; 5336 : 
; 5337 :             /* If the device handler has requested merging of data
; 5338 :                chained write CCWs, then collect the data from the
; 5339 :                chained-data CCWs in the sequence before passing buffer
; 5340 :                to device handler */
; 5341 : 
; 5342 :             /* Note: This test is commented out as we prefetch the data;
; 5343 :                      chain data, therefore, must always be handled.
; 5344 : 
; 5345 :             if ((dev->orb.flag5 & ORB5_P) ||
; 5346 :                 dev->cdwmerge)                                        */
; 5347 :             {
; 5348 :                 if (dev->code != 0x08 &&
; 5349 :                     !(ccwfmt == 0 && ((dev->code & 0x0F) == 0x08)) &&

  01b14	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01b18	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  01b1f	83 f8 08	 cmp	 eax, 8
  01b22	74 65		 je	 SHORT $LN138@s370_execu
  01b24	0f b6 45 0c	 movzx	 eax, BYTE PTR ccwfmt$[rbp]
  01b28	85 c0		 test	 eax, eax
  01b2a	75 13		 jne	 SHORT $LN139@s370_execu
  01b2c	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01b30	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  01b37	83 e0 0f	 and	 eax, 15
  01b3a	83 f8 08	 cmp	 eax, 8
  01b3d	74 4a		 je	 SHORT $LN138@s370_execu
$LN139@s370_execu:
  01b3f	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  01b43	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01b48	85 c0		 test	 eax, eax
  01b4a	74 3d		 je	 SHORT $LN138@s370_execu

; 5350 :                     flags & CCW_FLAGS_CD)
; 5351 :                 {
; 5352 :                     /* If this is the first CCW in the data chain,
; 5353 :                        then save the chaining flags from the
; 5354 :                        previous CCW */
; 5355 :                     if ((dev->chained & CCW_FLAGS_CD) == 0)

  01b4c	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01b50	0f b6 80 78 02
	00 00		 movzx	 eax, BYTE PTR [rax+632]
  01b57	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01b5c	85 c0		 test	 eax, eax
  01b5e	75 15		 jne	 SHORT $LN140@s370_execu

; 5356 :                         dev->prev_chained = dev->chained;

  01b60	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01b64	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01b68	0f b6 89 78 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+632]
  01b6f	88 88 79 02 00
	00		 mov	 BYTE PTR [rax+633], cl
$LN140@s370_execu:

; 5357 : 
; 5358 :                     /* Process next CCW in data chain */
; 5359 :                     dev->chained = CCW_FLAGS_CD;

  01b75	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01b79	c6 80 78 02 00
	00 80		 mov	 BYTE PTR [rax+632], 128	; 00000080H

; 5360 :                     chain = 1;

  01b80	c6 45 17 01	 mov	 BYTE PTR chain$[rbp], 1

; 5361 :                     continue;

  01b84	e9 67 eb ff ff	 jmp	 $LN291@s370_execu
$LN138@s370_execu:

; 5362 :                 }
; 5363 : 
; 5364 :                 /* If this is the last CCW in the data chain, then
; 5365 :                    restore the chaining flags from the previous
; 5366 :                    CCW */
; 5367 :                 if (dev->chained & CCW_FLAGS_CD)

  01b89	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01b8d	0f b6 80 78 02
	00 00		 movzx	 eax, BYTE PTR [rax+632]
  01b94	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01b99	85 c0		 test	 eax, eax
  01b9b	74 15		 je	 SHORT $LN141@s370_execu

; 5368 :                     dev->chained = dev->prev_chained;

  01b9d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01ba1	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01ba5	0f b6 89 79 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+633]
  01bac	88 88 78 02 00
	00		 mov	 BYTE PTR [rax+632], cl
$LN141@s370_execu:

; 5369 : 
; 5370 :             } /* end if(dev->cdwmerge) */
; 5371 : 
; 5372 :             /* Reset pointers */
; 5373 :             ccwaddr = prefetch.ccwaddr[0];

  01bb2	b8 04 00 00 00	 mov	 eax, 4
  01bb7	48 6b c0 00	 imul	 rax, rax, 0
  01bbb	8b 84 05 d0 02
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax+272]
  01bc2	89 45 18	 mov	 DWORD PTR ccwaddr$[rbp], eax

; 5374 :             dev->prevcode = prefetch.prevcode;

  01bc5	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01bc9	0f b6 8d cc 01
	00 00		 movzx	 ecx, BYTE PTR prefetch$[rbp+12]
  01bd0	88 88 7b 02 00
	00		 mov	 BYTE PTR [rax+635], cl

; 5375 :             dev->code = prefetch.opcode;

  01bd6	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01bda	0f b6 8d cd 01
	00 00		 movzx	 ecx, BYTE PTR prefetch$[rbp+13]
  01be1	88 88 7a 02 00
	00		 mov	 BYTE PTR [rax+634], cl

; 5376 :             count = prefetch.reqcount;

  01be7	8b 85 c8 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp+8]
  01bed	89 45 1c	 mov	 DWORD PTR count$[rbp], eax
$LN123@s370_execu:

; 5377 : 
; 5378 :         }   /* End prefetch */
; 5379 : 
; 5380 :         /* Set chaining flag */
; 5381 :         chain = ( flags & (CCW_FLAGS_CD | CCW_FLAGS_CC) ) ? 1 : 0;

  01bf0	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  01bf4	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  01bf9	85 c0		 test	 eax, eax
  01bfb	74 0c		 je	 SHORT $LN250@s370_execu
  01bfd	c7 85 b8 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv1212[rbp], 1
  01c07	eb 0a		 jmp	 SHORT $LN251@s370_execu
$LN250@s370_execu:
  01c09	c7 85 b8 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1212[rbp], 0
$LN251@s370_execu:
  01c13	0f b6 85 b8 00
	00 00		 movzx	 eax, BYTE PTR tv1212[rbp]
  01c1a	88 45 17	 mov	 BYTE PTR chain$[rbp], al

; 5382 : 
; 5383 :         /* If first in sequence, begin execution and channel data
; 5384 :            transfer */
; 5385 :         if (!skip_ccws)

  01c1d	83 7d 54 00	 cmp	 DWORD PTR skip_ccws$[rbp], 0
  01c21	0f 85 29 04 00
	00		 jne	 $LN142@s370_execu

; 5386 :         {
; 5387 :             /* Initialize residual byte count */
; 5388 :             residual = count;

  01c27	8b 45 1c	 mov	 eax, DWORD PTR count$[rbp]
  01c2a	89 45 28	 mov	 DWORD PTR residual$[rbp], eax

; 5389 :             more = bufpos = unitstat = chanstat = 0;

  01c2d	c6 45 09 00	 mov	 BYTE PTR chanstat$[rbp], 0
  01c31	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  01c35	88 45 0b	 mov	 BYTE PTR unitstat$[rbp], al
  01c38	0f b6 45 0b	 movzx	 eax, BYTE PTR unitstat$[rbp]
  01c3c	89 45 50	 mov	 DWORD PTR bufpos$[rbp], eax
  01c3f	0f b6 45 50	 movzx	 eax, BYTE PTR bufpos$[rbp]
  01c43	88 45 38	 mov	 BYTE PTR more$[rbp], al

; 5390 : 
; 5391 :             /* Pass the CCW to the device handler for execution */
; 5392 :             dev->iobuf.length = iobuf->size;

  01c46	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01c4a	48 8b 4d 48	 mov	 rcx, QWORD PTR iobuf$[rbp]
  01c4e	8b 09		 mov	 ecx, DWORD PTR [rcx]
  01c50	89 88 a8 02 00
	00		 mov	 DWORD PTR [rax+680], ecx

; 5393 :             dev->iobuf.data = iobuf->data;

  01c56	48 8b 45 48	 mov	 rax, QWORD PTR iobuf$[rbp]
  01c5a	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  01c60	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01c64	48 89 81 b0 02
	00 00		 mov	 QWORD PTR [rcx+688], rax

; 5394 :             (dev->hnd->exec) (dev, dev->code, flags, dev->chained,

  01c6b	48 8b 45 48	 mov	 rax, QWORD PTR iobuf$[rbp]
  01c6f	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  01c75	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01c79	48 8b 89 90 02
	00 00		 mov	 rcx, QWORD PTR [rcx+656]
  01c80	48 89 8d 80 01
	00 00		 mov	 QWORD PTR tv2078[rbp], rcx
  01c87	48 8d 55 28	 lea	 rdx, QWORD PTR residual$[rbp]
  01c8b	48 89 54 24 50	 mov	 QWORD PTR [rsp+80], rdx
  01c90	48 8d 55 0b	 lea	 rdx, QWORD PTR unitstat$[rbp]
  01c94	48 89 54 24 48	 mov	 QWORD PTR [rsp+72], rdx
  01c99	48 8d 55 38	 lea	 rdx, QWORD PTR more$[rbp]
  01c9d	48 89 54 24 40	 mov	 QWORD PTR [rsp+64], rdx
  01ca2	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  01ca7	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01cab	8b 80 7c 02 00
	00		 mov	 eax, DWORD PTR [rax+636]
  01cb1	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  01cb5	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01cb9	0f b6 80 7b 02
	00 00		 movzx	 eax, BYTE PTR [rax+635]
  01cc0	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  01cc4	8b 45 1c	 mov	 eax, DWORD PTR count$[rbp]
  01cc7	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  01ccb	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01ccf	44 0f b6 88 78
	02 00 00	 movzx	 r9d, BYTE PTR [rax+632]
  01cd7	44 0f b6 45 08	 movzx	 r8d, BYTE PTR flags$[rbp]
  01cdc	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01ce0	0f b6 90 7a 02
	00 00		 movzx	 edx, BYTE PTR [rax+634]
  01ce7	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01ceb	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR tv2078[rbp]
  01cf2	ff 50 08	 call	 QWORD PTR [rax+8]

; 5395 :                               count, dev->prevcode, dev->ccwseq,
; 5396 :                               iobuf->data,
; 5397 :                               &more, &unitstat, &residual);
; 5398 :             dev->iobuf.length = 0;

  01cf5	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01cf9	c7 80 a8 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+680], 0

; 5399 :             dev->iobuf.data   = 0;

  01d03	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01d07	48 c7 80 b0 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+688], 0

; 5400 : 
; 5401 :             /* Check for Command Retry (suggested by Jim Pierson) */
; 5402 :             if ( --cmdretry && unitstat == ( CSW_CE | CSW_DE | CSW_UC | CSW_SM ) )

  01d12	8b 45 78	 mov	 eax, DWORD PTR cmdretry$[rbp]
  01d15	ff c8		 dec	 eax
  01d17	89 45 78	 mov	 DWORD PTR cmdretry$[rbp], eax
  01d1a	83 7d 78 00	 cmp	 DWORD PTR cmdretry$[rbp], 0
  01d1e	74 41		 je	 SHORT $LN143@s370_execu
  01d20	0f b6 45 0b	 movzx	 eax, BYTE PTR unitstat$[rbp]
  01d24	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  01d27	75 38		 jne	 SHORT $LN143@s370_execu

; 5403 :             {
; 5404 :                 chain    = 1;

  01d29	c6 45 17 01	 mov	 BYTE PTR chain$[rbp], 1

; 5405 :                 if (prefetch.seq)

  01d2d	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  01d34	74 1d		 je	 SHORT $LN144@s370_execu

; 5406 :                 {
; 5407 :                     ccwaddr = prefetch.ccwaddr[0];

  01d36	b8 04 00 00 00	 mov	 eax, 4
  01d3b	48 6b c0 00	 imul	 rax, rax, 0
  01d3f	8b 84 05 d0 02
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax+272]
  01d46	89 45 18	 mov	 DWORD PTR ccwaddr$[rbp], eax

; 5408 :                     prefetch.seq = 0;

  01d49	c7 85 c0 01 00
	00 00 00 00 00	 mov	 DWORD PTR prefetch$[rbp], 0
$LN144@s370_execu:

; 5409 :                 }
; 5410 :                 ccwaddr -= 8;   /* (retry same ccw again) */

  01d53	8b 45 18	 mov	 eax, DWORD PTR ccwaddr$[rbp]
  01d56	83 e8 08	 sub	 eax, 8
  01d59	89 45 18	 mov	 DWORD PTR ccwaddr$[rbp], eax

; 5411 :                 continue;

  01d5c	e9 8f e9 ff ff	 jmp	 $LN292@s370_execu
$LN143@s370_execu:

; 5412 :             }
; 5413 : 
; 5414 :             /* Handle command reject with no data transfer */
; 5415 :             if (residual == count &&
; 5416 :                 (unitstat & CSW_UC) &&

  01d61	8b 45 1c	 mov	 eax, DWORD PTR count$[rbp]
  01d64	39 45 28	 cmp	 DWORD PTR residual$[rbp], eax
  01d67	75 5d		 jne	 SHORT $LN145@s370_execu
  01d69	0f b6 45 0b	 movzx	 eax, BYTE PTR unitstat$[rbp]
  01d6d	83 e0 02	 and	 eax, 2
  01d70	85 c0		 test	 eax, eax
  01d72	74 52		 je	 SHORT $LN145@s370_execu
  01d74	b8 01 00 00 00	 mov	 eax, 1
  01d79	48 6b c0 00	 imul	 rax, rax, 0
  01d7d	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01d81	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  01d89	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01d8e	85 c0		 test	 eax, eax
  01d90	74 34		 je	 SHORT $LN145@s370_execu

; 5417 :                 (dev->sense[0] & SENSE_CR))
; 5418 :             {
; 5419 :                 residual = 0;

  01d92	c7 45 28 00 00
	00 00		 mov	 DWORD PTR residual$[rbp], 0

; 5420 :                 if (prefetch.seq)

  01d99	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  01da0	74 1a		 je	 SHORT $LN147@s370_execu

; 5421 :                 {
; 5422 :                     ps = 0;

  01da2	c7 45 10 00 00
	00 00		 mov	 DWORD PTR ps$[rbp], 0

; 5423 :                     ccwaddr = prefetch.ccwaddr[0];

  01da9	b8 04 00 00 00	 mov	 eax, 4
  01dae	48 6b c0 00	 imul	 rax, rax, 0
  01db2	8b 84 05 d0 02
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax+272]
  01db9	89 45 18	 mov	 DWORD PTR ccwaddr$[rbp], eax
$LN147@s370_execu:

; 5424 :                 }
; 5425 : 
; 5426 :                 goto breakchain;

  01dbc	e9 14 03 00 00	 jmp	 $breakchain$298

; 5427 :             }

  01dc1	e9 8a 02 00 00	 jmp	 $LN146@s370_execu
$LN145@s370_execu:

; 5428 : 
; 5429 :             /* Handle prefetch (write) conditions */
; 5430 :             else if (prefetch.seq)

  01dc6	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  01dcd	0f 84 4d 01 00
	00		 je	 $LN148@s370_execu

; 5431 :             {
; 5432 :                 /* Set prefetch remaining byte count */
; 5433 :                 prefetch_remaining = count - residual;

  01dd3	8b 45 28	 mov	 eax, DWORD PTR residual$[rbp]
  01dd6	8b 4d 1c	 mov	 ecx, DWORD PTR count$[rbp]
  01dd9	2b c8		 sub	 ecx, eax
  01ddb	8b c1		 mov	 eax, ecx
  01ddd	89 45 68	 mov	 DWORD PTR prefetch_remaining$[rbp], eax

; 5434 : 
; 5435 :                 /* Determine prefetched CCW limit and raise requested
; 5436 :                    PCI interrupts */
; 5437 :                 for (ps = ts = 0,

  01de0	c7 45 20 00 00
	00 00		 mov	 DWORD PTR ts$[rbp], 0
  01de7	8b 45 20	 mov	 eax, DWORD PTR ts$[rbp]
  01dea	89 45 10	 mov	 DWORD PTR ps$[rbp], eax
  01ded	c7 45 5c 01 00
	00 00		 mov	 DWORD PTR prevccwaddr$[rbp], 1
  01df4	eb 08		 jmp	 SHORT $LN15@s370_execu
$LN13@s370_execu:

; 5440 :                      ts++)

  01df6	8b 45 20	 mov	 eax, DWORD PTR ts$[rbp]
  01df9	ff c0		 inc	 eax
  01dfb	89 45 20	 mov	 DWORD PTR ts$[rbp], eax
$LN15@s370_execu:

; 5438 :                         prevccwaddr = 1;
; 5439 :                      ts < prefetch.seq;

  01dfe	8b 85 c0 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp]
  01e04	39 45 20	 cmp	 DWORD PTR ts$[rbp], eax
  01e07	0f 83 f3 00 00
	00		 jae	 $LN14@s370_execu

; 5441 :                 {
; 5442 :                     /* Set clean index not affected by loop completion
; 5443 :                        */
; 5444 :                     ps = ts;

  01e0d	8b 45 20	 mov	 eax, DWORD PTR ts$[rbp]
  01e10	89 45 10	 mov	 DWORD PTR ps$[rbp], eax

; 5445 : 
; 5446 :                     /* ccwaddr and flags match each CCW encountered */
; 5447 :                     if (prevccwaddr != prefetch.ccwaddr[ps])

  01e13	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01e16	8b 84 85 d0 02
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax*4+272]
  01e1d	39 45 5c	 cmp	 DWORD PTR prevccwaddr$[rbp], eax
  01e20	74 50		 je	 SHORT $LN150@s370_execu

; 5448 :                     {
; 5449 :                         flags = prefetch.ccwflags[ps];

  01e22	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01e25	0f b6 84 05 d0
	12 00 00	 movzx	 eax, BYTE PTR prefetch$[rbp+rax+4368]
  01e2d	88 45 08	 mov	 BYTE PTR flags$[rbp], al

; 5450 :                         prevccwaddr = prefetch.ccwaddr[ps];

  01e30	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01e33	8b 84 85 d0 02
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax*4+272]
  01e3a	89 45 5c	 mov	 DWORD PTR prevccwaddr$[rbp], eax

; 5451 :                         residual = count = prefetch.ccwcount[ps];

  01e3d	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01e40	0f b7 84 45 d0
	13 00 00	 movzx	 eax, WORD PTR prefetch$[rbp+rax*2+4624]
  01e48	89 45 1c	 mov	 DWORD PTR count$[rbp], eax
  01e4b	8b 45 1c	 mov	 eax, DWORD PTR count$[rbp]
  01e4e	89 45 28	 mov	 DWORD PTR residual$[rbp], eax

; 5452 : 
; 5453 :                         /* Raise PCI interrupt */
; 5454 :                         if (flags & CCW_FLAGS_PCI)

  01e51	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  01e55	83 e0 08	 and	 eax, 8
  01e58	85 c0		 test	 eax, eax
  01e5a	74 16		 je	 SHORT $LN151@s370_execu

; 5455 :                             ARCH_DEP(raise_pci) (dev, ccwkey, ccwfmt,

  01e5c	44 8b 4d 5c	 mov	 r9d, DWORD PTR prevccwaddr$[rbp]
  01e60	44 0f b6 45 0c	 movzx	 r8d, BYTE PTR ccwfmt$[rbp]
  01e65	0f b6 55 14	 movzx	 edx, BYTE PTR ccwkey$[rbp]
  01e69	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  01e6d	e8 00 00 00 00	 call	 s370_raise_pci
$LN151@s370_execu:
$LN150@s370_execu:

; 5456 :                                                  prevccwaddr);
; 5457 :                     }
; 5458 : 
; 5459 :                     /* Adjust counts */
; 5460 :                     if (prefetch.datalen[ps])

  01e72	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01e75	83 bc 85 d0 06
	00 00 00	 cmp	 DWORD PTR prefetch$[rbp+rax*4+1296], 0
  01e7d	74 5a		 je	 SHORT $LN152@s370_execu

; 5461 :                     {
; 5462 :                         if (residual >= prefetch.datalen[ps])

  01e7f	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01e82	8b 84 85 d0 06
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax*4+1296]
  01e89	39 45 28	 cmp	 DWORD PTR residual$[rbp], eax
  01e8c	72 16		 jb	 SHORT $LN153@s370_execu

; 5463 :                             residual -= prefetch.datalen[ps];

  01e8e	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01e91	8b 84 85 d0 06
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax*4+1296]
  01e98	8b 4d 28	 mov	 ecx, DWORD PTR residual$[rbp]
  01e9b	2b c8		 sub	 ecx, eax
  01e9d	8b c1		 mov	 eax, ecx
  01e9f	89 45 28	 mov	 DWORD PTR residual$[rbp], eax
  01ea2	eb 07		 jmp	 SHORT $LN154@s370_execu
$LN153@s370_execu:

; 5464 :                         else
; 5465 :                             residual = 0;

  01ea4	c7 45 28 00 00
	00 00		 mov	 DWORD PTR residual$[rbp], 0
$LN154@s370_execu:

; 5466 : 
; 5467 :                         if (prefetch_remaining >= prefetch.datalen[ps])

  01eab	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01eae	8b 84 85 d0 06
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax*4+1296]
  01eb5	39 45 68	 cmp	 DWORD PTR prefetch_remaining$[rbp], eax
  01eb8	72 16		 jb	 SHORT $LN155@s370_execu

; 5468 :                             prefetch_remaining -= prefetch.datalen[ps];

  01eba	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01ebd	8b 84 85 d0 06
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax*4+1296]
  01ec4	8b 4d 68	 mov	 ecx, DWORD PTR prefetch_remaining$[rbp]
  01ec7	2b c8		 sub	 ecx, eax
  01ec9	8b c1		 mov	 eax, ecx
  01ecb	89 45 68	 mov	 DWORD PTR prefetch_remaining$[rbp], eax
  01ece	eb 09		 jmp	 SHORT $LN156@s370_execu
$LN155@s370_execu:

; 5469 :                         else
; 5470 :                         {
; 5471 :                             prefetch_remaining = 0;

  01ed0	c7 45 68 00 00
	00 00		 mov	 DWORD PTR prefetch_remaining$[rbp], 0

; 5472 :                             break;

  01ed7	eb 27		 jmp	 SHORT $LN14@s370_execu
$LN156@s370_execu:
$LN152@s370_execu:

; 5473 :                         }
; 5474 :                     }
; 5475 : 
; 5476 :                     /* Check for prefetch replay completed */
; 5477 :                     if (prefetch.chanstat[ps] ||

  01ed9	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01edc	0f b6 84 05 d0
	01 00 00	 movzx	 eax, BYTE PTR prefetch$[rbp+rax+16]
  01ee4	85 c0		 test	 eax, eax
  01ee6	75 11		 jne	 SHORT $LN158@s370_execu
  01ee8	83 7d 68 00	 cmp	 DWORD PTR prefetch_remaining$[rbp], 0
  01eec	75 0d		 jne	 SHORT $LN157@s370_execu
  01eee	8b 85 c0 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp]
  01ef4	39 45 10	 cmp	 DWORD PTR ps$[rbp], eax
  01ef7	72 02		 jb	 SHORT $LN157@s370_execu
$LN158@s370_execu:

; 5478 :                         (!prefetch_remaining &&
; 5479 :                          (ps >= prefetch.seq)))
; 5480 :                         break;

  01ef9	eb 05		 jmp	 SHORT $LN14@s370_execu
$LN157@s370_execu:

; 5481 : 
; 5482 :                 }

  01efb	e9 f6 fe ff ff	 jmp	 $LN13@s370_execu
$LN14@s370_execu:

; 5483 : 
; 5484 :                 /* Update SCSW CCW address and channel status */
; 5485 :                 ccwaddr  = prefetch.ccwaddr[ps];

  01f00	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01f03	8b 84 85 d0 02
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax*4+272]
  01f0a	89 45 18	 mov	 DWORD PTR ccwaddr$[rbp], eax

; 5486 :                 chanstat = prefetch.chanstat[ps];

  01f0d	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  01f10	0f b6 84 05 d0
	01 00 00	 movzx	 eax, BYTE PTR prefetch$[rbp+rax+16]
  01f18	88 45 09	 mov	 BYTE PTR chanstat$[rbp], al

; 5487 : 
; 5488 :             } /* End prefetch status update */

  01f1b	e9 30 01 00 00	 jmp	 $LN149@s370_execu
$LN148@s370_execu:

; 5489 : 
; 5490 : 
; 5491 :             /* For READ, SENSE, and READ BACKWARD operations, copy data
; 5492 :                from channel buffer to main storage, unless SKIP is set
; 5493 :             */
; 5494 :             else if (1
; 5495 :                 && !dev->is_immed
; 5496 :                 && !skip_ccws
; 5497 :                 && !(flags & CCW_FLAGS_SKIP)
; 5498 :                 && (0

  01f20	33 c0		 xor	 eax, eax
  01f22	83 f8 01	 cmp	 eax, 1
  01f25	0f 84 25 01 00
	00		 je	 $LN159@s370_execu
  01f2b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01f2f	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  01f36	0f 85 14 01 00
	00		 jne	 $LN159@s370_execu
  01f3c	83 7d 54 00	 cmp	 DWORD PTR skip_ccws$[rbp], 0
  01f40	0f 85 0a 01 00
	00		 jne	 $LN159@s370_execu
  01f46	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  01f4a	83 e0 10	 and	 eax, 16
  01f4d	85 c0		 test	 eax, eax
  01f4f	0f 85 fb 00 00
	00		 jne	 $LN159@s370_execu
  01f55	33 c0		 xor	 eax, eax
  01f57	85 c0		 test	 eax, eax
  01f59	75 3d		 jne	 SHORT $LN160@s370_execu
  01f5b	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01f5f	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  01f66	83 e0 03	 and	 eax, 3
  01f69	83 f8 02	 cmp	 eax, 2
  01f6c	74 2a		 je	 SHORT $LN160@s370_execu
  01f6e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01f72	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  01f79	83 e0 0f	 and	 eax, 15
  01f7c	83 f8 04	 cmp	 eax, 4
  01f7f	74 17		 je	 SHORT $LN160@s370_execu
  01f81	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  01f85	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  01f8c	83 e0 0f	 and	 eax, 15
  01f8f	83 f8 0c	 cmp	 eax, 12
  01f92	0f 85 b8 00 00
	00		 jne	 $LN159@s370_execu
$LN160@s370_execu:

; 5499 :                     || IS_CCW_READ(   dev->code )
; 5500 :                     || IS_CCW_SENSE(  dev->code )
; 5501 :                     || IS_CCW_RDBACK( dev->code )
; 5502 :                    )
; 5503 :             )
; 5504 :             {
; 5505 :                 /* Copy data from I/O buffer to main storage */
; 5506 :                 ARCH_DEP(copy_iobuf) (dev, ccw, dev->code, flags, addr,

  01f98	48 8b 45 48	 mov	 rax, QWORD PTR iobuf$[rbp]
  01f9c	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  01fa2	8b 4d 28	 mov	 ecx, DWORD PTR residual$[rbp]
  01fa5	8b 55 1c	 mov	 edx, DWORD PTR count$[rbp]
  01fa8	2b d1		 sub	 edx, ecx
  01faa	8b ca		 mov	 ecx, edx
  01fac	48 8d 95 c0 01
	00 00		 lea	 rdx, QWORD PTR prefetch$[rbp]
  01fb3	48 89 54 24 70	 mov	 QWORD PTR [rsp+112], rdx
  01fb8	48 8d 55 28	 lea	 rdx, QWORD PTR residual$[rbp]
  01fbc	48 89 54 24 68	 mov	 QWORD PTR [rsp+104], rdx
  01fc1	48 8d 55 09	 lea	 rdx, QWORD PTR chanstat$[rbp]
  01fc5	48 89 54 24 60	 mov	 QWORD PTR [rsp+96], rdx
  01fca	48 8b 55 48	 mov	 rdx, QWORD PTR iobuf$[rbp]
  01fce	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  01fd2	48 89 54 24 58	 mov	 QWORD PTR [rsp+88], rdx
  01fd7	48 8b 55 48	 mov	 rdx, QWORD PTR iobuf$[rbp]
  01fdb	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  01fdf	48 89 54 24 50	 mov	 QWORD PTR [rsp+80], rdx
  01fe4	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  01fe9	0f b7 45 3c	 movzx	 eax, WORD PTR idapmask$[rbp]
  01fed	66 89 44 24 40	 mov	 WORD PTR [rsp+64], ax
  01ff2	0f b6 45 16	 movzx	 eax, BYTE PTR idawfmt$[rbp]
  01ff6	88 44 24 38	 mov	 BYTE PTR [rsp+56], al
  01ffa	0f b6 45 14	 movzx	 eax, BYTE PTR ccwkey$[rbp]
  01ffe	88 44 24 30	 mov	 BYTE PTR [rsp+48], al
  02002	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  02006	8b 45 2c	 mov	 eax, DWORD PTR addr$[rbp]
  02009	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0200d	44 0f b6 4d 08	 movzx	 r9d, BYTE PTR flags$[rbp]
  02012	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02016	44 0f b6 80 7a
	02 00 00	 movzx	 r8d, BYTE PTR [rax+634]
  0201e	48 8b 55 70	 mov	 rdx, QWORD PTR ccw$[rbp]
  02022	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02026	e8 00 00 00 00	 call	 s370_copy_iobuf

; 5507 :                                       count - residual, ccwkey,
; 5508 :                                       idawfmt, idapmask,
; 5509 :                                       iobuf->data,
; 5510 :                                       iobuf->start, iobuf->end,
; 5511 :                                       &chanstat, &residual, &prefetch);
; 5512 : 
; 5513 :                 /* Update number of bytes in channel buffer */
; 5514 :                 bufpos = prefetch.pos;

  0202b	8b 85 c4 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp+4]
  02031	89 45 50	 mov	 DWORD PTR bufpos$[rbp], eax

; 5515 : 
; 5516 :                 /* If error during copy, skip remaining CD CCWs */
; 5517 :                 if (chanstat && (flags & CCW_FLAGS_CD))

  02034	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  02038	85 c0		 test	 eax, eax
  0203a	74 14		 je	 SHORT $LN161@s370_execu
  0203c	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  02040	25 80 00 00 00	 and	 eax, 128		; 00000080H
  02045	85 c0		 test	 eax, eax
  02047	74 07		 je	 SHORT $LN161@s370_execu

; 5518 :                     skip_ccws = 1;

  02049	c7 45 54 01 00
	00 00		 mov	 DWORD PTR skip_ccws$[rbp], 1
$LN161@s370_execu:
$LN159@s370_execu:
$LN149@s370_execu:
$LN146@s370_execu:
$LN142@s370_execu:

; 5519 :             }
; 5520 :         }
; 5521 : 
; 5522 :         /* Check for incorrect length */
; 5523 :         if ((residual || more)
; 5524 :             && !(chanstat & ~(CSW_PCI | CSW_IL)))

  02050	83 7d 28 00	 cmp	 DWORD PTR residual$[rbp], 0
  02054	75 08		 jne	 SHORT $LN163@s370_execu
  02056	0f b6 45 38	 movzx	 eax, BYTE PTR more$[rbp]
  0205a	85 c0		 test	 eax, eax
  0205c	74 77		 je	 SHORT $LN162@s370_execu
$LN163@s370_execu:
  0205e	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  02062	25 3f ff ff ff	 and	 eax, -193		; ffffffffffffff3fH
  02067	85 c0		 test	 eax, eax
  02069	75 6a		 jne	 SHORT $LN162@s370_execu

; 5525 :         {
; 5526 :             /* Set incorrect length status if not suppressed         */
; 5527 :             /* SA22-7201-05:                                         */
; 5528 :             /*  pp. 16-24 -- 16-25, Incorrect Length                 */
; 5529 :             /* GA22-7000-10:                                         */
; 5530 :             /*  p. 13-70, Incorrect Length                           */
; 5531 :             /*
; 5532 : 
; 5533 :             The SLI bit in the CCW ALWAYS suppresses incorrect length,
; 5534 :             regardless of Format-0 or Format-1 and regardless of whether
; 5535 :             the CCW is an immediate operation or not and regardless of
; 5536 :             whether the count field is zero or not (i.e. regardless of
; 5537 :             whether there is a residual or not).
; 5538 : 
; 5539 :             Incorrect length is also NEVER indicated for an immediate
; 5540 :             operation if the count field is zero, REGARDLESS of the
; 5541 :             SLI bit setting. This however only pertains to Format-1
; 5542 :             CCWs as only Format-1 CCWs may contain a length field of
; 5543 :             zero. The length field for a Format-0 CCW must always have
; 5544 :             a non-zero value from 1 to 65,535.
; 5545 : 
; 5546 :             So we only need to check for possible incorrect length
; 5547 :             if we have a residual.
; 5548 : 
; 5549 :             BUT... when:
; 5550 : 
; 5551 :                 a)  the CCW is an IMMEDIATE operation, and
; 5552 :                 b)  SLI bit NOT set (is zero), and
; 5553 :                 c)  the count field (residual) is non-zero,
; 5554 : 
; 5555 :             Then:
; 5556 : 
; 5557 :               Format-0:  Incorrect length is always SUPPRESSED.
; 5558 : 
; 5559 :               Format-1:  Incorrect length is always INDICATED...
; 5560 :                          UNLESS Incorrect-Length-Suppression Mode
; 5561 :                          is requested via the ORB 'L' flag!
; 5562 : 
; 5563 :                          That is to say, without the 'L' flag, Incor-
; 5564 :                          rect Length errors WILL occur for Format-1
; 5565 :                          immediate operations when there's a residual.
; 5566 : 
; 5567 :                          The ORB 'L' flag however, SUPPRESSES Incorrect
; 5568 :                          Length error for Format-1 immediate operations
; 5569 :                          causing them to behave the same as Format-0.
; 5570 :             */
; 5571 :             if (((residual && !(flags & CCW_FLAGS_SLI)) ||
; 5572 :                  ((more || (residual && prefetch.seq)) &&
; 5573 :                   !(flags & (CCW_FLAGS_CD | CCW_FLAGS_SLI))))
; 5574 : 
; 5575 :                 && !(dev->is_immed && (flags & CCW_FLAGS_CC))  /* DSF Debug */
; 5576 : 
; 5577 :                 && (0

  0206b	83 7d 28 00	 cmp	 DWORD PTR residual$[rbp], 0
  0206f	74 0b		 je	 SHORT $LN166@s370_execu
  02071	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  02075	83 e0 20	 and	 eax, 32			; 00000020H
  02078	85 c0		 test	 eax, eax
  0207a	74 24		 je	 SHORT $LN165@s370_execu
$LN166@s370_execu:
  0207c	0f b6 45 38	 movzx	 eax, BYTE PTR more$[rbp]
  02080	85 c0		 test	 eax, eax
  02082	75 0f		 jne	 SHORT $LN167@s370_execu
  02084	83 7d 28 00	 cmp	 DWORD PTR residual$[rbp], 0
  02088	74 4b		 je	 SHORT $LN164@s370_execu
  0208a	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  02091	74 42		 je	 SHORT $LN164@s370_execu
$LN167@s370_execu:
  02093	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  02097	25 a0 00 00 00	 and	 eax, 160		; 000000a0H
  0209c	85 c0		 test	 eax, eax
  0209e	75 35		 jne	 SHORT $LN164@s370_execu
$LN165@s370_execu:
  020a0	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  020a4	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  020ab	74 0b		 je	 SHORT $LN168@s370_execu
  020ad	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  020b1	83 e0 40	 and	 eax, 64			; 00000040H
  020b4	85 c0		 test	 eax, eax
  020b6	75 1d		 jne	 SHORT $LN164@s370_execu
$LN168@s370_execu:
  020b8	33 c0		 xor	 eax, eax
  020ba	85 c0		 test	 eax, eax
  020bc	75 0d		 jne	 SHORT $LN169@s370_execu
  020be	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  020c2	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  020c9	75 0a		 jne	 SHORT $LN164@s370_execu
$LN169@s370_execu:

; 5578 :                     || !dev->is_immed
; 5579 : #if defined( FEATURE_INCORRECT_LENGTH_INDICATION_SUPPRESSION )
; 5580 : 
; 5581 :                     /* Immediate operation. If Format-1 WITHOUT the
; 5582 :                        ORB 'L' flag, then Incorrect Length. Otherwise
; 5583 :                        if Format-0, or Format-1 WITH Incorrect Length
; 5584 :                        Suppresion enabled, then IL is NOT indicated
; 5585 :                        (i.e. is SUPPRESSED).
; 5586 :                     */
; 5587 :                     || (1
; 5588 :                         &&  (dev->orb.flag5 & ORB5_F)
; 5589 :                         && !(dev->orb.flag7 & ORB7_L)
; 5590 :                        )
; 5591 : #endif /* defined( FEATURE_INCORRECT_LENGTH_INDICATION_SUPPRESSION ) */
; 5592 :                    )
; 5593 :             )
; 5594 :                 chanstat |= CSW_IL;

  020cb	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  020cf	83 c8 40	 or	 eax, 64			; 00000040H
  020d2	88 45 09	 mov	 BYTE PTR chanstat$[rbp], al
$LN164@s370_execu:
$LN162@s370_execu:
$breakchain$298:

; 5595 :         }
; 5596 : 
; 5597 : breakchain:
; 5598 : 
; 5599 :         if (unlikely((chanstat & (CSW_PROGC | CSW_PROTC | CSW_CDC |

  020d5	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  020d9	83 e0 3f	 and	 eax, 63			; 0000003fH
  020dc	85 c0		 test	 eax, eax
  020de	75 30		 jne	 SHORT $LN253@s370_execu
  020e0	0f b6 45 0b	 movzx	 eax, BYTE PTR unitstat$[rbp]
  020e4	83 e0 02	 and	 eax, 2
  020e7	85 c0		 test	 eax, eax
  020e9	74 19		 je	 SHORT $LN252@s370_execu
  020eb	b8 01 00 00 00	 mov	 eax, 1
  020f0	48 6b c0 00	 imul	 rax, rax, 0
  020f4	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  020f8	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  02100	85 c0		 test	 eax, eax
  02102	75 0c		 jne	 SHORT $LN253@s370_execu
$LN252@s370_execu:
  02104	c7 85 bc 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1415[rbp], 0
  0210e	eb 0a		 jmp	 SHORT $LN257@s370_execu
$LN253@s370_execu:
  02110	c7 85 bc 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv1415[rbp], 1
$LN257@s370_execu:
  0211a	83 bd bc 00 00
	00 00		 cmp	 DWORD PTR tv1415[rbp], 0
  02121	0f 84 da 02 00
	00		 je	 $LN170@s370_execu

; 5600 :                                   CSW_CCC   | CSW_ICC   | CSW_CHC))
; 5601 :                   || ((unitstat & CSW_UC) && dev->sense[0])))
; 5602 :         {
; 5603 : 
; 5604 :             BYTE  tracing_active  = CCW_TRACING_ACTIVE( dev, tracethis );

  02127	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0212b	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  02131	c1 e8 0f	 shr	 eax, 15
  02134	83 e0 01	 and	 eax, 1
  02137	85 c0		 test	 eax, eax
  02139	75 14		 jne	 SHORT $LN258@s370_execu
  0213b	0f b6 45 15	 movzx	 eax, BYTE PTR tracethis$[rbp]
  0213f	85 c0		 test	 eax, eax
  02141	75 0c		 jne	 SHORT $LN258@s370_execu
  02143	c7 85 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1423[rbp], 0
  0214d	eb 0a		 jmp	 SHORT $LN259@s370_execu
$LN258@s370_execu:
  0214f	c7 85 c0 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv1423[rbp], 1
$LN259@s370_execu:
  02159	0f b6 85 c0 00
	00 00		 movzx	 eax, BYTE PTR tv1423[rbp]
  02160	88 45 58	 mov	 BYTE PTR tracing_active$6[rbp], al

; 5605 :             BYTE  cpu_tracing     = CPU_STEPPING_OR_TRACING_ALL;

  02163	b8 08 00 00 00	 mov	 eax, 8
  02168	48 6b c0 00	 imul	 rax, rax, 0
  0216c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  02173	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  0217c	75 32		 jne	 SHORT $LN260@s370_execu
  0217e	b8 08 00 00 00	 mov	 eax, 8
  02183	48 6b c0 01	 imul	 rax, rax, 1
  02187	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0218e	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  02197	75 17		 jne	 SHORT $LN260@s370_execu
  02199	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  021a0	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  021a6	c1 e8 0a	 shr	 eax, 10
  021a9	83 e0 01	 and	 eax, 1
  021ac	85 c0		 test	 eax, eax
  021ae	75 4e		 jne	 SHORT $LN262@s370_execu
$LN260@s370_execu:
  021b0	b8 08 00 00 00	 mov	 eax, 8
  021b5	48 6b c0 00	 imul	 rax, rax, 0
  021b9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  021c0	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  021c9	75 27		 jne	 SHORT $LN261@s370_execu
  021cb	b8 08 00 00 00	 mov	 eax, 8
  021d0	48 6b c0 01	 imul	 rax, rax, 1
  021d4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  021db	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  021e4	75 0c		 jne	 SHORT $LN261@s370_execu
  021e6	e8 00 00 00 00	 call	 insttrace_all
  021eb	0f b6 c0	 movzx	 eax, al
  021ee	85 c0		 test	 eax, eax
  021f0	75 0c		 jne	 SHORT $LN262@s370_execu
$LN261@s370_execu:
  021f2	c7 85 c4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1448[rbp], 0
  021fc	eb 0a		 jmp	 SHORT $LN263@s370_execu
$LN262@s370_execu:
  021fe	c7 85 c4 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv1448[rbp], 1
$LN263@s370_execu:
  02208	0f b6 85 c4 00
	00 00		 movzx	 eax, BYTE PTR tv1448[rbp]
  0220f	88 45 43	 mov	 BYTE PTR cpu_tracing$5[rbp], al

; 5606 :             BYTE  ostailor_quiet  = (sysblk.pgminttr == 0);

  02212	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  02219	48 83 b8 48 13
	00 00 00	 cmp	 QWORD PTR [rax+4936], 0
  02221	75 0c		 jne	 SHORT $LN264@s370_execu
  02223	c7 85 c8 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv1452[rbp], 1
  0222d	eb 0a		 jmp	 SHORT $LN265@s370_execu
$LN264@s370_execu:
  0222f	c7 85 c8 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1452[rbp], 0
$LN265@s370_execu:
  02239	0f b6 85 c8 00
	00 00		 movzx	 eax, BYTE PTR tv1452[rbp]
  02240	88 45 41	 mov	 BYTE PTR ostailor_quiet$3[rbp], al

; 5607 :             BYTE  ccw_tracing     = dev->ccwtrace;

  02243	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02247	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0224d	c1 e8 0f	 shr	 eax, 15
  02250	83 e0 01	 and	 eax, 1
  02253	88 45 42	 mov	 BYTE PTR ccw_tracing$4[rbp], al

; 5608 :             BYTE  skip_ch9uc      = SKIP_CH9UC( dev, chanstat, unitstat );

  02256	33 c0		 xor	 eax, eax
  02258	83 f8 01	 cmp	 eax, 1
  0225b	0f 84 e3 00 00
	00		 je	 $LN266@s370_execu
  02261	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02265	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0226b	c1 e8 0f	 shr	 eax, 15
  0226e	83 e0 01	 and	 eax, 1
  02271	85 c0		 test	 eax, eax
  02273	0f 85 cb 00 00
	00		 jne	 $LN266@s370_execu
  02279	b8 08 00 00 00	 mov	 eax, 8
  0227e	48 6b c0 00	 imul	 rax, rax, 0
  02282	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  02289	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  02292	75 32		 jne	 SHORT $LN267@s370_execu
  02294	b8 08 00 00 00	 mov	 eax, 8
  02299	48 6b c0 01	 imul	 rax, rax, 1
  0229d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  022a4	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  022ad	75 17		 jne	 SHORT $LN267@s370_execu
  022af	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  022b6	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  022bc	c1 e8 0a	 shr	 eax, 10
  022bf	83 e0 01	 and	 eax, 1
  022c2	85 c0		 test	 eax, eax
  022c4	75 7e		 jne	 SHORT $LN269@s370_execu
$LN267@s370_execu:
  022c6	b8 08 00 00 00	 mov	 eax, 8
  022cb	48 6b c0 00	 imul	 rax, rax, 0
  022cf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  022d6	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  022df	75 27		 jne	 SHORT $LN268@s370_execu
  022e1	b8 08 00 00 00	 mov	 eax, 8
  022e6	48 6b c0 01	 imul	 rax, rax, 1
  022ea	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  022f1	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  022fa	75 0c		 jne	 SHORT $LN268@s370_execu
  022fc	e8 00 00 00 00	 call	 insttrace_all
  02301	0f b6 c0	 movzx	 eax, al
  02304	85 c0		 test	 eax, eax
  02306	75 3c		 jne	 SHORT $LN269@s370_execu
$LN268@s370_execu:
  02308	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0230f	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  02315	c1 e8 19	 shr	 eax, 25
  02318	83 e0 01	 and	 eax, 1
  0231b	85 c0		 test	 eax, eax
  0231d	74 25		 je	 SHORT $LN266@s370_execu
  0231f	44 0f b6 45 0b	 movzx	 r8d, BYTE PTR unitstat$[rbp]
  02324	0f b6 55 09	 movzx	 edx, BYTE PTR chanstat$[rbp]
  02328	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0232c	e8 00 00 00 00	 call	 is_ch9oflow
  02331	0f b6 c0	 movzx	 eax, al
  02334	85 c0		 test	 eax, eax
  02336	74 0c		 je	 SHORT $LN266@s370_execu
  02338	c7 85 cc 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv1496[rbp], 1
  02342	eb 0a		 jmp	 SHORT $LN270@s370_execu
$LN266@s370_execu:
$LN269@s370_execu:
  02344	c7 85 cc 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1496[rbp], 0
$LN270@s370_execu:
  0234e	0f b6 85 cc 00
	00 00		 movzx	 eax, BYTE PTR tv1496[rbp]
  02355	88 45 40	 mov	 BYTE PTR skip_ch9uc$2[rbp], al

; 5609 : 
; 5610 :             /* Trace the CCW if not already done */
; 5611 :             if (1
; 5612 :                 && !tracing_active
; 5613 :                 && (0
; 5614 :                     || cpu_tracing
; 5615 :                     || !ostailor_quiet
; 5616 :                     || ccw_tracing
; 5617 :                    )
; 5618 :                 && !skip_ch9uc

  02358	33 c0		 xor	 eax, eax
  0235a	83 f8 01	 cmp	 eax, 1
  0235d	74 6f		 je	 SHORT $LN172@s370_execu
  0235f	0f b6 45 58	 movzx	 eax, BYTE PTR tracing_active$6[rbp]
  02363	85 c0		 test	 eax, eax
  02365	75 67		 jne	 SHORT $LN172@s370_execu
  02367	33 c0		 xor	 eax, eax
  02369	85 c0		 test	 eax, eax
  0236b	75 18		 jne	 SHORT $LN173@s370_execu
  0236d	0f b6 45 43	 movzx	 eax, BYTE PTR cpu_tracing$5[rbp]
  02371	85 c0		 test	 eax, eax
  02373	75 10		 jne	 SHORT $LN173@s370_execu
  02375	0f b6 45 41	 movzx	 eax, BYTE PTR ostailor_quiet$3[rbp]
  02379	85 c0		 test	 eax, eax
  0237b	74 08		 je	 SHORT $LN173@s370_execu
  0237d	0f b6 45 42	 movzx	 eax, BYTE PTR ccw_tracing$4[rbp]
  02381	85 c0		 test	 eax, eax
  02383	74 49		 je	 SHORT $LN172@s370_execu
$LN173@s370_execu:
  02385	0f b6 45 40	 movzx	 eax, BYTE PTR skip_ch9uc$2[rbp]
  02389	85 c0		 test	 eax, eax
  0238b	75 41		 jne	 SHORT $LN172@s370_execu

; 5619 :             )
; 5620 :             {
; 5621 :                 ioerror = 1;

  0238d	c6 45 24 01	 mov	 BYTE PTR ioerror$[rbp], 1

; 5622 :                 DISPLAY_CCW (dev, ccw, addr, count, flags);

  02391	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171734
  02398	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0239d	c7 44 24 30 f6
	15 00 00	 mov	 DWORD PTR [rsp+48], 5622 ; 000015f6H
  023a5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171735
  023ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  023b1	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  023b5	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  023b9	44 8b 4d 1c	 mov	 r9d, DWORD PTR count$[rbp]
  023bd	44 8b 45 2c	 mov	 r8d, DWORD PTR addr$[rbp]
  023c1	48 8b 55 70	 mov	 rdx, QWORD PTR ccw$[rbp]
  023c5	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  023c9	e8 00 00 00 00	 call	 _display_ccw
$LN172@s370_execu:

; 5623 :             }
; 5624 : 
; 5625 :             /* Activate tracing for this CCW chain only
; 5626 :                if any trace is already active */
; 5627 :             if (0
; 5628 :                 || ccw_tracing
; 5629 :                 || cpu_tracing
; 5630 :                 || (1

  023ce	33 c0		 xor	 eax, eax
  023d0	85 c0		 test	 eax, eax
  023d2	75 27		 jne	 SHORT $LN175@s370_execu
  023d4	0f b6 45 42	 movzx	 eax, BYTE PTR ccw_tracing$4[rbp]
  023d8	85 c0		 test	 eax, eax
  023da	75 1f		 jne	 SHORT $LN175@s370_execu
  023dc	0f b6 45 43	 movzx	 eax, BYTE PTR cpu_tracing$5[rbp]
  023e0	85 c0		 test	 eax, eax
  023e2	75 17		 jne	 SHORT $LN175@s370_execu
  023e4	33 c0		 xor	 eax, eax
  023e6	83 f8 01	 cmp	 eax, 1
  023e9	74 14		 je	 SHORT $LN174@s370_execu
  023eb	0f b6 45 41	 movzx	 eax, BYTE PTR ostailor_quiet$3[rbp]
  023ef	85 c0		 test	 eax, eax
  023f1	75 0c		 jne	 SHORT $LN174@s370_execu
  023f3	0f b6 45 40	 movzx	 eax, BYTE PTR skip_ch9uc$2[rbp]
  023f7	85 c0		 test	 eax, eax
  023f9	75 04		 jne	 SHORT $LN174@s370_execu
$LN175@s370_execu:

; 5631 :                     && !ostailor_quiet
; 5632 :                     && !skip_ch9uc
; 5633 :                    )
; 5634 :             )
; 5635 :             {
; 5636 :                 tracethis = 1;

  023fb	c6 45 15 01	 mov	 BYTE PTR tracethis$[rbp], 1
$LN174@s370_execu:

; 5637 :             }
; 5638 :         }

  023ff	eb 04		 jmp	 SHORT $LN171@s370_execu
$LN170@s370_execu:

; 5639 :         else
; 5640 :             ioerror = 0;

  02401	c6 45 24 00	 mov	 BYTE PTR ioerror$[rbp], 0
$LN171@s370_execu:

; 5641 : 
; 5642 :         /* Trace the results of CCW execution */
; 5643 :         if (unlikely( CCW_TRACING_ACTIVE( dev, tracethis )))

  02405	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02409	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0240f	c1 e8 0f	 shr	 eax, 15
  02412	83 e0 01	 and	 eax, 1
  02415	85 c0		 test	 eax, eax
  02417	75 14		 jne	 SHORT $LN271@s370_execu
  02419	0f b6 45 15	 movzx	 eax, BYTE PTR tracethis$[rbp]
  0241d	85 c0		 test	 eax, eax
  0241f	75 0c		 jne	 SHORT $LN271@s370_execu
  02421	c7 85 d0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1543[rbp], 0
  0242b	eb 0a		 jmp	 SHORT $LN274@s370_execu
$LN271@s370_execu:
  0242d	c7 85 d0 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv1543[rbp], 1
$LN274@s370_execu:
  02437	83 bd d0 00 00
	00 00		 cmp	 DWORD PTR tv1543[rbp], 0
  0243e	0f 84 ba 08 00
	00		 je	 $LN176@s370_execu

; 5644 :         {
; 5645 : #if DEBUG_PREFETCH
; 5646 :             if (!prefetch.seq)
; 5647 :             {
; 5648 :                 char msgbuf[133];
; 5649 :                 MSGBUF( msgbuf, "flags=%2.2X count=%d (%4.4X) "
; 5650 :                                 "residual=%d (%4.4X) "
; 5651 :                                 "more=%d "
; 5652 :                                 "bufpos=%d",
; 5653 :                                 flags,
; 5654 :                                 count, count,
; 5655 :                                 residual, residual,
; 5656 :                                 more, bufpos );
; 5657 :                 WRMSG( HHC01392, "D", msgbuf );
; 5658 :             }
; 5659 : #endif
; 5660 : 
; 5661 :             /* Display prefetch data */
; 5662 :             if (prefetch.seq)

  02444	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  0244b	0f 84 56 01 00
	00		 je	 $LN177@s370_execu

; 5663 :             {
; 5664 :                 /* Display prefetch table */
; 5665 :                 DISPLAY_PREFETCH(&prefetch, ps, count, residual, more);
; 5666 : 
; 5667 :                 /* Loop through prefetch table for CCW/IDAW display */
; 5668 :                 for (ts = 0, prevccwaddr = 1;

  02451	c7 45 20 00 00
	00 00		 mov	 DWORD PTR ts$[rbp], 0
  02458	c7 45 5c 01 00
	00 00		 mov	 DWORD PTR prevccwaddr$[rbp], 1
  0245f	eb 08		 jmp	 SHORT $LN18@s370_execu
$LN16@s370_execu:

; 5670 :                      ts++)

  02461	8b 45 20	 mov	 eax, DWORD PTR ts$[rbp]
  02464	ff c0		 inc	 eax
  02466	89 45 20	 mov	 DWORD PTR ts$[rbp], eax
$LN18@s370_execu:

; 5669 :                      ts < ps && ts < prefetch.seq;

  02469	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  0246c	39 45 20	 cmp	 DWORD PTR ts$[rbp], eax
  0246f	0f 83 02 01 00
	00		 jae	 $LN17@s370_execu
  02475	8b 85 c0 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp]
  0247b	39 45 20	 cmp	 DWORD PTR ts$[rbp], eax
  0247e	0f 83 f3 00 00
	00		 jae	 $LN17@s370_execu

; 5671 :                 {
; 5672 :                     if (prevccwaddr != prefetch.ccwaddr[ts])

  02484	8b 45 20	 mov	 eax, DWORD PTR ts$[rbp]
  02487	8b 84 85 d0 02
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax*4+272]
  0248e	39 45 5c	 cmp	 DWORD PTR prevccwaddr$[rbp], eax
  02491	74 75		 je	 SHORT $LN178@s370_execu

; 5673 :                     {
; 5674 :                         prevccwaddr = prefetch.ccwaddr[ts];

  02493	8b 45 20	 mov	 eax, DWORD PTR ts$[rbp]
  02496	8b 84 85 d0 02
	00 00		 mov	 eax, DWORD PTR prefetch$[rbp+rax*4+272]
  0249d	89 45 5c	 mov	 DWORD PTR prevccwaddr$[rbp], eax

; 5675 :                         if (ts)

  024a0	83 7d 20 00	 cmp	 DWORD PTR ts$[rbp], 0
  024a4	74 62		 je	 SHORT $LN179@s370_execu

; 5676 :                         {
; 5677 :                             /* Display CCW */
; 5678 :                             DISPLAY_CCW (dev,

  024a6	8b 45 20	 mov	 eax, DWORD PTR ts$[rbp]
  024a9	8b 4d 20	 mov	 ecx, DWORD PTR ts$[rbp]
  024ac	8b 55 20	 mov	 edx, DWORD PTR ts$[rbp]
  024af	8b 94 95 d0 02
	00 00		 mov	 edx, DWORD PTR prefetch$[rbp+rdx*4+272]
  024b6	83 ea 08	 sub	 edx, 8
  024b9	8b d2		 mov	 edx, edx
  024bb	48 8b 7d 00	 mov	 rdi, QWORD PTR dev$[rbp]
  024bf	48 03 97 80 00
	00 00		 add	 rdx, QWORD PTR [rdi+128]
  024c6	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:$SG171742
  024cd	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  024d2	c7 44 24 30 33
	16 00 00	 mov	 DWORD PTR [rsp+48], 5683 ; 00001633H
  024da	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:$SG171743
  024e1	48 89 7c 24 28	 mov	 QWORD PTR [rsp+40], rdi
  024e6	0f b6 7d 08	 movzx	 edi, BYTE PTR flags$[rbp]
  024ea	40 88 7c 24 20	 mov	 BYTE PTR [rsp+32], dil
  024ef	44 8b 8c 85 d0
	06 00 00	 mov	 r9d, DWORD PTR prefetch$[rbp+rax*4+1296]
  024f7	44 8b 84 cd d0
	0a 00 00	 mov	 r8d, DWORD PTR prefetch$[rbp+rcx*8+2320]
  024ff	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02503	e8 00 00 00 00	 call	 _display_ccw
$LN179@s370_execu:
$LN178@s370_execu:

; 5679 :                                          dev->mainstor +
; 5680 :                                            (prefetch.ccwaddr[ts] - 8),
; 5681 :                                          prefetch.dataaddr[ts],
; 5682 :                                          prefetch.datalen[ts],
; 5683 :                                          flags);
; 5684 : 
; 5685 :                         }
; 5686 :                     }
; 5687 :                     if (prefetch.idawtype[ts])

  02508	8b 45 20	 mov	 eax, DWORD PTR ts$[rbp]
  0250b	0f b6 84 05 d0
	19 00 00	 movzx	 eax, BYTE PTR prefetch$[rbp+rax+6160]
  02513	85 c0		 test	 eax, eax
  02515	74 5b		 je	 SHORT $LN180@s370_execu

; 5688 :                         DISPLAY_IDAW(dev,

  02517	8b 45 20	 mov	 eax, DWORD PTR ts$[rbp]
  0251a	8b 4d 20	 mov	 ecx, DWORD PTR ts$[rbp]
  0251d	8b 55 20	 mov	 edx, DWORD PTR ts$[rbp]
  02520	8b 7d 20	 mov	 edi, DWORD PTR ts$[rbp]
  02523	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171745
  0252a	4c 89 44 24 38	 mov	 QWORD PTR [rsp+56], r8
  0252f	c7 44 24 30 3c
	16 00 00	 mov	 DWORD PTR [rsp+48], 5692 ; 0000163cH
  02537	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171746
  0253e	4c 89 44 24 28	 mov	 QWORD PTR [rsp+40], r8
  02543	0f b7 84 85 d0
	06 00 00	 movzx	 eax, WORD PTR prefetch$[rbp+rax*4+1296]
  0254b	66 89 44 24 20	 mov	 WORD PTR [rsp+32], ax
  02550	4c 8b 8c cd d0
	0a 00 00	 mov	 r9, QWORD PTR prefetch$[rbp+rcx*8+2320]
  02558	44 0f b6 84 15
	d0 1a 00 00	 movzx	 r8d, BYTE PTR prefetch$[rbp+rdx+6416]
  02561	0f b6 94 3d d0
	19 00 00	 movzx	 edx, BYTE PTR prefetch$[rbp+rdi+6160]
  02569	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0256d	e8 00 00 00 00	 call	 _display_idaw
$LN180@s370_execu:

; 5689 :                                      prefetch.idawtype[ts],
; 5690 :                                      prefetch.idawflag[ts],
; 5691 :                                      prefetch.dataaddr[ts],
; 5692 :                                      prefetch.datalen[ts]);
; 5693 :                 }

  02572	e9 ea fe ff ff	 jmp	 $LN16@s370_execu
$LN17@s370_execu:

; 5694 : 
; 5695 :                 /* Don't display data area on status */
; 5696 :                 area[0] = 0x00;

  02577	b8 01 00 00 00	 mov	 eax, 1
  0257c	48 6b c0 00	 imul	 rax, rax, 0
  02580	48 89 85 78 01
	00 00		 mov	 QWORD PTR $T10[rbp], rax
  02587	48 83 bd 78 01
	00 00 40	 cmp	 QWORD PTR $T10[rbp], 64	; 00000040H
  0258f	73 02		 jae	 SHORT $LN275@s370_execu
  02591	eb 05		 jmp	 SHORT $LN276@s370_execu
$LN275@s370_execu:
  02593	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN276@s370_execu:
  02598	48 8b 85 78 01
	00 00		 mov	 rax, QWORD PTR $T10[rbp]
  0259f	c6 84 05 00 30
	01 00 00	 mov	 BYTE PTR area$[rbp+rax], 0
$LN177@s370_execu:

; 5697 :             }
; 5698 : 
; 5699 :             /* Trace the read type CCW, UNLESS... the IDA/MIDA flag
; 5700 :                is on. When the IDA/MIDA flag is on for read type CCWs,
; 5701 :                the copy_iobuf function traces the CCW before it traces
; 5702 :                the IDA/MIDA.
; 5703 :             */
; 5704 :             if (1
; 5705 :                 && !(flags & CCW_FLAGS_IDA)
; 5706 :                 && !(flags & CCW_FLAGS_MIDAW)

  025a7	33 c0		 xor	 eax, eax
  025a9	83 f8 01	 cmp	 eax, 1
  025ac	74 5b		 je	 SHORT $LN181@s370_execu
  025ae	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  025b2	83 e0 04	 and	 eax, 4
  025b5	85 c0		 test	 eax, eax
  025b7	75 50		 jne	 SHORT $LN181@s370_execu
  025b9	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  025bd	83 e0 01	 and	 eax, 1
  025c0	85 c0		 test	 eax, eax
  025c2	75 45		 jne	 SHORT $LN181@s370_execu

; 5707 :             )
; 5708 :             {
; 5709 :                 /* If we're tracing due to an I/O error, then the CCW
; 5710 :                    has already been traced further above, so we DON'T
; 5711 :                    want to do it here again!
; 5712 :                 */
; 5713 :                 if (!ioerror)

  025c4	0f b6 45 24	 movzx	 eax, BYTE PTR ioerror$[rbp]
  025c8	85 c0		 test	 eax, eax
  025ca	75 3d		 jne	 SHORT $LN182@s370_execu

; 5714 :                     DISPLAY_CCW( dev, ccw, addr, count, flags );

  025cc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171749
  025d3	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  025d8	c7 44 24 30 52
	16 00 00	 mov	 DWORD PTR [rsp+48], 5714 ; 00001652H
  025e0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171750
  025e7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  025ec	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  025f0	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  025f4	44 8b 4d 1c	 mov	 r9d, DWORD PTR count$[rbp]
  025f8	44 8b 45 2c	 mov	 r8d, DWORD PTR addr$[rbp]
  025fc	48 8b 55 70	 mov	 rdx, QWORD PTR ccw$[rbp]
  02600	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02604	e8 00 00 00 00	 call	 _display_ccw
$LN182@s370_execu:
$LN181@s370_execu:

; 5715 :             }
; 5716 : 
; 5717 :             ioerror = 0; // (reset flag)

  02609	c6 45 24 00	 mov	 BYTE PTR ioerror$[rbp], 0

; 5718 : 
; 5719 :             /* Display status and residual byte count */
; 5720 : 
; 5721 :             if (dev->ccwtrace && sysblk.traceFILE)

  0260d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02611	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  02617	c1 e8 0f	 shr	 eax, 15
  0261a	83 e0 01	 and	 eax, 1
  0261d	85 c0		 test	 eax, eax
  0261f	74 62		 je	 SHORT $LN183@s370_execu
  02621	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  02628	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  02630	74 51		 je	 SHORT $LN183@s370_execu

; 5722 :                 tf_1312( dev, unitstat, chanstat, (BYTE) MIN( count, 16 ), residual, iobuf->data );

  02632	83 7d 1c 10	 cmp	 DWORD PTR count$[rbp], 16
  02636	73 0b		 jae	 SHORT $LN277@s370_execu
  02638	8b 45 1c	 mov	 eax, DWORD PTR count$[rbp]
  0263b	89 85 d4 00 00
	00		 mov	 DWORD PTR tv1634[rbp], eax
  02641	eb 0a		 jmp	 SHORT $LN278@s370_execu
$LN277@s370_execu:
  02643	c7 85 d4 00 00
	00 10 00 00 00	 mov	 DWORD PTR tv1634[rbp], 16
$LN278@s370_execu:
  0264d	48 8b 45 48	 mov	 rax, QWORD PTR iobuf$[rbp]
  02651	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  02657	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0265c	8b 45 28	 mov	 eax, DWORD PTR residual$[rbp]
  0265f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  02663	44 0f b6 8d d4
	00 00 00	 movzx	 r9d, BYTE PTR tv1634[rbp]
  0266b	44 0f b6 45 09	 movzx	 r8d, BYTE PTR chanstat$[rbp]
  02670	0f b6 55 0b	 movzx	 edx, BYTE PTR unitstat$[rbp]
  02674	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02678	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1312
  0267e	e9 ce 00 00 00	 jmp	 $LN184@s370_execu
$LN183@s370_execu:

; 5723 :             else
; 5724 :                 // "%1d:%04X CHAN: stat %2.2X%2.2X, count %4.4X"
; 5725 :                 WRMSG( HHC01312, "I", LCSS_DEVNUM,

  02683	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  02688	74 10		 je	 SHORT $LN279@s370_execu
  0268a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0268e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  02692	89 85 d8 00 00
	00		 mov	 DWORD PTR tv1647[rbp], eax
  02698	eb 0a		 jmp	 SHORT $LN280@s370_execu
$LN279@s370_execu:
  0269a	c7 85 d8 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1647[rbp], 0
$LN280@s370_execu:
  026a4	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  026a9	74 12		 je	 SHORT $LN281@s370_execu
  026ab	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  026af	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  026b3	d1 f8		 sar	 eax, 1
  026b5	89 85 dc 00 00
	00		 mov	 DWORD PTR tv1653[rbp], eax
  026bb	eb 0a		 jmp	 SHORT $LN282@s370_execu
$LN281@s370_execu:
  026bd	c7 85 dc 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1653[rbp], 0
$LN282@s370_execu:
  026c7	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  026cb	89 85 60 01 00
	00		 mov	 DWORD PTR tv1640[rbp], eax
  026d1	0f b6 4d 0b	 movzx	 ecx, BYTE PTR unitstat$[rbp]
  026d5	89 8d 64 01 00
	00		 mov	 DWORD PTR tv1642[rbp], ecx
  026db	b9 01 00 00 00	 mov	 ecx, 1
  026e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  026e6	8b 4d 28	 mov	 ecx, DWORD PTR residual$[rbp]
  026e9	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  026ed	8b 8d 60 01 00
	00		 mov	 ecx, DWORD PTR tv1640[rbp]
  026f3	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  026f7	8b 8d 64 01 00
	00		 mov	 ecx, DWORD PTR tv1642[rbp]
  026fd	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  02701	8b 8d d8 00 00
	00		 mov	 ecx, DWORD PTR tv1647[rbp]
  02707	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0270b	8b 8d dc 00 00
	00		 mov	 ecx, DWORD PTR tv1653[rbp]
  02711	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  02715	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171753
  0271c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  02721	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171754
  02728	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0272d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02732	41 b9 03 00 00
	00		 mov	 r9d, 3
  02738	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171755
  0273f	ba 5e 16 00 00	 mov	 edx, 5726		; 0000165eH
  02744	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171756
  0274b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN184@s370_execu:

; 5726 :                     unitstat, chanstat, residual );
; 5727 : 
; 5728 :             /* Display sense bytes if unit check is indicated */
; 5729 :             if (unitstat & CSW_UC)

  02751	0f b6 45 0b	 movzx	 eax, BYTE PTR unitstat$[rbp]
  02755	83 e0 02	 and	 eax, 2
  02758	85 c0		 test	 eax, eax
  0275a	0f 84 9e 05 00
	00		 je	 $LN185@s370_execu

; 5730 :             {
; 5731 :                 if (dev->ccwtrace && sysblk.traceFILE)

  02760	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02764	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0276a	c1 e8 0f	 shr	 eax, 15
  0276d	83 e0 01	 and	 eax, 1
  02770	85 c0		 test	 eax, eax
  02772	74 20		 je	 SHORT $LN186@s370_execu
  02774	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0277b	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  02783	74 0f		 je	 SHORT $LN186@s370_execu

; 5732 :                     tf_1313( dev );

  02785	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02789	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1313
  0278f	e9 6a 05 00 00	 jmp	 $LN187@s370_execu
$LN186@s370_execu:

; 5733 :                 else
; 5734 :                 {
; 5735 :                     register BYTE* sense = dev->sense;

  02794	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02798	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  0279e	48 89 45 30	 mov	 QWORD PTR sense$1[rbp], rax

; 5736 : 
; 5737 :                     // "%1d:%04X CHAN: sense %2.2X%2.2X%2.2X%2.2X ...
; 5738 :                     WRMSG( HHC01313, "I", LCSS_DEVNUM,

  027a2	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  027a7	74 10		 je	 SHORT $LN283@s370_execu
  027a9	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  027ad	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  027b1	89 85 e0 00 00
	00		 mov	 DWORD PTR tv1806[rbp], eax
  027b7	eb 0a		 jmp	 SHORT $LN284@s370_execu
$LN283@s370_execu:
  027b9	c7 85 e0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1806[rbp], 0
$LN284@s370_execu:
  027c3	48 83 7d 00 00	 cmp	 QWORD PTR dev$[rbp], 0
  027c8	74 12		 je	 SHORT $LN285@s370_execu
  027ca	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  027ce	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  027d2	d1 f8		 sar	 eax, 1
  027d4	89 85 e4 00 00
	00		 mov	 DWORD PTR tv1812[rbp], eax
  027da	eb 0a		 jmp	 SHORT $LN286@s370_execu
$LN285@s370_execu:
  027dc	c7 85 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv1812[rbp], 0
$LN286@s370_execu:
  027e6	b8 01 00 00 00	 mov	 eax, 1
  027eb	48 6b c0 1f	 imul	 rax, rax, 31
  027ef	48 8b 4d 30	 mov	 rcx, QWORD PTR sense$1[rbp]
  027f3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  027f7	89 85 68 01 00
	00		 mov	 DWORD PTR tv1677[rbp], eax
  027fd	b9 01 00 00 00	 mov	 ecx, 1
  02802	48 6b c9 1e	 imul	 rcx, rcx, 30
  02806	48 8b 55 30	 mov	 rdx, QWORD PTR sense$1[rbp]
  0280a	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0280e	89 8d 6c 01 00
	00		 mov	 DWORD PTR tv1681[rbp], ecx
  02814	ba 01 00 00 00	 mov	 edx, 1
  02819	48 6b d2 1d	 imul	 rdx, rdx, 29
  0281d	48 8b 7d 30	 mov	 rdi, QWORD PTR sense$1[rbp]
  02821	0f b6 14 17	 movzx	 edx, BYTE PTR [rdi+rdx]
  02825	89 95 00 01 00
	00		 mov	 DWORD PTR tv1685[rbp], edx
  0282b	bf 01 00 00 00	 mov	 edi, 1
  02830	48 6b ff 1c	 imul	 rdi, rdi, 28
  02834	4c 8b 45 30	 mov	 r8, QWORD PTR sense$1[rbp]
  02838	41 0f b6 3c 38	 movzx	 edi, BYTE PTR [r8+rdi]
  0283d	41 b8 01 00 00
	00		 mov	 r8d, 1
  02843	4d 6b c0 1b	 imul	 r8, r8, 27
  02847	4c 8b 4d 30	 mov	 r9, QWORD PTR sense$1[rbp]
  0284b	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  02850	44 89 85 04 01
	00 00		 mov	 DWORD PTR tv1693[rbp], r8d
  02857	41 b9 01 00 00
	00		 mov	 r9d, 1
  0285d	4d 6b c9 1a	 imul	 r9, r9, 26
  02861	4c 8b 55 30	 mov	 r10, QWORD PTR sense$1[rbp]
  02865	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  0286a	44 89 8d 08 01
	00 00		 mov	 DWORD PTR tv1697[rbp], r9d
  02871	41 ba 01 00 00
	00		 mov	 r10d, 1
  02877	4d 6b d2 19	 imul	 r10, r10, 25
  0287b	4c 8b 5d 30	 mov	 r11, QWORD PTR sense$1[rbp]
  0287f	47 0f b6 14 13	 movzx	 r10d, BYTE PTR [r11+r10]
  02884	44 89 95 0c 01
	00 00		 mov	 DWORD PTR tv1701[rbp], r10d
  0288b	41 bb 01 00 00
	00		 mov	 r11d, 1
  02891	4d 6b db 18	 imul	 r11, r11, 24
  02895	48 8b 5d 30	 mov	 rbx, QWORD PTR sense$1[rbp]
  02899	42 0f b6 1c 1b	 movzx	 ebx, BYTE PTR [rbx+r11]
  0289e	41 bb 01 00 00
	00		 mov	 r11d, 1
  028a4	4d 6b db 17	 imul	 r11, r11, 23
  028a8	48 8b 75 30	 mov	 rsi, QWORD PTR sense$1[rbp]
  028ac	42 0f b6 34 1e	 movzx	 esi, BYTE PTR [rsi+r11]
  028b1	41 bb 01 00 00
	00		 mov	 r11d, 1
  028b7	4d 6b db 16	 imul	 r11, r11, 22
  028bb	4c 8b 75 30	 mov	 r14, QWORD PTR sense$1[rbp]
  028bf	47 0f b6 1c 1e	 movzx	 r11d, BYTE PTR [r14+r11]
  028c4	44 89 9d 10 01
	00 00		 mov	 DWORD PTR tv1713[rbp], r11d
  028cb	41 be 01 00 00
	00		 mov	 r14d, 1
  028d1	4d 6b f6 15	 imul	 r14, r14, 21
  028d5	4c 8b 7d 30	 mov	 r15, QWORD PTR sense$1[rbp]
  028d9	47 0f b6 34 37	 movzx	 r14d, BYTE PTR [r15+r14]
  028de	41 bf 01 00 00
	00		 mov	 r15d, 1
  028e4	4d 6b ff 14	 imul	 r15, r15, 20
  028e8	4c 8b 65 30	 mov	 r12, QWORD PTR sense$1[rbp]
  028ec	47 0f b6 3c 3c	 movzx	 r15d, BYTE PTR [r12+r15]
  028f1	41 bc 01 00 00
	00		 mov	 r12d, 1
  028f7	4d 6b e4 13	 imul	 r12, r12, 19
  028fb	4c 8b 6d 30	 mov	 r13, QWORD PTR sense$1[rbp]
  028ff	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02904	44 89 a5 14 01
	00 00		 mov	 DWORD PTR tv1725[rbp], r12d
  0290b	41 bd 01 00 00
	00		 mov	 r13d, 1
  02911	4d 6b ed 12	 imul	 r13, r13, 18
  02915	4c 8b 65 30	 mov	 r12, QWORD PTR sense$1[rbp]
  02919	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  0291e	44 89 a5 18 01
	00 00		 mov	 DWORD PTR tv1729[rbp], r12d
  02925	41 bd 01 00 00
	00		 mov	 r13d, 1
  0292b	4d 6b ed 11	 imul	 r13, r13, 17
  0292f	4c 8b 65 30	 mov	 r12, QWORD PTR sense$1[rbp]
  02933	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02938	44 89 a5 1c 01
	00 00		 mov	 DWORD PTR tv1733[rbp], r12d
  0293f	41 bd 01 00 00
	00		 mov	 r13d, 1
  02945	4d 6b ed 10	 imul	 r13, r13, 16
  02949	4c 8b 65 30	 mov	 r12, QWORD PTR sense$1[rbp]
  0294d	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02952	44 89 a5 20 01
	00 00		 mov	 DWORD PTR tv1737[rbp], r12d
  02959	41 bd 01 00 00
	00		 mov	 r13d, 1
  0295f	4d 6b ed 0f	 imul	 r13, r13, 15
  02963	4c 8b 65 30	 mov	 r12, QWORD PTR sense$1[rbp]
  02967	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  0296c	44 89 a5 24 01
	00 00		 mov	 DWORD PTR tv1741[rbp], r12d
  02973	41 bd 01 00 00
	00		 mov	 r13d, 1
  02979	4d 6b ed 0e	 imul	 r13, r13, 14
  0297d	4c 8b 65 30	 mov	 r12, QWORD PTR sense$1[rbp]
  02981	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02986	44 89 a5 28 01
	00 00		 mov	 DWORD PTR tv1745[rbp], r12d
  0298d	41 bd 01 00 00
	00		 mov	 r13d, 1
  02993	4d 6b ed 0d	 imul	 r13, r13, 13
  02997	4c 8b 65 30	 mov	 r12, QWORD PTR sense$1[rbp]
  0299b	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  029a0	44 89 a5 2c 01
	00 00		 mov	 DWORD PTR tv1749[rbp], r12d
  029a7	41 bd 01 00 00
	00		 mov	 r13d, 1
  029ad	4d 6b ed 0c	 imul	 r13, r13, 12
  029b1	4c 8b 65 30	 mov	 r12, QWORD PTR sense$1[rbp]
  029b5	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  029ba	44 89 a5 30 01
	00 00		 mov	 DWORD PTR tv1753[rbp], r12d
  029c1	41 bd 01 00 00
	00		 mov	 r13d, 1
  029c7	4d 6b ed 0b	 imul	 r13, r13, 11
  029cb	4c 8b 65 30	 mov	 r12, QWORD PTR sense$1[rbp]
  029cf	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  029d4	44 89 a5 34 01
	00 00		 mov	 DWORD PTR tv1757[rbp], r12d
  029db	41 bd 01 00 00
	00		 mov	 r13d, 1
  029e1	4d 6b ed 0a	 imul	 r13, r13, 10
  029e5	4c 8b 65 30	 mov	 r12, QWORD PTR sense$1[rbp]
  029e9	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  029ee	44 89 a5 38 01
	00 00		 mov	 DWORD PTR tv1761[rbp], r12d
  029f5	41 bd 01 00 00
	00		 mov	 r13d, 1
  029fb	4d 6b ed 09	 imul	 r13, r13, 9
  029ff	4c 8b 65 30	 mov	 r12, QWORD PTR sense$1[rbp]
  02a03	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02a08	44 89 a5 3c 01
	00 00		 mov	 DWORD PTR tv1765[rbp], r12d
  02a0f	41 bd 01 00 00
	00		 mov	 r13d, 1
  02a15	4d 6b ed 08	 imul	 r13, r13, 8
  02a19	4c 8b 65 30	 mov	 r12, QWORD PTR sense$1[rbp]
  02a1d	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02a22	44 89 a5 40 01
	00 00		 mov	 DWORD PTR tv1769[rbp], r12d
  02a29	41 bd 01 00 00
	00		 mov	 r13d, 1
  02a2f	4d 6b ed 07	 imul	 r13, r13, 7
  02a33	4c 8b 65 30	 mov	 r12, QWORD PTR sense$1[rbp]
  02a37	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02a3c	44 89 a5 44 01
	00 00		 mov	 DWORD PTR tv1773[rbp], r12d
  02a43	41 bd 01 00 00
	00		 mov	 r13d, 1
  02a49	4d 6b ed 06	 imul	 r13, r13, 6
  02a4d	4c 8b 65 30	 mov	 r12, QWORD PTR sense$1[rbp]
  02a51	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02a56	44 89 a5 48 01
	00 00		 mov	 DWORD PTR tv1777[rbp], r12d
  02a5d	41 bd 01 00 00
	00		 mov	 r13d, 1
  02a63	4d 6b ed 05	 imul	 r13, r13, 5
  02a67	4c 8b 65 30	 mov	 r12, QWORD PTR sense$1[rbp]
  02a6b	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02a70	44 89 a5 4c 01
	00 00		 mov	 DWORD PTR tv1781[rbp], r12d
  02a77	41 bd 01 00 00
	00		 mov	 r13d, 1
  02a7d	4d 6b ed 04	 imul	 r13, r13, 4
  02a81	4c 8b 65 30	 mov	 r12, QWORD PTR sense$1[rbp]
  02a85	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02a8a	44 89 a5 50 01
	00 00		 mov	 DWORD PTR tv1785[rbp], r12d
  02a91	41 bd 01 00 00
	00		 mov	 r13d, 1
  02a97	4d 6b ed 03	 imul	 r13, r13, 3
  02a9b	4c 8b 65 30	 mov	 r12, QWORD PTR sense$1[rbp]
  02a9f	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02aa4	44 89 a5 54 01
	00 00		 mov	 DWORD PTR tv1789[rbp], r12d
  02aab	41 bd 01 00 00
	00		 mov	 r13d, 1
  02ab1	4d 6b ed 02	 imul	 r13, r13, 2
  02ab5	4c 8b 65 30	 mov	 r12, QWORD PTR sense$1[rbp]
  02ab9	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02abe	44 89 a5 58 01
	00 00		 mov	 DWORD PTR tv1793[rbp], r12d
  02ac5	41 bd 01 00 00
	00		 mov	 r13d, 1
  02acb	4d 6b ed 01	 imul	 r13, r13, 1
  02acf	4c 8b 65 30	 mov	 r12, QWORD PTR sense$1[rbp]
  02ad3	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02ad8	44 89 a5 5c 01
	00 00		 mov	 DWORD PTR tv1797[rbp], r12d
  02adf	41 bd 01 00 00
	00		 mov	 r13d, 1
  02ae5	4d 6b ed 00	 imul	 r13, r13, 0
  02ae9	4c 8b 65 30	 mov	 r12, QWORD PTR sense$1[rbp]
  02aed	47 0f b6 24 2c	 movzx	 r12d, BYTE PTR [r12+r13]
  02af2	b9 01 00 00 00	 mov	 ecx, 1
  02af7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02afd	8b 8d 68 01 00
	00		 mov	 ecx, DWORD PTR tv1677[rbp]
  02b03	89 8c 24 40 01
	00 00		 mov	 DWORD PTR [rsp+320], ecx
  02b0a	8b 8d 6c 01 00
	00		 mov	 ecx, DWORD PTR tv1681[rbp]
  02b10	89 8c 24 38 01
	00 00		 mov	 DWORD PTR [rsp+312], ecx
  02b17	8b 8d 00 01 00
	00		 mov	 ecx, DWORD PTR tv1685[rbp]
  02b1d	89 8c 24 30 01
	00 00		 mov	 DWORD PTR [rsp+304], ecx
  02b24	89 bc 24 28 01
	00 00		 mov	 DWORD PTR [rsp+296], edi
  02b2b	8b 8d 04 01 00
	00		 mov	 ecx, DWORD PTR tv1693[rbp]
  02b31	89 8c 24 20 01
	00 00		 mov	 DWORD PTR [rsp+288], ecx
  02b38	8b 8d 08 01 00
	00		 mov	 ecx, DWORD PTR tv1697[rbp]
  02b3e	89 8c 24 18 01
	00 00		 mov	 DWORD PTR [rsp+280], ecx
  02b45	8b 8d 0c 01 00
	00		 mov	 ecx, DWORD PTR tv1701[rbp]
  02b4b	89 8c 24 10 01
	00 00		 mov	 DWORD PTR [rsp+272], ecx
  02b52	89 9c 24 08 01
	00 00		 mov	 DWORD PTR [rsp+264], ebx
  02b59	89 b4 24 00 01
	00 00		 mov	 DWORD PTR [rsp+256], esi
  02b60	8b 8d 10 01 00
	00		 mov	 ecx, DWORD PTR tv1713[rbp]
  02b66	89 8c 24 f8 00
	00 00		 mov	 DWORD PTR [rsp+248], ecx
  02b6d	44 89 b4 24 f0
	00 00 00	 mov	 DWORD PTR [rsp+240], r14d
  02b75	44 89 bc 24 e8
	00 00 00	 mov	 DWORD PTR [rsp+232], r15d
  02b7d	8b 8d 14 01 00
	00		 mov	 ecx, DWORD PTR tv1725[rbp]
  02b83	89 8c 24 e0 00
	00 00		 mov	 DWORD PTR [rsp+224], ecx
  02b8a	8b 8d 18 01 00
	00		 mov	 ecx, DWORD PTR tv1729[rbp]
  02b90	89 8c 24 d8 00
	00 00		 mov	 DWORD PTR [rsp+216], ecx
  02b97	8b 8d 1c 01 00
	00		 mov	 ecx, DWORD PTR tv1733[rbp]
  02b9d	89 8c 24 d0 00
	00 00		 mov	 DWORD PTR [rsp+208], ecx
  02ba4	8b 8d 20 01 00
	00		 mov	 ecx, DWORD PTR tv1737[rbp]
  02baa	89 8c 24 c8 00
	00 00		 mov	 DWORD PTR [rsp+200], ecx
  02bb1	8b 8d 24 01 00
	00		 mov	 ecx, DWORD PTR tv1741[rbp]
  02bb7	89 8c 24 c0 00
	00 00		 mov	 DWORD PTR [rsp+192], ecx
  02bbe	8b 8d 28 01 00
	00		 mov	 ecx, DWORD PTR tv1745[rbp]
  02bc4	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR [rsp+184], ecx
  02bcb	8b 8d 2c 01 00
	00		 mov	 ecx, DWORD PTR tv1749[rbp]
  02bd1	89 8c 24 b0 00
	00 00		 mov	 DWORD PTR [rsp+176], ecx
  02bd8	8b 8d 30 01 00
	00		 mov	 ecx, DWORD PTR tv1753[rbp]
  02bde	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR [rsp+168], ecx
  02be5	8b 8d 34 01 00
	00		 mov	 ecx, DWORD PTR tv1757[rbp]
  02beb	89 8c 24 a0 00
	00 00		 mov	 DWORD PTR [rsp+160], ecx
  02bf2	8b 8d 38 01 00
	00		 mov	 ecx, DWORD PTR tv1761[rbp]
  02bf8	89 8c 24 98 00
	00 00		 mov	 DWORD PTR [rsp+152], ecx
  02bff	8b 8d 3c 01 00
	00		 mov	 ecx, DWORD PTR tv1765[rbp]
  02c05	89 8c 24 90 00
	00 00		 mov	 DWORD PTR [rsp+144], ecx
  02c0c	8b 8d 40 01 00
	00		 mov	 ecx, DWORD PTR tv1769[rbp]
  02c12	89 8c 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], ecx
  02c19	8b 8d 44 01 00
	00		 mov	 ecx, DWORD PTR tv1773[rbp]
  02c1f	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  02c26	8b 8d 48 01 00
	00		 mov	 ecx, DWORD PTR tv1777[rbp]
  02c2c	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  02c30	8b 8d 4c 01 00
	00		 mov	 ecx, DWORD PTR tv1781[rbp]
  02c36	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  02c3a	8b 8d 50 01 00
	00		 mov	 ecx, DWORD PTR tv1785[rbp]
  02c40	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  02c44	8b 8d 54 01 00
	00		 mov	 ecx, DWORD PTR tv1789[rbp]
  02c4a	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  02c4e	8b 8d 58 01 00
	00		 mov	 ecx, DWORD PTR tv1793[rbp]
  02c54	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  02c58	8b 8d 5c 01 00
	00		 mov	 ecx, DWORD PTR tv1797[rbp]
  02c5e	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  02c62	44 89 64 24 48	 mov	 DWORD PTR [rsp+72], r12d
  02c67	8b 8d e0 00 00
	00		 mov	 ecx, DWORD PTR tv1806[rbp]
  02c6d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  02c71	8b 8d e4 00 00
	00		 mov	 ecx, DWORD PTR tv1812[rbp]
  02c77	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  02c7b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171760
  02c82	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  02c87	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171761
  02c8e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02c93	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02c98	41 b9 03 00 00
	00		 mov	 r9d, 3
  02c9e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171762
  02ca5	ba 72 16 00 00	 mov	 edx, 5746		; 00001672H
  02caa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171763
  02cb1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 5739 :                             sense[ 0], sense[ 1], sense[ 2], sense[ 3],
; 5740 :                             sense[ 4], sense[ 5], sense[ 6], sense[ 7],
; 5741 :                             sense[ 8], sense[ 9], sense[10], sense[11],
; 5742 :                             sense[12], sense[13], sense[14], sense[15],
; 5743 :                             sense[16], sense[17], sense[18], sense[19],
; 5744 :                             sense[20], sense[21], sense[22], sense[23],
; 5745 :                             sense[24], sense[25], sense[26], sense[27],
; 5746 :                             sense[28], sense[29], sense[30], sense[31] );
; 5747 : 
; 5748 :                     if (sense[0] != 0 || sense[1] != 0)

  02cb7	b8 01 00 00 00	 mov	 eax, 1
  02cbc	48 6b c0 00	 imul	 rax, rax, 0
  02cc0	48 8b 4d 30	 mov	 rcx, QWORD PTR sense$1[rbp]
  02cc4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02cc8	85 c0		 test	 eax, eax
  02cca	75 15		 jne	 SHORT $LN189@s370_execu
  02ccc	b8 01 00 00 00	 mov	 eax, 1
  02cd1	48 6b c0 01	 imul	 rax, rax, 1
  02cd5	48 8b 4d 30	 mov	 rcx, QWORD PTR sense$1[rbp]
  02cd9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02cdd	85 c0		 test	 eax, eax
  02cdf	74 1d		 je	 SHORT $LN188@s370_execu
$LN189@s370_execu:

; 5749 :                         DISPLAY_SENSE( dev );

  02ce1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171766
  02ce8	41 b8 75 16 00
	00		 mov	 r8d, 5749		; 00001675H
  02cee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171767
  02cf5	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02cf9	e8 00 00 00 00	 call	 _display_sense
$LN188@s370_execu:
$LN187@s370_execu:
$LN185@s370_execu:
$LN176@s370_execu:

; 5750 :                 }
; 5751 :             }
; 5752 :         }
; 5753 : 
; 5754 :         /* Terminate the channel program if any unusual status */
; 5755 :         if (chanstat != 0
; 5756 :             || (unitstat & ~CSW_SM) != (CSW_CE | CSW_DE))

  02cfe	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  02d02	85 c0		 test	 eax, eax
  02d04	75 0c		 jne	 SHORT $LN192@s370_execu
  02d06	0f b6 45 0b	 movzx	 eax, BYTE PTR unitstat$[rbp]
  02d0a	83 e0 bf	 and	 eax, -65		; ffffffffffffffbfH
  02d0d	83 f8 0c	 cmp	 eax, 12
  02d10	74 49		 je	 SHORT $LN190@s370_execu
$LN192@s370_execu:

; 5757 :         {
; 5758 :             if (firstccw && !dev->is_immed && (dev->scsw.flag1 & SCSW1_I))

  02d12	0f b6 45 25	 movzx	 eax, BYTE PTR firstccw$[rbp]
  02d16	85 c0		 test	 eax, eax
  02d18	74 3b		 je	 SHORT $LN193@s370_execu
  02d1a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02d1e	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  02d25	75 2e		 jne	 SHORT $LN193@s370_execu
  02d27	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02d2b	0f b6 80 09 03
	00 00		 movzx	 eax, BYTE PTR [rax+777]
  02d32	83 e0 20	 and	 eax, 32			; 00000020H
  02d35	85 c0		 test	 eax, eax
  02d37	74 1c		 je	 SHORT $LN193@s370_execu

; 5759 :             {
; 5760 :                 /* Set the zero condition-code flag in the SCSW */
; 5761 :                 dev->scsw.flag1 |= SCSW1_Z;

  02d39	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02d3d	0f b6 80 09 03
	00 00		 movzx	 eax, BYTE PTR [rax+777]
  02d44	83 c8 04	 or	 eax, 4
  02d47	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02d4b	88 81 09 03 00
	00		 mov	 BYTE PTR [rcx+777], al

; 5762 :                 firstccw = 0;

  02d51	c6 45 25 00	 mov	 BYTE PTR firstccw$[rbp], 0
$LN193@s370_execu:

; 5763 :             }
; 5764 :             chain = 0;

  02d55	c6 45 17 00	 mov	 BYTE PTR chain$[rbp], 0

; 5765 :         }

  02d59	eb 15		 jmp	 SHORT $LN191@s370_execu
$LN190@s370_execu:

; 5766 : 
; 5767 :         /* Increment CCW address if device returned status modifier  */
; 5768 :         /* SA22-7201-05:                                             */
; 5769 :         /*  p. 15-30, Command Chaining                               */
; 5770 :         else if ((unitstat & (CSW_DE | CSW_SM)) == (CSW_DE | CSW_SM))

  02d5b	0f b6 45 0b	 movzx	 eax, BYTE PTR unitstat$[rbp]
  02d5f	83 e0 44	 and	 eax, 68			; 00000044H
  02d62	83 f8 44	 cmp	 eax, 68			; 00000044H
  02d65	75 09		 jne	 SHORT $LN194@s370_execu

; 5771 :             ccwaddr += 8;

  02d67	8b 45 18	 mov	 eax, DWORD PTR ccwaddr$[rbp]
  02d6a	83 c0 08	 add	 eax, 8
  02d6d	89 45 18	 mov	 DWORD PTR ccwaddr$[rbp], eax
$LN194@s370_execu:
$LN191@s370_execu:

; 5772 : 
; 5773 :         /* Update the chaining flags */
; 5774 :         dev->chained = flags & (CCW_FLAGS_CD | CCW_FLAGS_CC);

  02d70	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  02d74	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  02d79	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02d7d	88 81 78 02 00
	00		 mov	 BYTE PTR [rcx+632], al

; 5775 : 
; 5776 :         /* Update the CCW sequence number unless data chained */
; 5777 :         if ((flags & CCW_FLAGS_CD) == 0)

  02d83	0f b6 45 08	 movzx	 eax, BYTE PTR flags$[rbp]
  02d87	25 80 00 00 00	 and	 eax, 128		; 00000080H
  02d8c	85 c0		 test	 eax, eax
  02d8e	75 4e		 jne	 SHORT $LN195@s370_execu

; 5778 :         {
; 5779 :             dev->ccwseq++;

  02d90	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02d94	8b 80 7c 02 00
	00		 mov	 eax, DWORD PTR [rax+636]
  02d9a	ff c0		 inc	 eax
  02d9c	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02da0	89 81 7c 02 00
	00		 mov	 DWORD PTR [rcx+636], eax

; 5780 : 
; 5781 :             /* Reset prefetch table and master skip data */
; 5782 :             dev->is_immed =

  02da6	c7 45 50 00 00
	00 00		 mov	 DWORD PTR bufpos$[rbp], 0
  02dad	8b 45 50	 mov	 eax, DWORD PTR bufpos$[rbp]
  02db0	89 85 c4 01 00
	00		 mov	 DWORD PTR prefetch$[rbp+4], eax
  02db6	8b 85 c4 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp+4]
  02dbc	89 85 c0 01 00
	00		 mov	 DWORD PTR prefetch$[rbp], eax
  02dc2	8b 85 c0 01 00
	00		 mov	 eax, DWORD PTR prefetch$[rbp]
  02dc8	89 45 10	 mov	 DWORD PTR ps$[rbp], eax
  02dcb	8b 45 10	 mov	 eax, DWORD PTR ps$[rbp]
  02dce	89 45 54	 mov	 DWORD PTR skip_ccws$[rbp], eax
  02dd1	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02dd5	8b 4d 54	 mov	 ecx, DWORD PTR skip_ccws$[rbp]
  02dd8	89 88 a0 02 00
	00		 mov	 DWORD PTR [rax+672], ecx
$LN195@s370_execu:

; 5783 :             skip_ccws =
; 5784 :             ps =
; 5785 :             prefetch.seq =
; 5786 :             prefetch.pos =
; 5787 :             bufpos = 0;
; 5788 :         }
; 5789 : 
; 5790 :         /* If Halt or Clear Pending, restart chaining to reset */
; 5791 :         if (dev->scsw.flag2 & (SCSW2_AC_HALT | SCSW2_AC_CLEAR))

  02dde	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02de2	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  02de9	83 e0 03	 and	 eax, 3
  02dec	85 c0		 test	 eax, eax
  02dee	74 04		 je	 SHORT $LN196@s370_execu

; 5792 :             chain = 1;

  02df0	c6 45 17 01	 mov	 BYTE PTR chain$[rbp], 1
$LN196@s370_execu:

; 5793 : 
; 5794 :     } /* end while(chain) */

  02df4	e9 f7 d8 ff ff	 jmp	 $LN293@s370_execu
$LN3@s370_execu:
$LN21@s370_execu:

; 5795 : 
; 5796 :     IODELAY(dev);

  02df9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  02e00	83 b8 e0 13 00
	00 00		 cmp	 DWORD PTR [rax+5088], 0
  02e07	7e 2d		 jle	 SHORT $LN197@s370_execu
  02e09	b8 01 00 00 00	 mov	 eax, 1
  02e0e	48 6b c0 0a	 imul	 rax, rax, 10
  02e12	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02e16	0f b6 84 01 6c
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1388]
  02e1e	83 f8 20	 cmp	 eax, 32			; 00000020H
  02e21	75 13		 jne	 SHORT $LN197@s370_execu
  02e23	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  02e2a	8b 88 e0 13 00
	00		 mov	 ecx, DWORD PTR [rax+5088]
  02e30	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN197@s370_execu:
  02e36	33 c0		 xor	 eax, eax
  02e38	85 c0		 test	 eax, eax
  02e3a	75 bd		 jne	 SHORT $LN21@s370_execu

; 5797 : 
; 5798 :     /* Call the i/o end exit */
; 5799 :     if (dev->hnd->end) (dev->hnd->end) (dev);

  02e3c	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02e40	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  02e47	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  02e4c	74 12		 je	 SHORT $LN198@s370_execu
  02e4e	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02e52	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  02e59	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02e5d	ff 50 30	 call	 QWORD PTR [rax+48]
$LN198@s370_execu:

; 5800 : 
; 5801 :     /* If we're shutting down, skip final sequence and just exit now */
; 5802 :     if (sysblk.shutdown)

  02e60	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  02e67	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  02e6d	c1 e8 0b	 shr	 eax, 11
  02e70	83 e0 01	 and	 eax, 1
  02e73	85 c0		 test	 eax, eax
  02e75	74 18		 je	 SHORT $LN199@s370_execu

; 5803 :         return execute_ccw_chain_fast_return( iobuf, &iobuf_initial, NULL );

  02e77	45 33 c0	 xor	 r8d, r8d
  02e7a	48 8d 95 00 20
	00 00		 lea	 rdx, QWORD PTR iobuf_initial$[rbp]
  02e81	48 8b 4d 48	 mov	 rcx, QWORD PTR iobuf$[rbp]
  02e85	e8 00 00 00 00	 call	 execute_ccw_chain_fast_return
  02e8a	e9 54 03 00 00	 jmp	 $LN1@s370_execu
$LN199@s370_execu:

; 5804 : 
; 5805 :     /* Final sequence MUST be performed with INTLOCK held to prevent
; 5806 :        I/O instructions (such as test_subchan) from proceeding before
; 5807 :        we can set our flags properly and queue the actual I/O interrupt.
; 5808 :     */
; 5809 :     OBTAIN_INTLOCK(NULL);

  02e8f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171778
  02e96	33 c9		 xor	 ecx, ecx
  02e98	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 5810 :     obtain_lock(&dev->lock);

  02e9d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02ea1	48 83 c0 38	 add	 rax, 56			; 00000038H
  02ea5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171779
  02eac	48 8b c8	 mov	 rcx, rax
  02eaf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 5811 : 
; 5812 :     /* Complete the subchannel status word */
; 5813 :     dev->scsw.flag3 &= ~(SCSW3_AC_SCHAC | SCSW3_AC_DEVAC | SCSW3_SC_INTER);

  02eb5	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02eb9	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  02ec0	25 37 ff ff ff	 and	 eax, -201		; ffffffffffffff37H
  02ec5	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02ec9	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 5814 :     dev->scsw.flag3 |= (SCSW3_SC_PRI | SCSW3_SC_SEC | SCSW3_SC_PEND);

  02ecf	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02ed3	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  02eda	83 c8 07	 or	 eax, 7
  02edd	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02ee1	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al

; 5815 :     STORE_FW(dev->scsw.ccwaddr,ccwaddr);

  02ee7	8b 4d 18	 mov	 ecx, DWORD PTR ccwaddr$[rbp]
  02eea	e8 00 00 00 00	 call	 _byteswap_ulong
  02eef	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02ef3	48 81 c1 0c 03
	00 00		 add	 rcx, 780		; 0000030cH
  02efa	8b d0		 mov	 edx, eax
  02efc	e8 00 00 00 00	 call	 store_fw_noswap

; 5816 :     dev->scsw.unitstat = unitstat;

  02f01	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02f05	0f b6 4d 0b	 movzx	 ecx, BYTE PTR unitstat$[rbp]
  02f09	88 88 10 03 00
	00		 mov	 BYTE PTR [rax+784], cl

; 5817 :     dev->scsw.chanstat = chanstat;

  02f0f	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02f13	0f b6 4d 09	 movzx	 ecx, BYTE PTR chanstat$[rbp]
  02f17	88 88 11 03 00
	00		 mov	 BYTE PTR [rax+785], cl

; 5818 :     STORE_HW(dev->scsw.count,residual);

  02f1d	0f b7 4d 28	 movzx	 ecx, WORD PTR residual$[rbp]
  02f21	e8 00 00 00 00	 call	 _byteswap_ushort
  02f26	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02f2a	48 81 c1 12 03
	00 00		 add	 rcx, 786		; 00000312H
  02f31	0f b7 d0	 movzx	 edx, ax
  02f34	e8 00 00 00 00	 call	 store_hw_noswap

; 5819 : 
; 5820 :     /* Set alert status if terminated by any unusual condition */
; 5821 :     if (chanstat != 0 || unitstat != (CSW_CE | CSW_DE))

  02f39	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  02f3d	85 c0		 test	 eax, eax
  02f3f	75 09		 jne	 SHORT $LN201@s370_execu
  02f41	0f b6 45 0b	 movzx	 eax, BYTE PTR unitstat$[rbp]
  02f45	83 f8 0c	 cmp	 eax, 12
  02f48	74 18		 je	 SHORT $LN200@s370_execu
$LN201@s370_execu:

; 5822 :         dev->scsw.flag3 |= SCSW3_SC_ALERT;

  02f4a	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02f4e	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  02f55	83 c8 10	 or	 eax, 16
  02f58	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02f5c	88 81 0b 03 00
	00		 mov	 BYTE PTR [rcx+779], al
$LN200@s370_execu:

; 5823 : 
; 5824 :     /* Clear the Extended Status Word (ESW) and set LPUM in Word 0,
; 5825 :        defaulting to a Format-1 ESW if no other action taken */
; 5826 :     memset (&dev->esw, 0,sizeof(ESW));

  02f62	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02f66	48 05 2c 03 00
	00		 add	 rax, 812		; 0000032cH
  02f6c	48 8b f8	 mov	 rdi, rax
  02f6f	33 c0		 xor	 eax, eax
  02f71	b9 14 00 00 00	 mov	 ecx, 20
  02f76	f3 aa		 rep stosb

; 5827 :     dev->esw.lpum = 0x80;

  02f78	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02f7c	c6 80 2d 03 00
	00 80		 mov	 BYTE PTR [rax+813], 128	; 00000080H

; 5828 : 
; 5829 :     /* Format-0 if CDC, CCC OR IFCC */
; 5830 :     if (chanstat & (CSW_CDC | CSW_CCC | CSW_ICC))

  02f83	0f b6 45 09	 movzx	 eax, BYTE PTR chanstat$[rbp]
  02f87	83 e0 0e	 and	 eax, 14
  02f8a	85 c0		 test	 eax, eax
  02f8c	0f 84 8b 00 00
	00		 je	 $LN202@s370_execu

; 5831 :     {
; 5832 :         /* SA22-7201-5:                                              */
; 5833 :         /*  p. 16-34, Field Validity Flags (FVF)                     */
; 5834 :         /*  p. 16-34 -- 16-35, Termination Code                      */
; 5835 :         /*  p. 16-35 -- 16-36, Sequence Code (SC)                    */
; 5836 :         /*                                                           */
; 5837 :         /*  TBD: Further refinement needed as only CDC is even close */
; 5838 :         /*       to being properly implemented.                      */
; 5839 :         dev->esw.scl2 = 0x78;   /* FVF: LPUM, termination code,      */

  02f92	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02f96	c6 80 2e 03 00
	00 78		 mov	 BYTE PTR [rax+814], 120	; 00000078H

; 5840 :                                 /*      sequence code and device     */
; 5841 :                                 /*      status valid                 */
; 5842 :         /* Set data direction */
; 5843 :         if (!dev->is_immed)

  02f9d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02fa1	83 b8 a0 02 00
	00 00		 cmp	 DWORD PTR [rax+672], 0
  02fa8	75 68		 jne	 SHORT $LN203@s370_execu

; 5844 :         {
; 5845 :             if (prefetch.seq)

  02faa	83 bd c0 01 00
	00 00		 cmp	 DWORD PTR prefetch$[rbp], 0
  02fb1	74 1a		 je	 SHORT $LN204@s370_execu

; 5846 :                 dev->esw.scl2 |= 0x02;  /* Write operation */

  02fb3	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02fb7	0f b6 80 2e 03
	00 00		 movzx	 eax, BYTE PTR [rax+814]
  02fbe	83 c8 02	 or	 eax, 2
  02fc1	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02fc5	88 81 2e 03 00
	00		 mov	 BYTE PTR [rcx+814], al
  02fcb	eb 45		 jmp	 SHORT $LN205@s370_execu
$LN204@s370_execu:

; 5847 :             else if (IS_CCW_RDBACK(dev->code))

  02fcd	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02fd1	0f b6 80 7a 02
	00 00		 movzx	 eax, BYTE PTR [rax+634]
  02fd8	83 e0 0f	 and	 eax, 15
  02fdb	83 f8 0c	 cmp	 eax, 12
  02fde	75 1a		 jne	 SHORT $LN206@s370_execu

; 5848 :                 dev->esw.scl2 |= 0x03;  /* Read backward */

  02fe0	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02fe4	0f b6 80 2e 03
	00 00		 movzx	 eax, BYTE PTR [rax+814]
  02feb	83 c8 03	 or	 eax, 3
  02fee	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  02ff2	88 81 2e 03 00
	00		 mov	 BYTE PTR [rcx+814], al
  02ff8	eb 18		 jmp	 SHORT $LN207@s370_execu
$LN206@s370_execu:

; 5849 :             else
; 5850 :                 dev->esw.scl2 |= 0x01;  /* Read */

  02ffa	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  02ffe	0f b6 80 2e 03
	00 00		 movzx	 eax, BYTE PTR [rax+814]
  03005	83 c8 01	 or	 eax, 1
  03008	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0300c	88 81 2e 03 00
	00		 mov	 BYTE PTR [rcx+814], al
$LN207@s370_execu:
$LN205@s370_execu:
$LN203@s370_execu:

; 5851 :         }
; 5852 :         dev->esw.scl3 = 0x45;   /* Bits 24-25: Termination Code      */

  03012	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03016	c6 80 2f 03 00
	00 45		 mov	 BYTE PTR [rax+815], 69	; 00000045H
$LN202@s370_execu:

; 5853 :                                 /* Bits 29-31: Sequence Code         */
; 5854 :     }
; 5855 : 
; 5856 :     /* Clear the extended control word */
; 5857 :     memset (dev->ecw, 0, sizeof(dev->ecw));

  0301d	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03021	48 05 40 03 00
	00		 add	 rax, 832		; 00000340H
  03027	48 8b f8	 mov	 rdi, rax
  0302a	33 c0		 xor	 eax, eax
  0302c	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  03031	f3 aa		 rep stosb

; 5858 : 
; 5859 :     /* Return sense information if PMCW allows concurrent sense */
; 5860 :     if ((unitstat & CSW_UC) && (dev->pmcw.flag27 & PMCW27_S))

  03033	0f b6 45 0b	 movzx	 eax, BYTE PTR unitstat$[rbp]
  03037	83 e0 02	 and	 eax, 2
  0303a	85 c0		 test	 eax, eax
  0303c	0f 84 de 00 00
	00		 je	 $LN208@s370_execu
  03042	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03046	0f b6 80 07 03
	00 00		 movzx	 eax, BYTE PTR [rax+775]
  0304d	83 e0 01	 and	 eax, 1
  03050	85 c0		 test	 eax, eax
  03052	0f 84 c8 00 00
	00		 je	 $LN208@s370_execu

; 5861 :     {
; 5862 :         dev->scsw.flag1 |= SCSW1_E;

  03058	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0305c	0f b6 80 09 03
	00 00		 movzx	 eax, BYTE PTR [rax+777]
  03063	83 c8 02	 or	 eax, 2
  03066	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0306a	88 81 09 03 00
	00		 mov	 BYTE PTR [rcx+777], al

; 5863 :         dev->esw.erw0 |= ERW0_S;

  03070	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03074	0f b6 80 30 03
	00 00		 movzx	 eax, BYTE PTR [rax+816]
  0307b	83 c8 01	 or	 eax, 1
  0307e	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  03082	88 81 30 03 00
	00		 mov	 BYTE PTR [rcx+816], al

; 5864 :         dev->esw.erw1 = (BYTE)((dev->numsense < (int)sizeof(dev->ecw)) ?

  03088	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0308c	83 b8 60 03 00
	00 20		 cmp	 DWORD PTR [rax+864], 32	; 00000020H
  03093	73 12		 jae	 SHORT $LN287@s370_execu
  03095	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03099	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  0309f	89 85 e8 00 00
	00		 mov	 DWORD PTR tv2024[rbp], eax
  030a5	eb 0a		 jmp	 SHORT $LN288@s370_execu
$LN287@s370_execu:
  030a7	c7 85 e8 00 00
	00 20 00 00 00	 mov	 DWORD PTR tv2024[rbp], 32 ; 00000020H
$LN288@s370_execu:
  030b1	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  030b5	0f b6 8d e8 00
	00 00		 movzx	 ecx, BYTE PTR tv2024[rbp]
  030bc	88 88 31 03 00
	00		 mov	 BYTE PTR [rax+817], cl

; 5865 :                         dev->numsense : (int)sizeof(dev->ecw));
; 5866 :         memcpy (dev->ecw, dev->sense, dev->esw.erw1 & ERW1_SCNT);

  030c2	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  030c6	0f b6 80 31 03
	00 00		 movzx	 eax, BYTE PTR [rax+817]
  030cd	83 e0 3f	 and	 eax, 63			; 0000003fH
  030d0	48 98		 cdqe
  030d2	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  030d6	48 81 c1 64 03
	00 00		 add	 rcx, 868		; 00000364H
  030dd	48 8b 55 00	 mov	 rdx, QWORD PTR dev$[rbp]
  030e1	48 81 c2 40 03
	00 00		 add	 rdx, 832		; 00000340H
  030e8	48 8b fa	 mov	 rdi, rdx
  030eb	48 8b f1	 mov	 rsi, rcx
  030ee	48 8b c8	 mov	 rcx, rax
  030f1	f3 a4		 rep movsb

; 5867 :         memset (dev->sense, 0, sizeof(dev->sense));

  030f3	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  030f7	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  030fd	48 8b f8	 mov	 rdi, rax
  03100	33 c0		 xor	 eax, eax
  03102	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  03107	f3 aa		 rep stosb

; 5868 :         dev->sns_pending = 0;

  03109	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  0310d	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  03113	83 e0 fb	 and	 eax, -5			; fffffffbH
  03116	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  0311a	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax
$LN208@s370_execu:

; 5869 :     }
; 5870 : 
; 5871 :     /* Late notification. If halt or clear in process, go clear the  */
; 5872 :     /* mess.                                                         */
; 5873 :     if (dev->scsw.flag2 & (SCSW2_AC_HALT | SCSW2_AC_CLEAR))

  03120	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03124	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  0312b	83 e0 03	 and	 eax, 3
  0312e	85 c0		 test	 eax, eax
  03130	74 6a		 je	 SHORT $LN209@s370_execu

; 5874 :     {
; 5875 :         U8 halt = (dev->scsw.flag2 & SCSW2_AC_HALT) ? TRUE : FALSE;

  03132	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03136	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  0313d	83 e0 02	 and	 eax, 2
  03140	85 c0		 test	 eax, eax
  03142	74 0c		 je	 SHORT $LN289@s370_execu
  03144	c7 85 ec 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv2053[rbp], 1
  0314e	eb 0a		 jmp	 SHORT $LN290@s370_execu
$LN289@s370_execu:
  03150	c7 85 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv2053[rbp], 0
$LN290@s370_execu:
  0315a	0f b6 85 ec 00
	00 00		 movzx	 eax, BYTE PTR tv2053[rbp]
  03161	88 45 60	 mov	 BYTE PTR halt$7[rbp], al

; 5876 :         release_lock(&dev->lock);

  03164	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  03168	48 83 c0 38	 add	 rax, 56			; 00000038H
  0316c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171790
  03173	48 8b c8	 mov	 rcx, rax
  03176	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5877 :         RELEASE_INTLOCK(NULL);

  0317c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171791
  03183	33 c9		 xor	 ecx, ecx
  03185	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 5878 :         if (halt)

  0318a	0f b6 45 60	 movzx	 eax, BYTE PTR halt$7[rbp]
  0318e	85 c0		 test	 eax, eax
  03190	74 05		 je	 SHORT $LN210@s370_execu

; 5879 :             goto execute_halt;

  03192	e9 a0 d6 ff ff	 jmp	 $execute_halt$296
$LN210@s370_execu:

; 5880 :         goto execute_clear;

  03197	e9 b1 d5 ff ff	 jmp	 $execute_clear$295
$LN209@s370_execu:

; 5881 :     }
; 5882 : 
; 5883 :     /* Present the interrupt and return */
; 5884 :     queue_io_interrupt_and_update_status_locked( dev, TRUE );

  0319c	ba 01 00 00 00	 mov	 edx, 1
  031a1	48 8b 4d 00	 mov	 rcx, QWORD PTR dev$[rbp]
  031a5	e8 00 00 00 00	 call	 queue_io_interrupt_and_update_status_locked

; 5885 :     release_lock( &dev->lock );

  031aa	48 8b 45 00	 mov	 rax, QWORD PTR dev$[rbp]
  031ae	48 83 c0 38	 add	 rax, 56			; 00000038H
  031b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171793
  031b9	48 8b c8	 mov	 rcx, rax
  031bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5886 :     RELEASE_INTLOCK( NULL );

  031c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171794
  031c9	33 c9		 xor	 ecx, ecx
  031cb	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 5887 :     return execute_ccw_chain_fast_return( iobuf, &iobuf_initial, NULL );

  031d0	45 33 c0	 xor	 r8d, r8d
  031d3	48 8d 95 00 20
	00 00		 lea	 rdx, QWORD PTR iobuf_initial$[rbp]
  031da	48 8b 4d 48	 mov	 rcx, QWORD PTR iobuf$[rbp]
  031de	e8 00 00 00 00	 call	 execute_ccw_chain_fast_return
$LN1@s370_execu:
$LN211@s370_execu:

; 5888 : 
; 5889 : } /* end function execute_ccw_chain */

  031e3	48 8b 8d 40 30
	01 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  031ea	48 33 cc	 xor	 rcx, rsp
  031ed	e8 00 00 00 00	 call	 __security_check_cookie
  031f2	48 81 c4 a8 41
	01 00		 add	 rsp, 82344		; 000141a8H
  031f9	41 5f		 pop	 r15
  031fb	41 5e		 pop	 r14
  031fd	41 5d		 pop	 r13
  031ff	41 5c		 pop	 r12
  03201	5f		 pop	 rdi
  03202	5e		 pop	 rsi
  03203	5b		 pop	 rbx
  03204	5d		 pop	 rbp
  03205	c3		 ret	 0
s370_execute_ccw_chain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\channel.c
_TEXT	SEGMENT
tv156 = 96
tv182 = 100
tv338 = 104
tv344 = 108
tv196 = 112
tv200 = 116
tv203 = 120
tv207 = 124
rc$ = 128
tv375 = 136
msgbuf$1 = 144
__$ArrayPad$ = 272
regs$ = 320
dev$ = 328
orb$ = 336
s370_startio PROC

; 4199 : {

$LN31:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4200 : int     rc;                             /* Return code               */
; 4201 : 
; 4202 :     obtain_lock (&dev->lock);

  0002a	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00032	48 83 c0 38	 add	 rax, 56			; 00000038H
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171377
  0003d	48 8b c8	 mov	 rcx, rax
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4203 : 
; 4204 : #if defined(_FEATURE_IO_ASSIST)
; 4205 :     if(SIE_MODE(regs)
; 4206 :       && (regs->siebk->zone != dev->pmcw.zone

  00046	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00054	d1 e8		 shr	 eax, 1
  00056	83 e0 01	 and	 eax, 1
  00059	85 c0		 test	 eax, eax
  0005b	74 75		 je	 SHORT $LN2@s370_start
  0005d	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0006c	0f b6 40 74	 movzx	 eax, BYTE PTR [rax+116]
  00070	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00078	0f b6 89 04 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+772]
  0007f	3b c1		 cmp	 eax, ecx
  00081	75 18		 jne	 SHORT $LN3@s370_start
  00083	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0008b	0f b6 80 07 03
	00 00		 movzx	 eax, BYTE PTR [rax+775]
  00092	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00097	85 c0		 test	 eax, eax
  00099	75 37		 jne	 SHORT $LN2@s370_start
$LN3@s370_start:

; 4207 :         || !(dev->pmcw.flag27 & PMCW27_I)))
; 4208 :     {
; 4209 :         release_lock (&dev->lock);

  0009b	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a3	48 83 c0 38	 add	 rax, 56			; 00000038H
  000a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171380
  000ae	48 8b c8	 mov	 rcx, rax
  000b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4210 :         longjmp(regs->progjmp,SIE_INTERCEPT_INST);

  000b7	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bf	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000c5	ba fc ff ff ff	 mov	 edx, -4
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 longjmp
$LN2@s370_start:

; 4211 :     }
; 4212 : #endif
; 4213 : 
; 4214 :     /* Return condition code 1 if status pending */
; 4215 :     if (unlikely((dev->scsw.flag3     & SCSW3_SC_PEND)  ||

  000d2	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000da	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  000e1	83 e0 01	 and	 eax, 1
  000e4	85 c0		 test	 eax, eax
  000e6	75 4e		 jne	 SHORT $LN15@s370_start
  000e8	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000f0	0f b6 80 17 03
	00 00		 movzx	 eax, BYTE PTR [rax+791]
  000f7	83 e0 01	 and	 eax, 1
  000fa	85 c0		 test	 eax, eax
  000fc	75 38		 jne	 SHORT $LN15@s370_start
  000fe	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00106	0f b6 80 23 03
	00 00		 movzx	 eax, BYTE PTR [rax+803]
  0010d	83 e0 01	 and	 eax, 1
  00110	85 c0		 test	 eax, eax
  00112	75 22		 jne	 SHORT $LN15@s370_start
  00114	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0011c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00122	c1 e8 1b	 shr	 eax, 27
  00125	83 e0 01	 and	 eax, 1
  00128	85 c0		 test	 eax, eax
  0012a	75 0a		 jne	 SHORT $LN15@s370_start
  0012c	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv156[rsp], 0
  00134	eb 08		 jmp	 SHORT $LN18@s370_start
$LN15@s370_start:
  00136	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv156[rsp], 1
$LN18@s370_start:
  0013e	83 7c 24 60 00	 cmp	 DWORD PTR tv156[rsp], 0
  00143	74 26		 je	 SHORT $LN4@s370_start

; 4216 :                  (dev->pciscsw.flag3  & SCSW3_SC_PEND)  ||
; 4217 :                  (dev->attnscsw.flag3 & SCSW3_SC_PEND)  ||
; 4218 :                  dev->tschpending))
; 4219 :     {
; 4220 :         release_lock (&dev->lock);

  00145	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0014d	48 83 c0 38	 add	 rax, 56			; 00000038H
  00151	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171382
  00158	48 8b c8	 mov	 rcx, rax
  0015b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4221 :         return 1;

  00161	b8 01 00 00 00	 mov	 eax, 1
  00166	e9 06 06 00 00	 jmp	 $LN1@s370_start
$LN4@s370_start:

; 4222 :     }
; 4223 : 
; 4224 :     /* Return condition code 2 if device is busy */
; 4225 : #if defined( OPTION_SHARED_DEVICES )
; 4226 :     if (unlikely((dev->busy && dev->shioactive == DEV_SYS_LOCAL)

  0016b	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00173	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00179	c1 e8 13	 shr	 eax, 19
  0017c	83 e0 01	 and	 eax, 1
  0017f	85 c0		 test	 eax, eax
  00181	74 14		 je	 SHORT $LN19@s370_start
  00183	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0018b	81 b8 e4 05 00
	00 ff ff 00 00	 cmp	 DWORD PTR [rax+1508], 65535 ; 0000ffffH
  00195	74 22		 je	 SHORT $LN20@s370_start
$LN19@s370_start:
  00197	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0019f	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001a5	c1 e8 19	 shr	 eax, 25
  001a8	83 e0 01	 and	 eax, 1
  001ab	85 c0		 test	 eax, eax
  001ad	75 0a		 jne	 SHORT $LN20@s370_start
  001af	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv182[rsp], 0
  001b7	eb 08		 jmp	 SHORT $LN24@s370_start
$LN20@s370_start:
  001b9	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv182[rsp], 1
$LN24@s370_start:
  001c1	83 7c 24 64 00	 cmp	 DWORD PTR tv182[rsp], 0
  001c6	0f 84 22 01 00
	00		 je	 $LN5@s370_start

; 4227 :         || dev->startpending))
; 4228 : #else // !defined( OPTION_SHARED_DEVICES )
; 4229 :     if (unlikely((dev->busy)
; 4230 :         || dev->startpending))
; 4231 : #endif // defined( OPTION_SHARED_DEVICES )
; 4232 :     {
; 4233 :         release_lock (&dev->lock);

  001cc	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001d4	48 83 c0 38	 add	 rax, 56			; 00000038H
  001d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171384
  001df	48 8b c8	 mov	 rcx, rax
  001e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4234 : 
; 4235 :         /*************************************************************/
; 4236 :         /* VM system abends IQM00 were found to be caused by startio */
; 4237 :         /* SSCH resulting in cc=2 thanks to this additional log msg. */
; 4238 :         /*                        Peter J. Jansen, 21-Jun-2016       */
; 4239 :         /*************************************************************/
; 4240 :         if (dev->ccwtrace)

  001e8	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001f0	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001f6	c1 e8 0f	 shr	 eax, 15
  001f9	83 e0 01	 and	 eax, 1
  001fc	85 c0		 test	 eax, eax
  001fe	0f 84 e0 00 00
	00		 je	 $LN6@s370_start

; 4241 :         {
; 4242 :             if (sysblk.traceFILE)

  00204	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0020b	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00213	74 13		 je	 SHORT $LN7@s370_start

; 4243 :                 tf_1336( dev );

  00215	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0021d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1336
  00223	e9 bc 00 00 00	 jmp	 $LN8@s370_start
$LN7@s370_start:

; 4244 :             else
; 4245 :                 // "%1d:%04X CHAN: startio cc=2 (busy=%d startpending=%d)"
; 4246 :                 WRMSG( HHC01336, "I", SSID_TO_LCSS(dev->ssid),

  00228	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00230	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00236	c1 e8 19	 shr	 eax, 25
  00239	83 e0 01	 and	 eax, 1
  0023c	89 44 24 70	 mov	 DWORD PTR tv196[rsp], eax
  00240	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00248	8b 89 f8 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1528]
  0024e	c1 e9 13	 shr	 ecx, 19
  00251	83 e1 01	 and	 ecx, 1
  00254	89 4c 24 74	 mov	 DWORD PTR tv200[rsp], ecx
  00258	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00260	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00264	89 54 24 78	 mov	 DWORD PTR tv203[rsp], edx
  00268	4c 8b 84 24 48
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00270	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  00275	41 d1 f8	 sar	 r8d, 1
  00278	44 89 44 24 7c	 mov	 DWORD PTR tv207[rsp], r8d
  0027d	b9 01 00 00 00	 mov	 ecx, 1
  00282	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00288	8b 4c 24 70	 mov	 ecx, DWORD PTR tv196[rsp]
  0028c	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00290	8b 4c 24 74	 mov	 ecx, DWORD PTR tv200[rsp]
  00294	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00298	8b 4c 24 78	 mov	 ecx, DWORD PTR tv203[rsp]
  0029c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002a0	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv207[rsp]
  002a4	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171388
  002af	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171389
  002bb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002c0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c5	41 b9 03 00 00
	00		 mov	 r9d, 3
  002cb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171390
  002d2	ba 97 10 00 00	 mov	 edx, 4247		; 00001097H
  002d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171391
  002de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN8@s370_start:
$LN6@s370_start:

; 4247 :                        dev->devnum, dev->busy, dev->startpending );
; 4248 :         }
; 4249 : 
; 4250 :         return 2;

  002e4	b8 02 00 00 00	 mov	 eax, 2
  002e9	e9 83 04 00 00	 jmp	 $LN1@s370_start
$LN5@s370_start:

; 4251 :     }
; 4252 : 
; 4253 :     /* Ensure clean status flag bits */
; 4254 :     dev->suspended          = 0;

  002ee	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002f6	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  002fc	0f ba f0 15	 btr	 eax, 21
  00300	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00308	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4255 :     dev->pending            = 0;

  0030e	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00316	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0031c	0f ba f0 16	 btr	 eax, 22
  00320	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00328	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4256 :     dev->pcipending         = 0;

  0032e	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00336	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0033c	0f ba f0 17	 btr	 eax, 23
  00340	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00348	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4257 :     dev->attnpending        = 0;

  0034e	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00356	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0035c	0f ba f0 18	 btr	 eax, 24
  00360	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00368	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4258 :     dev->startpending       = 0;

  0036e	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00376	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0037c	0f ba f0 19	 btr	 eax, 25
  00380	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00388	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4259 :     dev->resumesuspended    = 0;

  0038e	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00396	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0039c	0f ba f0 1a	 btr	 eax, 26
  003a0	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003a8	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4260 :     dev->tschpending        = 0;

  003ae	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003b6	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  003bc	0f ba f0 1b	 btr	 eax, 27
  003c0	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003c8	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4261 : 
; 4262 :     /* Initialize the subchannel status word */
; 4263 :     memset (&dev->scsw,     0, sizeof(SCSW));

  003ce	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003d6	48 05 08 03 00
	00		 add	 rax, 776		; 00000308H
  003dc	48 8b f8	 mov	 rdi, rax
  003df	33 c0		 xor	 eax, eax
  003e1	b9 0c 00 00 00	 mov	 ecx, 12
  003e6	f3 aa		 rep stosb

; 4264 :     dev->scsw.flag0 = (orb->flag4 & (SCSW0_KEY |

  003e8	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR orb$[rsp]
  003f0	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  003f4	25 f8 00 00 00	 and	 eax, 248		; 000000f8H
  003f9	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00401	88 81 08 03 00
	00		 mov	 BYTE PTR [rcx+776], al

; 4265 :                                      SCSW0_S));
; 4266 :     dev->scsw.flag1 = (orb->flag5 & (SCSW1_F   |

  00407	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR orb$[rsp]
  0040f	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00413	25 f8 00 00 00	 and	 eax, 248		; 000000f8H
  00418	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00420	88 81 09 03 00
	00		 mov	 BYTE PTR [rcx+777], al

; 4267 :                                      SCSW1_P   |
; 4268 :                                      SCSW1_I   |
; 4269 :                                      SCSW1_A   |
; 4270 :                                      SCSW1_U));
; 4271 : 
; 4272 :     /* Set the device busy indicator */
; 4273 :     set_subchannel_busy(dev);

  00426	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0042e	e8 00 00 00 00	 call	 set_subchannel_busy

; 4274 : 
; 4275 :     /* Initialize shadow SCSWs */
; 4276 :     memcpy(&dev->pciscsw,  &dev->scsw, sizeof(SCSW));

  00433	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0043b	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00443	48 8d b8 14 03
	00 00		 lea	 rdi, QWORD PTR [rax+788]
  0044a	48 8d b1 08 03
	00 00		 lea	 rsi, QWORD PTR [rcx+776]
  00451	b9 0c 00 00 00	 mov	 ecx, 12
  00456	f3 a4		 rep movsb

; 4277 :     memcpy(&dev->attnscsw, &dev->scsw, sizeof(SCSW));

  00458	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00460	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00468	48 8d b8 20 03
	00 00		 lea	 rdi, QWORD PTR [rax+800]
  0046f	48 8d b1 08 03
	00 00		 lea	 rsi, QWORD PTR [rcx+776]
  00476	b9 0c 00 00 00	 mov	 ecx, 12
  0047b	f3 a4		 rep movsb

; 4278 : 
; 4279 :     /* Make the subchannel start-pending */
; 4280 :     dev->scsw.flag2 |= SCSW2_FC_START | SCSW2_AC_START;

  0047d	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00485	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  0048c	83 c8 44	 or	 eax, 68			; 00000044H
  0048f	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00497	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 4281 :     dev->startpending = 1;

  0049d	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004a5	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  004ab	0f ba e8 19	 bts	 eax, 25
  004af	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004b7	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4282 : 
; 4283 :     /* Copy the I/O parameter to the path management control word */
; 4284 :     memcpy (dev->pmcw.intparm, orb->intparm,

  004bd	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004c5	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR orb$[rsp]
  004cd	8b 09		 mov	 ecx, DWORD PTR [rcx]
  004cf	89 88 ec 02 00
	00		 mov	 DWORD PTR [rax+748], ecx

; 4285 :                         sizeof(dev->pmcw.intparm));
; 4286 : 
; 4287 :     /* Store the start I/O parameters in the device block */
; 4288 :     if (orb->flag7 & ORB7_X)

  004d5	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR orb$[rsp]
  004dd	0f b6 40 07	 movzx	 eax, BYTE PTR [rax+7]
  004e1	83 e0 01	 and	 eax, 1
  004e4	85 c0		 test	 eax, eax
  004e6	74 20		 je	 SHORT $LN9@s370_start

; 4289 :     {
; 4290 :         /* Extended ORB */
; 4291 :         memcpy(&dev->orb, orb, sizeof(ORB));

  004e8	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004f0	48 8d b8 cc 02
	00 00		 lea	 rdi, QWORD PTR [rax+716]
  004f7	48 8b b4 24 50
	01 00 00	 mov	 rsi, QWORD PTR orb$[rsp]
  004ff	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00504	f3 a4		 rep movsb

; 4292 :     }

  00506	eb 38		 jmp	 SHORT $LN10@s370_start
$LN9@s370_start:

; 4293 :     else
; 4294 :     {
; 4295 :         /* Original ORB size */
; 4296 :         memcpy(&dev->orb, orb, 12);

  00508	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00510	48 8d b8 cc 02
	00 00		 lea	 rdi, QWORD PTR [rax+716]
  00517	48 8b b4 24 50
	01 00 00	 mov	 rsi, QWORD PTR orb$[rsp]
  0051f	b9 0c 00 00 00	 mov	 ecx, 12
  00524	f3 a4		 rep movsb

; 4297 :         memset(&dev->orb.csspriority, 0, sizeof(ORB) - 12);

  00526	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0052e	48 05 d8 02 00
	00		 add	 rax, 728		; 000002d8H
  00534	48 8b f8	 mov	 rdi, rax
  00537	33 c0		 xor	 eax, eax
  00539	b9 14 00 00 00	 mov	 ecx, 20
  0053e	f3 aa		 rep stosb
$LN10@s370_start:

; 4298 :     }
; 4299 : 
; 4300 :     if (dev->orbtrace)

  00540	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00548	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0054e	c1 e8 0e	 shr	 eax, 14
  00551	83 e0 01	 and	 eax, 1
  00554	85 c0		 test	 eax, eax
  00556	0f 84 24 01 00
	00		 je	 $LN11@s370_start

; 4301 :     {
; 4302 :         if (dev->ccwtrace && sysblk.traceFILE)

  0055c	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00564	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0056a	c1 e8 0f	 shr	 eax, 15
  0056d	83 e0 01	 and	 eax, 1
  00570	85 c0		 test	 eax, eax
  00572	74 2c		 je	 SHORT $LN12@s370_start
  00574	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0057b	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00583	74 1b		 je	 SHORT $LN12@s370_start

; 4303 :             tf_1334( dev, orb );

  00585	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR orb$[rsp]
  0058d	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00595	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_1334
  0059b	e9 e0 00 00 00	 jmp	 $LN13@s370_start
$LN12@s370_start:

; 4304 :         else
; 4305 :         {
; 4306 :             char msgbuf[128] = {0};

  005a0	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR msgbuf$1[rsp]
  005a8	48 8b f8	 mov	 rdi, rax
  005ab	33 c0		 xor	 eax, eax
  005ad	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  005b2	f3 aa		 rep stosb

; 4307 :             FormatORB( orb, msgbuf, sizeof( msgbuf ));

  005b4	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  005ba	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR msgbuf$1[rsp]
  005c2	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR orb$[rsp]
  005ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FormatORB

; 4308 :             // "%1d:%04X CHAN: ORB: %s"
; 4309 :             WRMSG( HHC01334, "I", LCSS_DEVNUM, msgbuf );

  005d0	48 83 bc 24 48
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  005d9	74 12		 je	 SHORT $LN25@s370_start
  005db	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005e3	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  005e7	89 44 24 68	 mov	 DWORD PTR tv338[rsp], eax
  005eb	eb 08		 jmp	 SHORT $LN26@s370_start
$LN25@s370_start:
  005ed	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv338[rsp], 0
$LN26@s370_start:
  005f5	48 83 bc 24 48
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  005fe	74 14		 je	 SHORT $LN27@s370_start
  00600	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00608	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0060c	d1 f8		 sar	 eax, 1
  0060e	89 44 24 6c	 mov	 DWORD PTR tv344[rsp], eax
  00612	eb 08		 jmp	 SHORT $LN28@s370_start
$LN27@s370_start:
  00614	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv344[rsp], 0
$LN28@s370_start:
  0061c	b9 01 00 00 00	 mov	 ecx, 1
  00621	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00627	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR msgbuf$1[rsp]
  0062f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00634	8b 4c 24 68	 mov	 ecx, DWORD PTR tv338[rsp]
  00638	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0063c	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv344[rsp]
  00640	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00644	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171397
  0064b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00650	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171398
  00657	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0065c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00661	41 b9 03 00 00
	00		 mov	 r9d, 3
  00667	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171399
  0066e	ba d5 10 00 00	 mov	 edx, 4309		; 000010d5H
  00673	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171400
  0067a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN13@s370_start:
$LN11@s370_start:

; 4310 :         }
; 4311 :     }
; 4312 : 
; 4313 :     /* Set I/O priority */
; 4314 :     dev->priority &= 0x00FF0000ULL;

  00680	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00688	48 63 80 18 02
	00 00		 movsxd	 rax, DWORD PTR [rax+536]
  0068f	48 25 00 00 ff
	00		 and	 rax, 16711680		; 00ff0000H
  00695	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0069d	89 81 18 02 00
	00		 mov	 DWORD PTR [rcx+536], eax

; 4315 :     dev->priority |= dev->orb.csspriority << 8;

  006a3	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006ab	0f b6 80 d8 02
	00 00		 movzx	 eax, BYTE PTR [rax+728]
  006b2	c1 e0 08	 shl	 eax, 8
  006b5	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006bd	8b 89 18 02 00
	00		 mov	 ecx, DWORD PTR [rcx+536]
  006c3	0b c8		 or	 ecx, eax
  006c5	8b c1		 mov	 eax, ecx
  006c7	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006cf	89 81 18 02 00
	00		 mov	 DWORD PTR [rcx+536], eax

; 4316 :     dev->priority |= dev->orb.cupriority;

  006d5	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006dd	0f b6 80 da 02
	00 00		 movzx	 eax, BYTE PTR [rax+730]
  006e4	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006ec	8b 89 18 02 00
	00		 mov	 ecx, DWORD PTR [rcx+536]
  006f2	0b c8		 or	 ecx, eax
  006f4	8b c1		 mov	 eax, ecx
  006f6	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006fe	89 81 18 02 00
	00		 mov	 DWORD PTR [rcx+536], eax

; 4317 : 
; 4318 :     /* Schedule the I/O for execution */
; 4319 :     rc = schedule_ioq((sysblk.arch_mode == ARCH_370_IDX) ? regs : NULL,

  00704	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0070b	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [rax+136], 0
  00712	75 12		 jne	 SHORT $LN29@s370_start
  00714	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0071c	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv375[rsp], rax
  00724	eb 0c		 jmp	 SHORT $LN30@s370_start
$LN29@s370_start:
  00726	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv375[rsp], 0
$LN30@s370_start:
  00732	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0073a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv375[rsp]
  00742	e8 00 00 00 00	 call	 schedule_ioq
  00747	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 4320 :                       dev);
; 4321 : 
; 4322 :     /* Done; release locks and return */
; 4323 :     release_lock (&dev->lock);

  0074e	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00756	48 83 c0 38	 add	 rax, 56			; 00000038H
  0075a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171401
  00761	48 8b c8	 mov	 rcx, rax
  00764	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4324 :     return (rc);

  0076a	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR rc$[rsp]
$LN1@s370_start:
$LN14@s370_start:

; 4325 : 
; 4326 : } /* end function startio */

  00771	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00779	48 33 cc	 xor	 rcx, rsp
  0077c	e8 00 00 00 00	 call	 __security_check_cookie
  00781	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  00788	5f		 pop	 rdi
  00789	5e		 pop	 rsi
  0078a	c3		 ret	 0
s370_startio ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
