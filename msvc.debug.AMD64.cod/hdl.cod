; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	hdl_preload
_DATA	SEGMENT
COMM	hdl_devequ:QWORD
_DATA	ENDS
_DATA	SEGMENT
hdl_preload DQ	FLAT:$SG168166
	DD	010000000H
	ORG $+4
	DQ	FLAT:$SG168167
	DD	010000000H
	ORG $+4
	DQ	0000000000000000H
	DD	00H
	ORG $+4
$SG168166 DB	'hdteq', 00H
	ORG $+2
$SG168167 DB	'dyncrypt', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	hdl_main
PUBLIC	hdl_atexit
PUBLIC	hdl_addshut
PUBLIC	hdl_delshut
PUBLIC	hdl_initpath
PUBLIC	hdl_setpath
PUBLIC	hdl_getpath
PUBLIC	hdl_loadmod
PUBLIC	hdl_freemod
PUBLIC	hdl_listmods
PUBLIC	hdl_listdeps
PUBLIC	hdl_listequs
PUBLIC	hdl_DEVHND
PUBLIC	hdl_getsym
PUBLIC	hdl_next
PUBLIC	hdl_repins
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp_tolower:PROC
EXTRN	__imp__errno:PROC
EXTRN	strrchr:PROC
EXTRN	strcmp:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_GetLastError:PROC
EXTRN	__imp_FreeLibrary:PROC
EXTRN	__imp_GetModuleHandleA:PROC
EXTRN	__imp_GetProcAddress:PROC
EXTRN	__imp_LoadLibraryA:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp__stat64:PROC
EXTRN	hthread_initialize_lock:PROC
EXTRN	hthread_obtain_lock:PROC
EXTRN	hthread_release_lock:PROC
EXTRN	hthread_signal_condition:PROC
EXTRN	hthread_wait_condition:PROC
EXTRN	get_symbol:PROC
EXTRN	set_symbol:PROC
EXTRN	strlcpy:PROC
EXTRN	strlcat:PROC
EXTRN	trim:PROC
EXTRN	idx_snprintf:PROC
EXTRN	w32_strerror:PROC
EXTRN	realpath:PROC
EXTRN	hostpath:PROC
EXTRN	w32_snprintf:PROC
EXTRN	w32_basename:PROC
EXTRN	fwritemsg:PROC
EXTRN	logmsg:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__imp_panel_display:QWORD
EXTRN	__imp_daemon_task:QWORD
EXTRN	__imp_panel_command:QWORD
EXTRN	__imp_system_command:QWORD
EXTRN	__imp_replace_opcode:QWORD
EXTRN	__imp_debug_tt32_stats:QWORD
EXTRN	__imp_debug_tt32_tracing:QWORD
EXTRN	__imp_debug_cd_cmd:QWORD
EXTRN	__imp_debug_cpu_state:QWORD
EXTRN	__imp_debug_watchdog_signal:QWORD
EXTRN	__imp_debug_program_interrupt:QWORD
EXTRN	__imp_debug_diagnose:QWORD
EXTRN	__imp_debug_sclp_unknown_command:QWORD
EXTRN	__imp_debug_sclp_unknown_event:QWORD
EXTRN	__imp_debug_sclp_unknown_event_mask:QWORD
EXTRN	__imp_debug_sclp_event_data:QWORD
EXTRN	__imp_debug_chsc_unknown_request:QWORD
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
hdl_lock DQ	01H DUP (?)
hdl_mods DQ	01H DUP (?)
hdl_curmod DQ	01H DUP (?)
hdl_depend DQ	01H DUP (?)
hdl_modpath DQ	01H DUP (?)
hdl_arg_p DB	01H DUP (?)
	ALIGN	8

hdl_shutlist DQ	01H DUP (?)
hdl_shutting DB	01H DUP (?)
	ALIGN	8

hdl_real_pandisp DQ 01H DUP (?)
hdl_real_pancmd DQ 01H DUP (?)
hdl_real_repopcode DQ 01H DUP (?)
hdl_real_ckd_DEVHND DQ 01H DUP (?)
hdl_real_fba_DEVHND DQ 01H DUP (?)
$SG168717 DB	01H DUP (?)
	ALIGN	4

$SG168720 DB	01H DUP (?)
	ALIGN	4

$SG168730 DB	01H DUP (?)
	ALIGN	8

UNRESOLVED DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
$pdata$hdl_main DD imagerel $LN16
	DD	imagerel $LN16+844
	DD	imagerel $unwind$hdl_main
$pdata$hdl_atexit DD imagerel $LN11
	DD	imagerel $LN11+514
	DD	imagerel $unwind$hdl_atexit
$pdata$hdl_addshut DD imagerel $LN8
	DD	imagerel $LN8+212
	DD	imagerel $unwind$hdl_addshut
$pdata$hdl_delshut DD imagerel $LN8
	DD	imagerel $LN8+187
	DD	imagerel $unwind$hdl_delshut
$pdata$hdl_initpath DD imagerel $LN9
	DD	imagerel $LN9+324
	DD	imagerel $unwind$hdl_initpath
$pdata$hdl_setpath DD imagerel $LN20
	DD	imagerel $LN20+993
	DD	imagerel $unwind$hdl_setpath
$pdata$hdl_getpath DD imagerel $LN4
	DD	imagerel $LN4+33
	DD	imagerel $unwind$hdl_getpath
$pdata$hdl_loadmod DD imagerel $LN38
	DD	imagerel $LN38+2135
	DD	imagerel $unwind$hdl_loadmod
$pdata$hdl_freemod DD imagerel $LN47
	DD	imagerel $LN47+1813
	DD	imagerel $unwind$hdl_freemod
$pdata$hdl_listmods DD imagerel $LN34
	DD	imagerel $LN34+1618
	DD	imagerel $unwind$hdl_listmods
$pdata$hdl_listdeps DD imagerel $LN6
	DD	imagerel $LN6+159
	DD	imagerel $unwind$hdl_listdeps
$pdata$hdl_listequs DD imagerel $LN4
	DD	imagerel $LN4+106
	DD	imagerel $unwind$hdl_listequs
$pdata$hdl_DEVHND DD imagerel $LN8
	DD	imagerel $LN8+206
	DD	imagerel $unwind$hdl_DEVHND
$pdata$hdl_getsym DD imagerel $LN5
	DD	imagerel $LN5+67
	DD	imagerel $unwind$hdl_getsym
$pdata$hdl_next DD imagerel $LN21
	DD	imagerel $LN21+317
	DD	imagerel $unwind$hdl_next
$pdata$hdl_repins DD imagerel $LN21
	DD	imagerel $LN21+890
	DD	imagerel $unwind$hdl_repins
$pdata$Interrupt_Lock_Obtained DD imagerel Interrupt_Lock_Obtained
	DD	imagerel Interrupt_Lock_Obtained+267
	DD	imagerel $unwind$Interrupt_Lock_Obtained
$pdata$Obtain_Interrupt_Lock DD imagerel Obtain_Interrupt_Lock
	DD	imagerel Obtain_Interrupt_Lock+87
	DD	imagerel $unwind$Obtain_Interrupt_Lock
$pdata$Release_Interrupt_Lock DD imagerel Release_Interrupt_Lock
	DD	imagerel Release_Interrupt_Lock+70
	DD	imagerel $unwind$Release_Interrupt_Lock
$pdata$are_any_cpus_started_intlock_held DD imagerel are_any_cpus_started_intlock_held
	DD	imagerel are_any_cpus_started_intlock_held+118
	DD	imagerel $unwind$are_any_cpus_started_intlock_held
$pdata$hdl_check_depends_ep DD imagerel hdl_check_depends_ep
	DD	imagerel hdl_check_depends_ep+236
	DD	imagerel $unwind$hdl_check_depends_ep
$pdata$hdl_register_symbols_ep DD imagerel hdl_register_symbols_ep
	DD	imagerel hdl_register_symbols_ep+338
	DD	imagerel $unwind$hdl_register_symbols_ep
$pdata$hdl_resolve_symbols_ep DD imagerel hdl_resolve_symbols_ep
	DD	imagerel hdl_resolve_symbols_ep+389
	DD	imagerel $unwind$hdl_resolve_symbols_ep
$pdata$hdl_define_devtypes_ep DD imagerel hdl_define_devtypes_ep
	DD	imagerel hdl_define_devtypes_ep+320
	DD	imagerel $unwind$hdl_define_devtypes_ep
$pdata$hdl_check_depends_cb DD imagerel hdl_check_depends_cb
	DD	imagerel hdl_check_depends_cb+464
	DD	imagerel $unwind$hdl_check_depends_cb
$pdata$hdl_register_symbols_cb DD imagerel hdl_register_symbols_cb
	DD	imagerel hdl_register_symbols_cb+135
	DD	imagerel $unwind$hdl_register_symbols_cb
$pdata$hdl_resolve_symbols_cb DD imagerel hdl_resolve_symbols_cb
	DD	imagerel hdl_resolve_symbols_cb+384
	DD	imagerel $unwind$hdl_resolve_symbols_cb
$pdata$hdl_define_devtypes_cb DD imagerel hdl_define_devtypes_cb
	DD	imagerel hdl_define_devtypes_cb+104
	DD	imagerel $unwind$hdl_define_devtypes_cb
$pdata$hdl_define_instructs_cb DD imagerel hdl_define_instructs_cb
	DD	imagerel hdl_define_instructs_cb+303
	DD	imagerel $unwind$hdl_define_instructs_cb
$pdata$hdl_term DD imagerel hdl_term
	DD	imagerel hdl_term+483
	DD	imagerel $unwind$hdl_term
$pdata$hdl_dlopen DD imagerel hdl_dlopen
	DD	imagerel hdl_dlopen+640
	DD	imagerel $unwind$hdl_dlopen
$pdata$hdl_checkpath DD imagerel hdl_checkpath
	DD	imagerel hdl_checkpath+483
	DD	imagerel $unwind$hdl_checkpath
$pdata$get_HDLSYM DD imagerel get_HDLSYM
	DD	imagerel get_HDLSYM+123
	DD	imagerel $unwind$get_HDLSYM
$pdata$hdl_build_devmod_name DD imagerel hdl_build_devmod_name
	DD	imagerel hdl_build_devmod_name+207
	DD	imagerel $unwind$hdl_build_devmod_name
$pdata$hdl_get_DEVHND DD imagerel hdl_get_DEVHND
	DD	imagerel hdl_get_DEVHND+128
	DD	imagerel $unwind$hdl_get_DEVHND
$pdata$curr_opcode_ptr DD imagerel curr_opcode_ptr
	DD	imagerel curr_opcode_ptr+382
	DD	imagerel $unwind$curr_opcode_ptr
pdata	ENDS
_DATA	SEGMENT
	ORG $+7
$SG168261 DB	'hdl.c:91', 00H
	ORG $+3
$SG168265 DB	'S', 00H
	ORG $+2
$SG168262 DB	'&hdl_lock', 00H
	ORG $+2
$SG168313 DB	'/', 00H
	ORG $+2
$SG168264 DB	'malloc(%d)', 00H
	ORG $+1
$SG168377 DB	'E', 00H
	ORG $+2
$SG168266 DB	'HHC01511%s HDL: error in function %s: %s', 0aH, 00H
	ORG $+2
$SG168383 DB	'E', 00H
	ORG $+2
$SG168267 DB	'hdl_main', 00H
	ORG $+3
$SG168268 DB	'hdl.c', 00H
	ORG $+2
$SG168389 DB	'E', 00H
	ORG $+2
$SG168269 DB	'*Hercules', 00H
	ORG $+2
$SG168395 DB	'E', 00H
	ORG $+2
$SG168271 DB	'hdl_main', 00H
	ORG $+3
$SG168272 DB	'hdl.c', 00H
	ORG $+2
$SG168276 DB	'hdl.c', 00H
	ORG $+6
$SG168273 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168275 DB	'hdl_main', 00H
	ORG $+7
$SG168279 DB	'hdl.c:142', 00H
	ORG $+2
$SG168309 DB	'.dll', 00H
	ORG $+7
$SG168277 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168280 DB	'hdl.c:148', 00H
	ORG $+2
$SG168400 DB	'E', 00H
	ORG $+2
$SG168281 DB	'hdl_term', 00H
	ORG $+3
$SG168315 DB	'.dll', 00H
	ORG $+3
$SG168380 DB	'hdl.c', 00H
	ORG $+2
$SG168416 DB	'E', 00H
	ORG $+2
$SG168378 DB	'HHC01519%s HDL: module %s already loaded', 0aH, 00H
	ORG $+2
$SG168421 DB	'W', 00H
	ORG $+2
$SG168379 DB	'hdl_loadmod', 00H
$SG168422 DB	'E', 00H
	ORG $+2
$SG168382 DB	'malloc()', 00H
	ORG $+3
$SG168386 DB	'hdl.c', 00H
	ORG $+2
$SG168493 DB	'E', 00H
	ORG $+2
$SG168384 DB	'HHC01511%s HDL: error in function %s: %s', 0aH, 00H
	ORG $+2
$SG168499 DB	'E', 00H
	ORG $+2
$SG168385 DB	'hdl_loadmod', 00H
$SG168507 DB	'E', 00H
	ORG $+2
$SG168390 DB	'HHC01516%s HDL: unable to open module %s: %s', 0aH, 00H
	ORG $+2
$SG168391 DB	'hdl_loadmod', 00H
$SG168392 DB	'hdl.c', 00H
	ORG $+2
$SG168517 DB	'E', 00H
	ORG $+2
$SG168394 DB	'hdl_check_depends_ep', 00H
	ORG $+3
$SG168396 DB	'HHC01517%s HDL: no HDL_DEPENDENCY_SECTION in %s: %s', 0aH
	DB	00H
	ORG $+3
$SG168397 DB	'hdl_loadmod', 00H
$SG168398 DB	'hdl.c', 00H
	ORG $+2
$SG168526 DB	'E', 00H
	ORG $+2
$SG168401 DB	'HHC01520%s HDL: module %s is duplicate of %s', 0aH, 00H
	ORG $+2
$SG168402 DB	'hdl_loadmod', 00H
$SG168403 DB	'hdl.c', 00H
	ORG $+2
$SG168572 DB	'I', 00H
	ORG $+2
$SG168404 DB	'hdl_register_symbols_ep', 00H
$SG168405 DB	'hdl_resolve_symbols_ep', 00H
	ORG $+1
$SG168406 DB	'hdl_define_devtypes_ep', 00H
	ORG $+1
$SG168407 DB	'hdl_define_instructs_ep', 00H
$SG168408 DB	'hdl_on_module_unload_ep', 00H
$SG168409 DB	'hdl.c:329', 00H
	ORG $+2
$SG168577 DB	'I', 00H
	ORG $+2
$SG168411 DB	'hdl.c:336', 00H
	ORG $+2
$SG168582 DB	'I', 00H
	ORG $+2
$SG168413 DB	'hdl.c:340', 00H
	ORG $+2
$SG168587 DB	'I', 00H
	ORG $+2
$SG168414 DB	'hdl.c:341', 00H
	ORG $+2
$SG168605 DB	'W', 00H
	ORG $+2
$SG168415 DB	'to load an instruction module', 00H
	ORG $+2
$SG168417 DB	'HHC02253%s All CPU''s must be stopped %s', 0aH, 00H
	ORG $+3
$SG168419 DB	'hdl.c', 00H
	ORG $+2
$SG168652 DB	'E', 00H
	ORG $+2
$SG168418 DB	'hdl_loadmod', 00H
$SG168657 DB	'W', 00H
	ORG $+2
$SG168423 DB	'HHC01518%s HDL: dependency check failed for module %s', 0aH
	DB	00H
	ORG $+1
$SG168424 DB	'hdl_loadmod', 00H
$SG168425 DB	'hdl.c', 00H
	ORG $+2
$SG168661 DB	'W', 00H
	ORG $+2
$SG168429 DB	'hdl.c:368', 00H
	ORG $+2
$SG168668 DB	'W', 00H
	ORG $+2
$SG168430 DB	'hdl.c:369', 00H
	ORG $+2
$SG168674 DB	'I', 00H
	ORG $+2
$SG168435 DB	'hdl.c:411', 00H
	ORG $+2
$SG168721 DB	'EXE', 00H
$SG168436 DB	'hdl.c:414', 00H
	ORG $+2
$SG168722 DB	'hdl', 00H
$SG168490 DB	'hdl.c:440', 00H
	ORG $+2
$SG168723 DB	'I', 00H
	ORG $+2
$SG168492 DB	'hdl.c:453', 00H
	ORG $+2
$SG168732 DB	'I', 00H
	ORG $+2
$SG168494 DB	'HHC01524%s HDL: module %s not found', 0aH, 00H
	ORG $+3
$SG168495 DB	'hdl_freemod', 00H
$SG168496 DB	'hdl.c', 00H
	ORG $+2
$SG168739 DB	', ', 00H
	ORG $+1
$SG168498 DB	'hdl.c:462', 00H
	ORG $+2
$SG168740 DB	'I', 00H
	ORG $+2
$SG168500 DB	'HHC01521%s HDL: unloading of module %s not allowed', 0aH
	DB	00H
$SG168745 DB	', ', 00H
	ORG $+1
$SG168501 DB	'hdl_freemod', 00H
$SG168502 DB	'hdl.c', 00H
	ORG $+2
$SG168746 DB	'I', 00H
	ORG $+2
$SG168506 DB	'hdl.c:489', 00H
	ORG $+2
$SG168752 DB	'I', 00H
	ORG $+2
$SG168508 DB	'HHC01522%s HDL: module %s bound to device %1d:%04X', 0aH
	DB	00H
$SG168759 DB	'I', 00H
	ORG $+2
$SG168509 DB	'hdl_freemod', 00H
$SG168510 DB	'hdl.c', 00H
	ORG $+2
$SG168768 DB	'I', 00H
	ORG $+2
$SG168512 DB	'hdl.c:504', 00H
	ORG $+2
$SG168775 DB	'E', 00H
	ORG $+2
$SG168514 DB	'hdl.c:508', 00H
	ORG $+2
$SG168789 DB	'hdt', 00H
$SG168515 DB	'hdl.c:509', 00H
	ORG $+2
$SG168790 DB	'hdt', 00H
$SG168516 DB	'to unload an instruction module', 00H
$SG168518 DB	'HHC02253%s All CPU''s must be stopped %s', 0aH, 00H
	ORG $+3
$SG168520 DB	'hdl.c', 00H
	ORG $+2
$SG168829 DB	'I', 00H
	ORG $+2
$SG168519 DB	'hdl_freemod', 00H
$SG168835 DB	'I', 00H
	ORG $+2
$SG168524 DB	'hdl.c:524', 00H
	ORG $+2
$SG168840 DB	'I', 00H
	ORG $+2
$SG168525 DB	'hdl.c:525', 00H
	ORG $+2
$SG168845 DB	'I', 00H
	ORG $+2
$SG168527 DB	'HHC01523%s HDL: unload of module %s rejected by final se'
	DB	'ction', 0aH, 00H
	ORG $+1
$SG168528 DB	'hdl_freemod', 00H
$SG168529 DB	'hdl.c', 00H
	ORG $+2
$SG168906 DB	'WEBBLK', 00H
	ORG $+1
$SG169017 DB	'I', 00H
	ORG $+2
$SG168531 DB	'hdl.c:579', 00H
	ORG $+2
$SG168909 DB	'DEVBLK', 00H
	ORG $+1
$SG169022 DB	'I', 00H
	ORG $+2
$SG168533 DB	'hdl.c:599', 00H
	ORG $+2
$SG168915 DB	'SYSBLK', 00H
	ORG $+1
$SG169051 DB	'E', 00H
	ORG $+2
$SG168573 DB	'HHC01500%s HDL: begin shutdown sequence', 0aH, 00H
	ORG $+3
$SG168575 DB	'hdl.c', 00H
	ORG $+2
$SG169077 DB	'E', 00H
	ORG $+2
$SG168574 DB	'hdl_atexit', 00H
	ORG $+1
$SG169136 DB	'E', 00H
	ORG $+2
$SG168578 DB	'HHC01501%s HDL: calling %s', 0aH, 00H
$SG169147 DB	'E', 00H
	ORG $+2
$SG168579 DB	'hdl_atexit', 00H
	ORG $+1
$SG168580 DB	'hdl.c', 00H
	ORG $+6
$SG168583 DB	'HHC01502%s HDL: %s complete', 0aH, 00H
	ORG $+3
$SG168584 DB	'hdl_atexit', 00H
	ORG $+1
$SG168585 DB	'hdl.c', 00H
	ORG $+6
$SG168588 DB	'HHC01504%s HDL: shutdown sequence complete', 0aH, 00H
	ORG $+4
$SG168589 DB	'hdl_atexit', 00H
	ORG $+1
$SG168590 DB	'hdl.c', 00H
	ORG $+6
$SG168606 DB	'HHC01536%s HDL: WARNING: ''%s'' is not a valid directory'
	DB	0aH, 00H
$SG168607 DB	'hdl_checkpath', 00H
	ORG $+2
$SG168608 DB	'hdl.c', 00H
	ORG $+2
$SG168619 DB	'HERCULES_LIB', 00H
	ORG $+3
$SG168622 DB	'hercules', 00H
	ORG $+7
$SG168623 DB	'MODPATH', 00H
$SG168643 DB	'hdl_setpath', 00H
$SG168644 DB	'hdl.c', 00H
	ORG $+6
$SG168645 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168647 DB	'hdl_setpath', 00H
$SG168648 DB	'hdl.c', 00H
	ORG $+6
$SG168649 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168655 DB	'hdl.c', 00H
	ORG $+2
$SG168653 DB	'HHC01505%s HDL: directory ''%s'' rejected; exceeds maxim'
	DB	'um length of %d', 0aH, 00H
	ORG $+1
$SG168654 DB	'hdl_setpath', 00H
$SG168660 DB	'hdl.c', 00H
	ORG $+6
$SG168658 DB	'HHC01506%s HDL: directory ''%s'' rejected; ''-p'' cmdlin'
	DB	'e option rules', 0aH, 00H
	ORG $+4
$SG168659 DB	'hdl_setpath', 00H
$SG168664 DB	'hdl.c', 00H
	ORG $+6
$SG168662 DB	'HHC01507%s HDL: directory remains ''%s'' from ''-p'' cmd'
	DB	'line option', 0aH, 00H
	ORG $+7
$SG168663 DB	'hdl_setpath', 00H
	ORG $+4
$SG168666 DB	'"%s": %s', 00H
	ORG $+7
$SG168667 DB	'realpath()', 00H
	ORG $+5
$SG168669 DB	'HHC01511%s HDL: error in function %s: %s', 0aH, 00H
	ORG $+6
$SG168670 DB	'hdl_setpath', 00H
$SG168671 DB	'hdl.c', 00H
	ORG $+6
$SG168673 DB	'MODPATH', 00H
$SG168675 DB	'HHC01508%s HDL: loadable module directory is ''%s''', 0aH
	DB	00H
	ORG $+5
$SG168676 DB	'hdl_setpath', 00H
$SG168677 DB	'hdl.c', 00H
	ORG $+2
$SG168718 DB	'not ', 00H
	ORG $+3
$SG168719 DB	'NOT ', 00H
	ORG $+7
$SG168725 DB	'hdl_listmods', 00H
	ORG $+3
$SG168726 DB	'hdl.c', 00H
	ORG $+2
$SG168724 DB	'HHC01531%s HDL: name = %s, type = %s, flags = (%sunloada'
	DB	'ble, %sforced)', 0aH, 00H
$SG168731 DB	', UNRESOLVED', 00H
	ORG $+3
$SG168733 DB	'HHC01532%s HDL:  symbol = %s, loadcount = %d%s, owner = '
	DB	'%s', 0aH, 00H
	ORG $+4
$SG168734 DB	'hdl_listmods', 00H
	ORG $+3
$SG168735 DB	'hdl.c', 00H
	ORG $+2
$SG168738 DB	', %s', 00H
	ORG $+3
$SG168741 DB	'HHC01533%s HDL:  devtypes = %s', 0aH, 00H
$SG168742 DB	'hdl_listmods', 00H
	ORG $+3
$SG168743 DB	'hdl.c', 00H
	ORG $+2
$SG168747 DB	'HHC01533%s HDL:  devtypes = %s', 0aH, 00H
$SG168748 DB	'hdl_listmods', 00H
	ORG $+3
$SG168749 DB	'hdl.c', 00H
	ORG $+2
$SG168753 DB	'HHC01534%s HDL:  opcode %4.4X (%c%c%c) %s', 0aH, 00H
	ORG $+5
$SG168754 DB	'hdl_listmods', 00H
	ORG $+3
$SG168755 DB	'hdl.c', 00H
	ORG $+2
$SG168760 DB	'HHC01534%s HDL:  opcode %4.4X (%c%c%c) %s', 0aH, 00H
	ORG $+5
$SG168761 DB	'hdl_listmods', 00H
	ORG $+3
$SG168762 DB	'hdl.c', 00H
	ORG $+2
$SG168769 DB	'HHC01535%s HDL: dependency %s: version "%s", size %d', 0aH
	DB	00H
	ORG $+2
$SG168770 DB	'hdl_listdeps', 00H
	ORG $+3
$SG168771 DB	'hdl.c', 00H
	ORG $+2
$SG168776 DB	'HHC01543%s HDL: no devequ module has been loaded', 0aH, 00H
	ORG $+6
$SG168777 DB	'hdl_listequs', 00H
	ORG $+3
$SG168778 DB	'hdl.c', 00H
	ORG $+2
$SG168830 DB	'HHC01512%s HDL: begin termination sequence', 0aH, 00H
	ORG $+4
$SG168831 DB	'hdl_term', 00H
	ORG $+3
$SG168832 DB	'hdl.c', 00H
	ORG $+6
$SG168836 DB	'HHC01513%s HDL: calling module cleanup routine %s', 0aH, 00H
	ORG $+5
$SG168837 DB	'hdl_term', 00H
	ORG $+3
$SG168838 DB	'hdl.c', 00H
	ORG $+6
$SG168841 DB	'HHC01514%s HDL: module cleanup routine %s complete', 0aH
	DB	00H
	ORG $+4
$SG168842 DB	'hdl_term', 00H
	ORG $+3
$SG168843 DB	'hdl.c', 00H
	ORG $+6
$SG168846 DB	'HHC01515%s HDL: termination sequence complete', 0aH, 00H
	ORG $+1
$SG168847 DB	'hdl_term', 00H
	ORG $+3
$SG168848 DB	'hdl.c', 00H
	ORG $+6
$SG168905 DB	'SDL 4.00', 00H
	ORG $+7
$SG168908 DB	'SDL 4.00', 00H
	ORG $+7
$SG168911 DB	'SDL 4.00', 00H
	ORG $+3
$SG168912 DB	'REGS', 00H
	ORG $+7
$SG168914 DB	'SDL 4.2', 00H
$SG168917 DB	'SDL 4.60', 00H
	ORG $+7
$SG168918 DB	'HERCULES', 00H
	ORG $+7
$SG168942 DB	'panel_display', 00H
	ORG $+2
$SG168943 DB	'panel_command', 00H
	ORG $+2
$SG168944 DB	'replace_opcode', 00H
	ORG $+1
$SG168945 DB	'daemon_task', 00H
	ORG $+4
$SG168946 DB	'system_command', 00H
	ORG $+1
$SG168947 DB	'hdl_devequ', 00H
	ORG $+5
$SG168948 DB	'debug_cpu_state', 00H
$SG168949 DB	'debug_cd_cmd', 00H
	ORG $+3
$SG168950 DB	'debug_program_interrupt', 00H
$SG168951 DB	'debug_diagnose', 00H
	ORG $+1
$SG168952 DB	'debug_sclp_unknown_command', 00H
	ORG $+5
$SG168953 DB	'debug_sclp_unknown_event', 00H
	ORG $+7
$SG168954 DB	'debug_sclp_unknown_event_mask', 00H
	ORG $+2
$SG168955 DB	'debug_sclp_event_data', 00H
	ORG $+2
$SG168956 DB	'debug_chsc_unknown_request', 00H
	ORG $+5
$SG168957 DB	'debug_watchdog_signal', 00H
	ORG $+2
$SG168958 DB	'debug_tt32_stats', 00H
	ORG $+7
$SG168959 DB	'debug_tt32_tracing', 00H
	ORG $+5
$SG168963 DB	'panel_display', 00H
	ORG $+2
$SG168964 DB	'panel_command', 00H
	ORG $+2
$SG168965 DB	'replace_opcode', 00H
	ORG $+1
$SG168966 DB	'daemon_task', 00H
	ORG $+4
$SG168967 DB	'system_command', 00H
	ORG $+1
$SG168968 DB	'hdl_devequ', 00H
	ORG $+5
$SG168969 DB	'debug_cpu_state', 00H
$SG168970 DB	'debug_cd_cmd', 00H
	ORG $+3
$SG168971 DB	'debug_program_interrupt', 00H
$SG168972 DB	'debug_diagnose', 00H
	ORG $+1
$SG168973 DB	'debug_sclp_unknown_command', 00H
	ORG $+5
$SG168974 DB	'debug_sclp_unknown_event', 00H
	ORG $+7
$SG168975 DB	'debug_sclp_unknown_event_mask', 00H
	ORG $+2
$SG168976 DB	'debug_sclp_event_data', 00H
	ORG $+2
$SG168977 DB	'debug_chsc_unknown_request', 00H
	ORG $+5
$SG168978 DB	'debug_watchdog_signal', 00H
	ORG $+2
$SG168979 DB	'debug_tt32_stats', 00H
	ORG $+7
$SG168980 DB	'debug_tt32_tracing', 00H
	ORG $+1
$SG168984 DB	'2305', 00H
	ORG $+3
$SG168985 DB	'2311', 00H
	ORG $+3
$SG168986 DB	'2314', 00H
	ORG $+3
$SG168987 DB	'3330', 00H
	ORG $+3
$SG168988 DB	'3340', 00H
	ORG $+3
$SG168989 DB	'3350', 00H
	ORG $+3
$SG168990 DB	'3375', 00H
	ORG $+3
$SG168991 DB	'3380', 00H
	ORG $+3
$SG168992 DB	'3390', 00H
	ORG $+3
$SG168993 DB	'9345', 00H
	ORG $+3
$SG168994 DB	'0671', 00H
	ORG $+3
$SG168995 DB	'3310', 00H
	ORG $+3
$SG168996 DB	'3370', 00H
	ORG $+3
$SG168997 DB	'9313', 00H
	ORG $+3
$SG168998 DB	'9332', 00H
	ORG $+3
$SG168999 DB	'9335', 00H
	ORG $+3
$SG169000 DB	'9336', 00H
	ORG $+7
$SG169018 DB	'HHC01509%s HDL: dependency check failed for %s, version '
	DB	'%s expected %s', 0aH, 00H
$SG169019 DB	'hdl_check_depends_cb', 00H
	ORG $+3
$SG169020 DB	'hdl.c', 00H
	ORG $+2
$SG169024 DB	'hdl_check_depends_cb', 00H
	ORG $+3
$SG169023 DB	'HHC01510%s HDL: dependency check failed for %s, size %d '
	DB	'expected %d', 0aH, 00H
	ORG $+3
$SG169025 DB	'hdl.c', 00H
	ORG $+2
$SG169050 DB	'malloc()', 00H
	ORG $+7
$SG169052 DB	'HHC01511%s HDL: error in function %s: %s', 0aH, 00H
	ORG $+6
$SG169053 DB	'hdl_resolve_symbols_cb', 00H
	ORG $+1
$SG169054 DB	'hdl.c', 00H
	ORG $+2
$SG169076 DB	'hdl_define_instructs_cb', 00H
$SG169078 DB	'HHC01503%s HDL: Invalid architecture passed to %s', 0aH, 00H
	ORG $+5
$SG169079 DB	'hdl_define_instructs_cb', 00H
$SG169080 DB	'hdl.c', 00H
	ORG $+2
$SG169103 DB	'curr_opcode_ptr', 00H
$SG169104 DB	'hdl.c', 00H
	ORG $+2
$SG169107 DB	'curr_opcode_ptr', 00H
$SG169108 DB	'hdl.c', 00H
	ORG $+2
$SG169105 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169137 DB	'HHC01503%s HDL: Invalid architecture passed to %s', 0aH, 00H
	ORG $+5
$SG169109 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169135 DB	'hdl_repins', 00H
	ORG $+5
$SG169138 DB	'hdl_repins', 00H
	ORG $+1
$SG169139 DB	'hdl.c', 00H
	ORG $+6
$SG169146 DB	'hdl_repins', 00H
	ORG $+5
$SG169148 DB	'HHC01503%s HDL: Invalid architecture passed to %s', 0aH, 00H
	ORG $+5
$SG169149 DB	'hdl_repins', 00H
	ORG $+1
$SG169150 DB	'hdl.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:hdl_checkpath
	DD	016H
	DD	01cbH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:hdl_listmods
	DD	015H
	DD	063aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:hdl_setpath
	DD	016H
	DD	03c9H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:hdl_initpath
	DD	016H
	DD	012cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:hdl_main
	DD	025H
	DD	0334H
voltbl	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$hdl_main DD 022d19H
	DD	017011bH
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$hdl_atexit DD 010401H
	DD	0a204H
$unwind$hdl_addshut DD 011301H
	DD	06213H
$unwind$hdl_delshut DD 010e01H
	DD	0820eH
$unwind$hdl_initpath DD 021e19H
	DD	02b010cH
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$hdl_setpath DD 021e19H
	DD	087010cH
	DD	imagerel __GSHandlerCheck
	DD	0420H
$unwind$hdl_getpath DD 010401H
	DD	04204H
$unwind$hdl_loadmod DD 021001H
	DD	0170110H
$unwind$hdl_freemod DD 020c01H
	DD	01b010cH
$unwind$hdl_listmods DD 021d19H
	DD	03f010bH
	DD	imagerel __GSHandlerCheck
	DD	01e0H
$unwind$hdl_listdeps DD 010401H
	DD	0c204H
$unwind$hdl_listequs DD 010401H
	DD	08204H
$unwind$hdl_DEVHND DD 010901H
	DD	08209H
$unwind$hdl_getsym DD 010901H
	DD	06209H
$unwind$hdl_next DD 010901H
	DD	08209H
$unwind$hdl_repins DD 010d01H
	DD	0e20dH
$unwind$Interrupt_Lock_Obtained DD 010e01H
	DD	0420eH
$unwind$Obtain_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$Release_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$are_any_cpus_started_intlock_held DD 010401H
	DD	02204H
$unwind$hdl_check_depends_ep DD 010901H
	DD	06209H
$unwind$hdl_register_symbols_ep DD 010901H
	DD	04209H
$unwind$hdl_resolve_symbols_ep DD 010901H
	DD	04209H
$unwind$hdl_define_devtypes_ep DD 010901H
	DD	04209H
$unwind$hdl_check_depends_cb DD 011301H
	DD	0c213H
$unwind$hdl_register_symbols_cb DD 010e01H
	DD	0620eH
$unwind$hdl_resolve_symbols_cb DD 010901H
	DD	0e209H
$unwind$hdl_define_devtypes_cb DD 010e01H
	DD	0620eH
$unwind$hdl_define_instructs_cb DD 011601H
	DD	0a216H
$unwind$hdl_term DD 010901H
	DD	0a209H
$unwind$hdl_dlopen DD 010d01H
	DD	0e20dH
$unwind$hdl_checkpath DD 021e19H
	DD	039010cH
	DD	imagerel __GSHandlerCheck
	DD	01b0H
$unwind$get_HDLSYM DD 010901H
	DD	06209H
$unwind$hdl_build_devmod_name DD 010901H
	DD	08209H
$unwind$hdl_get_DEVHND DD 010901H
	DD	06209H
$unwind$curr_opcode_ptr DD 010c01H
	DD	0820cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
opcode2$ = 32
opcode1$ = 36
current$ = 40
dummy$ = 48
hdl_arch$ = 80
opcode$ = 88
curr_opcode_ptr PROC

; 1617 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1618 :     void*  current = NULL;

  0000c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR current$[rsp], 0

; 1619 :     void*  dummy   = (void*) 1;

  00015	48 c7 44 24 30
	01 00 00 00	 mov	 QWORD PTR dummy$[rsp], 1

; 1620 : 
; 1621 :     int    opcode1   = opcode >> 8;

  0001e	8b 44 24 58	 mov	 eax, DWORD PTR opcode$[rsp]
  00022	c1 f8 08	 sar	 eax, 8
  00025	89 44 24 24	 mov	 DWORD PTR opcode1$[rsp], eax

; 1622 :     int    opcode2   = opcode & 0x00ff;

  00029	8b 44 24 58	 mov	 eax, DWORD PTR opcode$[rsp]
  0002d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00032	89 44 24 20	 mov	 DWORD PTR opcode2$[rsp], eax

; 1623 : 
; 1624 : #ifdef                                _370
; 1625 :     if (hdl_arch    ==    HDL_INSTARCH_370) {

  00036	81 7c 24 50 00
	00 00 80	 cmp	 DWORD PTR hdl_arch$[rsp], -2147483648 ; 80000000H
  0003e	75 39		 jne	 SHORT $LN8@curr_opcod

; 1626 :         current = replace_opcode( ARCH_370_IDX, dummy,   opcode1, opcode2 );

  00040	44 8b 4c 24 20	 mov	 r9d, DWORD PTR opcode2$[rsp]
  00045	44 8b 44 24 24	 mov	 r8d, DWORD PTR opcode1$[rsp]
  0004a	48 8b 54 24 30	 mov	 rdx, QWORD PTR dummy$[rsp]
  0004f	33 c9		 xor	 ecx, ecx
  00051	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_replace_opcode
  00058	ff 10		 call	 QWORD PTR [rax]
  0005a	48 89 44 24 28	 mov	 QWORD PTR current$[rsp], rax

; 1627 :         replace_opcode(           ARCH_370_IDX, current, opcode1, opcode2 );

  0005f	44 8b 4c 24 20	 mov	 r9d, DWORD PTR opcode2$[rsp]
  00064	44 8b 44 24 24	 mov	 r8d, DWORD PTR opcode1$[rsp]
  00069	48 8b 54 24 28	 mov	 rdx, QWORD PTR current$[rsp]
  0006e	33 c9		 xor	 ecx, ecx
  00070	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_replace_opcode
  00077	ff 10		 call	 QWORD PTR [rax]
$LN8@curr_opcod:

; 1628 :     }
; 1629 : #endif
; 1630 : #ifdef                                _390
; 1631 :     if (hdl_arch    ==    HDL_INSTARCH_390) {

  00079	81 7c 24 50 00
	00 00 40	 cmp	 DWORD PTR hdl_arch$[rsp], 1073741824 ; 40000000H
  00081	75 3f		 jne	 SHORT $LN9@curr_opcod

; 1632 :         current = replace_opcode( ARCH_390_IDX, dummy,   opcode1, opcode2 );

  00083	44 8b 4c 24 20	 mov	 r9d, DWORD PTR opcode2$[rsp]
  00088	44 8b 44 24 24	 mov	 r8d, DWORD PTR opcode1$[rsp]
  0008d	48 8b 54 24 30	 mov	 rdx, QWORD PTR dummy$[rsp]
  00092	b9 01 00 00 00	 mov	 ecx, 1
  00097	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_replace_opcode
  0009e	ff 10		 call	 QWORD PTR [rax]
  000a0	48 89 44 24 28	 mov	 QWORD PTR current$[rsp], rax

; 1633 :         replace_opcode(           ARCH_390_IDX, current, opcode1, opcode2 );

  000a5	44 8b 4c 24 20	 mov	 r9d, DWORD PTR opcode2$[rsp]
  000aa	44 8b 44 24 24	 mov	 r8d, DWORD PTR opcode1$[rsp]
  000af	48 8b 54 24 28	 mov	 rdx, QWORD PTR current$[rsp]
  000b4	b9 01 00 00 00	 mov	 ecx, 1
  000b9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_replace_opcode
  000c0	ff 10		 call	 QWORD PTR [rax]
$LN9@curr_opcod:

; 1634 :     }
; 1635 : #endif
; 1636 : #ifdef                                _900
; 1637 :     if (hdl_arch    ==    HDL_INSTARCH_900) {

  000c2	81 7c 24 50 00
	00 00 20	 cmp	 DWORD PTR hdl_arch$[rsp], 536870912 ; 20000000H
  000ca	75 3f		 jne	 SHORT $LN10@curr_opcod

; 1638 :         current = replace_opcode( ARCH_900_IDX, dummy,   opcode1, opcode2 );

  000cc	44 8b 4c 24 20	 mov	 r9d, DWORD PTR opcode2$[rsp]
  000d1	44 8b 44 24 24	 mov	 r8d, DWORD PTR opcode1$[rsp]
  000d6	48 8b 54 24 30	 mov	 rdx, QWORD PTR dummy$[rsp]
  000db	b9 02 00 00 00	 mov	 ecx, 2
  000e0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_replace_opcode
  000e7	ff 10		 call	 QWORD PTR [rax]
  000e9	48 89 44 24 28	 mov	 QWORD PTR current$[rsp], rax

; 1639 :         replace_opcode(           ARCH_900_IDX, current, opcode1, opcode2 );

  000ee	44 8b 4c 24 20	 mov	 r9d, DWORD PTR opcode2$[rsp]
  000f3	44 8b 44 24 24	 mov	 r8d, DWORD PTR opcode1$[rsp]
  000f8	48 8b 54 24 28	 mov	 rdx, QWORD PTR current$[rsp]
  000fd	b9 02 00 00 00	 mov	 ecx, 2
  00102	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_replace_opcode
  00109	ff 10		 call	 QWORD PTR [rax]
$LN10@curr_opcod:
$LN4@curr_opcod:

; 1640 :     }
; 1641 : #endif
; 1642 : 
; 1643 :     ASSERT( current );   // (verify hdl_arch was valid)

  0010b	48 83 7c 24 28
	00		 cmp	 QWORD PTR current$[rsp], 0
  00111	75 5b		 jne	 SHORT $LN11@curr_opcod
$LN7@curr_opcod:
  00113	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169103
  0011a	41 b8 6b 06 00
	00		 mov	 r8d, 1643		; 0000066bH
  00120	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169104
  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169105
  0012e	e8 00 00 00 00	 call	 logmsg
  00133	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00139	85 c0		 test	 eax, eax
  0013b	74 20		 je	 SHORT $LN12@curr_opcod
  0013d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169107
  00144	41 b8 6b 06 00
	00		 mov	 r8d, 1643		; 0000066bH
  0014a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169108
  00151	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169109
  00158	e8 00 00 00 00	 call	 DebuggerTrace
$LN12@curr_opcod:
  0015d	33 c0		 xor	 eax, eax
  0015f	85 c0		 test	 eax, eax
  00161	75 b0		 jne	 SHORT $LN7@curr_opcod
  00163	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00169	85 c0		 test	 eax, eax
  0016b	74 01		 je	 SHORT $LN13@curr_opcod
  0016d	cc		 int	 3
$LN13@curr_opcod:
$LN11@curr_opcod:
  0016e	33 c0		 xor	 eax, eax
  00170	85 c0		 test	 eax, eax
  00172	75 97		 jne	 SHORT $LN4@curr_opcod

; 1644 :     return  current;

  00174	48 8b 44 24 28	 mov	 rax, QWORD PTR current$[rsp]

; 1645 : }

  00179	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0017d	c3		 ret	 0
curr_opcode_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
device$ = 32
mod$ = 40
typname$ = 64
hdl_get_DEVHND PROC

; 1112 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1113 :     HDLMOD*  mod;
; 1114 :     HDLDEV*  device;
; 1115 : 
; 1116 :     /* Search device modules for the one handling this device-type */
; 1117 :     for (mod = hdl_mods; mod; mod = mod->next)

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_mods
  00010	48 89 44 24 28	 mov	 QWORD PTR mod$[rsp], rax
  00015	eb 0e		 jmp	 SHORT $LN4@hdl_get_DE
$LN2@hdl_get_DE:
  00017	48 8b 44 24 28	 mov	 rax, QWORD PTR mod$[rsp]
  0001c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00020	48 89 44 24 28	 mov	 QWORD PTR mod$[rsp], rax
$LN4@hdl_get_DE:
  00025	48 83 7c 24 28
	00		 cmp	 QWORD PTR mod$[rsp], 0
  0002b	74 4c		 je	 SHORT $LN3@hdl_get_DE

; 1118 :     {
; 1119 :         for (device = mod->devices; device; device = device->next)

  0002d	48 8b 44 24 28	 mov	 rax, QWORD PTR mod$[rsp]
  00032	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00036	48 89 44 24 20	 mov	 QWORD PTR device$[rsp], rax
  0003b	eb 0e		 jmp	 SHORT $LN7@hdl_get_DE
$LN5@hdl_get_DE:
  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR device$[rsp]
  00042	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00046	48 89 44 24 20	 mov	 QWORD PTR device$[rsp], rax
$LN7@hdl_get_DE:
  0004b	48 83 7c 24 20
	00		 cmp	 QWORD PTR device$[rsp], 0
  00051	74 24		 je	 SHORT $LN6@hdl_get_DE

; 1120 :         {
; 1121 :             if (!strcasecmp( typname, device->name ))

  00053	48 8b 44 24 20	 mov	 rax, QWORD PTR device$[rsp]
  00058	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0005b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR typname$[rsp]
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00066	85 c0		 test	 eax, eax
  00068	75 0b		 jne	 SHORT $LN8@hdl_get_DE

; 1122 :                 return device->hnd;

  0006a	48 8b 44 24 20	 mov	 rax, QWORD PTR device$[rsp]
  0006f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00073	eb 06		 jmp	 SHORT $LN1@hdl_get_DE
$LN8@hdl_get_DE:

; 1123 :         }

  00075	eb c6		 jmp	 SHORT $LN5@hdl_get_DE
$LN6@hdl_get_DE:

; 1124 :     }

  00077	eb 9e		 jmp	 SHORT $LN2@hdl_get_DE
$LN3@hdl_get_DE:

; 1125 : 
; 1126 :     return NULL;

  00079	33 c0		 xor	 eax, eax
$LN1@hdl_get_DE:

; 1127 : }

  0007b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007f	c3		 ret	 0
hdl_get_DEVHND ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
dtname$ = 32
len$ = 40
size$ = 48
tv64 = 56
typname$ = 80
hdl_build_devmod_name PROC

; 1092 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1093 :     char*   dtname;
; 1094 :     size_t  len, size;
; 1095 : 
; 1096 :     size = strlen( "hdt" ) + strlen( typname ) + 1;  // (+1 for NULL terminator)

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168789
  00010	e8 00 00 00 00	 call	 strlen
  00015	48 89 44 24 38	 mov	 QWORD PTR tv64[rsp], rax
  0001a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR typname$[rsp]
  0001f	e8 00 00 00 00	 call	 strlen
  00024	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv64[rsp]
  00029	48 8d 44 01 01	 lea	 rax, QWORD PTR [rcx+rax+1]
  0002e	48 89 44 24 30	 mov	 QWORD PTR size$[rsp], rax

; 1097 :     dtname = malloc( size );

  00033	48 8b 4c 24 30	 mov	 rcx, QWORD PTR size$[rsp]
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0003e	48 89 44 24 20	 mov	 QWORD PTR dtname$[rsp], rax

; 1098 : 
; 1099 :     strlcpy( dtname, "hdt",   size );

  00043	4c 8b 44 24 30	 mov	 r8, QWORD PTR size$[rsp]
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168790
  0004f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dtname$[rsp]
  00054	e8 00 00 00 00	 call	 strlcpy

; 1100 :     strlcat( dtname, typname, size );

  00059	4c 8b 44 24 30	 mov	 r8, QWORD PTR size$[rsp]
  0005e	48 8b 54 24 50	 mov	 rdx, QWORD PTR typname$[rsp]
  00063	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dtname$[rsp]
  00068	e8 00 00 00 00	 call	 strlcat

; 1101 : 
; 1102 :     for (len = 0; len < strlen( dtname ); len++)

  0006d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR len$[rsp], 0
  00076	eb 0d		 jmp	 SHORT $LN4@hdl_build_
$LN2@hdl_build_:
  00078	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  0007d	48 ff c0	 inc	 rax
  00080	48 89 44 24 28	 mov	 QWORD PTR len$[rsp], rax
$LN4@hdl_build_:
  00085	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dtname$[rsp]
  0008a	e8 00 00 00 00	 call	 strlen
  0008f	48 39 44 24 28	 cmp	 QWORD PTR len$[rsp], rax
  00094	73 2f		 jae	 SHORT $LN3@hdl_build_

; 1103 :         dtname[ len ] = tolower( dtname[ len ]);

  00096	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  0009b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dtname$[rsp]
  000a0	48 03 c8	 add	 rcx, rax
  000a3	48 8b c1	 mov	 rax, rcx
  000a6	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000a9	8b c8		 mov	 ecx, eax
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tolower
  000b1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR len$[rsp]
  000b6	48 8b 54 24 20	 mov	 rdx, QWORD PTR dtname$[rsp]
  000bb	48 03 d1	 add	 rdx, rcx
  000be	48 8b ca	 mov	 rcx, rdx
  000c1	88 01		 mov	 BYTE PTR [rcx], al
  000c3	eb b3		 jmp	 SHORT $LN2@hdl_build_
$LN3@hdl_build_:

; 1104 : 
; 1105 :     return dtname;

  000c5	48 8b 44 24 20	 mov	 rax, QWORD PTR dtname$[rsp]

; 1106 : }

  000ca	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ce	c3		 ret	 0
hdl_build_devmod_name ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
sym$ = 32
mod$ = 40
symname$ = 64
get_HDLSYM PROC

; 933  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 934  :     HDLMOD*  mod;
; 935  :     HDLSYM*  sym;
; 936  : 
; 937  :     /* Search all modules for the desired symbol entry */
; 938  :     for (mod = hdl_mods; mod; mod = mod->next)

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_mods
  00010	48 89 44 24 28	 mov	 QWORD PTR mod$[rsp], rax
  00015	eb 0e		 jmp	 SHORT $LN4@get_HDLSYM
$LN2@get_HDLSYM:
  00017	48 8b 44 24 28	 mov	 rax, QWORD PTR mod$[rsp]
  0001c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00020	48 89 44 24 28	 mov	 QWORD PTR mod$[rsp], rax
$LN4@get_HDLSYM:
  00025	48 83 7c 24 28
	00		 cmp	 QWORD PTR mod$[rsp], 0
  0002b	74 47		 je	 SHORT $LN3@get_HDLSYM

; 939  :         for (sym = mod->symbols; sym; sym = sym->next)

  0002d	48 8b 44 24 28	 mov	 rax, QWORD PTR mod$[rsp]
  00032	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  00036	48 89 44 24 20	 mov	 QWORD PTR sym$[rsp], rax
  0003b	eb 0e		 jmp	 SHORT $LN7@get_HDLSYM
$LN5@get_HDLSYM:
  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR sym$[rsp]
  00042	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00046	48 89 44 24 20	 mov	 QWORD PTR sym$[rsp], rax
$LN7@get_HDLSYM:
  0004b	48 83 7c 24 20
	00		 cmp	 QWORD PTR sym$[rsp], 0
  00051	74 1f		 je	 SHORT $LN6@get_HDLSYM

; 940  :             if (strcmp( sym->name, symname ) == 0)

  00053	48 8b 54 24 40	 mov	 rdx, QWORD PTR symname$[rsp]
  00058	48 8b 44 24 20	 mov	 rax, QWORD PTR sym$[rsp]
  0005d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00060	e8 00 00 00 00	 call	 strcmp
  00065	85 c0		 test	 eax, eax
  00067	75 07		 jne	 SHORT $LN8@get_HDLSYM

; 941  :                 return sym;

  00069	48 8b 44 24 20	 mov	 rax, QWORD PTR sym$[rsp]
  0006e	eb 06		 jmp	 SHORT $LN1@get_HDLSYM
$LN8@get_HDLSYM:
  00070	eb cb		 jmp	 SHORT $LN5@get_HDLSYM
$LN6@get_HDLSYM:

; 942  : 
; 943  :     /* Symbol not found */
; 944  :     return NULL;

  00072	eb a3		 jmp	 SHORT $LN2@get_HDLSYM
$LN3@get_HDLSYM:
  00074	33 c0		 xor	 eax, eax
$LN1@get_HDLSYM:

; 945  : }

  00076	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007a	c3		 ret	 0
get_HDLSYM ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
c$ = 64
len$ = 68
tv131 = 72
invalid$ = 76
tv153 = 80
tv155 = 84
$T1 = 88
statbuf$ = 96
workpath$ = 160
__$ArrayPad$ = 432
path$ = 464
hdl_checkpath PROC

; 713  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec c8 01
	00 00		 sub	 rsp, 456		; 000001c8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 714  :     // MAYBE issue HHC01536 warning message if directory is invalid
; 715  : 
; 716  :     char workpath[ MAX_PATH ];
; 717  :     struct stat statbuf;
; 718  :     int invalid;
; 719  : 
; 720  : #ifdef _MSVC_
; 721  :     int len; char c;
; 722  : #endif
; 723  : 
; 724  :     STRLCPY( workpath, path );

  0001e	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00024	48 8b 94 24 d0
	01 00 00	 mov	 rdx, QWORD PTR path$[rsp]
  0002c	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR workpath$[rsp]
  00034	e8 00 00 00 00	 call	 strlcpy

; 725  : 
; 726  : #ifdef _MSVC_
; 727  : 
; 728  :     // stat: If path contains the location of a directory,
; 729  :     // it cannot contain a trailing backslash. If it does,
; 730  :     // -1 will be returned and errno will be set to ENOENT.
; 731  :     // Therefore we need to remove any trailing backslash.
; 732  : 
; 733  :     c = 0;

  00039	c6 44 24 40 00	 mov	 BYTE PTR c$[rsp], 0

; 734  :     len = strlen( workpath );

  0003e	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR workpath$[rsp]
  00046	e8 00 00 00 00	 call	 strlen
  0004b	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 735  : 
; 736  :     // Trailing path separator?
; 737  : 
; 738  :     if (0
; 739  :         || workpath[ len - 1 ] == '/'
; 740  :         || workpath[ len - 1 ] == '\\'

  0004f	33 c0		 xor	 eax, eax
  00051	85 c0		 test	 eax, eax
  00053	75 2a		 jne	 SHORT $LN3@hdl_checkp
  00055	8b 44 24 44	 mov	 eax, DWORD PTR len$[rsp]
  00059	ff c8		 dec	 eax
  0005b	48 98		 cdqe
  0005d	0f be 84 04 a0
	00 00 00	 movsx	 eax, BYTE PTR workpath$[rsp+rax]
  00065	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00068	74 15		 je	 SHORT $LN3@hdl_checkp
  0006a	8b 44 24 44	 mov	 eax, DWORD PTR len$[rsp]
  0006e	ff c8		 dec	 eax
  00070	48 98		 cdqe
  00072	0f be 84 04 a0
	00 00 00	 movsx	 eax, BYTE PTR workpath$[rsp+rax]
  0007a	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  0007d	75 40		 jne	 SHORT $LN2@hdl_checkp
$LN3@hdl_checkp:

; 741  :     )
; 742  :     {
; 743  :         // Yes, remove it and remember that we did so.
; 744  : 
; 745  :         c = workpath[ len - 1 ];     // (remember)

  0007f	8b 44 24 44	 mov	 eax, DWORD PTR len$[rsp]
  00083	ff c8		 dec	 eax
  00085	48 98		 cdqe
  00087	0f b6 84 04 a0
	00 00 00	 movzx	 eax, BYTE PTR workpath$[rsp+rax]
  0008f	88 44 24 40	 mov	 BYTE PTR c$[rsp], al

; 746  :         workpath[ len - 1 ] = 0;     // (remove it)

  00093	8b 44 24 44	 mov	 eax, DWORD PTR len$[rsp]
  00097	ff c8		 dec	 eax
  00099	48 98		 cdqe
  0009b	48 89 44 24 58	 mov	 QWORD PTR $T1[rsp], rax
  000a0	48 81 7c 24 58
	04 01 00 00	 cmp	 QWORD PTR $T1[rsp], 260	; 00000104H
  000a9	73 02		 jae	 SHORT $LN7@hdl_checkp
  000ab	eb 05		 jmp	 SHORT $LN8@hdl_checkp
$LN7@hdl_checkp:
  000ad	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN8@hdl_checkp:
  000b2	48 8b 44 24 58	 mov	 rax, QWORD PTR $T1[rsp]
  000b7	c6 84 04 a0 00
	00 00 00	 mov	 BYTE PTR workpath$[rsp+rax], 0
$LN2@hdl_checkp:

; 747  :     }
; 748  : #endif // _MSVC_
; 749  : 
; 750  :     // Is the directory valid? (does it exist?)
; 751  : 
; 752  :     invalid =

  000bf	33 c0		 xor	 eax, eax
  000c1	85 c0		 test	 eax, eax
  000c3	75 32		 jne	 SHORT $LN9@hdl_checkp
  000c5	48 8d 54 24 60	 lea	 rdx, QWORD PTR statbuf$[rsp]
  000ca	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR workpath$[rsp]
  000d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stat64
  000d8	85 c0		 test	 eax, eax
  000da	75 1b		 jne	 SHORT $LN9@hdl_checkp
  000dc	0f b7 44 24 66	 movzx	 eax, WORD PTR statbuf$[rsp+6]
  000e1	25 00 f0 00 00	 and	 eax, 61440		; 0000f000H
  000e6	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  000eb	75 0a		 jne	 SHORT $LN9@hdl_checkp
  000ed	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
  000f5	eb 08		 jmp	 SHORT $LN10@hdl_checkp
$LN9@hdl_checkp:
  000f7	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
$LN10@hdl_checkp:
  000ff	8b 44 24 48	 mov	 eax, DWORD PTR tv131[rsp]
  00103	89 44 24 4c	 mov	 DWORD PTR invalid$[rsp], eax

; 753  :     (0
; 754  :         || stat( workpath, &statbuf ) != 0
; 755  :         || !S_ISDIR( statbuf.st_mode )
; 756  :     );
; 757  : 
; 758  : #ifdef _MSVC_
; 759  : 
; 760  :     // (restore trailing path separator if removed)
; 761  : 
; 762  :     if (c)

  00107	0f be 44 24 40	 movsx	 eax, BYTE PTR c$[rsp]
  0010c	85 c0		 test	 eax, eax
  0010e	74 14		 je	 SHORT $LN4@hdl_checkp

; 763  :         workpath[ len - 1 ] = c;

  00110	8b 44 24 44	 mov	 eax, DWORD PTR len$[rsp]
  00114	ff c8		 dec	 eax
  00116	48 98		 cdqe
  00118	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR c$[rsp]
  0011d	88 8c 04 a0 00
	00 00		 mov	 BYTE PTR workpath$[rsp+rax], cl
$LN4@hdl_checkp:

; 764  : #endif
; 765  : 
; 766  :     if (invalid && MLVL( VERBOSE ))

  00124	83 7c 24 4c 00	 cmp	 DWORD PTR invalid$[rsp], 0
  00129	74 69		 je	 SHORT $LN5@hdl_checkp
  0012b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00132	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  00138	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0013d	85 c0		 test	 eax, eax
  0013f	74 53		 je	 SHORT $LN5@hdl_checkp

; 767  :     {
; 768  :         // "HDL: WARNING: '%s' is not a valid directory"
; 769  :         WRMSG( HHC01536, "W", path );

  00141	b9 01 00 00 00	 mov	 ecx, 1
  00146	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0014c	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  00154	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00159	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168605
  00160	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00165	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168606
  0016c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00171	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00176	41 b9 03 00 00
	00		 mov	 r9d, 3
  0017c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168607
  00183	ba 01 03 00 00	 mov	 edx, 769		; 00000301H
  00188	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168608
  0018f	e8 00 00 00 00	 call	 fwritemsg
$LN5@hdl_checkp:

; 770  :     }
; 771  : 
; 772  :     return !invalid ? TRUE : FALSE;     // (valid or invalid)

  00194	83 7c 24 4c 00	 cmp	 DWORD PTR invalid$[rsp], 0
  00199	75 0a		 jne	 SHORT $LN11@hdl_checkp
  0019b	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv153[rsp], 1
  001a3	eb 08		 jmp	 SHORT $LN12@hdl_checkp
$LN11@hdl_checkp:
  001a5	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv153[rsp], 0
$LN12@hdl_checkp:
  001ad	83 7c 24 50 00	 cmp	 DWORD PTR tv153[rsp], 0
  001b2	74 0a		 je	 SHORT $LN13@hdl_checkp
  001b4	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv155[rsp], 1
  001bc	eb 08		 jmp	 SHORT $LN14@hdl_checkp
$LN13@hdl_checkp:
  001be	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv155[rsp], 0
$LN14@hdl_checkp:
  001c6	0f b6 44 24 54	 movzx	 eax, BYTE PTR tv155[rsp]
$LN6@hdl_checkp:

; 773  : }

  001cb	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001d3	48 33 cc	 xor	 rcx, rsp
  001d6	e8 00 00 00 00	 call	 __security_check_cookie
  001db	48 81 c4 c8 01
	00 00		 add	 rsp, 456		; 000001c8H
  001e2	c3		 ret	 0
hdl_checkpath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
fullname$ = 32
ret$ = 40
fulllen$ = 48
tv69 = 56
tv129 = 64
filenamecopy$1 = 72
tv157 = 80
tv168 = 88
tv71 = 96
filename$ = 128
flag$ = 136
hdl_dlopen PROC

; 164  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 165  :     char*   fullname;
; 166  :     void*   ret;
; 167  :     size_t  fulllen = 0;

  0000d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR fulllen$[rsp], 0

; 168  : 
; 169  : #if defined( HDL_USE_LIBTOOL )
; 170  :     UNREFERENCED( flag );   /* stupid libtool doesn't support flags! */
; 171  : #endif
; 172  : 
; 173  :     /*
; 174  :      *  Check in this order:
; 175  :      *
; 176  :      *   1.  filename as passed
; 177  :      *   2.  filename with extension if needed
; 178  :      *   3.  modpath added if basename( filename )
; 179  :      *   4.  extension added to #3
; 180  :      */
; 181  :     if ((ret = dlopen( filename, flag ))) /* try filename as-is first */

  00016	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR filename$[rsp], 0
  0001f	74 15		 je	 SHORT $LN10@hdl_dlopen
  00021	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR filename$[rsp]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryA
  0002f	48 89 44 24 38	 mov	 QWORD PTR tv69[rsp], rax
  00034	eb 0d		 jmp	 SHORT $LN11@hdl_dlopen
$LN10@hdl_dlopen:
  00036	33 c9		 xor	 ecx, ecx
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleA
  0003e	48 89 44 24 38	 mov	 QWORD PTR tv69[rsp], rax
$LN11@hdl_dlopen:
  00043	48 8b 44 24 38	 mov	 rax, QWORD PTR tv69[rsp]
  00048	48 89 44 24 28	 mov	 QWORD PTR ret$[rsp], rax
  0004d	48 83 7c 24 28
	00		 cmp	 QWORD PTR ret$[rsp], 0
  00053	74 0a		 je	 SHORT $LN2@hdl_dlopen

; 182  :         return ret;

  00055	48 8b 44 24 28	 mov	 rax, QWORD PTR ret$[rsp]
  0005a	e9 1c 02 00 00	 jmp	 $LN1@hdl_dlopen
$LN2@hdl_dlopen:

; 183  : 
; 184  :      //  2.  filename with extension if needed
; 185  : 
; 186  :     fulllen = strlen( hdl_modpath ) + 1 + strlen( filename ) + HDL_SUFFIX_LENGTH + 1;

  0005f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hdl_modpath
  00066	e8 00 00 00 00	 call	 strlen
  0006b	48 89 44 24 60	 mov	 QWORD PTR tv71[rsp], rax
  00070	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR filename$[rsp]
  00078	e8 00 00 00 00	 call	 strlen
  0007d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv71[rsp]
  00082	48 8d 44 01 06	 lea	 rax, QWORD PTR [rcx+rax+6]
  00087	48 89 44 24 30	 mov	 QWORD PTR fulllen$[rsp], rax

; 187  :     fullname = calloc( 1, fulllen );

  0008c	48 8b 54 24 30	 mov	 rdx, QWORD PTR fulllen$[rsp]
  00091	b9 01 00 00 00	 mov	 ecx, 1
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0009c	48 89 44 24 20	 mov	 QWORD PTR fullname$[rsp], rax

; 188  : 
; 189  :     if (!fullname)

  000a1	48 83 7c 24 20
	00		 cmp	 QWORD PTR fullname$[rsp], 0
  000a7	75 07		 jne	 SHORT $LN3@hdl_dlopen

; 190  :         return NULL;

  000a9	33 c0		 xor	 eax, eax
  000ab	e9 cb 01 00 00	 jmp	 $LN1@hdl_dlopen
$LN3@hdl_dlopen:

; 191  : 
; 192  : #if defined( HDL_MODULE_SUFFIX )
; 193  : 
; 194  :     strlcpy( fullname, filename,          fulllen );

  000b0	4c 8b 44 24 30	 mov	 r8, QWORD PTR fulllen$[rsp]
  000b5	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR filename$[rsp]
  000bd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fullname$[rsp]
  000c2	e8 00 00 00 00	 call	 strlcpy

; 195  :     strlcat( fullname, HDL_MODULE_SUFFIX, fulllen );

  000c7	4c 8b 44 24 30	 mov	 r8, QWORD PTR fulllen$[rsp]
  000cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168309
  000d3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fullname$[rsp]
  000d8	e8 00 00 00 00	 call	 strlcat

; 196  : 
; 197  :     if ((ret = dlopen( fullname, flag )))   /* try filename with suffix next */

  000dd	48 83 7c 24 20
	00		 cmp	 QWORD PTR fullname$[rsp], 0
  000e3	74 12		 je	 SHORT $LN12@hdl_dlopen
  000e5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fullname$[rsp]
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryA
  000f0	48 89 44 24 40	 mov	 QWORD PTR tv129[rsp], rax
  000f5	eb 0d		 jmp	 SHORT $LN13@hdl_dlopen
$LN12@hdl_dlopen:
  000f7	33 c9		 xor	 ecx, ecx
  000f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleA
  000ff	48 89 44 24 40	 mov	 QWORD PTR tv129[rsp], rax
$LN13@hdl_dlopen:
  00104	48 8b 44 24 40	 mov	 rax, QWORD PTR tv129[rsp]
  00109	48 89 44 24 28	 mov	 QWORD PTR ret$[rsp], rax
  0010e	48 83 7c 24 28
	00		 cmp	 QWORD PTR ret$[rsp], 0
  00114	74 15		 je	 SHORT $LN4@hdl_dlopen

; 198  :     {
; 199  :         free( fullname );

  00116	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fullname$[rsp]
  0011b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 200  :         return ret;

  00121	48 8b 44 24 28	 mov	 rax, QWORD PTR ret$[rsp]
  00126	e9 50 01 00 00	 jmp	 $LN1@hdl_dlopen
$LN4@hdl_dlopen:

; 201  :     }
; 202  : #endif
; 203  : 
; 204  :      //  3.  modpath added if basename( filename )
; 205  : 
; 206  :     if (hdl_modpath && *hdl_modpath)

  0012b	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR hdl_modpath, 0
  00133	74 76		 je	 SHORT $LN5@hdl_dlopen
  00135	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_modpath
  0013c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0013f	85 c0		 test	 eax, eax
  00141	74 68		 je	 SHORT $LN5@hdl_dlopen

; 207  :     {
; 208  :         char* filenamecopy = strdup( filename );

  00143	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR filename$[rsp]
  0014b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00151	48 89 44 24 48	 mov	 QWORD PTR filenamecopy$1[rsp], rax

; 209  : 
; 210  :         strlcpy( fullname, hdl_modpath,              fulllen );

  00156	4c 8b 44 24 30	 mov	 r8, QWORD PTR fulllen$[rsp]
  0015b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR hdl_modpath
  00162	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fullname$[rsp]
  00167	e8 00 00 00 00	 call	 strlcpy

; 211  :         strlcat( fullname, PATHSEPS,                 fulllen );

  0016c	4c 8b 44 24 30	 mov	 r8, QWORD PTR fulllen$[rsp]
  00171	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168313
  00178	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fullname$[rsp]
  0017d	e8 00 00 00 00	 call	 strlcat

; 212  :         strlcat( fullname, basename( filenamecopy ), fulllen );

  00182	48 8b 4c 24 48	 mov	 rcx, QWORD PTR filenamecopy$1[rsp]
  00187	e8 00 00 00 00	 call	 w32_basename
  0018c	4c 8b 44 24 30	 mov	 r8, QWORD PTR fulllen$[rsp]
  00191	48 8b d0	 mov	 rdx, rax
  00194	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fullname$[rsp]
  00199	e8 00 00 00 00	 call	 strlcat

; 213  : 
; 214  :         free( filenamecopy );

  0019e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR filenamecopy$1[rsp]
  001a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 215  :     }

  001a9	eb 17		 jmp	 SHORT $LN6@hdl_dlopen
$LN5@hdl_dlopen:

; 216  :     else
; 217  :         strlcpy( fullname, filename, fulllen );

  001ab	4c 8b 44 24 30	 mov	 r8, QWORD PTR fulllen$[rsp]
  001b0	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR filename$[rsp]
  001b8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fullname$[rsp]
  001bd	e8 00 00 00 00	 call	 strlcpy
$LN6@hdl_dlopen:

; 218  : 
; 219  :     if ((ret = dlopen( fullname, flag )))

  001c2	48 83 7c 24 20
	00		 cmp	 QWORD PTR fullname$[rsp], 0
  001c8	74 12		 je	 SHORT $LN14@hdl_dlopen
  001ca	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fullname$[rsp]
  001cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryA
  001d5	48 89 44 24 50	 mov	 QWORD PTR tv157[rsp], rax
  001da	eb 0d		 jmp	 SHORT $LN15@hdl_dlopen
$LN14@hdl_dlopen:
  001dc	33 c9		 xor	 ecx, ecx
  001de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleA
  001e4	48 89 44 24 50	 mov	 QWORD PTR tv157[rsp], rax
$LN15@hdl_dlopen:
  001e9	48 8b 44 24 50	 mov	 rax, QWORD PTR tv157[rsp]
  001ee	48 89 44 24 28	 mov	 QWORD PTR ret$[rsp], rax
  001f3	48 83 7c 24 28
	00		 cmp	 QWORD PTR ret$[rsp], 0
  001f9	74 12		 je	 SHORT $LN7@hdl_dlopen

; 220  :     {
; 221  :         free( fullname );

  001fb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fullname$[rsp]
  00200	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 222  :         return ret;

  00206	48 8b 44 24 28	 mov	 rax, QWORD PTR ret$[rsp]
  0020b	eb 6e		 jmp	 SHORT $LN1@hdl_dlopen
$LN7@hdl_dlopen:

; 223  :     }
; 224  : 
; 225  :     //  4.  extension added to #3
; 226  : 
; 227  : #if defined( HDL_MODULE_SUFFIX )
; 228  : 
; 229  :     strlcat( fullname, HDL_MODULE_SUFFIX, fulllen );

  0020d	4c 8b 44 24 30	 mov	 r8, QWORD PTR fulllen$[rsp]
  00212	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168315
  00219	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fullname$[rsp]
  0021e	e8 00 00 00 00	 call	 strlcat

; 230  : 
; 231  :     if ((ret = dlopen( fullname, flag )))

  00223	48 83 7c 24 20
	00		 cmp	 QWORD PTR fullname$[rsp], 0
  00229	74 12		 je	 SHORT $LN16@hdl_dlopen
  0022b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fullname$[rsp]
  00230	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryA
  00236	48 89 44 24 58	 mov	 QWORD PTR tv168[rsp], rax
  0023b	eb 0d		 jmp	 SHORT $LN17@hdl_dlopen
$LN16@hdl_dlopen:
  0023d	33 c9		 xor	 ecx, ecx
  0023f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleA
  00245	48 89 44 24 58	 mov	 QWORD PTR tv168[rsp], rax
$LN17@hdl_dlopen:
  0024a	48 8b 44 24 58	 mov	 rax, QWORD PTR tv168[rsp]
  0024f	48 89 44 24 28	 mov	 QWORD PTR ret$[rsp], rax
  00254	48 83 7c 24 28
	00		 cmp	 QWORD PTR ret$[rsp], 0
  0025a	74 12		 je	 SHORT $LN8@hdl_dlopen

; 232  :     {
; 233  :         free( fullname );

  0025c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fullname$[rsp]
  00261	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 234  :         return ret;

  00267	48 8b 44 24 28	 mov	 rax, QWORD PTR ret$[rsp]
  0026c	eb 0d		 jmp	 SHORT $LN1@hdl_dlopen
$LN8@hdl_dlopen:

; 235  :     }
; 236  : #endif
; 237  : 
; 238  :     free( fullname );

  0026e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fullname$[rsp]
  00273	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 239  :     return NULL;

  00279	33 c0		 xor	 eax, eax
$LN1@hdl_dlopen:

; 240  : }

  0027b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0027f	c3		 ret	 0
hdl_dlopen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
mod$ = 64
arg$ = 96
hdl_term PROC

; 1196 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@hdl_term:

; 1197 :     HDLMOD*  mod;
; 1198 : 
; 1199 :     UNREFERENCED( arg );

  00009	33 c0		 xor	 eax, eax
  0000b	85 c0		 test	 eax, eax
  0000d	75 fa		 jne	 SHORT $LN4@hdl_term

; 1200 : 
; 1201 :     if (MLVL( DEBUG ))

  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00016	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  0001c	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00021	85 c0		 test	 eax, eax
  00023	74 46		 je	 SHORT $LN8@hdl_term

; 1202 :         // "HDL: begin termination sequence"
; 1203 :         WRMSG( HHC01512, "I" );

  00025	b9 01 00 00 00	 mov	 ecx, 1
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168829
  00037	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168830
  00043	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00048	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00053	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168831
  0005a	ba b3 04 00 00	 mov	 edx, 1203		; 000004b3H
  0005f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168832
  00066	e8 00 00 00 00	 call	 fwritemsg
$LN8@hdl_term:

; 1204 : 
; 1205 :     /* Call all final routines, in LIFO order */
; 1206 :     for (mod = hdl_mods; mod; mod = mod->next)

  0006b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_mods
  00072	48 89 44 24 40	 mov	 QWORD PTR mod$[rsp], rax
  00077	eb 0e		 jmp	 SHORT $LN7@hdl_term
$LN5@hdl_term:
  00079	48 8b 44 24 40	 mov	 rax, QWORD PTR mod$[rsp]
  0007e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00082	48 89 44 24 40	 mov	 QWORD PTR mod$[rsp], rax
$LN7@hdl_term:
  00087	48 83 7c 24 40
	00		 cmp	 QWORD PTR mod$[rsp], 0
  0008d	0f 84 ef 00 00
	00		 je	 $LN6@hdl_term

; 1207 :     {
; 1208 :         if (mod->finsec_ep)

  00093	48 8b 44 24 40	 mov	 rax, QWORD PTR mod$[rsp]
  00098	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  0009d	0f 84 da 00 00
	00		 je	 $LN9@hdl_term

; 1209 :         {
; 1210 :             if (MLVL( DEBUG ))

  000a3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000aa	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  000b0	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  000b5	85 c0		 test	 eax, eax
  000b7	74 53		 je	 SHORT $LN10@hdl_term

; 1211 :                 // "HDL: calling module cleanup routine %s"
; 1212 :                 WRMSG( HHC01513, "I", mod->name );

  000b9	b9 01 00 00 00	 mov	 ecx, 1
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000c4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mod$[rsp]
  000c9	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000cc	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168835
  000d8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168836
  000e4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ee	41 b9 03 00 00
	00		 mov	 r9d, 3
  000f4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168837
  000fb	ba bc 04 00 00	 mov	 edx, 1212		; 000004bcH
  00100	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168838
  00107	e8 00 00 00 00	 call	 fwritemsg
$LN10@hdl_term:

; 1213 : 
; 1214 :             /* Call this module's HDL_FINAL_SECTION */
; 1215 :             mod->finsec_ep();

  0010c	48 8b 44 24 40	 mov	 rax, QWORD PTR mod$[rsp]
  00111	ff 50 40	 call	 QWORD PTR [rax+64]

; 1216 : 
; 1217 :             if (MLVL( DEBUG ))

  00114	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0011b	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  00121	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00126	85 c0		 test	 eax, eax
  00128	74 53		 je	 SHORT $LN11@hdl_term

; 1218 :                 // "HDL: module cleanup routine %s complete"
; 1219 :                 WRMSG( HHC01514, "I", mod->name );

  0012a	b9 01 00 00 00	 mov	 ecx, 1
  0012f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00135	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mod$[rsp]
  0013a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0013d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00142	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168840
  00149	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0014e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168841
  00155	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0015a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0015f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00165	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168842
  0016c	ba c3 04 00 00	 mov	 edx, 1219		; 000004c3H
  00171	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168843
  00178	e8 00 00 00 00	 call	 fwritemsg
$LN11@hdl_term:
$LN9@hdl_term:

; 1220 :         }
; 1221 :     }

  0017d	e9 f7 fe ff ff	 jmp	 $LN5@hdl_term
$LN6@hdl_term:

; 1222 : 
; 1223 :     if (MLVL( DEBUG ))

  00182	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00189	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  0018f	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00194	85 c0		 test	 eax, eax
  00196	74 46		 je	 SHORT $LN12@hdl_term

; 1224 :         // "HDL: termination sequence complete"
; 1225 :         WRMSG( HHC01515, "I" );

  00198	b9 01 00 00 00	 mov	 ecx, 1
  0019d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168845
  001aa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168846
  001b6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001bb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c0	41 b9 03 00 00
	00		 mov	 r9d, 3
  001c6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168847
  001cd	ba c9 04 00 00	 mov	 edx, 1225		; 000004c9H
  001d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168848
  001d9	e8 00 00 00 00	 call	 fwritemsg
$LN12@hdl_term:

; 1226 : }

  001de	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001e2	c3		 ret	 0
hdl_term ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
tv80 = 64
newins$1 = 72
hdl_arch$ = 96
opcode$ = 104
name$ = 112
func$ = 120
hdl_define_instructs_cb PROC

; 1577 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :     /*
; 1579 :     **  Verify caller sanity: caller only allowed to replace one
; 1580 :     **  instruction for one HDL architecture at a time since that
; 1581 :     **  is all an HDLINS struct has room for. (HDL_DEF_INST calls
; 1582 :     **  us separately for each HDL architecture.)
; 1583 :     */
; 1584 :     if (0
; 1585 :         || hdl_arch == HDL_INSTARCH_370         //  S/370
; 1586 :         || hdl_arch == HDL_INSTARCH_390         //  ESA/390
; 1587 :         || hdl_arch == HDL_INSTARCH_900         //  z/Arch

  00016	33 c0		 xor	 eax, eax
  00018	85 c0		 test	 eax, eax
  0001a	75 22		 jne	 SHORT $LN4@hdl_define
  0001c	81 7c 24 60 00
	00 00 80	 cmp	 DWORD PTR hdl_arch$[rsp], -2147483648 ; 80000000H
  00024	74 18		 je	 SHORT $LN4@hdl_define
  00026	81 7c 24 60 00
	00 00 40	 cmp	 DWORD PTR hdl_arch$[rsp], 1073741824 ; 40000000H
  0002e	74 0e		 je	 SHORT $LN4@hdl_define
  00030	81 7c 24 60 00
	00 00 20	 cmp	 DWORD PTR hdl_arch$[rsp], 536870912 ; 20000000H
  00038	0f 85 9a 00 00
	00		 jne	 $LN2@hdl_define
$LN4@hdl_define:

; 1588 :     )
; 1589 :     {
; 1590 :         /* Allocate a new HDLINS entry for this instruction */
; 1591 :         HDLINS*  newins  = malloc( sizeof( HDLINS ));

  0003e	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00049	48 89 44 24 48	 mov	 QWORD PTR newins$1[rsp], rax

; 1592 : 
; 1593 :         /* Initialize the entry for this instruction */
; 1594 :         newins->instname   =  strdup( name );

  0004e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR name$[rsp]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00059	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newins$1[rsp]
  0005e	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1595 :         newins->hdl_arch   =  hdl_arch;

  00061	48 8b 44 24 48	 mov	 rax, QWORD PTR newins$1[rsp]
  00066	8b 4c 24 60	 mov	 ecx, DWORD PTR hdl_arch$[rsp]
  0006a	89 48 1c	 mov	 DWORD PTR [rax+28], ecx

; 1596 :         newins->opcode     =  opcode > 0xff ? opcode : (opcode << 8) ;

  0006d	81 7c 24 68 ff
	00 00 00	 cmp	 DWORD PTR opcode$[rsp], 255 ; 000000ffH
  00075	7e 0a		 jle	 SHORT $LN6@hdl_define
  00077	8b 44 24 68	 mov	 eax, DWORD PTR opcode$[rsp]
  0007b	89 44 24 40	 mov	 DWORD PTR tv80[rsp], eax
  0007f	eb 0b		 jmp	 SHORT $LN7@hdl_define
$LN6@hdl_define:
  00081	8b 44 24 68	 mov	 eax, DWORD PTR opcode$[rsp]
  00085	c1 e0 08	 shl	 eax, 8
  00088	89 44 24 40	 mov	 DWORD PTR tv80[rsp], eax
$LN7@hdl_define:
  0008c	48 8b 44 24 48	 mov	 rax, QWORD PTR newins$1[rsp]
  00091	8b 4c 24 40	 mov	 ecx, DWORD PTR tv80[rsp]
  00095	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 1597 :         newins->instfunc   =  func;

  00098	48 8b 44 24 48	 mov	 rax, QWORD PTR newins$1[rsp]
  0009d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR func$[rsp]
  000a2	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1598 : 
; 1599 :         /* Add it to the current module's chain */
; 1600 :         newins->next =  hdl_curmod->instructs;

  000a6	48 8b 44 24 48	 mov	 rax, QWORD PTR newins$1[rsp]
  000ab	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hdl_curmod
  000b2	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  000b6	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1601 :         hdl_curmod->instructs = newins;

  000ba	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_curmod
  000c1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newins$1[rsp]
  000c6	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 1602 : 
; 1603 :         /* Call 'replace_opcode' helper that does our grunt work */
; 1604 :         hdl_repins( true, newins );

  000ca	48 8b 54 24 48	 mov	 rdx, QWORD PTR newins$1[rsp]
  000cf	b1 01		 mov	 cl, 1
  000d1	e8 00 00 00 00	 call	 hdl_repins

; 1605 :     }

  000d6	eb 52		 jmp	 SHORT $LN3@hdl_define
$LN2@hdl_define:

; 1606 :     else
; 1607 :     {
; 1608 :         // "HDL: Invalid architecture passed to %s"
; 1609 :         WRMSG( HHC01503, "E", "hdl_define_instructs_cb" );

  000d8	b9 01 00 00 00	 mov	 ecx, 1
  000dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169076
  000ea	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169077
  000f6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169078
  00102	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00107	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0010c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00112	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169079
  00119	ba 49 06 00 00	 mov	 edx, 1609		; 00000649H
  0011e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169080
  00125	e8 00 00 00 00	 call	 fwritemsg
$LN3@hdl_define:

; 1610 :     }
; 1611 : }

  0012a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0012e	c3		 ret	 0
hdl_define_instructs_cb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
newhnd$ = 32
typname$ = 64
devhnd$ = 72
hdl_define_devtypes_cb PROC

; 1563 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1564 :     HDLDEV*  newhnd  = malloc( sizeof( HDLDEV ));

  0000e	b9 18 00 00 00	 mov	 ecx, 24
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00019	48 89 44 24 20	 mov	 QWORD PTR newhnd$[rsp], rax

; 1565 : 
; 1566 :     newhnd->name  =  strdup( typname );

  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR typname$[rsp]
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00029	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newhnd$[rsp]
  0002e	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1567 :     newhnd->hnd   =  devhnd;

  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR newhnd$[rsp]
  00036	48 8b 4c 24 48	 mov	 rcx, QWORD PTR devhnd$[rsp]
  0003b	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1568 :     newhnd->next  =  hdl_curmod->devices;

  0003f	48 8b 44 24 20	 mov	 rax, QWORD PTR newhnd$[rsp]
  00044	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hdl_curmod
  0004b	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0004f	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1569 : 
; 1570 :     hdl_curmod->devices = newhnd;

  00053	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_curmod
  0005a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newhnd$[rsp]
  0005f	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 1571 : }

  00063	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00067	c3		 ret	 0
hdl_define_devtypes_cb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
sym$ = 80
mod$ = 88
symbol$ = 96
tv85 = 104
name$ = 128
hdl_resolve_symbols_cb PROC

; 1513 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1514 :     HDLMOD*  mod;
; 1515 :     HDLSYM*  sym;
; 1516 :     void*    symbol;
; 1517 : 
; 1518 :     /* Resolve symbol address and increase reference count if found */
; 1519 :     if ((sym = get_HDLSYM( name )))

  00009	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR name$[rsp]
  00011	e8 00 00 00 00	 call	 get_HDLSYM
  00016	48 89 44 24 50	 mov	 QWORD PTR sym$[rsp], rax
  0001b	48 83 7c 24 50
	00		 cmp	 QWORD PTR sym$[rsp], 0
  00021	74 20		 je	 SHORT $LN5@hdl_resolv

; 1520 :     {
; 1521 :         sym->refcnt++;

  00023	48 8b 44 24 50	 mov	 rax, QWORD PTR sym$[rsp]
  00028	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0002b	ff c0		 inc	 eax
  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR sym$[rsp]
  00032	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 1522 :         return sym->symbol;

  00035	48 8b 44 24 50	 mov	 rax, QWORD PTR sym$[rsp]
  0003a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0003e	e9 38 01 00 00	 jmp	 $LN1@hdl_resolv
$LN5@hdl_resolv:

; 1523 :     }
; 1524 : 
; 1525 :     /* If not found, then lookup as regular symbol (i.e. for each
; 1526 :        module in our chain, ask the host operating if the module
; 1527 :        exported a symbol by that name).
; 1528 :        */
; 1529 :     for (mod = hdl_mods; mod; mod = mod->next)

  00043	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_mods
  0004a	48 89 44 24 58	 mov	 QWORD PTR mod$[rsp], rax
  0004f	eb 0e		 jmp	 SHORT $LN4@hdl_resolv
$LN2@hdl_resolv:
  00051	48 8b 44 24 58	 mov	 rax, QWORD PTR mod$[rsp]
  00056	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0005a	48 89 44 24 58	 mov	 QWORD PTR mod$[rsp], rax
$LN4@hdl_resolv:
  0005f	48 83 7c 24 58
	00		 cmp	 QWORD PTR mod$[rsp], 0
  00065	0f 84 0e 01 00
	00		 je	 $LN3@hdl_resolv

; 1530 :     {
; 1531 :         /* Ask host O/S if the symbol is exported from this module */
; 1532 :         if ((symbol = dlsym( mod->handle, name )))

  0006b	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR name$[rsp]
  00073	48 8b 44 24 58	 mov	 rax, QWORD PTR mod$[rsp]
  00078	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  00082	48 89 44 24 60	 mov	 QWORD PTR symbol$[rsp], rax
  00087	48 83 7c 24 60
	00		 cmp	 QWORD PTR symbol$[rsp], 0
  0008d	0f 84 e1 00 00
	00		 je	 $LN6@hdl_resolv

; 1533 :         {
; 1534 :             /* Yep! It's a regular (unregistered) exported symbol.
; 1535 :                Add this symbol to our symbol chain for this module.
; 1536 :             */
; 1537 :             if (!(sym = malloc( sizeof( HDLSYM ))))

  00093	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0009e	48 89 44 24 50	 mov	 QWORD PTR sym$[rsp], rax
  000a3	48 83 7c 24 50
	00		 cmp	 QWORD PTR sym$[rsp], 0
  000a9	75 72		 jne	 SHORT $LN7@hdl_resolv

; 1538 :             {
; 1539 :                 // "HDL: error in function %s: %s"
; 1540 :                 WRMSG( HHC01511, "E", "malloc()", strerror( errno ));

  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000b1	8b 08		 mov	 ecx, DWORD PTR [rax]
  000b3	e8 00 00 00 00	 call	 w32_strerror
  000b8	48 89 44 24 68	 mov	 QWORD PTR tv85[rsp], rax
  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000c8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv85[rsp]
  000cd	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169050
  000d9	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169051
  000e5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169052
  000f1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000f6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000fb	41 b9 03 00 00
	00		 mov	 r9d, 3
  00101	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169053
  00108	ba 04 06 00 00	 mov	 edx, 1540		; 00000604H
  0010d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169054
  00114	e8 00 00 00 00	 call	 fwritemsg

; 1541 :                 return NULL;

  00119	33 c0		 xor	 eax, eax
  0011b	eb 5e		 jmp	 SHORT $LN1@hdl_resolv
$LN7@hdl_resolv:

; 1542 :             }
; 1543 : 
; 1544 :             sym->name    =  strdup( name );

  0011d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR name$[rsp]
  00125	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0012b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR sym$[rsp]
  00130	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1545 :             sym->symbol  =  symbol;

  00133	48 8b 44 24 50	 mov	 rax, QWORD PTR sym$[rsp]
  00138	48 8b 4c 24 60	 mov	 rcx, QWORD PTR symbol$[rsp]
  0013d	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1546 :             sym->refcnt  =  1;

  00141	48 8b 44 24 50	 mov	 rax, QWORD PTR sym$[rsp]
  00146	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [rax+24], 1

; 1547 :             sym->next    =  mod->symbols;

  0014d	48 8b 44 24 50	 mov	 rax, QWORD PTR sym$[rsp]
  00152	48 8b 4c 24 58	 mov	 rcx, QWORD PTR mod$[rsp]
  00157	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  0015b	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1548 : 
; 1549 :             mod->symbols = sym;

  0015f	48 8b 44 24 58	 mov	 rax, QWORD PTR mod$[rsp]
  00164	48 8b 4c 24 50	 mov	 rcx, QWORD PTR sym$[rsp]
  00169	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 1550 : 
; 1551 :             return symbol;

  0016d	48 8b 44 24 60	 mov	 rax, QWORD PTR symbol$[rsp]
  00172	eb 07		 jmp	 SHORT $LN1@hdl_resolv
$LN6@hdl_resolv:

; 1552 :         }
; 1553 :     }

  00174	e9 d8 fe ff ff	 jmp	 $LN2@hdl_resolv
$LN3@hdl_resolv:

; 1554 : 
; 1555 :     /* Symbol not found */
; 1556 :     return NULL;

  00179	33 c0		 xor	 eax, eax
$LN1@hdl_resolv:

; 1557 : }

  0017b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0017f	c3		 ret	 0
hdl_resolve_symbols_cb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
newsym$ = 32
name$ = 64
symbol$ = 72
hdl_register_symbols_cb PROC

; 1497 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1498 :     HDLSYM*  newsym  = malloc( sizeof( HDLSYM ));

  0000e	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00019	48 89 44 24 20	 mov	 QWORD PTR newsym$[rsp], rax

; 1499 : 
; 1500 :     newsym->name    =  strdup( name );

  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR name$[rsp]
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00029	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newsym$[rsp]
  0002e	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1501 :     newsym->owner   =  hdl_curmod->name;

  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR newsym$[rsp]
  00036	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hdl_curmod
  0003d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00040	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1502 :     newsym->symbol  =  symbol;

  00044	48 8b 44 24 20	 mov	 rax, QWORD PTR newsym$[rsp]
  00049	48 8b 4c 24 48	 mov	 rcx, QWORD PTR symbol$[rsp]
  0004e	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1503 :     newsym->refcnt  =  0;

  00052	48 8b 44 24 20	 mov	 rax, QWORD PTR newsym$[rsp]
  00057	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 1504 :     newsym->next    =  hdl_curmod->symbols;

  0005e	48 8b 44 24 20	 mov	 rax, QWORD PTR newsym$[rsp]
  00063	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hdl_curmod
  0006a	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  0006e	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1505 : 
; 1506 :     hdl_curmod->symbols = newsym;

  00072	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_curmod
  00079	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newsym$[rsp]
  0007e	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 1507 : }

  00082	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00086	c3		 ret	 0
hdl_register_symbols_cb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
depent$ = 80
name$ = 112
version$ = 120
size$ = 128
hdl_check_depends_cb PROC

; 1451 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1452 :     HDLDEP*  depent;
; 1453 : 
; 1454 :     /* Locate the dependency entry we're interested in */
; 1455 :     for (depent = hdl_depend; depent; depent = depent->next)

  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_depend
  0001a	48 89 44 24 50	 mov	 QWORD PTR depent$[rsp], rax
  0001f	eb 0e		 jmp	 SHORT $LN4@hdl_check_
$LN2@hdl_check_:
  00021	48 8b 44 24 50	 mov	 rax, QWORD PTR depent$[rsp]
  00026	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0002a	48 89 44 24 50	 mov	 QWORD PTR depent$[rsp], rax
$LN4@hdl_check_:
  0002f	48 83 7c 24 50
	00		 cmp	 QWORD PTR depent$[rsp], 0
  00035	74 1a		 je	 SHORT $LN3@hdl_check_

; 1456 :     {
; 1457 :         if (strcmp( name, depent->name ) == 0)

  00037	48 8b 44 24 50	 mov	 rax, QWORD PTR depent$[rsp]
  0003c	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0003f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR name$[rsp]
  00044	e8 00 00 00 00	 call	 strcmp
  00049	85 c0		 test	 eax, eax
  0004b	75 02		 jne	 SHORT $LN5@hdl_check_

; 1458 :             break; // (we found it)

  0004d	eb 02		 jmp	 SHORT $LN3@hdl_check_
$LN5@hdl_check_:

; 1459 :     }

  0004f	eb d0		 jmp	 SHORT $LN2@hdl_check_
$LN3@hdl_check_:

; 1460 : 
; 1461 :     /* If we found it, then use it */
; 1462 :     if (depent)

  00051	48 83 7c 24 50
	00		 cmp	 QWORD PTR depent$[rsp], 0
  00057	0f 84 0a 01 00
	00		 je	 $LN6@hdl_check_

; 1463 :     {
; 1464 :         if (strcmp( version, depent->version ))

  0005d	48 8b 44 24 50	 mov	 rax, QWORD PTR depent$[rsp]
  00062	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00066	48 8b 4c 24 78	 mov	 rcx, QWORD PTR version$[rsp]
  0006b	e8 00 00 00 00	 call	 strcmp
  00070	85 c0		 test	 eax, eax
  00072	74 72		 je	 SHORT $LN8@hdl_check_

; 1465 :         {
; 1466 :             // "HDL: dependency check failed for %s, version %s expected %s"
; 1467 :             WRMSG( HHC01509, "I", name, version, depent->version );

  00074	b9 01 00 00 00	 mov	 ecx, 1
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0007f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR depent$[rsp]
  00084	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00088	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0008d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR version$[rsp]
  00092	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00097	48 8b 4c 24 70	 mov	 rcx, QWORD PTR name$[rsp]
  0009c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169017
  000a8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169018
  000b4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000b9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000be	41 b9 03 00 00
	00		 mov	 r9d, 3
  000c4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169019
  000cb	ba bb 05 00 00	 mov	 edx, 1467		; 000005bbH
  000d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169020
  000d7	e8 00 00 00 00	 call	 fwritemsg

; 1468 :             return -1;

  000dc	b8 ff ff ff ff	 mov	 eax, -1
  000e1	e9 e5 00 00 00	 jmp	 $LN1@hdl_check_
$LN8@hdl_check_:

; 1469 :         }
; 1470 : 
; 1471 :         if (size != depent->size)

  000e6	48 8b 44 24 50	 mov	 rax, QWORD PTR depent$[rsp]
  000eb	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000ee	39 84 24 80 00
	00 00		 cmp	 DWORD PTR size$[rsp], eax
  000f5	74 6e		 je	 SHORT $LN9@hdl_check_

; 1472 :         {
; 1473 :             // "HDL: dependency check failed for %s, size %d expected %d"
; 1474 :             WRMSG( HHC01510, "I", name, size, depent->size );

  000f7	b9 01 00 00 00	 mov	 ecx, 1
  000fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00102	48 8b 4c 24 50	 mov	 rcx, QWORD PTR depent$[rsp]
  00107	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  0010a	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0010e	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR size$[rsp]
  00115	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00119	48 8b 4c 24 70	 mov	 rcx, QWORD PTR name$[rsp]
  0011e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00123	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169022
  0012a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0012f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169023
  00136	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0013b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00140	41 b9 03 00 00
	00		 mov	 r9d, 3
  00146	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169024
  0014d	ba c2 05 00 00	 mov	 edx, 1474		; 000005c2H
  00152	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169025
  00159	e8 00 00 00 00	 call	 fwritemsg

; 1475 :             return -1;

  0015e	b8 ff ff ff ff	 mov	 eax, -1
  00163	eb 66		 jmp	 SHORT $LN1@hdl_check_
$LN9@hdl_check_:

; 1476 :         }
; 1477 :     }

  00165	eb 62		 jmp	 SHORT $LN7@hdl_check_
$LN6@hdl_check_:

; 1478 :     else /* Else not found; add it as a new entry in our chain */
; 1479 :     {
; 1480 :         depent = malloc( sizeof( HDLDEP ));

  00167	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0016c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00172	48 89 44 24 50	 mov	 QWORD PTR depent$[rsp], rax

; 1481 : 
; 1482 :         depent->name     =  strdup( name );

  00177	48 8b 4c 24 70	 mov	 rcx, QWORD PTR name$[rsp]
  0017c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00182	48 8b 4c 24 50	 mov	 rcx, QWORD PTR depent$[rsp]
  00187	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1483 :         depent->version  =  strdup( version );

  0018a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR version$[rsp]
  0018f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00195	48 8b 4c 24 50	 mov	 rcx, QWORD PTR depent$[rsp]
  0019a	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1484 :         depent->size     =  size;

  0019e	48 8b 44 24 50	 mov	 rax, QWORD PTR depent$[rsp]
  001a3	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR size$[rsp]
  001aa	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 1485 :         depent->next     =  hdl_depend;

  001ad	48 8b 44 24 50	 mov	 rax, QWORD PTR depent$[rsp]
  001b2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hdl_depend
  001b9	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 1486 : 
; 1487 :         hdl_depend = depent;

  001bd	48 8b 44 24 50	 mov	 rax, QWORD PTR depent$[rsp]
  001c2	48 89 05 00 00
	00 00		 mov	 QWORD PTR hdl_depend, rax
$LN7@hdl_check_:

; 1488 :     }
; 1489 : 
; 1490 :     return 0;

  001c9	33 c0		 xor	 eax, eax
$LN1@hdl_check_:

; 1491 : }

  001cb	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001cf	c3		 ret	 0
hdl_check_depends_cb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
defdev$ = 48
hdl_define_devtypes_ep PROC

; 1406 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1407 :     HDL_DEVICE (  2305,  *hdl_real_ckd_DEVHND  );

  00009	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR hdl_real_ckd_DEVHND
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168984
  00017	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 1408 :     HDL_DEVICE (  2311,  *hdl_real_ckd_DEVHND  );

  0001b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR hdl_real_ckd_DEVHND
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168985
  00029	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 1409 :     HDL_DEVICE (  2314,  *hdl_real_ckd_DEVHND  );

  0002d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR hdl_real_ckd_DEVHND
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168986
  0003b	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 1410 :     HDL_DEVICE (  3330,  *hdl_real_ckd_DEVHND  );

  0003f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR hdl_real_ckd_DEVHND
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168987
  0004d	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 1411 :     HDL_DEVICE (  3340,  *hdl_real_ckd_DEVHND  );

  00051	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR hdl_real_ckd_DEVHND
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168988
  0005f	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 1412 :     HDL_DEVICE (  3350,  *hdl_real_ckd_DEVHND  );

  00063	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR hdl_real_ckd_DEVHND
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168989
  00071	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 1413 :     HDL_DEVICE (  3375,  *hdl_real_ckd_DEVHND  );

  00075	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR hdl_real_ckd_DEVHND
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168990
  00083	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 1414 :     HDL_DEVICE (  3380,  *hdl_real_ckd_DEVHND  );

  00087	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR hdl_real_ckd_DEVHND
  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168991
  00095	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 1415 :     HDL_DEVICE (  3390,  *hdl_real_ckd_DEVHND  );

  00099	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR hdl_real_ckd_DEVHND
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168992
  000a7	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 1416 :     HDL_DEVICE (  9345,  *hdl_real_ckd_DEVHND  );

  000ab	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR hdl_real_ckd_DEVHND
  000b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168993
  000b9	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 1417 : 
; 1418 :     HDL_DEVICE (  0671,  *hdl_real_fba_DEVHND  );

  000bd	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR hdl_real_fba_DEVHND
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168994
  000cb	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 1419 :     HDL_DEVICE (  3310,  *hdl_real_fba_DEVHND  );

  000cf	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR hdl_real_fba_DEVHND
  000d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168995
  000dd	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 1420 :     HDL_DEVICE (  3370,  *hdl_real_fba_DEVHND  );

  000e1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR hdl_real_fba_DEVHND
  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168996
  000ef	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 1421 :     HDL_DEVICE (  9313,  *hdl_real_fba_DEVHND  );

  000f3	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR hdl_real_fba_DEVHND
  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168997
  00101	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 1422 :     HDL_DEVICE (  9332,  *hdl_real_fba_DEVHND  );

  00105	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR hdl_real_fba_DEVHND
  0010c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168998
  00113	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 1423 :     HDL_DEVICE (  9335,  *hdl_real_fba_DEVHND  );

  00117	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR hdl_real_fba_DEVHND
  0011e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168999
  00125	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 1424 :     HDL_DEVICE (  9336,  *hdl_real_fba_DEVHND  );

  00129	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR hdl_real_fba_DEVHND
  00130	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169000
  00137	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 1425 : }

  0013b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0013f	c3		 ret	 0
hdl_define_devtypes_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
getsym$ = 48
hdl_resolve_symbols_ep PROC

; 1375 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1376 :     HDL_RESOLVE( panel_display                 );

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168963
  00010	ff 54 24 30	 call	 QWORD PTR getsym$[rsp]
  00014	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_panel_display
  0001b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1377 :     HDL_RESOLVE( panel_command                 );

  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168964
  00025	ff 54 24 30	 call	 QWORD PTR getsym$[rsp]
  00029	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_panel_command
  00030	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1378 :     HDL_RESOLVE( replace_opcode                );

  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168965
  0003a	ff 54 24 30	 call	 QWORD PTR getsym$[rsp]
  0003e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_replace_opcode
  00045	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1379 : 
; 1380 :     HDL_RESOLVE( daemon_task                   );

  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168966
  0004f	ff 54 24 30	 call	 QWORD PTR getsym$[rsp]
  00053	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_daemon_task
  0005a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1381 :     HDL_RESOLVE( system_command                );

  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168967
  00064	ff 54 24 30	 call	 QWORD PTR getsym$[rsp]
  00068	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_system_command
  0006f	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1382 :     HDL_RESOLVE( hdl_devequ                    );

  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168968
  00079	ff 54 24 30	 call	 QWORD PTR getsym$[rsp]
  0007d	48 89 05 00 00
	00 00		 mov	 QWORD PTR hdl_devequ, rax

; 1383 : 
; 1384 :     HDL_RESOLVE( debug_cpu_state               );

  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168969
  0008b	ff 54 24 30	 call	 QWORD PTR getsym$[rsp]
  0008f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_debug_cpu_state
  00096	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1385 :     HDL_RESOLVE( debug_cd_cmd                  );

  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168970
  000a0	ff 54 24 30	 call	 QWORD PTR getsym$[rsp]
  000a4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_debug_cd_cmd
  000ab	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1386 :     HDL_RESOLVE( debug_program_interrupt       );

  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168971
  000b5	ff 54 24 30	 call	 QWORD PTR getsym$[rsp]
  000b9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_debug_program_interrupt
  000c0	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1387 :     HDL_RESOLVE( debug_diagnose                );

  000c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168972
  000ca	ff 54 24 30	 call	 QWORD PTR getsym$[rsp]
  000ce	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_debug_diagnose
  000d5	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1388 :     HDL_RESOLVE( debug_sclp_unknown_command    );

  000d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168973
  000df	ff 54 24 30	 call	 QWORD PTR getsym$[rsp]
  000e3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_debug_sclp_unknown_command
  000ea	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1389 :     HDL_RESOLVE( debug_sclp_unknown_event      );

  000ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168974
  000f4	ff 54 24 30	 call	 QWORD PTR getsym$[rsp]
  000f8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_debug_sclp_unknown_event
  000ff	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1390 :     HDL_RESOLVE( debug_sclp_unknown_event_mask );

  00102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168975
  00109	ff 54 24 30	 call	 QWORD PTR getsym$[rsp]
  0010d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_debug_sclp_unknown_event_mask
  00114	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1391 :     HDL_RESOLVE( debug_sclp_event_data         );

  00117	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168976
  0011e	ff 54 24 30	 call	 QWORD PTR getsym$[rsp]
  00122	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_debug_sclp_event_data
  00129	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1392 :     HDL_RESOLVE( debug_chsc_unknown_request    );

  0012c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168977
  00133	ff 54 24 30	 call	 QWORD PTR getsym$[rsp]
  00137	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_debug_chsc_unknown_request
  0013e	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1393 :     HDL_RESOLVE( debug_watchdog_signal         );

  00141	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168978
  00148	ff 54 24 30	 call	 QWORD PTR getsym$[rsp]
  0014c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_debug_watchdog_signal
  00153	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1394 : 
; 1395 : #if defined( OPTION_W32_CTCI )
; 1396 :     HDL_RESOLVE( debug_tt32_stats              );

  00156	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168979
  0015d	ff 54 24 30	 call	 QWORD PTR getsym$[rsp]
  00161	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_debug_tt32_stats
  00168	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1397 :     HDL_RESOLVE( debug_tt32_tracing            );

  0016b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168980
  00172	ff 54 24 30	 call	 QWORD PTR getsym$[rsp]
  00176	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_debug_tt32_tracing
  0017d	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1398 : #endif
; 1399 : }

  00180	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00184	c3		 ret	 0
hdl_resolve_symbols_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
regsym$ = 48
hdl_register_symbols_ep PROC

; 1344 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1345 :     HDL_REGISTER( panel_display,                 *hdl_real_pandisp   );

  00009	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR hdl_real_pandisp
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168942
  00017	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 1346 :     HDL_REGISTER( panel_command,                 *hdl_real_pancmd    );

  0001b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR hdl_real_pancmd
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168943
  00029	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 1347 :     HDL_REGISTER( replace_opcode,                *hdl_real_repopcode );

  0002d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR hdl_real_repopcode
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168944
  0003b	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 1348 : 
; 1349 :     HDL_REGISTER( daemon_task,                   *UNRESOLVED );

  0003f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR UNRESOLVED
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168945
  0004d	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 1350 :     HDL_REGISTER( system_command,                *UNRESOLVED );

  00051	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR UNRESOLVED
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168946
  0005f	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 1351 :     HDL_REGISTER( hdl_devequ,                    *UNRESOLVED );

  00063	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR UNRESOLVED
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168947
  00071	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 1352 : 
; 1353 :     HDL_REGISTER( debug_cpu_state,               *UNRESOLVED );

  00075	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR UNRESOLVED
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168948
  00083	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 1354 :     HDL_REGISTER( debug_cd_cmd,                  *UNRESOLVED );

  00087	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR UNRESOLVED
  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168949
  00095	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 1355 :     HDL_REGISTER( debug_program_interrupt,       *UNRESOLVED );

  00099	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR UNRESOLVED
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168950
  000a7	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 1356 :     HDL_REGISTER( debug_diagnose,                *UNRESOLVED );

  000ab	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR UNRESOLVED
  000b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168951
  000b9	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 1357 :     HDL_REGISTER( debug_sclp_unknown_command,    *UNRESOLVED );

  000bd	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR UNRESOLVED
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168952
  000cb	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 1358 :     HDL_REGISTER( debug_sclp_unknown_event,      *UNRESOLVED );

  000cf	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR UNRESOLVED
  000d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168953
  000dd	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 1359 :     HDL_REGISTER( debug_sclp_unknown_event_mask, *UNRESOLVED );

  000e1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR UNRESOLVED
  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168954
  000ef	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 1360 :     HDL_REGISTER( debug_sclp_event_data,         *UNRESOLVED );

  000f3	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR UNRESOLVED
  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168955
  00101	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 1361 :     HDL_REGISTER( debug_chsc_unknown_request,    *UNRESOLVED );

  00105	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR UNRESOLVED
  0010c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168956
  00113	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 1362 :     HDL_REGISTER( debug_watchdog_signal,         *UNRESOLVED );

  00117	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR UNRESOLVED
  0011e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168957
  00125	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 1363 : 
; 1364 : #if defined( OPTION_W32_CTCI )
; 1365 :     HDL_REGISTER( debug_tt32_stats,              *UNRESOLVED );

  00129	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR UNRESOLVED
  00130	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168958
  00137	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 1366 :     HDL_REGISTER( debug_tt32_tracing,            *UNRESOLVED );

  0013b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR UNRESOLVED
  00142	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168959
  00149	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 1367 : #endif
; 1368 : }

  0014d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00151	c3		 ret	 0
hdl_register_symbols_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
depchk_rc$ = 32
depchk$ = 64
hdl_check_depends_ep PROC

; 1327 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1328 :     int depchk_rc = 0;

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 0
$LN4@hdl_check_:

; 1329 : 
; 1330 :     HDL_DEPENDENCY( WEBBLK   );

  00011	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168905
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168906
  00025	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  00029	85 c0		 test	 eax, eax
  0002b	74 08		 je	 SHORT $LN17@hdl_check_
  0002d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN17@hdl_check_:
  00035	33 c0		 xor	 eax, eax
  00037	85 c0		 test	 eax, eax
  00039	75 d6		 jne	 SHORT $LN4@hdl_check_
$LN7@hdl_check_:

; 1331 :     HDL_DEPENDENCY( DEVBLK   );

  0003b	41 b8 a0 1b 00
	00		 mov	 r8d, 7072		; 00001ba0H
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168908
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168909
  0004f	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  00053	85 c0		 test	 eax, eax
  00055	74 08		 je	 SHORT $LN18@hdl_check_
  00057	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN18@hdl_check_:
  0005f	33 c0		 xor	 eax, eax
  00061	85 c0		 test	 eax, eax
  00063	75 d6		 jne	 SHORT $LN7@hdl_check_
$LN10@hdl_check_:

; 1332 :     HDL_DEPENDENCY( REGS     );

  00065	41 b8 80 60 01
	00		 mov	 r8d, 90240		; 00016080H
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168911
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168912
  00079	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  0007d	85 c0		 test	 eax, eax
  0007f	74 08		 je	 SHORT $LN19@hdl_check_
  00081	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN19@hdl_check_:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d6		 jne	 SHORT $LN10@hdl_check_
$LN13@hdl_check_:

; 1333 :     HDL_DEPENDENCY( SYSBLK   );

  0008f	41 b8 00 76 01
	00		 mov	 r8d, 95744		; 00017600H
  00095	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168914
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168915
  000a3	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  000a7	85 c0		 test	 eax, eax
  000a9	74 08		 je	 SHORT $LN20@hdl_check_
  000ab	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN20@hdl_check_:
  000b3	33 c0		 xor	 eax, eax
  000b5	85 c0		 test	 eax, eax
  000b7	75 d6		 jne	 SHORT $LN13@hdl_check_
$LN16@hdl_check_:

; 1334 :     HDL_DEPENDENCY( HERCULES );

  000b9	41 b8 08 00 00
	00		 mov	 r8d, 8
  000bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168917
  000c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168918
  000cd	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  000d1	85 c0		 test	 eax, eax
  000d3	74 08		 je	 SHORT $LN21@hdl_check_
  000d5	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN21@hdl_check_:
  000dd	33 c0		 xor	 eax, eax
  000df	85 c0		 test	 eax, eax
  000e1	75 d6		 jne	 SHORT $LN16@hdl_check_

; 1335 : 
; 1336 :     return depchk_rc;

  000e3	8b 44 24 20	 mov	 eax, DWORD PTR depchk_rc$[rsp]

; 1337 : }

  000e7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000eb	c3		 ret	 0
hdl_check_depends_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
cpu$ = 0
are_any_cpus_started_intlock_held PROC

; 501  : {

  00000	48 83 ec 18	 sub	 rsp, 24

; 502  :     int cpu;
; 503  : 
; 504  :     if (sysblk.cpus)

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	83 b8 04 01 00
	00 00		 cmp	 DWORD PTR [rax+260], 0
  00012	74 5b		 je	 SHORT $LN5@are_any_cp

; 505  :         for (cpu = 0; cpu < sysblk.hicpu; cpu++)

  00014	c7 04 24 00 00
	00 00		 mov	 DWORD PTR cpu$[rsp], 0
  0001b	eb 08		 jmp	 SHORT $LN4@are_any_cp
$LN2@are_any_cp:
  0001d	8b 04 24	 mov	 eax, DWORD PTR cpu$[rsp]
  00020	ff c0		 inc	 eax
  00022	89 04 24	 mov	 DWORD PTR cpu$[rsp], eax
$LN4@are_any_cp:
  00025	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002c	8b 80 08 01 00
	00		 mov	 eax, DWORD PTR [rax+264]
  00032	39 04 24	 cmp	 DWORD PTR cpu$[rsp], eax
  00035	7d 38		 jge	 SHORT $LN3@are_any_cp

; 506  :             if (IS_CPU_ONLINE( cpu ))

  00037	48 63 04 24	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0003b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00042	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0004b	74 20		 je	 SHORT $LN6@are_any_cp

; 507  :                 if (sysblk.regs[ cpu ]->cpustate == CPUSTATE_STARTED)

  0004d	48 63 04 24	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00051	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00058	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00060	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  00064	83 f8 01	 cmp	 eax, 1
  00067	75 04		 jne	 SHORT $LN7@are_any_cp

; 508  :                     return true;

  00069	b0 01		 mov	 al, 1
  0006b	eb 04		 jmp	 SHORT $LN1@are_any_cp
$LN7@are_any_cp:
$LN6@are_any_cp:
  0006d	eb ae		 jmp	 SHORT $LN2@are_any_cp
$LN3@are_any_cp:
$LN5@are_any_cp:

; 509  :     return false;

  0006f	32 c0		 xor	 al, al
$LN1@are_any_cp:

; 510  : }

  00071	48 83 c4 18	 add	 rsp, 24
  00075	c3		 ret	 0
are_any_cpus_started_intlock_held ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Release_Interrupt_Lock PROC

; 403  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@Release_In:

; 404  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@Release_In

; 405  :     sysblk.intowner = LOCK_OWNER_NONE;

  00014	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00020	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 406  :     hthread_release_lock( &sysblk.intlock, location );

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00034	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 hthread_release_lock

; 407  : }

  00041	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00045	c3		 ret	 0
Release_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Obtain_Interrupt_Lock PROC

; 379  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 380  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	74 13		 je	 SHORT $LN2@Obtain_Int

; 381  :         HOSTREGS->intwait = true;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00022	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN2@Obtain_Int:

; 382  :     hthread_obtain_lock( &sysblk.intlock, location );

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00036	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	e8 00 00 00 00	 call	 hthread_obtain_lock

; 383  :     Interrupt_Lock_Obtained( regs, location );

  00043	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00048	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0004d	e8 00 00 00 00	 call	 Interrupt_Lock_Obtained

; 384  : }

  00052	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00056	c3		 ret	 0
Obtain_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Interrupt_Lock_Obtained PROC

; 347  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 348  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	0f 84 d9 00 00
	00		 je	 $LN4@Interrupt_
$LN2@Interrupt_:

; 349  :     {
; 350  :         /* Wait for any SYNCHRONIZE_CPUS to finish before proceeding */
; 351  :         while (sysblk.syncing)

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8d 00 00
	00		 je	 $LN3@Interrupt_

; 352  :         {
; 353  :             /* Indicate we have reached the sync point */
; 354  :             sysblk.sync_mask &= ~HOSTREGS->cpubit;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00035	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 f7 d0	 not	 rax
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004a	48 8b 89 80 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4992]
  00051	48 23 c8	 and	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 89 81 80 13
	00 00		 mov	 QWORD PTR [rcx+4992], rax

; 355  : 
; 356  :             /* If we're the last CPU to reach this sync point,
; 357  :                signal the CPU that requested the sync that it
; 358  :                may now safely proceed with its exclusive logic.
; 359  :             */
; 360  :             if (!sysblk.sync_mask)

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 83 b8 80 13
	00 00 00	 cmp	 QWORD PTR [rax+4992], 0
  00074	75 1a		 jne	 SHORT $LN6@Interrupt_

; 361  :                 hthread_signal_condition( &sysblk.all_synced_cond, location );

  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00083	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	e8 00 00 00 00	 call	 hthread_signal_condition
$LN6@Interrupt_:

; 362  : 
; 363  :             /* Wait for CPU that requested the sync to indicate
; 364  :                it's done and thus is now safe for us to proceed.
; 365  :             */
; 366  :             hthread_wait_condition( &sysblk.sync_done_cond, &sysblk.intlock, location );

  00090	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00097	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  0009d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a4	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  000ab	4c 8b 44 24 38	 mov	 r8, QWORD PTR location$[rsp]
  000b0	48 8b d0	 mov	 rdx, rax
  000b3	e8 00 00 00 00	 call	 hthread_wait_condition

; 367  :         }

  000b8	e9 5d ff ff ff	 jmp	 $LN2@Interrupt_
$LN3@Interrupt_:

; 368  : 
; 369  :         HOSTREGS->intwait = false;

  000bd	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000c9	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0

; 370  :         sysblk.intowner = HOSTREGS->cpuad;

  000d0	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000dc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e3	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ea	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 371  :     }

  000f1	eb 13		 jmp	 SHORT $LN5@Interrupt_
$LN4@Interrupt_:

; 372  :     else
; 373  :         sysblk.intowner = LOCK_OWNER_OTHER;

  000f3	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000f8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000ff	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN5@Interrupt_:

; 374  : }

  00106	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010a	c3		 ret	 0
Interrupt_Lock_Obtained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
opcode2$ = 64
opcode1$ = 68
ins2$1 = 72
previous$2 = 80
mod$3 = 88
current$ = 96
replace$ = 128
ins$ = 136
hdl_repins PROC

; 1651 : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00009	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1652 :     void* current;
; 1653 : 
; 1654 :     int  opcode1  = ins->opcode >> 8;

  0000d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ins$[rsp]
  00015	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00018	c1 f8 08	 sar	 eax, 8
  0001b	89 44 24 44	 mov	 DWORD PTR opcode1$[rsp], eax

; 1655 :     int  opcode2  = ins->opcode & 0x00ff;

  0001f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ins$[rsp]
  00027	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0002a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0002f	89 44 24 40	 mov	 DWORD PTR opcode2$[rsp], eax

; 1656 : 
; 1657 :     /* Replace == install override? */
; 1658 : 
; 1659 :     if (replace)

  00033	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR replace$[rsp]
  0003b	85 c0		 test	 eax, eax
  0003d	0f 84 36 01 00
	00		 je	 $LN8@hdl_repins

; 1660 :     {
; 1661 :         ins->previous = NULL;

  00043	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ins$[rsp]
  0004b	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 1662 : #ifdef                                          _370
; 1663 :         if (ins->hdl_arch    ==     HDL_INSTARCH_370)

  00053	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ins$[rsp]
  0005b	81 78 1c 00 00
	00 80		 cmp	 DWORD PTR [rax+28], -2147483648 ; 80000000H
  00062	75 2d		 jne	 SHORT $LN9@hdl_repins

; 1664 :             ins->previous = replace_opcode( ARCH_370_IDX, ins->instfunc, opcode1, opcode2 );

  00064	44 8b 4c 24 40	 mov	 r9d, DWORD PTR opcode2$[rsp]
  00069	44 8b 44 24 44	 mov	 r8d, DWORD PTR opcode1$[rsp]
  0006e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ins$[rsp]
  00076	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0007a	33 c9		 xor	 ecx, ecx
  0007c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_replace_opcode
  00083	ff 10		 call	 QWORD PTR [rax]
  00085	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ins$[rsp]
  0008d	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
$LN9@hdl_repins:

; 1665 : #endif
; 1666 : #ifdef                                          _390
; 1667 :         if (ins->hdl_arch    ==     HDL_INSTARCH_390)

  00091	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ins$[rsp]
  00099	81 78 1c 00 00
	00 40		 cmp	 DWORD PTR [rax+28], 1073741824 ; 40000000H
  000a0	75 30		 jne	 SHORT $LN10@hdl_repins

; 1668 :             ins->previous = replace_opcode( ARCH_390_IDX, ins->instfunc, opcode1, opcode2 );

  000a2	44 8b 4c 24 40	 mov	 r9d, DWORD PTR opcode2$[rsp]
  000a7	44 8b 44 24 44	 mov	 r8d, DWORD PTR opcode1$[rsp]
  000ac	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ins$[rsp]
  000b4	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000b8	b9 01 00 00 00	 mov	 ecx, 1
  000bd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_replace_opcode
  000c4	ff 10		 call	 QWORD PTR [rax]
  000c6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ins$[rsp]
  000ce	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
$LN10@hdl_repins:

; 1669 : #endif
; 1670 : #ifdef                                          _900
; 1671 :         if (ins->hdl_arch    ==     HDL_INSTARCH_900)

  000d2	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ins$[rsp]
  000da	81 78 1c 00 00
	00 20		 cmp	 DWORD PTR [rax+28], 536870912 ; 20000000H
  000e1	75 30		 jne	 SHORT $LN11@hdl_repins

; 1672 :             ins->previous = replace_opcode( ARCH_900_IDX, ins->instfunc, opcode1, opcode2 );

  000e3	44 8b 4c 24 40	 mov	 r9d, DWORD PTR opcode2$[rsp]
  000e8	44 8b 44 24 44	 mov	 r8d, DWORD PTR opcode1$[rsp]
  000ed	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ins$[rsp]
  000f5	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000f9	b9 02 00 00 00	 mov	 ecx, 2
  000fe	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_replace_opcode
  00105	ff 10		 call	 QWORD PTR [rax]
  00107	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ins$[rsp]
  0010f	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
$LN11@hdl_repins:

; 1673 : #endif
; 1674 :         if (!ins->previous)

  00113	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ins$[rsp]
  0011b	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00120	75 52		 jne	 SHORT $LN12@hdl_repins

; 1675 :         {
; 1676 :             // "HDL: Invalid architecture passed to %s"
; 1677 :             WRMSG( HHC01503, "E", "hdl_repins" );

  00122	b9 01 00 00 00	 mov	 ecx, 1
  00127	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0012d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169135
  00134	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00139	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169136
  00140	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00145	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169137
  0014c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00151	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00156	41 b9 03 00 00
	00		 mov	 r9d, 3
  0015c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169138
  00163	ba 8d 06 00 00	 mov	 edx, 1677		; 0000068dH
  00168	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169139
  0016f	e8 00 00 00 00	 call	 fwritemsg
$LN12@hdl_repins:

; 1678 :         }
; 1679 :         return;   // (it either worked or it didn't)

  00174	e9 fc 01 00 00	 jmp	 $LN1@hdl_repins
$LN8@hdl_repins:

; 1680 :     }
; 1681 : 
; 1682 :     /* NOT replace == restore previous... */
; 1683 : 
; 1684 :     /* Is the opcode table still pointing to OUR override?
; 1685 :        Or is it pointing to some other module's override?
; 1686 :     */
; 1687 :     current = curr_opcode_ptr( ins->hdl_arch, ins->opcode );

  00179	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ins$[rsp]
  00181	8b 50 18	 mov	 edx, DWORD PTR [rax+24]
  00184	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ins$[rsp]
  0018c	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  0018f	e8 00 00 00 00	 call	 curr_opcode_ptr
  00194	48 89 44 24 60	 mov	 QWORD PTR current$[rsp], rax

; 1688 : 
; 1689 :     if (current == ins->instfunc)

  00199	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ins$[rsp]
  001a1	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001a5	48 39 44 24 60	 cmp	 QWORD PTR current$[rsp], rax
  001aa	0f 85 13 01 00
	00		 jne	 $LN13@hdl_repins

; 1690 :     {
; 1691 :         void* previous = NULL;

  001b0	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR previous$2[rsp], 0

; 1692 : 
; 1693 :         /* We still "own" this instruction override.  Uninstall
; 1694 :            our override by updating the opcode table pointer to
; 1695 :            point to the function it was pointing to before.
; 1696 :         */
; 1697 : #ifdef                                     _370
; 1698 :         if (ins->hdl_arch  ==  HDL_INSTARCH_370)

  001b9	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ins$[rsp]
  001c1	81 78 1c 00 00
	00 80		 cmp	 DWORD PTR [rax+28], -2147483648 ; 80000000H
  001c8	75 26		 jne	 SHORT $LN15@hdl_repins

; 1699 :             previous = replace_opcode( ARCH_370_IDX, ins->previous, opcode1, opcode2 );

  001ca	44 8b 4c 24 40	 mov	 r9d, DWORD PTR opcode2$[rsp]
  001cf	44 8b 44 24 44	 mov	 r8d, DWORD PTR opcode1$[rsp]
  001d4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ins$[rsp]
  001dc	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  001e0	33 c9		 xor	 ecx, ecx
  001e2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_replace_opcode
  001e9	ff 10		 call	 QWORD PTR [rax]
  001eb	48 89 44 24 50	 mov	 QWORD PTR previous$2[rsp], rax
$LN15@hdl_repins:

; 1700 : #endif
; 1701 : #ifdef                                     _390
; 1702 :         if (ins->hdl_arch  ==  HDL_INSTARCH_390)

  001f0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ins$[rsp]
  001f8	81 78 1c 00 00
	00 40		 cmp	 DWORD PTR [rax+28], 1073741824 ; 40000000H
  001ff	75 29		 jne	 SHORT $LN16@hdl_repins

; 1703 :             previous = replace_opcode( ARCH_390_IDX, ins->previous, opcode1, opcode2 );

  00201	44 8b 4c 24 40	 mov	 r9d, DWORD PTR opcode2$[rsp]
  00206	44 8b 44 24 44	 mov	 r8d, DWORD PTR opcode1$[rsp]
  0020b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ins$[rsp]
  00213	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00217	b9 01 00 00 00	 mov	 ecx, 1
  0021c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_replace_opcode
  00223	ff 10		 call	 QWORD PTR [rax]
  00225	48 89 44 24 50	 mov	 QWORD PTR previous$2[rsp], rax
$LN16@hdl_repins:

; 1704 : #endif
; 1705 : #ifdef                                     _900
; 1706 :         if (ins->hdl_arch  ==  HDL_INSTARCH_900)

  0022a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ins$[rsp]
  00232	81 78 1c 00 00
	00 20		 cmp	 DWORD PTR [rax+28], 536870912 ; 20000000H
  00239	75 29		 jne	 SHORT $LN17@hdl_repins

; 1707 :             previous = replace_opcode( ARCH_900_IDX, ins->previous, opcode1, opcode2 );

  0023b	44 8b 4c 24 40	 mov	 r9d, DWORD PTR opcode2$[rsp]
  00240	44 8b 44 24 44	 mov	 r8d, DWORD PTR opcode1$[rsp]
  00245	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ins$[rsp]
  0024d	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00251	b9 02 00 00 00	 mov	 ecx, 2
  00256	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_replace_opcode
  0025d	ff 10		 call	 QWORD PTR [rax]
  0025f	48 89 44 24 50	 mov	 QWORD PTR previous$2[rsp], rax
$LN17@hdl_repins:

; 1708 : #endif
; 1709 :         if (!previous)

  00264	48 83 7c 24 50
	00		 cmp	 QWORD PTR previous$2[rsp], 0
  0026a	75 52		 jne	 SHORT $LN18@hdl_repins

; 1710 :         {
; 1711 :             // "HDL: Invalid architecture passed to %s"
; 1712 :             WRMSG( HHC01503, "E", "hdl_repins" );

  0026c	b9 01 00 00 00	 mov	 ecx, 1
  00271	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00277	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169146
  0027e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00283	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169147
  0028a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0028f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169148
  00296	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0029b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002a0	41 b9 03 00 00
	00		 mov	 r9d, 3
  002a6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169149
  002ad	ba b0 06 00 00	 mov	 edx, 1712		; 000006b0H
  002b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169150
  002b9	e8 00 00 00 00	 call	 fwritemsg
$LN18@hdl_repins:

; 1713 :         }
; 1714 :     }

  002be	e9 b2 00 00 00	 jmp	 $LN14@hdl_repins
$LN13@hdl_repins:

; 1715 :     else /* (we don't "own" the override, some other module does) */
; 1716 :     {
; 1717 :         /*
; 1718 :         **  Some other module has overridden our override.  We need
; 1719 :         **  to FIX their "previous" instr function pointer to point
; 1720 :         **  to OUR "previous" instr function pointer instead.
; 1721 :         **
; 1722 :         **  Procedure: For each module that has overrides defined,
; 1723 :         **  chase their overrides to find one whose previous pointer
; 1724 :         **  matches our override (which is going away), and replace
; 1725 :         **  it instead with OUR previous value instead.
; 1726 :         **
; 1727 :         **  Doing this thereby fixes the "current/previous chain" by
; 1728 :         **  re-chaining the current override to our previous override
; 1729 :         **  thereby effectively removing ourselves from the middle of
; 1730 :         **  the current/previous chain.
; 1731 :         */
; 1732 :         HDLMOD*  mod;
; 1733 :         HDLINS*  ins2;
; 1734 : 
; 1735 :         for (mod = hdl_mods; mod; mod = mod->next)

  002c3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_mods
  002ca	48 89 44 24 58	 mov	 QWORD PTR mod$3[rsp], rax
  002cf	eb 0e		 jmp	 SHORT $LN4@hdl_repins
$LN2@hdl_repins:
  002d1	48 8b 44 24 58	 mov	 rax, QWORD PTR mod$3[rsp]
  002d6	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  002da	48 89 44 24 58	 mov	 QWORD PTR mod$3[rsp], rax
$LN4@hdl_repins:
  002df	48 83 7c 24 58
	00		 cmp	 QWORD PTR mod$3[rsp], 0
  002e5	0f 84 8a 00 00
	00		 je	 $LN3@hdl_repins

; 1736 :         {
; 1737 :             for (ins2 = mod->instructs; ins2; ins2 = ins2->next)

  002eb	48 8b 44 24 58	 mov	 rax, QWORD PTR mod$3[rsp]
  002f0	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002f4	48 89 44 24 48	 mov	 QWORD PTR ins2$1[rsp], rax
  002f9	eb 0e		 jmp	 SHORT $LN7@hdl_repins
$LN5@hdl_repins:
  002fb	48 8b 44 24 48	 mov	 rax, QWORD PTR ins2$1[rsp]
  00300	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00304	48 89 44 24 48	 mov	 QWORD PTR ins2$1[rsp], rax
$LN7@hdl_repins:
  00309	48 83 7c 24 48
	00		 cmp	 QWORD PTR ins2$1[rsp], 0
  0030f	74 5f		 je	 SHORT $LN6@hdl_repins

; 1738 :             {
; 1739 :                 if (1
; 1740 :                     && ins2->opcode   == ins->opcode
; 1741 :                     && ins2->hdl_arch == ins->hdl_arch
; 1742 :                     && ins2->previous == ins->instfunc

  00311	33 c0		 xor	 eax, eax
  00313	83 f8 01	 cmp	 eax, 1
  00316	74 56		 je	 SHORT $LN19@hdl_repins
  00318	48 8b 44 24 48	 mov	 rax, QWORD PTR ins2$1[rsp]
  0031d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ins$[rsp]
  00325	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  00328	39 48 18	 cmp	 DWORD PTR [rax+24], ecx
  0032b	75 41		 jne	 SHORT $LN19@hdl_repins
  0032d	48 8b 44 24 48	 mov	 rax, QWORD PTR ins2$1[rsp]
  00332	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ins$[rsp]
  0033a	8b 49 1c	 mov	 ecx, DWORD PTR [rcx+28]
  0033d	39 48 1c	 cmp	 DWORD PTR [rax+28], ecx
  00340	75 2c		 jne	 SHORT $LN19@hdl_repins
  00342	48 8b 44 24 48	 mov	 rax, QWORD PTR ins2$1[rsp]
  00347	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ins$[rsp]
  0034f	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00353	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  00357	75 15		 jne	 SHORT $LN19@hdl_repins

; 1743 :                 )
; 1744 :                 {
; 1745 :                     ins2->previous = ins->previous;

  00359	48 8b 44 24 48	 mov	 rax, QWORD PTR ins2$1[rsp]
  0035e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ins$[rsp]
  00366	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0036a	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
$LN19@hdl_repins:

; 1746 :                 }
; 1747 :             }

  0036e	eb 8b		 jmp	 SHORT $LN5@hdl_repins
$LN6@hdl_repins:

; 1748 :         }

  00370	e9 5c ff ff ff	 jmp	 $LN2@hdl_repins
$LN3@hdl_repins:
$LN14@hdl_repins:
$LN1@hdl_repins:

; 1749 :     }
; 1750 : }

  00375	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00379	c3		 ret	 0
hdl_repins ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
sym$ = 32
mod$ = 40
name$ = 48
symbol$ = 80
hdl_next PROC

; 1245 : {

$LN21:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1246 :     /* Called by various loadable modules to find the next handler */
; 1247 : 
; 1248 :     HDLMOD*      mod;
; 1249 :     HDLSYM*      sym  = NULL;

  00009	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR sym$[rsp], 0

; 1250 :     const char*  name;
; 1251 : 
; 1252 :     /* Find the module that defined the specified symbol.
; 1253 :        (i.e. the first module in our LIFO chain (being the
; 1254 :        most recently loaded module) with a defined symbol
; 1255 :        whose address is identical to the one passed to us).
; 1256 :     */
; 1257 :     for (mod = hdl_mods; mod; mod = mod->next)

  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_mods
  00019	48 89 44 24 28	 mov	 QWORD PTR mod$[rsp], rax
  0001e	eb 0e		 jmp	 SHORT $LN4@hdl_next
$LN2@hdl_next:
  00020	48 8b 44 24 28	 mov	 rax, QWORD PTR mod$[rsp]
  00025	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00029	48 89 44 24 28	 mov	 QWORD PTR mod$[rsp], rax
$LN4@hdl_next:
  0002e	48 83 7c 24 28
	00		 cmp	 QWORD PTR mod$[rsp], 0
  00034	74 46		 je	 SHORT $LN3@hdl_next

; 1258 :     {
; 1259 :         for (sym = mod->symbols; sym; sym = sym->next)

  00036	48 8b 44 24 28	 mov	 rax, QWORD PTR mod$[rsp]
  0003b	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  0003f	48 89 44 24 20	 mov	 QWORD PTR sym$[rsp], rax
  00044	eb 0e		 jmp	 SHORT $LN7@hdl_next
$LN5@hdl_next:
  00046	48 8b 44 24 20	 mov	 rax, QWORD PTR sym$[rsp]
  0004b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0004f	48 89 44 24 20	 mov	 QWORD PTR sym$[rsp], rax
$LN7@hdl_next:
  00054	48 83 7c 24 20
	00		 cmp	 QWORD PTR sym$[rsp], 0
  0005a	74 14		 je	 SHORT $LN6@hdl_next

; 1260 :         {
; 1261 :             /* Compare symbol addresses: a match means this
; 1262 :                module was the one that defined this symbol.
; 1263 :             */
; 1264 :             if (sym->symbol == symbol)

  0005c	48 8b 44 24 20	 mov	 rax, QWORD PTR sym$[rsp]
  00061	48 8b 4c 24 50	 mov	 rcx, QWORD PTR symbol$[rsp]
  00066	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  0006a	75 02		 jne	 SHORT $LN14@hdl_next

; 1265 :                 break;

  0006c	eb 02		 jmp	 SHORT $LN6@hdl_next
$LN14@hdl_next:

; 1266 :         }

  0006e	eb d6		 jmp	 SHORT $LN5@hdl_next
$LN6@hdl_next:

; 1267 : 
; 1268 :         /* Stop searching as soon as we find our symbol */
; 1269 :         if (sym)

  00070	48 83 7c 24 20
	00		 cmp	 QWORD PTR sym$[rsp], 0
  00076	74 02		 je	 SHORT $LN15@hdl_next

; 1270 :             break;

  00078	eb 02		 jmp	 SHORT $LN3@hdl_next
$LN15@hdl_next:

; 1271 :     }

  0007a	eb a4		 jmp	 SHORT $LN2@hdl_next
$LN3@hdl_next:

; 1272 : 
; 1273 :     /* Did we find our symbol? */
; 1274 :     if (sym)

  0007c	48 83 7c 24 20
	00		 cmp	 QWORD PTR sym$[rsp], 0
  00082	0f 84 ae 00 00
	00		 je	 $LN16@hdl_next

; 1275 :     {
; 1276 :         /* Save the name of the symbol we're now looking for */
; 1277 :         name = sym->name;

  00088	48 8b 44 24 20	 mov	 rax, QWORD PTR sym$[rsp]
  0008d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00090	48 89 44 24 30	 mov	 QWORD PTR name$[rsp], rax

; 1278 : 
; 1279 :         /* Does this module have a "next" link for this symbol?
; 1280 :            If so, then that's where we'll start our search for
; 1281 :            the next symbol registration. Otherwise we'll start
; 1282 :            our search with the NEXT module's symbols chain.
; 1283 :         */
; 1284 :         if (!(sym = sym->next))

  00095	48 8b 44 24 20	 mov	 rax, QWORD PTR sym$[rsp]
  0009a	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0009e	48 89 44 24 20	 mov	 QWORD PTR sym$[rsp], rax
  000a3	48 83 7c 24 20
	00		 cmp	 QWORD PTR sym$[rsp], 0
  000a9	75 28		 jne	 SHORT $LN17@hdl_next

; 1285 :         {
; 1286 :             /* No next symbol. Try the NEXT module's symbols */
; 1287 :             if (!(mod = mod->next))

  000ab	48 8b 44 24 28	 mov	 rax, QWORD PTR mod$[rsp]
  000b0	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000b4	48 89 44 24 28	 mov	 QWORD PTR mod$[rsp], rax
  000b9	48 83 7c 24 28
	00		 cmp	 QWORD PTR mod$[rsp], 0
  000bf	75 04		 jne	 SHORT $LN18@hdl_next

; 1288 :                 return NULL;        // (no "next" for symbol)

  000c1	33 c0		 xor	 eax, eax
  000c3	eb 73		 jmp	 SHORT $LN1@hdl_next
$LN18@hdl_next:

; 1289 : 
; 1290 :             sym = mod->symbols;     // (start searching here)

  000c5	48 8b 44 24 28	 mov	 rax, QWORD PTR mod$[rsp]
  000ca	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  000ce	48 89 44 24 20	 mov	 QWORD PTR sym$[rsp], rax
$LN17@hdl_next:

; 1291 :         }
; 1292 : 
; 1293 :         /* Find the "next entry" for our symbol by searching this
; 1294 :            module's (and all remaining modules') symbols for the
; 1295 :            first symbol that we find with the same name as ours.
; 1296 :         */
; 1297 :         for (; mod; mod = mod->next, sym = mod->symbols)

  000d3	eb 1c		 jmp	 SHORT $LN10@hdl_next
$LN8@hdl_next:
  000d5	48 8b 44 24 28	 mov	 rax, QWORD PTR mod$[rsp]
  000da	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000de	48 89 44 24 28	 mov	 QWORD PTR mod$[rsp], rax
  000e3	48 8b 44 24 28	 mov	 rax, QWORD PTR mod$[rsp]
  000e8	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  000ec	48 89 44 24 20	 mov	 QWORD PTR sym$[rsp], rax
$LN10@hdl_next:
  000f1	48 83 7c 24 28
	00		 cmp	 QWORD PTR mod$[rsp], 0
  000f7	74 3d		 je	 SHORT $LN9@hdl_next

; 1298 :         {
; 1299 :             for (; sym; sym = sym->next)

  000f9	eb 0e		 jmp	 SHORT $LN13@hdl_next
$LN11@hdl_next:
  000fb	48 8b 44 24 20	 mov	 rax, QWORD PTR sym$[rsp]
  00100	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00104	48 89 44 24 20	 mov	 QWORD PTR sym$[rsp], rax
$LN13@hdl_next:
  00109	48 83 7c 24 20
	00		 cmp	 QWORD PTR sym$[rsp], 0
  0010f	74 23		 je	 SHORT $LN12@hdl_next

; 1300 :             {
; 1301 :                 if (strcmp( sym->name, name ) == 0)

  00111	48 8b 54 24 30	 mov	 rdx, QWORD PTR name$[rsp]
  00116	48 8b 44 24 20	 mov	 rax, QWORD PTR sym$[rsp]
  0011b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0011e	e8 00 00 00 00	 call	 strcmp
  00123	85 c0		 test	 eax, eax
  00125	75 0b		 jne	 SHORT $LN19@hdl_next

; 1302 :                     return sym->symbol;

  00127	48 8b 44 24 20	 mov	 rax, QWORD PTR sym$[rsp]
  0012c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00130	eb 06		 jmp	 SHORT $LN1@hdl_next
$LN19@hdl_next:

; 1303 :             }

  00132	eb c7		 jmp	 SHORT $LN11@hdl_next
$LN12@hdl_next:

; 1304 :         }

  00134	eb 9f		 jmp	 SHORT $LN8@hdl_next
$LN9@hdl_next:
$LN16@hdl_next:

; 1305 :     }
; 1306 : 
; 1307 :     return NULL;

  00136	33 c0		 xor	 eax, eax
$LN1@hdl_next:

; 1308 : }

  00138	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0013c	c3		 ret	 0
hdl_next ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
sym$ = 32
tv68 = 40
symname$ = 64
hdl_getsym PROC

; 1232 : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1233 :     /* This function is mostly for the benefit of the httpserv.c's
; 1234 :        'http_request' function to locate any cgibin functions that
; 1235 :        may have been overridden/added by a hercules dynamic module.
; 1236 :     */
; 1237 :     HDLSYM* sym = get_HDLSYM( symname );

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR symname$[rsp]
  0000e	e8 00 00 00 00	 call	 get_HDLSYM
  00013	48 89 44 24 20	 mov	 QWORD PTR sym$[rsp], rax

; 1238 :     return sym ? sym->symbol : NULL;

  00018	48 83 7c 24 20
	00		 cmp	 QWORD PTR sym$[rsp], 0
  0001e	74 10		 je	 SHORT $LN3@hdl_getsym
  00020	48 8b 44 24 20	 mov	 rax, QWORD PTR sym$[rsp]
  00025	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00029	48 89 44 24 28	 mov	 QWORD PTR tv68[rsp], rax
  0002e	eb 09		 jmp	 SHORT $LN4@hdl_getsym
$LN3@hdl_getsym:
  00030	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tv68[rsp], 0
$LN4@hdl_getsym:
  00039	48 8b 44 24 28	 mov	 rax, QWORD PTR tv68[rsp]

; 1239 : }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
hdl_getsym ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
modname$ = 32
hnd$ = 40
equtyp$1 = 48
typname$ = 80
hdl_DEVHND PROC

; 1133 : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1134 :     /* Called by config.c "attach_device" */
; 1135 : 
; 1136 :     DEVHND*      hnd;
; 1137 :     const char*  modname;
; 1138 : 
; 1139 :     /* Get the device handler for requested device-type */
; 1140 :     if ((hnd = hdl_get_DEVHND( typname )))

  00009	48 8b 4c 24 50	 mov	 rcx, QWORD PTR typname$[rsp]
  0000e	e8 00 00 00 00	 call	 hdl_get_DEVHND
  00013	48 89 44 24 28	 mov	 QWORD PTR hnd$[rsp], rax
  00018	48 83 7c 24 28
	00		 cmp	 QWORD PTR hnd$[rsp], 0
  0001e	74 0a		 je	 SHORT $LN2@hdl_DEVHND

; 1141 :         return hnd;

  00020	48 8b 44 24 28	 mov	 rax, QWORD PTR hnd$[rsp]
  00025	e9 9f 00 00 00	 jmp	 $LN1@hdl_DEVHND
$LN2@hdl_DEVHND:

; 1142 : 
; 1143 :     /* We couldn't find a handler for the requested device-type.
; 1144 :        It might be that the module that handles this device-type
; 1145 :        has not been loaded yet. Try loading it using the passed
; 1146 :        device-type and then try getting the device handler again.
; 1147 :     */
; 1148 :     modname = hdl_build_devmod_name( typname );

  0002a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR typname$[rsp]
  0002f	e8 00 00 00 00	 call	 hdl_build_devmod_name
  00034	48 89 44 24 20	 mov	 QWORD PTR modname$[rsp], rax

; 1149 : 
; 1150 :     if (0
; 1151 :         || hdl_loadmod( modname, HDL_LOAD_NOMSG ) != 0
; 1152 :         || !(hnd = hdl_get_DEVHND( typname ))

  00039	33 c0		 xor	 eax, eax
  0003b	85 c0		 test	 eax, eax
  0003d	75 2a		 jne	 SHORT $LN4@hdl_DEVHND
  0003f	ba 00 00 00 10	 mov	 edx, 268435456		; 10000000H
  00044	48 8b 4c 24 20	 mov	 rcx, QWORD PTR modname$[rsp]
  00049	e8 00 00 00 00	 call	 hdl_loadmod
  0004e	85 c0		 test	 eax, eax
  00050	75 17		 jne	 SHORT $LN4@hdl_DEVHND
  00052	48 8b 4c 24 50	 mov	 rcx, QWORD PTR typname$[rsp]
  00057	e8 00 00 00 00	 call	 hdl_get_DEVHND
  0005c	48 89 44 24 28	 mov	 QWORD PTR hnd$[rsp], rax
  00061	48 83 7c 24 28
	00		 cmp	 QWORD PTR hnd$[rsp], 0
  00067	75 4b		 jne	 SHORT $LN3@hdl_DEVHND
$LN4@hdl_DEVHND:

; 1153 :     )
; 1154 :     {
; 1155 :         /* The handler module for the requested device-type
; 1156 :            might have a different module name than the one
; 1157 :            for the requested device-type (i.e. the requested
; 1158 :            device-type might be equated to a another device-
; 1159 :            type). If there exists a "device equates" module,
; 1160 :            try calling its equate function to retrieve the
; 1161 :            equated device-type name.
; 1162 :         */
; 1163 :         if (hdl_devequ)

  00069	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR hdl_devequ, 0
  00071	74 41		 je	 SHORT $LN5@hdl_DEVHND

; 1164 :         {
; 1165 :             const char* equtyp = hdl_devequ( typname );

  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR typname$[rsp]
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR hdl_devequ
  0007e	48 89 44 24 30	 mov	 QWORD PTR equtyp$1[rsp], rax

; 1166 : 
; 1167 :             if (equtyp)

  00083	48 83 7c 24 30
	00		 cmp	 QWORD PTR equtyp$1[rsp], 0
  00089	74 29		 je	 SHORT $LN6@hdl_DEVHND

; 1168 :             {
; 1169 :                 /* Try loading the device handler module
; 1170 :                    for the equated device-type.
; 1171 :                 */
; 1172 :                 free( modname );

  0008b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR modname$[rsp]
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1173 :                 modname = hdl_build_devmod_name( equtyp );

  00096	48 8b 4c 24 30	 mov	 rcx, QWORD PTR equtyp$1[rsp]
  0009b	e8 00 00 00 00	 call	 hdl_build_devmod_name
  000a0	48 89 44 24 20	 mov	 QWORD PTR modname$[rsp], rax

; 1174 :                 hdl_loadmod( modname, HDL_LOAD_NOMSG );

  000a5	ba 00 00 00 10	 mov	 edx, 268435456		; 10000000H
  000aa	48 8b 4c 24 20	 mov	 rcx, QWORD PTR modname$[rsp]
  000af	e8 00 00 00 00	 call	 hdl_loadmod
$LN6@hdl_DEVHND:
$LN5@hdl_DEVHND:
$LN3@hdl_DEVHND:

; 1175 : 
; 1176 :                 /* The module load of the device handler module
; 1177 :                    for the equated device-type either succeeded
; 1178 :                    or failed, but either way we don't care. If
; 1179 :                    it succeeded the "Last chance!" call further
; 1180 :                    below will succeed. Otherwise it will fail.
; 1181 :                 */
; 1182 :             }
; 1183 :         }
; 1184 :     }
; 1185 : 
; 1186 :     free( modname );

  000b4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR modname$[rsp]
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1187 : 
; 1188 :     /* Last chance! */
; 1189 :     return hdl_get_DEVHND( typname );

  000bf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR typname$[rsp]
  000c4	e8 00 00 00 00	 call	 hdl_get_DEVHND
$LN1@hdl_DEVHND:

; 1190 : }

  000c9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000cd	c3		 ret	 0
hdl_DEVHND ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
hdl_listequs PROC

; 1073 : {

$LN4:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1074 :     /* Called by hsccmd.c "lsequ_cmd" */
; 1075 : 
; 1076 :     if (!hdl_devequ)

  00004	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR hdl_devequ, 0
  0000c	75 4d		 jne	 SHORT $LN2@hdl_listeq

; 1077 :     {
; 1078 :         // "HDL: no devequ module has been loaded"
; 1079 :         WRMSG( HHC01543, "E" );

  0000e	b9 01 00 00 00	 mov	 ecx, 1
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168775
  00020	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168776
  0002c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00031	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00036	41 b9 03 00 00
	00		 mov	 r9d, 3
  0003c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168777
  00043	ba 37 04 00 00	 mov	 edx, 1079		; 00000437H
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168778
  0004f	e8 00 00 00 00	 call	 fwritemsg

; 1080 :         return -1;

  00054	b8 ff ff ff ff	 mov	 eax, -1
  00059	eb 0a		 jmp	 SHORT $LN1@hdl_listeq
$LN2@hdl_listeq:

; 1081 :     }
; 1082 : 
; 1083 :     /* List all device equates */
; 1084 :     hdl_devequ( NULL );

  0005b	33 c9		 xor	 ecx, ecx
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR hdl_devequ

; 1085 :     return 0;

  00063	33 c0		 xor	 eax, eax
$LN1@hdl_listeq:

; 1086 : }

  00065	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00069	c3		 ret	 0
hdl_listequs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
depent$ = 80
hdl_listdeps PROC

; 1059 : {

$LN6:
  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1060 :     /* Called by hsccmd.c "lsdep_cmd" */
; 1061 : 
; 1062 :     HDLDEP*  depent;
; 1063 : 
; 1064 :     for (depent = hdl_depend; depent; depent = depent->next)

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_depend
  0000b	48 89 44 24 50	 mov	 QWORD PTR depent$[rsp], rax
  00010	eb 0e		 jmp	 SHORT $LN4@hdl_listde
$LN2@hdl_listde:
  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR depent$[rsp]
  00017	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0001b	48 89 44 24 50	 mov	 QWORD PTR depent$[rsp], rax
$LN4@hdl_listde:
  00020	48 83 7c 24 50
	00		 cmp	 QWORD PTR depent$[rsp], 0
  00026	74 72		 je	 SHORT $LN3@hdl_listde

; 1065 :         // "HDL: dependency %s: version \"%s\", size %d"
; 1066 :         WRMSG( HHC01535, "I", depent->name, depent->version, depent->size );

  00028	b9 01 00 00 00	 mov	 ecx, 1
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00033	48 8b 4c 24 50	 mov	 rcx, QWORD PTR depent$[rsp]
  00038	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  0003b	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0003f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR depent$[rsp]
  00044	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00048	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0004d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR depent$[rsp]
  00052	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00055	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168768
  00061	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168769
  0006d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00072	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00077	41 b9 03 00 00
	00		 mov	 r9d, 3
  0007d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168770
  00084	ba 2a 04 00 00	 mov	 edx, 1066		; 0000042aH
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168771
  00090	e8 00 00 00 00	 call	 fwritemsg
  00095	e9 78 ff ff ff	 jmp	 $LN2@hdl_listde
$LN3@hdl_listde:

; 1067 : }

  0009a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0009e	c3		 ret	 0
hdl_listdeps ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
z900$1 = 96
s390$2 = 97
s370$3 = 98
len$4 = 100
mod$ = 104
sym$ = 112
ins$5 = 120
prev_ins$6 = 128
device$7 = 136
tv212 = 144
tv214 = 148
tv216 = 152
tv237 = 156
tv239 = 160
tv241 = 164
tv69 = 168
tv74 = 176
tv79 = 184
tv143 = 192
tv136 = 200
tv172 = 208
tv186 = 216
buf$ = 224
__$ArrayPad$ = 480
flags$ = 512
hdl_listmods PROC

; 951  : {

$LN34:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 81 ec f8 01
	00 00		 sub	 rsp, 504		; 000001f8H
  0000b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00012	48 33 c4	 xor	 rax, rsp
  00015	48 89 84 24 e0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 952  :     /* Called by hsccmd.c "lsmod_cmd" */
; 953  : 
; 954  :     HDLMOD*  mod;
; 955  :     HDLSYM*  sym;
; 956  :     char     buf[ 256 ];
; 957  : 
; 958  :     for (mod = hdl_mods; mod; mod = mod->next)

  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_mods
  00024	48 89 44 24 68	 mov	 QWORD PTR mod$[rsp], rax
  00029	eb 0e		 jmp	 SHORT $LN4@hdl_listmo
$LN2@hdl_listmo:
  0002b	48 8b 44 24 68	 mov	 rax, QWORD PTR mod$[rsp]
  00030	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00034	48 89 44 24 68	 mov	 QWORD PTR mod$[rsp], rax
$LN4@hdl_listmo:
  00039	48 83 7c 24 68
	00		 cmp	 QWORD PTR mod$[rsp], 0
  0003f	0f 84 f5 05 00
	00		 je	 $LN3@hdl_listmo

; 959  :     {
; 960  :         // "HDL: name = %s, type = %s, flags = (%sunloadable, %sforced)"
; 961  :         WRMSG( HHC01531, "I"

  00045	48 8b 44 24 68	 mov	 rax, QWORD PTR mod$[rsp]
  0004a	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0004d	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00052	85 c0		 test	 eax, eax
  00054	74 11		 je	 SHORT $LN26@hdl_listmo
  00056	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168717
  0005d	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv69[rsp], rax
  00065	eb 0f		 jmp	 SHORT $LN27@hdl_listmo
$LN26@hdl_listmo:
  00067	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168718
  0006e	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv69[rsp], rax
$LN27@hdl_listmo:
  00076	48 8b 44 24 68	 mov	 rax, QWORD PTR mod$[rsp]
  0007b	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0007e	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00083	85 c0		 test	 eax, eax
  00085	74 11		 je	 SHORT $LN28@hdl_listmo
  00087	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168719
  0008e	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv74[rsp], rax
  00096	eb 0f		 jmp	 SHORT $LN29@hdl_listmo
$LN28@hdl_listmo:
  00098	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168720
  0009f	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv74[rsp], rax
$LN29@hdl_listmo:
  000a7	48 8b 44 24 68	 mov	 rax, QWORD PTR mod$[rsp]
  000ac	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000af	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  000b4	85 c0		 test	 eax, eax
  000b6	74 11		 je	 SHORT $LN30@hdl_listmo
  000b8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168721
  000bf	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv79[rsp], rax
  000c7	eb 0f		 jmp	 SHORT $LN31@hdl_listmo
$LN30@hdl_listmo:
  000c9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168722
  000d0	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv79[rsp], rax
$LN31@hdl_listmo:
  000d8	b9 01 00 00 00	 mov	 ecx, 1
  000dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000e3	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv69[rsp]
  000eb	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000f0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv74[rsp]
  000f8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000fd	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv79[rsp]
  00105	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0010a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR mod$[rsp]
  0010f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00112	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00117	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168723
  0011e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00123	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168724
  0012a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0012f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00134	41 b9 03 00 00
	00		 mov	 r9d, 3
  0013a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168725
  00141	ba c6 03 00 00	 mov	 edx, 966		; 000003c6H
  00146	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168726
  0014d	e8 00 00 00 00	 call	 fwritemsg

; 962  :             ,  mod->name
; 963  :             , (mod->flags & HDL_LOAD_MAIN)       ?  "EXE"    :  "hdl"
; 964  :             , (mod->flags & HDL_LOAD_NOUNLOAD)   ?  "NOT "   :   ""
; 965  :             , (mod->flags & HDL_LOAD_WAS_FORCED) ?   ""      :  "not "
; 966  :         );
; 967  : 
; 968  :         for (sym = mod->symbols; sym; sym = sym->next)

  00152	48 8b 44 24 68	 mov	 rax, QWORD PTR mod$[rsp]
  00157	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  0015b	48 89 44 24 70	 mov	 QWORD PTR sym$[rsp], rax
  00160	eb 0e		 jmp	 SHORT $LN7@hdl_listmo
$LN5@hdl_listmo:
  00162	48 8b 44 24 70	 mov	 rax, QWORD PTR sym$[rsp]
  00167	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0016b	48 89 44 24 70	 mov	 QWORD PTR sym$[rsp], rax
$LN7@hdl_listmo:
  00170	48 83 7c 24 70
	00		 cmp	 QWORD PTR sym$[rsp], 0
  00176	0f 84 01 01 00
	00		 je	 $LN6@hdl_listmo

; 969  :         {
; 970  :             if (0
; 971  :                 || (flags & HDL_LIST_ALL)
; 972  :                 || !(1

  0017c	33 c0		 xor	 eax, eax
  0017e	85 c0		 test	 eax, eax
  00180	75 38		 jne	 SHORT $LN15@hdl_listmo
  00182	8b 84 24 00 02
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  00189	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0018e	85 c0		 test	 eax, eax
  00190	75 28		 jne	 SHORT $LN15@hdl_listmo
  00192	33 c0		 xor	 eax, eax
  00194	83 f8 01	 cmp	 eax, 1
  00197	74 21		 je	 SHORT $LN16@hdl_listmo
  00199	48 8b 44 24 68	 mov	 rax, QWORD PTR mod$[rsp]
  0019e	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  001a1	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001a6	85 c0		 test	 eax, eax
  001a8	74 10		 je	 SHORT $LN16@hdl_listmo
  001aa	48 8b 44 24 70	 mov	 rax, QWORD PTR sym$[rsp]
  001af	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  001b4	0f 84 be 00 00
	00		 je	 $LN14@hdl_listmo
$LN16@hdl_listmo:
$LN15@hdl_listmo:

; 973  :                      && (mod->flags & HDL_LOAD_MAIN)
; 974  :                      && !sym->symbol
; 975  :                     )
; 976  :             )
; 977  :             {
; 978  :                 // "HDL:  symbol = %s, loadcount = %d%s, owner = %s"
; 979  :                 WRMSG( HHC01532, "I"

  001ba	48 8b 44 24 70	 mov	 rax, QWORD PTR sym$[rsp]
  001bf	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  001c4	74 11		 je	 SHORT $LN32@hdl_listmo
  001c6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168730
  001cd	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv143[rsp], rax
  001d5	eb 0f		 jmp	 SHORT $LN33@hdl_listmo
$LN32@hdl_listmo:
  001d7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168731
  001de	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv143[rsp], rax
$LN33@hdl_listmo:
  001e6	48 8b 44 24 70	 mov	 rax, QWORD PTR sym$[rsp]
  001eb	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001ee	e8 00 00 00 00	 call	 get_HDLSYM
  001f3	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv136[rsp], rax
  001fb	b9 01 00 00 00	 mov	 ecx, 1
  00200	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00206	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv136[rsp]
  0020e	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00212	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00217	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv143[rsp]
  0021f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00224	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sym$[rsp]
  00229	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  0022c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00230	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sym$[rsp]
  00235	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00238	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0023d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168732
  00244	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00249	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168733
  00250	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00255	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0025a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00260	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168734
  00267	ba d7 03 00 00	 mov	 edx, 983		; 000003d7H
  0026c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168735
  00273	e8 00 00 00 00	 call	 fwritemsg
$LN14@hdl_listmo:

; 980  :                     , sym->name
; 981  :                     , sym->refcnt, sym->symbol ? "" : ", UNRESOLVED"
; 982  :                     , get_HDLSYM( sym->name )->owner
; 983  :                 );
; 984  :             }
; 985  :         }

  00278	e9 e5 fe ff ff	 jmp	 $LN5@hdl_listmo
$LN6@hdl_listmo:

; 986  : 
; 987  :         if (mod->devices)

  0027d	48 8b 44 24 68	 mov	 rax, QWORD PTR mod$[rsp]
  00282	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  00287	0f 84 71 01 00
	00		 je	 $LN17@hdl_listmo

; 988  :         {
; 989  :             HDLDEV*  device;
; 990  :             int      len = 0;

  0028d	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR len$4[rsp], 0

; 991  : 
; 992  :             for (device = mod->devices; device; device = device->next)

  00295	48 8b 44 24 68	 mov	 rax, QWORD PTR mod$[rsp]
  0029a	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  0029e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR device$7[rsp], rax
  002a6	eb 14		 jmp	 SHORT $LN10@hdl_listmo
$LN8@hdl_listmo:
  002a8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR device$7[rsp]
  002b0	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  002b4	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR device$7[rsp], rax
$LN10@hdl_listmo:
  002bc	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR device$7[rsp], 0
  002c5	0f 84 bd 00 00
	00		 je	 $LN9@hdl_listmo

; 993  :             {
; 994  :                 if ((len += idx_snprintf( len, buf, sizeof( buf ), ", %s", device->name )) >= 50)

  002cb	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR device$7[rsp]
  002d3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002d6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002db	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168738
  002e2	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  002e8	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  002f0	8b 4c 24 64	 mov	 ecx, DWORD PTR len$4[rsp]
  002f4	e8 00 00 00 00	 call	 idx_snprintf
  002f9	8b 4c 24 64	 mov	 ecx, DWORD PTR len$4[rsp]
  002fd	03 c8		 add	 ecx, eax
  002ff	8b c1		 mov	 eax, ecx
  00301	89 44 24 64	 mov	 DWORD PTR len$4[rsp], eax
  00305	83 7c 24 64 32	 cmp	 DWORD PTR len$4[rsp], 50 ; 00000032H
  0030a	7c 77		 jl	 SHORT $LN18@hdl_listmo

; 995  :                 {
; 996  :                     // "HDL:  devtypes = %s"
; 997  :                     WRMSG( HHC01533, "I", trim( buf, ", " ));

  0030c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168739
  00313	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0031b	e8 00 00 00 00	 call	 trim
  00320	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv172[rsp], rax
  00328	b9 01 00 00 00	 mov	 ecx, 1
  0032d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00333	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv172[rsp]
  0033b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00340	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168740
  00347	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0034c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168741
  00353	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00358	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0035d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00363	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168742
  0036a	ba e5 03 00 00	 mov	 edx, 997		; 000003e5H
  0036f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168743
  00376	e8 00 00 00 00	 call	 fwritemsg

; 998  :                     len = 0;

  0037b	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR len$4[rsp], 0
$LN18@hdl_listmo:

; 999  :                 }
; 1000 :             }

  00383	e9 20 ff ff ff	 jmp	 $LN8@hdl_listmo
$LN9@hdl_listmo:

; 1001 : 
; 1002 :             if (len)

  00388	83 7c 24 64 00	 cmp	 DWORD PTR len$4[rsp], 0
  0038d	74 6f		 je	 SHORT $LN19@hdl_listmo

; 1003 :             {
; 1004 :                 // "HDL:  devtypes = %s"
; 1005 :                 WRMSG( HHC01533, "I", trim( buf, ", " ));

  0038f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168745
  00396	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0039e	e8 00 00 00 00	 call	 trim
  003a3	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv186[rsp], rax
  003ab	b9 01 00 00 00	 mov	 ecx, 1
  003b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003b6	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv186[rsp]
  003be	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168746
  003ca	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168747
  003d6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003db	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003e0	41 b9 03 00 00
	00		 mov	 r9d, 3
  003e6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168748
  003ed	ba ed 03 00 00	 mov	 edx, 1005		; 000003edH
  003f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168749
  003f9	e8 00 00 00 00	 call	 fwritemsg
$LN19@hdl_listmo:
$LN17@hdl_listmo:

; 1006 :             }
; 1007 :         }
; 1008 : 
; 1009 :         if (mod->instructs)

  003fe	48 8b 44 24 68	 mov	 rax, QWORD PTR mod$[rsp]
  00403	48 83 78 58 00	 cmp	 QWORD PTR [rax+88], 0
  00408	0f 84 27 02 00
	00		 je	 $LN20@hdl_listmo

; 1010 :         {
; 1011 :             HDLINS*  ins;
; 1012 :             HDLINS*  prev_ins;
; 1013 :             char     s370, s390, z900;
; 1014 : 
; 1015 :             s370 = s390 = z900 = '.';

  0040e	c6 44 24 60 2e	 mov	 BYTE PTR z900$1[rsp], 46 ; 0000002eH
  00413	0f b6 44 24 60	 movzx	 eax, BYTE PTR z900$1[rsp]
  00418	88 44 24 61	 mov	 BYTE PTR s390$2[rsp], al
  0041c	0f b6 44 24 61	 movzx	 eax, BYTE PTR s390$2[rsp]
  00421	88 44 24 62	 mov	 BYTE PTR s370$3[rsp], al

; 1016 : 
; 1017 :             for (ins = prev_ins = mod->instructs; ins; ins = ins->next)

  00425	48 8b 44 24 68	 mov	 rax, QWORD PTR mod$[rsp]
  0042a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0042e	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR prev_ins$6[rsp], rax
  00436	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR prev_ins$6[rsp]
  0043e	48 89 44 24 78	 mov	 QWORD PTR ins$5[rsp], rax
  00443	eb 0e		 jmp	 SHORT $LN13@hdl_listmo
$LN11@hdl_listmo:
  00445	48 8b 44 24 78	 mov	 rax, QWORD PTR ins$5[rsp]
  0044a	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0044e	48 89 44 24 78	 mov	 QWORD PTR ins$5[rsp], rax
$LN13@hdl_listmo:
  00453	48 83 7c 24 78
	00		 cmp	 QWORD PTR ins$5[rsp], 0
  00459	0f 84 2c 01 00
	00		 je	 $LN12@hdl_listmo

; 1018 :             {
; 1019 :                 if (strcmp( ins->instname, prev_ins->instname ) != 0)

  0045f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR prev_ins$6[rsp]
  00467	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0046a	48 8b 44 24 78	 mov	 rax, QWORD PTR ins$5[rsp]
  0046f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00472	e8 00 00 00 00	 call	 strcmp
  00477	85 c0		 test	 eax, eax
  00479	0f 84 ce 00 00
	00		 je	 $LN21@hdl_listmo

; 1020 :                 {
; 1021 :                     // "HDL:  opcode %4.4X (%c%c%c) %s"
; 1022 :                     WRMSG( HHC01534, "I"

  0047f	0f be 44 24 60	 movsx	 eax, BYTE PTR z900$1[rsp]
  00484	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv212[rsp], eax
  0048b	0f be 4c 24 61	 movsx	 ecx, BYTE PTR s390$2[rsp]
  00490	89 8c 24 94 00
	00 00		 mov	 DWORD PTR tv214[rsp], ecx
  00497	0f be 54 24 62	 movsx	 edx, BYTE PTR s370$3[rsp]
  0049c	89 94 24 98 00
	00 00		 mov	 DWORD PTR tv216[rsp], edx
  004a3	b9 01 00 00 00	 mov	 ecx, 1
  004a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004ae	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR prev_ins$6[rsp]
  004b6	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  004b9	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  004be	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv212[rsp]
  004c5	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  004c9	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv214[rsp]
  004d0	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  004d4	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv216[rsp]
  004db	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  004df	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR prev_ins$6[rsp]
  004e7	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  004ea	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  004ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168752
  004f5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168753
  00501	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00506	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0050b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00511	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168754
  00518	ba 02 04 00 00	 mov	 edx, 1026		; 00000402H
  0051d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168755
  00524	e8 00 00 00 00	 call	 fwritemsg

; 1023 :                         , prev_ins->opcode
; 1024 :                         , s370, s390, z900
; 1025 :                         , prev_ins->instname
; 1026 :                     );
; 1027 : 
; 1028 :                     s370 = s390 = z900 = '.';

  00529	c6 44 24 60 2e	 mov	 BYTE PTR z900$1[rsp], 46 ; 0000002eH
  0052e	0f b6 44 24 60	 movzx	 eax, BYTE PTR z900$1[rsp]
  00533	88 44 24 61	 mov	 BYTE PTR s390$2[rsp], al
  00537	0f b6 44 24 61	 movzx	 eax, BYTE PTR s390$2[rsp]
  0053c	88 44 24 62	 mov	 BYTE PTR s370$3[rsp], al

; 1029 :                     prev_ins = ins;

  00540	48 8b 44 24 78	 mov	 rax, QWORD PTR ins$5[rsp]
  00545	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR prev_ins$6[rsp], rax
$LN21@hdl_listmo:

; 1030 :                 }
; 1031 : #if defined(                    _370 )
; 1032 :                 if (HDL_INSTARCH_370 == ins->hdl_arch)

  0054d	48 8b 44 24 78	 mov	 rax, QWORD PTR ins$5[rsp]
  00552	81 78 1c 00 00
	00 80		 cmp	 DWORD PTR [rax+28], -2147483648 ; 80000000H
  00559	75 05		 jne	 SHORT $LN22@hdl_listmo

; 1033 :                                 s370 = '7';

  0055b	c6 44 24 62 37	 mov	 BYTE PTR s370$3[rsp], 55 ; 00000037H
$LN22@hdl_listmo:

; 1034 : #endif
; 1035 : #if defined(                    _390 )
; 1036 :                 if (HDL_INSTARCH_390 == ins->hdl_arch)

  00560	48 8b 44 24 78	 mov	 rax, QWORD PTR ins$5[rsp]
  00565	81 78 1c 00 00
	00 40		 cmp	 DWORD PTR [rax+28], 1073741824 ; 40000000H
  0056c	75 05		 jne	 SHORT $LN23@hdl_listmo

; 1037 :                                 s390 = '9';

  0056e	c6 44 24 61 39	 mov	 BYTE PTR s390$2[rsp], 57 ; 00000039H
$LN23@hdl_listmo:

; 1038 : #endif
; 1039 : #if defined(                    _900 )
; 1040 :                 if (HDL_INSTARCH_900 == ins->hdl_arch)

  00573	48 8b 44 24 78	 mov	 rax, QWORD PTR ins$5[rsp]
  00578	81 78 1c 00 00
	00 20		 cmp	 DWORD PTR [rax+28], 536870912 ; 20000000H
  0057f	75 05		 jne	 SHORT $LN24@hdl_listmo

; 1041 :                                 z900 = 'Z';

  00581	c6 44 24 60 5a	 mov	 BYTE PTR z900$1[rsp], 90 ; 0000005aH
$LN24@hdl_listmo:

; 1042 : #endif
; 1043 :             }

  00586	e9 ba fe ff ff	 jmp	 $LN11@hdl_listmo
$LN12@hdl_listmo:

; 1044 : 
; 1045 :             // "HDL:  opcode %4.4X (%c%c%c) %s"
; 1046 :             WRMSG( HHC01534, "I"

  0058b	0f be 44 24 60	 movsx	 eax, BYTE PTR z900$1[rsp]
  00590	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv237[rsp], eax
  00597	0f be 4c 24 61	 movsx	 ecx, BYTE PTR s390$2[rsp]
  0059c	89 8c 24 a0 00
	00 00		 mov	 DWORD PTR tv239[rsp], ecx
  005a3	0f be 54 24 62	 movsx	 edx, BYTE PTR s370$3[rsp]
  005a8	89 94 24 a4 00
	00 00		 mov	 DWORD PTR tv241[rsp], edx
  005af	b9 01 00 00 00	 mov	 ecx, 1
  005b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005ba	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR prev_ins$6[rsp]
  005c2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  005c5	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  005ca	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv237[rsp]
  005d1	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  005d5	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv239[rsp]
  005dc	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  005e0	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv241[rsp]
  005e7	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005eb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR prev_ins$6[rsp]
  005f3	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  005f6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168759
  00601	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00606	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168760
  0060d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00612	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00617	41 b9 03 00 00
	00		 mov	 r9d, 3
  0061d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168761
  00624	ba 1a 04 00 00	 mov	 edx, 1050		; 0000041aH
  00629	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168762
  00630	e8 00 00 00 00	 call	 fwritemsg
$LN20@hdl_listmo:

; 1047 :                 , prev_ins->opcode
; 1048 :                 , s370, s390, z900
; 1049 :                 , prev_ins->instname
; 1050 :             );
; 1051 :         }
; 1052 :     }

  00635	e9 f1 f9 ff ff	 jmp	 $LN2@hdl_listmo
$LN3@hdl_listmo:

; 1053 : }

  0063a	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00642	48 33 cc	 xor	 rcx, rsp
  00645	e8 00 00 00 00	 call	 __security_check_cookie
  0064a	48 81 c4 f8 01
	00 00		 add	 rsp, 504		; 000001f8H
  00651	c3		 ret	 0
hdl_listmods ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
mod$ = 80
ppmod$ = 88
dev$ = 96
device$ = 104
cursym$ = 112
ins$1 = 120
tv162 = 128
tv168 = 132
rc$2 = 136
modname$ = 144
sym$ = 152
tv69 = 160
tv308 = 168
tv306 = 176
tv301 = 184
savedev$ = 192
saveins$3 = 200
name$ = 224
hdl_freemod PROC

; 423  : {

$LN47:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 424  :     /* Called by hsccmd.c's "rmmod_cmd" function */
; 425  : 
; 426  :     const char*  modname;
; 427  :     DEVBLK*      dev;
; 428  : 
; 429  :     HDLMOD*      mod;
; 430  :     HDLMOD**     ppmod;
; 431  : 
; 432  :     HDLSYM*      sym;
; 433  :     HDLSYM*      cursym;
; 434  : 
; 435  :     HDLDEV*      device;
; 436  :     HDLDEV*      savedev;
; 437  : 
; 438  :     modname = (modname = strrchr( name, '/' )) ? modname+1 : name;

  0000c	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  00011	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR name$[rsp]
  00019	e8 00 00 00 00	 call	 strrchr
  0001e	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR modname$[rsp], rax
  00026	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR modname$[rsp], 0
  0002f	74 15		 je	 SHORT $LN41@hdl_freemo
  00031	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR modname$[rsp]
  00039	48 ff c0	 inc	 rax
  0003c	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv69[rsp], rax
  00044	eb 10		 jmp	 SHORT $LN42@hdl_freemo
$LN41@hdl_freemo:
  00046	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  0004e	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv69[rsp], rax
$LN42@hdl_freemo:
  00056	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv69[rsp]
  0005e	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR modname$[rsp], rax

; 439  : 
; 440  :     obtain_lock( &hdl_lock );

  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168490
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_lock
  00074	e8 00 00 00 00	 call	 hthread_obtain_lock

; 441  :     {
; 442  :         /* Locate this module's entry in our chain */
; 443  :         for (ppmod = &(hdl_mods);

  00079	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:hdl_mods
  00080	48 89 44 24 58	 mov	 QWORD PTR ppmod$[rsp], rax
  00085	eb 11		 jmp	 SHORT $LN4@hdl_freemo
$LN2@hdl_freemo:

; 445  :              ppmod = &((*ppmod)->next))

  00087	48 8b 44 24 58	 mov	 rax, QWORD PTR ppmod$[rsp]
  0008c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008f	48 83 c0 60	 add	 rax, 96			; 00000060H
  00093	48 89 44 24 58	 mov	 QWORD PTR ppmod$[rsp], rax
$LN4@hdl_freemo:

; 444  :             *ppmod && strfilenamecmp( modname, (*ppmod)->name ) != 0;

  00098	48 8b 44 24 58	 mov	 rax, QWORD PTR ppmod$[rsp]
  0009d	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000a1	74 1f		 je	 SHORT $LN3@hdl_freemo
  000a3	48 8b 44 24 58	 mov	 rax, QWORD PTR ppmod$[rsp]
  000a8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ab	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  000ae	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR modname$[rsp]
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  000bc	85 c0		 test	 eax, eax
  000be	74 02		 je	 SHORT $LN3@hdl_freemo

; 446  :         {
; 447  :             ; // (nop)
; 448  :         }

  000c0	eb c5		 jmp	 SHORT $LN2@hdl_freemo
$LN3@hdl_freemo:

; 449  : 
; 450  :         /* Was module found? */
; 451  :         if (!*ppmod)

  000c2	48 8b 44 24 58	 mov	 rax, QWORD PTR ppmod$[rsp]
  000c7	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000cb	75 70		 jne	 SHORT $LN28@hdl_freemo

; 452  :         {
; 453  :             release_lock( &hdl_lock );

  000cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168492
  000d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_lock
  000db	e8 00 00 00 00	 call	 hthread_release_lock

; 454  :             // "HDL: module %s not found"
; 455  :             WRMSG( HHC01524, "E", modname );

  000e0	b9 01 00 00 00	 mov	 ecx, 1
  000e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000eb	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR modname$[rsp]
  000f3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168493
  000ff	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00104	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168494
  0010b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00110	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00115	41 b9 03 00 00
	00		 mov	 r9d, 3
  0011b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168495
  00122	ba c7 01 00 00	 mov	 edx, 455		; 000001c7H
  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168496
  0012e	e8 00 00 00 00	 call	 fwritemsg

; 456  :             return -1;

  00133	b8 ff ff ff ff	 mov	 eax, -1
  00138	e9 d0 05 00 00	 jmp	 $LN1@hdl_freemo
$LN28@hdl_freemo:

; 457  :         }
; 458  : 
; 459  :         /* Error if it 's not allowed to be unloaded */
; 460  :         if ((*ppmod)->flags & (HDL_LOAD_MAIN | HDL_LOAD_NOUNLOAD))

  0013d	48 8b 44 24 58	 mov	 rax, QWORD PTR ppmod$[rsp]
  00142	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00145	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00148	25 00 00 00 c0	 and	 eax, -1073741824	; c0000000H
  0014d	85 c0		 test	 eax, eax
  0014f	0f 84 83 00 00
	00		 je	 $LN29@hdl_freemo

; 461  :         {
; 462  :             release_lock( &hdl_lock );

  00155	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168498
  0015c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_lock
  00163	e8 00 00 00 00	 call	 hthread_release_lock

; 463  :             // "HDL: unloading of module %s not allowed"
; 464  :             WRMSG( HHC01521, "E", (*ppmod)->name );

  00168	48 8b 44 24 58	 mov	 rax, QWORD PTR ppmod$[rsp]
  0016d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00170	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv308[rsp], rax
  00178	b9 01 00 00 00	 mov	 ecx, 1
  0017d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00183	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv308[rsp]
  0018b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0018e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00193	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168499
  0019a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0019f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168500
  001a6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001ab	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b0	41 b9 03 00 00
	00		 mov	 r9d, 3
  001b6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168501
  001bd	ba d0 01 00 00	 mov	 edx, 464		; 000001d0H
  001c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168502
  001c9	e8 00 00 00 00	 call	 fwritemsg

; 465  :             return -1;

  001ce	b8 ff ff ff ff	 mov	 eax, -1
  001d3	e9 35 05 00 00	 jmp	 $LN1@hdl_freemo
$LN29@hdl_freemo:

; 466  :         }
; 467  : 
; 468  :         /* Disallow device modules to be unloaded if a device
; 469  :            is still using it by searching the device chain to
; 470  :            see if any of their DEVHND device handler pointers
; 471  :            matches the one for this module.
; 472  :         */
; 473  :         for (dev = sysblk.firstdev; dev; dev = dev->nextdev)

  001d8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001df	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  001e6	48 89 44 24 60	 mov	 QWORD PTR dev$[rsp], rax
  001eb	eb 0e		 jmp	 SHORT $LN7@hdl_freemo
$LN5@hdl_freemo:
  001ed	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001f2	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  001f6	48 89 44 24 60	 mov	 QWORD PTR dev$[rsp], rax
$LN7@hdl_freemo:
  001fb	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00201	0f 84 72 01 00
	00		 je	 $LN6@hdl_freemo

; 474  :         {
; 475  :             /* Is device in use? */
; 476  :             if (IS_DEV( dev ))

  00207	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0020c	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  00210	0f 84 5e 01 00
	00		 je	 $LN30@hdl_freemo
  00216	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0021b	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00222	83 e0 01	 and	 eax, 1
  00225	85 c0		 test	 eax, eax
  00227	75 19		 jne	 SHORT $LN31@hdl_freemo
  00229	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00230	48 8b 80 c8 11
	00 00		 mov	 rax, QWORD PTR [rax+4552]
  00237	48 39 44 24 60	 cmp	 QWORD PTR dev$[rsp], rax
  0023c	0f 85 32 01 00
	00		 jne	 $LN30@hdl_freemo
$LN31@hdl_freemo:

; 477  :             {
; 478  :                 /* Search DEVHND chain for this module to see
; 479  :                    if any of them match this device's. If so,
; 480  :                    then the current device is still using the
; 481  :                    module being unloaded (the device is still
; 482  :                    "bound" to the module being unloaded).
; 483  :                 */
; 484  :                 for (device = (*ppmod)->devices; device; device = device->next)

  00242	48 8b 44 24 58	 mov	 rax, QWORD PTR ppmod$[rsp]
  00247	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0024a	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  0024e	48 89 44 24 68	 mov	 QWORD PTR device$[rsp], rax
  00253	eb 0e		 jmp	 SHORT $LN10@hdl_freemo
$LN8@hdl_freemo:
  00255	48 8b 44 24 68	 mov	 rax, QWORD PTR device$[rsp]
  0025a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0025e	48 89 44 24 68	 mov	 QWORD PTR device$[rsp], rax
$LN10@hdl_freemo:
  00263	48 83 7c 24 68
	00		 cmp	 QWORD PTR device$[rsp], 0
  00269	0f 84 05 01 00
	00		 je	 $LN9@hdl_freemo

; 485  :                 {
; 486  :                     /* Is device still using this module? */
; 487  :                     if (dev->hnd == device->hnd)

  0026f	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00274	48 8b 4c 24 68	 mov	 rcx, QWORD PTR device$[rsp]
  00279	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0027d	48 39 88 90 02
	00 00		 cmp	 QWORD PTR [rax+656], rcx
  00284	0f 85 e5 00 00
	00		 jne	 $LN32@hdl_freemo

; 488  :                     {
; 489  :                         release_lock( &hdl_lock );

  0028a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168506
  00291	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_lock
  00298	e8 00 00 00 00	 call	 hthread_release_lock

; 490  :                         // "HDL: module %s bound to device %1d:%04X"
; 491  :                         WRMSG( HHC01522, "E", (*ppmod)->name,

  0029d	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002a3	74 12		 je	 SHORT $LN43@hdl_freemo
  002a5	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  002aa	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002ae	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv162[rsp], eax
  002b5	eb 0b		 jmp	 SHORT $LN44@hdl_freemo
$LN43@hdl_freemo:
  002b7	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv162[rsp], 0
$LN44@hdl_freemo:
  002c2	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002c8	74 14		 je	 SHORT $LN45@hdl_freemo
  002ca	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  002cf	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  002d3	d1 f8		 sar	 eax, 1
  002d5	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv168[rsp], eax
  002dc	eb 0b		 jmp	 SHORT $LN46@hdl_freemo
$LN45@hdl_freemo:
  002de	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv168[rsp], 0
$LN46@hdl_freemo:
  002e9	48 8b 44 24 58	 mov	 rax, QWORD PTR ppmod$[rsp]
  002ee	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002f1	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv306[rsp], rax
  002f9	b9 01 00 00 00	 mov	 ecx, 1
  002fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00304	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv162[rsp]
  0030b	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0030f	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv168[rsp]
  00316	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0031a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv306[rsp]
  00322	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00325	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0032a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168507
  00331	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00336	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168508
  0033d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00342	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00347	41 b9 03 00 00
	00		 mov	 r9d, 3
  0034d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168509
  00354	ba ec 01 00 00	 mov	 edx, 492		; 000001ecH
  00359	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168510
  00360	e8 00 00 00 00	 call	 fwritemsg

; 492  :                             LCSS_DEVNUM );
; 493  :                         return -1;

  00365	b8 ff ff ff ff	 mov	 eax, -1
  0036a	e9 9e 03 00 00	 jmp	 $LN1@hdl_freemo
$LN32@hdl_freemo:

; 494  :                     }
; 495  :                 }

  0036f	e9 e1 fe ff ff	 jmp	 $LN8@hdl_freemo
$LN9@hdl_freemo:
$LN30@hdl_freemo:

; 496  :             }
; 497  :         }

  00374	e9 74 fe ff ff	 jmp	 $LN5@hdl_freemo
$LN6@hdl_freemo:

; 498  : 
; 499  :         /* Disallow unloading of instruction override modules
; 500  :            if the system is currently executing instructions */
; 501  :         if ((*ppmod)->inssec_ep)

  00379	48 8b 44 24 58	 mov	 rax, QWORD PTR ppmod$[rsp]
  0037e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00381	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00386	0f 84 97 00 00
	00		 je	 $LN33@hdl_freemo

; 502  :         {
; 503  :             /* Prevent stopped CPUs from being started */
; 504  :             OBTAIN_INTLOCK( NULL );

  0038c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168512
  00393	33 c9		 xor	 ecx, ecx
  00395	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 505  : 
; 506  :             if (are_any_cpus_started_intlock_held())

  0039a	e8 00 00 00 00	 call	 are_any_cpus_started_intlock_held
  0039f	0f b6 c0	 movzx	 eax, al
  003a2	85 c0		 test	 eax, eax
  003a4	74 7d		 je	 SHORT $LN34@hdl_freemo

; 507  :             {
; 508  :                 RELEASE_INTLOCK( NULL );

  003a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168514
  003ad	33 c9		 xor	 ecx, ecx
  003af	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 509  :                 release_lock( &hdl_lock );

  003b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168515
  003bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_lock
  003c2	e8 00 00 00 00	 call	 hthread_release_lock

; 510  :                 // "All CPU's must be stopped %s"
; 511  :                 WRMSG( HHC02253, "E", "to unload an instruction module" );

  003c7	b9 01 00 00 00	 mov	 ecx, 1
  003cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168516
  003d9	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168517
  003e5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168518
  003f1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003f6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003fb	41 b9 03 00 00
	00		 mov	 r9d, 3
  00401	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168519
  00408	ba ff 01 00 00	 mov	 edx, 511		; 000001ffH
  0040d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168520
  00414	e8 00 00 00 00	 call	 fwritemsg

; 512  :                 return -1;

  00419	b8 ff ff ff ff	 mov	 eax, -1
  0041e	e9 ea 02 00 00	 jmp	 $LN1@hdl_freemo
$LN34@hdl_freemo:
$LN33@hdl_freemo:

; 513  :             }
; 514  :         }
; 515  : 
; 516  :         /* Call module's HDL_FINAL_SECTION, if it has one */
; 517  :         if ((*ppmod)->finsec_ep)

  00423	48 8b 44 24 58	 mov	 rax, QWORD PTR ppmod$[rsp]
  00428	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0042b	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  00430	0f 84 c2 00 00
	00		 je	 $LN35@hdl_freemo

; 518  :         {
; 519  :             int rc;
; 520  : 
; 521  :             if ((rc = (*ppmod)->finsec_ep()) != 0)

  00436	48 8b 44 24 58	 mov	 rax, QWORD PTR ppmod$[rsp]
  0043b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0043e	ff 50 40	 call	 QWORD PTR [rax+64]
  00441	89 84 24 88 00
	00 00		 mov	 DWORD PTR rc$2[rsp], eax
  00448	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR rc$2[rsp], 0
  00450	0f 84 a2 00 00
	00		 je	 $LN36@hdl_freemo

; 522  :             {
; 523  :                 if ((*ppmod)->inssec_ep)

  00456	48 8b 44 24 58	 mov	 rax, QWORD PTR ppmod$[rsp]
  0045b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0045e	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00463	74 0e		 je	 SHORT $LN37@hdl_freemo

; 524  :                     RELEASE_INTLOCK( NULL );

  00465	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168524
  0046c	33 c9		 xor	 ecx, ecx
  0046e	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN37@hdl_freemo:

; 525  :                 release_lock( &hdl_lock );

  00473	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168525
  0047a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_lock
  00481	e8 00 00 00 00	 call	 hthread_release_lock

; 526  :                 // "HDL: unload of module %s rejected by final section"
; 527  :                 WRMSG( HHC01523, "E", (*ppmod)->name );

  00486	48 8b 44 24 58	 mov	 rax, QWORD PTR ppmod$[rsp]
  0048b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0048e	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv301[rsp], rax
  00496	b9 01 00 00 00	 mov	 ecx, 1
  0049b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004a1	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv301[rsp]
  004a9	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  004ac	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168526
  004b8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168527
  004c4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004c9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004ce	41 b9 03 00 00
	00		 mov	 r9d, 3
  004d4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168528
  004db	ba 0f 02 00 00	 mov	 edx, 527		; 0000020fH
  004e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168529
  004e7	e8 00 00 00 00	 call	 fwritemsg

; 528  :                 return rc;

  004ec	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR rc$2[rsp]
  004f3	e9 15 02 00 00	 jmp	 $LN1@hdl_freemo
$LN36@hdl_freemo:
$LN35@hdl_freemo:

; 529  :             }
; 530  :         }
; 531  : 
; 532  :         sym = (*ppmod)->symbols;

  004f8	48 8b 44 24 58	 mov	 rax, QWORD PTR ppmod$[rsp]
  004fd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00500	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  00504	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR sym$[rsp], rax
$LN11@hdl_freemo:

; 533  : 
; 534  :         /* Free all symbols that this module registered */
; 535  :         while (sym)

  0050c	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR sym$[rsp], 0
  00515	74 3c		 je	 SHORT $LN12@hdl_freemo

; 536  :         {
; 537  :             cursym = sym;

  00517	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR sym$[rsp]
  0051f	48 89 44 24 70	 mov	 QWORD PTR cursym$[rsp], rax

; 538  : 
; 539  :             /* Go on to the next entry (if there is one) */
; 540  :             sym = sym->next;

  00524	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR sym$[rsp]
  0052c	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00530	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR sym$[rsp], rax

; 541  : 
; 542  :             /* free the symbol */
; 543  :             free( cursym->name );

  00538	48 8b 44 24 70	 mov	 rax, QWORD PTR cursym$[rsp]
  0053d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00540	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 544  :             free( cursym );

  00546	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cursym$[rsp]
  0054b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 545  :         }

  00551	eb b9		 jmp	 SHORT $LN11@hdl_freemo
$LN12@hdl_freemo:

; 546  : 
; 547  :         /* Remove the module from our chain */
; 548  :         mod    = *ppmod;

  00553	48 8b 44 24 58	 mov	 rax, QWORD PTR ppmod$[rsp]
  00558	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0055b	48 89 44 24 50	 mov	 QWORD PTR mod$[rsp], rax

; 549  :         *ppmod = mod->next;

  00560	48 8b 44 24 58	 mov	 rax, QWORD PTR ppmod$[rsp]
  00565	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mod$[rsp]
  0056a	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0056e	48 89 08	 mov	 QWORD PTR [rax], rcx

; 550  : 
; 551  :         /* Free all device registrations */
; 552  :         for (device = mod->devices; device;)

  00571	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  00576	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  0057a	48 89 44 24 68	 mov	 QWORD PTR device$[rsp], rax
$LN13@hdl_freemo:
  0057f	48 83 7c 24 68
	00		 cmp	 QWORD PTR device$[rsp], 0
  00585	74 39		 je	 SHORT $LN14@hdl_freemo

; 553  :         {
; 554  :             free( device->name );

  00587	48 8b 44 24 68	 mov	 rax, QWORD PTR device$[rsp]
  0058c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0058f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 555  :             savedev = device->next;

  00595	48 8b 44 24 68	 mov	 rax, QWORD PTR device$[rsp]
  0059a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0059e	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR savedev$[rsp], rax

; 556  :             free( device );

  005a6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR device$[rsp]
  005ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 557  :             device = savedev;

  005b1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR savedev$[rsp]
  005b9	48 89 44 24 68	 mov	 QWORD PTR device$[rsp], rax

; 558  :         }

  005be	eb bf		 jmp	 SHORT $LN13@hdl_freemo
$LN14@hdl_freemo:

; 559  : 
; 560  :         /* Revert and free all instruction overrides for this module */
; 561  :         if (mod->inssec_ep)

  005c0	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  005c5	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  005ca	74 69		 je	 SHORT $LN38@hdl_freemo

; 562  :         {
; 563  :             HDLINS*  ins;
; 564  :             HDLINS*  saveins;
; 565  : 
; 566  :             for (ins = mod->instructs; ins;)

  005cc	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  005d1	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  005d5	48 89 44 24 78	 mov	 QWORD PTR ins$1[rsp], rax
$LN16@hdl_freemo:
  005da	48 83 7c 24 78
	00		 cmp	 QWORD PTR ins$1[rsp], 0
  005e0	74 45		 je	 SHORT $LN17@hdl_freemo

; 567  :             {
; 568  :                 /* Revert this instruction override */
; 569  :                 hdl_repins( false, ins );

  005e2	48 8b 54 24 78	 mov	 rdx, QWORD PTR ins$1[rsp]
  005e7	33 c9		 xor	 ecx, ecx
  005e9	e8 00 00 00 00	 call	 hdl_repins

; 570  : 
; 571  :                 /* Free resources for this instruction override */
; 572  :                 free( ins->instname );   // (free name string)

  005ee	48 8b 44 24 78	 mov	 rax, QWORD PTR ins$1[rsp]
  005f3	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  005f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 573  :                 saveins = ins->next;     // (save before freeing)

  005fc	48 8b 44 24 78	 mov	 rax, QWORD PTR ins$1[rsp]
  00601	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00605	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR saveins$3[rsp], rax

; 574  :                 free( ins );             // (free HDLINS struct)

  0060d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ins$1[rsp]
  00612	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 575  : 
; 576  :                 /* Do for all overrides in this module's chain */
; 577  :                 ins = saveins;

  00618	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR saveins$3[rsp]
  00620	48 89 44 24 78	 mov	 QWORD PTR ins$1[rsp], rax

; 578  :             }

  00625	eb b3		 jmp	 SHORT $LN16@hdl_freemo
$LN17@hdl_freemo:

; 579  :             RELEASE_INTLOCK( NULL );

  00627	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168531
  0062e	33 c9		 xor	 ecx, ecx
  00630	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN38@hdl_freemo:

; 580  :         }
; 581  : 
; 582  :         /* Free the module's HDLMOD struct */
; 583  :         free( mod->name );

  00635	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  0063a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0063d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 584  :         dlclose( mod->handle );

  00643	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  00648	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0064c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FreeLibrary

; 585  :         free( mod );

  00652	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mod$[rsp]
  00657	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 586  : 
; 587  :         /* Reset symbol loadcounts for all remaining modules */
; 588  :         for (mod = hdl_mods; mod; mod = mod->next)

  0065d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_mods
  00664	48 89 44 24 50	 mov	 QWORD PTR mod$[rsp], rax
  00669	eb 0e		 jmp	 SHORT $LN21@hdl_freemo
$LN19@hdl_freemo:
  0066b	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  00670	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00674	48 89 44 24 50	 mov	 QWORD PTR mod$[rsp], rax
$LN21@hdl_freemo:
  00679	48 83 7c 24 50
	00		 cmp	 QWORD PTR mod$[rsp], 0
  0067f	74 36		 je	 SHORT $LN20@hdl_freemo

; 589  :             for (cursym = mod->symbols; cursym; cursym = cursym->next)

  00681	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  00686	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  0068a	48 89 44 24 70	 mov	 QWORD PTR cursym$[rsp], rax
  0068f	eb 0e		 jmp	 SHORT $LN24@hdl_freemo
$LN22@hdl_freemo:
  00691	48 8b 44 24 70	 mov	 rax, QWORD PTR cursym$[rsp]
  00696	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0069a	48 89 44 24 70	 mov	 QWORD PTR cursym$[rsp], rax
$LN24@hdl_freemo:
  0069f	48 83 7c 24 70
	00		 cmp	 QWORD PTR cursym$[rsp], 0
  006a5	74 0e		 je	 SHORT $LN23@hdl_freemo

; 590  :                 cursym->refcnt = 0;

  006a7	48 8b 44 24 70	 mov	 rax, QWORD PTR cursym$[rsp]
  006ac	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0
  006b3	eb dc		 jmp	 SHORT $LN22@hdl_freemo
$LN23@hdl_freemo:
  006b5	eb b4		 jmp	 SHORT $LN19@hdl_freemo
$LN20@hdl_freemo:

; 591  : 
; 592  :         /* Call all remaining modules' HDL_RESOLVER_SECTION again */
; 593  :         for (mod = hdl_mods; mod; mod = mod->next)

  006b7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_mods
  006be	48 89 44 24 50	 mov	 QWORD PTR mod$[rsp], rax
  006c3	eb 0e		 jmp	 SHORT $LN27@hdl_freemo
$LN25@hdl_freemo:
  006c5	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  006ca	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  006ce	48 89 44 24 50	 mov	 QWORD PTR mod$[rsp], rax
$LN27@hdl_freemo:
  006d3	48 83 7c 24 50
	00		 cmp	 QWORD PTR mod$[rsp], 0
  006d9	74 1d		 je	 SHORT $LN26@hdl_freemo

; 594  :         {
; 595  :             if (mod->ressec_ep)

  006db	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  006e0	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  006e5	74 0f		 je	 SHORT $LN39@hdl_freemo

; 596  :                 mod->ressec_ep( &hdl_resolve_symbols_cb );

  006e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_resolve_symbols_cb
  006ee	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  006f3	ff 50 28	 call	 QWORD PTR [rax+40]
$LN39@hdl_freemo:

; 597  :         }

  006f6	eb cd		 jmp	 SHORT $LN25@hdl_freemo
$LN26@hdl_freemo:

; 598  :     }
; 599  :     release_lock( &hdl_lock );

  006f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168533
  006ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_lock
  00706	e8 00 00 00 00	 call	 hthread_release_lock

; 600  : 
; 601  :     return 0;

  0070b	33 c0		 xor	 eax, eax
$LN1@hdl_freemo:

; 602  : }

  0070d	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00714	c3		 ret	 0
hdl_freemod ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
mod$ = 80
wrkmod$ = 88
modname$ = 96
sym$ = 104
tv69 = 112
tv144 = 120
tv170 = 128
tv280 = 136
tv94 = 144
tv150 = 152
tv175 = 160
sev$1 = 168
name$ = 192
flags$ = 200
hdl_loadmod PROC

; 246  : {

$LN38:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 247  :     /* Called by hsccmd.c's "ldmod_cmd" function */
; 248  : 
; 249  :     const char*  modname;
; 250  :     HDLMOD*      mod;
; 251  :     HDLMOD*      wrkmod;
; 252  :     HDLSYM*      sym;
; 253  : 
; 254  :     /* Search module chain to see if module is already loaded */
; 255  :     modname = (modname = strrchr( name, '/' )) ? modname+1 : name;

  00010	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  00015	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR name$[rsp]
  0001d	e8 00 00 00 00	 call	 strrchr
  00022	48 89 44 24 60	 mov	 QWORD PTR modname$[rsp], rax
  00027	48 83 7c 24 60
	00		 cmp	 QWORD PTR modname$[rsp], 0
  0002d	74 0f		 je	 SHORT $LN34@hdl_loadmo
  0002f	48 8b 44 24 60	 mov	 rax, QWORD PTR modname$[rsp]
  00034	48 ff c0	 inc	 rax
  00037	48 89 44 24 70	 mov	 QWORD PTR tv69[rsp], rax
  0003c	eb 0d		 jmp	 SHORT $LN35@hdl_loadmo
$LN34@hdl_loadmo:
  0003e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR name$[rsp]
  00046	48 89 44 24 70	 mov	 QWORD PTR tv69[rsp], rax
$LN35@hdl_loadmo:
  0004b	48 8b 44 24 70	 mov	 rax, QWORD PTR tv69[rsp]
  00050	48 89 44 24 60	 mov	 QWORD PTR modname$[rsp], rax

; 256  : 
; 257  :     for (mod = hdl_mods; mod; mod = mod->next)

  00055	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_mods
  0005c	48 89 44 24 50	 mov	 QWORD PTR mod$[rsp], rax
  00061	eb 0e		 jmp	 SHORT $LN4@hdl_loadmo
$LN2@hdl_loadmo:
  00063	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  00068	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0006c	48 89 44 24 50	 mov	 QWORD PTR mod$[rsp], rax
$LN4@hdl_loadmo:
  00071	48 83 7c 24 50
	00		 cmp	 QWORD PTR mod$[rsp], 0
  00077	74 79		 je	 SHORT $LN3@hdl_loadmo

; 258  :     {
; 259  :         if (strfilenamecmp( modname, mod->name ) == 0)

  00079	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  0007e	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00081	48 8b 4c 24 60	 mov	 rcx, QWORD PTR modname$[rsp]
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0008c	85 c0		 test	 eax, eax
  0008e	75 5d		 jne	 SHORT $LN17@hdl_loadmo

; 260  :         {
; 261  :             // "HDL: module %s already loaded"
; 262  :             WRMSG( HHC01519, "E", mod->name );

  00090	b9 01 00 00 00	 mov	 ecx, 1
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0009b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mod$[rsp]
  000a0	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000a3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168377
  000af	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168378
  000bb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000c0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c5	41 b9 03 00 00
	00		 mov	 r9d, 3
  000cb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168379
  000d2	ba 06 01 00 00	 mov	 edx, 262		; 00000106H
  000d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168380
  000de	e8 00 00 00 00	 call	 fwritemsg

; 263  :             return -1;

  000e3	b8 ff ff ff ff	 mov	 eax, -1
  000e8	e9 62 07 00 00	 jmp	 $LN1@hdl_loadmo
$LN17@hdl_loadmo:

; 264  :         }
; 265  :     }

  000ed	e9 71 ff ff ff	 jmp	 $LN2@hdl_loadmo
$LN3@hdl_loadmo:

; 266  : 
; 267  :     // Allocate a new HDLMOD structure for the module being loaded */
; 268  :     if (!(mod = malloc( sizeof( HDLMOD ))))

  000f2	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  000f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000fd	48 89 44 24 50	 mov	 QWORD PTR mod$[rsp], rax
  00102	48 83 7c 24 50
	00		 cmp	 QWORD PTR mod$[rsp], 0
  00108	75 7e		 jne	 SHORT $LN18@hdl_loadmo

; 269  :     {
; 270  :         // "HDL: error in function %s: %s"
; 271  :         WRMSG( HHC01511, "E", "malloc()", strerror( errno ));

  0010a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00110	8b 08		 mov	 ecx, DWORD PTR [rax]
  00112	e8 00 00 00 00	 call	 w32_strerror
  00117	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv94[rsp], rax
  0011f	b9 01 00 00 00	 mov	 ecx, 1
  00124	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0012a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv94[rsp]
  00132	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00137	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168382
  0013e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00143	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168383
  0014a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0014f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168384
  00156	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0015b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00160	41 b9 03 00 00
	00		 mov	 r9d, 3
  00166	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168385
  0016d	ba 0f 01 00 00	 mov	 edx, 271		; 0000010fH
  00172	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168386
  00179	e8 00 00 00 00	 call	 fwritemsg

; 272  :         return -1;

  0017e	b8 ff ff ff ff	 mov	 eax, -1
  00183	e9 c7 06 00 00	 jmp	 $LN1@hdl_loadmo
$LN18@hdl_loadmo:

; 273  :     }
; 274  : 
; 275  :     /* Ask the host operating system to load the module */
; 276  :     mod->name = strdup( modname );

  00188	48 8b 4c 24 60	 mov	 rcx, QWORD PTR modname$[rsp]
  0018d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00193	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mod$[rsp]
  00198	48 89 01	 mov	 QWORD PTR [rcx], rax

; 277  :     // FIXME what if this malloc() fails?
; 278  : 
; 279  :     if (!(mod->handle = hdl_dlopen( name, RTLD_NOW )))

  0019b	33 d2		 xor	 edx, edx
  0019d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR name$[rsp]
  001a5	e8 00 00 00 00	 call	 hdl_dlopen
  001aa	48 89 44 24 78	 mov	 QWORD PTR tv144[rsp], rax
  001af	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  001b4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv144[rsp]
  001b9	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  001bd	48 83 7c 24 78
	00		 cmp	 QWORD PTR tv144[rsp], 0
  001c3	0f 85 a8 00 00
	00		 jne	 $LN19@hdl_loadmo

; 280  :     {
; 281  :         if (!(flags & HDL_LOAD_NOMSG))

  001c9	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  001d0	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  001d5	85 c0		 test	 eax, eax
  001d7	75 75		 jne	 SHORT $LN20@hdl_loadmo

; 282  :             // "HDL: unable to open module %s: %s"
; 283  :             WRMSG( HHC01516, "E", name, dlerror());

  001d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  001df	8b c8		 mov	 ecx, eax
  001e1	e8 00 00 00 00	 call	 w32_strerror
  001e6	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv150[rsp], rax
  001ee	b9 01 00 00 00	 mov	 ecx, 1
  001f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001f9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv150[rsp]
  00201	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00206	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR name$[rsp]
  0020e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00213	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168389
  0021a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0021f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168390
  00226	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0022b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00230	41 b9 03 00 00
	00		 mov	 r9d, 3
  00236	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168391
  0023d	ba 1b 01 00 00	 mov	 edx, 283		; 0000011bH
  00242	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168392
  00249	e8 00 00 00 00	 call	 fwritemsg
$LN20@hdl_loadmo:

; 284  : 
; 285  :         free( mod->name );

  0024e	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  00253	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00256	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 286  :         free( mod );

  0025c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mod$[rsp]
  00261	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 287  :         return -1;

  00267	b8 ff ff ff ff	 mov	 eax, -1
  0026c	e9 de 05 00 00	 jmp	 $LN1@hdl_loadmo
$LN19@hdl_loadmo:

; 288  :     }
; 289  : 
; 290  :     mod->flags = (flags & (~HDL_LOAD_WAS_FORCED));

  00271	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  00278	0f ba f0 1b	 btr	 eax, 27
  0027c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mod$[rsp]
  00281	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 291  : 
; 292  :     /* Retrieve the module's HDL_DEPENDENCY_SECTION entry-point */
; 293  :     if (!(mod->depsec_ep = dlsym( mod->handle, "hdl_check_depends_ep" )))

  00284	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168394
  0028b	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  00290	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00294	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  0029a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv170[rsp], rax
  002a2	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  002a7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv170[rsp]
  002af	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx
  002b3	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR tv170[rsp], 0
  002bc	0f 85 a7 00 00
	00		 jne	 $LN21@hdl_loadmo

; 294  :     {
; 295  :         // "HDL: no HDL_DEPENDENCY_SECTION in %s: %s"
; 296  :         WRMSG( HHC01517, "E", mod->name, dlerror());

  002c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  002c8	8b c8		 mov	 ecx, eax
  002ca	e8 00 00 00 00	 call	 w32_strerror
  002cf	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv175[rsp], rax
  002d7	b9 01 00 00 00	 mov	 ecx, 1
  002dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002e2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv175[rsp]
  002ea	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002ef	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mod$[rsp]
  002f4	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  002f7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168395
  00303	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00308	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168396
  0030f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00314	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00319	41 b9 03 00 00
	00		 mov	 r9d, 3
  0031f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168397
  00326	ba 28 01 00 00	 mov	 edx, 296		; 00000128H
  0032b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168398
  00332	e8 00 00 00 00	 call	 fwritemsg

; 297  :         dlclose( mod->handle );

  00337	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  0033c	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00340	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FreeLibrary

; 298  :         free( mod->name );

  00346	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  0034b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0034e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 299  :         free( mod );

  00354	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mod$[rsp]
  00359	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 300  :         return -1;

  0035f	b8 ff ff ff ff	 mov	 eax, -1
  00364	e9 e6 04 00 00	 jmp	 $LN1@hdl_loadmo
$LN21@hdl_loadmo:

; 301  :     }
; 302  : 
; 303  :     /* Reject loading the same module again twice */
; 304  :     for (wrkmod = hdl_mods; wrkmod; wrkmod = wrkmod->next)

  00369	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_mods
  00370	48 89 44 24 58	 mov	 QWORD PTR wrkmod$[rsp], rax
  00375	eb 0e		 jmp	 SHORT $LN7@hdl_loadmo
$LN5@hdl_loadmo:
  00377	48 8b 44 24 58	 mov	 rax, QWORD PTR wrkmod$[rsp]
  0037c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00380	48 89 44 24 58	 mov	 QWORD PTR wrkmod$[rsp], rax
$LN7@hdl_loadmo:
  00385	48 83 7c 24 58
	00		 cmp	 QWORD PTR wrkmod$[rsp], 0
  0038b	0f 84 af 00 00
	00		 je	 $LN6@hdl_loadmo

; 305  :     {
; 306  :         if (wrkmod->depsec_ep == mod->depsec_ep)

  00391	48 8b 44 24 58	 mov	 rax, QWORD PTR wrkmod$[rsp]
  00396	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mod$[rsp]
  0039b	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0039f	48 39 48 18	 cmp	 QWORD PTR [rax+24], rcx
  003a3	0f 85 92 00 00
	00		 jne	 $LN22@hdl_loadmo

; 307  :         {
; 308  :             // "HDL: module %s is duplicate of %s"
; 309  :             WRMSG( HHC01520, "E", mod->name, wrkmod->name );

  003a9	b9 01 00 00 00	 mov	 ecx, 1
  003ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003b4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR wrkmod$[rsp]
  003b9	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  003bc	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  003c1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mod$[rsp]
  003c6	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  003c9	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168400
  003d5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168401
  003e1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003e6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003eb	41 b9 03 00 00
	00		 mov	 r9d, 3
  003f1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168402
  003f8	ba 35 01 00 00	 mov	 edx, 309		; 00000135H
  003fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168403
  00404	e8 00 00 00 00	 call	 fwritemsg

; 310  :             dlclose( mod->handle );

  00409	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  0040e	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00412	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FreeLibrary

; 311  :             free( mod->name );

  00418	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  0041d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00420	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 312  :             free( mod );

  00426	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mod$[rsp]
  0042b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 313  :             return -1;

  00431	b8 ff ff ff ff	 mov	 eax, -1
  00436	e9 14 04 00 00	 jmp	 $LN1@hdl_loadmo
$LN22@hdl_loadmo:

; 314  :         }
; 315  :     }

  0043b	e9 37 ff ff ff	 jmp	 $LN5@hdl_loadmo
$LN6@hdl_loadmo:

; 316  : 
; 317  :     /* Retrieve pointers to the module's entry-point functions */
; 318  :     mod->regsec_ep = dlsym( mod->handle, "hdl_register_symbols_ep" );

  00440	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168404
  00447	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  0044c	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00450	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  00456	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mod$[rsp]
  0045b	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 319  :     mod->ressec_ep = dlsym( mod->handle, "hdl_resolve_symbols_ep"  );

  0045f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168405
  00466	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  0046b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0046f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  00475	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mod$[rsp]
  0047a	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 320  :     mod->devsec_ep = dlsym( mod->handle, "hdl_define_devtypes_ep"  );

  0047e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168406
  00485	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  0048a	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0048e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  00494	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mod$[rsp]
  00499	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 321  :     mod->inssec_ep = dlsym( mod->handle, "hdl_define_instructs_ep" );

  0049d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168407
  004a4	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  004a9	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  004ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  004b3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mod$[rsp]
  004b8	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 322  :     mod->finsec_ep = dlsym( mod->handle, "hdl_on_module_unload_ep" );

  004bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168408
  004c3	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  004c8	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  004cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  004d2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mod$[rsp]
  004d7	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax

; 323  : 
; 324  :     /* No symbols, device types or instructions registered yet */
; 325  :     mod->symbols   = NULL;

  004db	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  004e0	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0

; 326  :     mod->devices   = NULL;

  004e8	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  004ed	48 c7 40 50 00
	00 00 00	 mov	 QWORD PTR [rax+80], 0

; 327  :     mod->instructs = NULL;

  004f5	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  004fa	48 c7 40 58 00
	00 00 00	 mov	 QWORD PTR [rax+88], 0

; 328  : 
; 329  :     obtain_lock( &hdl_lock );

  00502	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168409
  00509	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_lock
  00510	e8 00 00 00 00	 call	 hthread_obtain_lock

; 330  :     {
; 331  :         /* Disallow loading of instruction override modules
; 332  :            if the system is currently executing instructions */
; 333  :         if (mod->inssec_ep)

  00515	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  0051a	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  0051f	0f 84 c3 00 00
	00		 je	 $LN23@hdl_loadmo

; 334  :         {
; 335  :             /* Prevent stopped CPUs from being started */
; 336  :             OBTAIN_INTLOCK( NULL );

  00525	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168411
  0052c	33 c9		 xor	 ecx, ecx
  0052e	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 337  : 
; 338  :             if (are_any_cpus_started_intlock_held())

  00533	e8 00 00 00 00	 call	 are_any_cpus_started_intlock_held
  00538	0f b6 c0	 movzx	 eax, al
  0053b	85 c0		 test	 eax, eax
  0053d	0f 84 a5 00 00
	00		 je	 $LN24@hdl_loadmo

; 339  :             {
; 340  :                 RELEASE_INTLOCK( NULL );

  00543	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168413
  0054a	33 c9		 xor	 ecx, ecx
  0054c	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 341  :                 release_lock( &hdl_lock );

  00551	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168414
  00558	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_lock
  0055f	e8 00 00 00 00	 call	 hthread_release_lock

; 342  :                 // "All CPU's must be stopped %s"
; 343  :                 WRMSG( HHC02253, "E", "to load an instruction module" );

  00564	b9 01 00 00 00	 mov	 ecx, 1
  00569	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0056f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168415
  00576	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0057b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168416
  00582	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00587	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168417
  0058e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00593	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00598	41 b9 03 00 00
	00		 mov	 r9d, 3
  0059e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168418
  005a5	ba 57 01 00 00	 mov	 edx, 343		; 00000157H
  005aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168419
  005b1	e8 00 00 00 00	 call	 fwritemsg

; 344  :                 dlclose( mod->handle );

  005b6	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  005bb	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  005bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FreeLibrary

; 345  :                 free( mod->name );

  005c5	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  005ca	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  005cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 346  :                 free( mod );

  005d3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mod$[rsp]
  005d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 347  :                 return -1;

  005de	b8 ff ff ff ff	 mov	 eax, -1
  005e3	e9 67 02 00 00	 jmp	 $LN1@hdl_loadmo
$LN24@hdl_loadmo:
$LN23@hdl_loadmo:

; 348  :             }
; 349  :         }
; 350  : 
; 351  :         /* Call module's HDL_DEPENDENCY_SECTION */
; 352  :         if (mod->depsec_ep( &hdl_check_depends_cb ) != 0)

  005e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_check_depends_cb
  005ef	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  005f4	ff 50 18	 call	 QWORD PTR [rax+24]
  005f7	85 c0		 test	 eax, eax
  005f9	0f 84 19 01 00
	00		 je	 $LN25@hdl_loadmo

; 353  :         {
; 354  :             const char* sev = (flags & HDL_LOAD_FORCE) ? "W" : "E";

  005ff	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  00606	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0060b	85 c0		 test	 eax, eax
  0060d	74 11		 je	 SHORT $LN36@hdl_loadmo
  0060f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168421
  00616	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv280[rsp], rax
  0061e	eb 0f		 jmp	 SHORT $LN37@hdl_loadmo
$LN36@hdl_loadmo:
  00620	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168422
  00627	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv280[rsp], rax
$LN37@hdl_loadmo:
  0062f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv280[rsp]
  00637	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR sev$1[rsp], rax

; 355  : 
; 356  :             // "HDL: dependency check failed for module %s"
; 357  :             WRMSG( HHC01518, sev, mod->name );

  0063f	b9 01 00 00 00	 mov	 ecx, 1
  00644	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0064a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mod$[rsp]
  0064f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00652	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00657	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR sev$1[rsp]
  0065f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00664	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168423
  0066b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00670	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00675	41 b9 03 00 00
	00		 mov	 r9d, 3
  0067b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168424
  00682	ba 65 01 00 00	 mov	 edx, 357		; 00000165H
  00687	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168425
  0068e	e8 00 00 00 00	 call	 fwritemsg

; 358  : 
; 359  :             /* Allow module to be loaded anyway if forced */
; 360  :             if (flags & HDL_LOAD_FORCE)

  00693	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  0069a	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0069f	85 c0		 test	 eax, eax
  006a1	74 16		 je	 SHORT $LN26@hdl_loadmo

; 361  :             {
; 362  :                 /* Remember module was forcibly loaded */
; 363  :                 mod->flags |= HDL_LOAD_WAS_FORCED;

  006a3	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  006a8	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  006ab	0f ba e8 1b	 bts	 eax, 27
  006af	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mod$[rsp]
  006b4	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 364  :             }

  006b7	eb 5f		 jmp	 SHORT $LN27@hdl_loadmo
$LN26@hdl_loadmo:

; 365  :             else /* Abort the module load */
; 366  :             {
; 367  :                 if (mod->inssec_ep)

  006b9	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  006be	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  006c3	74 0e		 je	 SHORT $LN28@hdl_loadmo

; 368  :                     RELEASE_INTLOCK( NULL );

  006c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168429
  006cc	33 c9		 xor	 ecx, ecx
  006ce	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN28@hdl_loadmo:

; 369  :                 release_lock( &hdl_lock );

  006d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168430
  006da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_lock
  006e1	e8 00 00 00 00	 call	 hthread_release_lock

; 370  :                 dlclose( mod->handle );

  006e6	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  006eb	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  006ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FreeLibrary

; 371  :                 free( mod->name );

  006f5	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  006fa	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  006fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 372  :                 free( mod );

  00703	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mod$[rsp]
  00708	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 373  :                 return -1;

  0070e	b8 ff ff ff ff	 mov	 eax, -1
  00713	e9 37 01 00 00	 jmp	 $LN1@hdl_loadmo
$LN27@hdl_loadmo:
$LN25@hdl_loadmo:

; 374  :             }
; 375  :         }
; 376  : 
; 377  :         /* Update the current module pointer for the benefit of the
; 378  :            various module callback functions so they can access and
; 379  :            update the current module's HDLMOD structure.
; 380  :         */
; 381  :         hdl_curmod = mod;

  00718	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  0071d	48 89 05 00 00
	00 00		 mov	 QWORD PTR hdl_curmod, rax

; 382  : 
; 383  :         /* Call the module's HDL_REGISTER_SECTION, if it has one */
; 384  :         if (mod->regsec_ep)

  00724	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  00729	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  0072e	74 0f		 je	 SHORT $LN29@hdl_loadmo

; 385  :             mod->regsec_ep( &hdl_register_symbols_cb );

  00730	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_register_symbols_cb
  00737	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  0073c	ff 50 20	 call	 QWORD PTR [rax+32]
$LN29@hdl_loadmo:

; 386  : 
; 387  :         /* Insert current module at the head of the modules chain */
; 388  :         mod->next = hdl_mods;

  0073f	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  00744	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hdl_mods
  0074b	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 389  :         hdl_mods = mod;

  0074f	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  00754	48 89 05 00 00
	00 00		 mov	 QWORD PTR hdl_mods, rax

; 390  : 
; 391  :         /* Reset symbol loadcounts before re-resolving symbols */
; 392  :         for (wrkmod = hdl_mods; wrkmod; wrkmod = wrkmod->next)

  0075b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_mods
  00762	48 89 44 24 58	 mov	 QWORD PTR wrkmod$[rsp], rax
  00767	eb 0e		 jmp	 SHORT $LN10@hdl_loadmo
$LN8@hdl_loadmo:
  00769	48 8b 44 24 58	 mov	 rax, QWORD PTR wrkmod$[rsp]
  0076e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00772	48 89 44 24 58	 mov	 QWORD PTR wrkmod$[rsp], rax
$LN10@hdl_loadmo:
  00777	48 83 7c 24 58
	00		 cmp	 QWORD PTR wrkmod$[rsp], 0
  0077d	74 36		 je	 SHORT $LN9@hdl_loadmo

; 393  :             for (sym = wrkmod->symbols; sym; sym = sym->next)

  0077f	48 8b 44 24 58	 mov	 rax, QWORD PTR wrkmod$[rsp]
  00784	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  00788	48 89 44 24 68	 mov	 QWORD PTR sym$[rsp], rax
  0078d	eb 0e		 jmp	 SHORT $LN13@hdl_loadmo
$LN11@hdl_loadmo:
  0078f	48 8b 44 24 68	 mov	 rax, QWORD PTR sym$[rsp]
  00794	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00798	48 89 44 24 68	 mov	 QWORD PTR sym$[rsp], rax
$LN13@hdl_loadmo:
  0079d	48 83 7c 24 68
	00		 cmp	 QWORD PTR sym$[rsp], 0
  007a3	74 0e		 je	 SHORT $LN12@hdl_loadmo

; 394  :                 sym->refcnt = 0;

  007a5	48 8b 44 24 68	 mov	 rax, QWORD PTR sym$[rsp]
  007aa	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0
  007b1	eb dc		 jmp	 SHORT $LN11@hdl_loadmo
$LN12@hdl_loadmo:
  007b3	eb b4		 jmp	 SHORT $LN8@hdl_loadmo
$LN9@hdl_loadmo:

; 395  : 
; 396  :         /* Call HDL_RESOLVER_SECTION again for every loaded module */
; 397  :         for (wrkmod = hdl_mods; wrkmod; wrkmod = wrkmod->next)

  007b5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_mods
  007bc	48 89 44 24 58	 mov	 QWORD PTR wrkmod$[rsp], rax
  007c1	eb 0e		 jmp	 SHORT $LN16@hdl_loadmo
$LN14@hdl_loadmo:
  007c3	48 8b 44 24 58	 mov	 rax, QWORD PTR wrkmod$[rsp]
  007c8	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  007cc	48 89 44 24 58	 mov	 QWORD PTR wrkmod$[rsp], rax
$LN16@hdl_loadmo:
  007d1	48 83 7c 24 58
	00		 cmp	 QWORD PTR wrkmod$[rsp], 0
  007d7	74 1d		 je	 SHORT $LN15@hdl_loadmo

; 398  :         {
; 399  :             if (wrkmod->ressec_ep)

  007d9	48 8b 44 24 58	 mov	 rax, QWORD PTR wrkmod$[rsp]
  007de	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  007e3	74 0f		 je	 SHORT $LN30@hdl_loadmo

; 400  :                 wrkmod->ressec_ep( &hdl_resolve_symbols_cb );

  007e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_resolve_symbols_cb
  007ec	48 8b 44 24 58	 mov	 rax, QWORD PTR wrkmod$[rsp]
  007f1	ff 50 28	 call	 QWORD PTR [rax+40]
$LN30@hdl_loadmo:

; 401  :         }

  007f4	eb cd		 jmp	 SHORT $LN14@hdl_loadmo
$LN15@hdl_loadmo:

; 402  : 
; 403  :         /* Call the module's HDL_DEVICE_SECTION, if it has one */
; 404  :         if (mod->devsec_ep)

  007f6	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  007fb	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00800	74 0f		 je	 SHORT $LN31@hdl_loadmo

; 405  :             mod->devsec_ep( &hdl_define_devtypes_cb );

  00802	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_define_devtypes_cb
  00809	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  0080e	ff 50 30	 call	 QWORD PTR [rax+48]
$LN31@hdl_loadmo:

; 406  : 
; 407  :         /* Call the module's HDL_INSTRUCTION_SECTION, if it has one */
; 408  :         if (mod->inssec_ep)

  00811	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  00816	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  0081b	74 1d		 je	 SHORT $LN32@hdl_loadmo

; 409  :         {
; 410  :             mod->inssec_ep( &hdl_define_instructs_cb );

  0081d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_define_instructs_cb
  00824	48 8b 44 24 50	 mov	 rax, QWORD PTR mod$[rsp]
  00829	ff 50 38	 call	 QWORD PTR [rax+56]

; 411  :             RELEASE_INTLOCK( NULL );

  0082c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168435
  00833	33 c9		 xor	 ecx, ecx
  00835	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN32@hdl_loadmo:

; 412  :         }
; 413  :     }
; 414  :     release_lock( &hdl_lock );

  0083a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168436
  00841	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_lock
  00848	e8 00 00 00 00	 call	 hthread_release_lock

; 415  : 
; 416  :     return 0;

  0084d	33 c0		 xor	 eax, eax
$LN1@hdl_loadmo:

; 417  : }

  0084f	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00856	c3		 ret	 0
hdl_loadmod ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
hdl_getpath PROC

; 844  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 845  :     if (!hdl_modpath)           // (if default not set yet)

  00004	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR hdl_modpath, 0
  0000c	75 07		 jne	 SHORT $LN2@hdl_getpat

; 846  :         hdl_initpath( NULL );   // (then initilize default)

  0000e	33 c9		 xor	 ecx, ecx
  00010	e8 00 00 00 00	 call	 hdl_initpath
$LN2@hdl_getpat:

; 847  :     return hdl_modpath;         // (return current value)

  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_modpath

; 848  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
hdl_getpath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
$T1 = 80
$T2 = 88
tv197 = 96
abspath$ = 112
pathname$ = 384
buf$3 = 656
__$ArrayPad$ = 1056
path$ = 1088
hdl_setpath PROC

; 856  : {

$LN20:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 38 04
	00 00		 sub	 rsp, 1080		; 00000438H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 20
	04 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@hdl_setpat:

; 857  :     char    pathname[ MAX_PATH ];       /* pathname conversion       */
; 858  :     char    abspath [ MAX_PATH ];       /* pathname conversion       */
; 859  : 
; 860  :     ASSERT( path );                     /* Sanity check              */

  0001e	48 83 bc 24 40
	04 00 00 00	 cmp	 QWORD PTR path$[rsp], 0
  00027	75 5b		 jne	 SHORT $LN8@hdl_setpat
$LN7@hdl_setpat:
  00029	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168643
  00030	41 b8 5c 03 00
	00		 mov	 r8d, 860		; 0000035cH
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168644
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168645
  00044	e8 00 00 00 00	 call	 logmsg
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0004f	85 c0		 test	 eax, eax
  00051	74 20		 je	 SHORT $LN9@hdl_setpat
  00053	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168647
  0005a	41 b8 5c 03 00
	00		 mov	 r8d, 860		; 0000035cH
  00060	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168648
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168649
  0006e	e8 00 00 00 00	 call	 DebuggerTrace
$LN9@hdl_setpat:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 b0		 jne	 SHORT $LN7@hdl_setpat
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0007f	85 c0		 test	 eax, eax
  00081	74 01		 je	 SHORT $LN10@hdl_setpat
  00083	cc		 int	 3
$LN10@hdl_setpat:
$LN8@hdl_setpat:
  00084	33 c0		 xor	 eax, eax
  00086	85 c0		 test	 eax, eax
  00088	75 94		 jne	 SHORT $LN4@hdl_setpat

; 861  : 
; 862  :     // Reject paths that are too long
; 863  : 
; 864  :     if (strlen( path ) >= MAX_PATH)

  0008a	48 8b 8c 24 40
	04 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  00092	e8 00 00 00 00	 call	 strlen
  00097	48 3d 04 01 00
	00		 cmp	 rax, 260		; 00000104H
  0009d	72 65		 jb	 SHORT $LN11@hdl_setpat

; 865  :     {
; 866  :         // "HDL: directory '%s' rejected; exceeds maximum length of %d"
; 867  :         WRMSG( HHC01505, "E", path, MAX_PATH );

  0009f	b9 01 00 00 00	 mov	 ecx, 1
  000a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000aa	c7 44 24 40 04
	01 00 00	 mov	 DWORD PTR [rsp+64], 260	; 00000104H
  000b2	48 8b 8c 24 40
	04 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  000ba	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168652
  000c6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168653
  000d2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000d7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000dc	41 b9 03 00 00
	00		 mov	 r9d, 3
  000e2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168654
  000e9	ba 63 03 00 00	 mov	 edx, 867		; 00000363H
  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168655
  000f5	e8 00 00 00 00	 call	 fwritemsg

; 868  :         return -1;      // (error; not set)

  000fa	b8 ff ff ff ff	 mov	 eax, -1
  000ff	e9 c5 02 00 00	 jmp	 $LN1@hdl_setpat
$LN11@hdl_setpat:

; 869  :     }
; 870  : 
; 871  :     // Ignore 'modpath_cmd()' when -p cmdline option is specified
; 872  : 
; 873  :     if (hdl_arg_p)

  00104	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR hdl_arg_p
  0010b	85 c0		 test	 eax, eax
  0010d	0f 84 af 00 00
	00		 je	 $LN12@hdl_setpat

; 874  :     {
; 875  :         // "HDL: directory '%s' rejected; '-p' cmdline option rules"
; 876  :         WRMSG( HHC01506, "W", path );

  00113	b9 01 00 00 00	 mov	 ecx, 1
  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0011e	48 8b 8c 24 40
	04 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  00126	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0012b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168657
  00132	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00137	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168658
  0013e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00143	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00148	41 b9 03 00 00
	00		 mov	 r9d, 3
  0014e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168659
  00155	ba 6c 03 00 00	 mov	 edx, 876		; 0000036cH
  0015a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168660
  00161	e8 00 00 00 00	 call	 fwritemsg

; 877  : 
; 878  :         // "HDL: directory remains '%s' from '-p' cmdline option"
; 879  :         WRMSG( HHC01507, "W", hdl_modpath );

  00166	b9 01 00 00 00	 mov	 ecx, 1
  0016b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00171	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hdl_modpath
  00178	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0017d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168661
  00184	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00189	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168662
  00190	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00195	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0019a	41 b9 03 00 00
	00		 mov	 r9d, 3
  001a0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168663
  001a7	ba 6f 03 00 00	 mov	 edx, 879		; 0000036fH
  001ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168664
  001b3	e8 00 00 00 00	 call	 fwritemsg

; 880  :         return +1;      // (warning; not set)

  001b8	b8 01 00 00 00	 mov	 eax, 1
  001bd	e9 07 02 00 00	 jmp	 $LN1@hdl_setpat
$LN12@hdl_setpat:

; 881  :     }
; 882  : 
; 883  :     // Convert path to host format
; 884  : 
; 885  :     hostpath( pathname, path, sizeof( pathname ));

  001c2	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  001c8	48 8b 94 24 40
	04 00 00	 mov	 rdx, QWORD PTR path$[rsp]
  001d0	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  001d8	e8 00 00 00 00	 call	 hostpath

; 886  : 
; 887  :     // Convert path to absolute path if it's relative
; 888  : 
; 889  :     abspath[0] = 0;

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 00	 imul	 rax, rax, 0
  001e6	48 89 44 24 50	 mov	 QWORD PTR $T1[rsp], rax
  001eb	48 81 7c 24 50
	04 01 00 00	 cmp	 QWORD PTR $T1[rsp], 260	; 00000104H
  001f4	73 02		 jae	 SHORT $LN16@hdl_setpat
  001f6	eb 05		 jmp	 SHORT $LN17@hdl_setpat
$LN16@hdl_setpat:
  001f8	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN17@hdl_setpat:
  001fd	48 8b 44 24 50	 mov	 rax, QWORD PTR $T1[rsp]
  00202	c6 44 04 70 00	 mov	 BYTE PTR abspath$[rsp+rax], 0

; 890  : 
; 891  :     if (1
; 892  :         && '.' == pathname[0]               // (relative path?)
; 893  :         && !realpath( pathname, abspath )   // (doesn't exist?)

  00207	33 c0		 xor	 eax, eax
  00209	83 f8 01	 cmp	 eax, 1
  0020c	0f 84 f1 00 00
	00		 je	 $LN13@hdl_setpat
  00212	b8 01 00 00 00	 mov	 eax, 1
  00217	48 6b c0 00	 imul	 rax, rax, 0
  0021b	0f be 84 04 80
	01 00 00	 movsx	 eax, BYTE PTR pathname$[rsp+rax]
  00223	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00226	0f 85 d7 00 00
	00		 jne	 $LN13@hdl_setpat
  0022c	48 8d 54 24 70	 lea	 rdx, QWORD PTR abspath$[rsp]
  00231	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00239	e8 00 00 00 00	 call	 realpath
  0023e	48 85 c0	 test	 rax, rax
  00241	0f 85 bc 00 00
	00		 jne	 $LN13@hdl_setpat

; 894  :     )
; 895  :     {
; 896  :         char buf[ MAX_PATH + 128 ];
; 897  : 
; 898  :         MSGBUF( buf,  "\"%s\": %s", pathname, strerror( errno ));

  00247	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0024d	8b 08		 mov	 ecx, DWORD PTR [rax]
  0024f	e8 00 00 00 00	 call	 w32_strerror
  00254	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00259	4c 8d 8c 24 80
	01 00 00	 lea	 r9, QWORD PTR pathname$[rsp]
  00261	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168666
  00268	ba 84 01 00 00	 mov	 edx, 388		; 00000184H
  0026d	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR buf$3[rsp]
  00275	e8 00 00 00 00	 call	 w32_snprintf

; 899  : 
; 900  :         // "HDL: error in function %s: %s"
; 901  :         WRMSG( HHC01511, "W", "realpath()", buf );

  0027a	b9 01 00 00 00	 mov	 ecx, 1
  0027f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00285	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR buf$3[rsp]
  0028d	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00292	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168667
  00299	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0029e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168668
  002a5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168669
  002b1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002b6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002bb	41 b9 03 00 00
	00		 mov	 r9d, 3
  002c1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168670
  002c8	ba 85 03 00 00	 mov	 edx, 901		; 00000385H
  002cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168671
  002d4	e8 00 00 00 00	 call	 fwritemsg

; 902  :         abspath[0] = 0;

  002d9	b8 01 00 00 00	 mov	 eax, 1
  002de	48 6b c0 00	 imul	 rax, rax, 0
  002e2	48 89 44 24 58	 mov	 QWORD PTR $T2[rsp], rax
  002e7	48 81 7c 24 58
	04 01 00 00	 cmp	 QWORD PTR $T2[rsp], 260	; 00000104H
  002f0	73 02		 jae	 SHORT $LN18@hdl_setpat
  002f2	eb 05		 jmp	 SHORT $LN19@hdl_setpat
$LN18@hdl_setpat:
  002f4	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN19@hdl_setpat:
  002f9	48 8b 44 24 58	 mov	 rax, QWORD PTR $T2[rsp]
  002fe	c6 44 04 70 00	 mov	 BYTE PTR abspath$[rsp+rax], 0
$LN13@hdl_setpat:

; 903  :     }
; 904  : 
; 905  :     // Use unresolved path if unable to resolve to an absolute path
; 906  : 
; 907  :     if (!abspath[0])

  00303	b8 01 00 00 00	 mov	 eax, 1
  00308	48 6b c0 00	 imul	 rax, rax, 0
  0030c	0f be 44 04 70	 movsx	 eax, BYTE PTR abspath$[rsp+rax]
  00311	85 c0		 test	 eax, eax
  00313	75 18		 jne	 SHORT $LN14@hdl_setpat

; 908  :         STRLCPY( abspath, pathname );

  00315	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0031b	48 8d 94 24 80
	01 00 00	 lea	 rdx, QWORD PTR pathname$[rsp]
  00323	48 8d 4c 24 70	 lea	 rcx, QWORD PTR abspath$[rsp]
  00328	e8 00 00 00 00	 call	 strlcpy
$LN14@hdl_setpat:

; 909  : 
; 910  :     // Set the path as requested
; 911  : 
; 912  :     free( hdl_modpath );

  0032d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hdl_modpath
  00334	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 913  :     hdl_modpath = strdup( abspath );

  0033a	48 8d 4c 24 70	 lea	 rcx, QWORD PTR abspath$[rsp]
  0033f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00345	48 89 05 00 00
	00 00		 mov	 QWORD PTR hdl_modpath, rax

; 914  : 
; 915  :     // Update the MODPATH symbol
; 916  : 
; 917  :     set_symbol( "MODPATH", hdl_getpath() );

  0034c	e8 00 00 00 00	 call	 hdl_getpath
  00351	48 8b d0	 mov	 rdx, rax
  00354	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168673
  0035b	e8 00 00 00 00	 call	 set_symbol

; 918  : 
; 919  :     // "HDL: loadable module directory is '%s'"
; 920  :     WRMSG( HHC01508, "I", hdl_getpath() );

  00360	e8 00 00 00 00	 call	 hdl_getpath
  00365	48 89 44 24 60	 mov	 QWORD PTR tv197[rsp], rax
  0036a	b9 01 00 00 00	 mov	 ecx, 1
  0036f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00375	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv197[rsp]
  0037a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0037f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168674
  00386	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0038b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168675
  00392	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00397	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0039c	41 b9 03 00 00
	00		 mov	 r9d, 3
  003a2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168676
  003a9	ba 98 03 00 00	 mov	 edx, 920		; 00000398H
  003ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168677
  003b5	e8 00 00 00 00	 call	 fwritemsg

; 921  : 
; 922  :     // Check path and MAYBE issue HHC01536 warning if it's invalid
; 923  : 
; 924  :     hdl_checkpath( hdl_getpath() );

  003ba	e8 00 00 00 00	 call	 hdl_getpath
  003bf	48 8b c8	 mov	 rcx, rax
  003c2	e8 00 00 00 00	 call	 hdl_checkpath

; 925  : 
; 926  :     return 0;   // (success; set)

  003c7	33 c0		 xor	 eax, eax
$LN1@hdl_setpat:
$LN15@hdl_setpat:

; 927  : }

  003c9	48 8b 8c 24 20
	04 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003d1	48 33 cc	 xor	 rcx, rsp
  003d4	e8 00 00 00 00	 call	 __security_check_cookie
  003d9	48 81 c4 38 04
	00 00		 add	 rsp, 1080		; 00000438H
  003e0	c3		 ret	 0
hdl_setpath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
def$1 = 32
pathname$2 = 48
__$ArrayPad$ = 320
path$ = 352
hdl_initpath PROC

; 786  : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 787  :     free( hdl_modpath );    // (discard old value, if any)

  0001e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hdl_modpath
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 788  : 
; 789  :     // 1) -p from startup
; 790  : 
; 791  :     if (path)

  0002b	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR path$[rsp], 0
  00034	74 21		 je	 SHORT $LN2@hdl_initpa

; 792  :     {
; 793  :         hdl_arg_p = true;  // (remember -p cmdline option specified)

  00036	c6 05 00 00 00
	00 01		 mov	 BYTE PTR hdl_arg_p, 1

; 794  :         hdl_modpath = strdup( path );

  0003d	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0004b	48 89 05 00 00
	00 00		 mov	 QWORD PTR hdl_modpath, rax

; 795  :     }

  00052	e9 b4 00 00 00	 jmp	 $LN3@hdl_initpa
$LN2@hdl_initpa:

; 796  :     else
; 797  :     {
; 798  :         // 2) HERCULES_LIB environment variable
; 799  : 
; 800  :         const char* def;
; 801  :         char pathname[ MAX_PATH ];
; 802  : 
; 803  :         if ((def = get_symbol("HERCULES_LIB")) && *def)

  00057	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168619
  0005e	e8 00 00 00 00	 call	 get_symbol
  00063	48 89 44 24 20	 mov	 QWORD PTR def$1[rsp], rax
  00068	48 83 7c 24 20
	00		 cmp	 QWORD PTR def$1[rsp], 0
  0006e	74 35		 je	 SHORT $LN4@hdl_initpa
  00070	48 8b 44 24 20	 mov	 rax, QWORD PTR def$1[rsp]
  00075	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00078	85 c0		 test	 eax, eax
  0007a	74 29		 je	 SHORT $LN4@hdl_initpa

; 804  :         {
; 805  :             hostpath( pathname, def, sizeof( pathname ));

  0007c	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00082	48 8b 54 24 20	 mov	 rdx, QWORD PTR def$1[rsp]
  00087	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pathname$2[rsp]
  0008c	e8 00 00 00 00	 call	 hostpath

; 806  :             hdl_modpath = strdup( pathname );

  00091	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pathname$2[rsp]
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0009c	48 89 05 00 00
	00 00		 mov	 QWORD PTR hdl_modpath, rax

; 807  :         }

  000a3	eb 66		 jmp	 SHORT $LN5@hdl_initpa
$LN4@hdl_initpa:

; 808  :         else
; 809  :         {
; 810  :             // 3) MODULESDIR compile time define
; 811  : 
; 812  : #if defined( MODULESDIR )
; 813  :             hostpath( pathname, MODULESDIR, sizeof( pathname ));
; 814  :             hdl_modpath = strdup( pathname );
; 815  : #else
; 816  :             // 4) Hercules executable directory
; 817  : 
; 818  :             if (sysblk.hercules_pgmpath && strlen( sysblk.hercules_pgmpath ))

  000a5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ac	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  000b1	74 2f		 je	 SHORT $LN6@hdl_initpa
  000b3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ba	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]
  000be	e8 00 00 00 00	 call	 strlen
  000c3	48 85 c0	 test	 rax, rax
  000c6	74 1a		 je	 SHORT $LN6@hdl_initpa

; 819  :             {
; 820  :                 hdl_modpath = strdup( sysblk.hercules_pgmpath );

  000c8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000cf	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]
  000d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  000d9	48 89 05 00 00
	00 00		 mov	 QWORD PTR hdl_modpath, rax

; 821  :             }

  000e0	eb 29		 jmp	 SHORT $LN7@hdl_initpa
$LN6@hdl_initpa:

; 822  :             else
; 823  :             {
; 824  :                 // 5) "hercules"
; 825  : 
; 826  :                 hostpath( pathname, "hercules", sizeof( pathname ));

  000e2	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  000e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168622
  000ef	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pathname$2[rsp]
  000f4	e8 00 00 00 00	 call	 hostpath

; 827  :                 hdl_modpath = strdup( pathname );

  000f9	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pathname$2[rsp]
  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00104	48 89 05 00 00
	00 00		 mov	 QWORD PTR hdl_modpath, rax
$LN7@hdl_initpa:
$LN5@hdl_initpa:
$LN3@hdl_initpa:

; 828  :             }
; 829  : #endif // defined( MODULESDIR )
; 830  :         }
; 831  :     }
; 832  : 
; 833  :     // Check path and MAYBE issue HHC01536 warning if it's invalid
; 834  : 
; 835  :     hdl_checkpath( hdl_getpath() );

  0010b	e8 00 00 00 00	 call	 hdl_getpath
  00110	48 8b c8	 mov	 rcx, rax
  00113	e8 00 00 00 00	 call	 hdl_checkpath

; 836  : 
; 837  :     set_symbol( "MODPATH", hdl_getpath() );

  00118	e8 00 00 00 00	 call	 hdl_getpath
  0011d	48 8b d0	 mov	 rdx, rax
  00120	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168623
  00127	e8 00 00 00 00	 call	 set_symbol

; 838  : }

  0012c	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00134	48 33 cc	 xor	 rcx, rsp
  00137	e8 00 00 00 00	 call	 __security_check_cookie
  0013c	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  00143	c3		 ret	 0
hdl_initpath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
rc$ = 32
pshut$ = 40
shut$ = 48
shutfunc$ = 80
shutarg$ = 88
hdl_delshut PROC

; 641  : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 642  :     HDLSHUT**  pshut;
; 643  :     HDLSHUT*   shut;
; 644  :     int        rc = -1;

  0000e	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 645  : 
; 646  :     if (hdl_shutting)

  00016	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR hdl_shutting
  0001d	85 c0		 test	 eax, eax
  0001f	74 09		 je	 SHORT $LN5@hdl_delshu

; 647  :         return rc;

  00021	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  00025	e9 8c 00 00 00	 jmp	 $LN1@hdl_delshu
$LN5@hdl_delshu:

; 648  : 
; 649  :     for (pshut = &(hdl_shutlist); *pshut; pshut = &((*pshut)->next) )

  0002a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:hdl_shutlist
  00031	48 89 44 24 28	 mov	 QWORD PTR pshut$[rsp], rax
  00036	eb 0d		 jmp	 SHORT $LN4@hdl_delshu
$LN2@hdl_delshu:
  00038	48 8b 44 24 28	 mov	 rax, QWORD PTR pshut$[rsp]
  0003d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00040	48 89 44 24 28	 mov	 QWORD PTR pshut$[rsp], rax
$LN4@hdl_delshu:
  00045	48 8b 44 24 28	 mov	 rax, QWORD PTR pshut$[rsp]
  0004a	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0004e	74 62		 je	 SHORT $LN3@hdl_delshu

; 650  :     {
; 651  :         if (1
; 652  :             && (*pshut)->shutfunc == shutfunc
; 653  :             && (*pshut)->shutarg  == shutarg

  00050	33 c0		 xor	 eax, eax
  00052	83 f8 01	 cmp	 eax, 1
  00055	74 59		 je	 SHORT $LN6@hdl_delshu
  00057	48 8b 44 24 28	 mov	 rax, QWORD PTR pshut$[rsp]
  0005c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR shutfunc$[rsp]
  00064	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  00068	75 46		 jne	 SHORT $LN6@hdl_delshu
  0006a	48 8b 44 24 28	 mov	 rax, QWORD PTR pshut$[rsp]
  0006f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00072	48 8b 4c 24 58	 mov	 rcx, QWORD PTR shutarg$[rsp]
  00077	48 39 48 18	 cmp	 QWORD PTR [rax+24], rcx
  0007b	75 33		 jne	 SHORT $LN6@hdl_delshu

; 654  :         )
; 655  :         {
; 656  :             shut = *pshut;

  0007d	48 8b 44 24 28	 mov	 rax, QWORD PTR pshut$[rsp]
  00082	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00085	48 89 44 24 30	 mov	 QWORD PTR shut$[rsp], rax

; 657  :             {
; 658  :                 *pshut = (*pshut)->next;

  0008a	48 8b 44 24 28	 mov	 rax, QWORD PTR pshut$[rsp]
  0008f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00092	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pshut$[rsp]
  00097	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 659  :             }
; 660  :             free( shut );

  0009d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR shut$[rsp]
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 661  : 
; 662  :             rc = 0;

  000a8	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
$LN6@hdl_delshu:

; 663  :         }
; 664  :     }

  000b0	eb 86		 jmp	 SHORT $LN2@hdl_delshu
$LN3@hdl_delshu:

; 665  :     return rc;

  000b2	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@hdl_delshu:

; 666  : }

  000b6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ba	c3		 ret	 0
hdl_delshut ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
pshut$ = 32
shut$ = 40
shutname$ = 64
shutfunc$ = 72
shutarg$ = 80
hdl_addshut PROC

; 608  : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 609  :     HDLSHUT*   shut;
; 610  :     HDLSHUT**  pshut;
; 611  : 
; 612  :     if (hdl_shutting)

  00013	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR hdl_shutting
  0001a	85 c0		 test	 eax, eax
  0001c	74 05		 je	 SHORT $LN5@hdl_addshu

; 613  :         return;

  0001e	e9 ac 00 00 00	 jmp	 $LN1@hdl_addshu
$LN5@hdl_addshu:

; 614  : 
; 615  :     /* avoid duplicates - keep the first one */
; 616  :     for (pshut = &(hdl_shutlist); *pshut; pshut = &((*pshut)->next) )

  00023	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:hdl_shutlist
  0002a	48 89 44 24 20	 mov	 QWORD PTR pshut$[rsp], rax
  0002f	eb 0d		 jmp	 SHORT $LN4@hdl_addshu
$LN2@hdl_addshu:
  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR pshut$[rsp]
  00036	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00039	48 89 44 24 20	 mov	 QWORD PTR pshut$[rsp], rax
$LN4@hdl_addshu:
  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR pshut$[rsp]
  00043	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00047	74 31		 je	 SHORT $LN3@hdl_addshu

; 617  :     {
; 618  :         if (1
; 619  :             && (*pshut)->shutfunc == shutfunc
; 620  :             && (*pshut)->shutarg  == shutarg

  00049	33 c0		 xor	 eax, eax
  0004b	83 f8 01	 cmp	 eax, 1
  0004e	74 28		 je	 SHORT $LN6@hdl_addshu
  00050	48 8b 44 24 20	 mov	 rax, QWORD PTR pshut$[rsp]
  00055	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00058	48 8b 4c 24 48	 mov	 rcx, QWORD PTR shutfunc$[rsp]
  0005d	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  00061	75 15		 jne	 SHORT $LN6@hdl_addshu
  00063	48 8b 44 24 20	 mov	 rax, QWORD PTR pshut$[rsp]
  00068	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR shutarg$[rsp]
  00070	48 39 48 18	 cmp	 QWORD PTR [rax+24], rcx
  00074	75 02		 jne	 SHORT $LN6@hdl_addshu

; 621  :         )
; 622  :             return;

  00076	eb 57		 jmp	 SHORT $LN1@hdl_addshu
$LN6@hdl_addshu:

; 623  :     }

  00078	eb b7		 jmp	 SHORT $LN2@hdl_addshu
$LN3@hdl_addshu:

; 624  : 
; 625  :     /* Add new entry to head of list (LIFO) */
; 626  : 
; 627  :     shut = malloc( sizeof( HDLSHUT ));

  0007a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00085	48 89 44 24 28	 mov	 QWORD PTR shut$[rsp], rax

; 628  : 
; 629  :     shut->next      =  hdl_shutlist;

  0008a	48 8b 44 24 28	 mov	 rax, QWORD PTR shut$[rsp]
  0008f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hdl_shutlist
  00096	48 89 08	 mov	 QWORD PTR [rax], rcx

; 630  :     shut->shutname  =  shutname;

  00099	48 8b 44 24 28	 mov	 rax, QWORD PTR shut$[rsp]
  0009e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR shutname$[rsp]
  000a3	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 631  :     shut->shutfunc  =  shutfunc;

  000a7	48 8b 44 24 28	 mov	 rax, QWORD PTR shut$[rsp]
  000ac	48 8b 4c 24 48	 mov	 rcx, QWORD PTR shutfunc$[rsp]
  000b1	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 632  :     shut->shutarg   =  shutarg;

  000b5	48 8b 44 24 28	 mov	 rax, QWORD PTR shut$[rsp]
  000ba	48 8b 4c 24 50	 mov	 rcx, QWORD PTR shutarg$[rsp]
  000bf	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 633  : 
; 634  :     hdl_shutlist = shut;

  000c3	48 8b 44 24 28	 mov	 rax, QWORD PTR shut$[rsp]
  000c8	48 89 05 00 00
	00 00		 mov	 QWORD PTR hdl_shutlist, rax
$LN1@hdl_addshu:

; 635  : }

  000cf	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d3	c3		 ret	 0
hdl_addshut ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
shut$ = 64
hdl_atexit PROC

; 672  : {

$LN11:
  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 673  :     HDLSHUT*  shut;
; 674  : 
; 675  :     if (hdl_shutting)

  00004	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR hdl_shutting
  0000b	85 c0		 test	 eax, eax
  0000d	74 05		 je	 SHORT $LN5@hdl_atexit

; 676  :         return;

  0000f	e9 e9 01 00 00	 jmp	 $LN1@hdl_atexit
$LN5@hdl_atexit:

; 677  : 
; 678  :     if (MLVL( DEBUG ))

  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001b	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  00021	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00026	85 c0		 test	 eax, eax
  00028	74 46		 je	 SHORT $LN6@hdl_atexit

; 679  :         // "HDL: begin shutdown sequence"
; 680  :         WRMSG( HHC01500, "I" );

  0002a	b9 01 00 00 00	 mov	 ecx, 1
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168572
  0003c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168573
  00048	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0004d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00052	41 b9 03 00 00
	00		 mov	 r9d, 3
  00058	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168574
  0005f	ba a8 02 00 00	 mov	 edx, 680		; 000002a8H
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168575
  0006b	e8 00 00 00 00	 call	 fwritemsg
$LN6@hdl_atexit:

; 681  : 
; 682  :     hdl_shutting = true;

  00070	c6 05 00 00 00
	00 01		 mov	 BYTE PTR hdl_shutting, 1

; 683  : 
; 684  :     for (shut = hdl_shutlist; shut; shut = hdl_shutlist)

  00077	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_shutlist
  0007e	48 89 44 24 40	 mov	 QWORD PTR shut$[rsp], rax
  00083	eb 0c		 jmp	 SHORT $LN4@hdl_atexit
$LN2@hdl_atexit:
  00085	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_shutlist
  0008c	48 89 44 24 40	 mov	 QWORD PTR shut$[rsp], rax
$LN4@hdl_atexit:
  00091	48 83 7c 24 40
	00		 cmp	 QWORD PTR shut$[rsp], 0
  00097	0f 84 04 01 00
	00		 je	 $LN3@hdl_atexit

; 685  :     {
; 686  :         /* Remove shutdown call entry to ensure it is called once */
; 687  :         hdl_shutlist = shut->next;

  0009d	48 8b 44 24 40	 mov	 rax, QWORD PTR shut$[rsp]
  000a2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a5	48 89 05 00 00
	00 00		 mov	 QWORD PTR hdl_shutlist, rax

; 688  :         {
; 689  :             if (MLVL( DEBUG ))

  000ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000b3	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  000b9	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  000be	85 c0		 test	 eax, eax
  000c0	74 54		 je	 SHORT $LN7@hdl_atexit

; 690  :                 // "HDL: calling %s"
; 691  :                 WRMSG( HHC01501, "I", shut->shutname );

  000c2	b9 01 00 00 00	 mov	 ecx, 1
  000c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000cd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR shut$[rsp]
  000d2	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000d6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168577
  000e2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168578
  000ee	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000f3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f8	41 b9 03 00 00
	00		 mov	 r9d, 3
  000fe	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168579
  00105	ba b3 02 00 00	 mov	 edx, 691		; 000002b3H
  0010a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168580
  00111	e8 00 00 00 00	 call	 fwritemsg
$LN7@hdl_atexit:

; 692  : 
; 693  :             shut->shutfunc( shut->shutarg );

  00116	48 8b 44 24 40	 mov	 rax, QWORD PTR shut$[rsp]
  0011b	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0011f	48 8b 44 24 40	 mov	 rax, QWORD PTR shut$[rsp]
  00124	ff 50 10	 call	 QWORD PTR [rax+16]

; 694  : 
; 695  :             if (MLVL( DEBUG ))

  00127	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0012e	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  00134	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00139	85 c0		 test	 eax, eax
  0013b	74 54		 je	 SHORT $LN8@hdl_atexit

; 696  :                 // "HDL: %s complete"
; 697  :                 WRMSG( HHC01502, "I", shut->shutname );

  0013d	b9 01 00 00 00	 mov	 ecx, 1
  00142	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00148	48 8b 4c 24 40	 mov	 rcx, QWORD PTR shut$[rsp]
  0014d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00151	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00156	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168582
  0015d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00162	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168583
  00169	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0016e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00173	41 b9 03 00 00
	00		 mov	 r9d, 3
  00179	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168584
  00180	ba b9 02 00 00	 mov	 edx, 697		; 000002b9H
  00185	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168585
  0018c	e8 00 00 00 00	 call	 fwritemsg
$LN8@hdl_atexit:

; 698  :         }
; 699  :         free( shut );

  00191	48 8b 4c 24 40	 mov	 rcx, QWORD PTR shut$[rsp]
  00196	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 700  :     }

  0019c	e9 e4 fe ff ff	 jmp	 $LN2@hdl_atexit
$LN3@hdl_atexit:

; 701  : 
; 702  :     if (MLVL( DEBUG ))

  001a1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001a8	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  001ae	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  001b3	85 c0		 test	 eax, eax
  001b5	74 46		 je	 SHORT $LN9@hdl_atexit

; 703  :         // "HDL: shutdown sequence complete"
; 704  :         WRMSG( HHC01504, "I" );

  001b7	b9 01 00 00 00	 mov	 ecx, 1
  001bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168587
  001c9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168588
  001d5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001df	41 b9 03 00 00
	00		 mov	 r9d, 3
  001e5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168589
  001ec	ba c0 02 00 00	 mov	 edx, 704		; 000002c0H
  001f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168590
  001f8	e8 00 00 00 00	 call	 fwritemsg
$LN9@hdl_atexit:
$LN1@hdl_atexit:

; 705  : }

  001fd	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00201	c3		 ret	 0
hdl_atexit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hdl.c
_TEXT	SEGMENT
preload$ = 80
tv73 = 88
buf$1 = 96
__$ArrayPad$ = 160
real_pandisp$ = 192
real_pancmd$ = 200
real_repopcode$ = 208
real_ckd_DEVHND$ = 216
real_fba_DEVHND$ = 224
hdl_main PROC

; 87   : {

$LN16:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 88   :     /* Called ONCE by impl.c during Hercules startup */
; 89   : 
; 90   :     HDLPRE*  preload;
; 91   :     initialize_lock( &hdl_lock );

  0002d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168261
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168262
  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_lock
  00042	e8 00 00 00 00	 call	 hthread_initialize_lock

; 92   :     hdl_shutting = false;

  00047	c6 05 00 00 00
	00 00		 mov	 BYTE PTR hdl_shutting, 0

; 93   :     dlinit();
; 94   : 
; 95   :     /*
; 96   :     **  Save the pointers that were passed to us by impl.c.
; 97   :     **  Our internal entry-point functions need these pointers.
; 98   :     */
; 99   :     hdl_real_pandisp    = real_pandisp;     /*  real panel_display   */

  0004e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR real_pandisp$[rsp]
  00056	48 89 05 00 00
	00 00		 mov	 QWORD PTR hdl_real_pandisp, rax

; 100  :     hdl_real_pancmd     = real_pancmd;      /*  real panel_command   */

  0005d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR real_pancmd$[rsp]
  00065	48 89 05 00 00
	00 00		 mov	 QWORD PTR hdl_real_pancmd, rax

; 101  :     hdl_real_repopcode  = real_repopcode;   /*  real replace_opcode  */

  0006c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR real_repopcode$[rsp]
  00074	48 89 05 00 00
	00 00		 mov	 QWORD PTR hdl_real_repopcode, rax

; 102  :     hdl_real_ckd_DEVHND = real_ckd_DEVHND;  /*  CKD devices DEVHND   */

  0007b	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR real_ckd_DEVHND$[rsp]
  00083	48 89 05 00 00
	00 00		 mov	 QWORD PTR hdl_real_ckd_DEVHND, rax

; 103  :     hdl_real_fba_DEVHND = real_fba_DEVHND ; /*  FBA devices DEVHND   */

  0008a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR real_fba_DEVHND$[rsp]
  00092	48 89 05 00 00
	00 00		 mov	 QWORD PTR hdl_real_fba_DEVHND, rax

; 104  : 
; 105  :     /*
; 106  :     **  Manually create the main Hercules executable HDLMOD entry
; 107  :     **  and insert it as the first entry in our HDL modules chain.
; 108  :     **  This eliminates the issue of needing to do dlopen( self ).
; 109  :     */
; 110  :     if (!(hdl_curmod = malloc( sizeof( HDLMOD ))))

  00099	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000a4	48 89 05 00 00
	00 00		 mov	 QWORD PTR hdl_curmod, rax
  000ab	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR hdl_curmod, 0
  000b3	0f 85 92 00 00
	00		 jne	 $LN11@hdl_main

; 111  :     {
; 112  :         char buf[64];
; 113  :         MSGBUF( buf,  "malloc(%d)", (int) sizeof( HDLMOD ));

  000b9	41 b9 68 00 00
	00		 mov	 r9d, 104		; 00000068H
  000bf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168264
  000c6	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  000cb	48 8d 4c 24 60	 lea	 rcx, QWORD PTR buf$1[rsp]
  000d0	e8 00 00 00 00	 call	 w32_snprintf

; 114  :         // "HDL: error in function %s: %s"
; 115  :         WRMSG( HHC01511, "S", buf, strerror( errno ));

  000d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000db	8b 08		 mov	 ecx, DWORD PTR [rax]
  000dd	e8 00 00 00 00	 call	 w32_strerror
  000e2	48 89 44 24 58	 mov	 QWORD PTR tv73[rsp], rax
  000e7	b9 01 00 00 00	 mov	 ecx, 1
  000ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000f2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv73[rsp]
  000f7	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000fc	48 8d 4c 24 60	 lea	 rcx, QWORD PTR buf$1[rsp]
  00101	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00106	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168265
  0010d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00112	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168266
  00119	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0011e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00123	41 b9 03 00 00
	00		 mov	 r9d, 3
  00129	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168267
  00130	ba 73 00 00 00	 mov	 edx, 115		; 00000073H
  00135	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168268
  0013c	e8 00 00 00 00	 call	 fwritemsg

; 116  :         return -1;

  00141	b8 ff ff ff ff	 mov	 eax, -1
  00146	e9 e9 01 00 00	 jmp	 $LN1@hdl_main
$LN11@hdl_main:

; 117  :     }
; 118  : 
; 119  :     hdl_curmod->name       =  strdup( "*Hercules" );

  0014b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168269
  00152	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00158	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hdl_curmod
  0015f	48 89 01	 mov	 QWORD PTR [rcx], rax

; 120  :     hdl_curmod->flags      =  (HDL_LOAD_MAIN | HDL_LOAD_NOUNLOAD);

  00162	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_curmod
  00169	c7 40 10 00 00
	00 c0		 mov	 DWORD PTR [rax+16], -1073741824 ; ffffffffc0000000H

; 121  : 
; 122  :     hdl_curmod->depsec_ep  =  hdl_check_depends_ep;

  00170	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_curmod
  00177	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_check_depends_ep
  0017e	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 123  :     hdl_curmod->regsec_ep  =  hdl_register_symbols_ep;

  00182	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_curmod
  00189	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_register_symbols_ep
  00190	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 124  :     hdl_curmod->ressec_ep  =  hdl_resolve_symbols_ep;

  00194	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_curmod
  0019b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_resolve_symbols_ep
  001a2	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 125  :     hdl_curmod->devsec_ep  =  hdl_define_devtypes_ep;

  001a6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_curmod
  001ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_define_devtypes_ep
  001b4	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 126  :     hdl_curmod->inssec_ep  =  NULL;

  001b8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_curmod
  001bf	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 127  :     hdl_curmod->finsec_ep  =  NULL;

  001c7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_curmod
  001ce	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0

; 128  : 
; 129  :     hdl_curmod->symbols    =  NULL;

  001d6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_curmod
  001dd	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0

; 130  :     hdl_curmod->devices    =  NULL;

  001e5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_curmod
  001ec	48 c7 40 50 00
	00 00 00	 mov	 QWORD PTR [rax+80], 0

; 131  :     hdl_curmod->instructs  =  NULL;

  001f4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_curmod
  001fb	48 c7 40 58 00
	00 00 00	 mov	 QWORD PTR [rax+88], 0

; 132  :     hdl_curmod->next       =  hdl_mods;

  00203	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_curmod
  0020a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hdl_mods
  00211	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 133  :     hdl_mods               =  hdl_curmod;

  00215	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hdl_curmod
  0021c	48 89 05 00 00
	00 00		 mov	 QWORD PTR hdl_mods, rax
$LN4@hdl_main:

; 134  : 
; 135  :     /* Create default dependency chain */
; 136  :     VERIFY( hdl_check_depends_ep( &hdl_check_depends_cb ) == 0);

  00223	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_check_depends_cb
  0022a	e8 00 00 00 00	 call	 hdl_check_depends_ep
  0022f	85 c0		 test	 eax, eax
  00231	74 5b		 je	 SHORT $LN12@hdl_main
$LN7@hdl_main:
  00233	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168271
  0023a	41 b8 88 00 00
	00		 mov	 r8d, 136		; 00000088H
  00240	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168272
  00247	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168273
  0024e	e8 00 00 00 00	 call	 logmsg
  00253	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00259	85 c0		 test	 eax, eax
  0025b	74 20		 je	 SHORT $LN13@hdl_main
  0025d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168275
  00264	41 b8 88 00 00
	00		 mov	 r8d, 136		; 00000088H
  0026a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168276
  00271	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168277
  00278	e8 00 00 00 00	 call	 DebuggerTrace
$LN13@hdl_main:
  0027d	33 c0		 xor	 eax, eax
  0027f	85 c0		 test	 eax, eax
  00281	75 b0		 jne	 SHORT $LN7@hdl_main
  00283	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00289	85 c0		 test	 eax, eax
  0028b	74 01		 je	 SHORT $LN14@hdl_main
  0028d	cc		 int	 3
$LN14@hdl_main:
$LN12@hdl_main:
  0028e	33 c0		 xor	 eax, eax
  00290	85 c0		 test	 eax, eax
  00292	75 8f		 jne	 SHORT $LN4@hdl_main

; 137  : 
; 138  :     /*
; 139  :     **  Create an initial symbols list by manualy registering
; 140  :     **  and resolving all symbols needed for proper HDL support.
; 141  :     */
; 142  :     obtain_lock( &hdl_lock );

  00294	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168279
  0029b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_lock
  002a2	e8 00 00 00 00	 call	 hthread_obtain_lock

; 143  :     {
; 144  :         hdl_register_symbols_ep ( &hdl_register_symbols_cb );

  002a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_register_symbols_cb
  002ae	e8 00 00 00 00	 call	 hdl_register_symbols_ep

; 145  :         hdl_resolve_symbols_ep  ( &hdl_resolve_symbols_cb  );

  002b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_resolve_symbols_cb
  002ba	e8 00 00 00 00	 call	 hdl_resolve_symbols_ep

; 146  :         hdl_define_devtypes_ep  ( &hdl_define_devtypes_cb  );

  002bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_define_devtypes_cb
  002c6	e8 00 00 00 00	 call	 hdl_define_devtypes_ep

; 147  :     }
; 148  :     release_lock( &hdl_lock );

  002cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168280
  002d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hdl_lock
  002d9	e8 00 00 00 00	 call	 hthread_release_lock

; 149  : 
; 150  :     /* Register our termination routine */
; 151  :     hdl_addshut( "hdl_term", hdl_term, NULL );

  002de	45 33 c0	 xor	 r8d, r8d
  002e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:hdl_term
  002e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168281
  002ef	e8 00 00 00 00	 call	 hdl_addshut

; 152  : 
; 153  :     /* Pre-load all HDL modules that must be loaded at startup */
; 154  :     for (preload = hdl_preload; preload->name; preload++)

  002f4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:hdl_preload
  002fb	48 89 44 24 50	 mov	 QWORD PTR preload$[rsp], rax
  00300	eb 0e		 jmp	 SHORT $LN10@hdl_main
$LN8@hdl_main:
  00302	48 8b 44 24 50	 mov	 rax, QWORD PTR preload$[rsp]
  00307	48 83 c0 10	 add	 rax, 16
  0030b	48 89 44 24 50	 mov	 QWORD PTR preload$[rsp], rax
$LN10@hdl_main:
  00310	48 8b 44 24 50	 mov	 rax, QWORD PTR preload$[rsp]
  00315	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00319	74 17		 je	 SHORT $LN9@hdl_main

; 155  :         hdl_loadmod( preload->name, preload->flag );

  0031b	48 8b 44 24 50	 mov	 rax, QWORD PTR preload$[rsp]
  00320	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  00323	48 8b 44 24 50	 mov	 rax, QWORD PTR preload$[rsp]
  00328	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0032b	e8 00 00 00 00	 call	 hdl_loadmod
  00330	eb d0		 jmp	 SHORT $LN8@hdl_main
$LN9@hdl_main:

; 156  : 
; 157  :     return 0;

  00332	33 c0		 xor	 eax, eax
$LN1@hdl_main:

; 158  : }

  00334	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0033c	48 33 cc	 xor	 rcx, rsp
  0033f	e8 00 00 00 00	 call	 __security_check_cookie
  00344	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0034b	c3		 ret	 0
hdl_main ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
