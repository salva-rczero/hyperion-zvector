; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	captured_zpsw:BYTE:028H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	load_ipl
PUBLIC	s370_load_ipl
PUBLIC	system_reset
PUBLIC	s370_system_reset
PUBLIC	cpu_reset
PUBLIC	s370_cpu_reset
PUBLIC	initial_cpu_reset_all
PUBLIC	initial_cpu_reset
PUBLIC	s370_initial_cpu_reset
PUBLIC	s370_common_load_begin
PUBLIC	s370_common_load_finish
PUBLIC	storage_clear
PUBLIC	xstorage_clear
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	_get_storekey_ptr
PUBLIC	_get_storekey1_ptr
PUBLIC	_get_storekey2_ptr
PUBLIC	s370__or_storage_key
PUBLIC	s370_or_2K_storage_key
PUBLIC	s370_or_storage_key
PUBLIC	s390_load_ipl
PUBLIC	s390_system_reset
PUBLIC	s390_cpu_reset
PUBLIC	s390_initial_cpu_reset
PUBLIC	s390_common_load_begin
PUBLIC	s390_common_load_finish
PUBLIC	s390__or_storage_key
PUBLIC	s390_or_4K_storage_key
PUBLIC	s390_or_storage_key
PUBLIC	z900_load_ipl
PUBLIC	z900_system_reset
PUBLIC	z900_cpu_reset
PUBLIC	z900_initial_cpu_reset
PUBLIC	z900_common_load_begin
PUBLIC	z900_common_load_finish
PUBLIC	z900__or_storage_key
PUBLIC	z900_or_4K_storage_key
PUBLIC	z900_or_storage_key
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_ptt_pthread_trace:PROC
EXTRN	__imp_strlcat:PROC
EXTRN	__imp_ptyp2short:PROC
EXTRN	__imp_usleep:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	s370_store_int_timer_locked:PROC
EXTRN	set_cpu_timer:PROC
EXTRN	set_int_timer:PROC
EXTRN	thread_cputime_us:PROC
EXTRN	s370_execute_ccw_chain:PROC
EXTRN	s390_execute_ccw_chain:PROC
EXTRN	z900_execute_ccw_chain:PROC
EXTRN	io_reset:PROC
EXTRN	s370_load_psw:PROC
EXTRN	s390_load_psw:PROC
EXTRN	z900_load_psw:PROC
EXTRN	find_device_by_devnum:PROC
EXTRN	configure_cpu:PROC
EXTRN	setCpuIdregs:PROC
EXTRN	renew_wrapping_keys:PROC
EXTRN	Dequeue_IO_Interrupt_QLocked:PROC
EXTRN	s370_purge_tlb:PROC
EXTRN	s390_purge_tlb:PROC
EXTRN	z900_purge_tlb:PROC
EXTRN	s390_purge_alb:PROC
EXTRN	z900_purge_alb:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	get_arch_name:PROC
EXTRN	init_cpu_facilities:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_pttclass:QWORD
EXTRN	__imp_sysblk:BYTE
EXTRN	__imp_debug_cpu_state:QWORD
EXTRN	__security_cookie:QWORD
pdata	SEGMENT
$pdata$load_ipl DD imagerel $LN12
	DD	imagerel $LN12+197
	DD	imagerel $unwind$load_ipl
$pdata$s370_load_ipl DD imagerel $LN22
	DD	imagerel $LN22+2135
	DD	imagerel $unwind$s370_load_ipl
$pdata$system_reset DD imagerel $LN12
	DD	imagerel $LN12+195
	DD	imagerel $unwind$system_reset
$pdata$s370_system_reset DD imagerel $LN63
	DD	imagerel $LN63+2044
	DD	imagerel $unwind$s370_system_reset
$pdata$cpu_reset DD imagerel $LN12
	DD	imagerel $LN12+132
	DD	imagerel $unwind$cpu_reset
$pdata$s370_cpu_reset DD imagerel $LN11
	DD	imagerel $LN11+548
	DD	imagerel $unwind$s370_cpu_reset
$pdata$initial_cpu_reset_all DD imagerel $LN8
	DD	imagerel $LN8+124
	DD	imagerel $unwind$initial_cpu_reset_all
$pdata$initial_cpu_reset DD imagerel $LN12
	DD	imagerel $LN12+132
	DD	imagerel $unwind$initial_cpu_reset
$pdata$s370_initial_cpu_reset DD imagerel $LN11
	DD	imagerel $LN11+700
	DD	imagerel $unwind$s370_initial_cpu_reset
$pdata$s370_common_load_begin DD imagerel $LN12
	DD	imagerel $LN12+406
	DD	imagerel $unwind$s370_common_load_begin
$pdata$s370_common_load_finish DD imagerel $LN8
	DD	imagerel $LN8+870
	DD	imagerel $unwind$s370_common_load_finish
$pdata$storage_clear DD imagerel $LN6
	DD	imagerel $LN6+185
	DD	imagerel $unwind$storage_clear
$pdata$xstorage_clear DD imagerel $LN5
	DD	imagerel $LN5+128
	DD	imagerel $unwind$xstorage_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$wakeup_cpu DD imagerel wakeup_cpu
	DD	imagerel wakeup_cpu+44
	DD	imagerel $unwind$wakeup_cpu
$pdata$Interrupt_Lock_Obtained DD imagerel Interrupt_Lock_Obtained
	DD	imagerel Interrupt_Lock_Obtained+269
	DD	imagerel $unwind$Interrupt_Lock_Obtained
$pdata$Obtain_Interrupt_Lock DD imagerel Obtain_Interrupt_Lock
	DD	imagerel Obtain_Interrupt_Lock+88
	DD	imagerel $unwind$Obtain_Interrupt_Lock
$pdata$Release_Interrupt_Lock DD imagerel Release_Interrupt_Lock
	DD	imagerel Release_Interrupt_Lock+71
	DD	imagerel $unwind$Release_Interrupt_Lock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_get_storekey_ptr DD imagerel $LN5
	DD	imagerel $LN5+104
	DD	imagerel $unwind$_get_storekey_ptr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+170
	DD	imagerel $unwind$s370__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_or_2K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$s370_or_2K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$s370_or_storage_key
pdata	ENDS
pdata	SEGMENT
$pdata$cpu_reset_instcount_and_cputime DD imagerel cpu_reset_instcount_and_cputime
	DD	imagerel cpu_reset_instcount_and_cputime+159
	DD	imagerel $unwind$cpu_reset_instcount_and_cputime
$pdata$subsystem_reset DD imagerel subsystem_reset
	DD	imagerel subsystem_reset+422
	DD	imagerel $unwind$subsystem_reset
$pdata$s390_load_ipl DD imagerel $LN20
	DD	imagerel $LN20+2119
	DD	imagerel $unwind$s390_load_ipl
$pdata$s390_system_reset DD imagerel $LN63
	DD	imagerel $LN63+2044
	DD	imagerel $unwind$s390_system_reset
$pdata$s390_cpu_reset DD imagerel $LN11
	DD	imagerel $LN11+548
	DD	imagerel $unwind$s390_cpu_reset
$pdata$s390_initial_cpu_reset DD imagerel $LN9
	DD	imagerel $LN9+607
	DD	imagerel $unwind$s390_initial_cpu_reset
$pdata$s390_common_load_begin DD imagerel $LN12
	DD	imagerel $LN12+406
	DD	imagerel $unwind$s390_common_load_begin
$pdata$s390_common_load_finish DD imagerel $LN8
	DD	imagerel $LN8+870
	DD	imagerel $unwind$s390_common_load_finish
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$s390__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$s390_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$s390_or_storage_key
pdata	ENDS
pdata	SEGMENT
$pdata$z900_load_ipl DD imagerel $LN20
	DD	imagerel $LN20+2118
	DD	imagerel $unwind$z900_load_ipl
$pdata$z900_system_reset DD imagerel $LN63
	DD	imagerel $LN63+2078
	DD	imagerel $unwind$z900_system_reset
$pdata$z900_cpu_reset DD imagerel $LN15
	DD	imagerel $LN15+688
	DD	imagerel $unwind$z900_cpu_reset
$pdata$z900_initial_cpu_reset DD imagerel $LN13
	DD	imagerel $LN13+801
	DD	imagerel $unwind$z900_initial_cpu_reset
$pdata$z900_common_load_begin DD imagerel $LN12
	DD	imagerel $LN12+406
	DD	imagerel $unwind$z900_common_load_begin
$pdata$z900_common_load_finish DD imagerel $LN8
	DD	imagerel $LN8+870
	DD	imagerel $unwind$z900_common_load_finish
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$z900__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$z900_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$z900_or_storage_key
pdata	ENDS
_DATA	SEGMENT
$SG169570 DB	'ipl.c:89', 00H
	ORG $+7
$SG169571 DB	'ipl.c:93', 00H
	ORG $+3
$SG169667 DB	'E', 00H
	ORG $+2
$SG169645 DB	'ipl.c:157', 00H
	ORG $+2
$SG169738 DB	'E', 00H
	ORG $+2
$SG169646 DB	'ipl.c:159', 00H
	ORG $+2
$SG169744 DB	'E', 00H
	ORG $+2
$SG169647 DB	'ipl.c:161', 00H
	ORG $+2
$SG169760 DB	' ', 00H
	ORG $+2
$SG169657 DB	'ipl.c:193', 00H
	ORG $+2
$SG169762 DB	'E', 00H
	ORG $+2
$SG169658 DB	'ipl.c:198', 00H
	ORG $+2
$SG169778 DB	'E', 00H
	ORG $+2
$SG169659 DB	'ipl.c:200', 00H
	ORG $+2
$SG179936 DB	'E', 00H
	ORG $+2
$SG169660 DB	'ipl.c:202', 00H
	ORG $+2
$SG180006 DB	'E', 00H
	ORG $+2
$SG169663 DB	'ipl.c:227', 00H
	ORG $+2
$SG180012 DB	'E', 00H
	ORG $+2
$SG169664 DB	'ipl.c:231', 00H
	ORG $+2
$SG180028 DB	' ', 00H
	ORG $+2
$SG169666 DB	'Could not perform reset within three seconds', 00H
	ORG $+3
$SG169668 DB	'HHC90000%s DBG: %s', 0aH, 00H
$SG180030 DB	'E', 00H
	ORG $+2
$SG169669 DB	's370_system_reset', 00H
	ORG $+2
$SG169670 DB	'ipl.c', 00H
	ORG $+2
$SG180044 DB	'E', 00H
	ORG $+2
$SG169737 DB	'CP%2.2X Offline', 00H
$SG169739 DB	'HHC00810%s Processor %s%02X: ipl failed: %s', 0aH, 00H
	ORG $+3
$SG169740 DB	's370_load_ipl', 00H
	ORG $+2
$SG169741 DB	'ipl.c', 00H
	ORG $+2
$SG169743 DB	'device %1d:%04X not found', 00H
	ORG $+2
$SG193078 DB	'E', 00H
	ORG $+2
$SG169745 DB	'HHC00810%s Processor %s%02X: ipl failed: %s', 0aH, 00H
	ORG $+3
$SG169746 DB	's370_load_ipl', 00H
	ORG $+2
$SG169747 DB	'ipl.c', 00H
	ORG $+2
$SG169749 DB	'ipl.c:487', 00H
	ORG $+2
$SG193148 DB	'E', 00H
	ORG $+2
$SG169750 DB	'ipl.c:492', 00H
	ORG $+2
$SG193154 DB	'E', 00H
	ORG $+2
$SG169751 DB	'ipl.c:495', 00H
	ORG $+2
$SG193170 DB	' ', 00H
	ORG $+2
$SG169752 DB	'ipl.c:496', 00H
	ORG $+2
$SG193172 DB	'E', 00H
	ORG $+2
$SG169753 DB	'ipl.c:497', 00H
	ORG $+2
$SG193186 DB	'E', 00H
	ORG $+2
$SG169754 DB	'ipl.c:498', 00H
	ORG $+6
$SG169755 DB	'ipl.c:499', 00H
	ORG $+2
$SG169758 DB	'%2.2X', 00H
	ORG $+6
$SG169761 DB	'architecture mode %s, csw status %2.2X%2.2X, sense %s', 00H
	ORG $+2
$SG169763 DB	'HHC00828%s Processor %s%02X: ipl failed: %s', 0aH, 00H
	ORG $+3
$SG169764 DB	's370_load_ipl', 00H
	ORG $+2
$SG169765 DB	'ipl.c', 00H
	ORG $+2
$SG169777 DB	'architecture mode %s, invalid ipl psw %2.2X%2.2X%2.2X%2.'
	DB	'2X%2.2X%2.2X%2.2X%2.2X', 00H
	ORG $+1
$SG169779 DB	'HHC00839%s Processor %s%02X: ipl failed: %s', 0aH, 00H
	ORG $+3
$SG169780 DB	's370_common_load_finish', 00H
$SG169781 DB	'ipl.c', 00H
	ORG $+2
$SG169782 DB	'ipl.c:602', 00H
	ORG $+6
$SG179914 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:157', 00H
	ORG $+3
$SG180026 DB	'%2.2X', 00H
	ORG $+6
$SG179915 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:159', 00H
	ORG $+3
$SG193168 DB	'%2.2X', 00H
	ORG $+6
$SG179916 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:161', 00H
	ORG $+7
$SG179926 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:193', 00H
	ORG $+7
$SG179927 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:198', 00H
	ORG $+7
$SG179928 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:200', 00H
	ORG $+7
$SG179929 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:202', 00H
	ORG $+7
$SG179932 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:227', 00H
	ORG $+7
$SG179933 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:231', 00H
	ORG $+7
$SG179935 DB	'Could not perform reset within three seconds', 00H
	ORG $+3
$SG179937 DB	'HHC90000%s DBG: %s', 0aH, 00H
	ORG $+4
$SG179938 DB	's390_system_reset', 00H
	ORG $+6
$SG179939 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c', 00H
	ORG $+3
$SG180005 DB	'CP%2.2X Offline', 00H
$SG180007 DB	'HHC00810%s Processor %s%02X: ipl failed: %s', 0aH, 00H
	ORG $+3
$SG180008 DB	's390_load_ipl', 00H
	ORG $+2
$SG180009 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c', 00H
	ORG $+3
$SG180011 DB	'device %1d:%04X not found', 00H
	ORG $+6
$SG180013 DB	'HHC00810%s Processor %s%02X: ipl failed: %s', 0aH, 00H
	ORG $+3
$SG180014 DB	's390_load_ipl', 00H
	ORG $+2
$SG180015 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c', 00H
	ORG $+3
$SG180017 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:487', 00H
	ORG $+7
$SG180018 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:492', 00H
	ORG $+7
$SG180019 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:495', 00H
	ORG $+7
$SG180020 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:496', 00H
	ORG $+7
$SG180021 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:497', 00H
	ORG $+7
$SG180022 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:498', 00H
	ORG $+7
$SG180023 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:499', 00H
	ORG $+7
$SG180029 DB	'architecture mode %s, csw status %2.2X%2.2X, sense %s', 00H
	ORG $+2
$SG180031 DB	'HHC00828%s Processor %s%02X: ipl failed: %s', 0aH, 00H
	ORG $+3
$SG180032 DB	's390_load_ipl', 00H
	ORG $+2
$SG180033 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c', 00H
	ORG $+11
$SG180043 DB	'architecture mode %s, invalid ipl psw %2.2X%2.2X%2.2X%2.'
	DB	'2X%2.2X%2.2X%2.2X%2.2X', 00H
	ORG $+1
$SG180045 DB	'HHC00839%s Processor %s%02X: ipl failed: %s', 0aH, 00H
	ORG $+3
$SG180046 DB	's390_common_load_finish', 00H
$SG180047 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c', 00H
	ORG $+3
$SG180048 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:602', 00H
	ORG $+7
$SG193056 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:157', 00H
	ORG $+7
$SG193057 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:159', 00H
	ORG $+7
$SG193058 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:161', 00H
	ORG $+7
$SG193068 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:193', 00H
	ORG $+7
$SG193069 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:198', 00H
	ORG $+7
$SG193070 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:200', 00H
	ORG $+7
$SG193071 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:202', 00H
	ORG $+7
$SG193074 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:227', 00H
	ORG $+7
$SG193075 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:231', 00H
	ORG $+7
$SG193077 DB	'Could not perform reset within three seconds', 00H
	ORG $+3
$SG193079 DB	'HHC90000%s DBG: %s', 0aH, 00H
	ORG $+4
$SG193080 DB	'z900_system_reset', 00H
	ORG $+6
$SG193081 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c', 00H
	ORG $+3
$SG193147 DB	'CP%2.2X Offline', 00H
$SG193149 DB	'HHC00810%s Processor %s%02X: ipl failed: %s', 0aH, 00H
	ORG $+3
$SG193150 DB	'z900_load_ipl', 00H
	ORG $+2
$SG193151 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c', 00H
	ORG $+3
$SG193153 DB	'device %1d:%04X not found', 00H
	ORG $+6
$SG193155 DB	'HHC00810%s Processor %s%02X: ipl failed: %s', 0aH, 00H
	ORG $+3
$SG193156 DB	'z900_load_ipl', 00H
	ORG $+2
$SG193157 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c', 00H
	ORG $+3
$SG193159 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:487', 00H
	ORG $+7
$SG193160 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:492', 00H
	ORG $+7
$SG193161 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:495', 00H
	ORG $+7
$SG193162 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:496', 00H
	ORG $+7
$SG193163 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:497', 00H
	ORG $+7
$SG193164 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:498', 00H
	ORG $+7
$SG193165 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:499', 00H
	ORG $+7
$SG193171 DB	'architecture mode %s, csw status %2.2X%2.2X, sense %s', 00H
	ORG $+2
$SG193173 DB	'HHC00828%s Processor %s%02X: ipl failed: %s', 0aH, 00H
	ORG $+3
$SG193174 DB	'z900_load_ipl', 00H
	ORG $+2
$SG193175 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c', 00H
	ORG $+11
$SG193185 DB	'architecture mode %s, invalid ipl psw %2.2X%2.2X%2.2X%2.'
	DB	'2X%2.2X%2.2X%2.2X%2.2X', 00H
	ORG $+1
$SG193187 DB	'HHC00839%s Processor %s%02X: ipl failed: %s', 0aH, 00H
	ORG $+3
$SG193188 DB	'z900_common_load_finish', 00H
$SG193189 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c', 00H
	ORG $+3
$SG193190 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:602', 00H
	ORG $+7
$SG193217 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:625', 00H
	ORG $+7
$SG193218 DB	'TXF CPURES', 00H
	ORG $+5
$SG193249 DB	'C:\papa\MyGit\hyperion-zvector\ipl.c:714', 00H
	ORG $+7
$SG193250 DB	'TXF ICPURES', 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_or_2K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_get_storekey_ptr DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_common_load_finish
	DD	018H
	DD	034cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_load_ipl
	DD	026H
	DD	082dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_common_load_finish
	DD	018H
	DD	034cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_load_ipl
	DD	026H
	DD	082eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_common_load_finish
	DD	018H
	DD	034cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_load_ipl
	DD	026H
	DD	083eH
voltbl	ENDS
xdata	SEGMENT
$unwind$load_ipl DD 011801H
	DD	06218H
$unwind$s370_load_ipl DD 032e19H
	DD	056011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	02a0H
$unwind$system_reset DD 011601H
	DD	06216H
$unwind$s370_system_reset DD 031a01H
	DD	014011aH
	DD	07013H
$unwind$cpu_reset DD 010901H
	DD	06209H
$unwind$s370_cpu_reset DD 010901H
	DD	08209H
$unwind$initial_cpu_reset_all DD 010401H
	DD	06204H
$unwind$initial_cpu_reset DD 010901H
	DD	06209H
$unwind$s370_initial_cpu_reset DD 020a01H
	DD	07006720aH
$unwind$s370_common_load_begin DD 030e01H
	DD	0700a820eH
	DD	06009H
$unwind$s370_common_load_finish DD 042019H
	DD	021010eH
	DD	030067007H
	DD	imagerel __GSHandlerCheck
	DD	0f0H
$unwind$storage_clear DD 020601H
	DD	070021206H
$unwind$xstorage_clear DD 020601H
	DD	070021206H
$unwind$wakeup_cpu DD 010e01H
	DD	0420eH
$unwind$Interrupt_Lock_Obtained DD 010e01H
	DD	0420eH
$unwind$Obtain_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$Release_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$cpu_reset_instcount_and_cputime DD 010901H
	DD	04209H
$unwind$subsystem_reset DD 010401H
	DD	08204H
$unwind$s390_load_ipl DD 032e19H
	DD	056011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	02a0H
$unwind$s390_system_reset DD 031a01H
	DD	014011aH
	DD	07013H
$unwind$s390_cpu_reset DD 010901H
	DD	08209H
$unwind$s390_initial_cpu_reset DD 020a01H
	DD	07006720aH
$unwind$s390_common_load_begin DD 030e01H
	DD	0700a820eH
	DD	06009H
$unwind$s390_common_load_finish DD 042019H
	DD	021010eH
	DD	030067007H
	DD	imagerel __GSHandlerCheck
	DD	0f0H
$unwind$z900_load_ipl DD 032e19H
	DD	056011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	02a0H
$unwind$z900_system_reset DD 031a01H
	DD	014011aH
	DD	07013H
$unwind$z900_cpu_reset DD 010901H
	DD	0a209H
$unwind$z900_initial_cpu_reset DD 020a01H
	DD	07006b20aH
$unwind$z900_common_load_begin DD 030e01H
	DD	0700a820eH
	DD	06009H
$unwind$z900_common_load_finish DD 042019H
	DD	021010eH
	DD	030067007H
	DD	imagerel __GSHandlerCheck
	DD	0f0H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 z900_or_4K_storage_key

; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
z900_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 z900__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
z900_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
z900__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@z900__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@z900__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@z900__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@z900__or_s
$LN5@z900__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@z900__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
z900__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ipl.c
_TEXT	SEGMENT
rc$ = 96
tv76 = 100
tv82 = 104
tv88 = 108
tv94 = 112
tv132 = 116
tv138 = 120
tv160 = 128
tv180 = 136
tv196 = 144
buf$1 = 160
__$ArrayPad$ = 240
regs$ = 288
z900_common_load_finish PROC

; 568  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 569  : int rc;
; 570  :     /* Zeroize the interrupt code in the PSW */
; 571  :     regs->psw.intcode = 0;

  00020	33 c0		 xor	 eax, eax
  00022	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0002a	66 89 81 98 00
	00 00		 mov	 WORD PTR [rcx+152], ax

; 572  : 
; 573  :     /* Load IPL PSW from PSA+X'0' */
; 574  :     if ((rc = ARCH_DEP(load_psw) (regs, regs->psa->iplpsw)) )

  00031	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00039	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  00040	48 8b d0	 mov	 rdx, rax
  00043	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004b	e8 00 00 00 00	 call	 z900_load_psw
  00050	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax
  00054	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  00059	0f 84 3b 02 00
	00		 je	 $LN2@z900_commo

; 575  :     {
; 576  :         char buf[80];
; 577  :         MSGBUF(buf, "architecture mode %s, invalid ipl psw %2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X",

  0005f	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00067	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  0006e	b9 01 00 00 00	 mov	 ecx, 1
  00073	48 6b c9 07	 imul	 rcx, rcx, 7
  00077	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0007b	89 44 24 64	 mov	 DWORD PTR tv76[rsp], eax
  0007f	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00087	48 8b 89 60 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2144]
  0008e	ba 01 00 00 00	 mov	 edx, 1
  00093	48 6b d2 06	 imul	 rdx, rdx, 6
  00097	0f b6 0c 11	 movzx	 ecx, BYTE PTR [rcx+rdx]
  0009b	89 4c 24 68	 mov	 DWORD PTR tv82[rsp], ecx
  0009f	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000a7	48 8b 92 60 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2144]
  000ae	41 b8 01 00 00
	00		 mov	 r8d, 1
  000b4	4d 6b c0 05	 imul	 r8, r8, 5
  000b8	42 0f b6 14 02	 movzx	 edx, BYTE PTR [rdx+r8]
  000bd	89 54 24 6c	 mov	 DWORD PTR tv88[rsp], edx
  000c1	4c 8b 84 24 20
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000c9	4d 8b 80 60 08
	00 00		 mov	 r8, QWORD PTR [r8+2144]
  000d0	41 b9 01 00 00
	00		 mov	 r9d, 1
  000d6	4d 6b c9 04	 imul	 r9, r9, 4
  000da	47 0f b6 04 08	 movzx	 r8d, BYTE PTR [r8+r9]
  000df	44 89 44 24 70	 mov	 DWORD PTR tv94[rsp], r8d
  000e4	4c 8b 8c 24 20
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000ec	4d 8b 89 60 08
	00 00		 mov	 r9, QWORD PTR [r9+2144]
  000f3	41 ba 01 00 00
	00		 mov	 r10d, 1
  000f9	4d 6b d2 03	 imul	 r10, r10, 3
  000fd	47 0f b6 0c 11	 movzx	 r9d, BYTE PTR [r9+r10]
  00102	44 89 4c 24 74	 mov	 DWORD PTR tv132[rsp], r9d
  00107	4c 8b 94 24 20
	01 00 00	 mov	 r10, QWORD PTR regs$[rsp]
  0010f	4d 8b 92 60 08
	00 00		 mov	 r10, QWORD PTR [r10+2144]
  00116	41 bb 01 00 00
	00		 mov	 r11d, 1
  0011c	4d 6b db 02	 imul	 r11, r11, 2
  00120	47 0f b6 14 1a	 movzx	 r10d, BYTE PTR [r10+r11]
  00125	44 89 54 24 78	 mov	 DWORD PTR tv138[rsp], r10d
  0012a	4c 8b 9c 24 20
	01 00 00	 mov	 r11, QWORD PTR regs$[rsp]
  00132	4d 8b 9b 60 08
	00 00		 mov	 r11, QWORD PTR [r11+2144]
  00139	bb 01 00 00 00	 mov	 ebx, 1
  0013e	48 6b db 01	 imul	 rbx, rbx, 1
  00142	41 0f b6 1c 1b	 movzx	 ebx, BYTE PTR [r11+rbx]
  00147	4c 8b 9c 24 20
	01 00 00	 mov	 r11, QWORD PTR regs$[rsp]
  0014f	4d 8b 9b 60 08
	00 00		 mov	 r11, QWORD PTR [r11+2144]
  00156	bf 01 00 00 00	 mov	 edi, 1
  0015b	48 6b ff 00	 imul	 rdi, rdi, 0
  0015f	41 0f b6 3c 3b	 movzx	 edi, BYTE PTR [r11+rdi]
  00164	33 c9		 xor	 ecx, ecx
  00166	e8 00 00 00 00	 call	 get_arch_name
  0016b	8b 4c 24 64	 mov	 ecx, DWORD PTR tv76[rsp]
  0016f	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00173	8b 4c 24 68	 mov	 ecx, DWORD PTR tv82[rsp]
  00177	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0017b	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv88[rsp]
  0017f	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00183	8b 4c 24 70	 mov	 ecx, DWORD PTR tv94[rsp]
  00187	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0018b	8b 4c 24 74	 mov	 ecx, DWORD PTR tv132[rsp]
  0018f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00193	8b 4c 24 78	 mov	 ecx, DWORD PTR tv138[rsp]
  00197	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  0019b	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  0019f	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  001a3	4c 8b c8	 mov	 r9, rax
  001a6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193185
  001ad	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  001b2	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  001ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 578  :                 get_arch_name( NULL ),
; 579  :                 regs->psa->iplpsw[0], regs->psa->iplpsw[1],
; 580  :                 regs->psa->iplpsw[2], regs->psa->iplpsw[3],
; 581  :                 regs->psa->iplpsw[4], regs->psa->iplpsw[5],
; 582  :                 regs->psa->iplpsw[6], regs->psa->iplpsw[7]);
; 583  :         WRMSG (HHC00839, "E", PTYPSTR(sysblk.pcpu), sysblk.pcpu, buf);

  001c0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001c7	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  001ce	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001d5	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  001dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  001e3	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv160[rsp], rax
  001eb	b9 01 00 00 00	 mov	 ecx, 1
  001f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001f6	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  001fe	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00203	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0020a	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  00210	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00214	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv160[rsp]
  0021c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00221	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193186
  00228	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0022d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193187
  00234	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00239	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0023e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00244	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193188
  0024b	ba 47 02 00 00	 mov	 edx, 583		; 00000247H
  00250	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193189
  00257	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 584  : 
; 585  :         /* HercGUI hook so it can update its LEDs */
; 586  :         HDC1( debug_cpu_state, regs );

  0025d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  00264	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00268	74 1b		 je	 SHORT $LN4@z900_commo
  0026a	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00272	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  00279	ff 10		 call	 QWORD PTR [rax]
  0027b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv180[rsp], rax
  00283	eb 0c		 jmp	 SHORT $LN5@z900_commo
$LN4@z900_commo:
  00285	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv180[rsp], 0
$LN5@z900_commo:

; 587  : 
; 588  :         return rc;

  00291	8b 44 24 60	 mov	 eax, DWORD PTR rc$[rsp]
  00295	e9 b2 00 00 00	 jmp	 $LN1@z900_commo
$LN2@z900_commo:

; 589  :     }
; 590  : 
; 591  :     /* Set the CPU into the started state */
; 592  :     regs->opinterv = 0;

  0029a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a2	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  002a8	83 e0 ef	 and	 eax, -17		; ffffffefH
  002ab	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b3	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 593  :     regs->cpustate = CPUSTATE_STARTED;

  002b9	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c1	c6 40 60 01	 mov	 BYTE PTR [rax+96], 1

; 594  : 
; 595  :     /* The actual IPL (load) is now completed... */
; 596  :     regs->loadstate = 0;

  002c5	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002cd	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  002d3	0f ba f0 0c	 btr	 eax, 12
  002d7	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002df	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 597  : 
; 598  :     /* reset sys_reset flag to indicate a active machine */
; 599  :     sysblk.sys_reset = FALSE;

  002e5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002ec	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  002f2	83 e0 fe	 and	 eax, -2			; fffffffeH
  002f5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002fc	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 600  : 
; 601  :     /* Signal the CPU to retest stopped indicator */
; 602  :     WAKEUP_CPU (regs);

  00302	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193190
  00309	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00311	e8 00 00 00 00	 call	 wakeup_cpu

; 603  : 
; 604  :     /* HercGUI hook so it can update its LEDs */
; 605  :     HDC1( debug_cpu_state, regs );

  00316	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  0031d	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00321	74 1b		 je	 SHORT $LN6@z900_commo
  00323	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0032b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  00332	ff 10		 call	 QWORD PTR [rax]
  00334	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv196[rsp], rax
  0033c	eb 0c		 jmp	 SHORT $LN7@z900_commo
$LN6@z900_commo:
  0033e	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv196[rsp], 0
$LN7@z900_commo:

; 606  : 
; 607  :     return 0;

  0034a	33 c0		 xor	 eax, eax
$LN1@z900_commo:

; 608  : } /* end function common_load_finish */

  0034c	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00354	48 33 cc	 xor	 rcx, rsp
  00357	e8 00 00 00 00	 call	 __security_check_cookie
  0035c	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  00363	5f		 pop	 rdi
  00364	5b		 pop	 rbx
  00365	c3		 ret	 0
z900_common_load_finish ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ipl.c
_TEXT	SEGMENT
ipl$ = 32
tv75 = 36
tv86 = 40
tv91 = 44
rc$ = 48
capture$ = 52
target_mode$ = 56
cpu$ = 96
clear$ = 104
z900_common_load_begin PROC

; 367  : {

$LN12:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	56		 push	 rsi
  00009	57		 push	 rdi
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 368  :     const bool ipl = true;

  0000e	c6 44 24 20 01	 mov	 BYTE PTR ipl$[rsp], 1

; 369  :     int target_mode;
; 370  :     int capture;
; 371  :     int rc;
; 372  : 
; 373  :     /* Ensure dummyregs archmode matches SYSBLK archmode */
; 374  :     sysblk.dummyregs.arch_mode = sysblk.arch_mode;

  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00021	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  00027	89 88 64 15 00
	00		 mov	 DWORD PTR [rax+5476], ecx

; 375  : 
; 376  :     capture = TRUE

  0002d	33 c0		 xor	 eax, eax
  0002f	83 f8 01	 cmp	 eax, 1
  00032	74 38		 je	 SHORT $LN6@z900_commo
  00034	83 7c 24 68 00	 cmp	 DWORD PTR clear$[rsp], 0
  00039	75 31		 jne	 SHORT $LN6@z900_commo
  0003b	48 63 44 24 60	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00040	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00047	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00050	74 1a		 je	 SHORT $LN6@z900_commo
  00052	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00059	83 b8 88 00 00
	00 02		 cmp	 DWORD PTR [rax+136], 2
  00060	75 0a		 jne	 SHORT $LN6@z900_commo
  00062	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  0006a	eb 08		 jmp	 SHORT $LN7@z900_commo
$LN6@z900_commo:
  0006c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN7@z900_commo:
  00074	8b 44 24 24	 mov	 eax, DWORD PTR tv75[rsp]
  00078	89 44 24 34	 mov	 DWORD PTR capture$[rsp], eax

; 377  :         && !clear
; 378  :         && IS_CPU_ONLINE( cpu )
; 379  :         && sysblk.arch_mode == ARCH_900_IDX
; 380  :         ;
; 381  : 
; 382  :     /* Capture the z/Arch PSW if this is a Load-normal IPL */
; 383  :     if (capture)

  0007c	83 7c 24 34 00	 cmp	 DWORD PTR capture$[rsp], 0
  00081	74 29		 je	 SHORT $LN2@z900_commo

; 384  :         captured_zpsw = sysblk.regs[ cpu ]->psw;

  00083	48 63 44 24 60	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00088	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0008f	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00097	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:captured_zpsw
  0009e	48 8b f9	 mov	 rdi, rcx
  000a1	48 8d 70 78	 lea	 rsi, QWORD PTR [rax+120]
  000a5	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  000aa	f3 a4		 rep movsb
$LN2@z900_commo:

; 385  : 
; 386  :     /* Perform system-reset-normal or system-reset-clear function.
; 387  :      *
; 388  :      * SA22-7085-0 IBM System/370 Extended Architecture Principles
; 389  :      *             of Operation, Chapter 12, Operator Facilities,
; 390  :      *             LOAD-CLEAR KEY and LOAD-NORMAL KEY, p. 12-3.
; 391  :      */
; 392  : 
; 393  :     target_mode = sysblk.arch_mode > ARCH_390_IDX ?

  000ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000b3	83 b8 88 00 00
	00 01		 cmp	 DWORD PTR [rax+136], 1
  000ba	7e 0a		 jle	 SHORT $LN8@z900_commo
  000bc	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv86[rsp], 1
  000c4	eb 11		 jmp	 SHORT $LN9@z900_commo
$LN8@z900_commo:
  000c6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000cd	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  000d3	89 44 24 28	 mov	 DWORD PTR tv86[rsp], eax
$LN9@z900_commo:
  000d7	8b 44 24 28	 mov	 eax, DWORD PTR tv86[rsp]
  000db	89 44 24 38	 mov	 DWORD PTR target_mode$[rsp], eax

; 394  :                                      ARCH_390_IDX : sysblk.arch_mode;
; 395  : 
; 396  :     if ((rc = ARCH_DEP( system_reset )( target_mode, clear, ipl, cpu )) != 0)

  000df	83 7c 24 68 00	 cmp	 DWORD PTR clear$[rsp], 0
  000e4	75 0a		 jne	 SHORT $LN10@z900_commo
  000e6	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
  000ee	eb 08		 jmp	 SHORT $LN11@z900_commo
$LN10@z900_commo:
  000f0	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv91[rsp], 1
$LN11@z900_commo:
  000f8	44 8b 4c 24 60	 mov	 r9d, DWORD PTR cpu$[rsp]
  000fd	44 0f b6 44 24
	20		 movzx	 r8d, BYTE PTR ipl$[rsp]
  00103	0f b6 54 24 2c	 movzx	 edx, BYTE PTR tv91[rsp]
  00108	8b 4c 24 38	 mov	 ecx, DWORD PTR target_mode$[rsp]
  0010c	e8 00 00 00 00	 call	 z900_system_reset
  00111	89 44 24 30	 mov	 DWORD PTR rc$[rsp], eax
  00115	83 7c 24 30 00	 cmp	 DWORD PTR rc$[rsp], 0
  0011a	74 06		 je	 SHORT $LN3@z900_commo

; 397  :         return rc;

  0011c	8b 44 24 30	 mov	 eax, DWORD PTR rc$[rsp]
  00120	eb 6d		 jmp	 SHORT $LN1@z900_commo
$LN3@z900_commo:

; 398  : 
; 399  :     /* Save our captured-z/Arch-PSW if this is a Load-normal IPL
; 400  :        since the initial_cpu_reset call cleared it to zero. */
; 401  :     if (capture)

  00122	83 7c 24 34 00	 cmp	 DWORD PTR capture$[rsp], 0
  00127	74 2c		 je	 SHORT $LN4@z900_commo

; 402  :         sysblk.regs[ cpu ]->captured_zpsw = captured_zpsw;

  00129	48 63 44 24 60	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0012e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00135	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0013d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:captured_zpsw
  00144	48 8d b8 40 09
	00 00		 lea	 rdi, QWORD PTR [rax+2368]
  0014b	48 8b f1	 mov	 rsi, rcx
  0014e	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00153	f3 a4		 rep movsb
$LN4@z900_commo:

; 403  : 
; 404  :     /* The actual IPL (load) now begins... */
; 405  :     sysblk.regs[ cpu ]->loadstate = TRUE;

  00155	48 63 44 24 60	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0015a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00161	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00169	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0016f	0f ba e8 0c	 bts	 eax, 12
  00173	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR cpu$[rsp]
  00178	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0017f	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00187	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 406  : 
; 407  :     return 0;

  0018d	33 c0		 xor	 eax, eax
$LN1@z900_commo:

; 408  : } /* end function common_load_begin */

  0018f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00193	5f		 pop	 rdi
  00194	5e		 pop	 rsi
  00195	c3		 ret	 0
z900_common_load_begin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ipl.c
_TEXT	SEGMENT
rc$ = 64
tv167 = 68
rc2$1 = 72
tv129 = 80
regs$ = 112
z900_initial_cpu_reset PROC

; 688  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 689  :     int rc = 0;

  0000a	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 690  : 
; 691  :     /* Clear reset pending indicators */
; 692  :     regs->sigp_ini_reset = regs->sigp_reset = 0;

  00012	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00017	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0001d	0f ba f0 13	 btr	 eax, 19
  00021	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00026	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
  0002c	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00031	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00037	0f ba f0 14	 btr	 eax, 20
  0003b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00040	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 693  : 
; 694  :     /* Clear the registers */
; 695  :     memset ( &regs->psw,           0, sizeof( regs->psw           ));

  00046	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	48 83 c0 78	 add	 rax, 120		; 00000078H
  0004f	48 8b f8	 mov	 rdi, rax
  00052	33 c0		 xor	 eax, eax
  00054	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00059	f3 aa		 rep stosb

; 696  :     memset ( &regs->captured_zpsw, 0, sizeof( regs->captured_zpsw ));

  0005b	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00060	48 05 40 09 00
	00		 add	 rax, 2368		; 00000940H
  00066	48 8b f8	 mov	 rdi, rax
  00069	33 c0		 xor	 eax, eax
  0006b	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00070	f3 aa		 rep stosb

; 697  :     memset ( &regs->cr_struct,     0, sizeof( regs->cr_struct     ));

  00072	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00077	48 05 00 06 00
	00		 add	 rax, 1536		; 00000600H
  0007d	48 8b f8	 mov	 rdi, rax
  00080	33 c0		 xor	 eax, eax
  00082	b9 08 01 00 00	 mov	 ecx, 264		; 00000108H
  00087	f3 aa		 rep stosb

; 698  :     regs->fpc    = 0;

  00089	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0008e	c7 80 c0 03 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+960], 0

; 699  :     regs->PX     = 0;

  00098	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0009d	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 700  :     regs->psw.AMASK_G = AMASK24;

  000a5	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000aa	48 c7 80 90 00
	00 00 ff ff ff
	00		 mov	 QWORD PTR [rax+144], 16777215 ; 00ffffffH

; 701  : 
; 702  :     /* Ensure memory sizes are properly indicated */
; 703  :     regs->mainstor = sysblk.mainstor;

  000b5	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000ba	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000c1	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  000c8	48 89 88 48 08
	00 00		 mov	 QWORD PTR [rax+2120], rcx

; 704  :     regs->storkeys = sysblk.storkeys;

  000cf	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000db	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  000e2	48 89 88 50 08
	00 00		 mov	 QWORD PTR [rax+2128], rcx

; 705  :     regs->mainlim  = sysblk.mainsize ? (sysblk.mainsize - 1) : 0;

  000e9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000f0	48 83 b8 90 00
	00 00 00	 cmp	 QWORD PTR [rax+144], 0
  000f8	74 18		 je	 SHORT $LN9@z900_initi
  000fa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00101	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00108	48 ff c8	 dec	 rax
  0010b	48 89 44 24 50	 mov	 QWORD PTR tv129[rsp], rax
  00110	eb 09		 jmp	 SHORT $LN10@z900_initi
$LN9@z900_initi:
  00112	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv129[rsp], 0
$LN10@z900_initi:
  0011b	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00120	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv129[rsp]
  00125	48 89 88 58 08
	00 00		 mov	 QWORD PTR [rax+2136], rcx

; 706  :     regs->psa      = (PSA_3XX*)regs->mainstor;

  0012c	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00131	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00136	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  0013d	48 89 88 60 08
	00 00		 mov	 QWORD PTR [rax+2144], rcx

; 707  : 
; 708  :     /* Perform a CPU reset (after setting PSA) */
; 709  :     rc = ARCH_DEP( cpu_reset )( regs );

  00144	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00149	e8 00 00 00 00	 call	 z900_cpu_reset
  0014e	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 710  : 
; 711  :     regs->todpr  = 0;

  00152	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00157	c7 80 58 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1880], 0

; 712  :     regs->clkc   = 0;

  00161	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00166	48 c7 80 48 07
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1864], 0
$LN4@z900_initi:

; 713  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 714  :     PTT_TXF( "TXF ICPURES", 0, 0, regs->txf_tnd );

  00171	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00178	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0017b	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00181	48 85 c0	 test	 rax, rax
  00184	74 3e		 je	 SHORT $LN5@z900_initi
  00186	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0018b	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00192	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0019b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193249
  001a7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ac	45 33 c9	 xor	 r9d, r9d
  001af	45 33 c0	 xor	 r8d, r8d
  001b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193250
  001b9	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  001be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN5@z900_initi:
  001c4	33 c0		 xor	 eax, eax
  001c6	85 c0		 test	 eax, eax
  001c8	75 a7		 jne	 SHORT $LN4@z900_initi

; 715  :     /* EXIT SILENTLY from transactional execution mode */
; 716  :     regs->txf_tnd = 0;

  001ca	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  001cf	c6 80 58 0e 00
	00 00		 mov	 BYTE PTR [rax+3672], 0

; 717  :     regs->txf_aborts = 0;

  001d6	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  001db	c7 80 50 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+3664], 0

; 718  :     regs->txf_contran = false;

  001e5	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  001ea	c6 80 4c 0e 00
	00 00		 mov	 BYTE PTR [rax+3660], 0

; 719  :     regs->txf_UPGM_abort = false;

  001f1	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  001f6	c6 80 4d 0e 00
	00 00		 mov	 BYTE PTR [rax+3661], 0

; 720  : #endif
; 721  :     set_cpu_timer( regs, 0 );

  001fd	33 d2		 xor	 edx, edx
  001ff	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00204	e8 00 00 00 00	 call	 set_cpu_timer

; 722  : #if defined( _FEATURE_INTERVAL_TIMER )
; 723  :     set_int_timer( regs, 0 );

  00209	33 d2		 xor	 edx, edx
  0020b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00210	e8 00 00 00 00	 call	 set_int_timer

; 724  : #endif
; 725  : 
; 726  :     /* The breaking event address register is initialised to 1 */
; 727  :     regs->bear = 1;

  00215	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0021a	48 c7 80 18 02
	00 00 01 00 00
	00		 mov	 QWORD PTR [rax+536], 1

; 728  : 
; 729  :     /* Initialize external interrupt masks in control register 0 */
; 730  :     regs->CR(0) = CR0_XM_INTKEY | CR0_XM_EXTSIG |

  00225	b8 01 00 00 00	 mov	 eax, 1
  0022a	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0022e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00233	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  0023b	83 e0 10	 and	 eax, 16
  0023e	85 c0		 test	 eax, eax
  00240	74 0a		 je	 SHORT $LN11@z900_initi
  00242	c7 44 24 44 80
	00 00 00	 mov	 DWORD PTR tv167[rsp], 128 ; 00000080H
  0024a	eb 08		 jmp	 SHORT $LN12@z900_initi
$LN11@z900_initi:
  0024c	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv167[rsp], 0
$LN12@z900_initi:
  00254	8b 44 24 44	 mov	 eax, DWORD PTR tv167[rsp]
  00258	83 c8 60	 or	 eax, 96			; 00000060H
  0025b	b9 08 00 00 00	 mov	 ecx, 8
  00260	48 6b c9 01	 imul	 rcx, rcx, 1
  00264	48 98		 cdqe
  00266	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  0026b	48 89 84 0a 00
	06 00 00	 mov	 QWORD PTR [rdx+rcx+1536], rax

; 731  :       (FACILITY_ENABLED( HERC_INTERVAL_TIMER, regs ) ? CR0_XM_ITIMER : 0);
; 732  : 
; 733  : #if defined( FEATURE_S370_CHANNEL ) && !defined( FEATURE_ACCESS_REGISTERS )
; 734  :     /* For S/370 initialize the channel masks in CR2 */
; 735  :     regs->CR(2) = (U32)0xFFFFFFFFF;
; 736  : #endif
; 737  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 738  :     regs->CR(2) &= ~(CR2_TDS | CR2_TDC);

  00273	b8 08 00 00 00	 mov	 eax, 8
  00278	48 6b c0 03	 imul	 rax, rax, 3
  0027c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00281	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00289	48 83 e0 f8	 and	 rax, -8
  0028d	b9 08 00 00 00	 mov	 ecx, 8
  00292	48 6b c9 03	 imul	 rcx, rcx, 3
  00296	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  0029b	48 89 84 0a 00
	06 00 00	 mov	 QWORD PTR [rdx+rcx+1536], rax

; 739  : #endif
; 740  : 
; 741  :     regs->chanset =

  002a3	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  002a8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  002ad	66 89 81 38 08
	00 00		 mov	 WORD PTR [rcx+2104], ax

; 742  : #if defined( FEATURE_CHANNEL_SWITCHING )
; 743  :         regs->cpuad < FEATURE_LCSS_MAX ? regs->cpuad :
; 744  : #endif
; 745  :         0xFFFF;
; 746  : 
; 747  :     /* Initialize the machine check masks in control register 14 */
; 748  :     regs->CR(14) = CR14_CHKSTOP | CR14_SYNCMCEL | CR14_XDMGRPT;

  002b4	b8 08 00 00 00	 mov	 eax, 8
  002b9	48 6b c0 0f	 imul	 rax, rax, 15
  002bd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  002c2	ba 00 00 00 c2	 mov	 edx, -1040187392	; c2000000H
  002c7	48 89 94 01 00
	06 00 00	 mov	 QWORD PTR [rcx+rax+1536], rdx

; 749  : 
; 750  : #if !defined( FEATURE_LINKAGE_STACK )
; 751  :     /* For S/370 initialize the MCEL address in CR15 */
; 752  :     regs->CR(15) = 512;
; 753  : #endif
; 754  : 
; 755  :     if (regs->host && GUESTREGS)

  002cf	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  002d4	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  002da	c1 e8 07	 shr	 eax, 7
  002dd	83 e0 01	 and	 eax, 1
  002e0	85 c0		 test	 eax, eax
  002e2	74 33		 je	 SHORT $LN6@z900_initi
  002e4	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  002e9	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  002f1	74 24		 je	 SHORT $LN6@z900_initi

; 756  :     {
; 757  :         int rc2 = initial_cpu_reset( GUESTREGS );

  002f3	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  002f8	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  002ff	e8 00 00 00 00	 call	 initial_cpu_reset
  00304	89 44 24 48	 mov	 DWORD PTR rc2$1[rsp], eax

; 758  :         if (rc2 != 0)

  00308	83 7c 24 48 00	 cmp	 DWORD PTR rc2$1[rsp], 0
  0030d	74 08		 je	 SHORT $LN7@z900_initi

; 759  :             rc = rc2;

  0030f	8b 44 24 48	 mov	 eax, DWORD PTR rc2$1[rsp]
  00313	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax
$LN7@z900_initi:
$LN6@z900_initi:

; 760  :     }
; 761  : 
; 762  :     return rc;

  00317	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]

; 763  : } /* end function initial_cpu_reset */

  0031b	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0031f	5f		 pop	 rdi
  00320	c3		 ret	 0
z900_initial_cpu_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ipl.c
_TEXT	SEGMENT
i$ = 64
rc$ = 68
regs$ = 96
z900_cpu_reset PROC

; 614  : {

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 615  : int i, rc = 0;                          /* Array subscript           */

  00009	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 616  : 
; 617  :     regs->ip = regs->inst;

  00011	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00016	48 05 f1 08 00
	00		 add	 rax, 2289		; 000008f1H
  0001c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00021	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 618  : 
; 619  :     /* Clear indicators */
; 620  :     regs->loadstate = 0;

  00025	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0002a	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00030	0f ba f0 0c	 btr	 eax, 12
  00034	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00039	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 621  :     regs->checkstop = 0;

  0003f	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00044	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0004a	83 e0 df	 and	 eax, -33		; ffffffdfH
  0004d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 622  :     regs->sigp_reset = 0;

  00058	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00063	0f ba f0 13	 btr	 eax, 19
  00067	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0006c	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 623  :     regs->extccpu = 0;

  00072	33 c0		 xor	 eax, eax
  00074	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00079	66 89 41 62	 mov	 WORD PTR [rcx+98], ax
$LN4@z900_cpu_r:

; 624  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 625  :     PTT_TXF( "TXF CPURES", 0, 0, regs->txf_tnd );

  0007d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00084	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00087	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  0008d	48 85 c0	 test	 rax, rax
  00090	74 3e		 je	 SHORT $LN11@z900_cpu_r
  00092	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00097	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0009e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000a7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000ac	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193217
  000b3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b8	45 33 c9	 xor	 r9d, r9d
  000bb	45 33 c0	 xor	 r8d, r8d
  000be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193218
  000c5	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN11@z900_cpu_r:
  000d0	33 c0		 xor	 eax, eax
  000d2	85 c0		 test	 eax, eax
  000d4	75 a7		 jne	 SHORT $LN4@z900_cpu_r

; 626  :     /* EXIT SILENTLY from transactional execution mode */
; 627  :     regs->txf_tnd = 0;

  000d6	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000db	c6 80 58 0e 00
	00 00		 mov	 BYTE PTR [rax+3672], 0

; 628  :     regs->txf_aborts = 0;

  000e2	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	c7 80 50 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+3664], 0

; 629  :     regs->txf_contran = false;

  000f1	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000f6	c6 80 4c 0e 00
	00 00		 mov	 BYTE PTR [rax+3660], 0

; 630  :     regs->txf_UPGM_abort = false;

  000fd	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00102	c6 80 4d 0e 00
	00 00		 mov	 BYTE PTR [rax+3661], 0

; 631  : #endif
; 632  :     for (i = 0; i < sysblk.maxcpu; i++)

  00109	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00111	eb 0a		 jmp	 SHORT $LN7@z900_cpu_r
$LN5@z900_cpu_r:
  00113	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00117	ff c0		 inc	 eax
  00119	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN7@z900_cpu_r:
  0011d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00124	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0012a	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  0012e	7d 14		 jge	 SHORT $LN6@z900_cpu_r

; 633  :         regs->emercpu[i] = 0;

  00130	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00135	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0013a	c6 84 01 80 01
	00 00 00	 mov	 BYTE PTR [rcx+rax+384], 0
  00142	eb cf		 jmp	 SHORT $LN5@z900_cpu_r
$LN6@z900_cpu_r:

; 634  :     regs->instinvalid = 1;

  00144	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00149	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0014f	83 c8 08	 or	 eax, 8
  00152	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00157	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 635  : 
; 636  :     /* Clear interrupts */
; 637  :     SET_IC_INITIAL_MASK(regs);

  0015d	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00162	c7 40 4c 0a 00
	00 80		 mov	 DWORD PTR [rax+76], -2147483638 ; 8000000aH

; 638  :     SET_IC_INITIAL_STATE(regs);

  00169	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0016e	c7 40 48 01 00
	00 00		 mov	 DWORD PTR [rax+72], 1

; 639  : 
; 640  :     /* Clear the translation exception identification */
; 641  :     regs->EA_G = 0;

  00175	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0017a	48 c7 80 18 07
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1816], 0

; 642  :     regs->excarid = 0;

  00185	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0018a	c6 80 3e 08 00
	00 00		 mov	 BYTE PTR [rax+2110], 0

; 643  : 
; 644  :     /* Clear monitor code */
; 645  :     regs->MC_G = 0;

  00191	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00196	48 c7 80 10 07
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1808], 0

; 646  : 
; 647  :     /* Purge the lookaside buffers */
; 648  :     ARCH_DEP(purge_tlb) (regs);

  001a1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001a6	e8 00 00 00 00	 call	 z900_purge_tlb

; 649  : 
; 650  : #if defined(FEATURE_ACCESS_REGISTERS)
; 651  :     ARCH_DEP(purge_alb) (regs);

  001ab	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001b0	e8 00 00 00 00	 call	 z900_purge_alb

; 652  : #endif /*defined(FEATURE_ACCESS_REGISTERS)*/
; 653  : 
; 654  :     if(regs->host)

  001b5	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  001ba	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  001c0	c1 e8 07	 shr	 eax, 7
  001c3	83 e0 01	 and	 eax, 1
  001c6	85 c0		 test	 eax, eax
  001c8	74 3c		 je	 SHORT $LN12@z900_cpu_r

; 655  :     {
; 656  :         /* Put the CPU into the stopped state */
; 657  :         regs->opinterv = 0;

  001ca	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  001cf	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  001d5	83 e0 ef	 and	 eax, -17		; ffffffefH
  001d8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001dd	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 658  :         regs->cpustate = CPUSTATE_STOPPED;

  001e3	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  001e8	c6 40 60 03	 mov	 BYTE PTR [rax+96], 3
$LN10@z900_cpu_r:

; 659  :         ON_IC_INTERRUPT(regs);

  001ec	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  001f1	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  001f4	0f ba e8 1f	 bts	 eax, 31
  001f8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001fd	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00200	33 c0		 xor	 eax, eax
  00202	85 c0		 test	 eax, eax
  00204	75 e6		 jne	 SHORT $LN10@z900_cpu_r
$LN12@z900_cpu_r:

; 660  :     }
; 661  : 
; 662  : #ifdef FEATURE_INTERVAL_TIMER
; 663  :     ARCH_DEP( store_int_timer_locked )( regs );
; 664  : #endif
; 665  : 
; 666  :     if (regs->host && GUESTREGS)

  00206	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0020b	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00211	c1 e8 07	 shr	 eax, 7
  00214	83 e0 01	 and	 eax, 1
  00217	85 c0		 test	 eax, eax
  00219	74 5b		 je	 SHORT $LN13@z900_cpu_r
  0021b	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00220	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  00228	74 4c		 je	 SHORT $LN13@z900_cpu_r

; 667  :     {
; 668  :         rc = cpu_reset( GUESTREGS );

  0022a	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0022f	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00236	e8 00 00 00 00	 call	 cpu_reset
  0023b	89 44 24 44	 mov	 DWORD PTR rc$[rsp], eax

; 669  : 
; 670  :         /* CPU state of SIE copy cannot be controlled */
; 671  :         GUESTREGS->opinterv = 0;

  0023f	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00244	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0024b	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00251	83 e0 ef	 and	 eax, -17		; ffffffefH
  00254	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00259	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00260	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 672  :         GUESTREGS->cpustate = CPUSTATE_STARTED;

  00266	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0026b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00272	c6 40 60 01	 mov	 BYTE PTR [rax+96], 1
$LN13@z900_cpu_r:

; 673  :     }
; 674  : 
; 675  :     /* Re-initialize the facilities list for this CPU */
; 676  :     init_cpu_facilities( regs );

  00276	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0027b	e8 00 00 00 00	 call	 init_cpu_facilities

; 677  : 
; 678  :     /* Ensure CPU ID is accurate in case archmode changed */
; 679  :     setCpuIdregs( regs, -1, -1, -1, -1, true );

  00280	c6 44 24 28 01	 mov	 BYTE PTR [rsp+40], 1
  00285	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR [rsp+32], -1
  0028d	41 b9 ff ff ff
	ff		 mov	 r9d, -1
  00293	66 41 b8 ff ff	 mov	 r8w, -1
  00298	ba ff ff ff ff	 mov	 edx, -1
  0029d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  002a2	e8 00 00 00 00	 call	 setCpuIdregs

; 680  : 
; 681  :    return rc;

  002a7	8b 44 24 44	 mov	 eax, DWORD PTR rc$[rsp]

; 682  : } /* end function cpu_reset */

  002ab	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002af	c3		 ret	 0
z900_cpu_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ipl.c
_TEXT	SEGMENT
n$ = 64
wait$1 = 68
regs$ = 72
i$2 = 80
i$3 = 84
mask$ = 88
i$4 = 96
architecture_switch$ = 100
regs_mode$ = 104
rc$ = 108
tv88 = 112
mask$5 = 120
mask$6 = 128
mask$7 = 136
tv80 = 144
target_mode$ = 176
clear$ = 184
ipl$ = 192
cpu$ = 200
z900_system_reset PROC

; 116  : {

$LN63:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	57		 push	 rdi
  00013	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H

; 117  :     int         rc;
; 118  :     int         n;
; 119  :     int         regs_mode;
; 120  :     int         architecture_switch;
; 121  :     REGS*       regs;
; 122  :     CPU_BITMAP  mask;
; 123  : 
; 124  :     /* Configure the CPU if it's not online yet.
; 125  :      * Note: Configure implies initial reset.
; 126  :      */
; 127  :     if (!IS_CPU_ONLINE( cpu ))

  0001a	48 63 84 24 c8
	00 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00022	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00029	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00032	75 34		 jne	 SHORT $LN32@z900_syste

; 128  :     {
; 129  :         sysblk.arch_mode = target_mode;

  00034	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003b	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR target_mode$[rsp]
  00042	89 88 88 00 00
	00		 mov	 DWORD PTR [rax+136], ecx

; 130  : 
; 131  :         if ((rc = configure_cpu( cpu )))

  00048	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  0004f	e8 00 00 00 00	 call	 configure_cpu
  00054	89 44 24 6c	 mov	 DWORD PTR rc$[rsp], eax
  00058	83 7c 24 6c 00	 cmp	 DWORD PTR rc$[rsp], 0
  0005d	74 09		 je	 SHORT $LN33@z900_syste

; 132  :             return rc;

  0005f	8b 44 24 6c	 mov	 eax, DWORD PTR rc$[rsp]
  00063	e9 ad 07 00 00	 jmp	 $LN1@z900_syste
$LN33@z900_syste:
$LN32@z900_syste:

; 133  :     }
; 134  : 
; 135  :     /* HercGUI hook so it can update its LEDs */
; 136  :     HDC1( debug_cpu_state, sysblk.regs[ cpu ] );

  00068	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  0006f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00073	74 2a		 je	 SHORT $LN59@z900_syste
  00075	48 63 84 24 c8
	00 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0007d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00084	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  0008c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  00093	ff 10		 call	 QWORD PTR [rax]
  00095	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv80[rsp], rax
  0009d	eb 0c		 jmp	 SHORT $LN60@z900_syste
$LN59@z900_syste:
  0009f	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv80[rsp], 0
$LN60@z900_syste:

; 137  : 
; 138  :     /* Determine the target architecture mode for reset.
; 139  :      *
; 140  :      * A system reset normal never changes the architecture mode,
; 141  :      * nor does a system reset clear or IPL for architectures
; 142  :      * other than z/Architecture.  For z/Architecture however,
; 143  :      * a system reset clear or IPL changes the architecture mode
; 144  :      * to ESA/390.
; 145  :      */
; 146  :     if (target_mode > ARCH_390_IDX && (clear || ipl))

  000ab	83 bc 24 b0 00
	00 00 01	 cmp	 DWORD PTR target_mode$[rsp], 1
  000b3	7e 22		 jle	 SHORT $LN34@z900_syste
  000b5	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR clear$[rsp]
  000bd	85 c0		 test	 eax, eax
  000bf	75 0c		 jne	 SHORT $LN36@z900_syste
  000c1	0f b6 84 24 c0
	00 00 00	 movzx	 eax, BYTE PTR ipl$[rsp]
  000c9	85 c0		 test	 eax, eax
  000cb	74 0a		 je	 SHORT $LN34@z900_syste
$LN36@z900_syste:

; 147  :         regs_mode = ARCH_390_IDX;

  000cd	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR regs_mode$[rsp], 1
  000d5	eb 0b		 jmp	 SHORT $LN35@z900_syste
$LN34@z900_syste:

; 148  :     else
; 149  :         regs_mode = target_mode;

  000d7	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR target_mode$[rsp]
  000de	89 44 24 68	 mov	 DWORD PTR regs_mode$[rsp], eax
$LN35@z900_syste:

; 150  : 
; 151  :     /* Remember for later whether this is an architecture switch */
; 152  :     architecture_switch = (regs_mode != sysblk.arch_mode);

  000e2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000e9	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  000ef	39 44 24 68	 cmp	 DWORD PTR regs_mode$[rsp], eax
  000f3	74 0a		 je	 SHORT $LN61@z900_syste
  000f5	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv88[rsp], 1
  000fd	eb 08		 jmp	 SHORT $LN62@z900_syste
$LN61@z900_syste:
  000ff	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv88[rsp], 0
$LN62@z900_syste:
  00107	8b 44 24 70	 mov	 eax, DWORD PTR tv88[rsp]
  0010b	89 44 24 64	 mov	 DWORD PTR architecture_switch$[rsp], eax

; 153  : 
; 154  :     /* Signal all CPUs in configuration to stop and reset */
; 155  :     {
; 156  :         /* Switch lock context to hold both sigplock and intlock */
; 157  :         RELEASE_INTLOCK( NULL );

  0010f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193056
  00116	33 c9		 xor	 ecx, ecx
  00118	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 158  :         {
; 159  :             obtain_lock( &sysblk.sigplock );

  0011d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00124	48 05 80 10 00
	00		 add	 rax, 4224		; 00001080H
  0012a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193057
  00131	48 8b c8	 mov	 rcx, rax
  00134	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 160  :         }
; 161  :         OBTAIN_INTLOCK( NULL );

  0013a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193058
  00141	33 c9		 xor	 ecx, ecx
  00143	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock
$LN4@z900_syste:

; 162  : 
; 163  :         /* Ensure no external updates pending */
; 164  :         OFF_IC_SERVSIG;

  00148	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0014f	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00155	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0015a	85 c0		 test	 eax, eax
  0015c	0f 84 9c 00 00
	00		 je	 $LN37@z900_syste
  00162	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00169	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  0016f	0f ba f0 09	 btr	 eax, 9
  00173	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0017a	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  00180	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00187	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  0018e	48 89 44 24 78	 mov	 QWORD PTR mask$5[rsp], rax
  00193	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  0019b	eb 0a		 jmp	 SHORT $LN7@z900_syste
$LN5@z900_syste:
  0019d	8b 44 24 50	 mov	 eax, DWORD PTR i$2[rsp]
  001a1	ff c0		 inc	 eax
  001a3	89 44 24 50	 mov	 DWORD PTR i$2[rsp], eax
$LN7@z900_syste:
  001a7	48 83 7c 24 78
	00		 cmp	 QWORD PTR mask$5[rsp], 0
  001ad	74 4f		 je	 SHORT $LN6@z900_syste
  001af	48 8b 44 24 78	 mov	 rax, QWORD PTR mask$5[rsp]
  001b4	48 83 e0 01	 and	 rax, 1
  001b8	48 85 c0	 test	 rax, rax
  001bb	74 32		 je	 SHORT $LN38@z900_syste
  001bd	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$2[rsp]
  001c2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001c9	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  001d1	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  001d4	0f ba f0 09	 btr	 eax, 9
  001d8	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$2[rsp]
  001dd	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  001e4	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  001ec	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN38@z900_syste:
  001ef	48 8b 44 24 78	 mov	 rax, QWORD PTR mask$5[rsp]
  001f4	48 d1 e8	 shr	 rax, 1
  001f7	48 89 44 24 78	 mov	 QWORD PTR mask$5[rsp], rax
  001fc	eb 9f		 jmp	 SHORT $LN5@z900_syste
$LN6@z900_syste:
$LN37@z900_syste:
  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	0f 85 40 ff ff
	ff		 jne	 $LN4@z900_syste
$LN10@z900_syste:

; 165  :         OFF_IC_INTKEY;

  00208	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0020f	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00215	83 e0 40	 and	 eax, 64			; 00000040H
  00218	85 c0		 test	 eax, eax
  0021a	0f 84 a9 00 00
	00		 je	 $LN39@z900_syste
  00220	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00227	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  0022d	83 e0 bf	 and	 eax, -65		; ffffffbfH
  00230	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00237	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  0023d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00244	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  0024b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR mask$6[rsp], rax
  00253	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$3[rsp], 0
  0025b	eb 0a		 jmp	 SHORT $LN13@z900_syste
$LN11@z900_syste:
  0025d	8b 44 24 54	 mov	 eax, DWORD PTR i$3[rsp]
  00261	ff c0		 inc	 eax
  00263	89 44 24 54	 mov	 DWORD PTR i$3[rsp], eax
$LN13@z900_syste:
  00267	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR mask$6[rsp], 0
  00270	74 57		 je	 SHORT $LN12@z900_syste
  00272	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mask$6[rsp]
  0027a	48 83 e0 01	 and	 rax, 1
  0027e	48 85 c0	 test	 rax, rax
  00281	74 31		 je	 SHORT $LN40@z900_syste
  00283	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$3[rsp]
  00288	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0028f	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00297	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0029a	83 e0 bf	 and	 eax, -65		; ffffffbfH
  0029d	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR i$3[rsp]
  002a2	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  002a9	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  002b1	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN40@z900_syste:
  002b4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mask$6[rsp]
  002bc	48 d1 e8	 shr	 rax, 1
  002bf	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR mask$6[rsp], rax
  002c7	eb 94		 jmp	 SHORT $LN11@z900_syste
$LN12@z900_syste:
$LN39@z900_syste:
  002c9	33 c0		 xor	 eax, eax
  002cb	85 c0		 test	 eax, eax
  002cd	0f 85 35 ff ff
	ff		 jne	 $LN10@z900_syste

; 166  : 
; 167  :         /* Loop through CPUs and issue appropriate CPU reset function */
; 168  : 
; 169  :         mask = sysblk.config_mask;

  002d3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002da	48 8b 80 a8 12
	00 00		 mov	 rax, QWORD PTR [rax+4776]
  002e1	48 89 44 24 58	 mov	 QWORD PTR mask$[rsp], rax

; 170  : 
; 171  :         for (n = 0; mask; mask >>= 1, ++n)

  002e6	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  002ee	eb 17		 jmp	 SHORT $LN16@z900_syste
$LN14@z900_syste:
  002f0	48 8b 44 24 58	 mov	 rax, QWORD PTR mask$[rsp]
  002f5	48 d1 e8	 shr	 rax, 1
  002f8	48 89 44 24 58	 mov	 QWORD PTR mask$[rsp], rax
  002fd	8b 44 24 40	 mov	 eax, DWORD PTR n$[rsp]
  00301	ff c0		 inc	 eax
  00303	89 44 24 40	 mov	 DWORD PTR n$[rsp], eax
$LN16@z900_syste:
  00307	48 83 7c 24 58
	00		 cmp	 QWORD PTR mask$[rsp], 0
  0030d	0f 84 e5 00 00
	00		 je	 $LN15@z900_syste

; 172  :         {
; 173  :             if (mask & 1)

  00313	48 8b 44 24 58	 mov	 rax, QWORD PTR mask$[rsp]
  00318	48 83 e0 01	 and	 rax, 1
  0031c	48 85 c0	 test	 rax, rax
  0031f	0f 84 ce 00 00
	00		 je	 $LN41@z900_syste

; 174  :             {
; 175  :                 regs = sysblk.regs[n];

  00325	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$[rsp]
  0032a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00331	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00339	48 89 44 24 48	 mov	 QWORD PTR regs$[rsp], rax

; 176  : 
; 177  :                 /* Signal CPU reset function: if requesting CPU
; 178  :                  * with CLEAR or architecture change, then signal
; 179  :                  * initial CPU reset.  Otherwise, signal a normal
; 180  :                  * CPU reset.
; 181  :                  */
; 182  :                 if (0
; 183  :                     || architecture_switch
; 184  :                     || (n == cpu && (clear || ipl))

  0033e	33 c0		 xor	 eax, eax
  00340	85 c0		 test	 eax, eax
  00342	75 2c		 jne	 SHORT $LN44@z900_syste
  00344	83 7c 24 64 00	 cmp	 DWORD PTR architecture_switch$[rsp], 0
  00349	75 25		 jne	 SHORT $LN44@z900_syste
  0034b	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR cpu$[rsp]
  00352	39 44 24 40	 cmp	 DWORD PTR n$[rsp], eax
  00356	75 34		 jne	 SHORT $LN42@z900_syste
  00358	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR clear$[rsp]
  00360	85 c0		 test	 eax, eax
  00362	75 0c		 jne	 SHORT $LN45@z900_syste
  00364	0f b6 84 24 c0
	00 00 00	 movzx	 eax, BYTE PTR ipl$[rsp]
  0036c	85 c0		 test	 eax, eax
  0036e	74 1c		 je	 SHORT $LN42@z900_syste
$LN45@z900_syste:
$LN44@z900_syste:

; 185  :                 )
; 186  :                     regs->sigp_ini_reset = TRUE;

  00370	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00375	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0037b	0f ba e8 14	 bts	 eax, 20
  0037f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00384	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
  0038a	eb 1a		 jmp	 SHORT $LN43@z900_syste
$LN42@z900_syste:

; 187  :                 else
; 188  :                     regs->sigp_reset = TRUE;

  0038c	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00391	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00397	0f ba e8 13	 bts	 eax, 19
  0039b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  003a0	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN43@z900_syste:

; 189  : 
; 190  :                 regs->opinterv = TRUE;

  003a6	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  003ab	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  003b1	83 c8 10	 or	 eax, 16
  003b4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  003b9	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 191  :                 regs->cpustate = CPUSTATE_STOPPING;

  003bf	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  003c4	c6 40 60 02	 mov	 BYTE PTR [rax+96], 2
$LN19@z900_syste:

; 192  :                 ON_IC_INTERRUPT( regs );

  003c8	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  003cd	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  003d0	0f ba e8 1f	 bts	 eax, 31
  003d4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  003d9	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  003dc	33 c0		 xor	 eax, eax
  003de	85 c0		 test	 eax, eax
  003e0	75 e6		 jne	 SHORT $LN19@z900_syste

; 193  :                 WAKEUP_CPU( regs );

  003e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193068
  003e9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  003ee	e8 00 00 00 00	 call	 wakeup_cpu
$LN41@z900_syste:

; 194  :             }
; 195  :         }

  003f3	e9 f8 fe ff ff	 jmp	 $LN14@z900_syste
$LN15@z900_syste:

; 196  : 
; 197  :         /* Return to hold of just intlock */
; 198  :         RELEASE_INTLOCK( NULL );

  003f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193069
  003ff	33 c9		 xor	 ecx, ecx
  00401	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 199  :         {
; 200  :             release_lock( &sysblk.sigplock );

  00406	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0040d	48 05 80 10 00
	00		 add	 rax, 4224		; 00001080H
  00413	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193070
  0041a	48 8b c8	 mov	 rcx, rax
  0041d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 201  :         }
; 202  :         OBTAIN_INTLOCK( NULL );

  00423	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193071
  0042a	33 c9		 xor	 ecx, ecx
  0042c	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 203  :     }
; 204  : 
; 205  :     /* Wait for CPUs to complete their resets */
; 206  :     {
; 207  :         int i;
; 208  :         bool wait = true;

  00431	c6 44 24 44 01	 mov	 BYTE PTR wait$1[rsp], 1

; 209  : 
; 210  :         for (n = 0; wait && n < 300; ++n)

  00436	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  0043e	eb 0a		 jmp	 SHORT $LN22@z900_syste
$LN20@z900_syste:
  00440	8b 44 24 40	 mov	 eax, DWORD PTR n$[rsp]
  00444	ff c0		 inc	 eax
  00446	89 44 24 40	 mov	 DWORD PTR n$[rsp], eax
$LN22@z900_syste:
  0044a	0f b6 44 24 44	 movzx	 eax, BYTE PTR wait$1[rsp]
  0044f	85 c0		 test	 eax, eax
  00451	0f 84 bc 00 00
	00		 je	 $LN21@z900_syste
  00457	81 7c 24 40 2c
	01 00 00	 cmp	 DWORD PTR n$[rsp], 300	; 0000012cH
  0045f	0f 8d ae 00 00
	00		 jge	 $LN21@z900_syste

; 211  :         {
; 212  :             mask = sysblk.config_mask;

  00465	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0046c	48 8b 80 a8 12
	00 00		 mov	 rax, QWORD PTR [rax+4776]
  00473	48 89 44 24 58	 mov	 QWORD PTR mask$[rsp], rax

; 213  :             wait = false;

  00478	c6 44 24 44 00	 mov	 BYTE PTR wait$1[rsp], 0

; 214  : 
; 215  :             for (i=0; mask; mask >>= 1, ++i)

  0047d	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$4[rsp], 0
  00485	eb 17		 jmp	 SHORT $LN25@z900_syste
$LN23@z900_syste:
  00487	48 8b 44 24 58	 mov	 rax, QWORD PTR mask$[rsp]
  0048c	48 d1 e8	 shr	 rax, 1
  0048f	48 89 44 24 58	 mov	 QWORD PTR mask$[rsp], rax
  00494	8b 44 24 60	 mov	 eax, DWORD PTR i$4[rsp]
  00498	ff c0		 inc	 eax
  0049a	89 44 24 60	 mov	 DWORD PTR i$4[rsp], eax
$LN25@z900_syste:
  0049e	48 83 7c 24 58
	00		 cmp	 QWORD PTR mask$[rsp], 0
  004a4	74 68		 je	 SHORT $LN24@z900_syste

; 216  :             {
; 217  :                 if (!(mask & 1))

  004a6	48 8b 44 24 58	 mov	 rax, QWORD PTR mask$[rsp]
  004ab	48 83 e0 01	 and	 rax, 1
  004af	48 85 c0	 test	 rax, rax
  004b2	75 02		 jne	 SHORT $LN46@z900_syste

; 218  :                     continue;

  004b4	eb d1		 jmp	 SHORT $LN23@z900_syste
$LN46@z900_syste:

; 219  : 
; 220  :                 regs = sysblk.regs[ i ];

  004b6	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$4[rsp]
  004bb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004c2	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  004ca	48 89 44 24 48	 mov	 QWORD PTR regs$[rsp], rax

; 221  : 
; 222  :                 if (regs->cpustate != CPUSTATE_STOPPED)

  004cf	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  004d4	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  004d8	83 f8 03	 cmp	 eax, 3
  004db	74 2c		 je	 SHORT $LN47@z900_syste

; 223  :                 {
; 224  :                     wait = true;

  004dd	c6 44 24 44 01	 mov	 BYTE PTR wait$1[rsp], 1

; 225  : 
; 226  :                     /* Release intlock, take a nap, and re-acquire */
; 227  :                     RELEASE_INTLOCK( NULL );

  004e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193074
  004e9	33 c9		 xor	 ecx, ecx
  004eb	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 228  :                     {
; 229  :                         usleep( 10000 );  // (wait 10 milliseconds)

  004f0	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  004f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 230  :                     }
; 231  :                     OBTAIN_INTLOCK( NULL );

  004fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193075
  00502	33 c9		 xor	 ecx, ecx
  00504	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock
$LN47@z900_syste:

; 232  :                 }
; 233  :             }

  00509	e9 79 ff ff ff	 jmp	 $LN23@z900_syste
$LN24@z900_syste:

; 234  :         }

  0050e	e9 2d ff ff ff	 jmp	 $LN20@z900_syste
$LN21@z900_syste:

; 235  :     }
; 236  : 
; 237  :     /* FIXME: Recovery code is needed to handle the case where
; 238  :      * CPUs are misbehaving. Outstanding locks should be reported,
; 239  :      * then take-over CPUs and perform initial reset of each CPU.
; 240  :      */
; 241  :     if (n >= 300)   // (more than 300 * 10 milliseconds == 3 seconds?)

  00513	81 7c 24 40 2c
	01 00 00	 cmp	 DWORD PTR n$[rsp], 300	; 0000012cH
  0051b	7c 53		 jl	 SHORT $LN48@z900_syste

; 242  :     {
; 243  :         // "DBG: %s"
; 244  :         WRMSG( HHC90000, "E", "Could not perform reset within three seconds" );

  0051d	b9 01 00 00 00	 mov	 ecx, 1
  00522	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00528	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193077
  0052f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00534	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193078
  0053b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00540	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193079
  00547	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0054c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00551	41 b9 03 00 00
	00		 mov	 r9d, 3
  00557	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193080
  0055e	ba f4 00 00 00	 mov	 edx, 244		; 000000f4H
  00563	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193081
  0056a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN48@z900_syste:

; 245  :     }
; 246  : 
; 247  :     /* Clear Crypto Wrapping Keys. We do this regardless of whether
; 248  :        the facility is enabled for the given architecture or not
; 249  :        since there is no real harm in always doing so. Note too that
; 250  :        we only do this when the architecture is NOT being switched
; 251  :        so that it only gets done once and not twice since it doesn't
; 252  :        matter what the current architecture mode is since the crypto
; 253  :        wrapping keys aren't associated with any given architecture.
; 254  :     */
; 255  : #if defined( _FEATURE_076_MSA_EXTENSION_FACILITY_3 ) // (underscore!)
; 256  :     if (clear && !architecture_switch)

  00570	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR clear$[rsp]
  00578	85 c0		 test	 eax, eax
  0057a	74 0c		 je	 SHORT $LN49@z900_syste
  0057c	83 7c 24 64 00	 cmp	 DWORD PTR architecture_switch$[rsp], 0
  00581	75 05		 jne	 SHORT $LN49@z900_syste

; 257  :         renew_wrapping_keys();

  00583	e8 00 00 00 00	 call	 renew_wrapping_keys
$LN49@z900_syste:

; 258  : #endif
; 259  : 
; 260  :     /* Finish the reset in the requested mode if switching architectures */
; 261  :     if (architecture_switch)

  00588	83 7c 24 64 00	 cmp	 DWORD PTR architecture_switch$[rsp], 0
  0058d	74 3b		 je	 SHORT $LN50@z900_syste

; 262  :     {
; 263  :         sysblk.arch_mode = regs_mode;

  0058f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00596	8b 4c 24 68	 mov	 ecx, DWORD PTR regs_mode$[rsp]
  0059a	89 88 88 00 00
	00		 mov	 DWORD PTR [rax+136], ecx

; 264  :         return ARCH_DEP( system_reset )( target_mode, clear, ipl, cpu );

  005a0	44 8b 8c 24 c8
	00 00 00	 mov	 r9d, DWORD PTR cpu$[rsp]
  005a8	44 0f b6 84 24
	c0 00 00 00	 movzx	 r8d, BYTE PTR ipl$[rsp]
  005b1	0f b6 94 24 b8
	00 00 00	 movzx	 edx, BYTE PTR clear$[rsp]
  005b9	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR target_mode$[rsp]
  005c0	e8 00 00 00 00	 call	 z900_system_reset
  005c5	e9 4b 02 00 00	 jmp	 $LN1@z900_syste
$LN50@z900_syste:

; 265  :     }
; 266  : 
; 267  :     /* Perform subsystem reset
; 268  :      *
; 269  :      * GA22-7000-10 IBM System/370 Principles of Operation, Chapter 4.
; 270  :      *              Control, Subsystem Reset, p. 4-34
; 271  :      * SA22-7085-00 IBM System/370 Extended Architecture Principles of
; 272  :      *              Operation, Chapter 4. Control, Subsystem Reset,
; 273  :      *              p. 4-28
; 274  :      * SA22-7832-09 z/Architecture Principles of Operation, Chapter 4.
; 275  :      *              Control, Subsystem Reset, p. 4-57
; 276  :      */
; 277  :     subsystem_reset();

  005ca	e8 00 00 00 00	 call	 subsystem_reset

; 278  : 
; 279  :     /* Perform system-reset-clear additional functions */
; 280  :     if (clear)

  005cf	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR clear$[rsp]
  005d7	85 c0		 test	 eax, eax
  005d9	0f 84 0c 01 00
	00		 je	 $LN51@z900_syste

; 281  :     {
; 282  :         /* Finish reset-clear of all CPUs in the configuration */
; 283  :         for (n = 0; n < sysblk.maxcpu; ++n)

  005df	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  005e7	eb 0a		 jmp	 SHORT $LN28@z900_syste
$LN26@z900_syste:
  005e9	8b 44 24 40	 mov	 eax, DWORD PTR n$[rsp]
  005ed	ff c0		 inc	 eax
  005ef	89 44 24 40	 mov	 DWORD PTR n$[rsp], eax
$LN28@z900_syste:
  005f3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005fa	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00600	39 44 24 40	 cmp	 DWORD PTR n$[rsp], eax
  00604	0f 8d 84 00 00
	00		 jge	 $LN27@z900_syste

; 284  :         {
; 285  :             if (IS_CPU_ONLINE( n ))

  0060a	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$[rsp]
  0060f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00616	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0061f	74 68		 je	 SHORT $LN53@z900_syste

; 286  :             {
; 287  :                 regs = sysblk.regs[ n ];

  00621	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$[rsp]
  00626	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0062d	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00635	48 89 44 24 48	 mov	 QWORD PTR regs$[rsp], rax

; 288  : 
; 289  :                 /* Clear all the registers (AR, GPR, FPR, VR)
; 290  :                  * as part of the CPU CLEAR RESET operation
; 291  :                  */
; 292  :                 memset( regs->ar,  0, sizeof( regs->ar  ));

  0063a	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0063f	48 05 00 03 00
	00		 add	 rax, 768		; 00000300H
  00645	48 8b f8	 mov	 rdi, rax
  00648	33 c0		 xor	 eax, eax
  0064a	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0064f	f3 aa		 rep stosb

; 293  :                 memset( regs->gr,  0, sizeof( regs->gr  ));

  00651	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00656	48 05 80 02 00
	00		 add	 rax, 640		; 00000280H
  0065c	48 8b f8	 mov	 rdi, rax
  0065f	33 c0		 xor	 eax, eax
  00661	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00666	f3 aa		 rep stosb

; 294  :                 memset( regs->fpr, 0, sizeof( regs->fpr ));

  00668	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0066d	48 05 40 03 00
	00		 add	 rax, 832		; 00000340H
  00673	48 8b f8	 mov	 rdi, rax
  00676	33 c0		 xor	 eax, eax
  00678	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0067d	f3 aa		 rep stosb

; 295  : 
; 296  : #if defined( _FEATURE_S370_S390_VECTOR_FACILITY )
; 297  :                 memset( regs->vf->vr, 0, sizeof( regs->vf->vr ));
; 298  : #endif
; 299  :                 /* Clear the instruction counter and CPU time used */
; 300  :                 cpu_reset_instcount_and_cputime( regs );

  0067f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00684	e8 00 00 00 00	 call	 cpu_reset_instcount_and_cputime
$LN53@z900_syste:

; 301  :             }
; 302  :         }

  00689	e9 5b ff ff ff	 jmp	 $LN26@z900_syste
$LN27@z900_syste:

; 303  : 
; 304  :         /* Clear storage */
; 305  :         sysblk.main_clear = sysblk.xpnd_clear = 0;

  0068e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00695	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0069b	0f ba f0 0f	 btr	 eax, 15
  0069f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006a6	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
  006ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006b3	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  006b9	0f ba f0 0e	 btr	 eax, 14
  006bd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006c4	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 306  :         storage_clear();

  006ca	e8 00 00 00 00	 call	 storage_clear

; 307  :         xstorage_clear();

  006cf	e8 00 00 00 00	 call	 xstorage_clear

; 308  : 
; 309  :         /* Clear IPL program parameter */
; 310  :         sysblk.program_parameter = 0;

  006d4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006db	48 c7 80 18 0e
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+3608], 0

; 311  :     }

  006e6	e9 80 00 00 00	 jmp	 $LN52@z900_syste
$LN51@z900_syste:

; 312  : 
; 313  :     /* If IPL call, reset CPU instruction counts and times */
; 314  :     else if (ipl)

  006eb	0f b6 84 24 c0
	00 00 00	 movzx	 eax, BYTE PTR ipl$[rsp]
  006f3	85 c0		 test	 eax, eax
  006f5	74 74		 je	 SHORT $LN54@z900_syste

; 315  :     {
; 316  :         CPU_BITMAP  mask  = sysblk.config_mask;

  006f7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006fe	48 8b 80 a8 12
	00 00		 mov	 rax, QWORD PTR [rax+4776]
  00705	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR mask$7[rsp], rax

; 317  : 
; 318  :         for (n=0; mask; mask >>= 1, ++n)

  0070d	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  00715	eb 1d		 jmp	 SHORT $LN31@z900_syste
$LN29@z900_syste:
  00717	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR mask$7[rsp]
  0071f	48 d1 e8	 shr	 rax, 1
  00722	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR mask$7[rsp], rax
  0072a	8b 44 24 40	 mov	 eax, DWORD PTR n$[rsp]
  0072e	ff c0		 inc	 eax
  00730	89 44 24 40	 mov	 DWORD PTR n$[rsp], eax
$LN31@z900_syste:
  00734	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR mask$7[rsp], 0
  0073d	74 2c		 je	 SHORT $LN30@z900_syste

; 319  :         {
; 320  :             if (mask & 0x01)

  0073f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR mask$7[rsp]
  00747	48 83 e0 01	 and	 rax, 1
  0074b	48 85 c0	 test	 rax, rax
  0074e	74 19		 je	 SHORT $LN55@z900_syste

; 321  :                 cpu_reset_instcount_and_cputime( sysblk.regs[ n ]);

  00750	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$[rsp]
  00755	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0075c	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  00764	e8 00 00 00 00	 call	 cpu_reset_instcount_and_cputime
$LN55@z900_syste:

; 322  :         }

  00769	eb ac		 jmp	 SHORT $LN29@z900_syste
$LN30@z900_syste:
$LN54@z900_syste:
$LN52@z900_syste:

; 323  :     }
; 324  : 
; 325  :     /* If IPL or system-reset-clear, clear the system
; 326  :      * instruction counter, rates, and IPLed indicator.
; 327  :      */
; 328  :     if (clear || ipl)

  0076b	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR clear$[rsp]
  00773	85 c0		 test	 eax, eax
  00775	75 0c		 jne	 SHORT $LN57@z900_syste
  00777	0f b6 84 24 c0
	00 00 00	 movzx	 eax, BYTE PTR ipl$[rsp]
  0077f	85 c0		 test	 eax, eax
  00781	74 51		 je	 SHORT $LN56@z900_syste
$LN57@z900_syste:

; 329  :     {
; 330  :         /* Clear system instruction counter and CPU rates */
; 331  :         sysblk.instcount = 0;

  00783	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0078a	48 c7 80 80 14
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+5248], 0

; 332  :         sysblk.mipsrate  = 0;

  00795	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0079c	c7 80 88 14 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5256], 0

; 333  :         sysblk.siosrate  = 0;

  007a6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007ad	c7 80 8c 14 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5260], 0

; 334  :         sysblk.ipled     = FALSE;

  007b7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007be	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  007c4	83 e0 fd	 and	 eax, -3			; fffffffdH
  007c7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  007ce	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
$LN56@z900_syste:

; 335  :     }
; 336  : 
; 337  :     /* Set horizontal polarization and clear the
; 338  :        topology-change-report-pending condition.
; 339  :     */
; 340  : #if defined( FEATURE_011_CONFIG_TOPOLOGY_FACILITY )
; 341  :     sysblk.topology = TOPOLOGY_HORIZ;

  007d4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007db	c7 80 0c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+268], 0

; 342  :     sysblk.topchnge = 0;

  007e5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007ec	c7 80 10 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+272], 0

; 343  : #endif
; 344  : 
; 345  :     /* Set the system state to "reset" */
; 346  :     sysblk.sys_reset = TRUE;

  007f6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007fd	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00803	83 c8 01	 or	 eax, 1
  00806	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0080d	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 347  : 
; 348  :     return 0;

  00813	33 c0		 xor	 eax, eax
$LN1@z900_syste:

; 349  : } /* end function system_reset */

  00815	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  0081c	5f		 pop	 rdi
  0081d	c3		 ret	 0
z900_system_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ipl.c
_TEXT	SEGMENT
chanstat$ = 80
unitstat$ = 81
i$ = 84
dev$ = 88
regs$ = 96
rc$ = 104
tv303 = 108
tv305 = 112
tv81 = 120
tv148 = 128
tv168 = 136
tv315 = 144
tv335 = 152
buf2$1 = 160
buf$2 = 176
buf$3 = 256
buf$4 = 336
buffer$5 = 416
__$ArrayPad$ = 672
lcss$ = 704
devnum$ = 712
cpu$ = 720
clear$ = 728
z900_load_ipl PROC

; 416  : {

$LN20:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000f	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00014	57		 push	 rdi
  00015	48 81 ec b0 02
	00 00		 sub	 rsp, 688		; 000002b0H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 a0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 417  : REGS   *regs;                           /* -> Regs                   */
; 418  : DEVBLK *dev;                            /* -> Device control block   */
; 419  : int     i;                              /* Array subscript           */
; 420  : BYTE    unitstat;                       /* IPL device unit status    */
; 421  : BYTE    chanstat;                       /* IPL device channel status */
; 422  : int rc;
; 423  : 
; 424  :     /* Get started */
; 425  :     if ((rc = ARCH_DEP( common_load_begin )( cpu, clear )))

  0002e	8b 94 24 d8 02
	00 00		 mov	 edx, DWORD PTR clear$[rsp]
  00035	8b 8c 24 d0 02
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  0003c	e8 00 00 00 00	 call	 z900_common_load_begin
  00041	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax
  00045	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  0004a	74 09		 je	 SHORT $LN8@z900_load_

; 426  :         return rc;

  0004c	8b 44 24 68	 mov	 eax, DWORD PTR rc$[rsp]
  00050	e9 d8 07 00 00	 jmp	 $LN1@z900_load_
$LN8@z900_load_:

; 427  : 
; 428  :     /* Ensure CPU is online */
; 429  :     if (!IS_CPU_ONLINE(cpu))

  00055	48 63 84 24 d0
	02 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0005d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00064	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0006d	0f 85 c6 00 00
	00		 jne	 $LN9@z900_load_

; 430  :     {
; 431  :         char buf[80];
; 432  :         MSGBUF(buf, "CP%2.2X Offline", devnum);

  00073	0f b7 84 24 c8
	02 00 00	 movzx	 eax, WORD PTR devnum$[rsp]
  0007b	44 8b c8	 mov	 r9d, eax
  0007e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193147
  00085	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  0008a	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR buf$3[rsp]
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 433  :         // "Processor %s%02X: ipl failed: %s"
; 434  :         WRMSG (HHC00810, "E", PTYPSTR(sysblk.pcpu), sysblk.pcpu, buf);

  00098	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0009f	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  000a6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000ad	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  000bb	48 89 44 24 78	 mov	 QWORD PTR tv81[rsp], rax
  000c0	b9 01 00 00 00	 mov	 ecx, 1
  000c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000cb	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR buf$3[rsp]
  000d3	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000d8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000df	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  000e5	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000e9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv81[rsp]
  000ee	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193148
  000fa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193149
  00106	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0010b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00110	41 b9 03 00 00
	00		 mov	 r9d, 3
  00116	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193150
  0011d	ba b2 01 00 00	 mov	 edx, 434		; 000001b2H
  00122	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193151
  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 435  :         return -1;

  0012f	b8 ff ff ff ff	 mov	 eax, -1
  00134	e9 f4 06 00 00	 jmp	 $LN1@z900_load_
$LN9@z900_load_:

; 436  :     }
; 437  : 
; 438  :     /* The actual IPL proper starts here... */
; 439  : 
; 440  :     regs = sysblk.regs[cpu];    /* Point to IPL CPU's registers */

  00139	48 63 84 24 d0
	02 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00141	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00148	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00150	48 89 44 24 60	 mov	 QWORD PTR regs$[rsp], rax

; 441  :     /* Point to the device block for the IPL device */
; 442  :     dev = find_device_by_devnum (lcss,devnum);

  00155	0f b7 94 24 c8
	02 00 00	 movzx	 edx, WORD PTR devnum$[rsp]
  0015d	0f b7 8c 24 c0
	02 00 00	 movzx	 ecx, WORD PTR lcss$[rsp]
  00165	e8 00 00 00 00	 call	 find_device_by_devnum
  0016a	48 89 44 24 58	 mov	 QWORD PTR dev$[rsp], rax

; 443  :     if (dev == NULL)

  0016f	48 83 7c 24 58
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00175	0f 85 09 01 00
	00		 jne	 $LN10@z900_load_

; 444  :     {
; 445  :         char buf[80];
; 446  :         MSGBUF( buf, "device %1d:%04X not found", lcss, devnum );

  0017b	0f b7 84 24 c8
	02 00 00	 movzx	 eax, WORD PTR devnum$[rsp]
  00183	0f b7 8c 24 c0
	02 00 00	 movzx	 ecx, WORD PTR lcss$[rsp]
  0018b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0018f	44 8b c9	 mov	 r9d, ecx
  00192	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193153
  00199	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  0019e	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$4[rsp]
  001a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 447  :         // "Processor %s%02X: ipl failed: %s"
; 448  :         WRMSG( HHC00810, "E", PTYPSTR( sysblk.pcpu ), sysblk.pcpu, buf );

  001ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001b3	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  001ba	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001c1	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  001c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  001cf	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv148[rsp], rax
  001d7	b9 01 00 00 00	 mov	 ecx, 1
  001dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001e2	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$4[rsp]
  001ea	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001ef	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001f6	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  001fc	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00200	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv148[rsp]
  00208	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0020d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193154
  00214	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00219	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193155
  00220	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00225	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0022a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00230	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193156
  00237	ba c0 01 00 00	 mov	 edx, 448		; 000001c0H
  0023c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193157
  00243	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 449  : 
; 450  :         /* HercGUI hook so it can update its LEDs */
; 451  :         HDC1( debug_cpu_state, regs );

  00249	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  00250	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00254	74 18		 je	 SHORT $LN16@z900_load_
  00256	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0025b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  00262	ff 10		 call	 QWORD PTR [rax]
  00264	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv168[rsp], rax
  0026c	eb 0c		 jmp	 SHORT $LN17@z900_load_
$LN16@z900_load_:
  0026e	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv168[rsp], 0
$LN17@z900_load_:

; 452  : 
; 453  :         return -1;

  0027a	b8 ff ff ff ff	 mov	 eax, -1
  0027f	e9 a9 05 00 00	 jmp	 $LN1@z900_load_
$LN10@z900_load_:

; 454  :     }
; 455  : 
; 456  :     if(sysblk.haveiplparm)

  00284	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0028b	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00291	c1 e8 15	 shr	 eax, 21
  00294	83 e0 01	 and	 eax, 1
  00297	85 c0		 test	 eax, eax
  00299	74 73		 je	 SHORT $LN11@z900_load_

; 457  :     {
; 458  :         for(i=0;i<16;i++)

  0029b	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002a3	eb 0a		 jmp	 SHORT $LN4@z900_load_
$LN2@z900_load_:
  002a5	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  002a9	ff c0		 inc	 eax
  002ab	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN4@z900_load_:
  002af	83 7c 24 54 10	 cmp	 DWORD PTR i$[rsp], 16
  002b4	7d 3a		 jge	 SHORT $LN3@z900_load_

; 459  :         {
; 460  :             regs->GR_L(i)=fetch_fw(&sysblk.iplparmstring[i*4]);

  002b6	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  002ba	c1 e0 02	 shl	 eax, 2
  002bd	48 98		 cdqe
  002bf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002c6	48 8d 84 01 f8
	12 00 00	 lea	 rax, QWORD PTR [rcx+rax+4856]
  002ce	48 8b c8	 mov	 rcx, rax
  002d1	e8 00 00 00 00	 call	 fetch_fw_noswap
  002d6	8b c8		 mov	 ecx, eax
  002d8	e8 00 00 00 00	 call	 _byteswap_ulong
  002dd	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR i$[rsp]
  002e2	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  002e7	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 461  :         }

  002ee	eb b5		 jmp	 SHORT $LN2@z900_load_
$LN3@z900_load_:

; 462  :         sysblk.haveiplparm=0;

  002f0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002f7	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  002fd	0f ba f0 15	 btr	 eax, 21
  00301	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00308	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
$LN11@z900_load_:

; 463  :     }
; 464  : 
; 465  :     /* Set Main Storage Reference and Update bits */
; 466  :     ARCH_DEP( or_storage_key )( regs->PX, (STORKEY_REF | STORKEY_CHANGE) );

  0030e	b2 06		 mov	 dl, 6
  00310	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00315	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00319	e8 00 00 00 00	 call	 z900_or_storage_key

; 467  :     sysblk.main_clear = sysblk.xpnd_clear = 0;

  0031e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00325	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0032b	0f ba f0 0f	 btr	 eax, 15
  0032f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00336	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
  0033c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00343	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00349	0f ba f0 0e	 btr	 eax, 14
  0034d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00354	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 468  : 
; 469  :     /* Build the IPL CCW at location 0 */
; 470  :     regs->psa->iplpsw[0] = 0x02;              /* CCW command = Read */

  0035a	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0035f	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  00366	b9 01 00 00 00	 mov	 ecx, 1
  0036b	48 6b c9 00	 imul	 rcx, rcx, 0
  0036f	c6 04 08 02	 mov	 BYTE PTR [rax+rcx], 2

; 471  :     regs->psa->iplpsw[1] = 0;                 /* Data address = zero */

  00373	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00378	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  0037f	b9 01 00 00 00	 mov	 ecx, 1
  00384	48 6b c9 01	 imul	 rcx, rcx, 1
  00388	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 472  :     regs->psa->iplpsw[2] = 0;

  0038c	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00391	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  00398	b9 01 00 00 00	 mov	 ecx, 1
  0039d	48 6b c9 02	 imul	 rcx, rcx, 2
  003a1	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 473  :     regs->psa->iplpsw[3] = 0;

  003a5	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  003aa	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  003b1	b9 01 00 00 00	 mov	 ecx, 1
  003b6	48 6b c9 03	 imul	 rcx, rcx, 3
  003ba	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 474  :     regs->psa->iplpsw[4] = CCW_FLAGS_CC | CCW_FLAGS_SLI;

  003be	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  003c3	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  003ca	b9 01 00 00 00	 mov	 ecx, 1
  003cf	48 6b c9 04	 imul	 rcx, rcx, 4
  003d3	c6 04 08 60	 mov	 BYTE PTR [rax+rcx], 96	; 00000060H

; 475  :                                         /* CCW flags */
; 476  :     regs->psa->iplpsw[5] = 0;                 /* Reserved byte */

  003d7	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  003dc	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  003e3	b9 01 00 00 00	 mov	 ecx, 1
  003e8	48 6b c9 05	 imul	 rcx, rcx, 5
  003ec	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 477  :     regs->psa->iplpsw[6] = 0;                 /* Byte count = 24 */

  003f0	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  003f5	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  003fc	b9 01 00 00 00	 mov	 ecx, 1
  00401	48 6b c9 06	 imul	 rcx, rcx, 6
  00405	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 478  :     regs->psa->iplpsw[7] = 24;

  00409	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0040e	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  00415	b9 01 00 00 00	 mov	 ecx, 1
  0041a	48 6b c9 07	 imul	 rcx, rcx, 7
  0041e	c6 04 08 18	 mov	 BYTE PTR [rax+rcx], 24

; 479  : 
; 480  :     /* Enable the subchannel for the IPL device */
; 481  :     dev->pmcw.flag5 |= PMCW5_E;

  00422	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  00427	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0042e	0f ba e8 07	 bts	 eax, 7
  00432	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dev$[rsp]
  00437	88 81 f1 02 00
	00		 mov	 BYTE PTR [rcx+753], al

; 482  : 
; 483  :     /* Build the operation request block */
; 484  :     memset (&dev->orb, 0, sizeof(ORB));

  0043d	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  00442	48 05 cc 02 00
	00		 add	 rax, 716		; 000002ccH
  00448	48 8b f8	 mov	 rdi, rax
  0044b	33 c0		 xor	 eax, eax
  0044d	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00452	f3 aa		 rep stosb

; 485  :     dev->busy = 1;

  00454	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  00459	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0045f	0f ba e8 13	 bts	 eax, 19
  00463	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dev$[rsp]
  00468	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 486  : 
; 487  :     RELEASE_INTLOCK(NULL);

  0046e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193159
  00475	33 c9		 xor	 ecx, ecx
  00477	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 488  : 
; 489  :     /* Execute the IPL channel program */
; 490  :     ARCH_DEP(execute_ccw_chain) (dev);

  0047c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dev$[rsp]
  00481	e8 00 00 00 00	 call	 z900_execute_ccw_chain

; 491  : 
; 492  :     OBTAIN_INTLOCK(NULL);

  00486	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193160
  0048d	33 c9		 xor	 ecx, ecx
  0048f	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 493  : 
; 494  :     /* Clear the interrupt pending and device busy conditions */
; 495  :     obtain_lock (&sysblk.iointqlk);

  00494	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0049b	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  004a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193161
  004a8	48 8b c8	 mov	 rcx, rax
  004ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 496  :     DEQUEUE_IO_INTERRUPT_QLOCKED(&dev->ioint);

  004b1	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  004b6	48 05 28 02 00
	00		 add	 rax, 552		; 00000228H
  004bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193162
  004c3	48 8b c8	 mov	 rcx, rax
  004c6	e8 00 00 00 00	 call	 Dequeue_IO_Interrupt_QLocked

; 497  :     DEQUEUE_IO_INTERRUPT_QLOCKED(&dev->pciioint);

  004cb	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  004d0	48 05 40 02 00
	00		 add	 rax, 576		; 00000240H
  004d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193163
  004dd	48 8b c8	 mov	 rcx, rax
  004e0	e8 00 00 00 00	 call	 Dequeue_IO_Interrupt_QLocked

; 498  :     DEQUEUE_IO_INTERRUPT_QLOCKED(&dev->attnioint);

  004e5	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  004ea	48 05 58 02 00
	00		 add	 rax, 600		; 00000258H
  004f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193164
  004f7	48 8b c8	 mov	 rcx, rax
  004fa	e8 00 00 00 00	 call	 Dequeue_IO_Interrupt_QLocked

; 499  :     release_lock(&sysblk.iointqlk);

  004ff	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00506	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  0050c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193165
  00513	48 8b c8	 mov	 rcx, rax
  00516	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 500  :     dev->busy = 0;

  0051c	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  00521	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00527	0f ba f0 13	 btr	 eax, 19
  0052b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dev$[rsp]
  00530	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 501  :     dev->scsw.flag2 = 0;

  00536	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  0053b	c6 80 0a 03 00
	00 00		 mov	 BYTE PTR [rax+778], 0

; 502  :     dev->scsw.flag3 = 0;

  00542	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  00547	c6 80 0b 03 00
	00 00		 mov	 BYTE PTR [rax+779], 0

; 503  : 
; 504  :     /* Check that load completed normally */
; 505  :     unitstat = dev->scsw.unitstat;

  0054e	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  00553	0f b6 80 10 03
	00 00		 movzx	 eax, BYTE PTR [rax+784]
  0055a	88 44 24 51	 mov	 BYTE PTR unitstat$[rsp], al

; 506  :     chanstat = dev->scsw.chanstat;

  0055e	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  00563	0f b6 80 11 03
	00 00		 movzx	 eax, BYTE PTR [rax+785]
  0056a	88 44 24 50	 mov	 BYTE PTR chanstat$[rsp], al

; 507  : 
; 508  :     if (unitstat != (CSW_CE | CSW_DE) || chanstat != 0)

  0056e	0f b6 44 24 51	 movzx	 eax, BYTE PTR unitstat$[rsp]
  00573	83 f8 0c	 cmp	 eax, 12
  00576	75 0d		 jne	 SHORT $LN13@z900_load_
  00578	0f b6 44 24 50	 movzx	 eax, BYTE PTR chanstat$[rsp]
  0057d	85 c0		 test	 eax, eax
  0057f	0f 84 db 01 00
	00		 je	 $LN12@z900_load_
$LN13@z900_load_:

; 509  :     {
; 510  :         char buf[80];
; 511  :         char buf2[16];
; 512  : 
; 513  :         memset(buf,0,sizeof(buf));

  00585	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR buf$2[rsp]
  0058d	48 8b f8	 mov	 rdi, rax
  00590	33 c0		 xor	 eax, eax
  00592	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00597	f3 aa		 rep stosb

; 514  :         for (i=0; i < (int)dev->numsense; i++)

  00599	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  005a1	eb 0a		 jmp	 SHORT $LN7@z900_load_
$LN5@z900_load_:
  005a3	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  005a7	ff c0		 inc	 eax
  005a9	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN7@z900_load_:
  005ad	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  005b2	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  005b8	39 44 24 54	 cmp	 DWORD PTR i$[rsp], eax
  005bc	7d 77		 jge	 SHORT $LN6@z900_load_

; 515  :         {
; 516  :             MSGBUF(buf2, "%2.2X", dev->sense[i]);

  005be	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  005c3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dev$[rsp]
  005c8	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  005d0	44 8b c8	 mov	 r9d, eax
  005d3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193168
  005da	ba 10 00 00 00	 mov	 edx, 16
  005df	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR buf2$1[rsp]
  005e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 517  :             STRLCAT( buf, buf2 );

  005ed	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  005f3	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR buf2$1[rsp]
  005fb	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  00603	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 518  :             if ((i & 3) == 3) STRLCAT( buf, " " );

  00609	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  0060d	83 e0 03	 and	 eax, 3
  00610	83 f8 03	 cmp	 eax, 3
  00613	75 1b		 jne	 SHORT $LN14@z900_load_
  00615	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  0061b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193170
  00622	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  0062a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN14@z900_load_:

; 519  :         }

  00630	e9 6e ff ff ff	 jmp	 $LN5@z900_load_
$LN6@z900_load_:

; 520  :         {
; 521  :             char buffer[256];
; 522  :             MSGBUF(buffer, "architecture mode %s, csw status %2.2X%2.2X, sense %s",

  00635	0f b6 44 24 50	 movzx	 eax, BYTE PTR chanstat$[rsp]
  0063a	89 44 24 6c	 mov	 DWORD PTR tv303[rsp], eax
  0063e	0f b6 4c 24 51	 movzx	 ecx, BYTE PTR unitstat$[rsp]
  00643	89 4c 24 70	 mov	 DWORD PTR tv305[rsp], ecx
  00647	33 c9		 xor	 ecx, ecx
  00649	e8 00 00 00 00	 call	 get_arch_name
  0064e	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  00656	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0065b	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv303[rsp]
  0065f	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  00663	8b 4c 24 70	 mov	 ecx, DWORD PTR tv305[rsp]
  00667	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0066b	4c 8b c8	 mov	 r9, rax
  0066e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193171
  00675	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0067a	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR buffer$5[rsp]
  00682	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 523  :                 get_arch_name( NULL ),
; 524  :                 unitstat, chanstat, buf);
; 525  :             WRMSG (HHC00828, "E", PTYPSTR(sysblk.pcpu), sysblk.pcpu, buffer);

  00688	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0068f	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00696	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0069d	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  006a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  006ab	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv315[rsp], rax
  006b3	b9 01 00 00 00	 mov	 ecx, 1
  006b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006be	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR buffer$5[rsp]
  006c6	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  006cb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006d2	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  006d8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006dc	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv315[rsp]
  006e4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  006e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193172
  006f0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193173
  006fc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00701	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00706	41 b9 03 00 00
	00		 mov	 r9d, 3
  0070c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193174
  00713	ba 0d 02 00 00	 mov	 edx, 525		; 0000020dH
  00718	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193175
  0071f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 526  :         }
; 527  : 
; 528  :         /* HercGUI hook so it can update its LEDs */
; 529  :         HDC1( debug_cpu_state, regs );

  00725	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  0072c	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00730	74 18		 je	 SHORT $LN18@z900_load_
  00732	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00737	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  0073e	ff 10		 call	 QWORD PTR [rax]
  00740	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv335[rsp], rax
  00748	eb 0c		 jmp	 SHORT $LN19@z900_load_
$LN18@z900_load_:
  0074a	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv335[rsp], 0
$LN19@z900_load_:

; 530  : 
; 531  :         return -1;

  00756	b8 ff ff ff ff	 mov	 eax, -1
  0075b	e9 cd 00 00 00	 jmp	 $LN1@z900_load_
$LN12@z900_load_:

; 532  :     }
; 533  : 
; 534  : #ifdef FEATURE_S370_CHANNEL
; 535  :     /* Test the EC mode bit in the IPL PSW */
; 536  :     if (regs->psa->iplpsw[1] & 0x08) {
; 537  :         /* In EC mode, store device address at locations 184-187 */
; 538  :         STORE_FW(regs->psa->ioid, dev->devnum);
; 539  :     } else {
; 540  :         /* In BC mode, store device address at locations 2-3 */
; 541  :         STORE_HW(regs->psa->iplpsw + 2, dev->devnum);
; 542  :     }
; 543  : #endif /*FEATURE_S370_CHANNEL*/
; 544  : 
; 545  : #ifdef FEATURE_CHANNEL_SUBSYSTEM
; 546  :     /* Set LPUM */
; 547  :     dev->pmcw.lpum = 0x80;

  00760	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  00765	c6 80 f6 02 00
	00 80		 mov	 BYTE PTR [rax+758], 128	; 00000080H

; 548  :     STORE_FW(regs->psa->ioid, (dev->ssid<<16)|dev->subchan);

  0076c	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  00771	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00775	c1 e0 10	 shl	 eax, 16
  00778	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dev$[rsp]
  0077d	0f b7 49 46	 movzx	 ecx, WORD PTR [rcx+70]
  00781	0b c1		 or	 eax, ecx
  00783	8b c8		 mov	 ecx, eax
  00785	e8 00 00 00 00	 call	 _byteswap_ulong
  0078a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0078f	48 8b 89 60 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2144]
  00796	48 81 c1 b8 00
	00 00		 add	 rcx, 184		; 000000b8H
  0079d	8b d0		 mov	 edx, eax
  0079f	e8 00 00 00 00	 call	 store_fw_noswap

; 549  : 
; 550  :     /* Store zeroes at locations 188-191 */
; 551  :     memset (regs->psa->ioparm, 0, 4);

  007a4	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  007a9	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  007b0	48 05 bc 00 00
	00		 add	 rax, 188		; 000000bcH
  007b6	48 8b f8	 mov	 rdi, rax
  007b9	33 c0		 xor	 eax, eax
  007bb	b9 04 00 00 00	 mov	 ecx, 4
  007c0	f3 aa		 rep stosb

; 552  : #endif /*FEATURE_CHANNEL_SUBSYSTEM*/
; 553  : 
; 554  :     /* Save IPL device number, cpu number and lcss */
; 555  :     sysblk.ipldev = devnum;

  007c2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007c9	0f b7 8c 24 c8
	02 00 00	 movzx	 ecx, WORD PTR devnum$[rsp]
  007d1	66 89 88 f2 00
	00 00		 mov	 WORD PTR [rax+242], cx

; 556  :     sysblk.iplcpu = regs->cpuad;

  007d8	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  007dd	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  007e4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  007eb	89 81 f4 00 00
	00		 mov	 DWORD PTR [rcx+244], eax

; 557  :     sysblk.ipllcss = lcss;

  007f1	0f b7 84 24 c0
	02 00 00	 movzx	 eax, WORD PTR lcss$[rsp]
  007f9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00800	89 81 f8 00 00
	00		 mov	 DWORD PTR [rcx+248], eax

; 558  :     sysblk.ipled = TRUE;

  00806	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0080d	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00813	83 c8 02	 or	 eax, 2
  00816	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0081d	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 559  : 
; 560  :     /* Finish up... */
; 561  :     return ARCH_DEP(common_load_finish) (regs);

  00823	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00828	e8 00 00 00 00	 call	 z900_common_load_finish
$LN1@z900_load_:

; 562  : } /* end function load_ipl */

  0082d	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00835	48 33 cc	 xor	 rcx, rsp
  00838	e8 00 00 00 00	 call	 __security_check_cookie
  0083d	48 81 c4 b0 02
	00 00		 add	 rsp, 688		; 000002b0H
  00844	5f		 pop	 rdi
  00845	c3		 ret	 0
z900_load_ipl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 s390_or_4K_storage_key

; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
s390_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 s390__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s390_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s390__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s390__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@s390__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@s390__or_s
$LN5@s390__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s390__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
s390__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ipl.c
_TEXT	SEGMENT
rc$ = 96
tv76 = 100
tv82 = 104
tv88 = 108
tv94 = 112
tv132 = 116
tv138 = 120
tv160 = 128
tv180 = 136
tv196 = 144
buf$1 = 160
__$ArrayPad$ = 240
regs$ = 288
s390_common_load_finish PROC

; 568  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 569  : int rc;
; 570  :     /* Zeroize the interrupt code in the PSW */
; 571  :     regs->psw.intcode = 0;

  00020	33 c0		 xor	 eax, eax
  00022	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0002a	66 89 81 98 00
	00 00		 mov	 WORD PTR [rcx+152], ax

; 572  : 
; 573  :     /* Load IPL PSW from PSA+X'0' */
; 574  :     if ((rc = ARCH_DEP(load_psw) (regs, regs->psa->iplpsw)) )

  00031	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00039	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  00040	48 8b d0	 mov	 rdx, rax
  00043	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004b	e8 00 00 00 00	 call	 s390_load_psw
  00050	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax
  00054	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  00059	0f 84 3b 02 00
	00		 je	 $LN2@s390_commo

; 575  :     {
; 576  :         char buf[80];
; 577  :         MSGBUF(buf, "architecture mode %s, invalid ipl psw %2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X",

  0005f	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00067	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  0006e	b9 01 00 00 00	 mov	 ecx, 1
  00073	48 6b c9 07	 imul	 rcx, rcx, 7
  00077	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0007b	89 44 24 64	 mov	 DWORD PTR tv76[rsp], eax
  0007f	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00087	48 8b 89 60 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2144]
  0008e	ba 01 00 00 00	 mov	 edx, 1
  00093	48 6b d2 06	 imul	 rdx, rdx, 6
  00097	0f b6 0c 11	 movzx	 ecx, BYTE PTR [rcx+rdx]
  0009b	89 4c 24 68	 mov	 DWORD PTR tv82[rsp], ecx
  0009f	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000a7	48 8b 92 60 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2144]
  000ae	41 b8 01 00 00
	00		 mov	 r8d, 1
  000b4	4d 6b c0 05	 imul	 r8, r8, 5
  000b8	42 0f b6 14 02	 movzx	 edx, BYTE PTR [rdx+r8]
  000bd	89 54 24 6c	 mov	 DWORD PTR tv88[rsp], edx
  000c1	4c 8b 84 24 20
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000c9	4d 8b 80 60 08
	00 00		 mov	 r8, QWORD PTR [r8+2144]
  000d0	41 b9 01 00 00
	00		 mov	 r9d, 1
  000d6	4d 6b c9 04	 imul	 r9, r9, 4
  000da	47 0f b6 04 08	 movzx	 r8d, BYTE PTR [r8+r9]
  000df	44 89 44 24 70	 mov	 DWORD PTR tv94[rsp], r8d
  000e4	4c 8b 8c 24 20
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000ec	4d 8b 89 60 08
	00 00		 mov	 r9, QWORD PTR [r9+2144]
  000f3	41 ba 01 00 00
	00		 mov	 r10d, 1
  000f9	4d 6b d2 03	 imul	 r10, r10, 3
  000fd	47 0f b6 0c 11	 movzx	 r9d, BYTE PTR [r9+r10]
  00102	44 89 4c 24 74	 mov	 DWORD PTR tv132[rsp], r9d
  00107	4c 8b 94 24 20
	01 00 00	 mov	 r10, QWORD PTR regs$[rsp]
  0010f	4d 8b 92 60 08
	00 00		 mov	 r10, QWORD PTR [r10+2144]
  00116	41 bb 01 00 00
	00		 mov	 r11d, 1
  0011c	4d 6b db 02	 imul	 r11, r11, 2
  00120	47 0f b6 14 1a	 movzx	 r10d, BYTE PTR [r10+r11]
  00125	44 89 54 24 78	 mov	 DWORD PTR tv138[rsp], r10d
  0012a	4c 8b 9c 24 20
	01 00 00	 mov	 r11, QWORD PTR regs$[rsp]
  00132	4d 8b 9b 60 08
	00 00		 mov	 r11, QWORD PTR [r11+2144]
  00139	bb 01 00 00 00	 mov	 ebx, 1
  0013e	48 6b db 01	 imul	 rbx, rbx, 1
  00142	41 0f b6 1c 1b	 movzx	 ebx, BYTE PTR [r11+rbx]
  00147	4c 8b 9c 24 20
	01 00 00	 mov	 r11, QWORD PTR regs$[rsp]
  0014f	4d 8b 9b 60 08
	00 00		 mov	 r11, QWORD PTR [r11+2144]
  00156	bf 01 00 00 00	 mov	 edi, 1
  0015b	48 6b ff 00	 imul	 rdi, rdi, 0
  0015f	41 0f b6 3c 3b	 movzx	 edi, BYTE PTR [r11+rdi]
  00164	33 c9		 xor	 ecx, ecx
  00166	e8 00 00 00 00	 call	 get_arch_name
  0016b	8b 4c 24 64	 mov	 ecx, DWORD PTR tv76[rsp]
  0016f	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00173	8b 4c 24 68	 mov	 ecx, DWORD PTR tv82[rsp]
  00177	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0017b	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv88[rsp]
  0017f	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00183	8b 4c 24 70	 mov	 ecx, DWORD PTR tv94[rsp]
  00187	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0018b	8b 4c 24 74	 mov	 ecx, DWORD PTR tv132[rsp]
  0018f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00193	8b 4c 24 78	 mov	 ecx, DWORD PTR tv138[rsp]
  00197	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  0019b	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  0019f	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  001a3	4c 8b c8	 mov	 r9, rax
  001a6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180043
  001ad	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  001b2	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  001ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 578  :                 get_arch_name( NULL ),
; 579  :                 regs->psa->iplpsw[0], regs->psa->iplpsw[1],
; 580  :                 regs->psa->iplpsw[2], regs->psa->iplpsw[3],
; 581  :                 regs->psa->iplpsw[4], regs->psa->iplpsw[5],
; 582  :                 regs->psa->iplpsw[6], regs->psa->iplpsw[7]);
; 583  :         WRMSG (HHC00839, "E", PTYPSTR(sysblk.pcpu), sysblk.pcpu, buf);

  001c0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001c7	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  001ce	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001d5	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  001dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  001e3	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv160[rsp], rax
  001eb	b9 01 00 00 00	 mov	 ecx, 1
  001f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001f6	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  001fe	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00203	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0020a	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  00210	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00214	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv160[rsp]
  0021c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00221	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180044
  00228	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0022d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180045
  00234	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00239	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0023e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00244	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180046
  0024b	ba 47 02 00 00	 mov	 edx, 583		; 00000247H
  00250	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180047
  00257	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 584  : 
; 585  :         /* HercGUI hook so it can update its LEDs */
; 586  :         HDC1( debug_cpu_state, regs );

  0025d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  00264	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00268	74 1b		 je	 SHORT $LN4@s390_commo
  0026a	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00272	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  00279	ff 10		 call	 QWORD PTR [rax]
  0027b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv180[rsp], rax
  00283	eb 0c		 jmp	 SHORT $LN5@s390_commo
$LN4@s390_commo:
  00285	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv180[rsp], 0
$LN5@s390_commo:

; 587  : 
; 588  :         return rc;

  00291	8b 44 24 60	 mov	 eax, DWORD PTR rc$[rsp]
  00295	e9 b2 00 00 00	 jmp	 $LN1@s390_commo
$LN2@s390_commo:

; 589  :     }
; 590  : 
; 591  :     /* Set the CPU into the started state */
; 592  :     regs->opinterv = 0;

  0029a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a2	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  002a8	83 e0 ef	 and	 eax, -17		; ffffffefH
  002ab	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b3	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 593  :     regs->cpustate = CPUSTATE_STARTED;

  002b9	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c1	c6 40 60 01	 mov	 BYTE PTR [rax+96], 1

; 594  : 
; 595  :     /* The actual IPL (load) is now completed... */
; 596  :     regs->loadstate = 0;

  002c5	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002cd	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  002d3	0f ba f0 0c	 btr	 eax, 12
  002d7	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002df	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 597  : 
; 598  :     /* reset sys_reset flag to indicate a active machine */
; 599  :     sysblk.sys_reset = FALSE;

  002e5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002ec	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  002f2	83 e0 fe	 and	 eax, -2			; fffffffeH
  002f5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002fc	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 600  : 
; 601  :     /* Signal the CPU to retest stopped indicator */
; 602  :     WAKEUP_CPU (regs);

  00302	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180048
  00309	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00311	e8 00 00 00 00	 call	 wakeup_cpu

; 603  : 
; 604  :     /* HercGUI hook so it can update its LEDs */
; 605  :     HDC1( debug_cpu_state, regs );

  00316	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  0031d	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00321	74 1b		 je	 SHORT $LN6@s390_commo
  00323	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0032b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  00332	ff 10		 call	 QWORD PTR [rax]
  00334	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv196[rsp], rax
  0033c	eb 0c		 jmp	 SHORT $LN7@s390_commo
$LN6@s390_commo:
  0033e	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv196[rsp], 0
$LN7@s390_commo:

; 606  : 
; 607  :     return 0;

  0034a	33 c0		 xor	 eax, eax
$LN1@s390_commo:

; 608  : } /* end function common_load_finish */

  0034c	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00354	48 33 cc	 xor	 rcx, rsp
  00357	e8 00 00 00 00	 call	 __security_check_cookie
  0035c	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  00363	5f		 pop	 rdi
  00364	5b		 pop	 rbx
  00365	c3		 ret	 0
s390_common_load_finish ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ipl.c
_TEXT	SEGMENT
ipl$ = 32
tv75 = 36
tv86 = 40
tv91 = 44
rc$ = 48
capture$ = 52
target_mode$ = 56
cpu$ = 96
clear$ = 104
s390_common_load_begin PROC

; 367  : {

$LN12:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	56		 push	 rsi
  00009	57		 push	 rdi
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 368  :     const bool ipl = true;

  0000e	c6 44 24 20 01	 mov	 BYTE PTR ipl$[rsp], 1

; 369  :     int target_mode;
; 370  :     int capture;
; 371  :     int rc;
; 372  : 
; 373  :     /* Ensure dummyregs archmode matches SYSBLK archmode */
; 374  :     sysblk.dummyregs.arch_mode = sysblk.arch_mode;

  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00021	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  00027	89 88 64 15 00
	00		 mov	 DWORD PTR [rax+5476], ecx

; 375  : 
; 376  :     capture = TRUE

  0002d	33 c0		 xor	 eax, eax
  0002f	83 f8 01	 cmp	 eax, 1
  00032	74 38		 je	 SHORT $LN6@s390_commo
  00034	83 7c 24 68 00	 cmp	 DWORD PTR clear$[rsp], 0
  00039	75 31		 jne	 SHORT $LN6@s390_commo
  0003b	48 63 44 24 60	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00040	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00047	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00050	74 1a		 je	 SHORT $LN6@s390_commo
  00052	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00059	83 b8 88 00 00
	00 02		 cmp	 DWORD PTR [rax+136], 2
  00060	75 0a		 jne	 SHORT $LN6@s390_commo
  00062	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  0006a	eb 08		 jmp	 SHORT $LN7@s390_commo
$LN6@s390_commo:
  0006c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN7@s390_commo:
  00074	8b 44 24 24	 mov	 eax, DWORD PTR tv75[rsp]
  00078	89 44 24 34	 mov	 DWORD PTR capture$[rsp], eax

; 377  :         && !clear
; 378  :         && IS_CPU_ONLINE( cpu )
; 379  :         && sysblk.arch_mode == ARCH_900_IDX
; 380  :         ;
; 381  : 
; 382  :     /* Capture the z/Arch PSW if this is a Load-normal IPL */
; 383  :     if (capture)

  0007c	83 7c 24 34 00	 cmp	 DWORD PTR capture$[rsp], 0
  00081	74 29		 je	 SHORT $LN2@s390_commo

; 384  :         captured_zpsw = sysblk.regs[ cpu ]->psw;

  00083	48 63 44 24 60	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00088	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0008f	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00097	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:captured_zpsw
  0009e	48 8b f9	 mov	 rdi, rcx
  000a1	48 8d 70 78	 lea	 rsi, QWORD PTR [rax+120]
  000a5	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  000aa	f3 a4		 rep movsb
$LN2@s390_commo:

; 385  : 
; 386  :     /* Perform system-reset-normal or system-reset-clear function.
; 387  :      *
; 388  :      * SA22-7085-0 IBM System/370 Extended Architecture Principles
; 389  :      *             of Operation, Chapter 12, Operator Facilities,
; 390  :      *             LOAD-CLEAR KEY and LOAD-NORMAL KEY, p. 12-3.
; 391  :      */
; 392  : 
; 393  :     target_mode = sysblk.arch_mode > ARCH_390_IDX ?

  000ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000b3	83 b8 88 00 00
	00 01		 cmp	 DWORD PTR [rax+136], 1
  000ba	7e 0a		 jle	 SHORT $LN8@s390_commo
  000bc	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv86[rsp], 1
  000c4	eb 11		 jmp	 SHORT $LN9@s390_commo
$LN8@s390_commo:
  000c6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000cd	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  000d3	89 44 24 28	 mov	 DWORD PTR tv86[rsp], eax
$LN9@s390_commo:
  000d7	8b 44 24 28	 mov	 eax, DWORD PTR tv86[rsp]
  000db	89 44 24 38	 mov	 DWORD PTR target_mode$[rsp], eax

; 394  :                                      ARCH_390_IDX : sysblk.arch_mode;
; 395  : 
; 396  :     if ((rc = ARCH_DEP( system_reset )( target_mode, clear, ipl, cpu )) != 0)

  000df	83 7c 24 68 00	 cmp	 DWORD PTR clear$[rsp], 0
  000e4	75 0a		 jne	 SHORT $LN10@s390_commo
  000e6	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
  000ee	eb 08		 jmp	 SHORT $LN11@s390_commo
$LN10@s390_commo:
  000f0	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv91[rsp], 1
$LN11@s390_commo:
  000f8	44 8b 4c 24 60	 mov	 r9d, DWORD PTR cpu$[rsp]
  000fd	44 0f b6 44 24
	20		 movzx	 r8d, BYTE PTR ipl$[rsp]
  00103	0f b6 54 24 2c	 movzx	 edx, BYTE PTR tv91[rsp]
  00108	8b 4c 24 38	 mov	 ecx, DWORD PTR target_mode$[rsp]
  0010c	e8 00 00 00 00	 call	 s390_system_reset
  00111	89 44 24 30	 mov	 DWORD PTR rc$[rsp], eax
  00115	83 7c 24 30 00	 cmp	 DWORD PTR rc$[rsp], 0
  0011a	74 06		 je	 SHORT $LN3@s390_commo

; 397  :         return rc;

  0011c	8b 44 24 30	 mov	 eax, DWORD PTR rc$[rsp]
  00120	eb 6d		 jmp	 SHORT $LN1@s390_commo
$LN3@s390_commo:

; 398  : 
; 399  :     /* Save our captured-z/Arch-PSW if this is a Load-normal IPL
; 400  :        since the initial_cpu_reset call cleared it to zero. */
; 401  :     if (capture)

  00122	83 7c 24 34 00	 cmp	 DWORD PTR capture$[rsp], 0
  00127	74 2c		 je	 SHORT $LN4@s390_commo

; 402  :         sysblk.regs[ cpu ]->captured_zpsw = captured_zpsw;

  00129	48 63 44 24 60	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0012e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00135	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0013d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:captured_zpsw
  00144	48 8d b8 40 09
	00 00		 lea	 rdi, QWORD PTR [rax+2368]
  0014b	48 8b f1	 mov	 rsi, rcx
  0014e	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00153	f3 a4		 rep movsb
$LN4@s390_commo:

; 403  : 
; 404  :     /* The actual IPL (load) now begins... */
; 405  :     sysblk.regs[ cpu ]->loadstate = TRUE;

  00155	48 63 44 24 60	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0015a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00161	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00169	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0016f	0f ba e8 0c	 bts	 eax, 12
  00173	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR cpu$[rsp]
  00178	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0017f	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00187	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 406  : 
; 407  :     return 0;

  0018d	33 c0		 xor	 eax, eax
$LN1@s390_commo:

; 408  : } /* end function common_load_begin */

  0018f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00193	5f		 pop	 rdi
  00194	5e		 pop	 rsi
  00195	c3		 ret	 0
s390_common_load_begin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ipl.c
_TEXT	SEGMENT
rc$ = 32
tv151 = 36
rc2$1 = 40
tv129 = 48
regs$ = 80
s390_initial_cpu_reset PROC

; 688  : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 689  :     int rc = 0;

  0000a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 690  : 
; 691  :     /* Clear reset pending indicators */
; 692  :     regs->sigp_ini_reset = regs->sigp_reset = 0;

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00017	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0001d	0f ba f0 13	 btr	 eax, 19
  00021	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00026	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
  0002c	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00031	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00037	0f ba f0 14	 btr	 eax, 20
  0003b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00040	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 693  : 
; 694  :     /* Clear the registers */
; 695  :     memset ( &regs->psw,           0, sizeof( regs->psw           ));

  00046	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	48 83 c0 78	 add	 rax, 120		; 00000078H
  0004f	48 8b f8	 mov	 rdi, rax
  00052	33 c0		 xor	 eax, eax
  00054	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00059	f3 aa		 rep stosb

; 696  :     memset ( &regs->captured_zpsw, 0, sizeof( regs->captured_zpsw ));

  0005b	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00060	48 05 40 09 00
	00		 add	 rax, 2368		; 00000940H
  00066	48 8b f8	 mov	 rdi, rax
  00069	33 c0		 xor	 eax, eax
  0006b	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00070	f3 aa		 rep stosb

; 697  :     memset ( &regs->cr_struct,     0, sizeof( regs->cr_struct     ));

  00072	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00077	48 05 00 06 00
	00		 add	 rax, 1536		; 00000600H
  0007d	48 8b f8	 mov	 rdi, rax
  00080	33 c0		 xor	 eax, eax
  00082	b9 08 01 00 00	 mov	 ecx, 264		; 00000108H
  00087	f3 aa		 rep stosb

; 698  :     regs->fpc    = 0;

  00089	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0008e	c7 80 c0 03 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+960], 0

; 699  :     regs->PX     = 0;

  00098	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0009d	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [rax+112], 0

; 700  :     regs->psw.AMASK_G = AMASK24;

  000a4	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000a9	48 c7 80 90 00
	00 00 ff ff ff
	00		 mov	 QWORD PTR [rax+144], 16777215 ; 00ffffffH

; 701  : 
; 702  :     /* Ensure memory sizes are properly indicated */
; 703  :     regs->mainstor = sysblk.mainstor;

  000b4	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000c0	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  000c7	48 89 88 48 08
	00 00		 mov	 QWORD PTR [rax+2120], rcx

; 704  :     regs->storkeys = sysblk.storkeys;

  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000d3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000da	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  000e1	48 89 88 50 08
	00 00		 mov	 QWORD PTR [rax+2128], rcx

; 705  :     regs->mainlim  = sysblk.mainsize ? (sysblk.mainsize - 1) : 0;

  000e8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ef	48 83 b8 90 00
	00 00 00	 cmp	 QWORD PTR [rax+144], 0
  000f7	74 18		 je	 SHORT $LN5@s390_initi
  000f9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00100	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00107	48 ff c8	 dec	 rax
  0010a	48 89 44 24 30	 mov	 QWORD PTR tv129[rsp], rax
  0010f	eb 09		 jmp	 SHORT $LN6@s390_initi
$LN5@s390_initi:
  00111	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv129[rsp], 0
$LN6@s390_initi:
  0011a	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0011f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv129[rsp]
  00124	48 89 88 58 08
	00 00		 mov	 QWORD PTR [rax+2136], rcx

; 706  :     regs->psa      = (PSA_3XX*)regs->mainstor;

  0012b	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00130	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00135	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  0013c	48 89 88 60 08
	00 00		 mov	 QWORD PTR [rax+2144], rcx

; 707  : 
; 708  :     /* Perform a CPU reset (after setting PSA) */
; 709  :     rc = ARCH_DEP( cpu_reset )( regs );

  00143	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00148	e8 00 00 00 00	 call	 s390_cpu_reset
  0014d	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 710  : 
; 711  :     regs->todpr  = 0;

  00151	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00156	c7 80 58 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1880], 0

; 712  :     regs->clkc   = 0;

  00160	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00165	48 c7 80 48 07
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1864], 0

; 713  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 714  :     PTT_TXF( "TXF ICPURES", 0, 0, regs->txf_tnd );
; 715  :     /* EXIT SILENTLY from transactional execution mode */
; 716  :     regs->txf_tnd = 0;
; 717  :     regs->txf_aborts = 0;
; 718  :     regs->txf_contran = false;
; 719  :     regs->txf_UPGM_abort = false;
; 720  : #endif
; 721  :     set_cpu_timer( regs, 0 );

  00170	33 d2		 xor	 edx, edx
  00172	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00177	e8 00 00 00 00	 call	 set_cpu_timer

; 722  : #if defined( _FEATURE_INTERVAL_TIMER )
; 723  :     set_int_timer( regs, 0 );

  0017c	33 d2		 xor	 edx, edx
  0017e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00183	e8 00 00 00 00	 call	 set_int_timer

; 724  : #endif
; 725  : 
; 726  :     /* The breaking event address register is initialised to 1 */
; 727  :     regs->bear = 1;

  00188	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0018d	48 c7 80 18 02
	00 00 01 00 00
	00		 mov	 QWORD PTR [rax+536], 1

; 728  : 
; 729  :     /* Initialize external interrupt masks in control register 0 */
; 730  :     regs->CR(0) = CR0_XM_INTKEY | CR0_XM_EXTSIG |

  00198	b8 01 00 00 00	 mov	 eax, 1
  0019d	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  001a1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  001a6	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001ae	83 e0 10	 and	 eax, 16
  001b1	85 c0		 test	 eax, eax
  001b3	74 0a		 je	 SHORT $LN7@s390_initi
  001b5	c7 44 24 24 80
	00 00 00	 mov	 DWORD PTR tv151[rsp], 128 ; 00000080H
  001bd	eb 08		 jmp	 SHORT $LN8@s390_initi
$LN7@s390_initi:
  001bf	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN8@s390_initi:
  001c7	8b 44 24 24	 mov	 eax, DWORD PTR tv151[rsp]
  001cb	83 c8 60	 or	 eax, 96			; 00000060H
  001ce	b9 08 00 00 00	 mov	 ecx, 8
  001d3	48 6b c9 01	 imul	 rcx, rcx, 1
  001d7	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  001dc	89 84 0a 00 06
	00 00		 mov	 DWORD PTR [rdx+rcx+1536], eax

; 731  :       (FACILITY_ENABLED( HERC_INTERVAL_TIMER, regs ) ? CR0_XM_ITIMER : 0);
; 732  : 
; 733  : #if defined( FEATURE_S370_CHANNEL ) && !defined( FEATURE_ACCESS_REGISTERS )
; 734  :     /* For S/370 initialize the channel masks in CR2 */
; 735  :     regs->CR(2) = (U32)0xFFFFFFFFF;
; 736  : #endif
; 737  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 738  :     regs->CR(2) &= ~(CR2_TDS | CR2_TDC);
; 739  : #endif
; 740  : 
; 741  :     regs->chanset =

  001e3	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  001e8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  001ed	66 89 81 38 08
	00 00		 mov	 WORD PTR [rcx+2104], ax

; 742  : #if defined( FEATURE_CHANNEL_SWITCHING )
; 743  :         regs->cpuad < FEATURE_LCSS_MAX ? regs->cpuad :
; 744  : #endif
; 745  :         0xFFFF;
; 746  : 
; 747  :     /* Initialize the machine check masks in control register 14 */
; 748  :     regs->CR(14) = CR14_CHKSTOP | CR14_SYNCMCEL | CR14_XDMGRPT;

  001f4	b8 08 00 00 00	 mov	 eax, 8
  001f9	48 6b c0 0f	 imul	 rax, rax, 15
  001fd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00202	c7 84 01 00 06
	00 00 00 00 00
	c2		 mov	 DWORD PTR [rcx+rax+1536], -1040187392 ; c2000000H

; 749  : 
; 750  : #if !defined( FEATURE_LINKAGE_STACK )
; 751  :     /* For S/370 initialize the MCEL address in CR15 */
; 752  :     regs->CR(15) = 512;
; 753  : #endif
; 754  : 
; 755  :     if (regs->host && GUESTREGS)

  0020d	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00212	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00218	c1 e8 07	 shr	 eax, 7
  0021b	83 e0 01	 and	 eax, 1
  0021e	85 c0		 test	 eax, eax
  00220	74 33		 je	 SHORT $LN2@s390_initi
  00222	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00227	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  0022f	74 24		 je	 SHORT $LN2@s390_initi

; 756  :     {
; 757  :         int rc2 = initial_cpu_reset( GUESTREGS );

  00231	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00236	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0023d	e8 00 00 00 00	 call	 initial_cpu_reset
  00242	89 44 24 28	 mov	 DWORD PTR rc2$1[rsp], eax

; 758  :         if (rc2 != 0)

  00246	83 7c 24 28 00	 cmp	 DWORD PTR rc2$1[rsp], 0
  0024b	74 08		 je	 SHORT $LN3@s390_initi

; 759  :             rc = rc2;

  0024d	8b 44 24 28	 mov	 eax, DWORD PTR rc2$1[rsp]
  00251	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
$LN3@s390_initi:
$LN2@s390_initi:

; 760  :     }
; 761  : 
; 762  :     return rc;

  00255	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 763  : } /* end function initial_cpu_reset */

  00259	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0025d	5f		 pop	 rdi
  0025e	c3		 ret	 0
s390_initial_cpu_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ipl.c
_TEXT	SEGMENT
i$ = 48
rc$ = 52
regs$ = 80
s390_cpu_reset PROC

; 614  : {

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 615  : int i, rc = 0;                          /* Array subscript           */

  00009	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 616  : 
; 617  :     regs->ip = regs->inst;

  00011	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00016	48 05 f1 08 00
	00		 add	 rax, 2289		; 000008f1H
  0001c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00021	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 618  : 
; 619  :     /* Clear indicators */
; 620  :     regs->loadstate = 0;

  00025	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0002a	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00030	0f ba f0 0c	 btr	 eax, 12
  00034	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00039	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 621  :     regs->checkstop = 0;

  0003f	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00044	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0004a	83 e0 df	 and	 eax, -33		; ffffffdfH
  0004d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 622  :     regs->sigp_reset = 0;

  00058	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00063	0f ba f0 13	 btr	 eax, 19
  00067	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0006c	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 623  :     regs->extccpu = 0;

  00072	33 c0		 xor	 eax, eax
  00074	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00079	66 89 41 62	 mov	 WORD PTR [rcx+98], ax

; 624  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 625  :     PTT_TXF( "TXF CPURES", 0, 0, regs->txf_tnd );
; 626  :     /* EXIT SILENTLY from transactional execution mode */
; 627  :     regs->txf_tnd = 0;
; 628  :     regs->txf_aborts = 0;
; 629  :     regs->txf_contran = false;
; 630  :     regs->txf_UPGM_abort = false;
; 631  : #endif
; 632  :     for (i = 0; i < sysblk.maxcpu; i++)

  0007d	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00085	eb 0a		 jmp	 SHORT $LN4@s390_cpu_r
$LN2@s390_cpu_r:
  00087	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0008b	ff c0		 inc	 eax
  0008d	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@s390_cpu_r:
  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0009e	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  000a2	7d 14		 jge	 SHORT $LN3@s390_cpu_r

; 633  :         regs->emercpu[i] = 0;

  000a4	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  000a9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	c6 84 01 80 01
	00 00 00	 mov	 BYTE PTR [rcx+rax+384], 0
  000b6	eb cf		 jmp	 SHORT $LN2@s390_cpu_r
$LN3@s390_cpu_r:

; 634  :     regs->instinvalid = 1;

  000b8	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000bd	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000c3	83 c8 08	 or	 eax, 8
  000c6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  000cb	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 635  : 
; 636  :     /* Clear interrupts */
; 637  :     SET_IC_INITIAL_MASK(regs);

  000d1	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000d6	c7 40 4c 0a 00
	00 80		 mov	 DWORD PTR [rax+76], -2147483638 ; 8000000aH

; 638  :     SET_IC_INITIAL_STATE(regs);

  000dd	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000e2	c7 40 48 01 00
	00 00		 mov	 DWORD PTR [rax+72], 1

; 639  : 
; 640  :     /* Clear the translation exception identification */
; 641  :     regs->EA_G = 0;

  000e9	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000ee	48 c7 80 18 07
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1816], 0

; 642  :     regs->excarid = 0;

  000f9	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000fe	c6 80 3e 08 00
	00 00		 mov	 BYTE PTR [rax+2110], 0

; 643  : 
; 644  :     /* Clear monitor code */
; 645  :     regs->MC_G = 0;

  00105	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0010a	48 c7 80 10 07
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1808], 0

; 646  : 
; 647  :     /* Purge the lookaside buffers */
; 648  :     ARCH_DEP(purge_tlb) (regs);

  00115	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0011a	e8 00 00 00 00	 call	 s390_purge_tlb

; 649  : 
; 650  : #if defined(FEATURE_ACCESS_REGISTERS)
; 651  :     ARCH_DEP(purge_alb) (regs);

  0011f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00124	e8 00 00 00 00	 call	 s390_purge_alb

; 652  : #endif /*defined(FEATURE_ACCESS_REGISTERS)*/
; 653  : 
; 654  :     if(regs->host)

  00129	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0012e	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00134	c1 e8 07	 shr	 eax, 7
  00137	83 e0 01	 and	 eax, 1
  0013a	85 c0		 test	 eax, eax
  0013c	74 3c		 je	 SHORT $LN8@s390_cpu_r

; 655  :     {
; 656  :         /* Put the CPU into the stopped state */
; 657  :         regs->opinterv = 0;

  0013e	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00143	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00149	83 e0 ef	 and	 eax, -17		; ffffffefH
  0014c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00151	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 658  :         regs->cpustate = CPUSTATE_STOPPED;

  00157	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	c6 40 60 03	 mov	 BYTE PTR [rax+96], 3
$LN7@s390_cpu_r:

; 659  :         ON_IC_INTERRUPT(regs);

  00160	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00165	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00168	0f ba e8 1f	 bts	 eax, 31
  0016c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00171	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00174	33 c0		 xor	 eax, eax
  00176	85 c0		 test	 eax, eax
  00178	75 e6		 jne	 SHORT $LN7@s390_cpu_r
$LN8@s390_cpu_r:

; 660  :     }
; 661  : 
; 662  : #ifdef FEATURE_INTERVAL_TIMER
; 663  :     ARCH_DEP( store_int_timer_locked )( regs );
; 664  : #endif
; 665  : 
; 666  :     if (regs->host && GUESTREGS)

  0017a	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0017f	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00185	c1 e8 07	 shr	 eax, 7
  00188	83 e0 01	 and	 eax, 1
  0018b	85 c0		 test	 eax, eax
  0018d	74 5b		 je	 SHORT $LN9@s390_cpu_r
  0018f	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00194	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  0019c	74 4c		 je	 SHORT $LN9@s390_cpu_r

; 667  :     {
; 668  :         rc = cpu_reset( GUESTREGS );

  0019e	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  001a3	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  001aa	e8 00 00 00 00	 call	 cpu_reset
  001af	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 669  : 
; 670  :         /* CPU state of SIE copy cannot be controlled */
; 671  :         GUESTREGS->opinterv = 0;

  001b3	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  001b8	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  001bf	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  001c5	83 e0 ef	 and	 eax, -17		; ffffffefH
  001c8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  001cd	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  001d4	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 672  :         GUESTREGS->cpustate = CPUSTATE_STARTED;

  001da	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  001df	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  001e6	c6 40 60 01	 mov	 BYTE PTR [rax+96], 1
$LN9@s390_cpu_r:

; 673  :     }
; 674  : 
; 675  :     /* Re-initialize the facilities list for this CPU */
; 676  :     init_cpu_facilities( regs );

  001ea	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  001ef	e8 00 00 00 00	 call	 init_cpu_facilities

; 677  : 
; 678  :     /* Ensure CPU ID is accurate in case archmode changed */
; 679  :     setCpuIdregs( regs, -1, -1, -1, -1, true );

  001f4	c6 44 24 28 01	 mov	 BYTE PTR [rsp+40], 1
  001f9	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR [rsp+32], -1
  00201	41 b9 ff ff ff
	ff		 mov	 r9d, -1
  00207	66 41 b8 ff ff	 mov	 r8w, -1
  0020c	ba ff ff ff ff	 mov	 edx, -1
  00211	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00216	e8 00 00 00 00	 call	 setCpuIdregs

; 680  : 
; 681  :    return rc;

  0021b	8b 44 24 34	 mov	 eax, DWORD PTR rc$[rsp]

; 682  : } /* end function cpu_reset */

  0021f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00223	c3		 ret	 0
s390_cpu_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ipl.c
_TEXT	SEGMENT
n$ = 64
wait$1 = 68
regs$ = 72
i$2 = 80
i$3 = 84
mask$ = 88
i$4 = 96
architecture_switch$ = 100
regs_mode$ = 104
rc$ = 108
tv88 = 112
mask$5 = 120
mask$6 = 128
mask$7 = 136
tv80 = 144
target_mode$ = 176
clear$ = 184
ipl$ = 192
cpu$ = 200
s390_system_reset PROC

; 116  : {

$LN63:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	57		 push	 rdi
  00013	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H

; 117  :     int         rc;
; 118  :     int         n;
; 119  :     int         regs_mode;
; 120  :     int         architecture_switch;
; 121  :     REGS*       regs;
; 122  :     CPU_BITMAP  mask;
; 123  : 
; 124  :     /* Configure the CPU if it's not online yet.
; 125  :      * Note: Configure implies initial reset.
; 126  :      */
; 127  :     if (!IS_CPU_ONLINE( cpu ))

  0001a	48 63 84 24 c8
	00 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00022	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00029	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00032	75 34		 jne	 SHORT $LN32@s390_syste

; 128  :     {
; 129  :         sysblk.arch_mode = target_mode;

  00034	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003b	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR target_mode$[rsp]
  00042	89 88 88 00 00
	00		 mov	 DWORD PTR [rax+136], ecx

; 130  : 
; 131  :         if ((rc = configure_cpu( cpu )))

  00048	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  0004f	e8 00 00 00 00	 call	 configure_cpu
  00054	89 44 24 6c	 mov	 DWORD PTR rc$[rsp], eax
  00058	83 7c 24 6c 00	 cmp	 DWORD PTR rc$[rsp], 0
  0005d	74 09		 je	 SHORT $LN33@s390_syste

; 132  :             return rc;

  0005f	8b 44 24 6c	 mov	 eax, DWORD PTR rc$[rsp]
  00063	e9 8b 07 00 00	 jmp	 $LN1@s390_syste
$LN33@s390_syste:
$LN32@s390_syste:

; 133  :     }
; 134  : 
; 135  :     /* HercGUI hook so it can update its LEDs */
; 136  :     HDC1( debug_cpu_state, sysblk.regs[ cpu ] );

  00068	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  0006f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00073	74 2a		 je	 SHORT $LN59@s390_syste
  00075	48 63 84 24 c8
	00 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0007d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00084	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  0008c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  00093	ff 10		 call	 QWORD PTR [rax]
  00095	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv80[rsp], rax
  0009d	eb 0c		 jmp	 SHORT $LN60@s390_syste
$LN59@s390_syste:
  0009f	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv80[rsp], 0
$LN60@s390_syste:

; 137  : 
; 138  :     /* Determine the target architecture mode for reset.
; 139  :      *
; 140  :      * A system reset normal never changes the architecture mode,
; 141  :      * nor does a system reset clear or IPL for architectures
; 142  :      * other than z/Architecture.  For z/Architecture however,
; 143  :      * a system reset clear or IPL changes the architecture mode
; 144  :      * to ESA/390.
; 145  :      */
; 146  :     if (target_mode > ARCH_390_IDX && (clear || ipl))

  000ab	83 bc 24 b0 00
	00 00 01	 cmp	 DWORD PTR target_mode$[rsp], 1
  000b3	7e 22		 jle	 SHORT $LN34@s390_syste
  000b5	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR clear$[rsp]
  000bd	85 c0		 test	 eax, eax
  000bf	75 0c		 jne	 SHORT $LN36@s390_syste
  000c1	0f b6 84 24 c0
	00 00 00	 movzx	 eax, BYTE PTR ipl$[rsp]
  000c9	85 c0		 test	 eax, eax
  000cb	74 0a		 je	 SHORT $LN34@s390_syste
$LN36@s390_syste:

; 147  :         regs_mode = ARCH_390_IDX;

  000cd	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR regs_mode$[rsp], 1
  000d5	eb 0b		 jmp	 SHORT $LN35@s390_syste
$LN34@s390_syste:

; 148  :     else
; 149  :         regs_mode = target_mode;

  000d7	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR target_mode$[rsp]
  000de	89 44 24 68	 mov	 DWORD PTR regs_mode$[rsp], eax
$LN35@s390_syste:

; 150  : 
; 151  :     /* Remember for later whether this is an architecture switch */
; 152  :     architecture_switch = (regs_mode != sysblk.arch_mode);

  000e2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000e9	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  000ef	39 44 24 68	 cmp	 DWORD PTR regs_mode$[rsp], eax
  000f3	74 0a		 je	 SHORT $LN61@s390_syste
  000f5	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv88[rsp], 1
  000fd	eb 08		 jmp	 SHORT $LN62@s390_syste
$LN61@s390_syste:
  000ff	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv88[rsp], 0
$LN62@s390_syste:
  00107	8b 44 24 70	 mov	 eax, DWORD PTR tv88[rsp]
  0010b	89 44 24 64	 mov	 DWORD PTR architecture_switch$[rsp], eax

; 153  : 
; 154  :     /* Signal all CPUs in configuration to stop and reset */
; 155  :     {
; 156  :         /* Switch lock context to hold both sigplock and intlock */
; 157  :         RELEASE_INTLOCK( NULL );

  0010f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179914
  00116	33 c9		 xor	 ecx, ecx
  00118	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 158  :         {
; 159  :             obtain_lock( &sysblk.sigplock );

  0011d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00124	48 05 80 10 00
	00		 add	 rax, 4224		; 00001080H
  0012a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179915
  00131	48 8b c8	 mov	 rcx, rax
  00134	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 160  :         }
; 161  :         OBTAIN_INTLOCK( NULL );

  0013a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179916
  00141	33 c9		 xor	 ecx, ecx
  00143	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock
$LN4@s390_syste:

; 162  : 
; 163  :         /* Ensure no external updates pending */
; 164  :         OFF_IC_SERVSIG;

  00148	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0014f	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00155	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0015a	85 c0		 test	 eax, eax
  0015c	0f 84 9c 00 00
	00		 je	 $LN37@s390_syste
  00162	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00169	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  0016f	0f ba f0 09	 btr	 eax, 9
  00173	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0017a	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  00180	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00187	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  0018e	48 89 44 24 78	 mov	 QWORD PTR mask$5[rsp], rax
  00193	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  0019b	eb 0a		 jmp	 SHORT $LN7@s390_syste
$LN5@s390_syste:
  0019d	8b 44 24 50	 mov	 eax, DWORD PTR i$2[rsp]
  001a1	ff c0		 inc	 eax
  001a3	89 44 24 50	 mov	 DWORD PTR i$2[rsp], eax
$LN7@s390_syste:
  001a7	48 83 7c 24 78
	00		 cmp	 QWORD PTR mask$5[rsp], 0
  001ad	74 4f		 je	 SHORT $LN6@s390_syste
  001af	48 8b 44 24 78	 mov	 rax, QWORD PTR mask$5[rsp]
  001b4	48 83 e0 01	 and	 rax, 1
  001b8	48 85 c0	 test	 rax, rax
  001bb	74 32		 je	 SHORT $LN38@s390_syste
  001bd	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$2[rsp]
  001c2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001c9	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  001d1	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  001d4	0f ba f0 09	 btr	 eax, 9
  001d8	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$2[rsp]
  001dd	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  001e4	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  001ec	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN38@s390_syste:
  001ef	48 8b 44 24 78	 mov	 rax, QWORD PTR mask$5[rsp]
  001f4	48 d1 e8	 shr	 rax, 1
  001f7	48 89 44 24 78	 mov	 QWORD PTR mask$5[rsp], rax
  001fc	eb 9f		 jmp	 SHORT $LN5@s390_syste
$LN6@s390_syste:
$LN37@s390_syste:
  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	0f 85 40 ff ff
	ff		 jne	 $LN4@s390_syste
$LN10@s390_syste:

; 165  :         OFF_IC_INTKEY;

  00208	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0020f	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00215	83 e0 40	 and	 eax, 64			; 00000040H
  00218	85 c0		 test	 eax, eax
  0021a	0f 84 a9 00 00
	00		 je	 $LN39@s390_syste
  00220	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00227	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  0022d	83 e0 bf	 and	 eax, -65		; ffffffbfH
  00230	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00237	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  0023d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00244	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  0024b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR mask$6[rsp], rax
  00253	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$3[rsp], 0
  0025b	eb 0a		 jmp	 SHORT $LN13@s390_syste
$LN11@s390_syste:
  0025d	8b 44 24 54	 mov	 eax, DWORD PTR i$3[rsp]
  00261	ff c0		 inc	 eax
  00263	89 44 24 54	 mov	 DWORD PTR i$3[rsp], eax
$LN13@s390_syste:
  00267	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR mask$6[rsp], 0
  00270	74 57		 je	 SHORT $LN12@s390_syste
  00272	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mask$6[rsp]
  0027a	48 83 e0 01	 and	 rax, 1
  0027e	48 85 c0	 test	 rax, rax
  00281	74 31		 je	 SHORT $LN40@s390_syste
  00283	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$3[rsp]
  00288	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0028f	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00297	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0029a	83 e0 bf	 and	 eax, -65		; ffffffbfH
  0029d	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR i$3[rsp]
  002a2	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  002a9	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  002b1	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN40@s390_syste:
  002b4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mask$6[rsp]
  002bc	48 d1 e8	 shr	 rax, 1
  002bf	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR mask$6[rsp], rax
  002c7	eb 94		 jmp	 SHORT $LN11@s390_syste
$LN12@s390_syste:
$LN39@s390_syste:
  002c9	33 c0		 xor	 eax, eax
  002cb	85 c0		 test	 eax, eax
  002cd	0f 85 35 ff ff
	ff		 jne	 $LN10@s390_syste

; 166  : 
; 167  :         /* Loop through CPUs and issue appropriate CPU reset function */
; 168  : 
; 169  :         mask = sysblk.config_mask;

  002d3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002da	48 8b 80 a8 12
	00 00		 mov	 rax, QWORD PTR [rax+4776]
  002e1	48 89 44 24 58	 mov	 QWORD PTR mask$[rsp], rax

; 170  : 
; 171  :         for (n = 0; mask; mask >>= 1, ++n)

  002e6	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  002ee	eb 17		 jmp	 SHORT $LN16@s390_syste
$LN14@s390_syste:
  002f0	48 8b 44 24 58	 mov	 rax, QWORD PTR mask$[rsp]
  002f5	48 d1 e8	 shr	 rax, 1
  002f8	48 89 44 24 58	 mov	 QWORD PTR mask$[rsp], rax
  002fd	8b 44 24 40	 mov	 eax, DWORD PTR n$[rsp]
  00301	ff c0		 inc	 eax
  00303	89 44 24 40	 mov	 DWORD PTR n$[rsp], eax
$LN16@s390_syste:
  00307	48 83 7c 24 58
	00		 cmp	 QWORD PTR mask$[rsp], 0
  0030d	0f 84 e5 00 00
	00		 je	 $LN15@s390_syste

; 172  :         {
; 173  :             if (mask & 1)

  00313	48 8b 44 24 58	 mov	 rax, QWORD PTR mask$[rsp]
  00318	48 83 e0 01	 and	 rax, 1
  0031c	48 85 c0	 test	 rax, rax
  0031f	0f 84 ce 00 00
	00		 je	 $LN41@s390_syste

; 174  :             {
; 175  :                 regs = sysblk.regs[n];

  00325	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$[rsp]
  0032a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00331	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00339	48 89 44 24 48	 mov	 QWORD PTR regs$[rsp], rax

; 176  : 
; 177  :                 /* Signal CPU reset function: if requesting CPU
; 178  :                  * with CLEAR or architecture change, then signal
; 179  :                  * initial CPU reset.  Otherwise, signal a normal
; 180  :                  * CPU reset.
; 181  :                  */
; 182  :                 if (0
; 183  :                     || architecture_switch
; 184  :                     || (n == cpu && (clear || ipl))

  0033e	33 c0		 xor	 eax, eax
  00340	85 c0		 test	 eax, eax
  00342	75 2c		 jne	 SHORT $LN44@s390_syste
  00344	83 7c 24 64 00	 cmp	 DWORD PTR architecture_switch$[rsp], 0
  00349	75 25		 jne	 SHORT $LN44@s390_syste
  0034b	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR cpu$[rsp]
  00352	39 44 24 40	 cmp	 DWORD PTR n$[rsp], eax
  00356	75 34		 jne	 SHORT $LN42@s390_syste
  00358	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR clear$[rsp]
  00360	85 c0		 test	 eax, eax
  00362	75 0c		 jne	 SHORT $LN45@s390_syste
  00364	0f b6 84 24 c0
	00 00 00	 movzx	 eax, BYTE PTR ipl$[rsp]
  0036c	85 c0		 test	 eax, eax
  0036e	74 1c		 je	 SHORT $LN42@s390_syste
$LN45@s390_syste:
$LN44@s390_syste:

; 185  :                 )
; 186  :                     regs->sigp_ini_reset = TRUE;

  00370	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00375	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0037b	0f ba e8 14	 bts	 eax, 20
  0037f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00384	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
  0038a	eb 1a		 jmp	 SHORT $LN43@s390_syste
$LN42@s390_syste:

; 187  :                 else
; 188  :                     regs->sigp_reset = TRUE;

  0038c	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00391	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00397	0f ba e8 13	 bts	 eax, 19
  0039b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  003a0	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN43@s390_syste:

; 189  : 
; 190  :                 regs->opinterv = TRUE;

  003a6	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  003ab	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  003b1	83 c8 10	 or	 eax, 16
  003b4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  003b9	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 191  :                 regs->cpustate = CPUSTATE_STOPPING;

  003bf	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  003c4	c6 40 60 02	 mov	 BYTE PTR [rax+96], 2
$LN19@s390_syste:

; 192  :                 ON_IC_INTERRUPT( regs );

  003c8	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  003cd	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  003d0	0f ba e8 1f	 bts	 eax, 31
  003d4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  003d9	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  003dc	33 c0		 xor	 eax, eax
  003de	85 c0		 test	 eax, eax
  003e0	75 e6		 jne	 SHORT $LN19@s390_syste

; 193  :                 WAKEUP_CPU( regs );

  003e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179926
  003e9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  003ee	e8 00 00 00 00	 call	 wakeup_cpu
$LN41@s390_syste:

; 194  :             }
; 195  :         }

  003f3	e9 f8 fe ff ff	 jmp	 $LN14@s390_syste
$LN15@s390_syste:

; 196  : 
; 197  :         /* Return to hold of just intlock */
; 198  :         RELEASE_INTLOCK( NULL );

  003f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179927
  003ff	33 c9		 xor	 ecx, ecx
  00401	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 199  :         {
; 200  :             release_lock( &sysblk.sigplock );

  00406	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0040d	48 05 80 10 00
	00		 add	 rax, 4224		; 00001080H
  00413	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179928
  0041a	48 8b c8	 mov	 rcx, rax
  0041d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 201  :         }
; 202  :         OBTAIN_INTLOCK( NULL );

  00423	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179929
  0042a	33 c9		 xor	 ecx, ecx
  0042c	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 203  :     }
; 204  : 
; 205  :     /* Wait for CPUs to complete their resets */
; 206  :     {
; 207  :         int i;
; 208  :         bool wait = true;

  00431	c6 44 24 44 01	 mov	 BYTE PTR wait$1[rsp], 1

; 209  : 
; 210  :         for (n = 0; wait && n < 300; ++n)

  00436	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  0043e	eb 0a		 jmp	 SHORT $LN22@s390_syste
$LN20@s390_syste:
  00440	8b 44 24 40	 mov	 eax, DWORD PTR n$[rsp]
  00444	ff c0		 inc	 eax
  00446	89 44 24 40	 mov	 DWORD PTR n$[rsp], eax
$LN22@s390_syste:
  0044a	0f b6 44 24 44	 movzx	 eax, BYTE PTR wait$1[rsp]
  0044f	85 c0		 test	 eax, eax
  00451	0f 84 bc 00 00
	00		 je	 $LN21@s390_syste
  00457	81 7c 24 40 2c
	01 00 00	 cmp	 DWORD PTR n$[rsp], 300	; 0000012cH
  0045f	0f 8d ae 00 00
	00		 jge	 $LN21@s390_syste

; 211  :         {
; 212  :             mask = sysblk.config_mask;

  00465	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0046c	48 8b 80 a8 12
	00 00		 mov	 rax, QWORD PTR [rax+4776]
  00473	48 89 44 24 58	 mov	 QWORD PTR mask$[rsp], rax

; 213  :             wait = false;

  00478	c6 44 24 44 00	 mov	 BYTE PTR wait$1[rsp], 0

; 214  : 
; 215  :             for (i=0; mask; mask >>= 1, ++i)

  0047d	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$4[rsp], 0
  00485	eb 17		 jmp	 SHORT $LN25@s390_syste
$LN23@s390_syste:
  00487	48 8b 44 24 58	 mov	 rax, QWORD PTR mask$[rsp]
  0048c	48 d1 e8	 shr	 rax, 1
  0048f	48 89 44 24 58	 mov	 QWORD PTR mask$[rsp], rax
  00494	8b 44 24 60	 mov	 eax, DWORD PTR i$4[rsp]
  00498	ff c0		 inc	 eax
  0049a	89 44 24 60	 mov	 DWORD PTR i$4[rsp], eax
$LN25@s390_syste:
  0049e	48 83 7c 24 58
	00		 cmp	 QWORD PTR mask$[rsp], 0
  004a4	74 68		 je	 SHORT $LN24@s390_syste

; 216  :             {
; 217  :                 if (!(mask & 1))

  004a6	48 8b 44 24 58	 mov	 rax, QWORD PTR mask$[rsp]
  004ab	48 83 e0 01	 and	 rax, 1
  004af	48 85 c0	 test	 rax, rax
  004b2	75 02		 jne	 SHORT $LN46@s390_syste

; 218  :                     continue;

  004b4	eb d1		 jmp	 SHORT $LN23@s390_syste
$LN46@s390_syste:

; 219  : 
; 220  :                 regs = sysblk.regs[ i ];

  004b6	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$4[rsp]
  004bb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004c2	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  004ca	48 89 44 24 48	 mov	 QWORD PTR regs$[rsp], rax

; 221  : 
; 222  :                 if (regs->cpustate != CPUSTATE_STOPPED)

  004cf	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  004d4	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  004d8	83 f8 03	 cmp	 eax, 3
  004db	74 2c		 je	 SHORT $LN47@s390_syste

; 223  :                 {
; 224  :                     wait = true;

  004dd	c6 44 24 44 01	 mov	 BYTE PTR wait$1[rsp], 1

; 225  : 
; 226  :                     /* Release intlock, take a nap, and re-acquire */
; 227  :                     RELEASE_INTLOCK( NULL );

  004e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179932
  004e9	33 c9		 xor	 ecx, ecx
  004eb	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 228  :                     {
; 229  :                         usleep( 10000 );  // (wait 10 milliseconds)

  004f0	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  004f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 230  :                     }
; 231  :                     OBTAIN_INTLOCK( NULL );

  004fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179933
  00502	33 c9		 xor	 ecx, ecx
  00504	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock
$LN47@s390_syste:

; 232  :                 }
; 233  :             }

  00509	e9 79 ff ff ff	 jmp	 $LN23@s390_syste
$LN24@s390_syste:

; 234  :         }

  0050e	e9 2d ff ff ff	 jmp	 $LN20@s390_syste
$LN21@s390_syste:

; 235  :     }
; 236  : 
; 237  :     /* FIXME: Recovery code is needed to handle the case where
; 238  :      * CPUs are misbehaving. Outstanding locks should be reported,
; 239  :      * then take-over CPUs and perform initial reset of each CPU.
; 240  :      */
; 241  :     if (n >= 300)   // (more than 300 * 10 milliseconds == 3 seconds?)

  00513	81 7c 24 40 2c
	01 00 00	 cmp	 DWORD PTR n$[rsp], 300	; 0000012cH
  0051b	7c 53		 jl	 SHORT $LN48@s390_syste

; 242  :     {
; 243  :         // "DBG: %s"
; 244  :         WRMSG( HHC90000, "E", "Could not perform reset within three seconds" );

  0051d	b9 01 00 00 00	 mov	 ecx, 1
  00522	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00528	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179935
  0052f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00534	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179936
  0053b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00540	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179937
  00547	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0054c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00551	41 b9 03 00 00
	00		 mov	 r9d, 3
  00557	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179938
  0055e	ba f4 00 00 00	 mov	 edx, 244		; 000000f4H
  00563	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179939
  0056a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN48@s390_syste:

; 245  :     }
; 246  : 
; 247  :     /* Clear Crypto Wrapping Keys. We do this regardless of whether
; 248  :        the facility is enabled for the given architecture or not
; 249  :        since there is no real harm in always doing so. Note too that
; 250  :        we only do this when the architecture is NOT being switched
; 251  :        so that it only gets done once and not twice since it doesn't
; 252  :        matter what the current architecture mode is since the crypto
; 253  :        wrapping keys aren't associated with any given architecture.
; 254  :     */
; 255  : #if defined( _FEATURE_076_MSA_EXTENSION_FACILITY_3 ) // (underscore!)
; 256  :     if (clear && !architecture_switch)

  00570	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR clear$[rsp]
  00578	85 c0		 test	 eax, eax
  0057a	74 0c		 je	 SHORT $LN49@s390_syste
  0057c	83 7c 24 64 00	 cmp	 DWORD PTR architecture_switch$[rsp], 0
  00581	75 05		 jne	 SHORT $LN49@s390_syste

; 257  :         renew_wrapping_keys();

  00583	e8 00 00 00 00	 call	 renew_wrapping_keys
$LN49@s390_syste:

; 258  : #endif
; 259  : 
; 260  :     /* Finish the reset in the requested mode if switching architectures */
; 261  :     if (architecture_switch)

  00588	83 7c 24 64 00	 cmp	 DWORD PTR architecture_switch$[rsp], 0
  0058d	74 3b		 je	 SHORT $LN50@s390_syste

; 262  :     {
; 263  :         sysblk.arch_mode = regs_mode;

  0058f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00596	8b 4c 24 68	 mov	 ecx, DWORD PTR regs_mode$[rsp]
  0059a	89 88 88 00 00
	00		 mov	 DWORD PTR [rax+136], ecx

; 264  :         return ARCH_DEP( system_reset )( target_mode, clear, ipl, cpu );

  005a0	44 8b 8c 24 c8
	00 00 00	 mov	 r9d, DWORD PTR cpu$[rsp]
  005a8	44 0f b6 84 24
	c0 00 00 00	 movzx	 r8d, BYTE PTR ipl$[rsp]
  005b1	0f b6 94 24 b8
	00 00 00	 movzx	 edx, BYTE PTR clear$[rsp]
  005b9	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR target_mode$[rsp]
  005c0	e8 00 00 00 00	 call	 s390_system_reset
  005c5	e9 29 02 00 00	 jmp	 $LN1@s390_syste
$LN50@s390_syste:

; 265  :     }
; 266  : 
; 267  :     /* Perform subsystem reset
; 268  :      *
; 269  :      * GA22-7000-10 IBM System/370 Principles of Operation, Chapter 4.
; 270  :      *              Control, Subsystem Reset, p. 4-34
; 271  :      * SA22-7085-00 IBM System/370 Extended Architecture Principles of
; 272  :      *              Operation, Chapter 4. Control, Subsystem Reset,
; 273  :      *              p. 4-28
; 274  :      * SA22-7832-09 z/Architecture Principles of Operation, Chapter 4.
; 275  :      *              Control, Subsystem Reset, p. 4-57
; 276  :      */
; 277  :     subsystem_reset();

  005ca	e8 00 00 00 00	 call	 subsystem_reset

; 278  : 
; 279  :     /* Perform system-reset-clear additional functions */
; 280  :     if (clear)

  005cf	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR clear$[rsp]
  005d7	85 c0		 test	 eax, eax
  005d9	0f 84 0c 01 00
	00		 je	 $LN51@s390_syste

; 281  :     {
; 282  :         /* Finish reset-clear of all CPUs in the configuration */
; 283  :         for (n = 0; n < sysblk.maxcpu; ++n)

  005df	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  005e7	eb 0a		 jmp	 SHORT $LN28@s390_syste
$LN26@s390_syste:
  005e9	8b 44 24 40	 mov	 eax, DWORD PTR n$[rsp]
  005ed	ff c0		 inc	 eax
  005ef	89 44 24 40	 mov	 DWORD PTR n$[rsp], eax
$LN28@s390_syste:
  005f3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005fa	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00600	39 44 24 40	 cmp	 DWORD PTR n$[rsp], eax
  00604	0f 8d 84 00 00
	00		 jge	 $LN27@s390_syste

; 284  :         {
; 285  :             if (IS_CPU_ONLINE( n ))

  0060a	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$[rsp]
  0060f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00616	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0061f	74 68		 je	 SHORT $LN53@s390_syste

; 286  :             {
; 287  :                 regs = sysblk.regs[ n ];

  00621	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$[rsp]
  00626	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0062d	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00635	48 89 44 24 48	 mov	 QWORD PTR regs$[rsp], rax

; 288  : 
; 289  :                 /* Clear all the registers (AR, GPR, FPR, VR)
; 290  :                  * as part of the CPU CLEAR RESET operation
; 291  :                  */
; 292  :                 memset( regs->ar,  0, sizeof( regs->ar  ));

  0063a	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0063f	48 05 00 03 00
	00		 add	 rax, 768		; 00000300H
  00645	48 8b f8	 mov	 rdi, rax
  00648	33 c0		 xor	 eax, eax
  0064a	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0064f	f3 aa		 rep stosb

; 293  :                 memset( regs->gr,  0, sizeof( regs->gr  ));

  00651	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00656	48 05 80 02 00
	00		 add	 rax, 640		; 00000280H
  0065c	48 8b f8	 mov	 rdi, rax
  0065f	33 c0		 xor	 eax, eax
  00661	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00666	f3 aa		 rep stosb

; 294  :                 memset( regs->fpr, 0, sizeof( regs->fpr ));

  00668	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0066d	48 05 40 03 00
	00		 add	 rax, 832		; 00000340H
  00673	48 8b f8	 mov	 rdi, rax
  00676	33 c0		 xor	 eax, eax
  00678	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0067d	f3 aa		 rep stosb

; 295  : 
; 296  : #if defined( _FEATURE_S370_S390_VECTOR_FACILITY )
; 297  :                 memset( regs->vf->vr, 0, sizeof( regs->vf->vr ));
; 298  : #endif
; 299  :                 /* Clear the instruction counter and CPU time used */
; 300  :                 cpu_reset_instcount_and_cputime( regs );

  0067f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00684	e8 00 00 00 00	 call	 cpu_reset_instcount_and_cputime
$LN53@s390_syste:

; 301  :             }
; 302  :         }

  00689	e9 5b ff ff ff	 jmp	 $LN26@s390_syste
$LN27@s390_syste:

; 303  : 
; 304  :         /* Clear storage */
; 305  :         sysblk.main_clear = sysblk.xpnd_clear = 0;

  0068e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00695	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0069b	0f ba f0 0f	 btr	 eax, 15
  0069f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006a6	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
  006ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006b3	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  006b9	0f ba f0 0e	 btr	 eax, 14
  006bd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006c4	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 306  :         storage_clear();

  006ca	e8 00 00 00 00	 call	 storage_clear

; 307  :         xstorage_clear();

  006cf	e8 00 00 00 00	 call	 xstorage_clear

; 308  : 
; 309  :         /* Clear IPL program parameter */
; 310  :         sysblk.program_parameter = 0;

  006d4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006db	48 c7 80 18 0e
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+3608], 0

; 311  :     }

  006e6	e9 80 00 00 00	 jmp	 $LN52@s390_syste
$LN51@s390_syste:

; 312  : 
; 313  :     /* If IPL call, reset CPU instruction counts and times */
; 314  :     else if (ipl)

  006eb	0f b6 84 24 c0
	00 00 00	 movzx	 eax, BYTE PTR ipl$[rsp]
  006f3	85 c0		 test	 eax, eax
  006f5	74 74		 je	 SHORT $LN54@s390_syste

; 315  :     {
; 316  :         CPU_BITMAP  mask  = sysblk.config_mask;

  006f7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006fe	48 8b 80 a8 12
	00 00		 mov	 rax, QWORD PTR [rax+4776]
  00705	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR mask$7[rsp], rax

; 317  : 
; 318  :         for (n=0; mask; mask >>= 1, ++n)

  0070d	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  00715	eb 1d		 jmp	 SHORT $LN31@s390_syste
$LN29@s390_syste:
  00717	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR mask$7[rsp]
  0071f	48 d1 e8	 shr	 rax, 1
  00722	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR mask$7[rsp], rax
  0072a	8b 44 24 40	 mov	 eax, DWORD PTR n$[rsp]
  0072e	ff c0		 inc	 eax
  00730	89 44 24 40	 mov	 DWORD PTR n$[rsp], eax
$LN31@s390_syste:
  00734	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR mask$7[rsp], 0
  0073d	74 2c		 je	 SHORT $LN30@s390_syste

; 319  :         {
; 320  :             if (mask & 0x01)

  0073f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR mask$7[rsp]
  00747	48 83 e0 01	 and	 rax, 1
  0074b	48 85 c0	 test	 rax, rax
  0074e	74 19		 je	 SHORT $LN55@s390_syste

; 321  :                 cpu_reset_instcount_and_cputime( sysblk.regs[ n ]);

  00750	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$[rsp]
  00755	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0075c	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  00764	e8 00 00 00 00	 call	 cpu_reset_instcount_and_cputime
$LN55@s390_syste:

; 322  :         }

  00769	eb ac		 jmp	 SHORT $LN29@s390_syste
$LN30@s390_syste:
$LN54@s390_syste:
$LN52@s390_syste:

; 323  :     }
; 324  : 
; 325  :     /* If IPL or system-reset-clear, clear the system
; 326  :      * instruction counter, rates, and IPLed indicator.
; 327  :      */
; 328  :     if (clear || ipl)

  0076b	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR clear$[rsp]
  00773	85 c0		 test	 eax, eax
  00775	75 0c		 jne	 SHORT $LN57@s390_syste
  00777	0f b6 84 24 c0
	00 00 00	 movzx	 eax, BYTE PTR ipl$[rsp]
  0077f	85 c0		 test	 eax, eax
  00781	74 51		 je	 SHORT $LN56@s390_syste
$LN57@s390_syste:

; 329  :     {
; 330  :         /* Clear system instruction counter and CPU rates */
; 331  :         sysblk.instcount = 0;

  00783	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0078a	48 c7 80 80 14
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+5248], 0

; 332  :         sysblk.mipsrate  = 0;

  00795	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0079c	c7 80 88 14 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5256], 0

; 333  :         sysblk.siosrate  = 0;

  007a6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007ad	c7 80 8c 14 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5260], 0

; 334  :         sysblk.ipled     = FALSE;

  007b7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007be	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  007c4	83 e0 fd	 and	 eax, -3			; fffffffdH
  007c7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  007ce	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
$LN56@s390_syste:

; 335  :     }
; 336  : 
; 337  :     /* Set horizontal polarization and clear the
; 338  :        topology-change-report-pending condition.
; 339  :     */
; 340  : #if defined( FEATURE_011_CONFIG_TOPOLOGY_FACILITY )
; 341  :     sysblk.topology = TOPOLOGY_HORIZ;
; 342  :     sysblk.topchnge = 0;
; 343  : #endif
; 344  : 
; 345  :     /* Set the system state to "reset" */
; 346  :     sysblk.sys_reset = TRUE;

  007d4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007db	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  007e1	83 c8 01	 or	 eax, 1
  007e4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  007eb	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 347  : 
; 348  :     return 0;

  007f1	33 c0		 xor	 eax, eax
$LN1@s390_syste:

; 349  : } /* end function system_reset */

  007f3	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  007fa	5f		 pop	 rdi
  007fb	c3		 ret	 0
s390_system_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ipl.c
_TEXT	SEGMENT
chanstat$ = 80
unitstat$ = 81
i$ = 84
dev$ = 88
regs$ = 96
rc$ = 104
tv304 = 108
tv306 = 112
tv81 = 120
tv148 = 128
tv168 = 136
tv316 = 144
tv336 = 152
buf2$1 = 160
buf$2 = 176
buf$3 = 256
buf$4 = 336
buffer$5 = 416
__$ArrayPad$ = 672
lcss$ = 704
devnum$ = 712
cpu$ = 720
clear$ = 728
s390_load_ipl PROC

; 416  : {

$LN20:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000f	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00014	57		 push	 rdi
  00015	48 81 ec b0 02
	00 00		 sub	 rsp, 688		; 000002b0H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 a0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 417  : REGS   *regs;                           /* -> Regs                   */
; 418  : DEVBLK *dev;                            /* -> Device control block   */
; 419  : int     i;                              /* Array subscript           */
; 420  : BYTE    unitstat;                       /* IPL device unit status    */
; 421  : BYTE    chanstat;                       /* IPL device channel status */
; 422  : int rc;
; 423  : 
; 424  :     /* Get started */
; 425  :     if ((rc = ARCH_DEP( common_load_begin )( cpu, clear )))

  0002e	8b 94 24 d8 02
	00 00		 mov	 edx, DWORD PTR clear$[rsp]
  00035	8b 8c 24 d0 02
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  0003c	e8 00 00 00 00	 call	 s390_common_load_begin
  00041	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax
  00045	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  0004a	74 09		 je	 SHORT $LN8@s390_load_

; 426  :         return rc;

  0004c	8b 44 24 68	 mov	 eax, DWORD PTR rc$[rsp]
  00050	e9 d9 07 00 00	 jmp	 $LN1@s390_load_
$LN8@s390_load_:

; 427  : 
; 428  :     /* Ensure CPU is online */
; 429  :     if (!IS_CPU_ONLINE(cpu))

  00055	48 63 84 24 d0
	02 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0005d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00064	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0006d	0f 85 c6 00 00
	00		 jne	 $LN9@s390_load_

; 430  :     {
; 431  :         char buf[80];
; 432  :         MSGBUF(buf, "CP%2.2X Offline", devnum);

  00073	0f b7 84 24 c8
	02 00 00	 movzx	 eax, WORD PTR devnum$[rsp]
  0007b	44 8b c8	 mov	 r9d, eax
  0007e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180005
  00085	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  0008a	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR buf$3[rsp]
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 433  :         // "Processor %s%02X: ipl failed: %s"
; 434  :         WRMSG (HHC00810, "E", PTYPSTR(sysblk.pcpu), sysblk.pcpu, buf);

  00098	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0009f	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  000a6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000ad	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  000bb	48 89 44 24 78	 mov	 QWORD PTR tv81[rsp], rax
  000c0	b9 01 00 00 00	 mov	 ecx, 1
  000c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000cb	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR buf$3[rsp]
  000d3	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000d8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000df	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  000e5	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000e9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv81[rsp]
  000ee	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180006
  000fa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180007
  00106	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0010b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00110	41 b9 03 00 00
	00		 mov	 r9d, 3
  00116	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180008
  0011d	ba b2 01 00 00	 mov	 edx, 434		; 000001b2H
  00122	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180009
  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 435  :         return -1;

  0012f	b8 ff ff ff ff	 mov	 eax, -1
  00134	e9 f5 06 00 00	 jmp	 $LN1@s390_load_
$LN9@s390_load_:

; 436  :     }
; 437  : 
; 438  :     /* The actual IPL proper starts here... */
; 439  : 
; 440  :     regs = sysblk.regs[cpu];    /* Point to IPL CPU's registers */

  00139	48 63 84 24 d0
	02 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00141	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00148	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00150	48 89 44 24 60	 mov	 QWORD PTR regs$[rsp], rax

; 441  :     /* Point to the device block for the IPL device */
; 442  :     dev = find_device_by_devnum (lcss,devnum);

  00155	0f b7 94 24 c8
	02 00 00	 movzx	 edx, WORD PTR devnum$[rsp]
  0015d	0f b7 8c 24 c0
	02 00 00	 movzx	 ecx, WORD PTR lcss$[rsp]
  00165	e8 00 00 00 00	 call	 find_device_by_devnum
  0016a	48 89 44 24 58	 mov	 QWORD PTR dev$[rsp], rax

; 443  :     if (dev == NULL)

  0016f	48 83 7c 24 58
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00175	0f 85 09 01 00
	00		 jne	 $LN10@s390_load_

; 444  :     {
; 445  :         char buf[80];
; 446  :         MSGBUF( buf, "device %1d:%04X not found", lcss, devnum );

  0017b	0f b7 84 24 c8
	02 00 00	 movzx	 eax, WORD PTR devnum$[rsp]
  00183	0f b7 8c 24 c0
	02 00 00	 movzx	 ecx, WORD PTR lcss$[rsp]
  0018b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0018f	44 8b c9	 mov	 r9d, ecx
  00192	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180011
  00199	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  0019e	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$4[rsp]
  001a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 447  :         // "Processor %s%02X: ipl failed: %s"
; 448  :         WRMSG( HHC00810, "E", PTYPSTR( sysblk.pcpu ), sysblk.pcpu, buf );

  001ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001b3	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  001ba	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001c1	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  001c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  001cf	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv148[rsp], rax
  001d7	b9 01 00 00 00	 mov	 ecx, 1
  001dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001e2	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$4[rsp]
  001ea	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001ef	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001f6	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  001fc	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00200	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv148[rsp]
  00208	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0020d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180012
  00214	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00219	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180013
  00220	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00225	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0022a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00230	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180014
  00237	ba c0 01 00 00	 mov	 edx, 448		; 000001c0H
  0023c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180015
  00243	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 449  : 
; 450  :         /* HercGUI hook so it can update its LEDs */
; 451  :         HDC1( debug_cpu_state, regs );

  00249	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  00250	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00254	74 18		 je	 SHORT $LN16@s390_load_
  00256	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0025b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  00262	ff 10		 call	 QWORD PTR [rax]
  00264	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv168[rsp], rax
  0026c	eb 0c		 jmp	 SHORT $LN17@s390_load_
$LN16@s390_load_:
  0026e	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv168[rsp], 0
$LN17@s390_load_:

; 452  : 
; 453  :         return -1;

  0027a	b8 ff ff ff ff	 mov	 eax, -1
  0027f	e9 aa 05 00 00	 jmp	 $LN1@s390_load_
$LN10@s390_load_:

; 454  :     }
; 455  : 
; 456  :     if(sysblk.haveiplparm)

  00284	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0028b	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00291	c1 e8 15	 shr	 eax, 21
  00294	83 e0 01	 and	 eax, 1
  00297	85 c0		 test	 eax, eax
  00299	74 73		 je	 SHORT $LN11@s390_load_

; 457  :     {
; 458  :         for(i=0;i<16;i++)

  0029b	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002a3	eb 0a		 jmp	 SHORT $LN4@s390_load_
$LN2@s390_load_:
  002a5	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  002a9	ff c0		 inc	 eax
  002ab	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN4@s390_load_:
  002af	83 7c 24 54 10	 cmp	 DWORD PTR i$[rsp], 16
  002b4	7d 3a		 jge	 SHORT $LN3@s390_load_

; 459  :         {
; 460  :             regs->GR_L(i)=fetch_fw(&sysblk.iplparmstring[i*4]);

  002b6	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  002ba	c1 e0 02	 shl	 eax, 2
  002bd	48 98		 cdqe
  002bf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002c6	48 8d 84 01 f8
	12 00 00	 lea	 rax, QWORD PTR [rcx+rax+4856]
  002ce	48 8b c8	 mov	 rcx, rax
  002d1	e8 00 00 00 00	 call	 fetch_fw_noswap
  002d6	8b c8		 mov	 ecx, eax
  002d8	e8 00 00 00 00	 call	 _byteswap_ulong
  002dd	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR i$[rsp]
  002e2	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  002e7	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 461  :         }

  002ee	eb b5		 jmp	 SHORT $LN2@s390_load_
$LN3@s390_load_:

; 462  :         sysblk.haveiplparm=0;

  002f0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002f7	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  002fd	0f ba f0 15	 btr	 eax, 21
  00301	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00308	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
$LN11@s390_load_:

; 463  :     }
; 464  : 
; 465  :     /* Set Main Storage Reference and Update bits */
; 466  :     ARCH_DEP( or_storage_key )( regs->PX, (STORKEY_REF | STORKEY_CHANGE) );

  0030e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00313	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00316	b2 06		 mov	 dl, 6
  00318	8b c8		 mov	 ecx, eax
  0031a	e8 00 00 00 00	 call	 s390_or_storage_key

; 467  :     sysblk.main_clear = sysblk.xpnd_clear = 0;

  0031f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00326	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0032c	0f ba f0 0f	 btr	 eax, 15
  00330	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00337	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
  0033d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00344	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0034a	0f ba f0 0e	 btr	 eax, 14
  0034e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00355	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 468  : 
; 469  :     /* Build the IPL CCW at location 0 */
; 470  :     regs->psa->iplpsw[0] = 0x02;              /* CCW command = Read */

  0035b	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00360	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  00367	b9 01 00 00 00	 mov	 ecx, 1
  0036c	48 6b c9 00	 imul	 rcx, rcx, 0
  00370	c6 04 08 02	 mov	 BYTE PTR [rax+rcx], 2

; 471  :     regs->psa->iplpsw[1] = 0;                 /* Data address = zero */

  00374	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00379	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  00380	b9 01 00 00 00	 mov	 ecx, 1
  00385	48 6b c9 01	 imul	 rcx, rcx, 1
  00389	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 472  :     regs->psa->iplpsw[2] = 0;

  0038d	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00392	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  00399	b9 01 00 00 00	 mov	 ecx, 1
  0039e	48 6b c9 02	 imul	 rcx, rcx, 2
  003a2	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 473  :     regs->psa->iplpsw[3] = 0;

  003a6	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  003ab	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  003b2	b9 01 00 00 00	 mov	 ecx, 1
  003b7	48 6b c9 03	 imul	 rcx, rcx, 3
  003bb	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 474  :     regs->psa->iplpsw[4] = CCW_FLAGS_CC | CCW_FLAGS_SLI;

  003bf	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  003c4	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  003cb	b9 01 00 00 00	 mov	 ecx, 1
  003d0	48 6b c9 04	 imul	 rcx, rcx, 4
  003d4	c6 04 08 60	 mov	 BYTE PTR [rax+rcx], 96	; 00000060H

; 475  :                                         /* CCW flags */
; 476  :     regs->psa->iplpsw[5] = 0;                 /* Reserved byte */

  003d8	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  003dd	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  003e4	b9 01 00 00 00	 mov	 ecx, 1
  003e9	48 6b c9 05	 imul	 rcx, rcx, 5
  003ed	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 477  :     regs->psa->iplpsw[6] = 0;                 /* Byte count = 24 */

  003f1	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  003f6	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  003fd	b9 01 00 00 00	 mov	 ecx, 1
  00402	48 6b c9 06	 imul	 rcx, rcx, 6
  00406	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 478  :     regs->psa->iplpsw[7] = 24;

  0040a	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0040f	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  00416	b9 01 00 00 00	 mov	 ecx, 1
  0041b	48 6b c9 07	 imul	 rcx, rcx, 7
  0041f	c6 04 08 18	 mov	 BYTE PTR [rax+rcx], 24

; 479  : 
; 480  :     /* Enable the subchannel for the IPL device */
; 481  :     dev->pmcw.flag5 |= PMCW5_E;

  00423	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  00428	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0042f	0f ba e8 07	 bts	 eax, 7
  00433	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dev$[rsp]
  00438	88 81 f1 02 00
	00		 mov	 BYTE PTR [rcx+753], al

; 482  : 
; 483  :     /* Build the operation request block */
; 484  :     memset (&dev->orb, 0, sizeof(ORB));

  0043e	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  00443	48 05 cc 02 00
	00		 add	 rax, 716		; 000002ccH
  00449	48 8b f8	 mov	 rdi, rax
  0044c	33 c0		 xor	 eax, eax
  0044e	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00453	f3 aa		 rep stosb

; 485  :     dev->busy = 1;

  00455	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  0045a	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00460	0f ba e8 13	 bts	 eax, 19
  00464	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dev$[rsp]
  00469	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 486  : 
; 487  :     RELEASE_INTLOCK(NULL);

  0046f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180017
  00476	33 c9		 xor	 ecx, ecx
  00478	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 488  : 
; 489  :     /* Execute the IPL channel program */
; 490  :     ARCH_DEP(execute_ccw_chain) (dev);

  0047d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dev$[rsp]
  00482	e8 00 00 00 00	 call	 s390_execute_ccw_chain

; 491  : 
; 492  :     OBTAIN_INTLOCK(NULL);

  00487	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180018
  0048e	33 c9		 xor	 ecx, ecx
  00490	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 493  : 
; 494  :     /* Clear the interrupt pending and device busy conditions */
; 495  :     obtain_lock (&sysblk.iointqlk);

  00495	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0049c	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  004a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180019
  004a9	48 8b c8	 mov	 rcx, rax
  004ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 496  :     DEQUEUE_IO_INTERRUPT_QLOCKED(&dev->ioint);

  004b2	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  004b7	48 05 28 02 00
	00		 add	 rax, 552		; 00000228H
  004bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180020
  004c4	48 8b c8	 mov	 rcx, rax
  004c7	e8 00 00 00 00	 call	 Dequeue_IO_Interrupt_QLocked

; 497  :     DEQUEUE_IO_INTERRUPT_QLOCKED(&dev->pciioint);

  004cc	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  004d1	48 05 40 02 00
	00		 add	 rax, 576		; 00000240H
  004d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180021
  004de	48 8b c8	 mov	 rcx, rax
  004e1	e8 00 00 00 00	 call	 Dequeue_IO_Interrupt_QLocked

; 498  :     DEQUEUE_IO_INTERRUPT_QLOCKED(&dev->attnioint);

  004e6	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  004eb	48 05 58 02 00
	00		 add	 rax, 600		; 00000258H
  004f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180022
  004f8	48 8b c8	 mov	 rcx, rax
  004fb	e8 00 00 00 00	 call	 Dequeue_IO_Interrupt_QLocked

; 499  :     release_lock(&sysblk.iointqlk);

  00500	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00507	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  0050d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180023
  00514	48 8b c8	 mov	 rcx, rax
  00517	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 500  :     dev->busy = 0;

  0051d	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  00522	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00528	0f ba f0 13	 btr	 eax, 19
  0052c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dev$[rsp]
  00531	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 501  :     dev->scsw.flag2 = 0;

  00537	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  0053c	c6 80 0a 03 00
	00 00		 mov	 BYTE PTR [rax+778], 0

; 502  :     dev->scsw.flag3 = 0;

  00543	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  00548	c6 80 0b 03 00
	00 00		 mov	 BYTE PTR [rax+779], 0

; 503  : 
; 504  :     /* Check that load completed normally */
; 505  :     unitstat = dev->scsw.unitstat;

  0054f	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  00554	0f b6 80 10 03
	00 00		 movzx	 eax, BYTE PTR [rax+784]
  0055b	88 44 24 51	 mov	 BYTE PTR unitstat$[rsp], al

; 506  :     chanstat = dev->scsw.chanstat;

  0055f	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  00564	0f b6 80 11 03
	00 00		 movzx	 eax, BYTE PTR [rax+785]
  0056b	88 44 24 50	 mov	 BYTE PTR chanstat$[rsp], al

; 507  : 
; 508  :     if (unitstat != (CSW_CE | CSW_DE) || chanstat != 0)

  0056f	0f b6 44 24 51	 movzx	 eax, BYTE PTR unitstat$[rsp]
  00574	83 f8 0c	 cmp	 eax, 12
  00577	75 0d		 jne	 SHORT $LN13@s390_load_
  00579	0f b6 44 24 50	 movzx	 eax, BYTE PTR chanstat$[rsp]
  0057e	85 c0		 test	 eax, eax
  00580	0f 84 db 01 00
	00		 je	 $LN12@s390_load_
$LN13@s390_load_:

; 509  :     {
; 510  :         char buf[80];
; 511  :         char buf2[16];
; 512  : 
; 513  :         memset(buf,0,sizeof(buf));

  00586	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR buf$2[rsp]
  0058e	48 8b f8	 mov	 rdi, rax
  00591	33 c0		 xor	 eax, eax
  00593	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00598	f3 aa		 rep stosb

; 514  :         for (i=0; i < (int)dev->numsense; i++)

  0059a	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  005a2	eb 0a		 jmp	 SHORT $LN7@s390_load_
$LN5@s390_load_:
  005a4	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  005a8	ff c0		 inc	 eax
  005aa	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN7@s390_load_:
  005ae	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  005b3	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  005b9	39 44 24 54	 cmp	 DWORD PTR i$[rsp], eax
  005bd	7d 77		 jge	 SHORT $LN6@s390_load_

; 515  :         {
; 516  :             MSGBUF(buf2, "%2.2X", dev->sense[i]);

  005bf	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  005c4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dev$[rsp]
  005c9	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  005d1	44 8b c8	 mov	 r9d, eax
  005d4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180026
  005db	ba 10 00 00 00	 mov	 edx, 16
  005e0	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR buf2$1[rsp]
  005e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 517  :             STRLCAT( buf, buf2 );

  005ee	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  005f4	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR buf2$1[rsp]
  005fc	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  00604	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 518  :             if ((i & 3) == 3) STRLCAT( buf, " " );

  0060a	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  0060e	83 e0 03	 and	 eax, 3
  00611	83 f8 03	 cmp	 eax, 3
  00614	75 1b		 jne	 SHORT $LN14@s390_load_
  00616	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  0061c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180028
  00623	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  0062b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN14@s390_load_:

; 519  :         }

  00631	e9 6e ff ff ff	 jmp	 $LN5@s390_load_
$LN6@s390_load_:

; 520  :         {
; 521  :             char buffer[256];
; 522  :             MSGBUF(buffer, "architecture mode %s, csw status %2.2X%2.2X, sense %s",

  00636	0f b6 44 24 50	 movzx	 eax, BYTE PTR chanstat$[rsp]
  0063b	89 44 24 6c	 mov	 DWORD PTR tv304[rsp], eax
  0063f	0f b6 4c 24 51	 movzx	 ecx, BYTE PTR unitstat$[rsp]
  00644	89 4c 24 70	 mov	 DWORD PTR tv306[rsp], ecx
  00648	33 c9		 xor	 ecx, ecx
  0064a	e8 00 00 00 00	 call	 get_arch_name
  0064f	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  00657	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0065c	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv304[rsp]
  00660	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  00664	8b 4c 24 70	 mov	 ecx, DWORD PTR tv306[rsp]
  00668	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0066c	4c 8b c8	 mov	 r9, rax
  0066f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180029
  00676	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0067b	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR buffer$5[rsp]
  00683	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 523  :                 get_arch_name( NULL ),
; 524  :                 unitstat, chanstat, buf);
; 525  :             WRMSG (HHC00828, "E", PTYPSTR(sysblk.pcpu), sysblk.pcpu, buffer);

  00689	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00690	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00697	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0069e	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  006a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  006ac	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv316[rsp], rax
  006b4	b9 01 00 00 00	 mov	 ecx, 1
  006b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006bf	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR buffer$5[rsp]
  006c7	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  006cc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006d3	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  006d9	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006dd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv316[rsp]
  006e5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  006ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180030
  006f1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180031
  006fd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00702	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00707	41 b9 03 00 00
	00		 mov	 r9d, 3
  0070d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180032
  00714	ba 0d 02 00 00	 mov	 edx, 525		; 0000020dH
  00719	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180033
  00720	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 526  :         }
; 527  : 
; 528  :         /* HercGUI hook so it can update its LEDs */
; 529  :         HDC1( debug_cpu_state, regs );

  00726	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  0072d	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00731	74 18		 je	 SHORT $LN18@s390_load_
  00733	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00738	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  0073f	ff 10		 call	 QWORD PTR [rax]
  00741	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv336[rsp], rax
  00749	eb 0c		 jmp	 SHORT $LN19@s390_load_
$LN18@s390_load_:
  0074b	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv336[rsp], 0
$LN19@s390_load_:

; 530  : 
; 531  :         return -1;

  00757	b8 ff ff ff ff	 mov	 eax, -1
  0075c	e9 cd 00 00 00	 jmp	 $LN1@s390_load_
$LN12@s390_load_:

; 532  :     }
; 533  : 
; 534  : #ifdef FEATURE_S370_CHANNEL
; 535  :     /* Test the EC mode bit in the IPL PSW */
; 536  :     if (regs->psa->iplpsw[1] & 0x08) {
; 537  :         /* In EC mode, store device address at locations 184-187 */
; 538  :         STORE_FW(regs->psa->ioid, dev->devnum);
; 539  :     } else {
; 540  :         /* In BC mode, store device address at locations 2-3 */
; 541  :         STORE_HW(regs->psa->iplpsw + 2, dev->devnum);
; 542  :     }
; 543  : #endif /*FEATURE_S370_CHANNEL*/
; 544  : 
; 545  : #ifdef FEATURE_CHANNEL_SUBSYSTEM
; 546  :     /* Set LPUM */
; 547  :     dev->pmcw.lpum = 0x80;

  00761	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  00766	c6 80 f6 02 00
	00 80		 mov	 BYTE PTR [rax+758], 128	; 00000080H

; 548  :     STORE_FW(regs->psa->ioid, (dev->ssid<<16)|dev->subchan);

  0076d	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  00772	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00776	c1 e0 10	 shl	 eax, 16
  00779	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dev$[rsp]
  0077e	0f b7 49 46	 movzx	 ecx, WORD PTR [rcx+70]
  00782	0b c1		 or	 eax, ecx
  00784	8b c8		 mov	 ecx, eax
  00786	e8 00 00 00 00	 call	 _byteswap_ulong
  0078b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00790	48 8b 89 60 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2144]
  00797	48 81 c1 b8 00
	00 00		 add	 rcx, 184		; 000000b8H
  0079e	8b d0		 mov	 edx, eax
  007a0	e8 00 00 00 00	 call	 store_fw_noswap

; 549  : 
; 550  :     /* Store zeroes at locations 188-191 */
; 551  :     memset (regs->psa->ioparm, 0, 4);

  007a5	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  007aa	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  007b1	48 05 bc 00 00
	00		 add	 rax, 188		; 000000bcH
  007b7	48 8b f8	 mov	 rdi, rax
  007ba	33 c0		 xor	 eax, eax
  007bc	b9 04 00 00 00	 mov	 ecx, 4
  007c1	f3 aa		 rep stosb

; 552  : #endif /*FEATURE_CHANNEL_SUBSYSTEM*/
; 553  : 
; 554  :     /* Save IPL device number, cpu number and lcss */
; 555  :     sysblk.ipldev = devnum;

  007c3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007ca	0f b7 8c 24 c8
	02 00 00	 movzx	 ecx, WORD PTR devnum$[rsp]
  007d2	66 89 88 f2 00
	00 00		 mov	 WORD PTR [rax+242], cx

; 556  :     sysblk.iplcpu = regs->cpuad;

  007d9	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  007de	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  007e5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  007ec	89 81 f4 00 00
	00		 mov	 DWORD PTR [rcx+244], eax

; 557  :     sysblk.ipllcss = lcss;

  007f2	0f b7 84 24 c0
	02 00 00	 movzx	 eax, WORD PTR lcss$[rsp]
  007fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00801	89 81 f8 00 00
	00		 mov	 DWORD PTR [rcx+248], eax

; 558  :     sysblk.ipled = TRUE;

  00807	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0080e	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00814	83 c8 02	 or	 eax, 2
  00817	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0081e	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 559  : 
; 560  :     /* Finish up... */
; 561  :     return ARCH_DEP(common_load_finish) (regs);

  00824	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00829	e8 00 00 00 00	 call	 s390_common_load_finish
$LN1@s390_load_:

; 562  : } /* end function load_ipl */

  0082e	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00836	48 33 cc	 xor	 rcx, rsp
  00839	e8 00 00 00 00	 call	 __security_check_cookie
  0083e	48 81 c4 b0 02
	00 00		 add	 rsp, 688		; 000002b0H
  00845	5f		 pop	 rdi
  00846	c3		 ret	 0
s390_load_ipl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ipl.c
_TEXT	SEGMENT
i$1 = 32
i$2 = 36
mask$3 = 40
mask$4 = 48
subsystem_reset PROC

; 72   : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@subsystem_:

; 73   :     /* Perform subsystem reset
; 74   :      *
; 75   :      * GA22-7000-10 IBM System/370 Principles of Operation, Chapter 4.
; 76   :      *              Control, Subsystem Reset, p. 4-34
; 77   :      * SA22-7085-00 IBM System/370 Extended Architecture Principles of
; 78   :      *              Operation, Chapter 4. Control, Subsystem Reset,
; 79   :      *              p. 4-28
; 80   :      * SA22-7832-09 z/Architecture Principles of Operation, Chapter 4.
; 81   :      *              Control, Subsystem Reset, p. 4-57
; 82   :      */
; 83   : 
; 84   :     /* Clear pending external interrupts */
; 85   :     OFF_IC_SERVSIG;

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00011	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00016	85 c0		 test	 eax, eax
  00018	0f 84 9c 00 00
	00		 je	 $LN14@subsystem_
  0001e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00025	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  0002b	0f ba f0 09	 btr	 eax, 9
  0002f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00036	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  0003c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00043	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  0004a	48 89 44 24 28	 mov	 QWORD PTR mask$3[rsp], rax
  0004f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00057	eb 0a		 jmp	 SHORT $LN7@subsystem_
$LN5@subsystem_:
  00059	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0005d	ff c0		 inc	 eax
  0005f	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN7@subsystem_:
  00063	48 83 7c 24 28
	00		 cmp	 QWORD PTR mask$3[rsp], 0
  00069	74 4f		 je	 SHORT $LN6@subsystem_
  0006b	48 8b 44 24 28	 mov	 rax, QWORD PTR mask$3[rsp]
  00070	48 83 e0 01	 and	 rax, 1
  00074	48 85 c0	 test	 rax, rax
  00077	74 32		 je	 SHORT $LN15@subsystem_
  00079	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  0007e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00085	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0008d	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00090	0f ba f0 09	 btr	 eax, 9
  00094	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00099	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  000a0	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  000a8	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN15@subsystem_:
  000ab	48 8b 44 24 28	 mov	 rax, QWORD PTR mask$3[rsp]
  000b0	48 d1 e8	 shr	 rax, 1
  000b3	48 89 44 24 28	 mov	 QWORD PTR mask$3[rsp], rax
  000b8	eb 9f		 jmp	 SHORT $LN5@subsystem_
$LN6@subsystem_:
$LN14@subsystem_:
  000ba	33 c0		 xor	 eax, eax
  000bc	85 c0		 test	 eax, eax
  000be	0f 85 40 ff ff
	ff		 jne	 $LN4@subsystem_
$LN10@subsystem_:

; 86   :     OFF_IC_INTKEY;

  000c4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000cb	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  000d1	83 e0 40	 and	 eax, 64			; 00000040H
  000d4	85 c0		 test	 eax, eax
  000d6	0f 84 9a 00 00
	00		 je	 $LN16@subsystem_
  000dc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000e3	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  000e9	83 e0 bf	 and	 eax, -65		; ffffffbfH
  000ec	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000f3	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  000f9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00100	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  00107	48 89 44 24 30	 mov	 QWORD PTR mask$4[rsp], rax
  0010c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  00114	eb 0a		 jmp	 SHORT $LN13@subsystem_
$LN11@subsystem_:
  00116	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  0011a	ff c0		 inc	 eax
  0011c	89 44 24 24	 mov	 DWORD PTR i$2[rsp], eax
$LN13@subsystem_:
  00120	48 83 7c 24 30
	00		 cmp	 QWORD PTR mask$4[rsp], 0
  00126	74 4e		 je	 SHORT $LN12@subsystem_
  00128	48 8b 44 24 30	 mov	 rax, QWORD PTR mask$4[rsp]
  0012d	48 83 e0 01	 and	 rax, 1
  00131	48 85 c0	 test	 rax, rax
  00134	74 31		 je	 SHORT $LN17@subsystem_
  00136	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$2[rsp]
  0013b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00142	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0014a	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0014d	83 e0 bf	 and	 eax, -65		; ffffffbfH
  00150	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR i$2[rsp]
  00155	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0015c	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00164	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN17@subsystem_:
  00167	48 8b 44 24 30	 mov	 rax, QWORD PTR mask$4[rsp]
  0016c	48 d1 e8	 shr	 rax, 1
  0016f	48 89 44 24 30	 mov	 QWORD PTR mask$4[rsp], rax
  00174	eb a0		 jmp	 SHORT $LN11@subsystem_
$LN12@subsystem_:
$LN16@subsystem_:
  00176	33 c0		 xor	 eax, eax
  00178	85 c0		 test	 eax, eax
  0017a	0f 85 44 ff ff
	ff		 jne	 $LN10@subsystem_

; 87   : 
; 88   :     /* Reset the I/O subsystem */
; 89   :     RELEASE_INTLOCK( NULL );

  00180	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169570
  00187	33 c9		 xor	 ecx, ecx
  00189	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 90   :     {
; 91   :         io_reset ();

  0018e	e8 00 00 00 00	 call	 io_reset

; 92   :     }
; 93   :     OBTAIN_INTLOCK( NULL );

  00193	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169571
  0019a	33 c9		 xor	 ecx, ecx
  0019c	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 94   : }

  001a1	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001a5	c3		 ret	 0
subsystem_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ipl.c
_TEXT	SEGMENT
regs$ = 48
cpu_reset_instcount_and_cputime PROC

; 48   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 49   :     /* Reset instruction counts, I/O counts and real CPU time */
; 50   :     regs->prevcount = 0;

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0000e	48 c7 80 90 07
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1936], 0

; 51   :     regs->instcount = 0;

  00019	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001e	c7 80 98 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1944], 0

; 52   :     regs->mipsrate  = 0;

  00028	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0002d	c7 80 9c 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1948], 0

; 53   :     regs->siocount  = 0;

  00037	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0003c	c7 80 a0 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1952], 0

; 54   :     regs->siosrate  = 0;

  00046	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	c7 80 a4 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1956], 0

; 55   :     regs->siototal  = 0;

  00055	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0005a	48 c7 80 a8 07
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1960], 0

; 56   :     regs->cpupct    = 0;

  00065	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	c7 80 b0 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1968], 0

; 57   :     regs->rcputime  = 0;

  00074	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00079	48 c7 80 80 07
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1920], 0

; 58   :     regs->bcputime  = thread_cputime_us( regs );

  00084	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	e8 00 00 00 00	 call	 thread_cputime_us
  0008e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00093	48 89 81 88 07
	00 00		 mov	 QWORD PTR [rcx+1928], rax

; 59   : }

  0009a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0009e	c3		 ret	 0
cpu_reset_instcount_and_cputime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s370_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 s370_or_2K_storage_key

; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );
; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
s370_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_or_2K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s370_or_2K_storage_key PROC				; COMDAT

; 231  :   inline void  ARCH_DEP( or_2K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 2 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 02	 mov	 r8b, 2
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 s370__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s370_or_2K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s370__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s370__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s370__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	0f b6 44 24 60	 movzx	 eax, BYTE PTR K$[rsp]
  0001d	83 f8 04	 cmp	 eax, 4
  00020	75 57		 jne	 SHORT $LN5@s370__or_s
  00022	33 c0		 xor	 eax, eax
  00024	83 f8 01	 cmp	 eax, 1
  00027	74 50		 je	 SHORT $LN5@s370__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  0002e	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00033	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  00038	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  0003d	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00042	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  00047	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00051	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00054	0b c8		 or	 ecx, eax
  00056	8b c1		 mov	 eax, ecx
  00058	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  0005d	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  0005f	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00064	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00069	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0006c	0b c8		 or	 ecx, eax
  0006e	8b c1		 mov	 eax, ecx
  00070	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00075	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  00077	eb 2c		 jmp	 SHORT $LN6@s370__or_s
$LN5@s370__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  00079	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  0007e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00083	e8 00 00 00 00	 call	 _get_storekey_ptr
  00088	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  0008d	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00092	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00097	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0009a	0b c8		 or	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  000a3	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s370__or_s:

; 202  :     }
; 203  : }

  000a5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a9	c3		 ret	 0
s370__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey2_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey2_ptr PROC					; COMDAT

; 60   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 61   :     ABS_CHECK( abs );
; 62   :     return &STOREKEY2( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 c8 01	 or	 rax, 1
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 63   : }

  00026	c3		 ret	 0
_get_storekey2_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey1_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey1_ptr PROC					; COMDAT

; 54   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 55   :     ABS_CHECK( abs );
; 56   :     return &STOREKEY1( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 e0 fe	 and	 rax, -2
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 57   : }

  00026	c3		 ret	 0
_get_storekey1_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey_ptr
_TEXT	SEGMENT
tv75 = 0
abs$ = 32
K$ = 40
_get_storekey_ptr PROC					; COMDAT

; 40   : {

$LN5:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 41   :     ABS_CHECK( abs );
; 42   :     return (4 == K) ? &STOREKEY1( abs, &sysblk ) // (see feature.h PROGRAMMING NOTE)

  0000d	0f b6 44 24 28	 movzx	 eax, BYTE PTR K$[rsp]
  00012	83 f8 04	 cmp	 eax, 4
  00015	75 27		 jne	 SHORT $LN3@get_storek
  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  0001c	48 c1 e8 0b	 shr	 rax, 11
  00020	48 83 e0 fe	 and	 rax, -2
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0002b	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00032	48 03 c8	 add	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
  0003c	eb 21		 jmp	 SHORT $LN4@get_storek
$LN3@get_storek:
  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  00043	48 c1 e8 0b	 shr	 rax, 11
  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004e	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00055	48 03 c8	 add	 rcx, rax
  00058	48 8b c1	 mov	 rax, rcx
  0005b	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
$LN4@get_storek:
  0005f	48 8b 04 24	 mov	 rax, QWORD PTR tv75[rsp]

; 43   :                     : &STOREKEY(  abs, &sysblk );
; 44   : }

  00063	48 83 c4 18	 add	 rsp, 24
  00067	c3		 ret	 0
_get_storekey_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Release_Interrupt_Lock PROC

; 403  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@Release_In:

; 404  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@Release_In

; 405  :     sysblk.intowner = LOCK_OWNER_NONE;

  00014	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00020	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 406  :     hthread_release_lock( &sysblk.intlock, location );

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00034	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 407  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
Release_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Obtain_Interrupt_Lock PROC

; 379  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 380  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	74 13		 je	 SHORT $LN2@Obtain_Int

; 381  :         HOSTREGS->intwait = true;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00022	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN2@Obtain_Int:

; 382  :     hthread_obtain_lock( &sysblk.intlock, location );

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00036	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 383  :     Interrupt_Lock_Obtained( regs, location );

  00044	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	e8 00 00 00 00	 call	 Interrupt_Lock_Obtained

; 384  : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
Obtain_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Interrupt_Lock_Obtained PROC

; 347  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 348  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	0f 84 db 00 00
	00		 je	 $LN4@Interrupt_
$LN2@Interrupt_:

; 349  :     {
; 350  :         /* Wait for any SYNCHRONIZE_CPUS to finish before proceeding */
; 351  :         while (sysblk.syncing)

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8f 00 00
	00		 je	 $LN3@Interrupt_

; 352  :         {
; 353  :             /* Indicate we have reached the sync point */
; 354  :             sysblk.sync_mask &= ~HOSTREGS->cpubit;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00035	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 f7 d0	 not	 rax
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004a	48 8b 89 80 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4992]
  00051	48 23 c8	 and	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 89 81 80 13
	00 00		 mov	 QWORD PTR [rcx+4992], rax

; 355  : 
; 356  :             /* If we're the last CPU to reach this sync point,
; 357  :                signal the CPU that requested the sync that it
; 358  :                may now safely proceed with its exclusive logic.
; 359  :             */
; 360  :             if (!sysblk.sync_mask)

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 83 b8 80 13
	00 00 00	 cmp	 QWORD PTR [rax+4992], 0
  00074	75 1b		 jne	 SHORT $LN6@Interrupt_

; 361  :                 hthread_signal_condition( &sysblk.all_synced_cond, location );

  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00083	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN6@Interrupt_:

; 362  : 
; 363  :             /* Wait for CPU that requested the sync to indicate
; 364  :                it's done and thus is now safe for us to proceed.
; 365  :             */
; 366  :             hthread_wait_condition( &sysblk.sync_done_cond, &sysblk.intlock, location );

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  000ac	4c 8b 44 24 38	 mov	 r8, QWORD PTR location$[rsp]
  000b1	48 8b d0	 mov	 rdx, rax
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 367  :         }

  000ba	e9 5b ff ff ff	 jmp	 $LN2@Interrupt_
$LN3@Interrupt_:

; 368  : 
; 369  :         HOSTREGS->intwait = false;

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cb	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0

; 370  :         sysblk.intowner = HOSTREGS->cpuad;

  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e5	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ec	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 371  :     }

  000f3	eb 13		 jmp	 SHORT $LN5@Interrupt_
$LN4@Interrupt_:

; 372  :     else
; 373  :         sysblk.intowner = LOCK_OWNER_OTHER;

  000f5	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00101	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN5@Interrupt_:

; 374  : }

  00108	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010c	c3		 ret	 0
Interrupt_Lock_Obtained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
wakeup_cpu PROC

; 268  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 269  :     hthread_signal_condition( &regs->intcond, location );

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 05 80 0c 00
	00		 add	 rax, 3200		; 00000c80H
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0001e	48 8b c8	 mov	 rcx, rax
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 270  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
wakeup_cpu ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ipl.c
_TEXT	SEGMENT
tv74 = 0
xstorage_clear PROC

; 971  : {

$LN5:
  00000	40 57		 push	 rdi
  00002	48 83 ec 10	 sub	 rsp, 16

; 972  :     if (!sysblk.xpnd_clear)

  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000d	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00013	c1 e8 0f	 shr	 eax, 15
  00016	83 e0 01	 and	 eax, 1
  00019	85 c0		 test	 eax, eax
  0001b	75 5d		 jne	 SHORT $LN2@xstorage_c

; 973  :     {
; 974  :         if (sysblk.xpndstor)

  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00024	48 83 b8 b0 00
	00 00 00	 cmp	 QWORD PTR [rax+176], 0
  0002c	74 2e		 je	 SHORT $LN3@xstorage_c

; 975  :             memset( sysblk.xpndstor, 0x00, (size_t)sysblk.xpndsize * XSTORE_PAGESIZE );

  0002e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00035	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [rax+172]
  0003b	48 69 c0 00 10
	00 00		 imul	 rax, rax, 4096		; 00001000H
  00042	48 89 04 24	 mov	 QWORD PTR tv74[rsp], rax
  00046	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004d	48 8b b9 b0 00
	00 00		 mov	 rdi, QWORD PTR [rcx+176]
  00054	33 c0		 xor	 eax, eax
  00056	48 8b 0c 24	 mov	 rcx, QWORD PTR tv74[rsp]
  0005a	f3 aa		 rep stosb
$LN3@xstorage_c:

; 976  : 
; 977  :         sysblk.xpnd_clear = 1;

  0005c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00063	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00069	0f ba e8 0f	 bts	 eax, 15
  0006d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00074	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
$LN2@xstorage_c:

; 978  :     }
; 979  : }

  0007a	48 83 c4 10	 add	 rsp, 16
  0007e	5f		 pop	 rdi
  0007f	c3		 ret	 0
xstorage_clear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ipl.c
_TEXT	SEGMENT
tv81 = 0
storage_clear PROC

; 958  : {

$LN6:
  00000	40 57		 push	 rdi
  00002	48 83 ec 10	 sub	 rsp, 16

; 959  :     if (!sysblk.main_clear)

  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000d	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00013	c1 e8 0e	 shr	 eax, 14
  00016	83 e0 01	 and	 eax, 1
  00019	85 c0		 test	 eax, eax
  0001b	0f 85 92 00 00
	00		 jne	 $LN2@storage_cl

; 960  :     {
; 961  :         if (sysblk.mainstor) memset( sysblk.mainstor, 0x00, sysblk.mainsize );

  00021	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00028	48 83 b8 98 00
	00 00 00	 cmp	 QWORD PTR [rax+152], 0
  00030	74 20		 je	 SHORT $LN3@storage_cl
  00032	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00039	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00040	48 8b b8 98 00
	00 00		 mov	 rdi, QWORD PTR [rax+152]
  00047	33 c0		 xor	 eax, eax
  00049	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  00050	f3 aa		 rep stosb
$LN3@storage_cl:

; 962  :         if (sysblk.storkeys) memset( sysblk.storkeys, 0x00, sysblk.mainsize / _STORKEY_ARRAY_UNITSIZE );

  00052	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00059	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  00061	74 32		 je	 SHORT $LN4@storage_cl
  00063	33 d2		 xor	 edx, edx
  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00073	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00078	48 f7 f1	 div	 rcx
  0007b	48 89 04 24	 mov	 QWORD PTR tv81[rsp], rax
  0007f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00086	48 8b b9 a0 00
	00 00		 mov	 rdi, QWORD PTR [rcx+160]
  0008d	33 c0		 xor	 eax, eax
  0008f	48 8b 0c 24	 mov	 rcx, QWORD PTR tv81[rsp]
  00093	f3 aa		 rep stosb
$LN4@storage_cl:

; 963  :         sysblk.main_clear = 1;

  00095	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0009c	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  000a2	0f ba e8 0e	 bts	 eax, 14
  000a6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000ad	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
$LN2@storage_cl:

; 964  :     }
; 965  : }

  000b3	48 83 c4 10	 add	 rsp, 16
  000b7	5f		 pop	 rdi
  000b8	c3		 ret	 0
storage_clear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ipl.c
_TEXT	SEGMENT
rc$ = 96
tv76 = 100
tv82 = 104
tv88 = 108
tv94 = 112
tv132 = 116
tv138 = 120
tv160 = 128
tv180 = 136
tv196 = 144
buf$1 = 160
__$ArrayPad$ = 240
regs$ = 288
s370_common_load_finish PROC

; 568  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 569  : int rc;
; 570  :     /* Zeroize the interrupt code in the PSW */
; 571  :     regs->psw.intcode = 0;

  00020	33 c0		 xor	 eax, eax
  00022	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0002a	66 89 81 98 00
	00 00		 mov	 WORD PTR [rcx+152], ax

; 572  : 
; 573  :     /* Load IPL PSW from PSA+X'0' */
; 574  :     if ((rc = ARCH_DEP(load_psw) (regs, regs->psa->iplpsw)) )

  00031	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00039	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  00040	48 8b d0	 mov	 rdx, rax
  00043	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004b	e8 00 00 00 00	 call	 s370_load_psw
  00050	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax
  00054	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  00059	0f 84 3b 02 00
	00		 je	 $LN2@s370_commo

; 575  :     {
; 576  :         char buf[80];
; 577  :         MSGBUF(buf, "architecture mode %s, invalid ipl psw %2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X",

  0005f	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00067	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  0006e	b9 01 00 00 00	 mov	 ecx, 1
  00073	48 6b c9 07	 imul	 rcx, rcx, 7
  00077	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0007b	89 44 24 64	 mov	 DWORD PTR tv76[rsp], eax
  0007f	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00087	48 8b 89 60 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2144]
  0008e	ba 01 00 00 00	 mov	 edx, 1
  00093	48 6b d2 06	 imul	 rdx, rdx, 6
  00097	0f b6 0c 11	 movzx	 ecx, BYTE PTR [rcx+rdx]
  0009b	89 4c 24 68	 mov	 DWORD PTR tv82[rsp], ecx
  0009f	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000a7	48 8b 92 60 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2144]
  000ae	41 b8 01 00 00
	00		 mov	 r8d, 1
  000b4	4d 6b c0 05	 imul	 r8, r8, 5
  000b8	42 0f b6 14 02	 movzx	 edx, BYTE PTR [rdx+r8]
  000bd	89 54 24 6c	 mov	 DWORD PTR tv88[rsp], edx
  000c1	4c 8b 84 24 20
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000c9	4d 8b 80 60 08
	00 00		 mov	 r8, QWORD PTR [r8+2144]
  000d0	41 b9 01 00 00
	00		 mov	 r9d, 1
  000d6	4d 6b c9 04	 imul	 r9, r9, 4
  000da	47 0f b6 04 08	 movzx	 r8d, BYTE PTR [r8+r9]
  000df	44 89 44 24 70	 mov	 DWORD PTR tv94[rsp], r8d
  000e4	4c 8b 8c 24 20
	01 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000ec	4d 8b 89 60 08
	00 00		 mov	 r9, QWORD PTR [r9+2144]
  000f3	41 ba 01 00 00
	00		 mov	 r10d, 1
  000f9	4d 6b d2 03	 imul	 r10, r10, 3
  000fd	47 0f b6 0c 11	 movzx	 r9d, BYTE PTR [r9+r10]
  00102	44 89 4c 24 74	 mov	 DWORD PTR tv132[rsp], r9d
  00107	4c 8b 94 24 20
	01 00 00	 mov	 r10, QWORD PTR regs$[rsp]
  0010f	4d 8b 92 60 08
	00 00		 mov	 r10, QWORD PTR [r10+2144]
  00116	41 bb 01 00 00
	00		 mov	 r11d, 1
  0011c	4d 6b db 02	 imul	 r11, r11, 2
  00120	47 0f b6 14 1a	 movzx	 r10d, BYTE PTR [r10+r11]
  00125	44 89 54 24 78	 mov	 DWORD PTR tv138[rsp], r10d
  0012a	4c 8b 9c 24 20
	01 00 00	 mov	 r11, QWORD PTR regs$[rsp]
  00132	4d 8b 9b 60 08
	00 00		 mov	 r11, QWORD PTR [r11+2144]
  00139	bb 01 00 00 00	 mov	 ebx, 1
  0013e	48 6b db 01	 imul	 rbx, rbx, 1
  00142	41 0f b6 1c 1b	 movzx	 ebx, BYTE PTR [r11+rbx]
  00147	4c 8b 9c 24 20
	01 00 00	 mov	 r11, QWORD PTR regs$[rsp]
  0014f	4d 8b 9b 60 08
	00 00		 mov	 r11, QWORD PTR [r11+2144]
  00156	bf 01 00 00 00	 mov	 edi, 1
  0015b	48 6b ff 00	 imul	 rdi, rdi, 0
  0015f	41 0f b6 3c 3b	 movzx	 edi, BYTE PTR [r11+rdi]
  00164	33 c9		 xor	 ecx, ecx
  00166	e8 00 00 00 00	 call	 get_arch_name
  0016b	8b 4c 24 64	 mov	 ecx, DWORD PTR tv76[rsp]
  0016f	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00173	8b 4c 24 68	 mov	 ecx, DWORD PTR tv82[rsp]
  00177	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0017b	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv88[rsp]
  0017f	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00183	8b 4c 24 70	 mov	 ecx, DWORD PTR tv94[rsp]
  00187	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0018b	8b 4c 24 74	 mov	 ecx, DWORD PTR tv132[rsp]
  0018f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00193	8b 4c 24 78	 mov	 ecx, DWORD PTR tv138[rsp]
  00197	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  0019b	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  0019f	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  001a3	4c 8b c8	 mov	 r9, rax
  001a6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169777
  001ad	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  001b2	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  001ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 578  :                 get_arch_name( NULL ),
; 579  :                 regs->psa->iplpsw[0], regs->psa->iplpsw[1],
; 580  :                 regs->psa->iplpsw[2], regs->psa->iplpsw[3],
; 581  :                 regs->psa->iplpsw[4], regs->psa->iplpsw[5],
; 582  :                 regs->psa->iplpsw[6], regs->psa->iplpsw[7]);
; 583  :         WRMSG (HHC00839, "E", PTYPSTR(sysblk.pcpu), sysblk.pcpu, buf);

  001c0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001c7	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  001ce	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001d5	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  001dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  001e3	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv160[rsp], rax
  001eb	b9 01 00 00 00	 mov	 ecx, 1
  001f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001f6	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  001fe	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00203	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0020a	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  00210	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00214	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv160[rsp]
  0021c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00221	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169778
  00228	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0022d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169779
  00234	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00239	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0023e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00244	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169780
  0024b	ba 47 02 00 00	 mov	 edx, 583		; 00000247H
  00250	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169781
  00257	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 584  : 
; 585  :         /* HercGUI hook so it can update its LEDs */
; 586  :         HDC1( debug_cpu_state, regs );

  0025d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  00264	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00268	74 1b		 je	 SHORT $LN4@s370_commo
  0026a	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00272	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  00279	ff 10		 call	 QWORD PTR [rax]
  0027b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv180[rsp], rax
  00283	eb 0c		 jmp	 SHORT $LN5@s370_commo
$LN4@s370_commo:
  00285	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv180[rsp], 0
$LN5@s370_commo:

; 587  : 
; 588  :         return rc;

  00291	8b 44 24 60	 mov	 eax, DWORD PTR rc$[rsp]
  00295	e9 b2 00 00 00	 jmp	 $LN1@s370_commo
$LN2@s370_commo:

; 589  :     }
; 590  : 
; 591  :     /* Set the CPU into the started state */
; 592  :     regs->opinterv = 0;

  0029a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a2	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  002a8	83 e0 ef	 and	 eax, -17		; ffffffefH
  002ab	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b3	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 593  :     regs->cpustate = CPUSTATE_STARTED;

  002b9	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c1	c6 40 60 01	 mov	 BYTE PTR [rax+96], 1

; 594  : 
; 595  :     /* The actual IPL (load) is now completed... */
; 596  :     regs->loadstate = 0;

  002c5	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002cd	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  002d3	0f ba f0 0c	 btr	 eax, 12
  002d7	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002df	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 597  : 
; 598  :     /* reset sys_reset flag to indicate a active machine */
; 599  :     sysblk.sys_reset = FALSE;

  002e5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002ec	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  002f2	83 e0 fe	 and	 eax, -2			; fffffffeH
  002f5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002fc	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 600  : 
; 601  :     /* Signal the CPU to retest stopped indicator */
; 602  :     WAKEUP_CPU (regs);

  00302	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169782
  00309	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00311	e8 00 00 00 00	 call	 wakeup_cpu

; 603  : 
; 604  :     /* HercGUI hook so it can update its LEDs */
; 605  :     HDC1( debug_cpu_state, regs );

  00316	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  0031d	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00321	74 1b		 je	 SHORT $LN6@s370_commo
  00323	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0032b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  00332	ff 10		 call	 QWORD PTR [rax]
  00334	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv196[rsp], rax
  0033c	eb 0c		 jmp	 SHORT $LN7@s370_commo
$LN6@s370_commo:
  0033e	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv196[rsp], 0
$LN7@s370_commo:

; 606  : 
; 607  :     return 0;

  0034a	33 c0		 xor	 eax, eax
$LN1@s370_commo:

; 608  : } /* end function common_load_finish */

  0034c	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00354	48 33 cc	 xor	 rcx, rsp
  00357	e8 00 00 00 00	 call	 __security_check_cookie
  0035c	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  00363	5f		 pop	 rdi
  00364	5b		 pop	 rbx
  00365	c3		 ret	 0
s370_common_load_finish ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ipl.c
_TEXT	SEGMENT
ipl$ = 32
tv75 = 36
tv86 = 40
tv91 = 44
rc$ = 48
capture$ = 52
target_mode$ = 56
cpu$ = 96
clear$ = 104
s370_common_load_begin PROC

; 367  : {

$LN12:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	56		 push	 rsi
  00009	57		 push	 rdi
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 368  :     const bool ipl = true;

  0000e	c6 44 24 20 01	 mov	 BYTE PTR ipl$[rsp], 1

; 369  :     int target_mode;
; 370  :     int capture;
; 371  :     int rc;
; 372  : 
; 373  :     /* Ensure dummyregs archmode matches SYSBLK archmode */
; 374  :     sysblk.dummyregs.arch_mode = sysblk.arch_mode;

  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00021	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  00027	89 88 64 15 00
	00		 mov	 DWORD PTR [rax+5476], ecx

; 375  : 
; 376  :     capture = TRUE

  0002d	33 c0		 xor	 eax, eax
  0002f	83 f8 01	 cmp	 eax, 1
  00032	74 38		 je	 SHORT $LN6@s370_commo
  00034	83 7c 24 68 00	 cmp	 DWORD PTR clear$[rsp], 0
  00039	75 31		 jne	 SHORT $LN6@s370_commo
  0003b	48 63 44 24 60	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00040	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00047	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00050	74 1a		 je	 SHORT $LN6@s370_commo
  00052	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00059	83 b8 88 00 00
	00 02		 cmp	 DWORD PTR [rax+136], 2
  00060	75 0a		 jne	 SHORT $LN6@s370_commo
  00062	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  0006a	eb 08		 jmp	 SHORT $LN7@s370_commo
$LN6@s370_commo:
  0006c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN7@s370_commo:
  00074	8b 44 24 24	 mov	 eax, DWORD PTR tv75[rsp]
  00078	89 44 24 34	 mov	 DWORD PTR capture$[rsp], eax

; 377  :         && !clear
; 378  :         && IS_CPU_ONLINE( cpu )
; 379  :         && sysblk.arch_mode == ARCH_900_IDX
; 380  :         ;
; 381  : 
; 382  :     /* Capture the z/Arch PSW if this is a Load-normal IPL */
; 383  :     if (capture)

  0007c	83 7c 24 34 00	 cmp	 DWORD PTR capture$[rsp], 0
  00081	74 29		 je	 SHORT $LN2@s370_commo

; 384  :         captured_zpsw = sysblk.regs[ cpu ]->psw;

  00083	48 63 44 24 60	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00088	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0008f	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00097	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:captured_zpsw
  0009e	48 8b f9	 mov	 rdi, rcx
  000a1	48 8d 70 78	 lea	 rsi, QWORD PTR [rax+120]
  000a5	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  000aa	f3 a4		 rep movsb
$LN2@s370_commo:

; 385  : 
; 386  :     /* Perform system-reset-normal or system-reset-clear function.
; 387  :      *
; 388  :      * SA22-7085-0 IBM System/370 Extended Architecture Principles
; 389  :      *             of Operation, Chapter 12, Operator Facilities,
; 390  :      *             LOAD-CLEAR KEY and LOAD-NORMAL KEY, p. 12-3.
; 391  :      */
; 392  : 
; 393  :     target_mode = sysblk.arch_mode > ARCH_390_IDX ?

  000ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000b3	83 b8 88 00 00
	00 01		 cmp	 DWORD PTR [rax+136], 1
  000ba	7e 0a		 jle	 SHORT $LN8@s370_commo
  000bc	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv86[rsp], 1
  000c4	eb 11		 jmp	 SHORT $LN9@s370_commo
$LN8@s370_commo:
  000c6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000cd	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  000d3	89 44 24 28	 mov	 DWORD PTR tv86[rsp], eax
$LN9@s370_commo:
  000d7	8b 44 24 28	 mov	 eax, DWORD PTR tv86[rsp]
  000db	89 44 24 38	 mov	 DWORD PTR target_mode$[rsp], eax

; 394  :                                      ARCH_390_IDX : sysblk.arch_mode;
; 395  : 
; 396  :     if ((rc = ARCH_DEP( system_reset )( target_mode, clear, ipl, cpu )) != 0)

  000df	83 7c 24 68 00	 cmp	 DWORD PTR clear$[rsp], 0
  000e4	75 0a		 jne	 SHORT $LN10@s370_commo
  000e6	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
  000ee	eb 08		 jmp	 SHORT $LN11@s370_commo
$LN10@s370_commo:
  000f0	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv91[rsp], 1
$LN11@s370_commo:
  000f8	44 8b 4c 24 60	 mov	 r9d, DWORD PTR cpu$[rsp]
  000fd	44 0f b6 44 24
	20		 movzx	 r8d, BYTE PTR ipl$[rsp]
  00103	0f b6 54 24 2c	 movzx	 edx, BYTE PTR tv91[rsp]
  00108	8b 4c 24 38	 mov	 ecx, DWORD PTR target_mode$[rsp]
  0010c	e8 00 00 00 00	 call	 s370_system_reset
  00111	89 44 24 30	 mov	 DWORD PTR rc$[rsp], eax
  00115	83 7c 24 30 00	 cmp	 DWORD PTR rc$[rsp], 0
  0011a	74 06		 je	 SHORT $LN3@s370_commo

; 397  :         return rc;

  0011c	8b 44 24 30	 mov	 eax, DWORD PTR rc$[rsp]
  00120	eb 6d		 jmp	 SHORT $LN1@s370_commo
$LN3@s370_commo:

; 398  : 
; 399  :     /* Save our captured-z/Arch-PSW if this is a Load-normal IPL
; 400  :        since the initial_cpu_reset call cleared it to zero. */
; 401  :     if (capture)

  00122	83 7c 24 34 00	 cmp	 DWORD PTR capture$[rsp], 0
  00127	74 2c		 je	 SHORT $LN4@s370_commo

; 402  :         sysblk.regs[ cpu ]->captured_zpsw = captured_zpsw;

  00129	48 63 44 24 60	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0012e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00135	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0013d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:captured_zpsw
  00144	48 8d b8 40 09
	00 00		 lea	 rdi, QWORD PTR [rax+2368]
  0014b	48 8b f1	 mov	 rsi, rcx
  0014e	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00153	f3 a4		 rep movsb
$LN4@s370_commo:

; 403  : 
; 404  :     /* The actual IPL (load) now begins... */
; 405  :     sysblk.regs[ cpu ]->loadstate = TRUE;

  00155	48 63 44 24 60	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0015a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00161	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00169	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0016f	0f ba e8 0c	 bts	 eax, 12
  00173	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR cpu$[rsp]
  00178	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0017f	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00187	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 406  : 
; 407  :     return 0;

  0018d	33 c0		 xor	 eax, eax
$LN1@s370_commo:

; 408  : } /* end function common_load_begin */

  0018f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00193	5f		 pop	 rdi
  00194	5e		 pop	 rsi
  00195	c3		 ret	 0
s370_common_load_begin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ipl.c
_TEXT	SEGMENT
rc$ = 32
tv151 = 36
tv163 = 40
rc2$1 = 44
tv129 = 48
regs$ = 80
s370_initial_cpu_reset PROC

; 688  : {

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 689  :     int rc = 0;

  0000a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 690  : 
; 691  :     /* Clear reset pending indicators */
; 692  :     regs->sigp_ini_reset = regs->sigp_reset = 0;

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00017	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0001d	0f ba f0 13	 btr	 eax, 19
  00021	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00026	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
  0002c	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00031	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00037	0f ba f0 14	 btr	 eax, 20
  0003b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00040	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 693  : 
; 694  :     /* Clear the registers */
; 695  :     memset ( &regs->psw,           0, sizeof( regs->psw           ));

  00046	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	48 83 c0 78	 add	 rax, 120		; 00000078H
  0004f	48 8b f8	 mov	 rdi, rax
  00052	33 c0		 xor	 eax, eax
  00054	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00059	f3 aa		 rep stosb

; 696  :     memset ( &regs->captured_zpsw, 0, sizeof( regs->captured_zpsw ));

  0005b	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00060	48 05 40 09 00
	00		 add	 rax, 2368		; 00000940H
  00066	48 8b f8	 mov	 rdi, rax
  00069	33 c0		 xor	 eax, eax
  0006b	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00070	f3 aa		 rep stosb

; 697  :     memset ( &regs->cr_struct,     0, sizeof( regs->cr_struct     ));

  00072	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00077	48 05 00 06 00
	00		 add	 rax, 1536		; 00000600H
  0007d	48 8b f8	 mov	 rdi, rax
  00080	33 c0		 xor	 eax, eax
  00082	b9 08 01 00 00	 mov	 ecx, 264		; 00000108H
  00087	f3 aa		 rep stosb

; 698  :     regs->fpc    = 0;

  00089	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0008e	c7 80 c0 03 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+960], 0

; 699  :     regs->PX     = 0;

  00098	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0009d	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [rax+112], 0

; 700  :     regs->psw.AMASK_G = AMASK24;

  000a4	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000a9	48 c7 80 90 00
	00 00 ff ff ff
	00		 mov	 QWORD PTR [rax+144], 16777215 ; 00ffffffH

; 701  : 
; 702  :     /* Ensure memory sizes are properly indicated */
; 703  :     regs->mainstor = sysblk.mainstor;

  000b4	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000c0	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  000c7	48 89 88 48 08
	00 00		 mov	 QWORD PTR [rax+2120], rcx

; 704  :     regs->storkeys = sysblk.storkeys;

  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000d3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000da	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  000e1	48 89 88 50 08
	00 00		 mov	 QWORD PTR [rax+2128], rcx

; 705  :     regs->mainlim  = sysblk.mainsize ? (sysblk.mainsize - 1) : 0;

  000e8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ef	48 83 b8 90 00
	00 00 00	 cmp	 QWORD PTR [rax+144], 0
  000f7	74 18		 je	 SHORT $LN5@s370_initi
  000f9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00100	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00107	48 ff c8	 dec	 rax
  0010a	48 89 44 24 30	 mov	 QWORD PTR tv129[rsp], rax
  0010f	eb 09		 jmp	 SHORT $LN6@s370_initi
$LN5@s370_initi:
  00111	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv129[rsp], 0
$LN6@s370_initi:
  0011a	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0011f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv129[rsp]
  00124	48 89 88 58 08
	00 00		 mov	 QWORD PTR [rax+2136], rcx

; 706  :     regs->psa      = (PSA_3XX*)regs->mainstor;

  0012b	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00130	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00135	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  0013c	48 89 88 60 08
	00 00		 mov	 QWORD PTR [rax+2144], rcx

; 707  : 
; 708  :     /* Perform a CPU reset (after setting PSA) */
; 709  :     rc = ARCH_DEP( cpu_reset )( regs );

  00143	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00148	e8 00 00 00 00	 call	 s370_cpu_reset
  0014d	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 710  : 
; 711  :     regs->todpr  = 0;

  00151	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00156	c7 80 58 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1880], 0

; 712  :     regs->clkc   = 0;

  00160	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00165	48 c7 80 48 07
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1864], 0

; 713  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 714  :     PTT_TXF( "TXF ICPURES", 0, 0, regs->txf_tnd );
; 715  :     /* EXIT SILENTLY from transactional execution mode */
; 716  :     regs->txf_tnd = 0;
; 717  :     regs->txf_aborts = 0;
; 718  :     regs->txf_contran = false;
; 719  :     regs->txf_UPGM_abort = false;
; 720  : #endif
; 721  :     set_cpu_timer( regs, 0 );

  00170	33 d2		 xor	 edx, edx
  00172	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00177	e8 00 00 00 00	 call	 set_cpu_timer

; 722  : #if defined( _FEATURE_INTERVAL_TIMER )
; 723  :     set_int_timer( regs, 0 );

  0017c	33 d2		 xor	 edx, edx
  0017e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00183	e8 00 00 00 00	 call	 set_int_timer

; 724  : #endif
; 725  : 
; 726  :     /* The breaking event address register is initialised to 1 */
; 727  :     regs->bear = 1;

  00188	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0018d	48 c7 80 18 02
	00 00 01 00 00
	00		 mov	 QWORD PTR [rax+536], 1

; 728  : 
; 729  :     /* Initialize external interrupt masks in control register 0 */
; 730  :     regs->CR(0) = CR0_XM_INTKEY | CR0_XM_EXTSIG |

  00198	b8 01 00 00 00	 mov	 eax, 1
  0019d	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  001a1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  001a6	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001ae	83 e0 10	 and	 eax, 16
  001b1	85 c0		 test	 eax, eax
  001b3	74 0a		 je	 SHORT $LN7@s370_initi
  001b5	c7 44 24 24 80
	00 00 00	 mov	 DWORD PTR tv151[rsp], 128 ; 00000080H
  001bd	eb 08		 jmp	 SHORT $LN8@s370_initi
$LN7@s370_initi:
  001bf	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN8@s370_initi:
  001c7	8b 44 24 24	 mov	 eax, DWORD PTR tv151[rsp]
  001cb	83 c8 60	 or	 eax, 96			; 00000060H
  001ce	b9 08 00 00 00	 mov	 ecx, 8
  001d3	48 6b c9 01	 imul	 rcx, rcx, 1
  001d7	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  001dc	89 84 0a 00 06
	00 00		 mov	 DWORD PTR [rdx+rcx+1536], eax

; 731  :       (FACILITY_ENABLED( HERC_INTERVAL_TIMER, regs ) ? CR0_XM_ITIMER : 0);
; 732  : 
; 733  : #if defined( FEATURE_S370_CHANNEL ) && !defined( FEATURE_ACCESS_REGISTERS )
; 734  :     /* For S/370 initialize the channel masks in CR2 */
; 735  :     regs->CR(2) = (U32)0xFFFFFFFFF;

  001e3	b8 08 00 00 00	 mov	 eax, 8
  001e8	48 6b c0 03	 imul	 rax, rax, 3
  001ec	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  001f1	c7 84 01 00 06
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rcx+rax+1536], -1 ; ffffffffH

; 736  : #endif
; 737  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 738  :     regs->CR(2) &= ~(CR2_TDS | CR2_TDC);
; 739  : #endif
; 740  : 
; 741  :     regs->chanset =

  001fc	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00201	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00208	83 f8 04	 cmp	 eax, 4
  0020b	7d 12		 jge	 SHORT $LN9@s370_initi
  0020d	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00212	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00219	89 44 24 28	 mov	 DWORD PTR tv163[rsp], eax
  0021d	eb 08		 jmp	 SHORT $LN10@s370_initi
$LN9@s370_initi:
  0021f	c7 44 24 28 ff
	ff 00 00	 mov	 DWORD PTR tv163[rsp], 65535 ; 0000ffffH
$LN10@s370_initi:
  00227	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0022c	0f b7 4c 24 28	 movzx	 ecx, WORD PTR tv163[rsp]
  00231	66 89 88 38 08
	00 00		 mov	 WORD PTR [rax+2104], cx

; 742  : #if defined( FEATURE_CHANNEL_SWITCHING )
; 743  :         regs->cpuad < FEATURE_LCSS_MAX ? regs->cpuad :
; 744  : #endif
; 745  :         0xFFFF;
; 746  : 
; 747  :     /* Initialize the machine check masks in control register 14 */
; 748  :     regs->CR(14) = CR14_CHKSTOP | CR14_SYNCMCEL | CR14_XDMGRPT;

  00238	b8 08 00 00 00	 mov	 eax, 8
  0023d	48 6b c0 0f	 imul	 rax, rax, 15
  00241	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00246	c7 84 01 00 06
	00 00 00 00 00
	c2		 mov	 DWORD PTR [rcx+rax+1536], -1040187392 ; c2000000H

; 749  : 
; 750  : #if !defined( FEATURE_LINKAGE_STACK )
; 751  :     /* For S/370 initialize the MCEL address in CR15 */
; 752  :     regs->CR(15) = 512;

  00251	b8 08 00 00 00	 mov	 eax, 8
  00256	48 6b c0 10	 imul	 rax, rax, 16
  0025a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0025f	c7 84 01 00 06
	00 00 00 02 00
	00		 mov	 DWORD PTR [rcx+rax+1536], 512 ; 00000200H

; 753  : #endif
; 754  : 
; 755  :     if (regs->host && GUESTREGS)

  0026a	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0026f	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00275	c1 e8 07	 shr	 eax, 7
  00278	83 e0 01	 and	 eax, 1
  0027b	85 c0		 test	 eax, eax
  0027d	74 33		 je	 SHORT $LN2@s370_initi
  0027f	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00284	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  0028c	74 24		 je	 SHORT $LN2@s370_initi

; 756  :     {
; 757  :         int rc2 = initial_cpu_reset( GUESTREGS );

  0028e	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00293	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0029a	e8 00 00 00 00	 call	 initial_cpu_reset
  0029f	89 44 24 2c	 mov	 DWORD PTR rc2$1[rsp], eax

; 758  :         if (rc2 != 0)

  002a3	83 7c 24 2c 00	 cmp	 DWORD PTR rc2$1[rsp], 0
  002a8	74 08		 je	 SHORT $LN3@s370_initi

; 759  :             rc = rc2;

  002aa	8b 44 24 2c	 mov	 eax, DWORD PTR rc2$1[rsp]
  002ae	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
$LN3@s370_initi:
$LN2@s370_initi:

; 760  :     }
; 761  : 
; 762  :     return rc;

  002b2	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 763  : } /* end function initial_cpu_reset */

  002b6	48 83 c4 40	 add	 rsp, 64			; 00000040H
  002ba	5f		 pop	 rdi
  002bb	c3		 ret	 0
s370_initial_cpu_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ipl.c
_TEXT	SEGMENT
rc$ = 32
tv65 = 36
p$1 = 40
regs$ = 64
initial_cpu_reset PROC

; 880  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 881  :     int rc = 0;

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 882  : 
; 883  :     switch ( regs->arch_mode )

  00011	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00016	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00019	89 44 24 24	 mov	 DWORD PTR tv65[rsp], eax
  0001d	83 7c 24 24 00	 cmp	 DWORD PTR tv65[rsp], 0
  00022	74 10		 je	 SHORT $LN7@initial_cp
  00024	83 7c 24 24 01	 cmp	 DWORD PTR tv65[rsp], 1
  00029	74 19		 je	 SHORT $LN8@initial_cp
  0002b	83 7c 24 24 02	 cmp	 DWORD PTR tv65[rsp], 2
  00030	74 22		 je	 SHORT $LN9@initial_cp
  00032	eb 30		 jmp	 SHORT $LN10@initial_cp
$LN7@initial_cp:

; 884  :     {
; 885  : #if defined(_370)
; 886  :         case ARCH_370_IDX: rc = s370_initial_cpu_reset( regs ); break;

  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00039	e8 00 00 00 00	 call	 s370_initial_cpu_reset
  0003e	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
  00042	eb 37		 jmp	 SHORT $LN2@initial_cp
$LN8@initial_cp:

; 887  : #endif
; 888  : #if defined(_390)
; 889  :         case ARCH_390_IDX: rc = s390_initial_cpu_reset( regs ); break;

  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00049	e8 00 00 00 00	 call	 s390_initial_cpu_reset
  0004e	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
  00052	eb 27		 jmp	 SHORT $LN2@initial_cp
$LN9@initial_cp:

; 890  : #endif
; 891  : #if defined(_900)
; 892  :         case ARCH_900_IDX: rc = z900_initial_cpu_reset( regs ); break;

  00054	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00059	e8 00 00 00 00	 call	 z900_initial_cpu_reset
  0005e	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
  00062	eb 17		 jmp	 SHORT $LN2@initial_cp
$LN10@initial_cp:
$LN6@initial_cp:

; 893  : #endif
; 894  :         default: CRASH();

  00064	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  0006d	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  00072	c6 00 00	 mov	 BYTE PTR [rax], 0
  00075	33 c0		 xor	 eax, eax
  00077	85 c0		 test	 eax, eax
  00079	75 e9		 jne	 SHORT $LN6@initial_cp
$LN2@initial_cp:

; 895  :     }
; 896  : 
; 897  :     return rc;

  0007b	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 898  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
initial_cpu_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ipl.c
_TEXT	SEGMENT
cpu$ = 32
regs$ = 40
initial_cpu_reset_all PROC

; 859  : {

$LN8:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 860  :     REGS* regs;
; 861  :     int cpu;
; 862  : 
; 863  :     if (sysblk.cpus)

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	83 b8 04 01 00
	00 00		 cmp	 DWORD PTR [rax+260], 0
  00012	74 63		 je	 SHORT $LN5@initial_cp

; 864  :     {
; 865  :         for (cpu = 0; cpu < sysblk.maxcpu; cpu++)

  00014	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR cpu$[rsp], 0
  0001c	eb 0a		 jmp	 SHORT $LN4@initial_cp
$LN2@initial_cp:
  0001e	8b 44 24 20	 mov	 eax, DWORD PTR cpu$[rsp]
  00022	ff c0		 inc	 eax
  00024	89 44 24 20	 mov	 DWORD PTR cpu$[rsp], eax
$LN4@initial_cp:
  00028	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00035	39 44 24 20	 cmp	 DWORD PTR cpu$[rsp], eax
  00039	7d 3c		 jge	 SHORT $LN3@initial_cp

; 866  :         {
; 867  :             if (IS_CPU_ONLINE( cpu ))

  0003b	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00040	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00047	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00050	74 23		 je	 SHORT $LN6@initial_cp

; 868  :             {
; 869  :                 regs = sysblk.regs[ cpu ];

  00052	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00066	48 89 44 24 28	 mov	 QWORD PTR regs$[rsp], rax

; 870  :                 initial_cpu_reset( regs ) ;

  0006b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  00070	e8 00 00 00 00	 call	 initial_cpu_reset
$LN6@initial_cp:

; 871  :             }
; 872  :         }

  00075	eb a7		 jmp	 SHORT $LN2@initial_cp
$LN3@initial_cp:
$LN5@initial_cp:

; 873  :     }
; 874  : }

  00077	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007b	c3		 ret	 0
initial_cpu_reset_all ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ipl.c
_TEXT	SEGMENT
i$ = 48
rc$ = 52
regs$ = 80
s370_cpu_reset PROC

; 614  : {

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 615  : int i, rc = 0;                          /* Array subscript           */

  00009	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 616  : 
; 617  :     regs->ip = regs->inst;

  00011	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00016	48 05 f1 08 00
	00		 add	 rax, 2289		; 000008f1H
  0001c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00021	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 618  : 
; 619  :     /* Clear indicators */
; 620  :     regs->loadstate = 0;

  00025	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0002a	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00030	0f ba f0 0c	 btr	 eax, 12
  00034	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00039	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 621  :     regs->checkstop = 0;

  0003f	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00044	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0004a	83 e0 df	 and	 eax, -33		; ffffffdfH
  0004d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 622  :     regs->sigp_reset = 0;

  00058	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00063	0f ba f0 13	 btr	 eax, 19
  00067	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0006c	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 623  :     regs->extccpu = 0;

  00072	33 c0		 xor	 eax, eax
  00074	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00079	66 89 41 62	 mov	 WORD PTR [rcx+98], ax

; 624  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 625  :     PTT_TXF( "TXF CPURES", 0, 0, regs->txf_tnd );
; 626  :     /* EXIT SILENTLY from transactional execution mode */
; 627  :     regs->txf_tnd = 0;
; 628  :     regs->txf_aborts = 0;
; 629  :     regs->txf_contran = false;
; 630  :     regs->txf_UPGM_abort = false;
; 631  : #endif
; 632  :     for (i = 0; i < sysblk.maxcpu; i++)

  0007d	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00085	eb 0a		 jmp	 SHORT $LN4@s370_cpu_r
$LN2@s370_cpu_r:
  00087	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0008b	ff c0		 inc	 eax
  0008d	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@s370_cpu_r:
  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0009e	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  000a2	7d 14		 jge	 SHORT $LN3@s370_cpu_r

; 633  :         regs->emercpu[i] = 0;

  000a4	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  000a9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	c6 84 01 80 01
	00 00 00	 mov	 BYTE PTR [rcx+rax+384], 0
  000b6	eb cf		 jmp	 SHORT $LN2@s370_cpu_r
$LN3@s370_cpu_r:

; 634  :     regs->instinvalid = 1;

  000b8	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000bd	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000c3	83 c8 08	 or	 eax, 8
  000c6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  000cb	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 635  : 
; 636  :     /* Clear interrupts */
; 637  :     SET_IC_INITIAL_MASK(regs);

  000d1	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000d6	c7 40 4c 0a 00
	00 80		 mov	 DWORD PTR [rax+76], -2147483638 ; 8000000aH

; 638  :     SET_IC_INITIAL_STATE(regs);

  000dd	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000e2	c7 40 48 01 00
	00 00		 mov	 DWORD PTR [rax+72], 1

; 639  : 
; 640  :     /* Clear the translation exception identification */
; 641  :     regs->EA_G = 0;

  000e9	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000ee	48 c7 80 18 07
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1816], 0

; 642  :     regs->excarid = 0;

  000f9	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000fe	c6 80 3e 08 00
	00 00		 mov	 BYTE PTR [rax+2110], 0

; 643  : 
; 644  :     /* Clear monitor code */
; 645  :     regs->MC_G = 0;

  00105	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0010a	48 c7 80 10 07
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1808], 0

; 646  : 
; 647  :     /* Purge the lookaside buffers */
; 648  :     ARCH_DEP(purge_tlb) (regs);

  00115	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0011a	e8 00 00 00 00	 call	 s370_purge_tlb

; 649  : 
; 650  : #if defined(FEATURE_ACCESS_REGISTERS)
; 651  :     ARCH_DEP(purge_alb) (regs);
; 652  : #endif /*defined(FEATURE_ACCESS_REGISTERS)*/
; 653  : 
; 654  :     if(regs->host)

  0011f	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00124	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0012a	c1 e8 07	 shr	 eax, 7
  0012d	83 e0 01	 and	 eax, 1
  00130	85 c0		 test	 eax, eax
  00132	74 3c		 je	 SHORT $LN8@s370_cpu_r

; 655  :     {
; 656  :         /* Put the CPU into the stopped state */
; 657  :         regs->opinterv = 0;

  00134	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00139	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0013f	83 e0 ef	 and	 eax, -17		; ffffffefH
  00142	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00147	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 658  :         regs->cpustate = CPUSTATE_STOPPED;

  0014d	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00152	c6 40 60 03	 mov	 BYTE PTR [rax+96], 3
$LN7@s370_cpu_r:

; 659  :         ON_IC_INTERRUPT(regs);

  00156	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0015b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0015e	0f ba e8 1f	 bts	 eax, 31
  00162	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00167	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  0016a	33 c0		 xor	 eax, eax
  0016c	85 c0		 test	 eax, eax
  0016e	75 e6		 jne	 SHORT $LN7@s370_cpu_r
$LN8@s370_cpu_r:

; 660  :     }
; 661  : 
; 662  : #ifdef FEATURE_INTERVAL_TIMER
; 663  :     ARCH_DEP( store_int_timer_locked )( regs );

  00170	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00175	e8 00 00 00 00	 call	 s370_store_int_timer_locked

; 664  : #endif
; 665  : 
; 666  :     if (regs->host && GUESTREGS)

  0017a	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0017f	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00185	c1 e8 07	 shr	 eax, 7
  00188	83 e0 01	 and	 eax, 1
  0018b	85 c0		 test	 eax, eax
  0018d	74 5b		 je	 SHORT $LN9@s370_cpu_r
  0018f	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00194	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  0019c	74 4c		 je	 SHORT $LN9@s370_cpu_r

; 667  :     {
; 668  :         rc = cpu_reset( GUESTREGS );

  0019e	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  001a3	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  001aa	e8 00 00 00 00	 call	 cpu_reset
  001af	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 669  : 
; 670  :         /* CPU state of SIE copy cannot be controlled */
; 671  :         GUESTREGS->opinterv = 0;

  001b3	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  001b8	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  001bf	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  001c5	83 e0 ef	 and	 eax, -17		; ffffffefH
  001c8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  001cd	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  001d4	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 672  :         GUESTREGS->cpustate = CPUSTATE_STARTED;

  001da	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  001df	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  001e6	c6 40 60 01	 mov	 BYTE PTR [rax+96], 1
$LN9@s370_cpu_r:

; 673  :     }
; 674  : 
; 675  :     /* Re-initialize the facilities list for this CPU */
; 676  :     init_cpu_facilities( regs );

  001ea	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  001ef	e8 00 00 00 00	 call	 init_cpu_facilities

; 677  : 
; 678  :     /* Ensure CPU ID is accurate in case archmode changed */
; 679  :     setCpuIdregs( regs, -1, -1, -1, -1, true );

  001f4	c6 44 24 28 01	 mov	 BYTE PTR [rsp+40], 1
  001f9	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR [rsp+32], -1
  00201	41 b9 ff ff ff
	ff		 mov	 r9d, -1
  00207	66 41 b8 ff ff	 mov	 r8w, -1
  0020c	ba ff ff ff ff	 mov	 edx, -1
  00211	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00216	e8 00 00 00 00	 call	 setCpuIdregs

; 680  : 
; 681  :    return rc;

  0021b	8b 44 24 34	 mov	 eax, DWORD PTR rc$[rsp]

; 682  : } /* end function cpu_reset */

  0021f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00223	c3		 ret	 0
s370_cpu_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ipl.c
_TEXT	SEGMENT
rc$ = 32
tv65 = 36
p$1 = 40
regs$ = 64
cpu_reset PROC

; 928  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 929  :     int rc = 0;

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 930  : 
; 931  :     switch (regs->arch_mode)

  00011	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00016	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00019	89 44 24 24	 mov	 DWORD PTR tv65[rsp], eax
  0001d	83 7c 24 24 00	 cmp	 DWORD PTR tv65[rsp], 0
  00022	74 10		 je	 SHORT $LN7@cpu_reset
  00024	83 7c 24 24 01	 cmp	 DWORD PTR tv65[rsp], 1
  00029	74 19		 je	 SHORT $LN8@cpu_reset
  0002b	83 7c 24 24 02	 cmp	 DWORD PTR tv65[rsp], 2
  00030	74 22		 je	 SHORT $LN9@cpu_reset
  00032	eb 30		 jmp	 SHORT $LN10@cpu_reset
$LN7@cpu_reset:

; 932  :     {
; 933  : #if defined(_370)
; 934  :         case ARCH_370_IDX:
; 935  :             rc = s370_cpu_reset (regs);

  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00039	e8 00 00 00 00	 call	 s370_cpu_reset
  0003e	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 936  :             break;

  00042	eb 37		 jmp	 SHORT $LN2@cpu_reset
$LN8@cpu_reset:

; 937  : #endif
; 938  : #if defined(_390)
; 939  :         case ARCH_390_IDX:
; 940  :             rc = s390_cpu_reset (regs);

  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00049	e8 00 00 00 00	 call	 s390_cpu_reset
  0004e	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 941  :             break;

  00052	eb 27		 jmp	 SHORT $LN2@cpu_reset
$LN9@cpu_reset:

; 942  : #endif
; 943  : #if defined(_900)
; 944  :         case ARCH_900_IDX:
; 945  :             rc = z900_cpu_reset (regs);

  00054	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00059	e8 00 00 00 00	 call	 z900_cpu_reset
  0005e	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 946  :             break;

  00062	eb 17		 jmp	 SHORT $LN2@cpu_reset
$LN10@cpu_reset:
$LN6@cpu_reset:

; 947  : #endif
; 948  :         default: CRASH();

  00064	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  0006d	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  00072	c6 00 00	 mov	 BYTE PTR [rax], 0
  00075	33 c0		 xor	 eax, eax
  00077	85 c0		 test	 eax, eax
  00079	75 e9		 jne	 SHORT $LN6@cpu_reset
$LN2@cpu_reset:

; 949  :     }
; 950  : 
; 951  :     return (rc);

  0007b	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 952  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
cpu_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ipl.c
_TEXT	SEGMENT
n$ = 64
wait$1 = 68
regs$ = 72
i$2 = 80
i$3 = 84
mask$ = 88
i$4 = 96
architecture_switch$ = 100
regs_mode$ = 104
rc$ = 108
tv88 = 112
mask$5 = 120
mask$6 = 128
mask$7 = 136
tv80 = 144
target_mode$ = 176
clear$ = 184
ipl$ = 192
cpu$ = 200
s370_system_reset PROC

; 116  : {

$LN63:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	57		 push	 rdi
  00013	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H

; 117  :     int         rc;
; 118  :     int         n;
; 119  :     int         regs_mode;
; 120  :     int         architecture_switch;
; 121  :     REGS*       regs;
; 122  :     CPU_BITMAP  mask;
; 123  : 
; 124  :     /* Configure the CPU if it's not online yet.
; 125  :      * Note: Configure implies initial reset.
; 126  :      */
; 127  :     if (!IS_CPU_ONLINE( cpu ))

  0001a	48 63 84 24 c8
	00 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00022	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00029	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00032	75 34		 jne	 SHORT $LN32@s370_syste

; 128  :     {
; 129  :         sysblk.arch_mode = target_mode;

  00034	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003b	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR target_mode$[rsp]
  00042	89 88 88 00 00
	00		 mov	 DWORD PTR [rax+136], ecx

; 130  : 
; 131  :         if ((rc = configure_cpu( cpu )))

  00048	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  0004f	e8 00 00 00 00	 call	 configure_cpu
  00054	89 44 24 6c	 mov	 DWORD PTR rc$[rsp], eax
  00058	83 7c 24 6c 00	 cmp	 DWORD PTR rc$[rsp], 0
  0005d	74 09		 je	 SHORT $LN33@s370_syste

; 132  :             return rc;

  0005f	8b 44 24 6c	 mov	 eax, DWORD PTR rc$[rsp]
  00063	e9 8b 07 00 00	 jmp	 $LN1@s370_syste
$LN33@s370_syste:
$LN32@s370_syste:

; 133  :     }
; 134  : 
; 135  :     /* HercGUI hook so it can update its LEDs */
; 136  :     HDC1( debug_cpu_state, sysblk.regs[ cpu ] );

  00068	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  0006f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00073	74 2a		 je	 SHORT $LN59@s370_syste
  00075	48 63 84 24 c8
	00 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0007d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00084	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  0008c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  00093	ff 10		 call	 QWORD PTR [rax]
  00095	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv80[rsp], rax
  0009d	eb 0c		 jmp	 SHORT $LN60@s370_syste
$LN59@s370_syste:
  0009f	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv80[rsp], 0
$LN60@s370_syste:

; 137  : 
; 138  :     /* Determine the target architecture mode for reset.
; 139  :      *
; 140  :      * A system reset normal never changes the architecture mode,
; 141  :      * nor does a system reset clear or IPL for architectures
; 142  :      * other than z/Architecture.  For z/Architecture however,
; 143  :      * a system reset clear or IPL changes the architecture mode
; 144  :      * to ESA/390.
; 145  :      */
; 146  :     if (target_mode > ARCH_390_IDX && (clear || ipl))

  000ab	83 bc 24 b0 00
	00 00 01	 cmp	 DWORD PTR target_mode$[rsp], 1
  000b3	7e 22		 jle	 SHORT $LN34@s370_syste
  000b5	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR clear$[rsp]
  000bd	85 c0		 test	 eax, eax
  000bf	75 0c		 jne	 SHORT $LN36@s370_syste
  000c1	0f b6 84 24 c0
	00 00 00	 movzx	 eax, BYTE PTR ipl$[rsp]
  000c9	85 c0		 test	 eax, eax
  000cb	74 0a		 je	 SHORT $LN34@s370_syste
$LN36@s370_syste:

; 147  :         regs_mode = ARCH_390_IDX;

  000cd	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR regs_mode$[rsp], 1
  000d5	eb 0b		 jmp	 SHORT $LN35@s370_syste
$LN34@s370_syste:

; 148  :     else
; 149  :         regs_mode = target_mode;

  000d7	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR target_mode$[rsp]
  000de	89 44 24 68	 mov	 DWORD PTR regs_mode$[rsp], eax
$LN35@s370_syste:

; 150  : 
; 151  :     /* Remember for later whether this is an architecture switch */
; 152  :     architecture_switch = (regs_mode != sysblk.arch_mode);

  000e2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000e9	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  000ef	39 44 24 68	 cmp	 DWORD PTR regs_mode$[rsp], eax
  000f3	74 0a		 je	 SHORT $LN61@s370_syste
  000f5	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv88[rsp], 1
  000fd	eb 08		 jmp	 SHORT $LN62@s370_syste
$LN61@s370_syste:
  000ff	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv88[rsp], 0
$LN62@s370_syste:
  00107	8b 44 24 70	 mov	 eax, DWORD PTR tv88[rsp]
  0010b	89 44 24 64	 mov	 DWORD PTR architecture_switch$[rsp], eax

; 153  : 
; 154  :     /* Signal all CPUs in configuration to stop and reset */
; 155  :     {
; 156  :         /* Switch lock context to hold both sigplock and intlock */
; 157  :         RELEASE_INTLOCK( NULL );

  0010f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169645
  00116	33 c9		 xor	 ecx, ecx
  00118	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 158  :         {
; 159  :             obtain_lock( &sysblk.sigplock );

  0011d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00124	48 05 80 10 00
	00		 add	 rax, 4224		; 00001080H
  0012a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169646
  00131	48 8b c8	 mov	 rcx, rax
  00134	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 160  :         }
; 161  :         OBTAIN_INTLOCK( NULL );

  0013a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169647
  00141	33 c9		 xor	 ecx, ecx
  00143	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock
$LN4@s370_syste:

; 162  : 
; 163  :         /* Ensure no external updates pending */
; 164  :         OFF_IC_SERVSIG;

  00148	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0014f	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00155	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0015a	85 c0		 test	 eax, eax
  0015c	0f 84 9c 00 00
	00		 je	 $LN37@s370_syste
  00162	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00169	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  0016f	0f ba f0 09	 btr	 eax, 9
  00173	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0017a	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  00180	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00187	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  0018e	48 89 44 24 78	 mov	 QWORD PTR mask$5[rsp], rax
  00193	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  0019b	eb 0a		 jmp	 SHORT $LN7@s370_syste
$LN5@s370_syste:
  0019d	8b 44 24 50	 mov	 eax, DWORD PTR i$2[rsp]
  001a1	ff c0		 inc	 eax
  001a3	89 44 24 50	 mov	 DWORD PTR i$2[rsp], eax
$LN7@s370_syste:
  001a7	48 83 7c 24 78
	00		 cmp	 QWORD PTR mask$5[rsp], 0
  001ad	74 4f		 je	 SHORT $LN6@s370_syste
  001af	48 8b 44 24 78	 mov	 rax, QWORD PTR mask$5[rsp]
  001b4	48 83 e0 01	 and	 rax, 1
  001b8	48 85 c0	 test	 rax, rax
  001bb	74 32		 je	 SHORT $LN38@s370_syste
  001bd	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$2[rsp]
  001c2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001c9	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  001d1	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  001d4	0f ba f0 09	 btr	 eax, 9
  001d8	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$2[rsp]
  001dd	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  001e4	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  001ec	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN38@s370_syste:
  001ef	48 8b 44 24 78	 mov	 rax, QWORD PTR mask$5[rsp]
  001f4	48 d1 e8	 shr	 rax, 1
  001f7	48 89 44 24 78	 mov	 QWORD PTR mask$5[rsp], rax
  001fc	eb 9f		 jmp	 SHORT $LN5@s370_syste
$LN6@s370_syste:
$LN37@s370_syste:
  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	0f 85 40 ff ff
	ff		 jne	 $LN4@s370_syste
$LN10@s370_syste:

; 165  :         OFF_IC_INTKEY;

  00208	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0020f	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00215	83 e0 40	 and	 eax, 64			; 00000040H
  00218	85 c0		 test	 eax, eax
  0021a	0f 84 a9 00 00
	00		 je	 $LN39@s370_syste
  00220	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00227	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  0022d	83 e0 bf	 and	 eax, -65		; ffffffbfH
  00230	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00237	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  0023d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00244	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  0024b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR mask$6[rsp], rax
  00253	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$3[rsp], 0
  0025b	eb 0a		 jmp	 SHORT $LN13@s370_syste
$LN11@s370_syste:
  0025d	8b 44 24 54	 mov	 eax, DWORD PTR i$3[rsp]
  00261	ff c0		 inc	 eax
  00263	89 44 24 54	 mov	 DWORD PTR i$3[rsp], eax
$LN13@s370_syste:
  00267	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR mask$6[rsp], 0
  00270	74 57		 je	 SHORT $LN12@s370_syste
  00272	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mask$6[rsp]
  0027a	48 83 e0 01	 and	 rax, 1
  0027e	48 85 c0	 test	 rax, rax
  00281	74 31		 je	 SHORT $LN40@s370_syste
  00283	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$3[rsp]
  00288	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0028f	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00297	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0029a	83 e0 bf	 and	 eax, -65		; ffffffbfH
  0029d	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR i$3[rsp]
  002a2	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  002a9	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  002b1	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN40@s370_syste:
  002b4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR mask$6[rsp]
  002bc	48 d1 e8	 shr	 rax, 1
  002bf	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR mask$6[rsp], rax
  002c7	eb 94		 jmp	 SHORT $LN11@s370_syste
$LN12@s370_syste:
$LN39@s370_syste:
  002c9	33 c0		 xor	 eax, eax
  002cb	85 c0		 test	 eax, eax
  002cd	0f 85 35 ff ff
	ff		 jne	 $LN10@s370_syste

; 166  : 
; 167  :         /* Loop through CPUs and issue appropriate CPU reset function */
; 168  : 
; 169  :         mask = sysblk.config_mask;

  002d3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002da	48 8b 80 a8 12
	00 00		 mov	 rax, QWORD PTR [rax+4776]
  002e1	48 89 44 24 58	 mov	 QWORD PTR mask$[rsp], rax

; 170  : 
; 171  :         for (n = 0; mask; mask >>= 1, ++n)

  002e6	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  002ee	eb 17		 jmp	 SHORT $LN16@s370_syste
$LN14@s370_syste:
  002f0	48 8b 44 24 58	 mov	 rax, QWORD PTR mask$[rsp]
  002f5	48 d1 e8	 shr	 rax, 1
  002f8	48 89 44 24 58	 mov	 QWORD PTR mask$[rsp], rax
  002fd	8b 44 24 40	 mov	 eax, DWORD PTR n$[rsp]
  00301	ff c0		 inc	 eax
  00303	89 44 24 40	 mov	 DWORD PTR n$[rsp], eax
$LN16@s370_syste:
  00307	48 83 7c 24 58
	00		 cmp	 QWORD PTR mask$[rsp], 0
  0030d	0f 84 e5 00 00
	00		 je	 $LN15@s370_syste

; 172  :         {
; 173  :             if (mask & 1)

  00313	48 8b 44 24 58	 mov	 rax, QWORD PTR mask$[rsp]
  00318	48 83 e0 01	 and	 rax, 1
  0031c	48 85 c0	 test	 rax, rax
  0031f	0f 84 ce 00 00
	00		 je	 $LN41@s370_syste

; 174  :             {
; 175  :                 regs = sysblk.regs[n];

  00325	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$[rsp]
  0032a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00331	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00339	48 89 44 24 48	 mov	 QWORD PTR regs$[rsp], rax

; 176  : 
; 177  :                 /* Signal CPU reset function: if requesting CPU
; 178  :                  * with CLEAR or architecture change, then signal
; 179  :                  * initial CPU reset.  Otherwise, signal a normal
; 180  :                  * CPU reset.
; 181  :                  */
; 182  :                 if (0
; 183  :                     || architecture_switch
; 184  :                     || (n == cpu && (clear || ipl))

  0033e	33 c0		 xor	 eax, eax
  00340	85 c0		 test	 eax, eax
  00342	75 2c		 jne	 SHORT $LN44@s370_syste
  00344	83 7c 24 64 00	 cmp	 DWORD PTR architecture_switch$[rsp], 0
  00349	75 25		 jne	 SHORT $LN44@s370_syste
  0034b	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR cpu$[rsp]
  00352	39 44 24 40	 cmp	 DWORD PTR n$[rsp], eax
  00356	75 34		 jne	 SHORT $LN42@s370_syste
  00358	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR clear$[rsp]
  00360	85 c0		 test	 eax, eax
  00362	75 0c		 jne	 SHORT $LN45@s370_syste
  00364	0f b6 84 24 c0
	00 00 00	 movzx	 eax, BYTE PTR ipl$[rsp]
  0036c	85 c0		 test	 eax, eax
  0036e	74 1c		 je	 SHORT $LN42@s370_syste
$LN45@s370_syste:
$LN44@s370_syste:

; 185  :                 )
; 186  :                     regs->sigp_ini_reset = TRUE;

  00370	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00375	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0037b	0f ba e8 14	 bts	 eax, 20
  0037f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00384	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
  0038a	eb 1a		 jmp	 SHORT $LN43@s370_syste
$LN42@s370_syste:

; 187  :                 else
; 188  :                     regs->sigp_reset = TRUE;

  0038c	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00391	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00397	0f ba e8 13	 bts	 eax, 19
  0039b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  003a0	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN43@s370_syste:

; 189  : 
; 190  :                 regs->opinterv = TRUE;

  003a6	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  003ab	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  003b1	83 c8 10	 or	 eax, 16
  003b4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  003b9	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 191  :                 regs->cpustate = CPUSTATE_STOPPING;

  003bf	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  003c4	c6 40 60 02	 mov	 BYTE PTR [rax+96], 2
$LN19@s370_syste:

; 192  :                 ON_IC_INTERRUPT( regs );

  003c8	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  003cd	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  003d0	0f ba e8 1f	 bts	 eax, 31
  003d4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  003d9	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  003dc	33 c0		 xor	 eax, eax
  003de	85 c0		 test	 eax, eax
  003e0	75 e6		 jne	 SHORT $LN19@s370_syste

; 193  :                 WAKEUP_CPU( regs );

  003e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169657
  003e9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  003ee	e8 00 00 00 00	 call	 wakeup_cpu
$LN41@s370_syste:

; 194  :             }
; 195  :         }

  003f3	e9 f8 fe ff ff	 jmp	 $LN14@s370_syste
$LN15@s370_syste:

; 196  : 
; 197  :         /* Return to hold of just intlock */
; 198  :         RELEASE_INTLOCK( NULL );

  003f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169658
  003ff	33 c9		 xor	 ecx, ecx
  00401	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 199  :         {
; 200  :             release_lock( &sysblk.sigplock );

  00406	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0040d	48 05 80 10 00
	00		 add	 rax, 4224		; 00001080H
  00413	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169659
  0041a	48 8b c8	 mov	 rcx, rax
  0041d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 201  :         }
; 202  :         OBTAIN_INTLOCK( NULL );

  00423	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169660
  0042a	33 c9		 xor	 ecx, ecx
  0042c	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 203  :     }
; 204  : 
; 205  :     /* Wait for CPUs to complete their resets */
; 206  :     {
; 207  :         int i;
; 208  :         bool wait = true;

  00431	c6 44 24 44 01	 mov	 BYTE PTR wait$1[rsp], 1

; 209  : 
; 210  :         for (n = 0; wait && n < 300; ++n)

  00436	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  0043e	eb 0a		 jmp	 SHORT $LN22@s370_syste
$LN20@s370_syste:
  00440	8b 44 24 40	 mov	 eax, DWORD PTR n$[rsp]
  00444	ff c0		 inc	 eax
  00446	89 44 24 40	 mov	 DWORD PTR n$[rsp], eax
$LN22@s370_syste:
  0044a	0f b6 44 24 44	 movzx	 eax, BYTE PTR wait$1[rsp]
  0044f	85 c0		 test	 eax, eax
  00451	0f 84 bc 00 00
	00		 je	 $LN21@s370_syste
  00457	81 7c 24 40 2c
	01 00 00	 cmp	 DWORD PTR n$[rsp], 300	; 0000012cH
  0045f	0f 8d ae 00 00
	00		 jge	 $LN21@s370_syste

; 211  :         {
; 212  :             mask = sysblk.config_mask;

  00465	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0046c	48 8b 80 a8 12
	00 00		 mov	 rax, QWORD PTR [rax+4776]
  00473	48 89 44 24 58	 mov	 QWORD PTR mask$[rsp], rax

; 213  :             wait = false;

  00478	c6 44 24 44 00	 mov	 BYTE PTR wait$1[rsp], 0

; 214  : 
; 215  :             for (i=0; mask; mask >>= 1, ++i)

  0047d	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$4[rsp], 0
  00485	eb 17		 jmp	 SHORT $LN25@s370_syste
$LN23@s370_syste:
  00487	48 8b 44 24 58	 mov	 rax, QWORD PTR mask$[rsp]
  0048c	48 d1 e8	 shr	 rax, 1
  0048f	48 89 44 24 58	 mov	 QWORD PTR mask$[rsp], rax
  00494	8b 44 24 60	 mov	 eax, DWORD PTR i$4[rsp]
  00498	ff c0		 inc	 eax
  0049a	89 44 24 60	 mov	 DWORD PTR i$4[rsp], eax
$LN25@s370_syste:
  0049e	48 83 7c 24 58
	00		 cmp	 QWORD PTR mask$[rsp], 0
  004a4	74 68		 je	 SHORT $LN24@s370_syste

; 216  :             {
; 217  :                 if (!(mask & 1))

  004a6	48 8b 44 24 58	 mov	 rax, QWORD PTR mask$[rsp]
  004ab	48 83 e0 01	 and	 rax, 1
  004af	48 85 c0	 test	 rax, rax
  004b2	75 02		 jne	 SHORT $LN46@s370_syste

; 218  :                     continue;

  004b4	eb d1		 jmp	 SHORT $LN23@s370_syste
$LN46@s370_syste:

; 219  : 
; 220  :                 regs = sysblk.regs[ i ];

  004b6	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$4[rsp]
  004bb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004c2	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  004ca	48 89 44 24 48	 mov	 QWORD PTR regs$[rsp], rax

; 221  : 
; 222  :                 if (regs->cpustate != CPUSTATE_STOPPED)

  004cf	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  004d4	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  004d8	83 f8 03	 cmp	 eax, 3
  004db	74 2c		 je	 SHORT $LN47@s370_syste

; 223  :                 {
; 224  :                     wait = true;

  004dd	c6 44 24 44 01	 mov	 BYTE PTR wait$1[rsp], 1

; 225  : 
; 226  :                     /* Release intlock, take a nap, and re-acquire */
; 227  :                     RELEASE_INTLOCK( NULL );

  004e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169663
  004e9	33 c9		 xor	 ecx, ecx
  004eb	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 228  :                     {
; 229  :                         usleep( 10000 );  // (wait 10 milliseconds)

  004f0	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  004f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 230  :                     }
; 231  :                     OBTAIN_INTLOCK( NULL );

  004fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169664
  00502	33 c9		 xor	 ecx, ecx
  00504	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock
$LN47@s370_syste:

; 232  :                 }
; 233  :             }

  00509	e9 79 ff ff ff	 jmp	 $LN23@s370_syste
$LN24@s370_syste:

; 234  :         }

  0050e	e9 2d ff ff ff	 jmp	 $LN20@s370_syste
$LN21@s370_syste:

; 235  :     }
; 236  : 
; 237  :     /* FIXME: Recovery code is needed to handle the case where
; 238  :      * CPUs are misbehaving. Outstanding locks should be reported,
; 239  :      * then take-over CPUs and perform initial reset of each CPU.
; 240  :      */
; 241  :     if (n >= 300)   // (more than 300 * 10 milliseconds == 3 seconds?)

  00513	81 7c 24 40 2c
	01 00 00	 cmp	 DWORD PTR n$[rsp], 300	; 0000012cH
  0051b	7c 53		 jl	 SHORT $LN48@s370_syste

; 242  :     {
; 243  :         // "DBG: %s"
; 244  :         WRMSG( HHC90000, "E", "Could not perform reset within three seconds" );

  0051d	b9 01 00 00 00	 mov	 ecx, 1
  00522	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00528	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169666
  0052f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00534	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169667
  0053b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00540	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169668
  00547	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0054c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00551	41 b9 03 00 00
	00		 mov	 r9d, 3
  00557	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169669
  0055e	ba f4 00 00 00	 mov	 edx, 244		; 000000f4H
  00563	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169670
  0056a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN48@s370_syste:

; 245  :     }
; 246  : 
; 247  :     /* Clear Crypto Wrapping Keys. We do this regardless of whether
; 248  :        the facility is enabled for the given architecture or not
; 249  :        since there is no real harm in always doing so. Note too that
; 250  :        we only do this when the architecture is NOT being switched
; 251  :        so that it only gets done once and not twice since it doesn't
; 252  :        matter what the current architecture mode is since the crypto
; 253  :        wrapping keys aren't associated with any given architecture.
; 254  :     */
; 255  : #if defined( _FEATURE_076_MSA_EXTENSION_FACILITY_3 ) // (underscore!)
; 256  :     if (clear && !architecture_switch)

  00570	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR clear$[rsp]
  00578	85 c0		 test	 eax, eax
  0057a	74 0c		 je	 SHORT $LN49@s370_syste
  0057c	83 7c 24 64 00	 cmp	 DWORD PTR architecture_switch$[rsp], 0
  00581	75 05		 jne	 SHORT $LN49@s370_syste

; 257  :         renew_wrapping_keys();

  00583	e8 00 00 00 00	 call	 renew_wrapping_keys
$LN49@s370_syste:

; 258  : #endif
; 259  : 
; 260  :     /* Finish the reset in the requested mode if switching architectures */
; 261  :     if (architecture_switch)

  00588	83 7c 24 64 00	 cmp	 DWORD PTR architecture_switch$[rsp], 0
  0058d	74 3b		 je	 SHORT $LN50@s370_syste

; 262  :     {
; 263  :         sysblk.arch_mode = regs_mode;

  0058f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00596	8b 4c 24 68	 mov	 ecx, DWORD PTR regs_mode$[rsp]
  0059a	89 88 88 00 00
	00		 mov	 DWORD PTR [rax+136], ecx

; 264  :         return ARCH_DEP( system_reset )( target_mode, clear, ipl, cpu );

  005a0	44 8b 8c 24 c8
	00 00 00	 mov	 r9d, DWORD PTR cpu$[rsp]
  005a8	44 0f b6 84 24
	c0 00 00 00	 movzx	 r8d, BYTE PTR ipl$[rsp]
  005b1	0f b6 94 24 b8
	00 00 00	 movzx	 edx, BYTE PTR clear$[rsp]
  005b9	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR target_mode$[rsp]
  005c0	e8 00 00 00 00	 call	 s370_system_reset
  005c5	e9 29 02 00 00	 jmp	 $LN1@s370_syste
$LN50@s370_syste:

; 265  :     }
; 266  : 
; 267  :     /* Perform subsystem reset
; 268  :      *
; 269  :      * GA22-7000-10 IBM System/370 Principles of Operation, Chapter 4.
; 270  :      *              Control, Subsystem Reset, p. 4-34
; 271  :      * SA22-7085-00 IBM System/370 Extended Architecture Principles of
; 272  :      *              Operation, Chapter 4. Control, Subsystem Reset,
; 273  :      *              p. 4-28
; 274  :      * SA22-7832-09 z/Architecture Principles of Operation, Chapter 4.
; 275  :      *              Control, Subsystem Reset, p. 4-57
; 276  :      */
; 277  :     subsystem_reset();

  005ca	e8 00 00 00 00	 call	 subsystem_reset

; 278  : 
; 279  :     /* Perform system-reset-clear additional functions */
; 280  :     if (clear)

  005cf	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR clear$[rsp]
  005d7	85 c0		 test	 eax, eax
  005d9	0f 84 0c 01 00
	00		 je	 $LN51@s370_syste

; 281  :     {
; 282  :         /* Finish reset-clear of all CPUs in the configuration */
; 283  :         for (n = 0; n < sysblk.maxcpu; ++n)

  005df	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  005e7	eb 0a		 jmp	 SHORT $LN28@s370_syste
$LN26@s370_syste:
  005e9	8b 44 24 40	 mov	 eax, DWORD PTR n$[rsp]
  005ed	ff c0		 inc	 eax
  005ef	89 44 24 40	 mov	 DWORD PTR n$[rsp], eax
$LN28@s370_syste:
  005f3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005fa	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00600	39 44 24 40	 cmp	 DWORD PTR n$[rsp], eax
  00604	0f 8d 84 00 00
	00		 jge	 $LN27@s370_syste

; 284  :         {
; 285  :             if (IS_CPU_ONLINE( n ))

  0060a	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$[rsp]
  0060f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00616	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0061f	74 68		 je	 SHORT $LN53@s370_syste

; 286  :             {
; 287  :                 regs = sysblk.regs[ n ];

  00621	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$[rsp]
  00626	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0062d	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00635	48 89 44 24 48	 mov	 QWORD PTR regs$[rsp], rax

; 288  : 
; 289  :                 /* Clear all the registers (AR, GPR, FPR, VR)
; 290  :                  * as part of the CPU CLEAR RESET operation
; 291  :                  */
; 292  :                 memset( regs->ar,  0, sizeof( regs->ar  ));

  0063a	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0063f	48 05 00 03 00
	00		 add	 rax, 768		; 00000300H
  00645	48 8b f8	 mov	 rdi, rax
  00648	33 c0		 xor	 eax, eax
  0064a	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0064f	f3 aa		 rep stosb

; 293  :                 memset( regs->gr,  0, sizeof( regs->gr  ));

  00651	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00656	48 05 80 02 00
	00		 add	 rax, 640		; 00000280H
  0065c	48 8b f8	 mov	 rdi, rax
  0065f	33 c0		 xor	 eax, eax
  00661	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00666	f3 aa		 rep stosb

; 294  :                 memset( regs->fpr, 0, sizeof( regs->fpr ));

  00668	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0066d	48 05 40 03 00
	00		 add	 rax, 832		; 00000340H
  00673	48 8b f8	 mov	 rdi, rax
  00676	33 c0		 xor	 eax, eax
  00678	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0067d	f3 aa		 rep stosb

; 295  : 
; 296  : #if defined( _FEATURE_S370_S390_VECTOR_FACILITY )
; 297  :                 memset( regs->vf->vr, 0, sizeof( regs->vf->vr ));
; 298  : #endif
; 299  :                 /* Clear the instruction counter and CPU time used */
; 300  :                 cpu_reset_instcount_and_cputime( regs );

  0067f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00684	e8 00 00 00 00	 call	 cpu_reset_instcount_and_cputime
$LN53@s370_syste:

; 301  :             }
; 302  :         }

  00689	e9 5b ff ff ff	 jmp	 $LN26@s370_syste
$LN27@s370_syste:

; 303  : 
; 304  :         /* Clear storage */
; 305  :         sysblk.main_clear = sysblk.xpnd_clear = 0;

  0068e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00695	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0069b	0f ba f0 0f	 btr	 eax, 15
  0069f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006a6	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
  006ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006b3	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  006b9	0f ba f0 0e	 btr	 eax, 14
  006bd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006c4	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 306  :         storage_clear();

  006ca	e8 00 00 00 00	 call	 storage_clear

; 307  :         xstorage_clear();

  006cf	e8 00 00 00 00	 call	 xstorage_clear

; 308  : 
; 309  :         /* Clear IPL program parameter */
; 310  :         sysblk.program_parameter = 0;

  006d4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006db	48 c7 80 18 0e
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+3608], 0

; 311  :     }

  006e6	e9 80 00 00 00	 jmp	 $LN52@s370_syste
$LN51@s370_syste:

; 312  : 
; 313  :     /* If IPL call, reset CPU instruction counts and times */
; 314  :     else if (ipl)

  006eb	0f b6 84 24 c0
	00 00 00	 movzx	 eax, BYTE PTR ipl$[rsp]
  006f3	85 c0		 test	 eax, eax
  006f5	74 74		 je	 SHORT $LN54@s370_syste

; 315  :     {
; 316  :         CPU_BITMAP  mask  = sysblk.config_mask;

  006f7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006fe	48 8b 80 a8 12
	00 00		 mov	 rax, QWORD PTR [rax+4776]
  00705	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR mask$7[rsp], rax

; 317  : 
; 318  :         for (n=0; mask; mask >>= 1, ++n)

  0070d	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  00715	eb 1d		 jmp	 SHORT $LN31@s370_syste
$LN29@s370_syste:
  00717	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR mask$7[rsp]
  0071f	48 d1 e8	 shr	 rax, 1
  00722	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR mask$7[rsp], rax
  0072a	8b 44 24 40	 mov	 eax, DWORD PTR n$[rsp]
  0072e	ff c0		 inc	 eax
  00730	89 44 24 40	 mov	 DWORD PTR n$[rsp], eax
$LN31@s370_syste:
  00734	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR mask$7[rsp], 0
  0073d	74 2c		 je	 SHORT $LN30@s370_syste

; 319  :         {
; 320  :             if (mask & 0x01)

  0073f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR mask$7[rsp]
  00747	48 83 e0 01	 and	 rax, 1
  0074b	48 85 c0	 test	 rax, rax
  0074e	74 19		 je	 SHORT $LN55@s370_syste

; 321  :                 cpu_reset_instcount_and_cputime( sysblk.regs[ n ]);

  00750	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$[rsp]
  00755	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0075c	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  00764	e8 00 00 00 00	 call	 cpu_reset_instcount_and_cputime
$LN55@s370_syste:

; 322  :         }

  00769	eb ac		 jmp	 SHORT $LN29@s370_syste
$LN30@s370_syste:
$LN54@s370_syste:
$LN52@s370_syste:

; 323  :     }
; 324  : 
; 325  :     /* If IPL or system-reset-clear, clear the system
; 326  :      * instruction counter, rates, and IPLed indicator.
; 327  :      */
; 328  :     if (clear || ipl)

  0076b	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR clear$[rsp]
  00773	85 c0		 test	 eax, eax
  00775	75 0c		 jne	 SHORT $LN57@s370_syste
  00777	0f b6 84 24 c0
	00 00 00	 movzx	 eax, BYTE PTR ipl$[rsp]
  0077f	85 c0		 test	 eax, eax
  00781	74 51		 je	 SHORT $LN56@s370_syste
$LN57@s370_syste:

; 329  :     {
; 330  :         /* Clear system instruction counter and CPU rates */
; 331  :         sysblk.instcount = 0;

  00783	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0078a	48 c7 80 80 14
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+5248], 0

; 332  :         sysblk.mipsrate  = 0;

  00795	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0079c	c7 80 88 14 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5256], 0

; 333  :         sysblk.siosrate  = 0;

  007a6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007ad	c7 80 8c 14 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5260], 0

; 334  :         sysblk.ipled     = FALSE;

  007b7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007be	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  007c4	83 e0 fd	 and	 eax, -3			; fffffffdH
  007c7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  007ce	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
$LN56@s370_syste:

; 335  :     }
; 336  : 
; 337  :     /* Set horizontal polarization and clear the
; 338  :        topology-change-report-pending condition.
; 339  :     */
; 340  : #if defined( FEATURE_011_CONFIG_TOPOLOGY_FACILITY )
; 341  :     sysblk.topology = TOPOLOGY_HORIZ;
; 342  :     sysblk.topchnge = 0;
; 343  : #endif
; 344  : 
; 345  :     /* Set the system state to "reset" */
; 346  :     sysblk.sys_reset = TRUE;

  007d4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007db	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  007e1	83 c8 01	 or	 eax, 1
  007e4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  007eb	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 347  : 
; 348  :     return 0;

  007f1	33 c0		 xor	 eax, eax
$LN1@s370_syste:

; 349  : } /* end function system_reset */

  007f3	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  007fa	5f		 pop	 rdi
  007fb	c3		 ret	 0
s370_system_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ipl.c
_TEXT	SEGMENT
rc$ = 32
tv65 = 36
p$1 = 40
target_mode$ = 64
clear$ = 72
ipl$ = 80
cpu$ = 88
system_reset PROC

; 904  : {

$LN12:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     int rc = 0;

  00016	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 906  : 
; 907  :     switch ( sysblk.arch_mode )

  0001e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00025	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0002b	89 44 24 24	 mov	 DWORD PTR tv65[rsp], eax
  0002f	83 7c 24 24 00	 cmp	 DWORD PTR tv65[rsp], 0
  00034	74 10		 je	 SHORT $LN7@system_res
  00036	83 7c 24 24 01	 cmp	 DWORD PTR tv65[rsp], 1
  0003b	74 28		 je	 SHORT $LN8@system_res
  0003d	83 7c 24 24 02	 cmp	 DWORD PTR tv65[rsp], 2
  00042	74 40		 je	 SHORT $LN9@system_res
  00044	eb 5d		 jmp	 SHORT $LN10@system_res
$LN7@system_res:

; 908  :     {
; 909  : #if defined( _370 )
; 910  :         case ARCH_370_IDX: rc = s370_system_reset( target_mode, clear, ipl, cpu ); break;

  00046	44 8b 4c 24 58	 mov	 r9d, DWORD PTR cpu$[rsp]
  0004b	44 0f b6 44 24
	50		 movzx	 r8d, BYTE PTR ipl$[rsp]
  00051	0f b6 54 24 48	 movzx	 edx, BYTE PTR clear$[rsp]
  00056	8b 4c 24 40	 mov	 ecx, DWORD PTR target_mode$[rsp]
  0005a	e8 00 00 00 00	 call	 s370_system_reset
  0005f	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
  00063	eb 55		 jmp	 SHORT $LN2@system_res
$LN8@system_res:

; 911  : #endif
; 912  : #if defined( _390 )
; 913  :         case ARCH_390_IDX: rc = s390_system_reset( target_mode, clear, ipl, cpu ); break;

  00065	44 8b 4c 24 58	 mov	 r9d, DWORD PTR cpu$[rsp]
  0006a	44 0f b6 44 24
	50		 movzx	 r8d, BYTE PTR ipl$[rsp]
  00070	0f b6 54 24 48	 movzx	 edx, BYTE PTR clear$[rsp]
  00075	8b 4c 24 40	 mov	 ecx, DWORD PTR target_mode$[rsp]
  00079	e8 00 00 00 00	 call	 s390_system_reset
  0007e	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
  00082	eb 36		 jmp	 SHORT $LN2@system_res
$LN9@system_res:

; 914  : #endif
; 915  : #if defined( _900 )
; 916  :         case ARCH_900_IDX: rc = z900_system_reset( target_mode, clear, ipl, cpu ); break;

  00084	44 8b 4c 24 58	 mov	 r9d, DWORD PTR cpu$[rsp]
  00089	44 0f b6 44 24
	50		 movzx	 r8d, BYTE PTR ipl$[rsp]
  0008f	0f b6 54 24 48	 movzx	 edx, BYTE PTR clear$[rsp]
  00094	8b 4c 24 40	 mov	 ecx, DWORD PTR target_mode$[rsp]
  00098	e8 00 00 00 00	 call	 z900_system_reset
  0009d	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
  000a1	eb 17		 jmp	 SHORT $LN2@system_res
$LN10@system_res:
$LN6@system_res:

; 917  : #endif
; 918  :         default: CRASH();

  000a3	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  000ac	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  000b1	c6 00 00	 mov	 BYTE PTR [rax], 0
  000b4	33 c0		 xor	 eax, eax
  000b6	85 c0		 test	 eax, eax
  000b8	75 e9		 jne	 SHORT $LN6@system_res
$LN2@system_res:

; 919  :     }
; 920  : 
; 921  :     return rc;

  000ba	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 922  : }

  000be	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c2	c3		 ret	 0
system_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ipl.c
_TEXT	SEGMENT
chanstat$ = 80
unitstat$ = 81
i$ = 84
dev$ = 88
regs$ = 96
rc$ = 104
tv304 = 108
tv306 = 112
tv81 = 120
tv148 = 128
tv168 = 136
tv316 = 144
tv336 = 152
buf2$1 = 160
buf$2 = 176
buf$3 = 256
buf$4 = 336
buffer$5 = 416
__$ArrayPad$ = 672
lcss$ = 704
devnum$ = 712
cpu$ = 720
clear$ = 728
s370_load_ipl PROC

; 416  : {

$LN22:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000f	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00014	57		 push	 rdi
  00015	48 81 ec b0 02
	00 00		 sub	 rsp, 688		; 000002b0H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 a0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 417  : REGS   *regs;                           /* -> Regs                   */
; 418  : DEVBLK *dev;                            /* -> Device control block   */
; 419  : int     i;                              /* Array subscript           */
; 420  : BYTE    unitstat;                       /* IPL device unit status    */
; 421  : BYTE    chanstat;                       /* IPL device channel status */
; 422  : int rc;
; 423  : 
; 424  :     /* Get started */
; 425  :     if ((rc = ARCH_DEP( common_load_begin )( cpu, clear )))

  0002e	8b 94 24 d8 02
	00 00		 mov	 edx, DWORD PTR clear$[rsp]
  00035	8b 8c 24 d0 02
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  0003c	e8 00 00 00 00	 call	 s370_common_load_begin
  00041	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax
  00045	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  0004a	74 09		 je	 SHORT $LN8@s370_load_

; 426  :         return rc;

  0004c	8b 44 24 68	 mov	 eax, DWORD PTR rc$[rsp]
  00050	e9 e9 07 00 00	 jmp	 $LN1@s370_load_
$LN8@s370_load_:

; 427  : 
; 428  :     /* Ensure CPU is online */
; 429  :     if (!IS_CPU_ONLINE(cpu))

  00055	48 63 84 24 d0
	02 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0005d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00064	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0006d	0f 85 c6 00 00
	00		 jne	 $LN9@s370_load_

; 430  :     {
; 431  :         char buf[80];
; 432  :         MSGBUF(buf, "CP%2.2X Offline", devnum);

  00073	0f b7 84 24 c8
	02 00 00	 movzx	 eax, WORD PTR devnum$[rsp]
  0007b	44 8b c8	 mov	 r9d, eax
  0007e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169737
  00085	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  0008a	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR buf$3[rsp]
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 433  :         // "Processor %s%02X: ipl failed: %s"
; 434  :         WRMSG (HHC00810, "E", PTYPSTR(sysblk.pcpu), sysblk.pcpu, buf);

  00098	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0009f	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  000a6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000ad	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  000bb	48 89 44 24 78	 mov	 QWORD PTR tv81[rsp], rax
  000c0	b9 01 00 00 00	 mov	 ecx, 1
  000c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000cb	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR buf$3[rsp]
  000d3	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000d8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000df	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  000e5	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000e9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv81[rsp]
  000ee	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169738
  000fa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169739
  00106	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0010b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00110	41 b9 03 00 00
	00		 mov	 r9d, 3
  00116	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169740
  0011d	ba b2 01 00 00	 mov	 edx, 434		; 000001b2H
  00122	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169741
  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 435  :         return -1;

  0012f	b8 ff ff ff ff	 mov	 eax, -1
  00134	e9 05 07 00 00	 jmp	 $LN1@s370_load_
$LN9@s370_load_:

; 436  :     }
; 437  : 
; 438  :     /* The actual IPL proper starts here... */
; 439  : 
; 440  :     regs = sysblk.regs[cpu];    /* Point to IPL CPU's registers */

  00139	48 63 84 24 d0
	02 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00141	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00148	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00150	48 89 44 24 60	 mov	 QWORD PTR regs$[rsp], rax

; 441  :     /* Point to the device block for the IPL device */
; 442  :     dev = find_device_by_devnum (lcss,devnum);

  00155	0f b7 94 24 c8
	02 00 00	 movzx	 edx, WORD PTR devnum$[rsp]
  0015d	0f b7 8c 24 c0
	02 00 00	 movzx	 ecx, WORD PTR lcss$[rsp]
  00165	e8 00 00 00 00	 call	 find_device_by_devnum
  0016a	48 89 44 24 58	 mov	 QWORD PTR dev$[rsp], rax

; 443  :     if (dev == NULL)

  0016f	48 83 7c 24 58
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00175	0f 85 09 01 00
	00		 jne	 $LN10@s370_load_

; 444  :     {
; 445  :         char buf[80];
; 446  :         MSGBUF( buf, "device %1d:%04X not found", lcss, devnum );

  0017b	0f b7 84 24 c8
	02 00 00	 movzx	 eax, WORD PTR devnum$[rsp]
  00183	0f b7 8c 24 c0
	02 00 00	 movzx	 ecx, WORD PTR lcss$[rsp]
  0018b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0018f	44 8b c9	 mov	 r9d, ecx
  00192	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169743
  00199	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  0019e	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$4[rsp]
  001a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 447  :         // "Processor %s%02X: ipl failed: %s"
; 448  :         WRMSG( HHC00810, "E", PTYPSTR( sysblk.pcpu ), sysblk.pcpu, buf );

  001ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001b3	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  001ba	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001c1	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  001c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  001cf	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv148[rsp], rax
  001d7	b9 01 00 00 00	 mov	 ecx, 1
  001dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001e2	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$4[rsp]
  001ea	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001ef	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001f6	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  001fc	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00200	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv148[rsp]
  00208	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0020d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169744
  00214	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00219	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169745
  00220	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00225	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0022a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00230	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169746
  00237	ba c0 01 00 00	 mov	 edx, 448		; 000001c0H
  0023c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169747
  00243	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 449  : 
; 450  :         /* HercGUI hook so it can update its LEDs */
; 451  :         HDC1( debug_cpu_state, regs );

  00249	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  00250	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00254	74 18		 je	 SHORT $LN18@s370_load_
  00256	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0025b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  00262	ff 10		 call	 QWORD PTR [rax]
  00264	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv168[rsp], rax
  0026c	eb 0c		 jmp	 SHORT $LN19@s370_load_
$LN18@s370_load_:
  0026e	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv168[rsp], 0
$LN19@s370_load_:

; 452  : 
; 453  :         return -1;

  0027a	b8 ff ff ff ff	 mov	 eax, -1
  0027f	e9 ba 05 00 00	 jmp	 $LN1@s370_load_
$LN10@s370_load_:

; 454  :     }
; 455  : 
; 456  :     if(sysblk.haveiplparm)

  00284	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0028b	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00291	c1 e8 15	 shr	 eax, 21
  00294	83 e0 01	 and	 eax, 1
  00297	85 c0		 test	 eax, eax
  00299	74 73		 je	 SHORT $LN11@s370_load_

; 457  :     {
; 458  :         for(i=0;i<16;i++)

  0029b	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002a3	eb 0a		 jmp	 SHORT $LN4@s370_load_
$LN2@s370_load_:
  002a5	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  002a9	ff c0		 inc	 eax
  002ab	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN4@s370_load_:
  002af	83 7c 24 54 10	 cmp	 DWORD PTR i$[rsp], 16
  002b4	7d 3a		 jge	 SHORT $LN3@s370_load_

; 459  :         {
; 460  :             regs->GR_L(i)=fetch_fw(&sysblk.iplparmstring[i*4]);

  002b6	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  002ba	c1 e0 02	 shl	 eax, 2
  002bd	48 98		 cdqe
  002bf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002c6	48 8d 84 01 f8
	12 00 00	 lea	 rax, QWORD PTR [rcx+rax+4856]
  002ce	48 8b c8	 mov	 rcx, rax
  002d1	e8 00 00 00 00	 call	 fetch_fw_noswap
  002d6	8b c8		 mov	 ecx, eax
  002d8	e8 00 00 00 00	 call	 _byteswap_ulong
  002dd	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR i$[rsp]
  002e2	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  002e7	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 461  :         }

  002ee	eb b5		 jmp	 SHORT $LN2@s370_load_
$LN3@s370_load_:

; 462  :         sysblk.haveiplparm=0;

  002f0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002f7	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  002fd	0f ba f0 15	 btr	 eax, 21
  00301	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00308	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
$LN11@s370_load_:

; 463  :     }
; 464  : 
; 465  :     /* Set Main Storage Reference and Update bits */
; 466  :     ARCH_DEP( or_storage_key )( regs->PX, (STORKEY_REF | STORKEY_CHANGE) );

  0030e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00313	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00316	b2 06		 mov	 dl, 6
  00318	8b c8		 mov	 ecx, eax
  0031a	e8 00 00 00 00	 call	 s370_or_storage_key

; 467  :     sysblk.main_clear = sysblk.xpnd_clear = 0;

  0031f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00326	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0032c	0f ba f0 0f	 btr	 eax, 15
  00330	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00337	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
  0033d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00344	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0034a	0f ba f0 0e	 btr	 eax, 14
  0034e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00355	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 468  : 
; 469  :     /* Build the IPL CCW at location 0 */
; 470  :     regs->psa->iplpsw[0] = 0x02;              /* CCW command = Read */

  0035b	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00360	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  00367	b9 01 00 00 00	 mov	 ecx, 1
  0036c	48 6b c9 00	 imul	 rcx, rcx, 0
  00370	c6 04 08 02	 mov	 BYTE PTR [rax+rcx], 2

; 471  :     regs->psa->iplpsw[1] = 0;                 /* Data address = zero */

  00374	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00379	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  00380	b9 01 00 00 00	 mov	 ecx, 1
  00385	48 6b c9 01	 imul	 rcx, rcx, 1
  00389	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 472  :     regs->psa->iplpsw[2] = 0;

  0038d	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00392	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  00399	b9 01 00 00 00	 mov	 ecx, 1
  0039e	48 6b c9 02	 imul	 rcx, rcx, 2
  003a2	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 473  :     regs->psa->iplpsw[3] = 0;

  003a6	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  003ab	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  003b2	b9 01 00 00 00	 mov	 ecx, 1
  003b7	48 6b c9 03	 imul	 rcx, rcx, 3
  003bb	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 474  :     regs->psa->iplpsw[4] = CCW_FLAGS_CC | CCW_FLAGS_SLI;

  003bf	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  003c4	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  003cb	b9 01 00 00 00	 mov	 ecx, 1
  003d0	48 6b c9 04	 imul	 rcx, rcx, 4
  003d4	c6 04 08 60	 mov	 BYTE PTR [rax+rcx], 96	; 00000060H

; 475  :                                         /* CCW flags */
; 476  :     regs->psa->iplpsw[5] = 0;                 /* Reserved byte */

  003d8	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  003dd	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  003e4	b9 01 00 00 00	 mov	 ecx, 1
  003e9	48 6b c9 05	 imul	 rcx, rcx, 5
  003ed	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 477  :     regs->psa->iplpsw[6] = 0;                 /* Byte count = 24 */

  003f1	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  003f6	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  003fd	b9 01 00 00 00	 mov	 ecx, 1
  00402	48 6b c9 06	 imul	 rcx, rcx, 6
  00406	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 478  :     regs->psa->iplpsw[7] = 24;

  0040a	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0040f	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  00416	b9 01 00 00 00	 mov	 ecx, 1
  0041b	48 6b c9 07	 imul	 rcx, rcx, 7
  0041f	c6 04 08 18	 mov	 BYTE PTR [rax+rcx], 24

; 479  : 
; 480  :     /* Enable the subchannel for the IPL device */
; 481  :     dev->pmcw.flag5 |= PMCW5_E;

  00423	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  00428	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0042f	0f ba e8 07	 bts	 eax, 7
  00433	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dev$[rsp]
  00438	88 81 f1 02 00
	00		 mov	 BYTE PTR [rcx+753], al

; 482  : 
; 483  :     /* Build the operation request block */
; 484  :     memset (&dev->orb, 0, sizeof(ORB));

  0043e	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  00443	48 05 cc 02 00
	00		 add	 rax, 716		; 000002ccH
  00449	48 8b f8	 mov	 rdi, rax
  0044c	33 c0		 xor	 eax, eax
  0044e	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00453	f3 aa		 rep stosb

; 485  :     dev->busy = 1;

  00455	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  0045a	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00460	0f ba e8 13	 bts	 eax, 19
  00464	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dev$[rsp]
  00469	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 486  : 
; 487  :     RELEASE_INTLOCK(NULL);

  0046f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169749
  00476	33 c9		 xor	 ecx, ecx
  00478	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 488  : 
; 489  :     /* Execute the IPL channel program */
; 490  :     ARCH_DEP(execute_ccw_chain) (dev);

  0047d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dev$[rsp]
  00482	e8 00 00 00 00	 call	 s370_execute_ccw_chain

; 491  : 
; 492  :     OBTAIN_INTLOCK(NULL);

  00487	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169750
  0048e	33 c9		 xor	 ecx, ecx
  00490	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 493  : 
; 494  :     /* Clear the interrupt pending and device busy conditions */
; 495  :     obtain_lock (&sysblk.iointqlk);

  00495	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0049c	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  004a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169751
  004a9	48 8b c8	 mov	 rcx, rax
  004ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 496  :     DEQUEUE_IO_INTERRUPT_QLOCKED(&dev->ioint);

  004b2	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  004b7	48 05 28 02 00
	00		 add	 rax, 552		; 00000228H
  004bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169752
  004c4	48 8b c8	 mov	 rcx, rax
  004c7	e8 00 00 00 00	 call	 Dequeue_IO_Interrupt_QLocked

; 497  :     DEQUEUE_IO_INTERRUPT_QLOCKED(&dev->pciioint);

  004cc	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  004d1	48 05 40 02 00
	00		 add	 rax, 576		; 00000240H
  004d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169753
  004de	48 8b c8	 mov	 rcx, rax
  004e1	e8 00 00 00 00	 call	 Dequeue_IO_Interrupt_QLocked

; 498  :     DEQUEUE_IO_INTERRUPT_QLOCKED(&dev->attnioint);

  004e6	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  004eb	48 05 58 02 00
	00		 add	 rax, 600		; 00000258H
  004f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169754
  004f8	48 8b c8	 mov	 rcx, rax
  004fb	e8 00 00 00 00	 call	 Dequeue_IO_Interrupt_QLocked

; 499  :     release_lock(&sysblk.iointqlk);

  00500	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00507	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  0050d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169755
  00514	48 8b c8	 mov	 rcx, rax
  00517	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 500  :     dev->busy = 0;

  0051d	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  00522	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00528	0f ba f0 13	 btr	 eax, 19
  0052c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dev$[rsp]
  00531	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 501  :     dev->scsw.flag2 = 0;

  00537	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  0053c	c6 80 0a 03 00
	00 00		 mov	 BYTE PTR [rax+778], 0

; 502  :     dev->scsw.flag3 = 0;

  00543	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  00548	c6 80 0b 03 00
	00 00		 mov	 BYTE PTR [rax+779], 0

; 503  : 
; 504  :     /* Check that load completed normally */
; 505  :     unitstat = dev->scsw.unitstat;

  0054f	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  00554	0f b6 80 10 03
	00 00		 movzx	 eax, BYTE PTR [rax+784]
  0055b	88 44 24 51	 mov	 BYTE PTR unitstat$[rsp], al

; 506  :     chanstat = dev->scsw.chanstat;

  0055f	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  00564	0f b6 80 11 03
	00 00		 movzx	 eax, BYTE PTR [rax+785]
  0056b	88 44 24 50	 mov	 BYTE PTR chanstat$[rsp], al

; 507  : 
; 508  :     if (unitstat != (CSW_CE | CSW_DE) || chanstat != 0)

  0056f	0f b6 44 24 51	 movzx	 eax, BYTE PTR unitstat$[rsp]
  00574	83 f8 0c	 cmp	 eax, 12
  00577	75 0d		 jne	 SHORT $LN13@s370_load_
  00579	0f b6 44 24 50	 movzx	 eax, BYTE PTR chanstat$[rsp]
  0057e	85 c0		 test	 eax, eax
  00580	0f 84 db 01 00
	00		 je	 $LN12@s370_load_
$LN13@s370_load_:

; 509  :     {
; 510  :         char buf[80];
; 511  :         char buf2[16];
; 512  : 
; 513  :         memset(buf,0,sizeof(buf));

  00586	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR buf$2[rsp]
  0058e	48 8b f8	 mov	 rdi, rax
  00591	33 c0		 xor	 eax, eax
  00593	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00598	f3 aa		 rep stosb

; 514  :         for (i=0; i < (int)dev->numsense; i++)

  0059a	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  005a2	eb 0a		 jmp	 SHORT $LN7@s370_load_
$LN5@s370_load_:
  005a4	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  005a8	ff c0		 inc	 eax
  005aa	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN7@s370_load_:
  005ae	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  005b3	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  005b9	39 44 24 54	 cmp	 DWORD PTR i$[rsp], eax
  005bd	7d 77		 jge	 SHORT $LN6@s370_load_

; 515  :         {
; 516  :             MSGBUF(buf2, "%2.2X", dev->sense[i]);

  005bf	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$[rsp]
  005c4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dev$[rsp]
  005c9	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  005d1	44 8b c8	 mov	 r9d, eax
  005d4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169758
  005db	ba 10 00 00 00	 mov	 edx, 16
  005e0	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR buf2$1[rsp]
  005e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 517  :             STRLCAT( buf, buf2 );

  005ee	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  005f4	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR buf2$1[rsp]
  005fc	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  00604	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 518  :             if ((i & 3) == 3) STRLCAT( buf, " " );

  0060a	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  0060e	83 e0 03	 and	 eax, 3
  00611	83 f8 03	 cmp	 eax, 3
  00614	75 1b		 jne	 SHORT $LN14@s370_load_
  00616	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  0061c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169760
  00623	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  0062b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN14@s370_load_:

; 519  :         }

  00631	e9 6e ff ff ff	 jmp	 $LN5@s370_load_
$LN6@s370_load_:

; 520  :         {
; 521  :             char buffer[256];
; 522  :             MSGBUF(buffer, "architecture mode %s, csw status %2.2X%2.2X, sense %s",

  00636	0f b6 44 24 50	 movzx	 eax, BYTE PTR chanstat$[rsp]
  0063b	89 44 24 6c	 mov	 DWORD PTR tv304[rsp], eax
  0063f	0f b6 4c 24 51	 movzx	 ecx, BYTE PTR unitstat$[rsp]
  00644	89 4c 24 70	 mov	 DWORD PTR tv306[rsp], ecx
  00648	33 c9		 xor	 ecx, ecx
  0064a	e8 00 00 00 00	 call	 get_arch_name
  0064f	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  00657	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0065c	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv304[rsp]
  00660	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  00664	8b 4c 24 70	 mov	 ecx, DWORD PTR tv306[rsp]
  00668	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0066c	4c 8b c8	 mov	 r9, rax
  0066f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169761
  00676	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0067b	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR buffer$5[rsp]
  00683	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 523  :                 get_arch_name( NULL ),
; 524  :                 unitstat, chanstat, buf);
; 525  :             WRMSG (HHC00828, "E", PTYPSTR(sysblk.pcpu), sysblk.pcpu, buffer);

  00689	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00690	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00697	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0069e	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  006a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  006ac	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv316[rsp], rax
  006b4	b9 01 00 00 00	 mov	 ecx, 1
  006b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006bf	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR buffer$5[rsp]
  006c7	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  006cc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006d3	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  006d9	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006dd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv316[rsp]
  006e5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  006ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169762
  006f1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169763
  006fd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00702	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00707	41 b9 03 00 00
	00		 mov	 r9d, 3
  0070d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169764
  00714	ba 0d 02 00 00	 mov	 edx, 525		; 0000020dH
  00719	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169765
  00720	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 526  :         }
; 527  : 
; 528  :         /* HercGUI hook so it can update its LEDs */
; 529  :         HDC1( debug_cpu_state, regs );

  00726	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  0072d	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00731	74 18		 je	 SHORT $LN20@s370_load_
  00733	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00738	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  0073f	ff 10		 call	 QWORD PTR [rax]
  00741	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv336[rsp], rax
  00749	eb 0c		 jmp	 SHORT $LN21@s370_load_
$LN20@s370_load_:
  0074b	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv336[rsp], 0
$LN21@s370_load_:

; 530  : 
; 531  :         return -1;

  00757	b8 ff ff ff ff	 mov	 eax, -1
  0075c	e9 dd 00 00 00	 jmp	 $LN1@s370_load_
$LN12@s370_load_:

; 532  :     }
; 533  : 
; 534  : #ifdef FEATURE_S370_CHANNEL
; 535  :     /* Test the EC mode bit in the IPL PSW */
; 536  :     if (regs->psa->iplpsw[1] & 0x08) {

  00761	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00766	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  0076d	b9 01 00 00 00	 mov	 ecx, 1
  00772	48 6b c9 01	 imul	 rcx, rcx, 1
  00776	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0077a	83 e0 08	 and	 eax, 8
  0077d	85 c0		 test	 eax, eax
  0077f	74 2c		 je	 SHORT $LN15@s370_load_

; 537  :         /* In EC mode, store device address at locations 184-187 */
; 538  :         STORE_FW(regs->psa->ioid, dev->devnum);

  00781	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  00786	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0078a	8b c8		 mov	 ecx, eax
  0078c	e8 00 00 00 00	 call	 _byteswap_ulong
  00791	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00796	48 8b 89 60 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2144]
  0079d	48 81 c1 b8 00
	00 00		 add	 rcx, 184		; 000000b8H
  007a4	8b d0		 mov	 edx, eax
  007a6	e8 00 00 00 00	 call	 store_fw_noswap

; 539  :     } else {

  007ab	eb 26		 jmp	 SHORT $LN16@s370_load_
$LN15@s370_load_:

; 540  :         /* In BC mode, store device address at locations 2-3 */
; 541  :         STORE_HW(regs->psa->iplpsw + 2, dev->devnum);

  007ad	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  007b2	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  007b6	e8 00 00 00 00	 call	 _byteswap_ushort
  007bb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  007c0	48 8b 89 60 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2144]
  007c7	48 83 c1 02	 add	 rcx, 2
  007cb	0f b7 d0	 movzx	 edx, ax
  007ce	e8 00 00 00 00	 call	 store_hw_noswap
$LN16@s370_load_:

; 542  :     }
; 543  : #endif /*FEATURE_S370_CHANNEL*/
; 544  : 
; 545  : #ifdef FEATURE_CHANNEL_SUBSYSTEM
; 546  :     /* Set LPUM */
; 547  :     dev->pmcw.lpum = 0x80;
; 548  :     STORE_FW(regs->psa->ioid, (dev->ssid<<16)|dev->subchan);
; 549  : 
; 550  :     /* Store zeroes at locations 188-191 */
; 551  :     memset (regs->psa->ioparm, 0, 4);
; 552  : #endif /*FEATURE_CHANNEL_SUBSYSTEM*/
; 553  : 
; 554  :     /* Save IPL device number, cpu number and lcss */
; 555  :     sysblk.ipldev = devnum;

  007d3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007da	0f b7 8c 24 c8
	02 00 00	 movzx	 ecx, WORD PTR devnum$[rsp]
  007e2	66 89 88 f2 00
	00 00		 mov	 WORD PTR [rax+242], cx

; 556  :     sysblk.iplcpu = regs->cpuad;

  007e9	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  007ee	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  007f5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  007fc	89 81 f4 00 00
	00		 mov	 DWORD PTR [rcx+244], eax

; 557  :     sysblk.ipllcss = lcss;

  00802	0f b7 84 24 c0
	02 00 00	 movzx	 eax, WORD PTR lcss$[rsp]
  0080a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00811	89 81 f8 00 00
	00		 mov	 DWORD PTR [rcx+248], eax

; 558  :     sysblk.ipled = TRUE;

  00817	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0081e	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00824	83 c8 02	 or	 eax, 2
  00827	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0082e	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 559  : 
; 560  :     /* Finish up... */
; 561  :     return ARCH_DEP(common_load_finish) (regs);

  00834	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00839	e8 00 00 00 00	 call	 s370_common_load_finish
$LN1@s370_load_:

; 562  : } /* end function load_ipl */

  0083e	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00846	48 33 cc	 xor	 rcx, rsp
  00849	e8 00 00 00 00	 call	 __security_check_cookie
  0084e	48 81 c4 b0 02
	00 00		 add	 rsp, 688		; 000002b0H
  00855	5f		 pop	 rdi
  00856	c3		 ret	 0
s370_load_ipl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ipl.c
_TEXT	SEGMENT
rc$ = 32
tv65 = 36
p$1 = 40
lcss$ = 64
devnum$ = 72
cpu$ = 80
clear$ = 88
load_ipl PROC

; 834  : {

$LN12:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000f	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 835  :     int rc = 0;

  00018	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 836  : 
; 837  :     switch ( sysblk.arch_mode )

  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00027	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0002d	89 44 24 24	 mov	 DWORD PTR tv65[rsp], eax
  00031	83 7c 24 24 00	 cmp	 DWORD PTR tv65[rsp], 0
  00036	74 10		 je	 SHORT $LN7@load_ipl
  00038	83 7c 24 24 01	 cmp	 DWORD PTR tv65[rsp], 1
  0003d	74 28		 je	 SHORT $LN8@load_ipl
  0003f	83 7c 24 24 02	 cmp	 DWORD PTR tv65[rsp], 2
  00044	74 40		 je	 SHORT $LN9@load_ipl
  00046	eb 5d		 jmp	 SHORT $LN10@load_ipl
$LN7@load_ipl:

; 838  :     {
; 839  : #if defined(_370)
; 840  :         case ARCH_370_IDX: rc = s370_load_ipl( lcss, devnum, cpu, clear ); break;

  00048	44 8b 4c 24 58	 mov	 r9d, DWORD PTR clear$[rsp]
  0004d	44 8b 44 24 50	 mov	 r8d, DWORD PTR cpu$[rsp]
  00052	0f b7 54 24 48	 movzx	 edx, WORD PTR devnum$[rsp]
  00057	0f b7 4c 24 40	 movzx	 ecx, WORD PTR lcss$[rsp]
  0005c	e8 00 00 00 00	 call	 s370_load_ipl
  00061	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
  00065	eb 55		 jmp	 SHORT $LN2@load_ipl
$LN8@load_ipl:

; 841  : #endif
; 842  : #if defined(_390)
; 843  :         case ARCH_390_IDX: rc = s390_load_ipl( lcss, devnum, cpu, clear ); break;

  00067	44 8b 4c 24 58	 mov	 r9d, DWORD PTR clear$[rsp]
  0006c	44 8b 44 24 50	 mov	 r8d, DWORD PTR cpu$[rsp]
  00071	0f b7 54 24 48	 movzx	 edx, WORD PTR devnum$[rsp]
  00076	0f b7 4c 24 40	 movzx	 ecx, WORD PTR lcss$[rsp]
  0007b	e8 00 00 00 00	 call	 s390_load_ipl
  00080	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
  00084	eb 36		 jmp	 SHORT $LN2@load_ipl
$LN9@load_ipl:

; 844  : #endif
; 845  : #if defined(_900)
; 846  :         /* NOTE: z/Arch always starts out in ESA390 mode */
; 847  :         case ARCH_900_IDX: rc = s390_load_ipl( lcss, devnum, cpu, clear ); break;

  00086	44 8b 4c 24 58	 mov	 r9d, DWORD PTR clear$[rsp]
  0008b	44 8b 44 24 50	 mov	 r8d, DWORD PTR cpu$[rsp]
  00090	0f b7 54 24 48	 movzx	 edx, WORD PTR devnum$[rsp]
  00095	0f b7 4c 24 40	 movzx	 ecx, WORD PTR lcss$[rsp]
  0009a	e8 00 00 00 00	 call	 s390_load_ipl
  0009f	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
  000a3	eb 17		 jmp	 SHORT $LN2@load_ipl
$LN10@load_ipl:
$LN6@load_ipl:

; 848  : #endif
; 849  :         default: CRASH();

  000a5	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  000ae	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  000b3	c6 00 00	 mov	 BYTE PTR [rax], 0
  000b6	33 c0		 xor	 eax, eax
  000b8	85 c0		 test	 eax, eax
  000ba	75 e9		 jne	 SHORT $LN6@load_ipl
$LN2@load_ipl:

; 850  :     }
; 851  : 
; 852  :     return rc;

  000bc	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 853  : }

  000c0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c4	c3		 ret	 0
load_ipl ENDP
_TEXT	ENDS
END
