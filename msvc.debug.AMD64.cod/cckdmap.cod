; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	pgm
PUBLIC	spacetab
PUBLIC	filesize
PUBLIC	total_unknown
PUBLIC	L2_lower_pos
PUBLIC	hdrerr
PUBLIC	numspace
PUBLIC	num_L1tab
PUBLIC	num_act_L2tab
PUBLIC	cckd64
PUBLIC	swaps_needed
PUBLIC	fba
PUBLIC	shadow
PUBLIC	data
PUBLIC	verbose
PUBLIC	overlap
PUBLIC	new_format
PUBLIC	info_only
PUBLIC	freeblk32
PUBLIC	freeblk
PUBLIC	cdevhdr32
PUBLIC	L1tab32
PUBLIC	L2tab32
PUBLIC	cdevhdr
PUBLIC	L1tab
PUBLIC	L2tab
_BSS	SEGMENT
pgm	DQ	01H DUP (?)
spacetab DQ	01H DUP (?)
filesize DQ	01H DUP (?)
total_unknown DQ 01H DUP (?)
L2_lower_pos DQ	01H DUP (?)
hdrerr	DD	01H DUP (?)
numspace DD	01H DUP (?)
num_L1tab DD	01H DUP (?)
num_act_L2tab DD 01H DUP (?)
cckd64	DB	01H DUP (?)
	ALIGN	4

swaps_needed DB	01H DUP (?)
	ALIGN	4

fba	DB	01H DUP (?)
	ALIGN	4

shadow	DB	01H DUP (?)
	ALIGN	4

data	DB	01H DUP (?)
	ALIGN	4

verbose	DB	01H DUP (?)
	ALIGN	4

overlap	DB	01H DUP (?)
	ALIGN	4

new_format DB	01H DUP (?)
	ALIGN	4

info_only DB	01H DUP (?)
	ALIGN	8

freeblk32 DQ	01H DUP (?)
freeblk	DB	010H DUP (?)
cdevhdr32 DB	0200H DUP (?)
L1tab32	DQ	01H DUP (?)
L2tab32	DQ	0100H DUP (?)
cdevhdr	DB	0200H DUP (?)
L1tab	DQ	01H DUP (?)
L2tab	DB	01000H DUP (?)
_BSS	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
VOL1_KEYA DB	056H
	DB	04fH
	DB	04cH
	DB	031H
VOL1_KEY DB	0e5H
	DB	0d6H
	DB	0d3H
	DB	0f1H
IPL1_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f1H
IPL2_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f2H
iplpsw	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
iplccw1	DB	06H
	DB	00H
	DB	03aH
	DB	098H
	DB	060H
	DB	00H
	DB	00H
	DB	060H
iplccw2	DB	08H
	DB	00H
	DB	03aH
	DB	098H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
noiplpsw DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0fH
noiplccw1 DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
noiplccw2 DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
ipl2data DB	07H
	DB	00H
	DB	03aH
	DB	0b8H
	DB	040H
	DB	00H
	DB	00H
	DB	06H
	DB	031H
	DB	00H
	DB	03aH
	DB	0beH
	DB	040H
	DB	00H
	DB	00H
	DB	05H
	DB	08H
	DB	00H
	DB	03aH
	DB	0a0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	06H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	00H
	DB	07fH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	04H
CONST	ENDS
PUBLIC	fetch_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	main
PUBLIC	__real@4130000000000000
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp__errno:PROC
EXTRN	memmove:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_realloc:PROC
EXTRN	__imp_qsort:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	__imp__lseeki64:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp_read:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fmt_S64:PROC
EXTRN	__imp_initialize_utility:PROC
EXTRN	__imp_rtrim:PROC
EXTRN	__imp_are_big_endian:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_hopen:PROC
EXTRN	__imp_dasd_lookup:PROC
EXTRN	__imp_spc_typ_to_str:PROC
EXTRN	__imp_cckd64_swapend_chdr:PROC
EXTRN	__imp_cckd64_swapend_l1:PROC
EXTRN	__imp_cckd64_swapend_l2:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_dh_devid_str:PROC
EXTRN	__imp_dh_devid_typ:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_BSS	SEGMENT
$SG169127 DB	01H DUP (?)
	ALIGN	4

$SG169138 DB	01H DUP (?)
	ALIGN	4

$SG169153 DB	01H DUP (?)
	ALIGN	4

$SG169174 DB	01H DUP (?)
	ALIGN	4

$SG169380 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$syntax DD imagerel syntax
	DD	imagerel syntax+97
	DD	imagerel $unwind$syntax
$pdata$cdevhdr_to_64 DD imagerel cdevhdr_to_64
	DD	imagerel cdevhdr_to_64+229
	DD	imagerel $unwind$cdevhdr_to_64
$pdata$L1tab_to_64 DD imagerel L1tab_to_64
	DD	imagerel L1tab_to_64+133
	DD	imagerel $unwind$L1tab_to_64
$pdata$L2tab_to_64 DD imagerel L2tab_to_64
	DD	imagerel L2tab_to_64+208
	DD	imagerel $unwind$L2tab_to_64
$pdata$are_swaps_needed DD imagerel are_swaps_needed
	DD	imagerel are_swaps_needed+142
	DD	imagerel $unwind$are_swaps_needed
$pdata$add_spc_to_table DD imagerel add_spc_to_table
	DD	imagerel add_spc_to_table+122
	DD	imagerel $unwind$add_spc_to_table
$pdata$del_spc_from_table DD imagerel del_spc_from_table
	DD	imagerel del_spc_from_table+121
	DD	imagerel $unwind$del_spc_from_table
$pdata$sort_spacetab_by_file_offset DD imagerel sort_spacetab_by_file_offset
	DD	imagerel sort_spacetab_by_file_offset+253
	DD	imagerel $unwind$sort_spacetab_by_file_offset
$pdata$dev_gc_state DD imagerel dev_gc_state
	DD	imagerel dev_gc_state+284
	DD	imagerel $unwind$dev_gc_state
$pdata$main DD	imagerel $LN298
	DD	imagerel $LN298+18766
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT __real@4130000000000000
CONST	SEGMENT
__real@4130000000000000 DQ 04130000000000000r	; 1.04858e+06
CONST	ENDS
_DATA	SEGMENT
$SG168671 DB	'I', 00H
	ORG $+14
$SG168672 DB	'HHC03000%s Usage: %s [ -i | -t | -v ] infile', 0aH, 'HHC'
	DB	'03000I   infile   Input file', 0aH, 'HHC03000I options:', 0aH
	DB	'HHC03000I   -i       report summary information only', 0aH, 'H'
	DB	'HC03000I   -t       report consolidated track data', 0aH, 'HH'
	DB	'C03000I   -v       verbose (report detailed track data)', 0aH
	DB	00H
$SG168673 DB	'syntax', 00H
	ORG $+1
$SG168950 DB	'-i', 00H
	ORG $+1
$SG168674 DB	'cckdmap.c', 00H
	ORG $+2
$SG168951 DB	'--info', 00H
	ORG $+1
$SG168955 DB	'-t', 00H
	ORG $+1
$SG168944 DB	'Compressed dasd file map', 00H
	ORG $+3
$SG168960 DB	'-v', 00H
	ORG $+1
$SG168945 DB	'cckdmap', 00H
$SG168956 DB	'--tracks', 00H
	ORG $+3
$SG168962 DB	'E', 00H
	ORG $+2
$SG168961 DB	'--verbose', 00H
	ORG $+2
$SG168967 DB	'E', 00H
	ORG $+2
$SG168963 DB	'HHC03001%s Unrecognized option: %s', 0aH, 00H
$SG168964 DB	'main', 00H
	ORG $+3
$SG168972 DB	'E', 00H
	ORG $+2
$SG168965 DB	'cckdmap.c', 00H
	ORG $+2
$SG168976 DB	'I', 00H
	ORG $+2
$SG168968 DB	'HHC03002%s Missing input-file specification', 0aH, 00H
	ORG $+3
$SG168969 DB	'main', 00H
	ORG $+3
$SG168970 DB	'cckdmap.c', 00H
	ORG $+2
$SG168980 DB	'I', 00H
	ORG $+2
$SG168973 DB	'HHC03003%s Extraneous parameter: %s', 0aH, 00H
	ORG $+3
$SG168974 DB	'main', 00H
	ORG $+3
$SG168975 DB	'cckdmap.c', 00H
	ORG $+2
$SG168985 DB	'open()', 00H
	ORG $+1
$SG168986 DB	'E', 00H
	ORG $+2
$SG168977 DB	'HHC03020%s ', 0aH, 00H
	ORG $+3
$SG168978 DB	'main', 00H
	ORG $+3
$SG168979 DB	'cckdmap.c', 00H
	ORG $+2
$SG168992 DB	'E', 00H
	ORG $+2
$SG168981 DB	'HHC03021%s %s of:     "%s"', 0aH, 00H
$SG168982 DB	'main', 00H
	ORG $+3
$SG168996 DB	'I', 00H
	ORG $+2
$SG168983 DB	'cckdmap.c', 00H
	ORG $+2
$SG169002 DB	'E', 00H
	ORG $+2
$SG168987 DB	'HHC03006%s %s error: %s', 0aH, 00H
	ORG $+3
$SG168988 DB	'main', 00H
	ORG $+3
$SG169007 DB	'read()', 00H
	ORG $+1
$SG169008 DB	'E', 00H
	ORG $+2
$SG168989 DB	'cckdmap.c', 00H
	ORG $+2
$SG169013 DB	'E', 00H
	ORG $+2
$SG168991 DB	'lseek()', 00H
$SG168993 DB	'HHC03006%s %s error: %s', 0aH, 00H
	ORG $+3
$SG168994 DB	'main', 00H
	ORG $+3
$SG169024 DB	'E', 00H
	ORG $+2
$SG168995 DB	'cckdmap.c', 00H
	ORG $+2
$SG169029 DB	'read()', 00H
	ORG $+1
$SG169030 DB	'E', 00H
	ORG $+2
$SG168997 DB	'HHC03007%s File size:      (%s bytes)', 0aH, 00H
	ORG $+1
$SG168998 DB	'main', 00H
	ORG $+3
$SG168999 DB	'cckdmap.c', 00H
	ORG $+2
$SG169036 DB	'E', 00H
	ORG $+2
$SG169001 DB	'lseek()', 00H
$SG169003 DB	'HHC03006%s %s error: %s', 0aH, 00H
	ORG $+3
$SG169004 DB	'main', 00H
	ORG $+3
$SG169041 DB	'read()', 00H
	ORG $+1
$SG169042 DB	'E', 00H
	ORG $+2
$SG169005 DB	'cckdmap.c', 00H
	ORG $+2
$SG169052 DB	'E', 00H
	ORG $+2
$SG169009 DB	'HHC03006%s %s error: %s', 0aH, 00H
	ORG $+3
$SG169010 DB	'main', 00H
	ORG $+3
$SG169057 DB	'E', 00H
	ORG $+2
$SG169011 DB	'cckdmap.c', 00H
	ORG $+2
$SG169064 DB	'E', 00H
	ORG $+2
$SG169014 DB	'HHC03004%s Unsupported dasd image file format', 0aH, 00H
	ORG $+1
$SG169015 DB	'main', 00H
	ORG $+3
$SG169016 DB	'cckdmap.c', 00H
	ORG $+2
$SG169071 DB	'read()', 00H
	ORG $+1
$SG169072 DB	'E', 00H
	ORG $+2
$SG169023 DB	'lseek()', 00H
$SG169025 DB	'HHC03006%s %s error: %s', 0aH, 00H
	ORG $+3
$SG169026 DB	'main', 00H
	ORG $+3
$SG169079 DB	'read()', 00H
	ORG $+1
$SG169080 DB	'E', 00H
	ORG $+2
$SG169027 DB	'cckdmap.c', 00H
	ORG $+2
$SG169090 DB	'E', 00H
	ORG $+2
$SG169031 DB	'HHC03006%s %s error: %s', 0aH, 00H
	ORG $+3
$SG169032 DB	'main', 00H
	ORG $+3
$SG169095 DB	'read()', 00H
	ORG $+1
$SG169096 DB	'E', 00H
	ORG $+2
$SG169033 DB	'cckdmap.c', 00H
	ORG $+2
$SG169104 DB	'E', 00H
	ORG $+2
$SG169035 DB	'lseek()', 00H
$SG169037 DB	'HHC03006%s %s error: %s', 0aH, 00H
	ORG $+3
$SG169038 DB	'main', 00H
	ORG $+3
$SG169111 DB	'read()', 00H
	ORG $+1
$SG169112 DB	'E', 00H
	ORG $+2
$SG169039 DB	'cckdmap.c', 00H
	ORG $+2
$SG169117 DB	'read()', 00H
	ORG $+1
$SG169118 DB	'E', 00H
	ORG $+2
$SG169043 DB	'HHC03006%s %s error: %s', 0aH, 00H
	ORG $+3
$SG169044 DB	'main', 00H
	ORG $+3
$SG169126 DB	'64', 00H
	ORG $+1
$SG169045 DB	'cckdmap.c', 00H
	ORG $+2
$SG169128 DB	'FBA', 00H
$SG169053 DB	'HHC03005%s Device type %4.4X not found in dasd table', 0aH
	DB	00H
	ORG $+2
$SG169054 DB	'main', 00H
	ORG $+3
$SG169055 DB	'cckdmap.c', 00H
	ORG $+2
$SG169129 DB	'64', 00H
	ORG $+1
$SG169058 DB	'HHC03005%s Device type %4.4X not found in dasd table', 0aH
	DB	00H
	ORG $+2
$SG169059 DB	'main', 00H
	ORG $+3
$SG169060 DB	'cckdmap.c', 00H
	ORG $+2
$SG169130 DB	'32', 00H
	ORG $+1
$SG169063 DB	'lseek()', 00H
$SG169065 DB	'HHC03006%s %s error: %s', 0aH, 00H
	ORG $+3
$SG169066 DB	'main', 00H
	ORG $+3
$SG169131 DB	'I', 00H
	ORG $+2
$SG169067 DB	'cckdmap.c', 00H
	ORG $+2
$SG169137 DB	'64', 00H
	ORG $+1
$SG169073 DB	'HHC03006%s %s error: %s', 0aH, 00H
	ORG $+3
$SG169074 DB	'main', 00H
	ORG $+3
$SG169139 DB	'CKD', 00H
$SG169075 DB	'cckdmap.c', 00H
	ORG $+2
$SG169140 DB	'64', 00H
	ORG $+1
$SG169077 DB	'FREE_BLK', 00H
	ORG $+3
$SG169141 DB	'32', 00H
	ORG $+1
$SG169081 DB	'HHC03006%s %s error: %s', 0aH, 00H
	ORG $+3
$SG169082 DB	'main', 00H
	ORG $+3
$SG169142 DB	'I', 00H
	ORG $+2
$SG169083 DB	'cckdmap.c', 00H
	ORG $+2
$SG169150 DB	'low', 00H
$SG169085 DB	'FREE_BLK', 00H
	ORG $+3
$SG169151 DB	'medium', 00H
	ORG $+1
$SG169154 DB	' ', 00H
	ORG $+2
$SG169089 DB	'lseek()', 00H
$SG169091 DB	'HHC03006%s %s error: %s', 0aH, 00H
	ORG $+3
$SG169092 DB	'main', 00H
	ORG $+3
$SG169157 DB	'bzip2', 00H
	ORG $+2
$SG169162 DB	'???', 00H
$SG169093 DB	'cckdmap.c', 00H
	ORG $+2
$SG169163 DB	'NEW', 00H
$SG169097 DB	'HHC03006%s %s error: %s', 0aH, 00H
	ORG $+3
$SG169098 DB	'main', 00H
	ORG $+3
$SG169160 DB	'ha r0', 00H
	ORG $+2
$SG169164 DB	'old', 00H
$SG169099 DB	'cckdmap.c', 00H
	ORG $+2
$SG169165 DB	'I', 00H
	ORG $+2
$SG169103 DB	'lseek()', 00H
$SG169105 DB	'HHC03006%s %s error: %s', 0aH, 00H
	ORG $+3
$SG169106 DB	'main', 00H
	ORG $+3
$SG169161 DB	'linux', 00H
	ORG $+2
$SG169171 DB	'low', 00H
$SG169107 DB	'cckdmap.c', 00H
	ORG $+2
$SG169172 DB	'medium', 00H
	ORG $+1
$SG169175 DB	' ', 00H
	ORG $+2
$SG169113 DB	'HHC03006%s %s error: %s', 0aH, 00H
	ORG $+3
$SG169114 DB	'main', 00H
	ORG $+3
$SG169178 DB	'bzip2', 00H
	ORG $+2
$SG169183 DB	'???', 00H
$SG169115 DB	'cckdmap.c', 00H
	ORG $+2
$SG169184 DB	'NEW', 00H
$SG169119 DB	'HHC03006%s %s error: %s', 0aH, 00H
	ORG $+3
$SG169120 DB	'main', 00H
	ORG $+3
$SG169181 DB	'ha r0', 00H
	ORG $+2
$SG169185 DB	'old', 00H
$SG169121 DB	'cckdmap.c', 00H
	ORG $+2
$SG169186 DB	'I', 00H
	ORG $+2
$SG169124 DB	'shadow file', 00H
$SG169194 DB	'W', 00H
	ORG $+2
$SG169125 DB	'base image', 00H
	ORG $+1
$SG169133 DB	'main', 00H
	ORG $+7
$SG169132 DB	'HHC03048%s ', 0aH, 'HHC03048I   dh_devid:      %s       '
	DB	' (%s-bit C%s%s %s)', 0aH, 'HHC03048I   dh_heads:      %u     '
	DB	'    (total sectors)', 0aH, 'HHC03048I   dh_trksize:    %u    '
	DB	'         (sector size)', 0aH, 'HHC03048I   dh_devtyp:     0x%'
	DB	'2.2X            (%s)', 0aH, 'HHC03048I   dh_fileseq:    0x%2.'
	DB	'2X', 0aH, 'HHC03048I   dh_highcyl:    %u', 0aH, 'HHC03048I   '
	DB	'dh_serial:     %s', 0aH, 00H
$SG169198 DB	'W', 00H
	ORG $+2
$SG169134 DB	'cckdmap.c', 00H
	ORG $+2
$SG169202 DB	'I', 00H
	ORG $+2
$SG169135 DB	'shadow file', 00H
$SG169203 DB	'not', 00H
$SG169136 DB	'base image', 00H
	ORG $+1
$SG169144 DB	'main', 00H
	ORG $+7
$SG169143 DB	'HHC03022%s ', 0aH, 'HHC03022I   dh_devid:      %s       '
	DB	' (%s-bit C%s%s %s)', 0aH, 'HHC03022I   dh_heads:      %u', 0aH
	DB	'HHC03022I   dh_trksize:    %u', 0aH, 'HHC03022I   dh_devtyp: '
	DB	'    0x%2.2X            (%s)', 0aH, 'HHC03022I   dh_fileseq:  '
	DB	'  0x%2.2X', 0aH, 'HHC03022I   dh_highcyl:    %u', 0aH, 'HHC03'
	DB	'022I   dh_serial:     %s', 0aH, 00H
	ORG $+2
$SG169204 DB	'I', 00H
	ORG $+2
$SG169145 DB	'cckdmap.c', 00H
	ORG $+2
$SG169205 DB	'I', 00H
	ORG $+2
$SG169148 DB	'default', 00H
$SG169149 DB	'none', 00H
	ORG $+3
$SG169152 DB	'high', 00H
	ORG $+3
$SG169155 DB	'none', 00H
	ORG $+3
$SG169156 DB	'zlib', 00H
	ORG $+3
$SG169158 DB	'INVALID', 00H
$SG169159 DB	'ha r0 EOF', 00H
	ORG $+2
$SG169167 DB	'main', 00H
	ORG $+7
$SG169166 DB	'HHC03024%s ', 0aH, 'HHC03024I   cdh_vrm:       %u.%u.%u', 0aH
	DB	'HHC03024I   cdh_opts:      0x%2.2X', 0aH, 'HHC03024I   num_L1'
	DB	'tab:     %d', 0aH, 'HHC03024I   num_L2tab:     %d', 0aH, 'HHC'
	DB	'03024I   cdh_cyls:      %u           (%s blkgrps)', 0aH, 'HHC'
	DB	'03024I   cdh_size:      0x%10.10llX    (%*s bytes)', 0aH, 'HH'
	DB	'C03024I   cdh_used:      0x%10.10llX    (%*s bytes)', 0aH, 'H'
	DB	'HC03024I   free_off:      0x%10.10llX    (%s format)', 0aH, 'H'
	DB	'HC03024I   free_total:    0x%10.10llX    (%*s bytes)', 0aH, 'H'
	DB	'HC03024I   free_largest:  0x%10.10llX    (%*s bytes)', 0aH, 'H'
	DB	'HC03024I   free_num:      %lld', 0aH, 'HHC03024I   free_imbed'
	DB	':    %llu', 0aH, 'HHC03024I   cdh_nullfmt:   %u              '
	DB	' (%s)', 0aH, 'HHC03024I   cmp_algo:      %u               (%s'
	DB	')', 0aH, 'HHC03024I   cmp_parm:      %hd              %s(%s)', 0aH
	DB	00H
$SG169168 DB	'cckdmap.c', 00H
	ORG $+2
$SG169209 DB	'!', 00H
	ORG $+2
$SG169169 DB	'default', 00H
$SG169170 DB	'none', 00H
	ORG $+3
$SG169173 DB	'high', 00H
	ORG $+3
$SG169176 DB	'none', 00H
	ORG $+3
$SG169177 DB	'zlib', 00H
	ORG $+3
$SG169179 DB	'INVALID', 00H
$SG169180 DB	'ha r0 EOF', 00H
	ORG $+2
$SG169182 DB	'linux', 00H
	ORG $+6
$SG169187 DB	'HHC03023%s ', 0aH, 'HHC03023I   cdh_vrm:       %u.%u.%u', 0aH
	DB	'HHC03023I   cdh_opts:      0x%2.2X', 0aH, 'HHC03023I   num_L1'
	DB	'tab:     %d', 0aH, 'HHC03023I   num_L2tab:     %d', 0aH, 'HHC'
	DB	'03023I   cdh_cyls:      %u           (%s tracks)', 0aH, 'HHC0'
	DB	'3023I   cdh_size:      0x%10.10llX    (%*s bytes)', 0aH, 'HHC'
	DB	'03023I   cdh_used:      0x%10.10llX    (%*s bytes)', 0aH, 'HH'
	DB	'C03023I   free_off:      0x%10.10llX    (%s format)', 0aH, 'H'
	DB	'HC03023I   free_total:    0x%10.10llX    (%*s bytes)', 0aH, 'H'
	DB	'HC03023I   free_largest:  0x%10.10llX    (%*s bytes)', 0aH, 'H'
	DB	'HC03023I   free_num:      %lld', 0aH, 'HHC03023I   free_imbed'
	DB	':    %llu', 0aH, 'HHC03023I   cdh_nullfmt:   %u              '
	DB	' (%s)', 0aH, 'HHC03023I   cmp_algo:      %u               (%s'
	DB	')', 0aH, 'HHC03023I   cmp_parm:      %hd              %s(%s)', 0aH
	DB	00H
	ORG $+1
$SG169188 DB	'main', 00H
	ORG $+3
$SG169189 DB	'cckdmap.c', 00H
	ORG $+2
$SG169210 DB	'.', 00H
	ORG $+2
$SG169193 DB	'SEVERELY', 00H
	ORG $+3
$SG169215 DB	'I', 00H
	ORG $+2
$SG169197 DB	'moderately', 00H
	ORG $+1
$SG169219 DB	'W', 00H
	ORG $+2
$SG169201 DB	'slightly', 00H
	ORG $+3
$SG169225 DB	'E', 00H
	ORG $+2
$SG169206 DB	'HHC03020%s ', 0aH, 00H
	ORG $+3
$SG169207 DB	'main', 00H
	ORG $+3
$SG169208 DB	'cckdmap.c', 00H
	ORG $+2
$SG169233 DB	'E', 00H
	ORG $+2
$SG169211 DB	'HHC03050%s Image is %s fragmented%s', 0aH, 00H
	ORG $+3
$SG169212 DB	'main', 00H
	ORG $+3
$SG169213 DB	'cckdmap.c', 00H
	ORG $+2
$SG169238 DB	'read()', 00H
	ORG $+1
$SG169239 DB	'E', 00H
	ORG $+2
$SG169216 DB	'HHC03020%s ', 0aH, 00H
	ORG $+3
$SG169217 DB	'main', 00H
	ORG $+3
$SG169218 DB	'cckdmap.c', 00H
	ORG $+2
$SG169221 DB	'main', 00H
	ORG $+7
$SG169220 DB	'HHC03008%s Compressed device header inconsistency(s) fou'
	DB	'nd! code: %4.4X', 0aH, 00H
	ORG $+3
$SG169245 DB	'E', 00H
	ORG $+2
$SG169222 DB	'cckdmap.c', 00H
	ORG $+2
$SG169251 DB	'E', 00H
	ORG $+2
$SG169224 DB	'calloc()', 00H
	ORG $+3
$SG169256 DB	'read()', 00H
	ORG $+1
$SG169257 DB	'E', 00H
	ORG $+2
$SG169226 DB	'HHC03006%s %s error: %s', 0aH, 00H
	ORG $+3
$SG169227 DB	'main', 00H
	ORG $+3
$SG169266 DB	'E', 00H
	ORG $+2
$SG169228 DB	'cckdmap.c', 00H
	ORG $+2
$SG169273 DB	'read()', 00H
	ORG $+1
$SG169274 DB	'E', 00H
	ORG $+2
$SG169232 DB	'lseek()', 00H
$SG169234 DB	'HHC03006%s %s error: %s', 0aH, 00H
	ORG $+3
$SG169235 DB	'main', 00H
	ORG $+3
$SG169279 DB	'read()', 00H
	ORG $+1
$SG169280 DB	'E', 00H
	ORG $+2
$SG169236 DB	'cckdmap.c', 00H
	ORG $+2
$SG169295 DB	'I', 00H
	ORG $+2
$SG169240 DB	'HHC03006%s %s error: %s', 0aH, 00H
	ORG $+3
$SG169241 DB	'main', 00H
	ORG $+3
$SG169299 DB	'I', 00H
	ORG $+2
$SG169242 DB	'cckdmap.c', 00H
	ORG $+2
$SG169313 DB	'I', 00H
	ORG $+2
$SG169244 DB	'calloc()', 00H
	ORG $+3
$SG169317 DB	'I', 00H
	ORG $+2
$SG169246 DB	'HHC03006%s %s error: %s', 0aH, 00H
	ORG $+3
$SG169247 DB	'main', 00H
	ORG $+3
$SG169321 DB	'I', 00H
	ORG $+2
$SG169248 DB	'cckdmap.c', 00H
	ORG $+2
$SG169326 DB	'I', 00H
	ORG $+2
$SG169250 DB	'lseek()', 00H
$SG169252 DB	'HHC03006%s %s error: %s', 0aH, 00H
	ORG $+3
$SG169253 DB	'main', 00H
	ORG $+3
$SG169330 DB	'I', 00H
	ORG $+2
$SG169254 DB	'cckdmap.c', 00H
	ORG $+2
$SG169334 DB	'I', 00H
	ORG $+2
$SG169258 DB	'HHC03006%s %s error: %s', 0aH, 00H
	ORG $+3
$SG169259 DB	'main', 00H
	ORG $+3
$SG169341 DB	'I', 00H
	ORG $+2
$SG169260 DB	'cckdmap.c', 00H
	ORG $+2
$SG169345 DB	'I', 00H
	ORG $+2
$SG169265 DB	'lseek()', 00H
$SG169267 DB	'HHC03006%s %s error: %s', 0aH, 00H
	ORG $+3
$SG169268 DB	'main', 00H
	ORG $+3
$SG169349 DB	'I', 00H
	ORG $+2
$SG169269 DB	'cckdmap.c', 00H
	ORG $+2
$SG169353 DB	'I', 00H
	ORG $+2
$SG169275 DB	'HHC03006%s %s error: %s', 0aH, 00H
	ORG $+3
$SG169276 DB	'main', 00H
	ORG $+3
$SG169357 DB	'I', 00H
	ORG $+2
$SG169277 DB	'cckdmap.c', 00H
	ORG $+2
$SG169361 DB	'I', 00H
	ORG $+2
$SG169281 DB	'HHC03006%s %s error: %s', 0aH, 00H
	ORG $+3
$SG169282 DB	'main', 00H
	ORG $+3
$SG169368 DB	'I', 00H
	ORG $+2
$SG169283 DB	'cckdmap.c', 00H
	ORG $+2
$SG169379 DB	'!', 00H
	ORG $+2
$SG169296 DB	'HHC03020%s ', 0aH, 00H
	ORG $+3
$SG169297 DB	'main', 00H
	ORG $+3
$SG169298 DB	'cckdmap.c', 00H
	ORG $+2
$SG169382 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+1
$SG169383 DB	'I', 00H
	ORG $+2
$SG169300 DB	'HHC03049%s Total unknown space    = %s bytes', 0aH, 00H
	ORG $+2
$SG169301 DB	'main', 00H
	ORG $+3
$SG169302 DB	'cckdmap.c', 00H
	ORG $+2
$SG169387 DB	'I', 00H
	ORG $+2
$SG169314 DB	'HHC03020%s ', 0aH, 00H
	ORG $+3
$SG169315 DB	'main', 00H
	ORG $+3
$SG169316 DB	'cckdmap.c', 00H
	ORG $+6
$SG169318 DB	'HHC03045%s Total active blkgrps   = %u groups', 0aH, 00H
	ORG $+1
$SG169319 DB	'main', 00H
	ORG $+3
$SG169320 DB	'cckdmap.c', 00H
	ORG $+6
$SG169322 DB	'HHC03046%s Avg. L2-to-block seek  = %.3f MB', 0aH, 00H
	ORG $+3
$SG169323 DB	'main', 00H
	ORG $+3
$SG169324 DB	'cckdmap.c', 00H
	ORG $+6
$SG169327 DB	'HHC03020%s ', 0aH, 00H
	ORG $+3
$SG169328 DB	'main', 00H
	ORG $+3
$SG169329 DB	'cckdmap.c', 00H
	ORG $+6
$SG169331 DB	'HHC03043%s Total active tracks    = %u tracks', 0aH, 00H
	ORG $+1
$SG169332 DB	'main', 00H
	ORG $+3
$SG169333 DB	'cckdmap.c', 00H
	ORG $+6
$SG169335 DB	'HHC03044%s Avg. L2-to-track seek  = %.3f MB', 0aH, 00H
	ORG $+3
$SG169336 DB	'main', 00H
	ORG $+3
$SG169337 DB	'cckdmap.c', 00H
	ORG $+6
$SG169342 DB	'HHC03020%s ', 0aH, 00H
	ORG $+3
$SG169343 DB	'main', 00H
	ORG $+3
$SG169344 DB	'cckdmap.c', 00H
	ORG $+2
$SG169347 DB	'main', 00H
	ORG $+7
$SG169346 DB	'HHC03047%s          File offset    Size (hex)         Si'
	DB	'ze  group(s)', 0aH, 00H
	ORG $+2
$SG169348 DB	'cckdmap.c', 00H
	ORG $+6
$SG169350 DB	'HHC03020%s ', 0aH, 00H
	ORG $+3
$SG169351 DB	'main', 00H
	ORG $+3
$SG169352 DB	'cckdmap.c', 00H
	ORG $+6
$SG169354 DB	'HHC03020%s ', 0aH, 00H
	ORG $+3
$SG169355 DB	'main', 00H
	ORG $+3
$SG169356 DB	'cckdmap.c', 00H
	ORG $+2
$SG169359 DB	'main', 00H
	ORG $+7
$SG169358 DB	'HHC03040%s          File offset    Size (hex)         Si'
	DB	'ze  track(s)', 0aH, 00H
	ORG $+2
$SG169360 DB	'cckdmap.c', 00H
	ORG $+6
$SG169362 DB	'HHC03020%s ', 0aH, 00H
	ORG $+3
$SG169363 DB	'main', 00H
	ORG $+3
$SG169364 DB	'cckdmap.c', 00H
	ORG $+6
$SG169369 DB	'HHC03041%s *********************************************'
	DB	'**************', 0aH, 00H
$SG169370 DB	'main', 00H
	ORG $+3
$SG169371 DB	'cckdmap.c', 00H
	ORG $+6
$SG169376 DB	'  %d - %d', 00H
	ORG $+2
$SG169378 DB	'  %d', 00H
	ORG $+3
$SG169381 DB	'%s%s', 00H
	ORG $+7
$SG169384 DB	'HHC03042%s %-8s 0x%10.10llX  0x%10.10llX %11llu%s', 0aH, 00H
	ORG $+1
$SG169385 DB	'main', 00H
	ORG $+7
$SG169386 DB	'cckdmap.c', 00H
	ORG $+6
$SG169388 DB	'HHC03020%s ', 0aH, 00H
	ORG $+3
$SG169389 DB	'main', 00H
	ORG $+3
$SG169390 DB	'cckdmap.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:main
	DD	01cH
	DD	04934H
voltbl	ENDS
xdata	SEGMENT
$unwind$syntax DD 010401H
	DD	08204H
$unwind$cdevhdr_to_64 DD 020301H
	DD	060027003H
$unwind$L1tab_to_64 DD 010401H
	DD	04204H
$unwind$L2tab_to_64 DD 010401H
	DD	02204H
$unwind$are_swaps_needed DD 010901H
	DD	06209H
$unwind$add_spc_to_table DD 030b01H
	DD	07007620bH
	DD	06006H
$unwind$del_spc_from_table DD 010801H
	DD	06208H
$unwind$sort_spacetab_by_file_offset DD 010e01H
	DD	0220eH
$unwind$dev_gc_state DD 010401H
	DD	04204H
$unwind$main DD	042419H
	DD	01330112H
	DD	0600a700bH
	DD	imagerel __GSHandlerCheck
	DD	0980H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckdmap.c
_TEXT	SEGMENT
i$ = 304
k$ = 308
size$ = 312
fd$ = 316
rc$ = 320
size32$ = 324
curpos$ = 328
devtype$ = 336
L1track$ = 340
imgtyp$ = 344
cyls$ = 348
active_tracks$ = 352
gc$1 = 356
tracks$ = 360
len_largest$ = 368
len_total$ = 376
len_size$ = 384
len_used$ = 392
chainbytes$2 = 400
free_num$3 = 404
heads$ = 408
seek_total$ = 416
tv1309 = 424
tv1313 = 428
tv1317 = 432
tv1321 = 436
tv1325 = 440
tv1329 = 444
tv1333 = 448
tv1337 = 452
tv1341 = 456
tv1344 = 460
tv1566 = 464
tv1572 = 468
tv1656 = 472
tv1679 = 476
tv1701 = 480
tv1762 = 484
tv1779 = 488
tv2385 = 492
tv2387 = 496
tv479 = 500
tv695 = 504
tv707 = 508
trksize$ = 512
tv1027 = 516
tv1164 = 520
freechain$4 = 528
gc_str$5 = 536
sev$6 = 544
tv924 = 552
tv960 = 556
tv1023 = 560
tv1039 = 564
tv1051 = 568
tv1128 = 572
tv556 = 576
tv1160 = 580
tv1176 = 584
tv1220 = 588
tv1265 = 592
tv1269 = 596
tv574 = 600
tv882 = 604
tv1132 = 608
tv884 = 612
tv888 = 616
tv922 = 620
fbatab$ = 624
ckdtab$ = 632
file$ = 640
tv894 = 648
tv898 = 656
tv903 = 664
tv966 = 672
tv970 = 680
tv975 = 688
tv1014 = 696
tv1015 = 704
tv1016 = 712
tv1033 = 720
tv1035 = 728
tv1047 = 736
tv1048 = 744
tv1017 = 752
tv1021 = 760
tv1037 = 768
tv1049 = 776
tv1089 = 784
tv1095 = 792
tv1101 = 800
tv1106 = 808
tv1112 = 816
tv1151 = 824
tv1152 = 832
tv1153 = 840
tv1170 = 848
tv1172 = 856
tv1216 = 864
tv1217 = 872
tv1154 = 880
tv1158 = 888
tv1174 = 896
tv1218 = 904
tv1226 = 912
tv1232 = 920
tv1238 = 928
tv1243 = 936
tv1249 = 944
tv1295 = 952
$T7 = 960
tv2392 = 968
tv164 = 976
tv189 = 984
tv231 = 992
tv250 = 1000
tv314 = 1008
tv333 = 1016
tv374 = 1024
tv425 = 1032
tv444 = 1040
tv463 = 1048
tv591 = 1056
tv644 = 1064
tv670 = 1072
tv713 = 1080
tv732 = 1088
block$8 = 1096
block32$9 = 1104
tv811 = 1112
tv832 = 1120
tv851 = 1128
tv905 = 1136
tv977 = 1144
tv1412 = 1152
tv1433 = 1160
tv1452 = 1168
tv1474 = 1176
tv1493 = 1184
tv1544 = 1192
tv1596 = 1200
tv1617 = 1208
tv1636 = 1216
tv2112 = 1224
tv2149 = 1232
tv2389 = 1240
tv2408 = 1248
tv2413 = 1256
spc$ = 1264
devhdr$ = 1312
ser$ = 1824
track_range$ = 1840
str_total$ = 1872
str_size$ = 1936
space_type$ = 2000
str_largest$ = 2032
str_used$ = 2096
pathname$ = 2160
__$ArrayPad$ = 2432
argc$ = 2480
argv$ = 2488
main	PROC

; 253  : {

$LN298:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 98 09
	00 00		 sub	 rsp, 2456		; 00000998H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 80
	09 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 254  : char*           file;                   /* File name                 */
; 255  : char            pathname[MAX_PATH];     /* File path in host format  */
; 256  : 
; 257  : char            str_size    [64];       /* Work area for fmt_S64     */
; 258  : char            str_used    [64];       /* Work area for fmt_S64     */
; 259  : char            str_total   [64];       /* Work area for fmt_S64     */
; 260  : char            str_largest [64];       /* Work area for fmt_S64     */
; 261  : char            track_range [32];       /* Work area for fmt_S64     */
; 262  : char            space_type  [32];       /* spc_typ_to_str work area  */
; 263  : 
; 264  : off_t           curpos;                 /* Work: saved file position */
; 265  : 
; 266  : CKDDEV*         ckdtab     = NULL;      /* Device table entry        */

  00024	48 c7 84 24 78
	02 00 00 00 00
	00 00		 mov	 QWORD PTR ckdtab$[rsp], 0

; 267  : FBADEV*         fbatab     = NULL;      /* Device table entry        */

  00030	48 c7 84 24 70
	02 00 00 00 00
	00 00		 mov	 QWORD PTR fbatab$[rsp], 0

; 268  : 
; 269  : CKD_DEVHDR      devhdr     = {0};       /* CKD device header         */

  0003c	48 8d 84 24 20
	05 00 00	 lea	 rax, QWORD PTR devhdr$[rsp]
  00044	48 8b f8	 mov	 rdi, rax
  00047	33 c0		 xor	 eax, eax
  00049	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0004e	f3 aa		 rep stosb

; 270  : SPCTAB64        spc        = {0};       /* Space table entry         */

  00050	48 8d 84 24 f0
	04 00 00	 lea	 rax, QWORD PTR spc$[rsp]
  00058	48 8b f8	 mov	 rdi, rax
  0005b	33 c0		 xor	 eax, eax
  0005d	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00062	f3 aa		 rep stosb

; 271  : char            ser[12+1]  = {0};       /* Serial number             */

  00064	48 8d 84 24 20
	07 00 00	 lea	 rax, QWORD PTR ser$[rsp]
  0006c	48 8b f8	 mov	 rdi, rax
  0006f	33 c0		 xor	 eax, eax
  00071	b9 0d 00 00 00	 mov	 ecx, 13
  00076	f3 aa		 rep stosb

; 272  : 
; 273  : int             rc;                     /* Return code               */
; 274  : int             fd;                     /* File descriptor integer   */
; 275  : int             i, k;                   /* Loop variables            */
; 276  : int             tracks;                 /* Total tracks              */
; 277  : int             L1track;                /* L1 table track number     */
; 278  : size_t          len_size,  len_used;    /* Return value from fmt_S64 */
; 279  : size_t          len_total, len_largest; /* Return value from fmt_S64 */
; 280  : 
; 281  : U64             seek_total;             /* Distance from L2 to track */
; 282  : U32             active_tracks;          /* Total active tracks       */
; 283  : U32             cyls;                   /* Total cylinders           */
; 284  : U32             heads;                  /* Heads per cylinder        */
; 285  : U32             trksize;                /* Track size                */
; 286  : U32             imgtyp;                 /* Dasd image format         */
; 287  : U32             size32;                 /* Work: CCKD   I/O size     */
; 288  : U32             size;                   /* Work: CCKD64 I/O size     */
; 289  : U16             devtype;                /* Device type (e.g. 0x3390) */
; 290  : 
; 291  :     INITIALIZE_UTILITY( UTILITY_NAME, UTILITY_DESC, &pgm );

  00078	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:pgm
  0007f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00084	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168944
  0008b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168945
  00092	48 8b 94 24 b8
	09 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0009a	8b 8c 24 b0 09
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_initialize_utility
  000a7	89 84 24 b0 09
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 292  : 
; 293  :     /* Parse options */
; 294  :     for (argc--, argv++; argc > 0; argc--, argv++)

  000ae	8b 84 24 b0 09
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  000b5	ff c8		 dec	 eax
  000b7	89 84 24 b0 09
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  000be	48 8b 84 24 b8
	09 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  000c6	48 83 c0 08	 add	 rax, 8
  000ca	48 89 84 24 b8
	09 00 00	 mov	 QWORD PTR argv$[rsp], rax
  000d2	eb 24		 jmp	 SHORT $LN4@main
$LN2@main:
  000d4	8b 84 24 b0 09
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  000db	ff c8		 dec	 eax
  000dd	89 84 24 b0 09
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  000e4	48 8b 84 24 b8
	09 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  000ec	48 83 c0 08	 add	 rax, 8
  000f0	48 89 84 24 b8
	09 00 00	 mov	 QWORD PTR argv$[rsp], rax
$LN4@main:
  000f8	83 bc 24 b0 09
	00 00 00	 cmp	 DWORD PTR argc$[rsp], 0
  00100	0f 8e ed 01 00
	00		 jle	 $LN3@main

; 295  :     {
; 296  :         /* End of options? */
; 297  :         if (argv[0][0] != '-')

  00106	b8 08 00 00 00	 mov	 eax, 8
  0010b	48 6b c0 00	 imul	 rax, rax, 0
  0010f	b9 01 00 00 00	 mov	 ecx, 1
  00114	48 6b c9 00	 imul	 rcx, rcx, 0
  00118	48 8b 94 24 b8
	09 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00120	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00124	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00128	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0012b	74 05		 je	 SHORT $LN50@main

; 298  :             break;

  0012d	e9 c1 01 00 00	 jmp	 $LN3@main
$LN50@main:

; 299  : 
; 300  :         if (0
; 301  :             || strcasecmp( argv[0], "-i"     ) == 0
; 302  :             || strcasecmp( argv[0], "--info" ) == 0

  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	75 4c		 jne	 SHORT $LN53@main
  00138	b8 08 00 00 00	 mov	 eax, 8
  0013d	48 6b c0 00	 imul	 rax, rax, 0
  00141	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168950
  00148	48 8b 8c 24 b8
	09 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00150	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00154	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0015a	85 c0		 test	 eax, eax
  0015c	74 26		 je	 SHORT $LN53@main
  0015e	b8 08 00 00 00	 mov	 eax, 8
  00163	48 6b c0 00	 imul	 rax, rax, 0
  00167	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168951
  0016e	48 8b 8c 24 b8
	09 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00176	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0017a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00180	85 c0		 test	 eax, eax
  00182	75 1a		 jne	 SHORT $LN51@main
$LN53@main:

; 303  :         )
; 304  :         {
; 305  :             info_only = true;   /* Report only summary information */

  00184	c6 05 00 00 00
	00 01		 mov	 BYTE PTR info_only, 1

; 306  :             data      = false;

  0018b	c6 05 00 00 00
	00 00		 mov	 BYTE PTR data, 0

; 307  :             verbose   = false;

  00192	c6 05 00 00 00
	00 00		 mov	 BYTE PTR verbose, 0

; 308  :         }

  00199	e9 50 01 00 00	 jmp	 $LN52@main
$LN51@main:

; 309  :         else if (0
; 310  :             || strcasecmp( argv[0], "-t"       ) == 0
; 311  :             || strcasecmp( argv[0], "--tracks" ) == 0

  0019e	33 c0		 xor	 eax, eax
  001a0	85 c0		 test	 eax, eax
  001a2	75 4c		 jne	 SHORT $LN56@main
  001a4	b8 08 00 00 00	 mov	 eax, 8
  001a9	48 6b c0 00	 imul	 rax, rax, 0
  001ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168955
  001b4	48 8b 8c 24 b8
	09 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001bc	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  001c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  001c6	85 c0		 test	 eax, eax
  001c8	74 26		 je	 SHORT $LN56@main
  001ca	b8 08 00 00 00	 mov	 eax, 8
  001cf	48 6b c0 00	 imul	 rax, rax, 0
  001d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168956
  001da	48 8b 8c 24 b8
	09 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001e2	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  001e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  001ec	85 c0		 test	 eax, eax
  001ee	75 1a		 jne	 SHORT $LN54@main
$LN56@main:

; 312  :         )
; 313  :         {
; 314  :             info_only = false;

  001f0	c6 05 00 00 00
	00 00		 mov	 BYTE PTR info_only, 0

; 315  :             data      = true;   /* Consolidated tracks report */

  001f7	c6 05 00 00 00
	00 01		 mov	 BYTE PTR data, 1

; 316  :             verbose   = false;

  001fe	c6 05 00 00 00
	00 00		 mov	 BYTE PTR verbose, 0

; 317  :         }

  00205	e9 e4 00 00 00	 jmp	 $LN55@main
$LN54@main:

; 318  :         else if (0
; 319  :             || strcasecmp( argv[0], "-v"        ) == 0
; 320  :             || strcasecmp( argv[0], "--verbose" ) == 0

  0020a	33 c0		 xor	 eax, eax
  0020c	85 c0		 test	 eax, eax
  0020e	75 4c		 jne	 SHORT $LN59@main
  00210	b8 08 00 00 00	 mov	 eax, 8
  00215	48 6b c0 00	 imul	 rax, rax, 0
  00219	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168960
  00220	48 8b 8c 24 b8
	09 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00228	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0022c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00232	85 c0		 test	 eax, eax
  00234	74 26		 je	 SHORT $LN59@main
  00236	b8 08 00 00 00	 mov	 eax, 8
  0023b	48 6b c0 00	 imul	 rax, rax, 0
  0023f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168961
  00246	48 8b 8c 24 b8
	09 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0024e	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00252	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00258	85 c0		 test	 eax, eax
  0025a	75 17		 jne	 SHORT $LN57@main
$LN59@main:

; 321  :         )
; 322  :         {
; 323  :             info_only = false;

  0025c	c6 05 00 00 00
	00 00		 mov	 BYTE PTR info_only, 0

; 324  :             data      = false;

  00263	c6 05 00 00 00
	00 00		 mov	 BYTE PTR data, 0

; 325  :             verbose   = true;   /* Report detailed track info */

  0026a	c6 05 00 00 00
	00 01		 mov	 BYTE PTR verbose, 1

; 326  :         }

  00271	eb 7b		 jmp	 SHORT $LN58@main
$LN57@main:

; 327  :         else
; 328  :         {
; 329  :             // "Unrecognized option: %s"
; 330  :             FWRMSG( stderr, HHC03001, "E", argv[0] );

  00273	b8 08 00 00 00	 mov	 eax, 8
  00278	48 6b c0 00	 imul	 rax, rax, 0
  0027c	48 89 84 24 d0
	03 00 00	 mov	 QWORD PTR tv164[rsp], rax
  00284	b9 02 00 00 00	 mov	 ecx, 2
  00289	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0028f	48 8b 8c 24 b8
	09 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00297	48 8b 94 24 d0
	03 00 00	 mov	 rdx, QWORD PTR tv164[rsp]
  0029f	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  002a3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168962
  002af	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168963
  002bb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002c0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c5	41 b9 03 00 00
	00		 mov	 r9d, 3
  002cb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168964
  002d2	ba 4a 01 00 00	 mov	 edx, 330		; 0000014aH
  002d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168965
  002de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 331  :             return syntax();

  002e4	e8 00 00 00 00	 call	 syntax
  002e9	e9 46 46 00 00	 jmp	 $LN1@main
$LN58@main:
$LN55@main:
$LN52@main:

; 332  :         }
; 333  :     }

  002ee	e9 e1 fd ff ff	 jmp	 $LN2@main
$LN3@main:

; 334  : 
; 335  :     /* Parse arguments */
; 336  :     if (argc < 1)

  002f3	83 bc 24 b0 09
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  002fb	7d 51		 jge	 SHORT $LN60@main

; 337  :     {
; 338  :         // "Missing input-file specification"
; 339  :         FWRMSG( stderr, HHC03002, "E" );

  002fd	b9 02 00 00 00	 mov	 ecx, 2
  00302	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00308	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168967
  0030f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00314	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168968
  0031b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00320	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00325	41 b9 03 00 00
	00		 mov	 r9d, 3
  0032b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168969
  00332	ba 53 01 00 00	 mov	 edx, 339		; 00000153H
  00337	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168970
  0033e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 340  :         return syntax();

  00344	e8 00 00 00 00	 call	 syntax
  00349	e9 e6 45 00 00	 jmp	 $LN1@main
$LN60@main:

; 341  :     }
; 342  : 
; 343  :     if (argc > 1)

  0034e	83 bc 24 b0 09
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  00356	7e 7b		 jle	 SHORT $LN61@main

; 344  :     {
; 345  :         // "Extraneous parameter: %s"
; 346  :         FWRMSG( stderr, HHC03003, "E", argv[1] );

  00358	b8 08 00 00 00	 mov	 eax, 8
  0035d	48 6b c0 01	 imul	 rax, rax, 1
  00361	48 89 84 24 d8
	03 00 00	 mov	 QWORD PTR tv189[rsp], rax
  00369	b9 02 00 00 00	 mov	 ecx, 2
  0036e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00374	48 8b 8c 24 b8
	09 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0037c	48 8b 94 24 d8
	03 00 00	 mov	 rdx, QWORD PTR tv189[rsp]
  00384	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00388	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0038d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168972
  00394	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00399	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168973
  003a0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003a5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003aa	41 b9 03 00 00
	00		 mov	 r9d, 3
  003b0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168974
  003b7	ba 5a 01 00 00	 mov	 edx, 346		; 0000015aH
  003bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168975
  003c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 347  :         return syntax();

  003c9	e8 00 00 00 00	 call	 syntax
  003ce	e9 61 45 00 00	 jmp	 $LN1@main
$LN61@main:

; 348  :     }
; 349  : 
; 350  :     file = argv[0];

  003d3	b8 08 00 00 00	 mov	 eax, 8
  003d8	48 6b c0 00	 imul	 rax, rax, 0
  003dc	48 8b 8c 24 b8
	09 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  003e4	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  003e8	48 89 84 24 80
	02 00 00	 mov	 QWORD PTR file$[rsp], rax

; 351  : 
; 352  :     // ""
; 353  :     // "%s of:     \"%s\""
; 354  :     // ""
; 355  :     WRMSG( HHC03020, "I" );

  003f0	b9 01 00 00 00	 mov	 ecx, 1
  003f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168976
  00402	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00407	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168977
  0040e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00413	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00418	41 b9 03 00 00
	00		 mov	 r9d, 3
  0041e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168978
  00425	ba 63 01 00 00	 mov	 edx, 355		; 00000163H
  0042a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168979
  00431	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 356  :     WRMSG( HHC03021, "I", pgm, file );

  00437	b9 01 00 00 00	 mov	 ecx, 1
  0043c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00442	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  0044a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0044f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pgm
  00456	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0045b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168980
  00462	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00467	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168981
  0046e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00473	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00478	41 b9 03 00 00
	00		 mov	 r9d, 3
  0047e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168982
  00485	ba 64 01 00 00	 mov	 edx, 356		; 00000164H
  0048a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168983
  00491	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 357  : 
; 358  :     /* Open file and verify correct format */
; 359  :     hostpath( pathname, file, sizeof( pathname ));

  00497	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0049d	48 8b 94 24 80
	02 00 00	 mov	 rdx, QWORD PTR file$[rsp]
  004a5	48 8d 8c 24 70
	08 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  004ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 360  :     if ((fd = HOPEN( pathname, O_RDONLY | O_BINARY )) < 0)

  004b3	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  004b8	48 8d 8c 24 70
	08 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  004c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  004c6	89 84 24 3c 01
	00 00		 mov	 DWORD PTR fd$[rsp], eax
  004cd	83 bc 24 3c 01
	00 00 00	 cmp	 DWORD PTR fd$[rsp], 0
  004d5	0f 8d 80 00 00
	00		 jge	 $LN62@main

; 361  :     {
; 362  :         // "%s error: %s"
; 363  :         FWRMSG( stderr, HHC03006, "E", "open()", strerror( errno ));

  004db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  004e1	8b 08		 mov	 ecx, DWORD PTR [rax]
  004e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  004e9	48 89 84 24 e0
	03 00 00	 mov	 QWORD PTR tv231[rsp], rax
  004f1	b9 02 00 00 00	 mov	 ecx, 2
  004f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004fc	48 8b 8c 24 e0
	03 00 00	 mov	 rcx, QWORD PTR tv231[rsp]
  00504	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00509	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168985
  00510	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00515	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168986
  0051c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00521	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168987
  00528	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0052d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00532	41 b9 03 00 00
	00		 mov	 r9d, 3
  00538	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168988
  0053f	ba 6b 01 00 00	 mov	 edx, 363		; 0000016bH
  00544	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168989
  0054b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 364  :         return -1;

  00551	b8 ff ff ff ff	 mov	 eax, -1
  00556	e9 d9 43 00 00	 jmp	 $LN1@main
$LN62@main:

; 365  :     }
; 366  : 
; 367  :     /* Add an EOF record right away */
; 368  :     if ((curpos = lseek( fd, 0, SEEK_END )) < 0)

  0055b	41 b8 02 00 00
	00		 mov	 r8d, 2
  00561	33 d2		 xor	 edx, edx
  00563	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  0056a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  00570	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR curpos$[rsp], rax
  00578	48 83 bc 24 48
	01 00 00 00	 cmp	 QWORD PTR curpos$[rsp], 0
  00581	0f 8d 80 00 00
	00		 jge	 $LN63@main

; 369  :     {
; 370  :         // "%s error: %s"
; 371  :         FWRMSG( stderr, HHC03006, "E", "lseek()", strerror( errno ));

  00587	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0058d	8b 08		 mov	 ecx, DWORD PTR [rax]
  0058f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00595	48 89 84 24 e8
	03 00 00	 mov	 QWORD PTR tv250[rsp], rax
  0059d	b9 02 00 00 00	 mov	 ecx, 2
  005a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005a8	48 8b 8c 24 e8
	03 00 00	 mov	 rcx, QWORD PTR tv250[rsp]
  005b0	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  005b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168991
  005bc	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  005c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168992
  005c8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168993
  005d4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005d9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005de	41 b9 03 00 00
	00		 mov	 r9d, 3
  005e4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168994
  005eb	ba 73 01 00 00	 mov	 edx, 371		; 00000173H
  005f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168995
  005f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 372  :         return -1;

  005fd	b8 ff ff ff ff	 mov	 eax, -1
  00602	e9 2d 43 00 00	 jmp	 $LN1@main
$LN63@main:

; 373  :     }
; 374  : 
; 375  :     spc.spc_typ  = SPCTAB_EOF;

  00607	c6 84 24 f0 04
	00 00 08	 mov	 BYTE PTR spc$[rsp], 8

; 376  :     spc.spc_off  = curpos;

  0060f	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR curpos$[rsp]
  00617	48 89 84 24 00
	05 00 00	 mov	 QWORD PTR spc$[rsp+16], rax

; 377  :     spc.spc_siz  = curpos;

  0061f	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR curpos$[rsp]
  00627	48 89 84 24 10
	05 00 00	 mov	 QWORD PTR spc$[rsp+32], rax

; 378  :     spc.spc_len  = curpos;

  0062f	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR curpos$[rsp]
  00637	48 89 84 24 08
	05 00 00	 mov	 QWORD PTR spc$[rsp+24], rax

; 379  :     spc.spc_val  = -1;

  0063f	c7 84 24 f4 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR spc$[rsp+4], -1

; 380  :     spc.spc_val2 = -1;

  0064a	c7 84 24 f8 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR spc$[rsp+8], -1

; 381  :     ADD_SPACE( spc );

  00655	48 8d 8c 24 f0
	04 00 00	 lea	 rcx, QWORD PTR spc$[rsp]
  0065d	e8 00 00 00 00	 call	 add_spc_to_table

; 382  : 
; 383  :     /* Save file size for later */
; 384  :     filesize = curpos;

  00662	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR curpos$[rsp]
  0066a	48 89 05 00 00
	00 00		 mov	 QWORD PTR filesize, rax

; 385  : 
; 386  :     // "File size:      (%s bytes)"
; 387  :     fmt_S64( str_size, (S64) filesize );

  00671	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR filesize
  00678	48 8d 8c 24 90
	07 00 00	 lea	 rcx, QWORD PTR str_size$[rsp]
  00680	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fmt_S64

; 388  :     WRMSG( HHC03007, "I", str_size );

  00686	b9 01 00 00 00	 mov	 ecx, 1
  0068b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00691	48 8d 8c 24 90
	07 00 00	 lea	 rcx, QWORD PTR str_size$[rsp]
  00699	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0069e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168996
  006a5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168997
  006b1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006b6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006bb	41 b9 03 00 00
	00		 mov	 r9d, 3
  006c1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168998
  006c8	ba 84 01 00 00	 mov	 edx, 388		; 00000184H
  006cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168999
  006d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 389  : 
; 390  :     /* Read the device header */
; 391  :     size = (U32) CKD_DEVHDR_SIZE;

  006da	c7 84 24 38 01
	00 00 00 02 00
	00		 mov	 DWORD PTR size$[rsp], 512 ; 00000200H

; 392  :     if ((curpos = lseek( fd, 0, SEEK_SET )) < 0)

  006e5	45 33 c0	 xor	 r8d, r8d
  006e8	33 d2		 xor	 edx, edx
  006ea	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  006f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  006f7	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR curpos$[rsp], rax
  006ff	48 83 bc 24 48
	01 00 00 00	 cmp	 QWORD PTR curpos$[rsp], 0
  00708	0f 8d 80 00 00
	00		 jge	 $LN64@main

; 393  :     {
; 394  :         // "%s error: %s"
; 395  :         FWRMSG( stderr, HHC03006, "E", "lseek()", strerror( errno ));

  0070e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00714	8b 08		 mov	 ecx, DWORD PTR [rax]
  00716	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0071c	48 89 84 24 f0
	03 00 00	 mov	 QWORD PTR tv314[rsp], rax
  00724	b9 02 00 00 00	 mov	 ecx, 2
  00729	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0072f	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR tv314[rsp]
  00737	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0073c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169001
  00743	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00748	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169002
  0074f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00754	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169003
  0075b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00760	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00765	41 b9 03 00 00
	00		 mov	 r9d, 3
  0076b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169004
  00772	ba 8b 01 00 00	 mov	 edx, 395		; 0000018bH
  00777	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169005
  0077e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 396  :         return -1;

  00784	b8 ff ff ff ff	 mov	 eax, -1
  00789	e9 a6 41 00 00	 jmp	 $LN1@main
$LN64@main:

; 397  :     }
; 398  :     if ((rc = read( fd, &devhdr, size )) < (int) size)

  0078e	44 8b 84 24 38
	01 00 00	 mov	 r8d, DWORD PTR size$[rsp]
  00796	48 8d 94 24 20
	05 00 00	 lea	 rdx, QWORD PTR devhdr$[rsp]
  0079e	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  007a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  007ab	89 84 24 40 01
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  007b2	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  007b9	39 84 24 40 01
	00 00		 cmp	 DWORD PTR rc$[rsp], eax
  007c0	0f 8d 80 00 00
	00		 jge	 $LN65@main

; 399  :     {
; 400  :         // "%s error: %s"
; 401  :         FWRMSG( stderr, HHC03006, "E", "read()", strerror( errno ));

  007c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  007cc	8b 08		 mov	 ecx, DWORD PTR [rax]
  007ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  007d4	48 89 84 24 f8
	03 00 00	 mov	 QWORD PTR tv333[rsp], rax
  007dc	b9 02 00 00 00	 mov	 ecx, 2
  007e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007e7	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR tv333[rsp]
  007ef	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  007f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169007
  007fb	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00800	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169008
  00807	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0080c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169009
  00813	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00818	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0081d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00823	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169010
  0082a	ba 91 01 00 00	 mov	 edx, 401		; 00000191H
  0082f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169011
  00836	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 402  :         return -1;

  0083c	b8 ff ff ff ff	 mov	 eax, -1
  00841	e9 ee 40 00 00	 jmp	 $LN1@main
$LN65@main:

; 403  :     }
; 404  : 
; 405  :     /* Input must be a compressed type */
; 406  :     if (!((imgtyp = dh_devid_typ( devhdr.dh_devid )) & ANY_CMP_OR_SF_TYP))

  00846	48 8d 8c 24 20
	05 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp]
  0084e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dh_devid_typ
  00854	89 84 24 58 01
	00 00		 mov	 DWORD PTR imgtyp$[rsp], eax
  0085b	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR imgtyp$[rsp]
  00862	25 60 60 60 60	 and	 eax, 1616928864		; 60606060H
  00867	85 c0		 test	 eax, eax
  00869	75 51		 jne	 SHORT $LN66@main

; 407  :     {
; 408  :         // "Unsupported dasd image file format"
; 409  :         FWRMSG( stderr, HHC03004, "E" );

  0086b	b9 02 00 00 00	 mov	 ecx, 2
  00870	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00876	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169013
  0087d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00882	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169014
  00889	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0088e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00893	41 b9 03 00 00
	00		 mov	 r9d, 3
  00899	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169015
  008a0	ba 99 01 00 00	 mov	 edx, 409		; 00000199H
  008a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169016
  008ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 410  :         return -1;

  008b2	b8 ff ff ff ff	 mov	 eax, -1
  008b7	e9 78 40 00 00	 jmp	 $LN1@main
$LN66@main:

; 411  :     }
; 412  : 
; 413  :     /* Remember whether input is CCKD/CFBA or CCKD64/CFBA64 */
; 414  :     if (imgtyp & ANY64_CMP_OR_SF_TYP)

  008bc	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR imgtyp$[rsp]
  008c3	25 60 00 60 00	 and	 eax, 6291552		; 00600060H
  008c8	85 c0		 test	 eax, eax
  008ca	74 07		 je	 SHORT $LN67@main

; 415  :         cckd64 = true;

  008cc	c6 05 00 00 00
	00 01		 mov	 BYTE PTR cckd64, 1
$LN67@main:

; 416  : 
; 417  :     /* Remember whether input is CFBA/CFBA64 or CCKD/CCKD64 */
; 418  :     if (imgtyp & FBA_CMP_OR_SF_TYP)

  008d3	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR imgtyp$[rsp]
  008da	25 60 60 00 00	 and	 eax, 24672		; 00006060H
  008df	85 c0		 test	 eax, eax
  008e1	74 07		 je	 SHORT $LN68@main

; 419  :         fba = true;

  008e3	c6 05 00 00 00
	00 01		 mov	 BYTE PTR fba, 1
$LN68@main:

; 420  : 
; 421  :     /* Remember whether input is shadow or not */
; 422  :     if (imgtyp & ANY_SF_TYP)

  008ea	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR imgtyp$[rsp]
  008f1	25 20 20 20 20	 and	 eax, 538976288		; 20202020H
  008f6	85 c0		 test	 eax, eax
  008f8	74 07		 je	 SHORT $LN69@main

; 423  :         shadow = true;

  008fa	c6 05 00 00 00
	00 01		 mov	 BYTE PTR shadow, 1
$LN69@main:

; 424  : 
; 425  :     /* Add CKD device header to spaces table */
; 426  :     spc.spc_typ  = SPCTAB_DEVHDR;

  00901	c6 84 24 f0 04
	00 00 01	 mov	 BYTE PTR spc$[rsp], 1

; 427  :     spc.spc_off  = 0;

  00909	48 c7 84 24 00
	05 00 00 00 00
	00 00		 mov	 QWORD PTR spc$[rsp+16], 0

; 428  :     spc.spc_siz  = CKD_DEVHDR_SIZE;

  00915	48 c7 84 24 10
	05 00 00 00 02
	00 00		 mov	 QWORD PTR spc$[rsp+32], 512 ; 00000200H

; 429  :     spc.spc_len  = spc.spc_siz;

  00921	48 8b 84 24 10
	05 00 00	 mov	 rax, QWORD PTR spc$[rsp+32]
  00929	48 89 84 24 08
	05 00 00	 mov	 QWORD PTR spc$[rsp+24], rax

; 430  :     spc.spc_val  = -1;

  00931	c7 84 24 f4 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR spc$[rsp+4], -1

; 431  :     spc.spc_val2 = -1;

  0093c	c7 84 24 f8 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR spc$[rsp+8], -1

; 432  :     ADD_SPACE( spc );

  00947	48 8d 8c 24 f0
	04 00 00	 lea	 rcx, QWORD PTR spc$[rsp]
  0094f	e8 00 00 00 00	 call	 add_spc_to_table

; 433  : 
; 434  :     /* Read the compressed device header... */
; 435  : 
; 436  :     /* Init the size of the device header */
; 437  :     size   = CCKD64_DEVHDR_SIZE;

  00954	c7 84 24 38 01
	00 00 00 02 00
	00		 mov	 DWORD PTR size$[rsp], 512 ; 00000200H

; 438  :     size32 = CCKD_DEVHDR_SIZE;

  0095f	c7 84 24 44 01
	00 00 00 02 00
	00		 mov	 DWORD PTR size32$[rsp], 512 ; 00000200H

; 439  : 
; 440  :     if (cckd64)

  0096a	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  00971	85 c0		 test	 eax, eax
  00973	0f 84 68 01 00
	00		 je	 $LN70@main

; 441  :     {
; 442  :         if ((curpos = lseek( fd, CCKD64_DEVHDR_POS, SEEK_SET )) < 0)

  00979	45 33 c0	 xor	 r8d, r8d
  0097c	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  00981	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  00988	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  0098e	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR curpos$[rsp], rax
  00996	48 83 bc 24 48
	01 00 00 00	 cmp	 QWORD PTR curpos$[rsp], 0
  0099f	0f 8d 80 00 00
	00		 jge	 $LN72@main

; 443  :         {
; 444  :             // "%s error: %s"
; 445  :             FWRMSG( stderr, HHC03006, "E", "lseek()", strerror( errno ));

  009a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  009ab	8b 08		 mov	 ecx, DWORD PTR [rax]
  009ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  009b3	48 89 84 24 00
	04 00 00	 mov	 QWORD PTR tv374[rsp], rax
  009bb	b9 02 00 00 00	 mov	 ecx, 2
  009c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009c6	48 8b 8c 24 00
	04 00 00	 mov	 rcx, QWORD PTR tv374[rsp]
  009ce	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  009d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169023
  009da	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  009df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169024
  009e6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169025
  009f2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  009f7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009fc	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a02	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169026
  00a09	ba bd 01 00 00	 mov	 edx, 445		; 000001bdH
  00a0e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169027
  00a15	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 446  :             return -1;

  00a1b	b8 ff ff ff ff	 mov	 eax, -1
  00a20	e9 0f 3f 00 00	 jmp	 $LN1@main
$LN72@main:

; 447  :         }
; 448  :         if ((rc = read( fd, &cdevhdr, size )) < (int) size)

  00a25	44 8b 84 24 38
	01 00 00	 mov	 r8d, DWORD PTR size$[rsp]
  00a2d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cdevhdr
  00a34	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  00a3b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  00a41	89 84 24 40 01
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  00a48	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  00a4f	39 84 24 40 01
	00 00		 cmp	 DWORD PTR rc$[rsp], eax
  00a56	0f 8d 80 00 00
	00		 jge	 $LN73@main

; 449  :         {
; 450  :             // "%s error: %s"
; 451  :             FWRMSG( stderr, HHC03006, "E", "read()", strerror( errno ));

  00a5c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00a62	8b 08		 mov	 ecx, DWORD PTR [rax]
  00a64	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00a6a	48 89 84 24 08
	04 00 00	 mov	 QWORD PTR tv425[rsp], rax
  00a72	b9 02 00 00 00	 mov	 ecx, 2
  00a77	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a7d	48 8b 8c 24 08
	04 00 00	 mov	 rcx, QWORD PTR tv425[rsp]
  00a85	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00a8a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169029
  00a91	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00a96	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169030
  00a9d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00aa2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169031
  00aa9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00aae	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ab3	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ab9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169032
  00ac0	ba c3 01 00 00	 mov	 edx, 451		; 000001c3H
  00ac5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169033
  00acc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 452  :             return -1;

  00ad2	b8 ff ff ff ff	 mov	 eax, -1
  00ad7	e9 58 3e 00 00	 jmp	 $LN1@main
$LN73@main:

; 453  :         }
; 454  :     }

  00adc	e9 68 01 00 00	 jmp	 $LN71@main
$LN70@main:

; 455  :     else
; 456  :     {
; 457  :         if ((curpos = lseek( fd, CCKD_DEVHDR_POS, SEEK_SET )) < 0)

  00ae1	45 33 c0	 xor	 r8d, r8d
  00ae4	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  00ae9	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  00af0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  00af6	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR curpos$[rsp], rax
  00afe	48 83 bc 24 48
	01 00 00 00	 cmp	 QWORD PTR curpos$[rsp], 0
  00b07	0f 8d 80 00 00
	00		 jge	 $LN74@main

; 458  :         {
; 459  :             // "%s error: %s"
; 460  :             FWRMSG( stderr, HHC03006, "E", "lseek()", strerror( errno ));

  00b0d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00b13	8b 08		 mov	 ecx, DWORD PTR [rax]
  00b15	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00b1b	48 89 84 24 10
	04 00 00	 mov	 QWORD PTR tv444[rsp], rax
  00b23	b9 02 00 00 00	 mov	 ecx, 2
  00b28	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b2e	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR tv444[rsp]
  00b36	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00b3b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169035
  00b42	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00b47	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169036
  00b4e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b53	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169037
  00b5a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b5f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b64	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b6a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169038
  00b71	ba cc 01 00 00	 mov	 edx, 460		; 000001ccH
  00b76	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169039
  00b7d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 461  :             return -1;

  00b83	b8 ff ff ff ff	 mov	 eax, -1
  00b88	e9 a7 3d 00 00	 jmp	 $LN1@main
$LN74@main:

; 462  :         }
; 463  :         if ((rc = read( fd, &cdevhdr32, size32 )) < (int) size32)

  00b8d	44 8b 84 24 44
	01 00 00	 mov	 r8d, DWORD PTR size32$[rsp]
  00b95	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cdevhdr32
  00b9c	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  00ba3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  00ba9	89 84 24 40 01
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  00bb0	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR size32$[rsp]
  00bb7	39 84 24 40 01
	00 00		 cmp	 DWORD PTR rc$[rsp], eax
  00bbe	0f 8d 80 00 00
	00		 jge	 $LN75@main

; 464  :         {
; 465  :             // "%s error: %s"
; 466  :             FWRMSG( stderr, HHC03006, "E", "read()", strerror( errno ));

  00bc4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00bca	8b 08		 mov	 ecx, DWORD PTR [rax]
  00bcc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00bd2	48 89 84 24 18
	04 00 00	 mov	 QWORD PTR tv463[rsp], rax
  00bda	b9 02 00 00 00	 mov	 ecx, 2
  00bdf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00be5	48 8b 8c 24 18
	04 00 00	 mov	 rcx, QWORD PTR tv463[rsp]
  00bed	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00bf2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169041
  00bf9	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00bfe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169042
  00c05	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c0a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169043
  00c11	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c16	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c1b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c21	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169044
  00c28	ba d2 01 00 00	 mov	 edx, 466		; 000001d2H
  00c2d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169045
  00c34	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 467  :             return -1;

  00c3a	b8 ff ff ff ff	 mov	 eax, -1
  00c3f	e9 f0 3c 00 00	 jmp	 $LN1@main
$LN75@main:

; 468  :         }
; 469  : 
; 470  :         /* Convert 32-bit CCKD/CFBA header to 64-bit CCKD64/CFBA64 */
; 471  :         cdevhdr_to_64();

  00c44	e8 00 00 00 00	 call	 cdevhdr_to_64
$LN71@main:

; 472  :     }
; 473  : 
; 474  :     /* Add compressed device header to spaces table */
; 475  :     spc.spc_typ  = SPCTAB_CDEVHDR;

  00c49	c6 84 24 f0 04
	00 00 02	 mov	 BYTE PTR spc$[rsp], 2

; 476  :     spc.spc_off  = curpos;

  00c51	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR curpos$[rsp]
  00c59	48 89 84 24 00
	05 00 00	 mov	 QWORD PTR spc$[rsp+16], rax

; 477  :     spc.spc_siz  = cckd64 ? size : size32;

  00c61	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  00c68	85 c0		 test	 eax, eax
  00c6a	74 10		 je	 SHORT $LN164@main
  00c6c	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  00c73	89 84 24 f4 01
	00 00		 mov	 DWORD PTR tv479[rsp], eax
  00c7a	eb 0e		 jmp	 SHORT $LN165@main
$LN164@main:
  00c7c	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR size32$[rsp]
  00c83	89 84 24 f4 01
	00 00		 mov	 DWORD PTR tv479[rsp], eax
$LN165@main:
  00c8a	8b 84 24 f4 01
	00 00		 mov	 eax, DWORD PTR tv479[rsp]
  00c91	48 89 84 24 10
	05 00 00	 mov	 QWORD PTR spc$[rsp+32], rax

; 478  :     spc.spc_len  = spc.spc_siz;

  00c99	48 8b 84 24 10
	05 00 00	 mov	 rax, QWORD PTR spc$[rsp+32]
  00ca1	48 89 84 24 08
	05 00 00	 mov	 QWORD PTR spc$[rsp+24], rax

; 479  :     spc.spc_val  = -1;

  00ca9	c7 84 24 f4 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR spc$[rsp+4], -1

; 480  :     spc.spc_val2 = -1;

  00cb4	c7 84 24 f8 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR spc$[rsp+8], -1

; 481  :     ADD_SPACE( spc );

  00cbf	48 8d 8c 24 f0
	04 00 00	 lea	 rcx, QWORD PTR spc$[rsp]
  00cc7	e8 00 00 00 00	 call	 add_spc_to_table

; 482  : 
; 483  :     /* Determine whether endian swaps are going to be needed or not */
; 484  :     swaps_needed = are_swaps_needed( &cdevhdr );

  00ccc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cdevhdr
  00cd3	e8 00 00 00 00	 call	 are_swaps_needed
  00cd8	88 05 00 00 00
	00		 mov	 BYTE PTR swaps_needed, al
$LN7@main:

; 485  : 
; 486  :     /* Swap compressed device header before processing */
; 487  :     SWAP_CCKD64_DEVHDR( &cdevhdr );

  00cde	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR swaps_needed
  00ce5	85 c0		 test	 eax, eax
  00ce7	74 0d		 je	 SHORT $LN76@main
  00ce9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cdevhdr
  00cf0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_cckd64_swapend_chdr
$LN76@main:
  00cf6	33 c0		 xor	 eax, eax
  00cf8	85 c0		 test	 eax, eax
  00cfa	75 e2		 jne	 SHORT $LN7@main

; 488  : 
; 489  :     /* Save some values for reporting */
; 490  :     devtype = 0x3300 + devhdr.dh_devtyp;

  00cfc	0f b6 84 24 30
	05 00 00	 movzx	 eax, BYTE PTR devhdr$[rsp+16]
  00d04	05 00 33 00 00	 add	 eax, 13056		; 00003300H
  00d09	66 89 84 24 50
	01 00 00	 mov	 WORD PTR devtype$[rsp], ax

; 491  : 
; 492  :     FETCH_LE_FW( heads,   devhdr.dh_heads   );

  00d11	48 8d 8c 24 28
	05 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+8]
  00d19	e8 00 00 00 00	 call	 fetch_fw_noswap
  00d1e	8b c8		 mov	 ecx, eax
  00d20	e8 00 00 00 00	 call	 _byteswap_ulong
  00d25	8b c8		 mov	 ecx, eax
  00d27	e8 00 00 00 00	 call	 _byteswap_ulong
  00d2c	89 84 24 98 01
	00 00		 mov	 DWORD PTR heads$[rsp], eax

; 493  :     FETCH_LE_FW( trksize, devhdr.dh_trksize );

  00d33	48 8d 8c 24 2c
	05 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+12]
  00d3b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00d40	8b c8		 mov	 ecx, eax
  00d42	e8 00 00 00 00	 call	 _byteswap_ulong
  00d47	8b c8		 mov	 ecx, eax
  00d49	e8 00 00 00 00	 call	 _byteswap_ulong
  00d4e	89 84 24 00 02
	00 00		 mov	 DWORD PTR trksize$[rsp], eax

; 494  :     FETCH_LE_FW( cyls,   cdevhdr.cdh_cyls   );

  00d55	48 8d 0d 0c 00
	00 00		 lea	 rcx, OFFSET FLAT:cdevhdr+12
  00d5c	e8 00 00 00 00	 call	 fetch_fw_noswap
  00d61	8b c8		 mov	 ecx, eax
  00d63	e8 00 00 00 00	 call	 _byteswap_ulong
  00d68	8b c8		 mov	 ecx, eax
  00d6a	e8 00 00 00 00	 call	 _byteswap_ulong
  00d6f	89 84 24 5c 01
	00 00		 mov	 DWORD PTR cyls$[rsp], eax

; 495  : 
; 496  :     if (fba)

  00d76	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR fba
  00d7d	85 c0		 test	 eax, eax
  00d7f	74 1c		 je	 SHORT $LN77@main

; 497  :         // (for fba, cyls is total sectors and tracks is blkgrps)
; 498  :         tracks = (cyls + CFBA_BLKS_PER_GRP - 1) / CFBA_BLKS_PER_GRP;

  00d81	8b 84 24 5c 01
	00 00		 mov	 eax, DWORD PTR cyls$[rsp]
  00d88	83 c0 77	 add	 eax, 119		; 00000077H
  00d8b	33 d2		 xor	 edx, edx
  00d8d	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  00d92	f7 f1		 div	 ecx
  00d94	89 84 24 68 01
	00 00		 mov	 DWORD PTR tracks$[rsp], eax
  00d9b	eb 16		 jmp	 SHORT $LN78@main
$LN77@main:

; 499  :     else
; 500  :         tracks = cyls * heads;

  00d9d	8b 84 24 5c 01
	00 00		 mov	 eax, DWORD PTR cyls$[rsp]
  00da4	0f af 84 24 98
	01 00 00	 imul	 eax, DWORD PTR heads$[rsp]
  00dac	89 84 24 68 01
	00 00		 mov	 DWORD PTR tracks$[rsp], eax
$LN78@main:

; 501  : 
; 502  :     /* Locate the CKD/FBA dasd table entry */
; 503  :     if (fba)

  00db3	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR fba
  00dba	85 c0		 test	 eax, eax
  00dbc	0f 84 a3 00 00
	00		 je	 $LN79@main

; 504  :     {
; 505  :         if (!(fbatab = dasd_lookup( DASD_FBADEV, NULL, devtype, cyls )))

  00dc2	0f b7 84 24 50
	01 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  00dca	44 8b 8c 24 5c
	01 00 00	 mov	 r9d, DWORD PTR cyls$[rsp]
  00dd2	44 8b c0	 mov	 r8d, eax
  00dd5	33 d2		 xor	 edx, edx
  00dd7	b9 03 00 00 00	 mov	 ecx, 3
  00ddc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dasd_lookup
  00de2	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR fbatab$[rsp], rax
  00dea	48 83 bc 24 70
	02 00 00 00	 cmp	 QWORD PTR fbatab$[rsp], 0
  00df3	75 6b		 jne	 SHORT $LN81@main

; 506  :         {
; 507  :             // "Device type %4.4X not found in dasd table"
; 508  :             FWRMSG( stderr, HHC03005, "E", devtype );

  00df5	0f b7 84 24 50
	01 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  00dfd	89 84 24 40 02
	00 00		 mov	 DWORD PTR tv556[rsp], eax
  00e04	b9 02 00 00 00	 mov	 ecx, 2
  00e09	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e0f	8b 8c 24 40 02
	00 00		 mov	 ecx, DWORD PTR tv556[rsp]
  00e16	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00e1a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169052
  00e21	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e26	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169053
  00e2d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e32	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e37	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e3d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169054
  00e44	ba fc 01 00 00	 mov	 edx, 508		; 000001fcH
  00e49	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169055
  00e50	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 509  :             return -1;

  00e56	b8 ff ff ff ff	 mov	 eax, -1
  00e5b	e9 d4 3a 00 00	 jmp	 $LN1@main
$LN81@main:

; 510  :         }
; 511  :     }

  00e60	e9 9e 00 00 00	 jmp	 $LN80@main
$LN79@main:

; 512  :     else
; 513  :     {
; 514  :         if (!(ckdtab = dasd_lookup( DASD_CKDDEV, NULL, devtype, cyls )))

  00e65	0f b7 84 24 50
	01 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  00e6d	44 8b 8c 24 5c
	01 00 00	 mov	 r9d, DWORD PTR cyls$[rsp]
  00e75	44 8b c0	 mov	 r8d, eax
  00e78	33 d2		 xor	 edx, edx
  00e7a	b9 01 00 00 00	 mov	 ecx, 1
  00e7f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dasd_lookup
  00e85	48 89 84 24 78
	02 00 00	 mov	 QWORD PTR ckdtab$[rsp], rax
  00e8d	48 83 bc 24 78
	02 00 00 00	 cmp	 QWORD PTR ckdtab$[rsp], 0
  00e96	75 6b		 jne	 SHORT $LN82@main

; 515  :         {
; 516  :             // "Device type %4.4X not found in dasd table"
; 517  :             FWRMSG( stderr, HHC03005, "E", devtype );

  00e98	0f b7 84 24 50
	01 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  00ea0	89 84 24 58 02
	00 00		 mov	 DWORD PTR tv574[rsp], eax
  00ea7	b9 02 00 00 00	 mov	 ecx, 2
  00eac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00eb2	8b 8c 24 58 02
	00 00		 mov	 ecx, DWORD PTR tv574[rsp]
  00eb9	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00ebd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169057
  00ec4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00ec9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169058
  00ed0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ed5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00eda	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ee0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169059
  00ee7	ba 05 02 00 00	 mov	 edx, 517		; 00000205H
  00eec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169060
  00ef3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 518  :             return -1;

  00ef9	b8 ff ff ff ff	 mov	 eax, -1
  00efe	e9 31 3a 00 00	 jmp	 $LN1@main
$LN82@main:
$LN80@main:

; 519  :         }
; 520  :     }
; 521  : 
; 522  :     /* Read the free space chain and add to table */
; 523  :     if (cdevhdr.free_num)

  00f03	48 83 3d 38 00
	00 00 00	 cmp	 QWORD PTR cdevhdr+56, 0
  00f0b	0f 84 c8 08 00
	00		 je	 $LN83@main

; 524  :     {
; 525  :         int free_num;
; 526  : 
; 527  :         /* Save the number of free spaces */
; 528  :         free_num = (int) cdevhdr.free_num;

  00f11	8b 05 38 00 00
	00		 mov	 eax, DWORD PTR cdevhdr+56
  00f17	89 84 24 94 01
	00 00		 mov	 DWORD PTR free_num$3[rsp], eax

; 529  : 
; 530  :         /* Init the size of a free space block */
; 531  :         size     = (U32) CCKD64_FREEBLK_SIZE;

  00f1e	c7 84 24 38 01
	00 00 10 00 00
	00		 mov	 DWORD PTR size$[rsp], 16

; 532  :         size32   = (U32) CCKD_FREEBLK_SIZE;

  00f29	c7 84 24 44 01
	00 00 08 00 00
	00		 mov	 DWORD PTR size32$[rsp], 8

; 533  : 
; 534  :         /* First, determine which format the INITIAL free space CHAIN
; 535  :            was written in: old format or "new" format, determined by
; 536  :            whether or not the very first free space block contains the
; 537  :            literal "FREE_BLK" or not (see documentation).
; 538  :         */
; 539  : 
; 540  :         curpos = cdevhdr.free_off;  // (position of first free block)

  00f34	48 8b 05 20 00
	00 00		 mov	 rax, QWORD PTR cdevhdr+32
  00f3b	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR curpos$[rsp], rax

; 541  : 
; 542  :         if (lseek( fd, curpos, SEEK_SET ) < 0)

  00f43	45 33 c0	 xor	 r8d, r8d
  00f46	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR curpos$[rsp]
  00f4e	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  00f55	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  00f5b	48 85 c0	 test	 rax, rax
  00f5e	0f 8d 80 00 00
	00		 jge	 $LN84@main

; 543  :         {
; 544  :             // "%s error: %s"
; 545  :             FWRMSG( stderr, HHC03006, "E", "lseek()", strerror( errno ));

  00f64	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00f6a	8b 08		 mov	 ecx, DWORD PTR [rax]
  00f6c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00f72	48 89 84 24 20
	04 00 00	 mov	 QWORD PTR tv591[rsp], rax
  00f7a	b9 02 00 00 00	 mov	 ecx, 2
  00f7f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00f85	48 8b 8c 24 20
	04 00 00	 mov	 rcx, QWORD PTR tv591[rsp]
  00f8d	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00f92	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169063
  00f99	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00f9e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169064
  00fa5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00faa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169065
  00fb1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00fb6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00fbb	41 b9 03 00 00
	00		 mov	 r9d, 3
  00fc1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169066
  00fc8	ba 21 02 00 00	 mov	 edx, 545		; 00000221H
  00fcd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169067
  00fd4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 546  :             return -1;

  00fda	b8 ff ff ff ff	 mov	 eax, -1
  00fdf	e9 50 39 00 00	 jmp	 $LN1@main
$LN84@main:

; 547  :         }
; 548  : 
; 549  :         if (cckd64)

  00fe4	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  00feb	85 c0		 test	 eax, eax
  00fed	0f 84 e0 00 00
	00		 je	 $LN85@main

; 550  :         {
; 551  :             if ((rc = read( fd, &freeblk, size )) < (int) size)

  00ff3	44 8b 84 24 38
	01 00 00	 mov	 r8d, DWORD PTR size$[rsp]
  00ffb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:freeblk
  01002	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  01009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  0100f	89 84 24 40 01
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  01016	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  0101d	39 84 24 40 01
	00 00		 cmp	 DWORD PTR rc$[rsp], eax
  01024	0f 8d 80 00 00
	00		 jge	 $LN87@main

; 552  :             {
; 553  :                 // "%s error: %s"
; 554  :                 FWRMSG( stderr, HHC03006, "E", "read()", strerror( errno ));

  0102a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01030	8b 08		 mov	 ecx, DWORD PTR [rax]
  01032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01038	48 89 84 24 28
	04 00 00	 mov	 QWORD PTR tv644[rsp], rax
  01040	b9 02 00 00 00	 mov	 ecx, 2
  01045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0104b	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR tv644[rsp]
  01053	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169071
  0105f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169072
  0106b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01070	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169073
  01077	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0107c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01081	41 b9 03 00 00
	00		 mov	 r9d, 3
  01087	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169074
  0108e	ba 2a 02 00 00	 mov	 edx, 554		; 0000022aH
  01093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169075
  0109a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 555  :                 return -1;

  010a0	b8 ff ff ff ff	 mov	 eax, -1
  010a5	e9 8a 38 00 00	 jmp	 $LN1@main
$LN87@main:

; 556  :             }
; 557  : 
; 558  :             if (mem_eq( &freeblk, "FREE_BLK", 8))

  010aa	41 b8 08 00 00
	00		 mov	 r8d, 8
  010b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169077
  010b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:freeblk
  010be	e8 00 00 00 00	 call	 memcmp
  010c3	85 c0		 test	 eax, eax
  010c5	75 07		 jne	 SHORT $LN88@main

; 559  :                 new_format = true;

  010c7	c6 05 00 00 00
	00 01		 mov	 BYTE PTR new_format, 1
$LN88@main:

; 560  :         }

  010ce	e9 db 00 00 00	 jmp	 $LN86@main
$LN85@main:

; 561  :         else // (32-bit CCKD)
; 562  :         {
; 563  :             if ((rc = read( fd, &freeblk32, size32 )) < (int) size32)

  010d3	44 8b 84 24 44
	01 00 00	 mov	 r8d, DWORD PTR size32$[rsp]
  010db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:freeblk32
  010e2	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  010e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  010ef	89 84 24 40 01
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  010f6	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR size32$[rsp]
  010fd	39 84 24 40 01
	00 00		 cmp	 DWORD PTR rc$[rsp], eax
  01104	0f 8d 80 00 00
	00		 jge	 $LN89@main

; 564  :             {
; 565  :                 // "%s error: %s"
; 566  :                 FWRMSG( stderr, HHC03006, "E", "read()", strerror( errno ));

  0110a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01110	8b 08		 mov	 ecx, DWORD PTR [rax]
  01112	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01118	48 89 84 24 30
	04 00 00	 mov	 QWORD PTR tv670[rsp], rax
  01120	b9 02 00 00 00	 mov	 ecx, 2
  01125	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0112b	48 8b 8c 24 30
	04 00 00	 mov	 rcx, QWORD PTR tv670[rsp]
  01133	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01138	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169079
  0113f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01144	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169080
  0114b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01150	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169081
  01157	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0115c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01161	41 b9 03 00 00
	00		 mov	 r9d, 3
  01167	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169082
  0116e	ba 36 02 00 00	 mov	 edx, 566		; 00000236H
  01173	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169083
  0117a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 567  :                 return -1;

  01180	b8 ff ff ff ff	 mov	 eax, -1
  01185	e9 aa 37 00 00	 jmp	 $LN1@main
$LN89@main:

; 568  :             }
; 569  : 
; 570  :             if (mem_eq( &freeblk32, "FREE_BLK", 8))

  0118a	41 b8 08 00 00
	00		 mov	 r8d, 8
  01190	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169085
  01197	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:freeblk32
  0119e	e8 00 00 00 00	 call	 memcmp
  011a3	85 c0		 test	 eax, eax
  011a5	75 07		 jne	 SHORT $LN90@main

; 571  :                 new_format = true;

  011a7	c6 05 00 00 00
	00 01		 mov	 BYTE PTR new_format, 1
$LN90@main:
$LN86@main:

; 572  :         }
; 573  : 
; 574  :         /* Now we know HOW to read in the initial free space chain... */
; 575  : 
; 576  :         if (new_format)

  011ae	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR new_format
  011b5	85 c0		 test	 eax, eax
  011b7	0f 84 31 03 00
	00		 je	 $LN91@main

; 577  :         {
; 578  :             /* Read the entire free space chain in all at once */
; 579  : 
; 580  :             int     chainbytes = free_num * (cckd64 ? size : size32);

  011bd	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  011c4	85 c0		 test	 eax, eax
  011c6	74 10		 je	 SHORT $LN166@main
  011c8	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  011cf	89 84 24 f8 01
	00 00		 mov	 DWORD PTR tv695[rsp], eax
  011d6	eb 0e		 jmp	 SHORT $LN167@main
$LN166@main:
  011d8	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR size32$[rsp]
  011df	89 84 24 f8 01
	00 00		 mov	 DWORD PTR tv695[rsp], eax
$LN167@main:
  011e6	8b 84 24 94 01
	00 00		 mov	 eax, DWORD PTR free_num$3[rsp]
  011ed	0f af 84 24 f8
	01 00 00	 imul	 eax, DWORD PTR tv695[rsp]
  011f5	89 84 24 90 01
	00 00		 mov	 DWORD PTR chainbytes$2[rsp], eax

; 581  :             void*   freechain  = malloc( chainbytes );

  011fc	48 63 84 24 90
	01 00 00	 movsxd	 rax, DWORD PTR chainbytes$2[rsp]
  01204	48 8b c8	 mov	 rcx, rax
  01207	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0120d	48 89 84 24 10
	02 00 00	 mov	 QWORD PTR freechain$4[rsp], rax

; 582  : 
; 583  :             if (lseek( fd, curpos + (cckd64 ? size : size32), SEEK_SET ) < 0)

  01215	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  0121c	85 c0		 test	 eax, eax
  0121e	74 10		 je	 SHORT $LN168@main
  01220	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  01227	89 84 24 fc 01
	00 00		 mov	 DWORD PTR tv707[rsp], eax
  0122e	eb 0e		 jmp	 SHORT $LN169@main
$LN168@main:
  01230	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR size32$[rsp]
  01237	89 84 24 fc 01
	00 00		 mov	 DWORD PTR tv707[rsp], eax
$LN169@main:
  0123e	8b 84 24 fc 01
	00 00		 mov	 eax, DWORD PTR tv707[rsp]
  01245	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR curpos$[rsp]
  0124d	48 03 c8	 add	 rcx, rax
  01250	48 8b c1	 mov	 rax, rcx
  01253	45 33 c0	 xor	 r8d, r8d
  01256	48 8b d0	 mov	 rdx, rax
  01259	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  01260	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  01266	48 85 c0	 test	 rax, rax
  01269	0f 8d 80 00 00
	00		 jge	 $LN93@main

; 584  :             {
; 585  :                 // "%s error: %s"
; 586  :                 FWRMSG( stderr, HHC03006, "E", "lseek()", strerror( errno ));

  0126f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01275	8b 08		 mov	 ecx, DWORD PTR [rax]
  01277	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0127d	48 89 84 24 38
	04 00 00	 mov	 QWORD PTR tv713[rsp], rax
  01285	b9 02 00 00 00	 mov	 ecx, 2
  0128a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01290	48 8b 8c 24 38
	04 00 00	 mov	 rcx, QWORD PTR tv713[rsp]
  01298	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0129d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169089
  012a4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  012a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169090
  012b0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  012b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169091
  012bc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  012c1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  012c6	41 b9 03 00 00
	00		 mov	 r9d, 3
  012cc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169092
  012d3	ba 4a 02 00 00	 mov	 edx, 586		; 0000024aH
  012d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169093
  012df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 587  :                 return -1;

  012e5	b8 ff ff ff ff	 mov	 eax, -1
  012ea	e9 45 36 00 00	 jmp	 $LN1@main
$LN93@main:

; 588  :             }
; 589  : 
; 590  :             if ((rc = read( fd, freechain, chainbytes )) < (int) chainbytes)

  012ef	44 8b 84 24 90
	01 00 00	 mov	 r8d, DWORD PTR chainbytes$2[rsp]
  012f7	48 8b 94 24 10
	02 00 00	 mov	 rdx, QWORD PTR freechain$4[rsp]
  012ff	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  01306	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  0130c	89 84 24 40 01
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  01313	8b 84 24 90 01
	00 00		 mov	 eax, DWORD PTR chainbytes$2[rsp]
  0131a	39 84 24 40 01
	00 00		 cmp	 DWORD PTR rc$[rsp], eax
  01321	0f 8d 80 00 00
	00		 jge	 $LN94@main

; 591  :             {
; 592  :                 // "%s error: %s"
; 593  :                 FWRMSG( stderr, HHC03006, "E", "read()", strerror( errno ));

  01327	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0132d	8b 08		 mov	 ecx, DWORD PTR [rax]
  0132f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01335	48 89 84 24 40
	04 00 00	 mov	 QWORD PTR tv732[rsp], rax
  0133d	b9 02 00 00 00	 mov	 ecx, 2
  01342	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01348	48 8b 8c 24 40
	04 00 00	 mov	 rcx, QWORD PTR tv732[rsp]
  01350	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01355	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169095
  0135c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01361	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169096
  01368	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0136d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169097
  01374	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01379	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0137e	41 b9 03 00 00
	00		 mov	 r9d, 3
  01384	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169098
  0138b	ba 51 02 00 00	 mov	 edx, 593		; 00000251H
  01390	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169099
  01397	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 594  :                 return -1;

  0139d	b8 ff ff ff ff	 mov	 eax, -1
  013a2	e9 8d 35 00 00	 jmp	 $LN1@main
$LN94@main:

; 595  :             }
; 596  : 
; 597  :             /* Then add each of those free spaces to our table */
; 598  :             {
; 599  :                 CCKD64_FREEBLK*  block     = freechain;

  013a7	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR freechain$4[rsp]
  013af	48 89 84 24 48
	04 00 00	 mov	 QWORD PTR block$8[rsp], rax

; 600  :                 CCKD_FREEBLK*    block32   = freechain;

  013b7	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR freechain$4[rsp]
  013bf	48 89 84 24 50
	04 00 00	 mov	 QWORD PTR block32$9[rsp], rax

; 601  : 
; 602  :                 for (i=0; i < free_num; ++i)

  013c7	c7 84 24 30 01
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  013d2	eb 10		 jmp	 SHORT $LN10@main
$LN8@main:
  013d4	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  013db	ff c0		 inc	 eax
  013dd	89 84 24 30 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN10@main:
  013e4	8b 84 24 94 01
	00 00		 mov	 eax, DWORD PTR free_num$3[rsp]
  013eb	39 84 24 30 01
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  013f2	0f 8d e3 00 00
	00		 jge	 $LN9@main

; 603  :                 {
; 604  :                     /* Convert 32-bit CCKD free block to 64-bit */
; 605  :                     if (cckd64)

  013f8	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  013ff	85 c0		 test	 eax, eax
  01401	74 34		 je	 SHORT $LN95@main

; 606  :                     {
; 607  :                         memcpy( &freeblk, &block[i], size );

  01403	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  0140a	48 63 8c 24 30
	01 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  01412	48 6b c9 10	 imul	 rcx, rcx, 16
  01416	48 8b 94 24 48
	04 00 00	 mov	 rdx, QWORD PTR block$8[rsp]
  0141e	48 03 d1	 add	 rdx, rcx
  01421	48 8b ca	 mov	 rcx, rdx
  01424	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:freeblk
  0142b	48 8b fa	 mov	 rdi, rdx
  0142e	48 8b f1	 mov	 rsi, rcx
  01431	8b c8		 mov	 ecx, eax
  01433	f3 a4		 rep movsb

; 608  :                     }

  01435	eb 46		 jmp	 SHORT $LN96@main
$LN95@main:

; 609  :                     else // (32-bit CCKD)
; 610  :                     {
; 611  :                         memcpy( &freeblk32, &block32[i], size32 );

  01437	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR size32$[rsp]
  0143e	48 63 8c 24 30
	01 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  01446	48 8b 94 24 50
	04 00 00	 mov	 rdx, QWORD PTR block32$9[rsp]
  0144e	48 8d 0c ca	 lea	 rcx, QWORD PTR [rdx+rcx*8]
  01452	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:freeblk32
  01459	48 8b fa	 mov	 rdi, rdx
  0145c	48 8b f1	 mov	 rsi, rcx
  0145f	8b c8		 mov	 ecx, eax
  01461	f3 a4		 rep movsb

; 612  : 
; 613  :                         freeblk.fb_offnxt = freeblk32.fb_offnxt;

  01463	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR freeblk32
  01469	48 89 05 00 00
	00 00		 mov	 QWORD PTR freeblk, rax

; 614  :                         freeblk.fb_len    = freeblk32.fb_len;

  01470	8b 05 04 00 00
	00		 mov	 eax, DWORD PTR freeblk32+4
  01476	48 89 05 08 00
	00 00		 mov	 QWORD PTR freeblk+8, rax
$LN96@main:

; 615  :                     }
; 616  : 
; 617  :                     /* Add free space entry */
; 618  :                     spc.spc_typ  = SPCTAB_FREE;

  0147d	c6 84 24 f0 04
	00 00 07	 mov	 BYTE PTR spc$[rsp], 7

; 619  :                     spc.spc_off  = freeblk.fb_offset;

  01485	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR freeblk
  0148c	48 89 84 24 00
	05 00 00	 mov	 QWORD PTR spc$[rsp+16], rax

; 620  :                     spc.spc_siz  = freeblk.fb_len;

  01494	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR freeblk+8
  0149b	48 89 84 24 10
	05 00 00	 mov	 QWORD PTR spc$[rsp+32], rax

; 621  :                     spc.spc_len  = spc.spc_siz;

  014a3	48 8b 84 24 10
	05 00 00	 mov	 rax, QWORD PTR spc$[rsp+32]
  014ab	48 89 84 24 08
	05 00 00	 mov	 QWORD PTR spc$[rsp+24], rax

; 622  :                     spc.spc_val  = -1;

  014b3	c7 84 24 f4 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR spc$[rsp+4], -1

; 623  :                     spc.spc_val2 = -1;

  014be	c7 84 24 f8 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR spc$[rsp+8], -1

; 624  :                     ADD_SPACE( spc );

  014c9	48 8d 8c 24 f0
	04 00 00	 lea	 rcx, QWORD PTR spc$[rsp]
  014d1	e8 00 00 00 00	 call	 add_spc_to_table

; 625  :                 }

  014d6	e9 f9 fe ff ff	 jmp	 $LN8@main
$LN9@main:

; 626  :             }
; 627  : 
; 628  :             /* Clean up after ourselves */
; 629  :             free( freechain );

  014db	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR freechain$4[rsp]
  014e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 630  :         }

  014e9	e9 eb 02 00 00	 jmp	 $LN92@main
$LN91@main:

; 631  :         else // (old format: chase each free space block individually)
; 632  :         {
; 633  :             /* Read each entry in the chain one by one */
; 634  : 
; 635  :             freeblk.fb_offnxt = curpos; // (init pos of "next" block)

  014ee	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR curpos$[rsp]
  014f6	48 89 05 00 00
	00 00		 mov	 QWORD PTR freeblk, rax

; 636  : 
; 637  :             for (i=0; i < free_num; i++)

  014fd	c7 84 24 30 01
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  01508	eb 10		 jmp	 SHORT $LN13@main
$LN11@main:
  0150a	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  01511	ff c0		 inc	 eax
  01513	89 84 24 30 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN13@main:
  0151a	8b 84 24 94 01
	00 00		 mov	 eax, DWORD PTR free_num$3[rsp]
  01521	39 84 24 30 01
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  01528	0f 8d ab 02 00
	00		 jge	 $LN12@main

; 638  :             {
; 639  :                 /* Offset of next free space block in the chain */
; 640  :                 curpos = freeblk.fb_offnxt;

  0152e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR freeblk
  01535	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR curpos$[rsp], rax

; 641  : 
; 642  :                 if (lseek( fd, curpos, SEEK_SET ) < 0)

  0153d	45 33 c0	 xor	 r8d, r8d
  01540	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR curpos$[rsp]
  01548	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  0154f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  01555	48 85 c0	 test	 rax, rax
  01558	0f 8d 80 00 00
	00		 jge	 $LN97@main

; 643  :                 {
; 644  :                     // "%s error: %s"
; 645  :                     FWRMSG( stderr, HHC03006, "E", "lseek()", strerror( errno ));

  0155e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01564	8b 08		 mov	 ecx, DWORD PTR [rax]
  01566	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0156c	48 89 84 24 58
	04 00 00	 mov	 QWORD PTR tv811[rsp], rax
  01574	b9 02 00 00 00	 mov	 ecx, 2
  01579	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0157f	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR tv811[rsp]
  01587	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0158c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169103
  01593	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01598	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169104
  0159f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  015a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169105
  015ab	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  015b0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  015b5	41 b9 03 00 00
	00		 mov	 r9d, 3
  015bb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169106
  015c2	ba 85 02 00 00	 mov	 edx, 645		; 00000285H
  015c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169107
  015ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 646  :                     return -1;

  015d4	b8 ff ff ff ff	 mov	 eax, -1
  015d9	e9 56 33 00 00	 jmp	 $LN1@main
$LN97@main:

; 647  :                 }
; 648  : 
; 649  :                 if (cckd64)

  015de	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  015e5	85 c0		 test	 eax, eax
  015e7	0f 84 bc 00 00
	00		 je	 $LN98@main

; 650  :                 {
; 651  :                     if ((rc = read( fd, &freeblk, size )) < (int) size)

  015ed	44 8b 84 24 38
	01 00 00	 mov	 r8d, DWORD PTR size$[rsp]
  015f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:freeblk
  015fc	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  01603	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  01609	89 84 24 40 01
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  01610	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  01617	39 84 24 40 01
	00 00		 cmp	 DWORD PTR rc$[rsp], eax
  0161e	0f 8d 80 00 00
	00		 jge	 $LN100@main

; 652  :                     {
; 653  :                         // "%s error: %s"
; 654  :                         FWRMSG( stderr, HHC03006, "E", "read()", strerror( errno ));

  01624	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0162a	8b 08		 mov	 ecx, DWORD PTR [rax]
  0162c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01632	48 89 84 24 60
	04 00 00	 mov	 QWORD PTR tv832[rsp], rax
  0163a	b9 02 00 00 00	 mov	 ecx, 2
  0163f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01645	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR tv832[rsp]
  0164d	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01652	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169111
  01659	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0165e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169112
  01665	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0166a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169113
  01671	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01676	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0167b	41 b9 03 00 00
	00		 mov	 r9d, 3
  01681	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169114
  01688	ba 8e 02 00 00	 mov	 edx, 654		; 0000028eH
  0168d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169115
  01694	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 655  :                         return -1;

  0169a	b8 ff ff ff ff	 mov	 eax, -1
  0169f	e9 90 32 00 00	 jmp	 $LN1@main
$LN100@main:

; 656  :                     }
; 657  :                 }

  016a4	e9 d1 00 00 00	 jmp	 $LN99@main
$LN98@main:

; 658  :                 else // (32-bit CCKD)
; 659  :                 {
; 660  :                     if ((rc = read( fd, &freeblk32, size32 )) < (int) size32)

  016a9	44 8b 84 24 44
	01 00 00	 mov	 r8d, DWORD PTR size32$[rsp]
  016b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:freeblk32
  016b8	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  016bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  016c5	89 84 24 40 01
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  016cc	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR size32$[rsp]
  016d3	39 84 24 40 01
	00 00		 cmp	 DWORD PTR rc$[rsp], eax
  016da	0f 8d 80 00 00
	00		 jge	 $LN101@main

; 661  :                     {
; 662  :                         // "%s error: %s"
; 663  :                         FWRMSG( stderr, HHC03006, "E", "read()", strerror( errno ));

  016e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  016e6	8b 08		 mov	 ecx, DWORD PTR [rax]
  016e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  016ee	48 89 84 24 68
	04 00 00	 mov	 QWORD PTR tv851[rsp], rax
  016f6	b9 02 00 00 00	 mov	 ecx, 2
  016fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01701	48 8b 8c 24 68
	04 00 00	 mov	 rcx, QWORD PTR tv851[rsp]
  01709	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0170e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169117
  01715	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0171a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169118
  01721	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01726	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169119
  0172d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01732	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01737	41 b9 03 00 00
	00		 mov	 r9d, 3
  0173d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169120
  01744	ba 97 02 00 00	 mov	 edx, 663		; 00000297H
  01749	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169121
  01750	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 664  :                         return -1;

  01756	b8 ff ff ff ff	 mov	 eax, -1
  0175b	e9 d4 31 00 00	 jmp	 $LN1@main
$LN101@main:

; 665  :                     }
; 666  : 
; 667  :                     freeblk.fb_offnxt = freeblk32.fb_offnxt;

  01760	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR freeblk32
  01766	48 89 05 00 00
	00 00		 mov	 QWORD PTR freeblk, rax

; 668  :                     freeblk.fb_len    = freeblk32.fb_len;

  0176d	8b 05 04 00 00
	00		 mov	 eax, DWORD PTR freeblk32+4
  01773	48 89 05 08 00
	00 00		 mov	 QWORD PTR freeblk+8, rax
$LN99@main:

; 669  :                 }
; 670  : 
; 671  :                 /* Add free space entry */
; 672  :                 spc.spc_typ  = SPCTAB_FREE;

  0177a	c6 84 24 f0 04
	00 00 07	 mov	 BYTE PTR spc$[rsp], 7

; 673  :                 spc.spc_off  = curpos;

  01782	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR curpos$[rsp]
  0178a	48 89 84 24 00
	05 00 00	 mov	 QWORD PTR spc$[rsp+16], rax

; 674  :                 spc.spc_siz  = freeblk.fb_len;

  01792	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR freeblk+8
  01799	48 89 84 24 10
	05 00 00	 mov	 QWORD PTR spc$[rsp+32], rax

; 675  :                 spc.spc_len  = spc.spc_siz;

  017a1	48 8b 84 24 10
	05 00 00	 mov	 rax, QWORD PTR spc$[rsp+32]
  017a9	48 89 84 24 08
	05 00 00	 mov	 QWORD PTR spc$[rsp+24], rax

; 676  :                 spc.spc_val  = -1;

  017b1	c7 84 24 f4 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR spc$[rsp+4], -1

; 677  :                 spc.spc_val2 = -1;

  017bc	c7 84 24 f8 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR spc$[rsp+8], -1

; 678  :                 ADD_SPACE( spc );

  017c7	48 8d 8c 24 f0
	04 00 00	 lea	 rcx, QWORD PTR spc$[rsp]
  017cf	e8 00 00 00 00	 call	 add_spc_to_table

; 679  :             }

  017d4	e9 31 fd ff ff	 jmp	 $LN11@main
$LN12@main:
$LN92@main:
$LN83@main:

; 680  :         }
; 681  :     }
; 682  : 
; 683  :     /* Report the dasd device header fields */
; 684  : 
; 685  :     memcpy( ser, devhdr.dh_serial, sizeof( devhdr.dh_serial ));

  017d9	48 8d 84 24 20
	07 00 00	 lea	 rax, QWORD PTR ser$[rsp]
  017e1	48 8d 8c 24 34
	05 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+20]
  017e9	48 8b f8	 mov	 rdi, rax
  017ec	48 8b f1	 mov	 rsi, rcx
  017ef	b9 0c 00 00 00	 mov	 ecx, 12
  017f4	f3 a4		 rep movsb

; 686  : 
; 687  :     if (fba)

  017f6	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR fba
  017fd	85 c0		 test	 eax, eax
  017ff	0f 84 bc 01 00
	00		 je	 $LN102@main

; 688  :     {
; 689  :         // dh_devid:      %s        (%s-bit C%s%s %s)
; 690  :         // dh_heads:      %u         (total sectors)
; 691  :         // dh_trksize:    %u             (sector size)
; 692  :         // dh_devtyp:     0x%02.2X            (%s)
; 693  :         // dh_fileseq:    0x%02.2X
; 694  :         // dh_highcyl:    %u
; 695  :         // dh_serial:     %s
; 696  :         WRMSG( HHC03048, "I", dh_devid_str( imgtyp ),

  01805	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR shadow
  0180c	85 c0		 test	 eax, eax
  0180e	74 11		 je	 SHORT $LN170@main
  01810	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169124
  01817	48 89 84 24 88
	02 00 00	 mov	 QWORD PTR tv894[rsp], rax
  0181f	eb 0f		 jmp	 SHORT $LN171@main
$LN170@main:
  01821	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169125
  01828	48 89 84 24 88
	02 00 00	 mov	 QWORD PTR tv894[rsp], rax
$LN171@main:
  01830	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  01837	85 c0		 test	 eax, eax
  01839	74 11		 je	 SHORT $LN172@main
  0183b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169126
  01842	48 89 84 24 90
	02 00 00	 mov	 QWORD PTR tv898[rsp], rax
  0184a	eb 0f		 jmp	 SHORT $LN173@main
$LN172@main:
  0184c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169127
  01853	48 89 84 24 90
	02 00 00	 mov	 QWORD PTR tv898[rsp], rax
$LN173@main:
  0185b	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  01862	85 c0		 test	 eax, eax
  01864	74 11		 je	 SHORT $LN174@main
  01866	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169129
  0186d	48 89 84 24 98
	02 00 00	 mov	 QWORD PTR tv903[rsp], rax
  01875	eb 0f		 jmp	 SHORT $LN175@main
$LN174@main:
  01877	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169130
  0187e	48 89 84 24 98
	02 00 00	 mov	 QWORD PTR tv903[rsp], rax
$LN175@main:
  01886	48 8d 8c 24 32
	05 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+18]
  0188e	e8 00 00 00 00	 call	 fetch_hw_noswap
  01893	0f b7 c8	 movzx	 ecx, ax
  01896	e8 00 00 00 00	 call	 _byteswap_ushort
  0189b	0f b7 c0	 movzx	 eax, ax
  0189e	89 84 24 5c 02
	00 00		 mov	 DWORD PTR tv882[rsp], eax
  018a5	0f b6 8c 24 31
	05 00 00	 movzx	 ecx, BYTE PTR devhdr$[rsp+17]
  018ad	89 8c 24 64 02
	00 00		 mov	 DWORD PTR tv884[rsp], ecx
  018b4	0f b6 94 24 30
	05 00 00	 movzx	 edx, BYTE PTR devhdr$[rsp+16]
  018bc	89 94 24 68 02
	00 00		 mov	 DWORD PTR tv888[rsp], edx
  018c3	8b 8c 24 58 01
	00 00		 mov	 ecx, DWORD PTR imgtyp$[rsp]
  018ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dh_devid_str
  018d0	48 89 84 24 70
	04 00 00	 mov	 QWORD PTR tv905[rsp], rax
  018d8	b9 01 00 00 00	 mov	 ecx, 1
  018dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  018e3	48 8d 8c 24 20
	07 00 00	 lea	 rcx, QWORD PTR ser$[rsp]
  018eb	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rcx
  018f3	8b 8c 24 5c 02
	00 00		 mov	 ecx, DWORD PTR tv882[rsp]
  018fa	89 8c 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], ecx
  01901	8b 8c 24 64 02
	00 00		 mov	 ecx, DWORD PTR tv884[rsp]
  01908	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  0190f	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR fbatab$[rsp]
  01917	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0191a	48 89 4c 24 78	 mov	 QWORD PTR [rsp+120], rcx
  0191f	8b 8c 24 68 02
	00 00		 mov	 ecx, DWORD PTR tv888[rsp]
  01926	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  0192a	8b 8c 24 00 02
	00 00		 mov	 ecx, DWORD PTR trksize$[rsp]
  01931	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  01935	8b 8c 24 98 01
	00 00		 mov	 ecx, DWORD PTR heads$[rsp]
  0193c	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  01940	48 8b 8c 24 88
	02 00 00	 mov	 rcx, QWORD PTR tv894[rsp]
  01948	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0194d	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR tv898[rsp]
  01955	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0195a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169128
  01961	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01966	48 8b 8c 24 98
	02 00 00	 mov	 rcx, QWORD PTR tv903[rsp]
  0196e	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01973	48 8b 8c 24 70
	04 00 00	 mov	 rcx, QWORD PTR tv905[rsp]
  0197b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01980	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169131
  01987	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0198c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169132
  01993	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01998	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0199d	41 b9 03 00 00
	00		 mov	 r9d, 3
  019a3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169133
  019aa	ba c1 02 00 00	 mov	 edx, 705		; 000002c1H
  019af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169134
  019b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 697  :             cckd64 ? "64"          : "32",
; 698  :                      "FBA",
; 699  :             cckd64 ? "64"          : "",
; 700  :             shadow ? "shadow file" : "base image",
; 701  :             heads, trksize,
; 702  :             devhdr.dh_devtyp, fbatab->name,
; 703  :             devhdr.dh_fileseq,
; 704  :             fetch_hw( devhdr.dh_highcyl ),
; 705  :             ser );
; 706  :     }

  019bc	e9 b7 01 00 00	 jmp	 $LN103@main
$LN102@main:

; 707  :     else
; 708  :     {
; 709  :         // dh_devid:      %s        (%s-bit C%s%s %s)
; 710  :         // dh_heads:      %u
; 711  :         // dh_trksize:    %u
; 712  :         // dh_devtyp:     0x%02.2X            (%s)
; 713  :         // dh_fileseq:    0x%02.2X
; 714  :         // dh_highcyl:    %u
; 715  :         // dh_serial:     %s
; 716  :         WRMSG( HHC03022, "I", dh_devid_str( imgtyp ),

  019c1	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR shadow
  019c8	85 c0		 test	 eax, eax
  019ca	74 11		 je	 SHORT $LN176@main
  019cc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169135
  019d3	48 89 84 24 a0
	02 00 00	 mov	 QWORD PTR tv966[rsp], rax
  019db	eb 0f		 jmp	 SHORT $LN177@main
$LN176@main:
  019dd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169136
  019e4	48 89 84 24 a0
	02 00 00	 mov	 QWORD PTR tv966[rsp], rax
$LN177@main:
  019ec	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  019f3	85 c0		 test	 eax, eax
  019f5	74 11		 je	 SHORT $LN178@main
  019f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169137
  019fe	48 89 84 24 a8
	02 00 00	 mov	 QWORD PTR tv970[rsp], rax
  01a06	eb 0f		 jmp	 SHORT $LN179@main
$LN178@main:
  01a08	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169138
  01a0f	48 89 84 24 a8
	02 00 00	 mov	 QWORD PTR tv970[rsp], rax
$LN179@main:
  01a17	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  01a1e	85 c0		 test	 eax, eax
  01a20	74 11		 je	 SHORT $LN180@main
  01a22	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169140
  01a29	48 89 84 24 b0
	02 00 00	 mov	 QWORD PTR tv975[rsp], rax
  01a31	eb 0f		 jmp	 SHORT $LN181@main
$LN180@main:
  01a33	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169141
  01a3a	48 89 84 24 b0
	02 00 00	 mov	 QWORD PTR tv975[rsp], rax
$LN181@main:
  01a42	48 8d 8c 24 32
	05 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+18]
  01a4a	e8 00 00 00 00	 call	 fetch_hw_noswap
  01a4f	0f b7 c8	 movzx	 ecx, ax
  01a52	e8 00 00 00 00	 call	 _byteswap_ushort
  01a57	0f b7 c0	 movzx	 eax, ax
  01a5a	89 84 24 6c 02
	00 00		 mov	 DWORD PTR tv922[rsp], eax
  01a61	0f b6 8c 24 31
	05 00 00	 movzx	 ecx, BYTE PTR devhdr$[rsp+17]
  01a69	89 8c 24 28 02
	00 00		 mov	 DWORD PTR tv924[rsp], ecx
  01a70	0f b6 94 24 30
	05 00 00	 movzx	 edx, BYTE PTR devhdr$[rsp+16]
  01a78	89 94 24 2c 02
	00 00		 mov	 DWORD PTR tv960[rsp], edx
  01a7f	8b 8c 24 58 01
	00 00		 mov	 ecx, DWORD PTR imgtyp$[rsp]
  01a86	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dh_devid_str
  01a8c	48 89 84 24 78
	04 00 00	 mov	 QWORD PTR tv977[rsp], rax
  01a94	b9 01 00 00 00	 mov	 ecx, 1
  01a99	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01a9f	48 8d 8c 24 20
	07 00 00	 lea	 rcx, QWORD PTR ser$[rsp]
  01aa7	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rcx
  01aaf	8b 8c 24 6c 02
	00 00		 mov	 ecx, DWORD PTR tv922[rsp]
  01ab6	89 8c 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], ecx
  01abd	8b 8c 24 28 02
	00 00		 mov	 ecx, DWORD PTR tv924[rsp]
  01ac4	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  01acb	48 8b 8c 24 78
	02 00 00	 mov	 rcx, QWORD PTR ckdtab$[rsp]
  01ad3	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  01ad6	48 89 4c 24 78	 mov	 QWORD PTR [rsp+120], rcx
  01adb	8b 8c 24 2c 02
	00 00		 mov	 ecx, DWORD PTR tv960[rsp]
  01ae2	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  01ae6	8b 8c 24 00 02
	00 00		 mov	 ecx, DWORD PTR trksize$[rsp]
  01aed	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  01af1	8b 8c 24 98 01
	00 00		 mov	 ecx, DWORD PTR heads$[rsp]
  01af8	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  01afc	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR tv966[rsp]
  01b04	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01b09	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR tv970[rsp]
  01b11	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01b16	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169139
  01b1d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01b22	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR tv975[rsp]
  01b2a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01b2f	48 8b 8c 24 78
	04 00 00	 mov	 rcx, QWORD PTR tv977[rsp]
  01b37	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01b3c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169142
  01b43	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01b48	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169143
  01b4f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01b54	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01b59	41 b9 03 00 00
	00		 mov	 r9d, 3
  01b5f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169144
  01b66	ba d5 02 00 00	 mov	 edx, 725		; 000002d5H
  01b6b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169145
  01b72	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN103@main:

; 717  :             cckd64 ? "64"          : "32",
; 718  :                      "CKD",
; 719  :             cckd64 ? "64"          : "",
; 720  :             shadow ? "shadow file" : "base image",
; 721  :             heads, trksize,
; 722  :             devhdr.dh_devtyp, ckdtab->name,
; 723  :             devhdr.dh_fileseq,
; 724  :             fetch_hw( devhdr.dh_highcyl ),
; 725  :             ser );
; 726  :     }
; 727  : 
; 728  :     /* Report the compressed device header fields */
; 729  : 
; 730  :     len_size    = fmt_S64( str_size,    (S64) cdevhdr.cdh_size     );

  01b78	48 8b 15 10 00
	00 00		 mov	 rdx, QWORD PTR cdevhdr+16
  01b7f	48 8d 8c 24 90
	07 00 00	 lea	 rcx, QWORD PTR str_size$[rsp]
  01b87	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fmt_S64
  01b8d	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR len_size$[rsp], rax

; 731  :     len_used    = fmt_S64( str_used,    (S64) cdevhdr.cdh_used     );

  01b95	48 8b 15 18 00
	00 00		 mov	 rdx, QWORD PTR cdevhdr+24
  01b9c	48 8d 8c 24 30
	08 00 00	 lea	 rcx, QWORD PTR str_used$[rsp]
  01ba4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fmt_S64
  01baa	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR len_used$[rsp], rax

; 732  : 
; 733  :     len_total   = fmt_S64( str_total,   (S64) cdevhdr.free_total   );

  01bb2	48 8b 15 28 00
	00 00		 mov	 rdx, QWORD PTR cdevhdr+40
  01bb9	48 8d 8c 24 50
	07 00 00	 lea	 rcx, QWORD PTR str_total$[rsp]
  01bc1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fmt_S64
  01bc7	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR len_total$[rsp], rax

; 734  :     len_largest = fmt_S64( str_largest, (S64) cdevhdr.free_largest );

  01bcf	48 8b 15 30 00
	00 00		 mov	 rdx, QWORD PTR cdevhdr+48
  01bd6	48 8d 8c 24 f0
	07 00 00	 lea	 rcx, QWORD PTR str_largest$[rsp]
  01bde	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fmt_S64
  01be4	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR len_largest$[rsp], rax

; 735  : 
; 736  :     fmt_S64( track_range, (S64) tracks );

  01bec	48 63 84 24 68
	01 00 00	 movsxd	 rax, DWORD PTR tracks$[rsp]
  01bf4	48 8b d0	 mov	 rdx, rax
  01bf7	48 8d 8c 24 30
	07 00 00	 lea	 rcx, QWORD PTR track_range$[rsp]
  01bff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fmt_S64

; 737  : 
; 738  :     if (fba)

  01c05	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR fba
  01c0c	85 c0		 test	 eax, eax
  01c0e	0f 84 7a 05 00
	00		 je	 $LN104@main

; 739  :     {
; 740  :         // cdh_vrm:       %u.%u.%u
; 741  :         // cdh_opts:      0x%02.2X
; 742  :         // num_L1tab:     %"PRId32
; 743  :         // num_L2tab:     %"PRId32
; 744  :         // cdh_cyls:      %"PRIu32"           (%s blkgrps)
; 745  :         // cdh_size:      0x%10.10"PRIX64"    (%*s bytes)
; 746  :         // cdh_used:      0x%10.10"PRIX64"    (%*s bytes)
; 747  :         // free_off:      0x%10.10"PRIX64"    (%s format)
; 748  :         // free_total:    0x%10.10"PRIX64"    (%*s bytes)
; 749  :         // free_largest:  0x%10.10"PRIX64"    (%*s bytes)
; 750  :         // free_num:      %"PRId64
; 751  :         // free_imbed:    %"PRIu64
; 752  :         // cdh_nullfmt:   %u               (%s)
; 753  :         // cmp_algo:      %u               (%s)
; 754  :         // cmp_parm:      %"PRId16"              %s(%s)
; 755  : 
; 756  :         WRMSG( HHC03024, "I"

  01c14	0f bf 05 4a 00
	00 00		 movsx	 eax, WORD PTR cdevhdr+74
  01c1b	85 c0		 test	 eax, eax
  01c1d	7d 14		 jge	 SHORT $LN188@main
  01c1f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169148
  01c26	48 89 84 24 f0
	02 00 00	 mov	 QWORD PTR tv1017[rsp], rax
  01c2e	e9 95 00 00 00	 jmp	 $LN189@main
$LN188@main:
  01c33	0f bf 05 4a 00
	00 00		 movsx	 eax, WORD PTR cdevhdr+74
  01c3a	85 c0		 test	 eax, eax
  01c3c	75 11		 jne	 SHORT $LN186@main
  01c3e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169149
  01c45	48 89 84 24 c8
	02 00 00	 mov	 QWORD PTR tv1016[rsp], rax
  01c4d	eb 69		 jmp	 SHORT $LN187@main
$LN186@main:
  01c4f	0f bf 05 4a 00
	00 00		 movsx	 eax, WORD PTR cdevhdr+74
  01c56	83 f8 03	 cmp	 eax, 3
  01c59	7f 11		 jg	 SHORT $LN184@main
  01c5b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169150
  01c62	48 89 84 24 c0
	02 00 00	 mov	 QWORD PTR tv1015[rsp], rax
  01c6a	eb 3c		 jmp	 SHORT $LN185@main
$LN184@main:
  01c6c	0f bf 05 4a 00
	00 00		 movsx	 eax, WORD PTR cdevhdr+74
  01c73	83 f8 06	 cmp	 eax, 6
  01c76	7f 11		 jg	 SHORT $LN182@main
  01c78	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169151
  01c7f	48 89 84 24 b8
	02 00 00	 mov	 QWORD PTR tv1014[rsp], rax
  01c87	eb 0f		 jmp	 SHORT $LN183@main
$LN182@main:
  01c89	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169152
  01c90	48 89 84 24 b8
	02 00 00	 mov	 QWORD PTR tv1014[rsp], rax
$LN183@main:
  01c98	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR tv1014[rsp]
  01ca0	48 89 84 24 c0
	02 00 00	 mov	 QWORD PTR tv1015[rsp], rax
$LN185@main:
  01ca8	48 8b 84 24 c0
	02 00 00	 mov	 rax, QWORD PTR tv1015[rsp]
  01cb0	48 89 84 24 c8
	02 00 00	 mov	 QWORD PTR tv1016[rsp], rax
$LN187@main:
  01cb8	48 8b 84 24 c8
	02 00 00	 mov	 rax, QWORD PTR tv1016[rsp]
  01cc0	48 89 84 24 f0
	02 00 00	 mov	 QWORD PTR tv1017[rsp], rax
$LN189@main:
  01cc8	0f bf 05 4a 00
	00 00		 movsx	 eax, WORD PTR cdevhdr+74
  01ccf	85 c0		 test	 eax, eax
  01cd1	7d 11		 jge	 SHORT $LN190@main
  01cd3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169153
  01cda	48 89 84 24 f8
	02 00 00	 mov	 QWORD PTR tv1021[rsp], rax
  01ce2	eb 0f		 jmp	 SHORT $LN191@main
$LN190@main:
  01ce4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169154
  01ceb	48 89 84 24 f8
	02 00 00	 mov	 QWORD PTR tv1021[rsp], rax
$LN191@main:
  01cf3	0f b6 05 49 00
	00 00		 movzx	 eax, BYTE PTR cdevhdr+73
  01cfa	85 c0		 test	 eax, eax
  01cfc	75 0d		 jne	 SHORT $LN192@main
  01cfe	c7 84 24 04 02
	00 00 01 00 00
	00		 mov	 DWORD PTR tv1027[rsp], 1
  01d09	eb 0b		 jmp	 SHORT $LN193@main
$LN192@main:
  01d0b	c7 84 24 04 02
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1027[rsp], 0
$LN193@main:
  01d16	83 bc 24 04 02
	00 00 00	 cmp	 DWORD PTR tv1027[rsp], 0
  01d1e	74 11		 je	 SHORT $LN198@main
  01d20	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169155
  01d27	48 89 84 24 00
	03 00 00	 mov	 QWORD PTR tv1037[rsp], rax
  01d2f	eb 6d		 jmp	 SHORT $LN199@main
$LN198@main:
  01d31	0f b6 05 49 00
	00 00		 movzx	 eax, BYTE PTR cdevhdr+73
  01d38	83 e0 01	 and	 eax, 1
  01d3b	85 c0		 test	 eax, eax
  01d3d	74 11		 je	 SHORT $LN196@main
  01d3f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169156
  01d46	48 89 84 24 d8
	02 00 00	 mov	 QWORD PTR tv1035[rsp], rax
  01d4e	eb 3e		 jmp	 SHORT $LN197@main
$LN196@main:
  01d50	0f b6 05 49 00
	00 00		 movzx	 eax, BYTE PTR cdevhdr+73
  01d57	83 e0 02	 and	 eax, 2
  01d5a	85 c0		 test	 eax, eax
  01d5c	74 11		 je	 SHORT $LN194@main
  01d5e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169157
  01d65	48 89 84 24 d0
	02 00 00	 mov	 QWORD PTR tv1033[rsp], rax
  01d6d	eb 0f		 jmp	 SHORT $LN195@main
$LN194@main:
  01d6f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169158
  01d76	48 89 84 24 d0
	02 00 00	 mov	 QWORD PTR tv1033[rsp], rax
$LN195@main:
  01d7e	48 8b 84 24 d0
	02 00 00	 mov	 rax, QWORD PTR tv1033[rsp]
  01d86	48 89 84 24 d8
	02 00 00	 mov	 QWORD PTR tv1035[rsp], rax
$LN197@main:
  01d8e	48 8b 84 24 d8
	02 00 00	 mov	 rax, QWORD PTR tv1035[rsp]
  01d96	48 89 84 24 00
	03 00 00	 mov	 QWORD PTR tv1037[rsp], rax
$LN199@main:
  01d9e	0f b6 05 48 00
	00 00		 movzx	 eax, BYTE PTR cdevhdr+72
  01da5	85 c0		 test	 eax, eax
  01da7	75 11		 jne	 SHORT $LN204@main
  01da9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169159
  01db0	48 89 84 24 08
	03 00 00	 mov	 QWORD PTR tv1049[rsp], rax
  01db8	eb 69		 jmp	 SHORT $LN205@main
$LN204@main:
  01dba	0f b6 05 48 00
	00 00		 movzx	 eax, BYTE PTR cdevhdr+72
  01dc1	83 f8 01	 cmp	 eax, 1
  01dc4	75 11		 jne	 SHORT $LN202@main
  01dc6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169160
  01dcd	48 89 84 24 e8
	02 00 00	 mov	 QWORD PTR tv1048[rsp], rax
  01dd5	eb 3c		 jmp	 SHORT $LN203@main
$LN202@main:
  01dd7	0f b6 05 48 00
	00 00		 movzx	 eax, BYTE PTR cdevhdr+72
  01dde	83 f8 02	 cmp	 eax, 2
  01de1	75 11		 jne	 SHORT $LN200@main
  01de3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169161
  01dea	48 89 84 24 e0
	02 00 00	 mov	 QWORD PTR tv1047[rsp], rax
  01df2	eb 0f		 jmp	 SHORT $LN201@main
$LN200@main:
  01df4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169162
  01dfb	48 89 84 24 e0
	02 00 00	 mov	 QWORD PTR tv1047[rsp], rax
$LN201@main:
  01e03	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR tv1047[rsp]
  01e0b	48 89 84 24 e8
	02 00 00	 mov	 QWORD PTR tv1048[rsp], rax
$LN203@main:
  01e13	48 8b 84 24 e8
	02 00 00	 mov	 rax, QWORD PTR tv1048[rsp]
  01e1b	48 89 84 24 08
	03 00 00	 mov	 QWORD PTR tv1049[rsp], rax
$LN205@main:
  01e23	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR len_largest$[rsp]
  01e2b	48 39 84 24 78
	01 00 00	 cmp	 QWORD PTR len_total$[rsp], rax
  01e33	76 12		 jbe	 SHORT $LN206@main
  01e35	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR len_total$[rsp]
  01e3d	48 89 84 24 10
	03 00 00	 mov	 QWORD PTR tv1089[rsp], rax
  01e45	eb 10		 jmp	 SHORT $LN207@main
$LN206@main:
  01e47	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR len_largest$[rsp]
  01e4f	48 89 84 24 10
	03 00 00	 mov	 QWORD PTR tv1089[rsp], rax
$LN207@main:
  01e57	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR len_largest$[rsp]
  01e5f	48 39 84 24 78
	01 00 00	 cmp	 QWORD PTR len_total$[rsp], rax
  01e67	76 12		 jbe	 SHORT $LN208@main
  01e69	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR len_total$[rsp]
  01e71	48 89 84 24 18
	03 00 00	 mov	 QWORD PTR tv1095[rsp], rax
  01e79	eb 10		 jmp	 SHORT $LN209@main
$LN208@main:
  01e7b	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR len_largest$[rsp]
  01e83	48 89 84 24 18
	03 00 00	 mov	 QWORD PTR tv1095[rsp], rax
$LN209@main:
  01e8b	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR new_format
  01e92	85 c0		 test	 eax, eax
  01e94	74 11		 je	 SHORT $LN210@main
  01e96	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169163
  01e9d	48 89 84 24 20
	03 00 00	 mov	 QWORD PTR tv1101[rsp], rax
  01ea5	eb 0f		 jmp	 SHORT $LN211@main
$LN210@main:
  01ea7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169164
  01eae	48 89 84 24 20
	03 00 00	 mov	 QWORD PTR tv1101[rsp], rax
$LN211@main:
  01eb6	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR len_size$[rsp]
  01ebe	48 39 84 24 88
	01 00 00	 cmp	 QWORD PTR len_used$[rsp], rax
  01ec6	76 12		 jbe	 SHORT $LN212@main
  01ec8	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR len_used$[rsp]
  01ed0	48 89 84 24 28
	03 00 00	 mov	 QWORD PTR tv1106[rsp], rax
  01ed8	eb 10		 jmp	 SHORT $LN213@main
$LN212@main:
  01eda	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR len_size$[rsp]
  01ee2	48 89 84 24 28
	03 00 00	 mov	 QWORD PTR tv1106[rsp], rax
$LN213@main:
  01eea	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR len_used$[rsp]
  01ef2	48 39 84 24 80
	01 00 00	 cmp	 QWORD PTR len_size$[rsp], rax
  01efa	76 12		 jbe	 SHORT $LN214@main
  01efc	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR len_size$[rsp]
  01f04	48 89 84 24 30
	03 00 00	 mov	 QWORD PTR tv1112[rsp], rax
  01f0c	eb 10		 jmp	 SHORT $LN215@main
$LN214@main:
  01f0e	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR len_used$[rsp]
  01f16	48 89 84 24 30
	03 00 00	 mov	 QWORD PTR tv1112[rsp], rax
$LN215@main:
  01f1e	0f bf 05 4a 00
	00 00		 movsx	 eax, WORD PTR cdevhdr+74
  01f25	89 84 24 30 02
	00 00		 mov	 DWORD PTR tv1023[rsp], eax
  01f2c	0f b6 0d 49 00
	00 00		 movzx	 ecx, BYTE PTR cdevhdr+73
  01f33	89 8c 24 34 02
	00 00		 mov	 DWORD PTR tv1039[rsp], ecx
  01f3a	0f b6 15 48 00
	00 00		 movzx	 edx, BYTE PTR cdevhdr+72
  01f41	89 94 24 38 02
	00 00		 mov	 DWORD PTR tv1051[rsp], edx
  01f48	0f b6 3d 03 00
	00 00		 movzx	 edi, BYTE PTR cdevhdr+3
  01f4f	be 01 00 00 00	 mov	 esi, 1
  01f54	48 6b f6 02	 imul	 rsi, rsi, 2
  01f58	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cdevhdr
  01f5f	41 0f b6 34 30	 movzx	 esi, BYTE PTR [r8+rsi]
  01f64	41 b8 01 00 00
	00		 mov	 r8d, 1
  01f6a	4d 6b c0 01	 imul	 r8, r8, 1
  01f6e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:cdevhdr
  01f75	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  01f7a	44 89 84 24 3c
	02 00 00	 mov	 DWORD PTR tv1128[rsp], r8d
  01f82	41 b9 01 00 00
	00		 mov	 r9d, 1
  01f88	4d 6b c9 00	 imul	 r9, r9, 0
  01f8c	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:cdevhdr
  01f93	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  01f98	44 89 8c 24 60
	02 00 00	 mov	 DWORD PTR tv1132[rsp], r9d
  01fa0	b9 01 00 00 00	 mov	 ecx, 1
  01fa5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01fab	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR tv1017[rsp]
  01fb3	48 89 8c 24 28
	01 00 00	 mov	 QWORD PTR [rsp+296], rcx
  01fbb	48 8b 8c 24 f8
	02 00 00	 mov	 rcx, QWORD PTR tv1021[rsp]
  01fc3	48 89 8c 24 20
	01 00 00	 mov	 QWORD PTR [rsp+288], rcx
  01fcb	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR tv1023[rsp]
  01fd2	89 8c 24 18 01
	00 00		 mov	 DWORD PTR [rsp+280], ecx
  01fd9	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR tv1037[rsp]
  01fe1	48 89 8c 24 10
	01 00 00	 mov	 QWORD PTR [rsp+272], rcx
  01fe9	8b 8c 24 34 02
	00 00		 mov	 ecx, DWORD PTR tv1039[rsp]
  01ff0	89 8c 24 08 01
	00 00		 mov	 DWORD PTR [rsp+264], ecx
  01ff7	48 8b 8c 24 08
	03 00 00	 mov	 rcx, QWORD PTR tv1049[rsp]
  01fff	48 89 8c 24 00
	01 00 00	 mov	 QWORD PTR [rsp+256], rcx
  02007	8b 8c 24 38 02
	00 00		 mov	 ecx, DWORD PTR tv1051[rsp]
  0200e	89 8c 24 f8 00
	00 00		 mov	 DWORD PTR [rsp+248], ecx
  02015	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR cdevhdr+64
  0201c	48 89 8c 24 f0
	00 00 00	 mov	 QWORD PTR [rsp+240], rcx
  02024	48 8b 0d 38 00
	00 00		 mov	 rcx, QWORD PTR cdevhdr+56
  0202b	48 89 8c 24 e8
	00 00 00	 mov	 QWORD PTR [rsp+232], rcx
  02033	48 8d 8c 24 f0
	07 00 00	 lea	 rcx, QWORD PTR str_largest$[rsp]
  0203b	48 89 8c 24 e0
	00 00 00	 mov	 QWORD PTR [rsp+224], rcx
  02043	8b 8c 24 10 03
	00 00		 mov	 ecx, DWORD PTR tv1089[rsp]
  0204a	89 8c 24 d8 00
	00 00		 mov	 DWORD PTR [rsp+216], ecx
  02051	48 8b 0d 30 00
	00 00		 mov	 rcx, QWORD PTR cdevhdr+48
  02058	48 89 8c 24 d0
	00 00 00	 mov	 QWORD PTR [rsp+208], rcx
  02060	48 8d 8c 24 50
	07 00 00	 lea	 rcx, QWORD PTR str_total$[rsp]
  02068	48 89 8c 24 c8
	00 00 00	 mov	 QWORD PTR [rsp+200], rcx
  02070	8b 8c 24 18 03
	00 00		 mov	 ecx, DWORD PTR tv1095[rsp]
  02077	89 8c 24 c0 00
	00 00		 mov	 DWORD PTR [rsp+192], ecx
  0207e	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR cdevhdr+40
  02085	48 89 8c 24 b8
	00 00 00	 mov	 QWORD PTR [rsp+184], rcx
  0208d	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR tv1101[rsp]
  02095	48 89 8c 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], rcx
  0209d	48 8b 0d 20 00
	00 00		 mov	 rcx, QWORD PTR cdevhdr+32
  020a4	48 89 8c 24 a8
	00 00 00	 mov	 QWORD PTR [rsp+168], rcx
  020ac	48 8d 8c 24 30
	08 00 00	 lea	 rcx, QWORD PTR str_used$[rsp]
  020b4	48 89 8c 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rcx
  020bc	8b 8c 24 28 03
	00 00		 mov	 ecx, DWORD PTR tv1106[rsp]
  020c3	89 8c 24 98 00
	00 00		 mov	 DWORD PTR [rsp+152], ecx
  020ca	48 8b 0d 18 00
	00 00		 mov	 rcx, QWORD PTR cdevhdr+24
  020d1	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rcx
  020d9	48 8d 8c 24 90
	07 00 00	 lea	 rcx, QWORD PTR str_size$[rsp]
  020e1	48 89 8c 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rcx
  020e9	8b 8c 24 30 03
	00 00		 mov	 ecx, DWORD PTR tv1112[rsp]
  020f0	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  020f7	48 8b 0d 10 00
	00 00		 mov	 rcx, QWORD PTR cdevhdr+16
  020fe	48 89 4c 24 78	 mov	 QWORD PTR [rsp+120], rcx
  02103	48 8d 8c 24 30
	07 00 00	 lea	 rcx, QWORD PTR track_range$[rsp]
  0210b	48 89 4c 24 70	 mov	 QWORD PTR [rsp+112], rcx
  02110	8b 8c 24 5c 01
	00 00		 mov	 ecx, DWORD PTR cyls$[rsp]
  02117	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  0211b	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR cdevhdr+8
  02121	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  02125	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR cdevhdr+4
  0212b	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0212f	89 7c 24 50	 mov	 DWORD PTR [rsp+80], edi
  02133	89 74 24 48	 mov	 DWORD PTR [rsp+72], esi
  02137	8b 8c 24 3c 02
	00 00		 mov	 ecx, DWORD PTR tv1128[rsp]
  0213e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  02142	8b 8c 24 60 02
	00 00		 mov	 ecx, DWORD PTR tv1132[rsp]
  02149	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0214d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169165
  02154	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  02159	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169166
  02160	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02165	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0216a	41 b9 03 00 00
	00		 mov	 r9d, 3
  02170	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169167
  02177	ba 0d 03 00 00	 mov	 edx, 781		; 0000030dH
  0217c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169168
  02183	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 757  :             , (U32) cdevhdr.cdh_vrm[0], (U32) cdevhdr.cdh_vrm[1], (U32) cdevhdr.cdh_vrm[2]
; 758  :             , cdevhdr.cdh_opts
; 759  :             , cdevhdr.num_L1tab
; 760  :             , cdevhdr.num_L2tab
; 761  :             , cyls, track_range
; 762  :             , cdevhdr.cdh_size, (int) max( len_size, len_used ), str_size
; 763  :             , cdevhdr.cdh_used, (int) max( len_used, len_size ), str_used
; 764  :             , cdevhdr.free_off, new_format ? "NEW" : "old"
; 765  :             , cdevhdr.free_total,   (int) max( len_total, len_largest ), str_total
; 766  :             , cdevhdr.free_largest, (int) max( len_total, len_largest ), str_largest
; 767  :             , cdevhdr.free_num
; 768  :             , cdevhdr.free_imbed
; 769  :             , (U32) cdevhdr.cdh_nullfmt, cdevhdr.cdh_nullfmt == CKD_NULLTRK_FMT0 ? "ha r0 EOF" :
; 770  :                                          cdevhdr.cdh_nullfmt == CKD_NULLTRK_FMT1 ? "ha r0" :
; 771  :                                          cdevhdr.cdh_nullfmt == CKD_NULLTRK_FMT2 ? "linux" : "???"
; 772  :             , (U32) cdevhdr.cmp_algo,   !cdevhdr.cmp_algo                        ? "none"  :
; 773  :                                         (cdevhdr.cmp_algo & CCKD_COMPRESS_ZLIB)  ? "zlib"  :
; 774  :                                         (cdevhdr.cmp_algo & CCKD_COMPRESS_BZIP2) ? "bzip2" : "INVALID"
; 775  :             , cdevhdr.cmp_parm
; 776  :             , cdevhdr.cmp_parm <  0 ? ""        : " "
; 777  :             , cdevhdr.cmp_parm <  0 ? "default" :
; 778  :               cdevhdr.cmp_parm == 0 ? "none"    :
; 779  :               cdevhdr.cmp_parm <= 3 ? "low"     :
; 780  :               cdevhdr.cmp_parm <= 6 ? "medium"  : "high"
; 781  :         );
; 782  :     }

  02189	e9 75 05 00 00	 jmp	 $LN105@main
$LN104@main:

; 783  :     else
; 784  :     {
; 785  :         // cdh_vrm:       %u.%u.%u
; 786  :         // cdh_opts:      0x%02.2X
; 787  :         // num_L1tab:     %"PRId32
; 788  :         // num_L2tab:     %"PRId32
; 789  :         // cdh_cyls:      %"PRIu32"           (%s tracks)
; 790  :         // cdh_size:      0x%10.10"PRIX64"    (%*s bytes)
; 791  :         // cdh_used:      0x%10.10"PRIX64"    (%*s bytes)
; 792  :         // free_off:      0x%10.10"PRIX64"    (%s format)
; 793  :         // free_total:    0x%10.10"PRIX64"    (%*s bytes)
; 794  :         // free_largest:  0x%10.10"PRIX64"    (%*s bytes)
; 795  :         // free_num:      %"PRId64
; 796  :         // free_imbed:    %"PRIu64
; 797  :         // cdh_nullfmt:   %u               (%s)
; 798  :         // cmp_algo:      %u               (%s)
; 799  :         // cmp_parm:      %"PRId16"              %s(%s)
; 800  : 
; 801  :         WRMSG( HHC03023, "I"

  0218e	0f bf 05 4a 00
	00 00		 movsx	 eax, WORD PTR cdevhdr+74
  02195	85 c0		 test	 eax, eax
  02197	7d 14		 jge	 SHORT $LN222@main
  02199	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169169
  021a0	48 89 84 24 70
	03 00 00	 mov	 QWORD PTR tv1154[rsp], rax
  021a8	e9 95 00 00 00	 jmp	 $LN223@main
$LN222@main:
  021ad	0f bf 05 4a 00
	00 00		 movsx	 eax, WORD PTR cdevhdr+74
  021b4	85 c0		 test	 eax, eax
  021b6	75 11		 jne	 SHORT $LN220@main
  021b8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169170
  021bf	48 89 84 24 48
	03 00 00	 mov	 QWORD PTR tv1153[rsp], rax
  021c7	eb 69		 jmp	 SHORT $LN221@main
$LN220@main:
  021c9	0f bf 05 4a 00
	00 00		 movsx	 eax, WORD PTR cdevhdr+74
  021d0	83 f8 03	 cmp	 eax, 3
  021d3	7f 11		 jg	 SHORT $LN218@main
  021d5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169171
  021dc	48 89 84 24 40
	03 00 00	 mov	 QWORD PTR tv1152[rsp], rax
  021e4	eb 3c		 jmp	 SHORT $LN219@main
$LN218@main:
  021e6	0f bf 05 4a 00
	00 00		 movsx	 eax, WORD PTR cdevhdr+74
  021ed	83 f8 06	 cmp	 eax, 6
  021f0	7f 11		 jg	 SHORT $LN216@main
  021f2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169172
  021f9	48 89 84 24 38
	03 00 00	 mov	 QWORD PTR tv1151[rsp], rax
  02201	eb 0f		 jmp	 SHORT $LN217@main
$LN216@main:
  02203	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169173
  0220a	48 89 84 24 38
	03 00 00	 mov	 QWORD PTR tv1151[rsp], rax
$LN217@main:
  02212	48 8b 84 24 38
	03 00 00	 mov	 rax, QWORD PTR tv1151[rsp]
  0221a	48 89 84 24 40
	03 00 00	 mov	 QWORD PTR tv1152[rsp], rax
$LN219@main:
  02222	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR tv1152[rsp]
  0222a	48 89 84 24 48
	03 00 00	 mov	 QWORD PTR tv1153[rsp], rax
$LN221@main:
  02232	48 8b 84 24 48
	03 00 00	 mov	 rax, QWORD PTR tv1153[rsp]
  0223a	48 89 84 24 70
	03 00 00	 mov	 QWORD PTR tv1154[rsp], rax
$LN223@main:
  02242	0f bf 05 4a 00
	00 00		 movsx	 eax, WORD PTR cdevhdr+74
  02249	85 c0		 test	 eax, eax
  0224b	7d 11		 jge	 SHORT $LN224@main
  0224d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169174
  02254	48 89 84 24 78
	03 00 00	 mov	 QWORD PTR tv1158[rsp], rax
  0225c	eb 0f		 jmp	 SHORT $LN225@main
$LN224@main:
  0225e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169175
  02265	48 89 84 24 78
	03 00 00	 mov	 QWORD PTR tv1158[rsp], rax
$LN225@main:
  0226d	0f b6 05 49 00
	00 00		 movzx	 eax, BYTE PTR cdevhdr+73
  02274	85 c0		 test	 eax, eax
  02276	75 0d		 jne	 SHORT $LN226@main
  02278	c7 84 24 08 02
	00 00 01 00 00
	00		 mov	 DWORD PTR tv1164[rsp], 1
  02283	eb 0b		 jmp	 SHORT $LN227@main
$LN226@main:
  02285	c7 84 24 08 02
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1164[rsp], 0
$LN227@main:
  02290	83 bc 24 08 02
	00 00 00	 cmp	 DWORD PTR tv1164[rsp], 0
  02298	74 11		 je	 SHORT $LN232@main
  0229a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169176
  022a1	48 89 84 24 80
	03 00 00	 mov	 QWORD PTR tv1174[rsp], rax
  022a9	eb 6d		 jmp	 SHORT $LN233@main
$LN232@main:
  022ab	0f b6 05 49 00
	00 00		 movzx	 eax, BYTE PTR cdevhdr+73
  022b2	83 e0 01	 and	 eax, 1
  022b5	85 c0		 test	 eax, eax
  022b7	74 11		 je	 SHORT $LN230@main
  022b9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169177
  022c0	48 89 84 24 58
	03 00 00	 mov	 QWORD PTR tv1172[rsp], rax
  022c8	eb 3e		 jmp	 SHORT $LN231@main
$LN230@main:
  022ca	0f b6 05 49 00
	00 00		 movzx	 eax, BYTE PTR cdevhdr+73
  022d1	83 e0 02	 and	 eax, 2
  022d4	85 c0		 test	 eax, eax
  022d6	74 11		 je	 SHORT $LN228@main
  022d8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169178
  022df	48 89 84 24 50
	03 00 00	 mov	 QWORD PTR tv1170[rsp], rax
  022e7	eb 0f		 jmp	 SHORT $LN229@main
$LN228@main:
  022e9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169179
  022f0	48 89 84 24 50
	03 00 00	 mov	 QWORD PTR tv1170[rsp], rax
$LN229@main:
  022f8	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR tv1170[rsp]
  02300	48 89 84 24 58
	03 00 00	 mov	 QWORD PTR tv1172[rsp], rax
$LN231@main:
  02308	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR tv1172[rsp]
  02310	48 89 84 24 80
	03 00 00	 mov	 QWORD PTR tv1174[rsp], rax
$LN233@main:
  02318	0f b6 05 48 00
	00 00		 movzx	 eax, BYTE PTR cdevhdr+72
  0231f	85 c0		 test	 eax, eax
  02321	75 11		 jne	 SHORT $LN238@main
  02323	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169180
  0232a	48 89 84 24 88
	03 00 00	 mov	 QWORD PTR tv1218[rsp], rax
  02332	eb 69		 jmp	 SHORT $LN239@main
$LN238@main:
  02334	0f b6 05 48 00
	00 00		 movzx	 eax, BYTE PTR cdevhdr+72
  0233b	83 f8 01	 cmp	 eax, 1
  0233e	75 11		 jne	 SHORT $LN236@main
  02340	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169181
  02347	48 89 84 24 68
	03 00 00	 mov	 QWORD PTR tv1217[rsp], rax
  0234f	eb 3c		 jmp	 SHORT $LN237@main
$LN236@main:
  02351	0f b6 05 48 00
	00 00		 movzx	 eax, BYTE PTR cdevhdr+72
  02358	83 f8 02	 cmp	 eax, 2
  0235b	75 11		 jne	 SHORT $LN234@main
  0235d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169182
  02364	48 89 84 24 60
	03 00 00	 mov	 QWORD PTR tv1216[rsp], rax
  0236c	eb 0f		 jmp	 SHORT $LN235@main
$LN234@main:
  0236e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169183
  02375	48 89 84 24 60
	03 00 00	 mov	 QWORD PTR tv1216[rsp], rax
$LN235@main:
  0237d	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR tv1216[rsp]
  02385	48 89 84 24 68
	03 00 00	 mov	 QWORD PTR tv1217[rsp], rax
$LN237@main:
  0238d	48 8b 84 24 68
	03 00 00	 mov	 rax, QWORD PTR tv1217[rsp]
  02395	48 89 84 24 88
	03 00 00	 mov	 QWORD PTR tv1218[rsp], rax
$LN239@main:
  0239d	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR len_largest$[rsp]
  023a5	48 39 84 24 78
	01 00 00	 cmp	 QWORD PTR len_total$[rsp], rax
  023ad	76 12		 jbe	 SHORT $LN240@main
  023af	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR len_total$[rsp]
  023b7	48 89 84 24 90
	03 00 00	 mov	 QWORD PTR tv1226[rsp], rax
  023bf	eb 10		 jmp	 SHORT $LN241@main
$LN240@main:
  023c1	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR len_largest$[rsp]
  023c9	48 89 84 24 90
	03 00 00	 mov	 QWORD PTR tv1226[rsp], rax
$LN241@main:
  023d1	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR len_largest$[rsp]
  023d9	48 39 84 24 78
	01 00 00	 cmp	 QWORD PTR len_total$[rsp], rax
  023e1	76 12		 jbe	 SHORT $LN242@main
  023e3	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR len_total$[rsp]
  023eb	48 89 84 24 98
	03 00 00	 mov	 QWORD PTR tv1232[rsp], rax
  023f3	eb 10		 jmp	 SHORT $LN243@main
$LN242@main:
  023f5	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR len_largest$[rsp]
  023fd	48 89 84 24 98
	03 00 00	 mov	 QWORD PTR tv1232[rsp], rax
$LN243@main:
  02405	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR new_format
  0240c	85 c0		 test	 eax, eax
  0240e	74 11		 je	 SHORT $LN244@main
  02410	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169184
  02417	48 89 84 24 a0
	03 00 00	 mov	 QWORD PTR tv1238[rsp], rax
  0241f	eb 0f		 jmp	 SHORT $LN245@main
$LN244@main:
  02421	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169185
  02428	48 89 84 24 a0
	03 00 00	 mov	 QWORD PTR tv1238[rsp], rax
$LN245@main:
  02430	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR len_size$[rsp]
  02438	48 39 84 24 88
	01 00 00	 cmp	 QWORD PTR len_used$[rsp], rax
  02440	76 12		 jbe	 SHORT $LN246@main
  02442	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR len_used$[rsp]
  0244a	48 89 84 24 a8
	03 00 00	 mov	 QWORD PTR tv1243[rsp], rax
  02452	eb 10		 jmp	 SHORT $LN247@main
$LN246@main:
  02454	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR len_size$[rsp]
  0245c	48 89 84 24 a8
	03 00 00	 mov	 QWORD PTR tv1243[rsp], rax
$LN247@main:
  02464	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR len_used$[rsp]
  0246c	48 39 84 24 80
	01 00 00	 cmp	 QWORD PTR len_size$[rsp], rax
  02474	76 12		 jbe	 SHORT $LN248@main
  02476	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR len_size$[rsp]
  0247e	48 89 84 24 b0
	03 00 00	 mov	 QWORD PTR tv1249[rsp], rax
  02486	eb 10		 jmp	 SHORT $LN249@main
$LN248@main:
  02488	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR len_used$[rsp]
  02490	48 89 84 24 b0
	03 00 00	 mov	 QWORD PTR tv1249[rsp], rax
$LN249@main:
  02498	0f bf 05 4a 00
	00 00		 movsx	 eax, WORD PTR cdevhdr+74
  0249f	89 84 24 44 02
	00 00		 mov	 DWORD PTR tv1160[rsp], eax
  024a6	0f b6 0d 49 00
	00 00		 movzx	 ecx, BYTE PTR cdevhdr+73
  024ad	89 8c 24 48 02
	00 00		 mov	 DWORD PTR tv1176[rsp], ecx
  024b4	0f b6 15 48 00
	00 00		 movzx	 edx, BYTE PTR cdevhdr+72
  024bb	89 94 24 4c 02
	00 00		 mov	 DWORD PTR tv1220[rsp], edx
  024c2	0f b6 3d 03 00
	00 00		 movzx	 edi, BYTE PTR cdevhdr+3
  024c9	be 01 00 00 00	 mov	 esi, 1
  024ce	48 6b f6 02	 imul	 rsi, rsi, 2
  024d2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cdevhdr
  024d9	41 0f b6 34 30	 movzx	 esi, BYTE PTR [r8+rsi]
  024de	41 b8 01 00 00
	00		 mov	 r8d, 1
  024e4	4d 6b c0 01	 imul	 r8, r8, 1
  024e8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:cdevhdr
  024ef	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  024f4	44 89 84 24 50
	02 00 00	 mov	 DWORD PTR tv1265[rsp], r8d
  024fc	41 b9 01 00 00
	00		 mov	 r9d, 1
  02502	4d 6b c9 00	 imul	 r9, r9, 0
  02506	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:cdevhdr
  0250d	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  02512	44 89 8c 24 54
	02 00 00	 mov	 DWORD PTR tv1269[rsp], r9d
  0251a	b9 01 00 00 00	 mov	 ecx, 1
  0251f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02525	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR tv1154[rsp]
  0252d	48 89 8c 24 28
	01 00 00	 mov	 QWORD PTR [rsp+296], rcx
  02535	48 8b 8c 24 78
	03 00 00	 mov	 rcx, QWORD PTR tv1158[rsp]
  0253d	48 89 8c 24 20
	01 00 00	 mov	 QWORD PTR [rsp+288], rcx
  02545	8b 8c 24 44 02
	00 00		 mov	 ecx, DWORD PTR tv1160[rsp]
  0254c	89 8c 24 18 01
	00 00		 mov	 DWORD PTR [rsp+280], ecx
  02553	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR tv1174[rsp]
  0255b	48 89 8c 24 10
	01 00 00	 mov	 QWORD PTR [rsp+272], rcx
  02563	8b 8c 24 48 02
	00 00		 mov	 ecx, DWORD PTR tv1176[rsp]
  0256a	89 8c 24 08 01
	00 00		 mov	 DWORD PTR [rsp+264], ecx
  02571	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR tv1218[rsp]
  02579	48 89 8c 24 00
	01 00 00	 mov	 QWORD PTR [rsp+256], rcx
  02581	8b 8c 24 4c 02
	00 00		 mov	 ecx, DWORD PTR tv1220[rsp]
  02588	89 8c 24 f8 00
	00 00		 mov	 DWORD PTR [rsp+248], ecx
  0258f	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR cdevhdr+64
  02596	48 89 8c 24 f0
	00 00 00	 mov	 QWORD PTR [rsp+240], rcx
  0259e	48 8b 0d 38 00
	00 00		 mov	 rcx, QWORD PTR cdevhdr+56
  025a5	48 89 8c 24 e8
	00 00 00	 mov	 QWORD PTR [rsp+232], rcx
  025ad	48 8d 8c 24 f0
	07 00 00	 lea	 rcx, QWORD PTR str_largest$[rsp]
  025b5	48 89 8c 24 e0
	00 00 00	 mov	 QWORD PTR [rsp+224], rcx
  025bd	8b 8c 24 90 03
	00 00		 mov	 ecx, DWORD PTR tv1226[rsp]
  025c4	89 8c 24 d8 00
	00 00		 mov	 DWORD PTR [rsp+216], ecx
  025cb	48 8b 0d 30 00
	00 00		 mov	 rcx, QWORD PTR cdevhdr+48
  025d2	48 89 8c 24 d0
	00 00 00	 mov	 QWORD PTR [rsp+208], rcx
  025da	48 8d 8c 24 50
	07 00 00	 lea	 rcx, QWORD PTR str_total$[rsp]
  025e2	48 89 8c 24 c8
	00 00 00	 mov	 QWORD PTR [rsp+200], rcx
  025ea	8b 8c 24 98 03
	00 00		 mov	 ecx, DWORD PTR tv1232[rsp]
  025f1	89 8c 24 c0 00
	00 00		 mov	 DWORD PTR [rsp+192], ecx
  025f8	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR cdevhdr+40
  025ff	48 89 8c 24 b8
	00 00 00	 mov	 QWORD PTR [rsp+184], rcx
  02607	48 8b 8c 24 a0
	03 00 00	 mov	 rcx, QWORD PTR tv1238[rsp]
  0260f	48 89 8c 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], rcx
  02617	48 8b 0d 20 00
	00 00		 mov	 rcx, QWORD PTR cdevhdr+32
  0261e	48 89 8c 24 a8
	00 00 00	 mov	 QWORD PTR [rsp+168], rcx
  02626	48 8d 8c 24 30
	08 00 00	 lea	 rcx, QWORD PTR str_used$[rsp]
  0262e	48 89 8c 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rcx
  02636	8b 8c 24 a8 03
	00 00		 mov	 ecx, DWORD PTR tv1243[rsp]
  0263d	89 8c 24 98 00
	00 00		 mov	 DWORD PTR [rsp+152], ecx
  02644	48 8b 0d 18 00
	00 00		 mov	 rcx, QWORD PTR cdevhdr+24
  0264b	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rcx
  02653	48 8d 8c 24 90
	07 00 00	 lea	 rcx, QWORD PTR str_size$[rsp]
  0265b	48 89 8c 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rcx
  02663	8b 8c 24 b0 03
	00 00		 mov	 ecx, DWORD PTR tv1249[rsp]
  0266a	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  02671	48 8b 0d 10 00
	00 00		 mov	 rcx, QWORD PTR cdevhdr+16
  02678	48 89 4c 24 78	 mov	 QWORD PTR [rsp+120], rcx
  0267d	48 8d 8c 24 30
	07 00 00	 lea	 rcx, QWORD PTR track_range$[rsp]
  02685	48 89 4c 24 70	 mov	 QWORD PTR [rsp+112], rcx
  0268a	8b 8c 24 5c 01
	00 00		 mov	 ecx, DWORD PTR cyls$[rsp]
  02691	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  02695	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR cdevhdr+8
  0269b	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  0269f	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR cdevhdr+4
  026a5	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  026a9	89 7c 24 50	 mov	 DWORD PTR [rsp+80], edi
  026ad	89 74 24 48	 mov	 DWORD PTR [rsp+72], esi
  026b1	8b 8c 24 50 02
	00 00		 mov	 ecx, DWORD PTR tv1265[rsp]
  026b8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  026bc	8b 8c 24 54 02
	00 00		 mov	 ecx, DWORD PTR tv1269[rsp]
  026c3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  026c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169186
  026ce	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  026d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169187
  026da	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  026df	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  026e4	41 b9 03 00 00
	00		 mov	 r9d, 3
  026ea	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169188
  026f1	ba 3a 03 00 00	 mov	 edx, 826		; 0000033aH
  026f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169189
  026fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN105@main:

; 802  :             , (U32) cdevhdr.cdh_vrm[0], (U32) cdevhdr.cdh_vrm[1], (U32) cdevhdr.cdh_vrm[2]
; 803  :             , cdevhdr.cdh_opts
; 804  :             , cdevhdr.num_L1tab
; 805  :             , cdevhdr.num_L2tab
; 806  :             , cyls, track_range
; 807  :             , cdevhdr.cdh_size, (int) max( len_size, len_used ), str_size
; 808  :             , cdevhdr.cdh_used, (int) max( len_used, len_size ), str_used
; 809  :             , cdevhdr.free_off, new_format ? "NEW" : "old"
; 810  :             , cdevhdr.free_total,   (int) max( len_total, len_largest ), str_total
; 811  :             , cdevhdr.free_largest, (int) max( len_total, len_largest ), str_largest
; 812  :             , cdevhdr.free_num
; 813  :             , cdevhdr.free_imbed
; 814  :             , (U32) cdevhdr.cdh_nullfmt, cdevhdr.cdh_nullfmt == CKD_NULLTRK_FMT0 ? "ha r0 EOF" :
; 815  :                                          cdevhdr.cdh_nullfmt == CKD_NULLTRK_FMT1 ? "ha r0" :
; 816  :                                          cdevhdr.cdh_nullfmt == CKD_NULLTRK_FMT2 ? "linux" : "???"
; 817  :             , (U32) cdevhdr.cmp_algo,   !cdevhdr.cmp_algo                        ? "none"  :
; 818  :                                         (cdevhdr.cmp_algo & CCKD_COMPRESS_ZLIB)  ? "zlib"  :
; 819  :                                         (cdevhdr.cmp_algo & CCKD_COMPRESS_BZIP2) ? "bzip2" : "INVALID"
; 820  :             , cdevhdr.cmp_parm
; 821  :             , cdevhdr.cmp_parm <  0 ? ""        : " "
; 822  :             , cdevhdr.cmp_parm <  0 ? "default" :
; 823  :               cdevhdr.cmp_parm == 0 ? "none"    :
; 824  :               cdevhdr.cmp_parm <= 3 ? "low"     :
; 825  :               cdevhdr.cmp_parm <= 6 ? "medium"  : "high"
; 826  :         );
; 827  :     }
; 828  : 
; 829  :     /* Retrieve and report garbage collector state, but ONLY if
; 830  :        the image is over 100MB in size. This prevents "scaring"
; 831  :        the user about SEVERELY fragmented files when the file
; 832  :        is too small to be much of a concern, as is usually the
; 833  :        case with e.g. shadow files.
; 834  :     */
; 835  :     if (cdevhdr.cdh_size > (100 * _1M))

  02703	48 81 3d 10 00
	00 00 00 00 40
	06		 cmp	 QWORD PTR cdevhdr+16, 104857600 ; 06400000H
  0270e	0f 86 7b 01 00
	00		 jbe	 $LN106@main

; 836  :     {
; 837  :         int gc = dev_gc_state();

  02714	e8 00 00 00 00	 call	 dev_gc_state
  02719	89 84 24 64 01
	00 00		 mov	 DWORD PTR gc$1[rsp], eax

; 838  :         const char *gc_str, *sev;
; 839  : 
; 840  :              if (gc <= 1) gc_str = "SEVERELY",   sev = "W";

  02720	83 bc 24 64 01
	00 00 01	 cmp	 DWORD PTR gc$1[rsp], 1
  02728	7f 20		 jg	 SHORT $LN107@main
  0272a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169193
  02731	48 89 84 24 18
	02 00 00	 mov	 QWORD PTR gc_str$5[rsp], rax
  02739	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169194
  02740	48 89 84 24 20
	02 00 00	 mov	 QWORD PTR sev$6[rsp], rax
  02748	eb 72		 jmp	 SHORT $LN108@main
$LN107@main:

; 841  :         else if (gc <= 2) gc_str = "moderately", sev = "W";

  0274a	83 bc 24 64 01
	00 00 02	 cmp	 DWORD PTR gc$1[rsp], 2
  02752	7f 20		 jg	 SHORT $LN109@main
  02754	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169197
  0275b	48 89 84 24 18
	02 00 00	 mov	 QWORD PTR gc_str$5[rsp], rax
  02763	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169198
  0276a	48 89 84 24 20
	02 00 00	 mov	 QWORD PTR sev$6[rsp], rax
  02772	eb 48		 jmp	 SHORT $LN110@main
$LN109@main:

; 842  :         else if (gc <= 3) gc_str = "slightly",   sev = "I";

  02774	83 bc 24 64 01
	00 00 03	 cmp	 DWORD PTR gc$1[rsp], 3
  0277c	7f 20		 jg	 SHORT $LN111@main
  0277e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169201
  02785	48 89 84 24 18
	02 00 00	 mov	 QWORD PTR gc_str$5[rsp], rax
  0278d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169202
  02794	48 89 84 24 20
	02 00 00	 mov	 QWORD PTR sev$6[rsp], rax
  0279c	eb 1e		 jmp	 SHORT $LN112@main
$LN111@main:

; 843  :         else              gc_str = "not",        sev = "I";

  0279e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169203
  027a5	48 89 84 24 18
	02 00 00	 mov	 QWORD PTR gc_str$5[rsp], rax
  027ad	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169204
  027b4	48 89 84 24 20
	02 00 00	 mov	 QWORD PTR sev$6[rsp], rax
$LN112@main:
$LN110@main:
$LN108@main:

; 844  : 
; 845  :         // "Image is %s fragmented%s"
; 846  :         WRMSG( HHC03020, "I" );

  027bc	b9 01 00 00 00	 mov	 ecx, 1
  027c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  027c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169205
  027ce	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  027d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169206
  027da	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  027df	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  027e4	41 b9 03 00 00
	00		 mov	 r9d, 3
  027ea	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169207
  027f1	ba 4e 03 00 00	 mov	 edx, 846		; 0000034eH
  027f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169208
  027fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 847  :         WRMSG( HHC03050, sev, gc_str, gc <= 1 ? "!" : "." );

  02803	83 bc 24 64 01
	00 00 01	 cmp	 DWORD PTR gc$1[rsp], 1
  0280b	7f 11		 jg	 SHORT $LN250@main
  0280d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169209
  02814	48 89 84 24 b8
	03 00 00	 mov	 QWORD PTR tv1295[rsp], rax
  0281c	eb 0f		 jmp	 SHORT $LN251@main
$LN250@main:
  0281e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169210
  02825	48 89 84 24 b8
	03 00 00	 mov	 QWORD PTR tv1295[rsp], rax
$LN251@main:
  0282d	b9 01 00 00 00	 mov	 ecx, 1
  02832	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02838	48 8b 8c 24 b8
	03 00 00	 mov	 rcx, QWORD PTR tv1295[rsp]
  02840	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  02845	48 8b 8c 24 18
	02 00 00	 mov	 rcx, QWORD PTR gc_str$5[rsp]
  0284d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  02852	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR sev$6[rsp]
  0285a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0285f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169211
  02866	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0286b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02870	41 b9 03 00 00
	00		 mov	 r9d, 3
  02876	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169212
  0287d	ba 4f 03 00 00	 mov	 edx, 847		; 0000034fH
  02882	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169213
  02889	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN106@main:

; 848  :     }
; 849  : 
; 850  :     /* cdevhdr inconsistencies check */
; 851  :     hdrerr  = 0;

  0288f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR hdrerr, 0

; 852  :     hdrerr |= cdevhdr.cdh_size != filesize && cdevhdr.cdh_size != cdevhdr.free_off ? 0x0001 : 0;

  02899	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR filesize
  028a0	48 39 05 10 00
	00 00		 cmp	 QWORD PTR cdevhdr+16, rax
  028a7	74 1d		 je	 SHORT $LN252@main
  028a9	48 8b 05 20 00
	00 00		 mov	 rax, QWORD PTR cdevhdr+32
  028b0	48 39 05 10 00
	00 00		 cmp	 QWORD PTR cdevhdr+16, rax
  028b7	74 0d		 je	 SHORT $LN252@main
  028b9	c7 84 24 a8 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv1309[rsp], 1
  028c4	eb 0b		 jmp	 SHORT $LN253@main
$LN252@main:
  028c6	c7 84 24 a8 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1309[rsp], 0
$LN253@main:
  028d1	8b 84 24 a8 01
	00 00		 mov	 eax, DWORD PTR tv1309[rsp]
  028d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR hdrerr
  028de	0b c8		 or	 ecx, eax
  028e0	8b c1		 mov	 eax, ecx
  028e2	89 05 00 00 00
	00		 mov	 DWORD PTR hdrerr, eax

; 853  :     hdrerr |= cdevhdr.cdh_size !=      cdevhdr.free_total  +  cdevhdr.cdh_used     ? 0x0002 : 0;

  028e8	48 8b 05 18 00
	00 00		 mov	 rax, QWORD PTR cdevhdr+24
  028ef	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR cdevhdr+40
  028f6	48 03 c8	 add	 rcx, rax
  028f9	48 8b c1	 mov	 rax, rcx
  028fc	48 39 05 10 00
	00 00		 cmp	 QWORD PTR cdevhdr+16, rax
  02903	74 0d		 je	 SHORT $LN254@main
  02905	c7 84 24 ac 01
	00 00 02 00 00
	00		 mov	 DWORD PTR tv1313[rsp], 2
  02910	eb 0b		 jmp	 SHORT $LN255@main
$LN254@main:
  02912	c7 84 24 ac 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1313[rsp], 0
$LN255@main:
  0291d	8b 84 24 ac 01
	00 00		 mov	 eax, DWORD PTR tv1313[rsp]
  02924	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR hdrerr
  0292a	0b c8		 or	 ecx, eax
  0292c	8b c1		 mov	 eax, ecx
  0292e	89 05 00 00 00
	00		 mov	 DWORD PTR hdrerr, eax

; 854  :     hdrerr |= cdevhdr.free_largest  >  cdevhdr.free_total  -  cdevhdr.free_imbed   ? 0x0004 : 0;

  02934	48 8b 05 40 00
	00 00		 mov	 rax, QWORD PTR cdevhdr+64
  0293b	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR cdevhdr+40
  02942	48 2b c8	 sub	 rcx, rax
  02945	48 8b c1	 mov	 rax, rcx
  02948	48 39 05 30 00
	00 00		 cmp	 QWORD PTR cdevhdr+48, rax
  0294f	76 0d		 jbe	 SHORT $LN256@main
  02951	c7 84 24 b0 01
	00 00 04 00 00
	00		 mov	 DWORD PTR tv1317[rsp], 4
  0295c	eb 0b		 jmp	 SHORT $LN257@main
$LN256@main:
  0295e	c7 84 24 b0 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1317[rsp], 0
$LN257@main:
  02969	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR tv1317[rsp]
  02970	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR hdrerr
  02976	0b c8		 or	 ecx, eax
  02978	8b c1		 mov	 eax, ecx
  0297a	89 05 00 00 00
	00		 mov	 DWORD PTR hdrerr, eax

; 855  :     hdrerr |= cdevhdr.free_off == 0 && cdevhdr.free_num    != 0                    ? 0x0008 : 0;

  02980	48 83 3d 20 00
	00 00 00	 cmp	 QWORD PTR cdevhdr+32, 0
  02988	75 17		 jne	 SHORT $LN258@main
  0298a	48 83 3d 38 00
	00 00 00	 cmp	 QWORD PTR cdevhdr+56, 0
  02992	74 0d		 je	 SHORT $LN258@main
  02994	c7 84 24 b4 01
	00 00 08 00 00
	00		 mov	 DWORD PTR tv1321[rsp], 8
  0299f	eb 0b		 jmp	 SHORT $LN259@main
$LN258@main:
  029a1	c7 84 24 b4 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1321[rsp], 0
$LN259@main:
  029ac	8b 84 24 b4 01
	00 00		 mov	 eax, DWORD PTR tv1321[rsp]
  029b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR hdrerr
  029b9	0b c8		 or	 ecx, eax
  029bb	8b c1		 mov	 eax, ecx
  029bd	89 05 00 00 00
	00		 mov	 DWORD PTR hdrerr, eax

; 856  :     hdrerr |= cdevhdr.free_off == 0 && cdevhdr.free_total  != cdevhdr.free_imbed   ? 0x0010 : 0;

  029c3	48 83 3d 20 00
	00 00 00	 cmp	 QWORD PTR cdevhdr+32, 0
  029cb	75 1d		 jne	 SHORT $LN260@main
  029cd	48 8b 05 40 00
	00 00		 mov	 rax, QWORD PTR cdevhdr+64
  029d4	48 39 05 28 00
	00 00		 cmp	 QWORD PTR cdevhdr+40, rax
  029db	74 0d		 je	 SHORT $LN260@main
  029dd	c7 84 24 b8 01
	00 00 10 00 00
	00		 mov	 DWORD PTR tv1325[rsp], 16
  029e8	eb 0b		 jmp	 SHORT $LN261@main
$LN260@main:
  029ea	c7 84 24 b8 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1325[rsp], 0
$LN261@main:
  029f5	8b 84 24 b8 01
	00 00		 mov	 eax, DWORD PTR tv1325[rsp]
  029fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR hdrerr
  02a02	0b c8		 or	 ecx, eax
  02a04	8b c1		 mov	 eax, ecx
  02a06	89 05 00 00 00
	00		 mov	 DWORD PTR hdrerr, eax

; 857  :     hdrerr |= cdevhdr.free_off != 0 && cdevhdr.free_total  == 0                    ? 0x0020 : 0;

  02a0c	48 83 3d 20 00
	00 00 00	 cmp	 QWORD PTR cdevhdr+32, 0
  02a14	74 17		 je	 SHORT $LN262@main
  02a16	48 83 3d 28 00
	00 00 00	 cmp	 QWORD PTR cdevhdr+40, 0
  02a1e	75 0d		 jne	 SHORT $LN262@main
  02a20	c7 84 24 bc 01
	00 00 20 00 00
	00		 mov	 DWORD PTR tv1329[rsp], 32 ; 00000020H
  02a2b	eb 0b		 jmp	 SHORT $LN263@main
$LN262@main:
  02a2d	c7 84 24 bc 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1329[rsp], 0
$LN263@main:
  02a38	8b 84 24 bc 01
	00 00		 mov	 eax, DWORD PTR tv1329[rsp]
  02a3f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR hdrerr
  02a45	0b c8		 or	 ecx, eax
  02a47	8b c1		 mov	 eax, ecx
  02a49	89 05 00 00 00
	00		 mov	 DWORD PTR hdrerr, eax

; 858  :     hdrerr |= cdevhdr.free_off != 0 && cdevhdr.free_num    == 0                    ? 0x0040 : 0;

  02a4f	48 83 3d 20 00
	00 00 00	 cmp	 QWORD PTR cdevhdr+32, 0
  02a57	74 17		 je	 SHORT $LN264@main
  02a59	48 83 3d 38 00
	00 00 00	 cmp	 QWORD PTR cdevhdr+56, 0
  02a61	75 0d		 jne	 SHORT $LN264@main
  02a63	c7 84 24 c0 01
	00 00 40 00 00
	00		 mov	 DWORD PTR tv1333[rsp], 64 ; 00000040H
  02a6e	eb 0b		 jmp	 SHORT $LN265@main
$LN264@main:
  02a70	c7 84 24 c0 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1333[rsp], 0
$LN265@main:
  02a7b	8b 84 24 c0 01
	00 00		 mov	 eax, DWORD PTR tv1333[rsp]
  02a82	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR hdrerr
  02a88	0b c8		 or	 ecx, eax
  02a8a	8b c1		 mov	 eax, ecx
  02a8c	89 05 00 00 00
	00		 mov	 DWORD PTR hdrerr, eax

; 859  :     hdrerr |= cdevhdr.free_num == 0 && cdevhdr.free_total  != cdevhdr.free_imbed   ? 0x0080 : 0;

  02a92	48 83 3d 38 00
	00 00 00	 cmp	 QWORD PTR cdevhdr+56, 0
  02a9a	75 1d		 jne	 SHORT $LN266@main
  02a9c	48 8b 05 40 00
	00 00		 mov	 rax, QWORD PTR cdevhdr+64
  02aa3	48 39 05 28 00
	00 00		 cmp	 QWORD PTR cdevhdr+40, rax
  02aaa	74 0d		 je	 SHORT $LN266@main
  02aac	c7 84 24 c4 01
	00 00 80 00 00
	00		 mov	 DWORD PTR tv1337[rsp], 128 ; 00000080H
  02ab7	eb 0b		 jmp	 SHORT $LN267@main
$LN266@main:
  02ab9	c7 84 24 c4 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1337[rsp], 0
$LN267@main:
  02ac4	8b 84 24 c4 01
	00 00		 mov	 eax, DWORD PTR tv1337[rsp]
  02acb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR hdrerr
  02ad1	0b c8		 or	 ecx, eax
  02ad3	8b c1		 mov	 eax, ecx
  02ad5	89 05 00 00 00
	00		 mov	 DWORD PTR hdrerr, eax

; 860  :     hdrerr |= cdevhdr.free_num != 0 && cdevhdr.free_total  <= cdevhdr.free_imbed   ? 0x0100 : 0;

  02adb	48 83 3d 38 00
	00 00 00	 cmp	 QWORD PTR cdevhdr+56, 0
  02ae3	74 1d		 je	 SHORT $LN268@main
  02ae5	48 8b 05 40 00
	00 00		 mov	 rax, QWORD PTR cdevhdr+64
  02aec	48 39 05 28 00
	00 00		 cmp	 QWORD PTR cdevhdr+40, rax
  02af3	77 0d		 ja	 SHORT $LN268@main
  02af5	c7 84 24 c8 01
	00 00 00 01 00
	00		 mov	 DWORD PTR tv1341[rsp], 256 ; 00000100H
  02b00	eb 0b		 jmp	 SHORT $LN269@main
$LN268@main:
  02b02	c7 84 24 c8 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1341[rsp], 0
$LN269@main:
  02b0d	8b 84 24 c8 01
	00 00		 mov	 eax, DWORD PTR tv1341[rsp]
  02b14	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR hdrerr
  02b1a	0b c8		 or	 ecx, eax
  02b1c	8b c1		 mov	 eax, ecx
  02b1e	89 05 00 00 00
	00		 mov	 DWORD PTR hdrerr, eax

; 861  :     hdrerr |= cdevhdr.free_imbed    >  cdevhdr.free_total                          ? 0x0200 : 0;

  02b24	48 8b 05 28 00
	00 00		 mov	 rax, QWORD PTR cdevhdr+40
  02b2b	48 39 05 40 00
	00 00		 cmp	 QWORD PTR cdevhdr+64, rax
  02b32	76 0d		 jbe	 SHORT $LN270@main
  02b34	c7 84 24 cc 01
	00 00 00 02 00
	00		 mov	 DWORD PTR tv1344[rsp], 512 ; 00000200H
  02b3f	eb 0b		 jmp	 SHORT $LN271@main
$LN270@main:
  02b41	c7 84 24 cc 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1344[rsp], 0
$LN271@main:
  02b4c	8b 84 24 cc 01
	00 00		 mov	 eax, DWORD PTR tv1344[rsp]
  02b53	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR hdrerr
  02b59	0b c8		 or	 ecx, eax
  02b5b	8b c1		 mov	 eax, ecx
  02b5d	89 05 00 00 00
	00		 mov	 DWORD PTR hdrerr, eax

; 862  : 
; 863  :     if (hdrerr != 0)

  02b63	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR hdrerr, 0
  02b6a	0f 84 98 00 00
	00		 je	 $LN113@main

; 864  :     {
; 865  :         // "Compressed device header inconsistency(s) found! code: %4.4X"
; 866  :         WRMSG( HHC03020, "I" );

  02b70	b9 01 00 00 00	 mov	 ecx, 1
  02b75	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02b7b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169215
  02b82	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  02b87	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169216
  02b8e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02b93	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02b98	41 b9 03 00 00
	00		 mov	 r9d, 3
  02b9e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169217
  02ba5	ba 62 03 00 00	 mov	 edx, 866		; 00000362H
  02baa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169218
  02bb1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 867  :         FWRMSG( stderr, HHC03008, "W", hdrerr );

  02bb7	b9 02 00 00 00	 mov	 ecx, 2
  02bbc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02bc2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR hdrerr
  02bc8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  02bcc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169219
  02bd3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  02bd8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169220
  02bdf	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02be4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02be9	41 b9 03 00 00
	00		 mov	 r9d, 3
  02bef	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169221
  02bf6	ba 63 03 00 00	 mov	 edx, 867		; 00000363H
  02bfb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169222
  02c02	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN113@main:

; 868  :     }
; 869  : 
; 870  :     /* Save the number of L1 table entries */
; 871  :     num_L1tab = cdevhdr.num_L1tab;

  02c08	8b 05 04 00 00
	00		 mov	 eax, DWORD PTR cdevhdr+4
  02c0e	89 05 00 00 00
	00		 mov	 DWORD PTR num_L1tab, eax

; 872  : 
; 873  :     /* Init the size of the L1 table */
; 874  :     size   = (num_L1tab * CCKD64_L1ENT_SIZE);

  02c14	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR num_L1tab
  02c1b	48 c1 e0 03	 shl	 rax, 3
  02c1f	89 84 24 38 01
	00 00		 mov	 DWORD PTR size$[rsp], eax

; 875  :     size32 = (num_L1tab * CCKD_L1ENT_SIZE);

  02c26	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR num_L1tab
  02c2d	48 c1 e0 02	 shl	 rax, 2
  02c31	89 84 24 44 01
	00 00		 mov	 DWORD PTR size32$[rsp], eax

; 876  : 
; 877  :     /* Allocate room for the L1 table */
; 878  :     if (!(L1tab = (CCKD64_L1ENT*) calloc( 1, size )))

  02c38	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  02c3f	8b d0		 mov	 edx, eax
  02c41	b9 01 00 00 00	 mov	 ecx, 1
  02c46	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  02c4c	48 89 05 00 00
	00 00		 mov	 QWORD PTR L1tab, rax
  02c53	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR L1tab, 0
  02c5b	0f 85 80 00 00
	00		 jne	 $LN114@main

; 879  :     {
; 880  :         // "%s error: %s"
; 881  :         FWRMSG( stderr, HHC03006, "E", "calloc()", strerror( errno ));

  02c61	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  02c67	8b 08		 mov	 ecx, DWORD PTR [rax]
  02c69	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  02c6f	48 89 84 24 80
	04 00 00	 mov	 QWORD PTR tv1412[rsp], rax
  02c77	b9 02 00 00 00	 mov	 ecx, 2
  02c7c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02c82	48 8b 8c 24 80
	04 00 00	 mov	 rcx, QWORD PTR tv1412[rsp]
  02c8a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  02c8f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169224
  02c96	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  02c9b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169225
  02ca2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  02ca7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169226
  02cae	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02cb3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02cb8	41 b9 03 00 00
	00		 mov	 r9d, 3
  02cbe	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169227
  02cc5	ba 71 03 00 00	 mov	 edx, 881		; 00000371H
  02cca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169228
  02cd1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 882  :         return -1;

  02cd7	b8 ff ff ff ff	 mov	 eax, -1
  02cdc	e9 53 1c 00 00	 jmp	 $LN1@main
$LN114@main:

; 883  :     }
; 884  : 
; 885  :     /* Read the L1 table */
; 886  :     if (cckd64)

  02ce1	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  02ce8	85 c0		 test	 eax, eax
  02cea	0f 84 68 01 00
	00		 je	 $LN115@main

; 887  :     {
; 888  :         /* Read the L1 table */
; 889  :         if ((curpos = lseek( fd, CCKD64_L1TAB_POS, SEEK_SET )) < 0)

  02cf0	45 33 c0	 xor	 r8d, r8d
  02cf3	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  02cf8	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  02cff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  02d05	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR curpos$[rsp], rax
  02d0d	48 83 bc 24 48
	01 00 00 00	 cmp	 QWORD PTR curpos$[rsp], 0
  02d16	0f 8d 80 00 00
	00		 jge	 $LN117@main

; 890  :         {
; 891  :             // "%s error: %s"
; 892  :             FWRMSG( stderr, HHC03006, "E", "lseek()", strerror( errno ));

  02d1c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  02d22	8b 08		 mov	 ecx, DWORD PTR [rax]
  02d24	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  02d2a	48 89 84 24 88
	04 00 00	 mov	 QWORD PTR tv1433[rsp], rax
  02d32	b9 02 00 00 00	 mov	 ecx, 2
  02d37	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02d3d	48 8b 8c 24 88
	04 00 00	 mov	 rcx, QWORD PTR tv1433[rsp]
  02d45	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  02d4a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169232
  02d51	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  02d56	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169233
  02d5d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  02d62	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169234
  02d69	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02d6e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02d73	41 b9 03 00 00
	00		 mov	 r9d, 3
  02d79	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169235
  02d80	ba 7c 03 00 00	 mov	 edx, 892		; 0000037cH
  02d85	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169236
  02d8c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 893  :             return -1;

  02d92	b8 ff ff ff ff	 mov	 eax, -1
  02d97	e9 98 1b 00 00	 jmp	 $LN1@main
$LN117@main:

; 894  :         }
; 895  :         if ((rc = read( fd, L1tab, size )) < (int) size)

  02d9c	44 8b 84 24 38
	01 00 00	 mov	 r8d, DWORD PTR size$[rsp]
  02da4	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR L1tab
  02dab	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  02db2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  02db8	89 84 24 40 01
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  02dbf	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  02dc6	39 84 24 40 01
	00 00		 cmp	 DWORD PTR rc$[rsp], eax
  02dcd	0f 8d 80 00 00
	00		 jge	 $LN118@main

; 896  :         {
; 897  :             // "%s error: %s"
; 898  :             FWRMSG( stderr, HHC03006, "E", "read()", strerror( errno ));

  02dd3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  02dd9	8b 08		 mov	 ecx, DWORD PTR [rax]
  02ddb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  02de1	48 89 84 24 90
	04 00 00	 mov	 QWORD PTR tv1452[rsp], rax
  02de9	b9 02 00 00 00	 mov	 ecx, 2
  02dee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02df4	48 8b 8c 24 90
	04 00 00	 mov	 rcx, QWORD PTR tv1452[rsp]
  02dfc	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  02e01	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169238
  02e08	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  02e0d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169239
  02e14	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  02e19	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169240
  02e20	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02e25	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02e2a	41 b9 03 00 00
	00		 mov	 r9d, 3
  02e30	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169241
  02e37	ba 82 03 00 00	 mov	 edx, 898		; 00000382H
  02e3c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169242
  02e43	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 899  :             return -1;

  02e49	b8 ff ff ff ff	 mov	 eax, -1
  02e4e	e9 e1 1a 00 00	 jmp	 $LN1@main
$LN118@main:

; 900  :         }
; 901  :     }

  02e53	e9 29 02 00 00	 jmp	 $LN116@main
$LN115@main:

; 902  :     else // (32-bit CCKD)
; 903  :     {
; 904  :         /* Allocate room for the L1 table */
; 905  :         if (!(L1tab32 = (CCKD_L1ENT*) calloc( 1, size32 )))

  02e58	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR size32$[rsp]
  02e5f	8b d0		 mov	 edx, eax
  02e61	b9 01 00 00 00	 mov	 ecx, 1
  02e66	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  02e6c	48 89 05 00 00
	00 00		 mov	 QWORD PTR L1tab32, rax
  02e73	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR L1tab32, 0
  02e7b	0f 85 80 00 00
	00		 jne	 $LN119@main

; 906  :         {
; 907  :             // "%s error: %s"
; 908  :             FWRMSG( stderr, HHC03006, "E", "calloc()", strerror( errno ));

  02e81	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  02e87	8b 08		 mov	 ecx, DWORD PTR [rax]
  02e89	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  02e8f	48 89 84 24 98
	04 00 00	 mov	 QWORD PTR tv1474[rsp], rax
  02e97	b9 02 00 00 00	 mov	 ecx, 2
  02e9c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02ea2	48 8b 8c 24 98
	04 00 00	 mov	 rcx, QWORD PTR tv1474[rsp]
  02eaa	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  02eaf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169244
  02eb6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  02ebb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169245
  02ec2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  02ec7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169246
  02ece	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02ed3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02ed8	41 b9 03 00 00
	00		 mov	 r9d, 3
  02ede	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169247
  02ee5	ba 8c 03 00 00	 mov	 edx, 908		; 0000038cH
  02eea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169248
  02ef1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 909  :             return -1;

  02ef7	b8 ff ff ff ff	 mov	 eax, -1
  02efc	e9 33 1a 00 00	 jmp	 $LN1@main
$LN119@main:

; 910  :         }
; 911  : 
; 912  :         /* Read the L1 table */
; 913  :         if ((curpos = lseek( fd, CCKD_L1TAB_POS, SEEK_SET )) < 0)

  02f01	45 33 c0	 xor	 r8d, r8d
  02f04	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  02f09	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  02f10	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  02f16	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR curpos$[rsp], rax
  02f1e	48 83 bc 24 48
	01 00 00 00	 cmp	 QWORD PTR curpos$[rsp], 0
  02f27	0f 8d 80 00 00
	00		 jge	 $LN120@main

; 914  :         {
; 915  :             // "%s error: %s"
; 916  :             FWRMSG( stderr, HHC03006, "E", "lseek()", strerror( errno ));

  02f2d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  02f33	8b 08		 mov	 ecx, DWORD PTR [rax]
  02f35	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  02f3b	48 89 84 24 a0
	04 00 00	 mov	 QWORD PTR tv1493[rsp], rax
  02f43	b9 02 00 00 00	 mov	 ecx, 2
  02f48	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02f4e	48 8b 8c 24 a0
	04 00 00	 mov	 rcx, QWORD PTR tv1493[rsp]
  02f56	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  02f5b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169250
  02f62	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  02f67	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169251
  02f6e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  02f73	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169252
  02f7a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02f7f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02f84	41 b9 03 00 00
	00		 mov	 r9d, 3
  02f8a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169253
  02f91	ba 94 03 00 00	 mov	 edx, 916		; 00000394H
  02f96	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169254
  02f9d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 917  :             return -1;

  02fa3	b8 ff ff ff ff	 mov	 eax, -1
  02fa8	e9 87 19 00 00	 jmp	 $LN1@main
$LN120@main:

; 918  :         }
; 919  :         if ((rc = read( fd, L1tab32, size32 )) < (int) size32)

  02fad	44 8b 84 24 44
	01 00 00	 mov	 r8d, DWORD PTR size32$[rsp]
  02fb5	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR L1tab32
  02fbc	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  02fc3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  02fc9	89 84 24 40 01
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  02fd0	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR size32$[rsp]
  02fd7	39 84 24 40 01
	00 00		 cmp	 DWORD PTR rc$[rsp], eax
  02fde	0f 8d 80 00 00
	00		 jge	 $LN121@main

; 920  :         {
; 921  :             // "%s error: %s"
; 922  :             FWRMSG( stderr, HHC03006, "E", "read()", strerror( errno ));

  02fe4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  02fea	8b 08		 mov	 ecx, DWORD PTR [rax]
  02fec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  02ff2	48 89 84 24 a8
	04 00 00	 mov	 QWORD PTR tv1544[rsp], rax
  02ffa	b9 02 00 00 00	 mov	 ecx, 2
  02fff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  03005	48 8b 8c 24 a8
	04 00 00	 mov	 rcx, QWORD PTR tv1544[rsp]
  0300d	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  03012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169256
  03019	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0301e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169257
  03025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0302a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169258
  03031	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  03036	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0303b	41 b9 03 00 00
	00		 mov	 r9d, 3
  03041	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169259
  03048	ba 9a 03 00 00	 mov	 edx, 922		; 0000039aH
  0304d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169260
  03054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 923  :             return -1;

  0305a	b8 ff ff ff ff	 mov	 eax, -1
  0305f	e9 d0 18 00 00	 jmp	 $LN1@main
$LN121@main:

; 924  :         }
; 925  : 
; 926  :         /* Convert 32-bit L1 table to 64-bit CCKD64 */
; 927  :         L1tab_to_64();

  03064	e8 00 00 00 00	 call	 L1tab_to_64

; 928  :         free( L1tab32 );

  03069	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR L1tab32
  03070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 929  :         L1tab32 = NULL;

  03076	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR L1tab32, 0
$LN116@main:
$LN16@main:

; 930  :     }
; 931  : 
; 932  :     /* Swap the L1 table before processing it */
; 933  :     SWAP_CCKD64_L1TAB( L1tab );

  03081	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR swaps_needed
  03088	85 c0		 test	 eax, eax
  0308a	74 13		 je	 SHORT $LN122@main
  0308c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR num_L1tab
  03092	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR L1tab
  03099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_cckd64_swapend_l1
$LN122@main:
  0309f	33 c0		 xor	 eax, eax
  030a1	85 c0		 test	 eax, eax
  030a3	75 dc		 jne	 SHORT $LN16@main

; 934  : 
; 935  :     /* Add the L1 table to spaces table */
; 936  :     spc.spc_typ  = SPCTAB_L1;

  030a5	c6 84 24 f0 04
	00 00 03	 mov	 BYTE PTR spc$[rsp], 3

; 937  :     spc.spc_off  = curpos;

  030ad	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR curpos$[rsp]
  030b5	48 89 84 24 00
	05 00 00	 mov	 QWORD PTR spc$[rsp+16], rax

; 938  :     spc.spc_siz  = cckd64 ? size : size32;

  030bd	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  030c4	85 c0		 test	 eax, eax
  030c6	74 10		 je	 SHORT $LN272@main
  030c8	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  030cf	89 84 24 d0 01
	00 00		 mov	 DWORD PTR tv1566[rsp], eax
  030d6	eb 0e		 jmp	 SHORT $LN273@main
$LN272@main:
  030d8	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR size32$[rsp]
  030df	89 84 24 d0 01
	00 00		 mov	 DWORD PTR tv1566[rsp], eax
$LN273@main:
  030e6	8b 84 24 d0 01
	00 00		 mov	 eax, DWORD PTR tv1566[rsp]
  030ed	48 89 84 24 10
	05 00 00	 mov	 QWORD PTR spc$[rsp+32], rax

; 939  :     spc.spc_len  = spc.spc_siz;

  030f5	48 8b 84 24 10
	05 00 00	 mov	 rax, QWORD PTR spc$[rsp+32]
  030fd	48 89 84 24 08
	05 00 00	 mov	 QWORD PTR spc$[rsp+24], rax

; 940  :     spc.spc_val  = 0;

  03105	c7 84 24 f4 04
	00 00 00 00 00
	00		 mov	 DWORD PTR spc$[rsp+4], 0

; 941  :     spc.spc_val2 = tracks - 1;

  03110	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR tracks$[rsp]
  03117	ff c8		 dec	 eax
  03119	89 84 24 f8 04
	00 00		 mov	 DWORD PTR spc$[rsp+8], eax

; 942  :     ADD_SPACE( spc );

  03120	48 8d 8c 24 f0
	04 00 00	 lea	 rcx, QWORD PTR spc$[rsp]
  03128	e8 00 00 00 00	 call	 add_spc_to_table

; 943  : 
; 944  :     /* Get past L1 table to where L2 tables should start */
; 945  :     curpos += (cckd64 ? size : size32);

  0312d	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  03134	85 c0		 test	 eax, eax
  03136	74 10		 je	 SHORT $LN274@main
  03138	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  0313f	89 84 24 d4 01
	00 00		 mov	 DWORD PTR tv1572[rsp], eax
  03146	eb 0e		 jmp	 SHORT $LN275@main
$LN274@main:
  03148	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR size32$[rsp]
  0314f	89 84 24 d4 01
	00 00		 mov	 DWORD PTR tv1572[rsp], eax
$LN275@main:
  03156	8b 84 24 d4 01
	00 00		 mov	 eax, DWORD PTR tv1572[rsp]
  0315d	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR curpos$[rsp]
  03165	48 03 c8	 add	 rcx, rax
  03168	48 8b c1	 mov	 rax, rcx
  0316b	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR curpos$[rsp], rax

; 946  : 
; 947  :     /* Add the calculated L2 tables LOWER bounds to spaces table */
; 948  :     L2_lower_pos = curpos;

  03173	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR curpos$[rsp]
  0317b	48 89 05 00 00
	00 00		 mov	 QWORD PTR L2_lower_pos, rax

; 949  :     spc.spc_typ  = SPCTAB_L2LOWER;

  03182	c6 84 24 f0 04
	00 00 09	 mov	 BYTE PTR spc$[rsp], 9

; 950  :     spc.spc_off  = L2_lower_pos;

  0318a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR L2_lower_pos
  03191	48 89 84 24 00
	05 00 00	 mov	 QWORD PTR spc$[rsp+16], rax

; 951  :     spc.spc_siz  = 0;

  03199	48 c7 84 24 10
	05 00 00 00 00
	00 00		 mov	 QWORD PTR spc$[rsp+32], 0

; 952  :     spc.spc_len  = 0;

  031a5	48 c7 84 24 08
	05 00 00 00 00
	00 00		 mov	 QWORD PTR spc$[rsp+24], 0

; 953  :     spc.spc_val  = -1;

  031b1	c7 84 24 f4 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR spc$[rsp+4], -1

; 954  :     spc.spc_val2 = -1;

  031bc	c7 84 24 f8 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR spc$[rsp+8], -1

; 955  :     ADD_SPACE( spc );

  031c7	48 8d 8c 24 f0
	04 00 00	 lea	 rcx, QWORD PTR spc$[rsp]
  031cf	e8 00 00 00 00	 call	 add_spc_to_table

; 956  : 
; 957  :     /* Init the size of each L2 table */
; 958  :     size   = CCKD64_L2TAB_SIZE;

  031d4	c7 84 24 38 01
	00 00 00 10 00
	00		 mov	 DWORD PTR size$[rsp], 4096 ; 00001000H

; 959  :     size32 = CCKD_L2TAB_SIZE;

  031df	c7 84 24 44 01
	00 00 00 08 00
	00		 mov	 DWORD PTR size32$[rsp], 2048 ; 00000800H

; 960  : 
; 961  :     /* Read in all of the L2 tables */
; 962  :     for (i=0; i < num_L1tab; i++)

  031ea	c7 84 24 30 01
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  031f5	eb 10		 jmp	 SHORT $LN19@main
$LN17@main:
  031f7	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  031fe	ff c0		 inc	 eax
  03200	89 84 24 30 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN19@main:
  03207	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR num_L1tab
  0320d	39 84 24 30 01
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  03214	0f 8d a4 04 00
	00		 jge	 $LN18@main

; 963  :     {
; 964  :         L1track = (i * 256);

  0321a	69 84 24 30 01
	00 00 00 01 00
	00		 imul	 eax, DWORD PTR i$[rsp], 256 ; 00000100H
  03225	89 84 24 54 01
	00 00		 mov	 DWORD PTR L1track$[rsp], eax

; 965  : 
; 966  :         /* Skip non-existent L2 tables */
; 967  :         if (0
; 968  :             || L1tab[i] == CCKD64_NOSIZE
; 969  :             || L1tab[i] == CCKD64_MAXSIZE

  0322c	33 c0		 xor	 eax, eax
  0322e	85 c0		 test	 eax, eax
  03230	75 2c		 jne	 SHORT $LN124@main
  03232	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0323a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR L1tab
  03241	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  03246	74 16		 je	 SHORT $LN124@main
  03248	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  03250	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR L1tab
  03257	48 83 3c c1 ff	 cmp	 QWORD PTR [rcx+rax*8], -1
  0325c	75 02		 jne	 SHORT $LN123@main
$LN124@main:

; 970  :         )
; 971  :             continue;  // (skip non-existent L2 table)

  0325e	eb 97		 jmp	 SHORT $LN17@main
$LN123@main:

; 972  : 
; 973  :         /* Read this L2 table */
; 974  :         if ((curpos = lseek( fd, L1tab[i], SEEK_SET )) < 0)

  03260	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  03268	45 33 c0	 xor	 r8d, r8d
  0326b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR L1tab
  03272	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  03276	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  0327d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  03283	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR curpos$[rsp], rax
  0328b	48 83 bc 24 48
	01 00 00 00	 cmp	 QWORD PTR curpos$[rsp], 0
  03294	0f 8d 80 00 00
	00		 jge	 $LN125@main

; 975  :         {
; 976  :             // "%s error: %s"
; 977  :             FWRMSG( stderr, HHC03006, "E", "lseek()", strerror( errno ));

  0329a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  032a0	8b 08		 mov	 ecx, DWORD PTR [rax]
  032a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  032a8	48 89 84 24 b0
	04 00 00	 mov	 QWORD PTR tv1596[rsp], rax
  032b0	b9 02 00 00 00	 mov	 ecx, 2
  032b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  032bb	48 8b 8c 24 b0
	04 00 00	 mov	 rcx, QWORD PTR tv1596[rsp]
  032c3	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  032c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169265
  032cf	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  032d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169266
  032db	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  032e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169267
  032e7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  032ec	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  032f1	41 b9 03 00 00
	00		 mov	 r9d, 3
  032f7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169268
  032fe	ba d1 03 00 00	 mov	 edx, 977		; 000003d1H
  03303	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169269
  0330a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 978  :             return -1;

  03310	b8 ff ff ff ff	 mov	 eax, -1
  03315	e9 1a 16 00 00	 jmp	 $LN1@main
$LN125@main:

; 979  :         }
; 980  : 
; 981  :         if (cckd64)

  0331a	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  03321	85 c0		 test	 eax, eax
  03323	0f 84 bc 00 00
	00		 je	 $LN126@main

; 982  :         {
; 983  :             if ((rc = read( fd, L2tab, size )) < (int) size)

  03329	44 8b 84 24 38
	01 00 00	 mov	 r8d, DWORD PTR size$[rsp]
  03331	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:L2tab
  03338	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  0333f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  03345	89 84 24 40 01
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  0334c	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  03353	39 84 24 40 01
	00 00		 cmp	 DWORD PTR rc$[rsp], eax
  0335a	0f 8d 80 00 00
	00		 jge	 $LN128@main

; 984  :             {
; 985  :                 // "%s error: %s"
; 986  :                 FWRMSG( stderr, HHC03006, "E", "read()", strerror( errno ));

  03360	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  03366	8b 08		 mov	 ecx, DWORD PTR [rax]
  03368	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0336e	48 89 84 24 b8
	04 00 00	 mov	 QWORD PTR tv1617[rsp], rax
  03376	b9 02 00 00 00	 mov	 ecx, 2
  0337b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  03381	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR tv1617[rsp]
  03389	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0338e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169273
  03395	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0339a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169274
  033a1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  033a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169275
  033ad	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  033b2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  033b7	41 b9 03 00 00
	00		 mov	 r9d, 3
  033bd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169276
  033c4	ba da 03 00 00	 mov	 edx, 986		; 000003daH
  033c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169277
  033d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 987  :                 return -1;

  033d6	b8 ff ff ff ff	 mov	 eax, -1
  033db	e9 54 15 00 00	 jmp	 $LN1@main
$LN128@main:

; 988  :             }
; 989  :         }

  033e0	e9 bc 00 00 00	 jmp	 $LN127@main
$LN126@main:

; 990  :         else // (32-bit CCKD)
; 991  :         {
; 992  :             if ((rc = read( fd, L2tab32, size32 )) < (int) size32)

  033e5	44 8b 84 24 44
	01 00 00	 mov	 r8d, DWORD PTR size32$[rsp]
  033ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:L2tab32
  033f4	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  033fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  03401	89 84 24 40 01
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  03408	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR size32$[rsp]
  0340f	39 84 24 40 01
	00 00		 cmp	 DWORD PTR rc$[rsp], eax
  03416	0f 8d 80 00 00
	00		 jge	 $LN129@main

; 993  :             {
; 994  :                 // "%s error: %s"
; 995  :                 FWRMSG( stderr, HHC03006, "E", "read()", strerror( errno ));

  0341c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  03422	8b 08		 mov	 ecx, DWORD PTR [rax]
  03424	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0342a	48 89 84 24 c0
	04 00 00	 mov	 QWORD PTR tv1636[rsp], rax
  03432	b9 02 00 00 00	 mov	 ecx, 2
  03437	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0343d	48 8b 8c 24 c0
	04 00 00	 mov	 rcx, QWORD PTR tv1636[rsp]
  03445	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0344a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169279
  03451	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  03456	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169280
  0345d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  03462	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169281
  03469	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0346e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  03473	41 b9 03 00 00
	00		 mov	 r9d, 3
  03479	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169282
  03480	ba e3 03 00 00	 mov	 edx, 995		; 000003e3H
  03485	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169283
  0348c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 996  :                 return -1;

  03492	b8 ff ff ff ff	 mov	 eax, -1
  03497	e9 98 14 00 00	 jmp	 $LN1@main
$LN129@main:

; 997  :             }
; 998  : 
; 999  :             /* Convert 32-bit L2 table to 64-bit CCKD64 */
; 1000 :             L2tab_to_64();

  0349c	e8 00 00 00 00	 call	 L2tab_to_64
$LN127@main:
$LN22@main:

; 1001 :         }
; 1002 : 
; 1003 :         /* Swap the L2 table before processing it */
; 1004 :         SWAP_CCKD64_L2TAB( L2tab );

  034a1	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR swaps_needed
  034a8	85 c0		 test	 eax, eax
  034aa	74 0d		 je	 SHORT $LN130@main
  034ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:L2tab
  034b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_cckd64_swapend_l2
$LN130@main:
  034b9	33 c0		 xor	 eax, eax
  034bb	85 c0		 test	 eax, eax
  034bd	75 e2		 jne	 SHORT $LN22@main

; 1005 : 
; 1006 :         /* Add this L2 table to the spaces table */
; 1007 :         spc.spc_typ  = SPCTAB_L2;

  034bf	c6 84 24 f0 04
	00 00 04	 mov	 BYTE PTR spc$[rsp], 4

; 1008 :         spc.spc_off  = curpos;

  034c7	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR curpos$[rsp]
  034cf	48 89 84 24 00
	05 00 00	 mov	 QWORD PTR spc$[rsp+16], rax

; 1009 :         spc.spc_siz  = cckd64 ? size : size32;

  034d7	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  034de	85 c0		 test	 eax, eax
  034e0	74 10		 je	 SHORT $LN276@main
  034e2	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  034e9	89 84 24 d8 01
	00 00		 mov	 DWORD PTR tv1656[rsp], eax
  034f0	eb 0e		 jmp	 SHORT $LN277@main
$LN276@main:
  034f2	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR size32$[rsp]
  034f9	89 84 24 d8 01
	00 00		 mov	 DWORD PTR tv1656[rsp], eax
$LN277@main:
  03500	8b 84 24 d8 01
	00 00		 mov	 eax, DWORD PTR tv1656[rsp]
  03507	48 89 84 24 10
	05 00 00	 mov	 QWORD PTR spc$[rsp+32], rax

; 1010 :         spc.spc_len  = spc.spc_siz;

  0350f	48 8b 84 24 10
	05 00 00	 mov	 rax, QWORD PTR spc$[rsp+32]
  03517	48 89 84 24 08
	05 00 00	 mov	 QWORD PTR spc$[rsp+24], rax

; 1011 :         spc.spc_val  = L1track;

  0351f	8b 84 24 54 01
	00 00		 mov	 eax, DWORD PTR L1track$[rsp]
  03526	89 84 24 f4 04
	00 00		 mov	 DWORD PTR spc$[rsp+4], eax

; 1012 :         spc.spc_val2 = L1track + 256 - 1;

  0352d	8b 84 24 54 01
	00 00		 mov	 eax, DWORD PTR L1track$[rsp]
  03534	05 ff 00 00 00	 add	 eax, 255		; 000000ffH
  03539	89 84 24 f8 04
	00 00		 mov	 DWORD PTR spc$[rsp+8], eax

; 1013 :         ADD_SPACE( spc );

  03540	48 8d 8c 24 f0
	04 00 00	 lea	 rcx, QWORD PTR spc$[rsp]
  03548	e8 00 00 00 00	 call	 add_spc_to_table

; 1014 : 
; 1015 :         /* Count active L2 tables */
; 1016 :         num_act_L2tab++;

  0354d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR num_act_L2tab
  03553	ff c0		 inc	 eax
  03555	89 05 00 00 00
	00		 mov	 DWORD PTR num_act_L2tab, eax

; 1017 : 
; 1018 :         /* Add all of this L2 table's active track data to the table */
; 1019 :         for (k=0; k < 256 && (L1track + k) < tracks; ++k)

  0355b	c7 84 24 34 01
	00 00 00 00 00
	00		 mov	 DWORD PTR k$[rsp], 0
  03566	eb 10		 jmp	 SHORT $LN25@main
$LN23@main:
  03568	8b 84 24 34 01
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  0356f	ff c0		 inc	 eax
  03571	89 84 24 34 01
	00 00		 mov	 DWORD PTR k$[rsp], eax
$LN25@main:
  03578	81 bc 24 34 01
	00 00 00 01 00
	00		 cmp	 DWORD PTR k$[rsp], 256	; 00000100H
  03583	0f 8d 30 01 00
	00		 jge	 $LN24@main
  03589	8b 84 24 34 01
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  03590	8b 8c 24 54 01
	00 00		 mov	 ecx, DWORD PTR L1track$[rsp]
  03597	03 c8		 add	 ecx, eax
  03599	8b c1		 mov	 eax, ecx
  0359b	3b 84 24 68 01
	00 00		 cmp	 eax, DWORD PTR tracks$[rsp]
  035a2	0f 8d 11 01 00
	00		 jge	 $LN24@main

; 1020 :         {
; 1021 :             if (0
; 1022 :                 || L2tab[k].L2_trkoff == CCKD64_NOSIZE
; 1023 :                 || L2tab[k].L2_trkoff == CCKD64_MAXSIZE

  035a8	33 c0		 xor	 eax, eax
  035aa	85 c0		 test	 eax, eax
  035ac	75 34		 jne	 SHORT $LN132@main
  035ae	48 63 84 24 34
	01 00 00	 movsxd	 rax, DWORD PTR k$[rsp]
  035b6	48 6b c0 10	 imul	 rax, rax, 16
  035ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:L2tab
  035c1	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  035c6	74 1a		 je	 SHORT $LN132@main
  035c8	48 63 84 24 34
	01 00 00	 movsxd	 rax, DWORD PTR k$[rsp]
  035d0	48 6b c0 10	 imul	 rax, rax, 16
  035d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:L2tab
  035db	48 83 3c 01 ff	 cmp	 QWORD PTR [rcx+rax], -1
  035e0	75 02		 jne	 SHORT $LN131@main
$LN132@main:

; 1024 :             )
; 1025 :                 continue;  // (skip non-active tracks)

  035e2	eb 84		 jmp	 SHORT $LN23@main
$LN131@main:

; 1026 : 
; 1027 :             /* Add this track's offset to the table */
; 1028 :             spc.spc_typ  = fba ? SPCTAB_BLKGRP : SPCTAB_TRK;

  035e4	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR fba
  035eb	85 c0		 test	 eax, eax
  035ed	74 0d		 je	 SHORT $LN278@main
  035ef	c7 84 24 dc 01
	00 00 06 00 00
	00		 mov	 DWORD PTR tv1679[rsp], 6
  035fa	eb 0b		 jmp	 SHORT $LN279@main
$LN278@main:
  035fc	c7 84 24 dc 01
	00 00 05 00 00
	00		 mov	 DWORD PTR tv1679[rsp], 5
$LN279@main:
  03607	0f b6 84 24 dc
	01 00 00	 movzx	 eax, BYTE PTR tv1679[rsp]
  0360f	88 84 24 f0 04
	00 00		 mov	 BYTE PTR spc$[rsp], al

; 1029 :             spc.spc_off  = L2tab[k].L2_trkoff;

  03616	48 63 84 24 34
	01 00 00	 movsxd	 rax, DWORD PTR k$[rsp]
  0361e	48 6b c0 10	 imul	 rax, rax, 16
  03622	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:L2tab
  03629	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0362d	48 89 84 24 00
	05 00 00	 mov	 QWORD PTR spc$[rsp+16], rax

; 1030 :             spc.spc_siz  = L2tab[k].L2_size;

  03635	48 63 84 24 34
	01 00 00	 movsxd	 rax, DWORD PTR k$[rsp]
  0363d	48 6b c0 10	 imul	 rax, rax, 16
  03641	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:L2tab
  03648	0f b7 44 01 0a	 movzx	 eax, WORD PTR [rcx+rax+10]
  0364d	48 89 84 24 10
	05 00 00	 mov	 QWORD PTR spc$[rsp+32], rax

; 1031 :             spc.spc_len  = L2tab[k].L2_len;

  03655	48 63 84 24 34
	01 00 00	 movsxd	 rax, DWORD PTR k$[rsp]
  0365d	48 6b c0 10	 imul	 rax, rax, 16
  03661	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:L2tab
  03668	0f b7 44 01 08	 movzx	 eax, WORD PTR [rcx+rax+8]
  0366d	48 89 84 24 08
	05 00 00	 mov	 QWORD PTR spc$[rsp+24], rax

; 1032 :             spc.spc_val  = L1track + k;

  03675	8b 84 24 34 01
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  0367c	8b 8c 24 54 01
	00 00		 mov	 ecx, DWORD PTR L1track$[rsp]
  03683	03 c8		 add	 ecx, eax
  03685	8b c1		 mov	 eax, ecx
  03687	89 84 24 f4 04
	00 00		 mov	 DWORD PTR spc$[rsp+4], eax

; 1033 :             spc.spc_val2 = L1track + k;

  0368e	8b 84 24 34 01
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  03695	8b 8c 24 54 01
	00 00		 mov	 ecx, DWORD PTR L1track$[rsp]
  0369c	03 c8		 add	 ecx, eax
  0369e	8b c1		 mov	 eax, ecx
  036a0	89 84 24 f8 04
	00 00		 mov	 DWORD PTR spc$[rsp+8], eax

; 1034 :             ADD_SPACE( spc );

  036a7	48 8d 8c 24 f0
	04 00 00	 lea	 rcx, QWORD PTR spc$[rsp]
  036af	e8 00 00 00 00	 call	 add_spc_to_table

; 1035 :         }

  036b4	e9 af fe ff ff	 jmp	 $LN23@main
$LN24@main:

; 1036 :     }

  036b9	e9 39 fb ff ff	 jmp	 $LN17@main
$LN18@main:

; 1037 : 
; 1038 :     /* Close input file */
; 1039 :     close( fd );

  036be	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  036c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 1040 : 
; 1041 :     /* Add the calculated L2 tables UPPER bounds to spaces table */
; 1042 :     spc.spc_typ  = SPCTAB_L2UPPER;

  036cb	c6 84 24 f0 04
	00 00 0a	 mov	 BYTE PTR spc$[rsp], 10

; 1043 :     spc.spc_off  = L2_lower_pos + (num_act_L2tab * (cckd64 ? size : size32));

  036d3	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  036da	85 c0		 test	 eax, eax
  036dc	74 10		 je	 SHORT $LN280@main
  036de	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  036e5	89 84 24 e0 01
	00 00		 mov	 DWORD PTR tv1701[rsp], eax
  036ec	eb 0e		 jmp	 SHORT $LN281@main
$LN280@main:
  036ee	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR size32$[rsp]
  036f5	89 84 24 e0 01
	00 00		 mov	 DWORD PTR tv1701[rsp], eax
$LN281@main:
  036fc	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR num_act_L2tab
  03702	0f af 84 24 e0
	01 00 00	 imul	 eax, DWORD PTR tv1701[rsp]
  0370a	8b c0		 mov	 eax, eax
  0370c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR L2_lower_pos
  03713	48 03 c8	 add	 rcx, rax
  03716	48 8b c1	 mov	 rax, rcx
  03719	48 89 84 24 00
	05 00 00	 mov	 QWORD PTR spc$[rsp+16], rax

; 1044 :     spc.spc_siz  = 0;

  03721	48 c7 84 24 10
	05 00 00 00 00
	00 00		 mov	 QWORD PTR spc$[rsp+32], 0

; 1045 :     spc.spc_len  = 0;

  0372d	48 c7 84 24 08
	05 00 00 00 00
	00 00		 mov	 QWORD PTR spc$[rsp+24], 0

; 1046 :     spc.spc_val  = -1;

  03739	c7 84 24 f4 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR spc$[rsp+4], -1

; 1047 :     spc.spc_val2 = -1;

  03744	c7 84 24 f8 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR spc$[rsp+8], -1

; 1048 :     ADD_SPACE( spc );

  0374f	48 8d 8c 24 f0
	04 00 00	 lea	 rcx, QWORD PTR spc$[rsp]
  03757	e8 00 00 00 00	 call	 add_spc_to_table

; 1049 : 
; 1050 :     /* Consolidate track data unless detailed track report wanted */
; 1051 :     if (!verbose && !info_only)

  0375c	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR verbose
  03763	85 c0		 test	 eax, eax
  03765	0f 85 e5 02 00
	00		 jne	 $LN133@main
  0376b	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR info_only
  03772	85 c0		 test	 eax, eax
  03774	0f 85 d6 02 00
	00		 jne	 $LN133@main

; 1052 :     {
; 1053 :         /* Sort table by file offset */
; 1054 :         qsort( spacetab, numspace, sizeof( SPCTAB64 ), sort_spacetab_by_file_offset );

  0377a	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR numspace
  03781	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:sort_spacetab_by_file_offset
  03788	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  0378e	48 8b d0	 mov	 rdx, rax
  03791	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  03798	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_qsort

; 1055 : 
; 1056 :         /* Find contiguous track entries... */
; 1057 :         for (i=0; i < numspace && spacetab[i].spc_typ != SPCTAB_EOF; ++i)

  0379e	c7 84 24 30 01
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  037a9	eb 10		 jmp	 SHORT $LN28@main
$LN26@main:
  037ab	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  037b2	ff c0		 inc	 eax
  037b4	89 84 24 30 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN28@main:
  037bb	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numspace
  037c1	39 84 24 30 01
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  037c8	0f 8d 01 02 00
	00		 jge	 $LN27@main
  037ce	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  037d6	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  037da	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  037e1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  037e5	83 f8 08	 cmp	 eax, 8
  037e8	0f 84 e1 01 00
	00		 je	 $LN27@main

; 1058 :         {
; 1059 :             /* Find next unconsolidated track entry... */
; 1060 :             if (spacetab[i].spc_typ != (fba ? SPCTAB_BLKGRP : SPCTAB_TRK))

  037ee	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR fba
  037f5	85 c0		 test	 eax, eax
  037f7	74 0d		 je	 SHORT $LN282@main
  037f9	c7 84 24 e4 01
	00 00 06 00 00
	00		 mov	 DWORD PTR tv1762[rsp], 6
  03804	eb 0b		 jmp	 SHORT $LN283@main
$LN282@main:
  03806	c7 84 24 e4 01
	00 00 05 00 00
	00		 mov	 DWORD PTR tv1762[rsp], 5
$LN283@main:
  03811	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  03819	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  0381d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  03824	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  03828	3b 84 24 e4 01
	00 00		 cmp	 eax, DWORD PTR tv1762[rsp]
  0382f	74 05		 je	 SHORT $LN134@main

; 1061 :                 continue;

  03831	e9 75 ff ff ff	 jmp	 $LN26@main
$LN134@main:

; 1062 : 
; 1063 :             /* We found a track entry. Consolidate all IMMEDIATELY
; 1064 :                following ADJACENT/contiguous track entries into one. */
; 1065 : 
; 1066 :             spacetab[i].spc_typ = SPCTAB_DATA;

  03836	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0383e	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  03842	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  03849	c6 04 01 0b	 mov	 BYTE PTR [rcx+rax], 11

; 1067 : 
; 1068 :             for (k = i+1; k < numspace; ++k)

  0384d	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  03854	ff c0		 inc	 eax
  03856	89 84 24 34 01
	00 00		 mov	 DWORD PTR k$[rsp], eax
  0385d	eb 10		 jmp	 SHORT $LN31@main
$LN29@main:
  0385f	8b 84 24 34 01
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  03866	ff c0		 inc	 eax
  03868	89 84 24 34 01
	00 00		 mov	 DWORD PTR k$[rsp], eax
$LN31@main:
  0386f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numspace
  03875	39 84 24 34 01
	00 00		 cmp	 DWORD PTR k$[rsp], eax
  0387c	0f 8d 48 01 00
	00		 jge	 $LN30@main

; 1069 :             {
; 1070 :                 /* Is this track IMMEDIATELY ADJACENT TO previous? */
; 1071 :                 if (0
; 1072 :                     || spacetab[k].spc_typ != (fba ? SPCTAB_BLKGRP : SPCTAB_TRK)
; 1073 :                     || spacetab[k].spc_off != (spacetab[i].spc_off + spacetab[i].spc_siz)

  03882	33 c0		 xor	 eax, eax
  03884	85 c0		 test	 eax, eax
  03886	0f 85 8d 00 00
	00		 jne	 $LN136@main
  0388c	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR fba
  03893	85 c0		 test	 eax, eax
  03895	74 0d		 je	 SHORT $LN284@main
  03897	c7 84 24 e8 01
	00 00 06 00 00
	00		 mov	 DWORD PTR tv1779[rsp], 6
  038a2	eb 0b		 jmp	 SHORT $LN285@main
$LN284@main:
  038a4	c7 84 24 e8 01
	00 00 05 00 00
	00		 mov	 DWORD PTR tv1779[rsp], 5
$LN285@main:
  038af	48 63 84 24 34
	01 00 00	 movsxd	 rax, DWORD PTR k$[rsp]
  038b7	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  038bb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  038c2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  038c6	3b 84 24 e8 01
	00 00		 cmp	 eax, DWORD PTR tv1779[rsp]
  038cd	75 4a		 jne	 SHORT $LN136@main
  038cf	48 63 84 24 34
	01 00 00	 movsxd	 rax, DWORD PTR k$[rsp]
  038d7	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  038db	48 63 8c 24 30
	01 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  038e3	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  038e7	48 63 94 24 30
	01 00 00	 movsxd	 rdx, DWORD PTR i$[rsp]
  038ef	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  038f3	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR spacetab
  038fa	48 8b 4c 0f 10	 mov	 rcx, QWORD PTR [rdi+rcx+16]
  038ff	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR spacetab
  03906	48 03 4c 17 20	 add	 rcx, QWORD PTR [rdi+rdx+32]
  0390b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR spacetab
  03912	48 39 4c 02 10	 cmp	 QWORD PTR [rdx+rax+16], rcx
  03917	74 05		 je	 SHORT $LN135@main
$LN136@main:

; 1074 :                 )
; 1075 :                     break;

  03919	e9 ac 00 00 00	 jmp	 $LN30@main
$LN135@main:

; 1076 : 
; 1077 :                 /* Consolidate this track's data
; 1078 :                    into original previous  entry
; 1079 :                 */
; 1080 :                 spacetab[i].spc_siz += spacetab[k].spc_siz;

  0391e	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  03926	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  0392a	48 63 8c 24 34
	01 00 00	 movsxd	 rcx, DWORD PTR k$[rsp]
  03932	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  03936	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR spacetab
  0393d	48 8b 44 02 20	 mov	 rax, QWORD PTR [rdx+rax+32]
  03942	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR spacetab
  03949	48 03 44 0a 20	 add	 rax, QWORD PTR [rdx+rcx+32]
  0394e	48 63 8c 24 30
	01 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  03956	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  0395a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR spacetab
  03961	48 89 44 0a 20	 mov	 QWORD PTR [rdx+rcx+32], rax

; 1081 :                 spacetab[i].spc_len += spacetab[k].spc_len;

  03966	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0396e	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  03972	48 63 8c 24 34
	01 00 00	 movsxd	 rcx, DWORD PTR k$[rsp]
  0397a	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  0397e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR spacetab
  03985	48 8b 44 02 18	 mov	 rax, QWORD PTR [rdx+rax+24]
  0398a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR spacetab
  03991	48 03 44 0a 18	 add	 rax, QWORD PTR [rdx+rcx+24]
  03996	48 63 8c 24 30
	01 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  0399e	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  039a2	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR spacetab
  039a9	48 89 44 0a 18	 mov	 QWORD PTR [rdx+rcx+24], rax

; 1082 : 
; 1083 :                 /* Mark track as having been consolidated */
; 1084 :                 spacetab[k].spc_typ = SPCTAB_NONE;

  039ae	48 63 84 24 34
	01 00 00	 movsxd	 rax, DWORD PTR k$[rsp]
  039b6	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  039ba	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  039c1	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 1085 :             }

  039c5	e9 95 fe ff ff	 jmp	 $LN29@main
$LN30@main:

; 1086 :         }

  039ca	e9 dc fd ff ff	 jmp	 $LN26@main
$LN27@main:

; 1087 : 
; 1088 :         /* Remove consolidated spaces (all SPCTAB_NONE spaces) */
; 1089 :         for (i=0; i < numspace && spacetab[i].spc_typ != SPCTAB_EOF; ++i)

  039cf	c7 84 24 30 01
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  039da	eb 10		 jmp	 SHORT $LN34@main
$LN32@main:
  039dc	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  039e3	ff c0		 inc	 eax
  039e5	89 84 24 30 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN34@main:
  039ec	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numspace
  039f2	39 84 24 30 01
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  039f9	7d 55		 jge	 SHORT $LN33@main
  039fb	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  03a03	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  03a07	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  03a0e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  03a12	83 f8 08	 cmp	 eax, 8
  03a15	74 39		 je	 SHORT $LN33@main

; 1090 :         {
; 1091 :             if (SPCTAB_NONE == spacetab[i].spc_typ)

  03a17	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  03a1f	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  03a23	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  03a2a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  03a2e	85 c0		 test	 eax, eax
  03a30	75 1c		 jne	 SHORT $LN137@main

; 1092 :             {
; 1093 :                 DEL_SPACE( i );

  03a32	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  03a39	e8 00 00 00 00	 call	 del_spc_from_table

; 1094 :                 i--;

  03a3e	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  03a45	ff c8		 dec	 eax
  03a47	89 84 24 30 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN137@main:

; 1095 :             }
; 1096 :         }

  03a4e	eb 8c		 jmp	 SHORT $LN32@main
$LN33@main:
$LN133@main:
$LN37@main:

; 1097 :     }
; 1098 : 
; 1099 :     /* Scan for unknown space and add to table */
; 1100 :     do
; 1101 :     {
; 1102 :         /* Sort table by file offset */
; 1103 :         qsort( spacetab, numspace, sizeof( SPCTAB64 ), sort_spacetab_by_file_offset );

  03a50	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR numspace
  03a57	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:sort_spacetab_by_file_offset
  03a5e	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  03a64	48 8b d0	 mov	 rdx, rax
  03a67	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  03a6e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_qsort

; 1104 : 
; 1105 :         /* Find gaps */
; 1106 :         for (i=0; i < numspace && spacetab[i].spc_typ != SPCTAB_EOF; ++i)

  03a74	c7 84 24 30 01
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  03a7f	eb 10		 jmp	 SHORT $LN40@main
$LN38@main:
  03a81	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  03a88	ff c0		 inc	 eax
  03a8a	89 84 24 30 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN40@main:
  03a91	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numspace
  03a97	39 84 24 30 01
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  03a9e	0f 8d 9f 01 00
	00		 jge	 $LN39@main
  03aa4	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  03aac	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  03ab0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  03ab7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  03abb	83 f8 08	 cmp	 eax, 8
  03abe	0f 84 7f 01 00
	00		 je	 $LN39@main

; 1107 :         {
; 1108 :             if (0
; 1109 :                 ||  spacetab[i].spc_typ == SPCTAB_NONE
; 1110 :                 ||  spacetab[i].spc_siz == 0
; 1111 :                 || (spacetab[i].spc_off + spacetab[i].spc_siz) >= spacetab[i+1].spc_off

  03ac4	33 c0		 xor	 eax, eax
  03ac6	85 c0		 test	 eax, eax
  03ac8	0f 85 84 00 00
	00		 jne	 $LN139@main
  03ace	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  03ad6	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  03ada	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  03ae1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  03ae5	85 c0		 test	 eax, eax
  03ae7	74 69		 je	 SHORT $LN139@main
  03ae9	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  03af1	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  03af5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  03afc	48 83 7c 01 20
	00		 cmp	 QWORD PTR [rcx+rax+32], 0
  03b02	74 4e		 je	 SHORT $LN139@main
  03b04	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  03b0c	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  03b10	48 63 8c 24 30
	01 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  03b18	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  03b1c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR spacetab
  03b23	48 8b 44 02 10	 mov	 rax, QWORD PTR [rdx+rax+16]
  03b28	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR spacetab
  03b2f	48 03 44 0a 20	 add	 rax, QWORD PTR [rdx+rcx+32]
  03b34	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  03b3b	ff c1		 inc	 ecx
  03b3d	48 63 c9	 movsxd	 rcx, ecx
  03b40	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  03b44	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR spacetab
  03b4b	48 3b 44 0a 10	 cmp	 rax, QWORD PTR [rdx+rcx+16]
  03b50	72 05		 jb	 SHORT $LN138@main
$LN139@main:

; 1112 :             )
; 1113 :                 continue;

  03b52	e9 2a ff ff ff	 jmp	 $LN38@main
$LN138@main:

; 1114 : 
; 1115 :             /* Unknown space detected! */
; 1116 :             spc.spc_typ  = SPCTAB_UNKNOWN;

  03b57	c6 84 24 f0 04
	00 00 0c	 mov	 BYTE PTR spc$[rsp], 12

; 1117 :             spc.spc_off  =                         (spacetab[i].spc_off + spacetab[i].spc_siz);

  03b5f	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  03b67	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  03b6b	48 63 8c 24 30
	01 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  03b73	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  03b77	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR spacetab
  03b7e	48 8b 44 02 10	 mov	 rax, QWORD PTR [rdx+rax+16]
  03b83	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR spacetab
  03b8a	48 03 44 0a 20	 add	 rax, QWORD PTR [rdx+rcx+32]
  03b8f	48 89 84 24 00
	05 00 00	 mov	 QWORD PTR spc$[rsp+16], rax

; 1118 :             spc.spc_siz  = spacetab[i+1].spc_off - (spacetab[i].spc_off + spacetab[i].spc_siz);

  03b97	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  03b9e	ff c0		 inc	 eax
  03ba0	48 98		 cdqe
  03ba2	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  03ba6	48 63 8c 24 30
	01 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  03bae	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  03bb2	48 63 94 24 30
	01 00 00	 movsxd	 rdx, DWORD PTR i$[rsp]
  03bba	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  03bbe	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR spacetab
  03bc5	48 8b 4c 0f 10	 mov	 rcx, QWORD PTR [rdi+rcx+16]
  03bca	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR spacetab
  03bd1	48 03 4c 17 20	 add	 rcx, QWORD PTR [rdi+rdx+32]
  03bd6	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR spacetab
  03bdd	48 8b 44 02 10	 mov	 rax, QWORD PTR [rdx+rax+16]
  03be2	48 2b c1	 sub	 rax, rcx
  03be5	48 89 84 24 10
	05 00 00	 mov	 QWORD PTR spc$[rsp+32], rax

; 1119 :             spc.spc_len  = spc.spc_siz;

  03bed	48 8b 84 24 10
	05 00 00	 mov	 rax, QWORD PTR spc$[rsp+32]
  03bf5	48 89 84 24 08
	05 00 00	 mov	 QWORD PTR spc$[rsp+24], rax

; 1120 :             spc.spc_val  = -1;

  03bfd	c7 84 24 f4 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR spc$[rsp+4], -1

; 1121 :             spc.spc_val2 = -1;

  03c08	c7 84 24 f8 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR spc$[rsp+8], -1

; 1122 :             total_unknown += spc.spc_siz;

  03c13	48 8b 84 24 10
	05 00 00	 mov	 rax, QWORD PTR spc$[rsp+32]
  03c1b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR total_unknown
  03c22	48 03 c8	 add	 rcx, rax
  03c25	48 8b c1	 mov	 rax, rcx
  03c28	48 89 05 00 00
	00 00		 mov	 QWORD PTR total_unknown, rax

; 1123 :             ADD_SPACE( spc );

  03c2f	48 8d 8c 24 f0
	04 00 00	 lea	 rcx, QWORD PTR spc$[rsp]
  03c37	e8 00 00 00 00	 call	 add_spc_to_table

; 1124 :             break;

  03c3c	eb 05		 jmp	 SHORT $LN39@main

; 1125 :         }

  03c3e	e9 3e fe ff ff	 jmp	 $LN38@main
$LN39@main:

; 1126 :     }
; 1127 :     while (spacetab[i].spc_typ != SPCTAB_EOF);

  03c43	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  03c4b	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  03c4f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  03c56	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  03c5a	83 f8 08	 cmp	 eax, 8
  03c5d	0f 85 ed fd ff
	ff		 jne	 $LN37@main

; 1128 : 
; 1129 :     if (total_unknown)

  03c63	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR total_unknown, 0
  03c6b	0f 84 b0 00 00
	00		 je	 $LN140@main

; 1130 :     {
; 1131 :         // ""
; 1132 :         // "Total unknown space    = %s bytes"
; 1133 :         fmt_S64( str_total, (S64) total_unknown );

  03c71	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR total_unknown
  03c78	48 8d 8c 24 50
	07 00 00	 lea	 rcx, QWORD PTR str_total$[rsp]
  03c80	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fmt_S64

; 1134 :         WRMSG( HHC03020, "I" );

  03c86	b9 01 00 00 00	 mov	 ecx, 1
  03c8b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  03c91	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169295
  03c98	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  03c9d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169296
  03ca4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  03ca9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  03cae	41 b9 03 00 00
	00		 mov	 r9d, 3
  03cb4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169297
  03cbb	ba 6e 04 00 00	 mov	 edx, 1134		; 0000046eH
  03cc0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169298
  03cc7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1135 :         WRMSG( HHC03049, "I", str_total );

  03ccd	b9 01 00 00 00	 mov	 ecx, 1
  03cd2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  03cd8	48 8d 8c 24 50
	07 00 00	 lea	 rcx, QWORD PTR str_total$[rsp]
  03ce0	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  03ce5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169299
  03cec	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  03cf1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169300
  03cf8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  03cfd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  03d02	41 b9 03 00 00
	00		 mov	 r9d, 3
  03d08	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169301
  03d0f	ba 6f 04 00 00	 mov	 edx, 1135		; 0000046fH
  03d14	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169302
  03d1b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN140@main:

; 1136 :     }
; 1137 : 
; 1138 :     /* Calculate average distance from each L2 table to its tracks/blkgrps */
; 1139 : 
; 1140 :     if (verbose || info_only)  /* (inaccurate statistics otherwise!) */

  03d21	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR verbose
  03d28	85 c0		 test	 eax, eax
  03d2a	75 0f		 jne	 SHORT $LN142@main
  03d2c	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR info_only
  03d33	85 c0		 test	 eax, eax
  03d35	0f 84 10 05 00
	00		 je	 $LN141@main
$LN142@main:

; 1141 :     {
; 1142 :         seek_total    = 0;

  03d3b	48 c7 84 24 a0
	01 00 00 00 00
	00 00		 mov	 QWORD PTR seek_total$[rsp], 0

; 1143 :         active_tracks = 0;

  03d47	c7 84 24 60 01
	00 00 00 00 00
	00		 mov	 DWORD PTR active_tracks$[rsp], 0

; 1144 : 
; 1145 :         for (i=0; i < numspace && spacetab[i].spc_typ != SPCTAB_EOF; ++i)

  03d52	c7 84 24 30 01
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  03d5d	eb 10		 jmp	 SHORT $LN43@main
$LN41@main:
  03d5f	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  03d66	ff c0		 inc	 eax
  03d68	89 84 24 30 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN43@main:
  03d6f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numspace
  03d75	39 84 24 30 01
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  03d7c	0f 8d 27 02 00
	00		 jge	 $LN42@main
  03d82	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  03d8a	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  03d8e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  03d95	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  03d99	83 f8 08	 cmp	 eax, 8
  03d9c	0f 84 07 02 00
	00		 je	 $LN42@main

; 1146 :         {
; 1147 :             /* Locate next L2 table entry */
; 1148 :             if (spacetab[i].spc_typ != SPCTAB_L2)

  03da2	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  03daa	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  03dae	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  03db5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  03db9	83 f8 04	 cmp	 eax, 4
  03dbc	74 02		 je	 SHORT $LN143@main

; 1149 :                 continue;

  03dbe	eb 9f		 jmp	 SHORT $LN41@main
$LN143@main:

; 1150 : 
; 1151 :             /* Save starting track/blkgrp number for this L2 table */
; 1152 :             L1track = spacetab[i].spc_val;

  03dc0	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  03dc8	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  03dcc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  03dd3	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  03dd7	89 84 24 54 01
	00 00		 mov	 DWORD PTR L1track$[rsp], eax

; 1153 : 
; 1154 :             /* Find all tracks/blkgrps for this L2 table */
; 1155 :             for (k=0; k < numspace && spacetab[k].spc_typ != SPCTAB_EOF; ++k)

  03dde	c7 84 24 34 01
	00 00 00 00 00
	00		 mov	 DWORD PTR k$[rsp], 0
  03de9	eb 10		 jmp	 SHORT $LN46@main
$LN44@main:
  03deb	8b 84 24 34 01
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  03df2	ff c0		 inc	 eax
  03df4	89 84 24 34 01
	00 00		 mov	 DWORD PTR k$[rsp], eax
$LN46@main:
  03dfb	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numspace
  03e01	39 84 24 34 01
	00 00		 cmp	 DWORD PTR k$[rsp], eax
  03e08	0f 8d 96 01 00
	00		 jge	 $LN45@main
  03e0e	48 63 84 24 34
	01 00 00	 movsxd	 rax, DWORD PTR k$[rsp]
  03e16	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  03e1a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  03e21	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  03e25	83 f8 08	 cmp	 eax, 8
  03e28	0f 84 76 01 00
	00		 je	 $LN45@main

; 1156 :             {
; 1157 :                 if ((0
; 1158 :                     || spacetab[k].spc_typ == SPCTAB_TRK
; 1159 :                     || spacetab[k].spc_typ == SPCTAB_BLKGRP
; 1160 :                 )
; 1161 :                 && (1

  03e2e	33 c0		 xor	 eax, eax
  03e30	85 c0		 test	 eax, eax
  03e32	75 3c		 jne	 SHORT $LN145@main
  03e34	48 63 84 24 34
	01 00 00	 movsxd	 rax, DWORD PTR k$[rsp]
  03e3c	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  03e40	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  03e47	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  03e4b	83 f8 05	 cmp	 eax, 5
  03e4e	74 20		 je	 SHORT $LN145@main
  03e50	48 63 84 24 34
	01 00 00	 movsxd	 rax, DWORD PTR k$[rsp]
  03e58	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  03e5c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  03e63	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  03e67	83 f8 06	 cmp	 eax, 6
  03e6a	0f 85 2f 01 00
	00		 jne	 $LN144@main
$LN145@main:
  03e70	33 c0		 xor	 eax, eax
  03e72	83 f8 01	 cmp	 eax, 1
  03e75	0f 84 24 01 00
	00		 je	 $LN144@main
  03e7b	48 63 84 24 34
	01 00 00	 movsxd	 rax, DWORD PTR k$[rsp]
  03e83	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  03e87	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  03e8e	8b 94 24 54 01
	00 00		 mov	 edx, DWORD PTR L1track$[rsp]
  03e95	39 54 01 04	 cmp	 DWORD PTR [rcx+rax+4], edx
  03e99	0f 8c 00 01 00
	00		 jl	 $LN144@main
  03e9f	48 63 84 24 34
	01 00 00	 movsxd	 rax, DWORD PTR k$[rsp]
  03ea7	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  03eab	8b 8c 24 54 01
	00 00		 mov	 ecx, DWORD PTR L1track$[rsp]
  03eb2	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  03eb8	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR spacetab
  03ebf	39 4c 02 04	 cmp	 DWORD PTR [rdx+rax+4], ecx
  03ec3	0f 8d d6 00 00
	00		 jge	 $LN144@main

; 1162 :                     && spacetab[k].spc_val >= (L1track +   0)
; 1163 :                     && spacetab[k].spc_val <  (L1track + 256)
; 1164 :                 ))
; 1165 :                 {
; 1166 :                     /* Count active track/blkgrp */
; 1167 :                     active_tracks++;

  03ec9	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR active_tracks$[rsp]
  03ed0	ff c0		 inc	 eax
  03ed2	89 84 24 60 01
	00 00		 mov	 DWORD PTR active_tracks$[rsp], eax

; 1168 : 
; 1169 :                     /* Calculate this track's/blkgrp's distance from its L2 table */
; 1170 :                     if (                spacetab[i].spc_off > spacetab[k].spc_off)

  03ed9	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  03ee1	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  03ee5	48 63 8c 24 34
	01 00 00	 movsxd	 rcx, DWORD PTR k$[rsp]
  03eed	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  03ef1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR spacetab
  03ef8	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR spacetab
  03eff	48 8b 4c 0f 10	 mov	 rcx, QWORD PTR [rdi+rcx+16]
  03f04	48 39 4c 02 10	 cmp	 QWORD PTR [rdx+rax+16], rcx
  03f09	76 4b		 jbe	 SHORT $LN146@main

; 1171 :                          seek_total += (spacetab[i].spc_off - spacetab[k].spc_off);

  03f0b	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  03f13	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  03f17	48 63 8c 24 34
	01 00 00	 movsxd	 rcx, DWORD PTR k$[rsp]
  03f1f	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  03f23	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR spacetab
  03f2a	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR spacetab
  03f31	48 8b 4c 0f 10	 mov	 rcx, QWORD PTR [rdi+rcx+16]
  03f36	48 8b 44 02 10	 mov	 rax, QWORD PTR [rdx+rax+16]
  03f3b	48 2b c1	 sub	 rax, rcx
  03f3e	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR seek_total$[rsp]
  03f46	48 03 c8	 add	 rcx, rax
  03f49	48 8b c1	 mov	 rax, rcx
  03f4c	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR seek_total$[rsp], rax
  03f54	eb 49		 jmp	 SHORT $LN147@main
$LN146@main:

; 1172 :                     else seek_total += (spacetab[k].spc_off - spacetab[i].spc_off);

  03f56	48 63 84 24 34
	01 00 00	 movsxd	 rax, DWORD PTR k$[rsp]
  03f5e	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  03f62	48 63 8c 24 30
	01 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  03f6a	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  03f6e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR spacetab
  03f75	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR spacetab
  03f7c	48 8b 4c 0f 10	 mov	 rcx, QWORD PTR [rdi+rcx+16]
  03f81	48 8b 44 02 10	 mov	 rax, QWORD PTR [rdx+rax+16]
  03f86	48 2b c1	 sub	 rax, rcx
  03f89	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR seek_total$[rsp]
  03f91	48 03 c8	 add	 rcx, rax
  03f94	48 8b c1	 mov	 rax, rcx
  03f97	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR seek_total$[rsp], rax
$LN147@main:
$LN144@main:

; 1173 :                 }
; 1174 :             }

  03f9f	e9 47 fe ff ff	 jmp	 $LN44@main
$LN45@main:

; 1175 :         }

  03fa4	e9 b6 fd ff ff	 jmp	 $LN41@main
$LN42@main:

; 1176 : 
; 1177 :         if (fba)

  03fa9	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR fba
  03fb0	85 c0		 test	 eax, eax
  03fb2	0f 84 4c 01 00
	00		 je	 $LN148@main

; 1178 :         {
; 1179 :             // ""
; 1180 :             // "Total active blkgrps   = %"PRIu32" groups"
; 1181 :             // "Avg. L2-to-block seek  = %.3f MB"
; 1182 :             if (!total_unknown) WRMSG( HHC03020, "I" );

  03fb8	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR total_unknown, 0
  03fc0	75 47		 jne	 SHORT $LN150@main
  03fc2	b9 01 00 00 00	 mov	 ecx, 1
  03fc7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  03fcd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169313
  03fd4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  03fd9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169314
  03fe0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  03fe5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  03fea	41 b9 03 00 00
	00		 mov	 r9d, 3
  03ff0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169315
  03ff7	ba 9e 04 00 00	 mov	 edx, 1182		; 0000049eH
  03ffc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169316
  04003	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN150@main:

; 1183 :             WRMSG( HHC03045, "I", active_tracks );

  04009	b9 01 00 00 00	 mov	 ecx, 1
  0400e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  04014	8b 8c 24 60 01
	00 00		 mov	 ecx, DWORD PTR active_tracks$[rsp]
  0401b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0401f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169317
  04026	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0402b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169318
  04032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  04037	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0403c	41 b9 03 00 00
	00		 mov	 r9d, 3
  04042	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169319
  04049	ba 9f 04 00 00	 mov	 edx, 1183		; 0000049fH
  0404e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169320
  04055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1184 :             WRMSG( HHC03046, "I", (((double) seek_total)/((double) active_tracks)) / (1024.0 * 1024.0) );

  0405b	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR seek_total$[rsp]
  04063	48 85 c0	 test	 rax, rax
  04066	7c 07		 jl	 SHORT $LN296@main
  04068	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  0406d	eb 19		 jmp	 SHORT $LN297@main
$LN296@main:
  0406f	48 8b c8	 mov	 rcx, rax
  04072	48 d1 e9	 shr	 rcx, 1
  04075	48 83 e0 01	 and	 rax, 1
  04079	48 0b c8	 or	 rcx, rax
  0407c	f2 48 0f 2a c9	 cvtsi2sd xmm1, rcx
  04081	f2 0f 58 c9	 addsd	 xmm1, xmm1
  04085	0f 28 c1	 movaps	 xmm0, xmm1
$LN297@main:
  04088	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR active_tracks$[rsp]
  0408f	f2 48 0f 2a c8	 cvtsi2sd xmm1, rax
  04094	f2 0f 5e c1	 divsd	 xmm0, xmm1
  04098	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4130000000000000
  040a0	f2 0f 11 84 24
	c8 04 00 00	 movsd	 QWORD PTR tv2112[rsp], xmm0
  040a9	b9 01 00 00 00	 mov	 ecx, 1
  040ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  040b4	f2 0f 10 84 24
	c8 04 00 00	 movsd	 xmm0, QWORD PTR tv2112[rsp]
  040bd	f2 0f 11 44 24
	38		 movsd	 QWORD PTR [rsp+56], xmm0
  040c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169321
  040ca	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  040cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169322
  040d6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  040db	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  040e0	41 b9 03 00 00
	00		 mov	 r9d, 3
  040e6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169323
  040ed	ba a0 04 00 00	 mov	 edx, 1184		; 000004a0H
  040f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169324
  040f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1185 :         }

  040ff	e9 47 01 00 00	 jmp	 $LN149@main
$LN148@main:

; 1186 :         else
; 1187 :         {
; 1188 :             // ""
; 1189 :             // "Total active tracks    = %"PRIu32" tracks"
; 1190 :             // "Avg. L2-to-track seek  = %.3f MB"
; 1191 :             if (!total_unknown) WRMSG( HHC03020, "I" );

  04104	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR total_unknown, 0
  0410c	75 47		 jne	 SHORT $LN151@main
  0410e	b9 01 00 00 00	 mov	 ecx, 1
  04113	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  04119	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169326
  04120	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  04125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169327
  0412c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  04131	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  04136	41 b9 03 00 00
	00		 mov	 r9d, 3
  0413c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169328
  04143	ba a7 04 00 00	 mov	 edx, 1191		; 000004a7H
  04148	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169329
  0414f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN151@main:

; 1192 :             WRMSG( HHC03043, "I", active_tracks );

  04155	b9 01 00 00 00	 mov	 ecx, 1
  0415a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  04160	8b 8c 24 60 01
	00 00		 mov	 ecx, DWORD PTR active_tracks$[rsp]
  04167	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0416b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169330
  04172	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  04177	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169331
  0417e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  04183	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  04188	41 b9 03 00 00
	00		 mov	 r9d, 3
  0418e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169332
  04195	ba a8 04 00 00	 mov	 edx, 1192		; 000004a8H
  0419a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169333
  041a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1193 :             WRMSG( HHC03044, "I", (((double) seek_total)/((double) active_tracks)) / (1024.0 * 1024.0) );

  041a7	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR seek_total$[rsp]
  041af	48 85 c0	 test	 rax, rax
  041b2	7c 07		 jl	 SHORT $LN294@main
  041b4	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  041b9	eb 19		 jmp	 SHORT $LN295@main
$LN294@main:
  041bb	48 8b c8	 mov	 rcx, rax
  041be	48 d1 e9	 shr	 rcx, 1
  041c1	48 83 e0 01	 and	 rax, 1
  041c5	48 0b c8	 or	 rcx, rax
  041c8	f2 48 0f 2a c9	 cvtsi2sd xmm1, rcx
  041cd	f2 0f 58 c9	 addsd	 xmm1, xmm1
  041d1	0f 28 c1	 movaps	 xmm0, xmm1
$LN295@main:
  041d4	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR active_tracks$[rsp]
  041db	f2 48 0f 2a c8	 cvtsi2sd xmm1, rax
  041e0	f2 0f 5e c1	 divsd	 xmm0, xmm1
  041e4	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4130000000000000
  041ec	f2 0f 11 84 24
	d0 04 00 00	 movsd	 QWORD PTR tv2149[rsp], xmm0
  041f5	b9 01 00 00 00	 mov	 ecx, 1
  041fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  04200	f2 0f 10 84 24
	d0 04 00 00	 movsd	 xmm0, QWORD PTR tv2149[rsp]
  04209	f2 0f 11 44 24
	38		 movsd	 QWORD PTR [rsp+56], xmm0
  0420f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169334
  04216	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0421b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169335
  04222	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  04227	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0422c	41 b9 03 00 00
	00		 mov	 r9d, 3
  04232	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169336
  04239	ba a9 04 00 00	 mov	 edx, 1193		; 000004a9H
  0423e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169337
  04245	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN149@main:
$LN141@main:

; 1194 :         }
; 1195 :     }
; 1196 : 
; 1197 :     /* Finally, print the actual map (i.e. where everything is) ... */
; 1198 : 
; 1199 :     if (!info_only)

  0424b	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR info_only
  04252	85 c0		 test	 eax, eax
  04254	0f 85 91 06 00
	00		 jne	 $LN152@main

; 1200 :     {
; 1201 :         if (fba)

  0425a	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR fba
  04261	85 c0		 test	 eax, eax
  04263	0f 84 da 00 00
	00		 je	 $LN153@main

; 1202 :         {
; 1203 :             // ""
; 1204 :             // "         File offset    Size (hex)         Size  group(s)"
; 1205 :             // ""
; 1206 :             WRMSG( HHC03020, "I" );

  04269	b9 01 00 00 00	 mov	 ecx, 1
  0426e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  04274	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169341
  0427b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  04280	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169342
  04287	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0428c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  04291	41 b9 03 00 00
	00		 mov	 r9d, 3
  04297	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169343
  0429e	ba b6 04 00 00	 mov	 edx, 1206		; 000004b6H
  042a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169344
  042aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1207 :             WRMSG( HHC03047, "I" );

  042b0	b9 01 00 00 00	 mov	 ecx, 1
  042b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  042bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169345
  042c2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  042c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169346
  042ce	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  042d3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  042d8	41 b9 03 00 00
	00		 mov	 r9d, 3
  042de	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169347
  042e5	ba b7 04 00 00	 mov	 edx, 1207		; 000004b7H
  042ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169348
  042f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1208 :             WRMSG( HHC03020, "I" );

  042f7	b9 01 00 00 00	 mov	 ecx, 1
  042fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  04302	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169349
  04309	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0430e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169350
  04315	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0431a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0431f	41 b9 03 00 00
	00		 mov	 r9d, 3
  04325	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169351
  0432c	ba b8 04 00 00	 mov	 edx, 1208		; 000004b8H
  04331	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169352
  04338	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1209 :         }

  0433e	e9 d5 00 00 00	 jmp	 $LN154@main
$LN153@main:

; 1210 :         else
; 1211 :         {
; 1212 :             // ""
; 1213 :             // "         File offset    Size (hex)         Size  track(s)"
; 1214 :             // ""
; 1215 :             WRMSG( HHC03020, "I" );

  04343	b9 01 00 00 00	 mov	 ecx, 1
  04348	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0434e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169353
  04355	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0435a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169354
  04361	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  04366	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0436b	41 b9 03 00 00
	00		 mov	 r9d, 3
  04371	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169355
  04378	ba bf 04 00 00	 mov	 edx, 1215		; 000004bfH
  0437d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169356
  04384	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1216 :             WRMSG( HHC03040, "I" );

  0438a	b9 01 00 00 00	 mov	 ecx, 1
  0438f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  04395	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169357
  0439c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  043a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169358
  043a8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  043ad	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  043b2	41 b9 03 00 00
	00		 mov	 r9d, 3
  043b8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169359
  043bf	ba c0 04 00 00	 mov	 edx, 1216		; 000004c0H
  043c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169360
  043cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1217 :             WRMSG( HHC03020, "I" );

  043d1	b9 01 00 00 00	 mov	 ecx, 1
  043d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  043dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169361
  043e3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  043e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169362
  043ef	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  043f4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  043f9	41 b9 03 00 00
	00		 mov	 r9d, 3
  043ff	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169363
  04406	ba c1 04 00 00	 mov	 edx, 1217		; 000004c1H
  0440b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169364
  04412	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN154@main:

; 1218 :         }
; 1219 : 
; 1220 :         for (i=0; i < numspace; ++i)

  04418	c7 84 24 30 01
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  04423	eb 10		 jmp	 SHORT $LN49@main
$LN47@main:
  04425	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0442c	ff c0		 inc	 eax
  0442e	89 84 24 30 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN49@main:
  04435	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numspace
  0443b	39 84 24 30 01
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  04442	0f 8d a3 04 00
	00		 jge	 $LN48@main

; 1221 :         {
; 1222 :             if (spacetab[i].spc_typ == SPCTAB_NONE)

  04448	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  04450	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  04454	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  0445b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0445f	85 c0		 test	 eax, eax
  04461	75 02		 jne	 SHORT $LN155@main

; 1223 :                 continue;

  04463	eb c0		 jmp	 SHORT $LN47@main
$LN155@main:

; 1224 : 
; 1225 :             /* Print dashed line to mark L2 area lower/upper bounds */
; 1226 :             if (0
; 1227 :                 || spacetab[i].spc_typ == SPCTAB_L2LOWER
; 1228 :                 || spacetab[i].spc_typ == SPCTAB_L2UPPER

  04465	33 c0		 xor	 eax, eax
  04467	85 c0		 test	 eax, eax
  04469	75 38		 jne	 SHORT $LN157@main
  0446b	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  04473	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  04477	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  0447e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  04482	83 f8 09	 cmp	 eax, 9
  04485	74 1c		 je	 SHORT $LN157@main
  04487	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0448f	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  04493	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  0449a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0449e	83 f8 0a	 cmp	 eax, 10
  044a1	75 47		 jne	 SHORT $LN156@main
$LN157@main:

; 1229 :             )
; 1230 :                 // "***********************************************************"
; 1231 :                 WRMSG( HHC03041, "I" );

  044a3	b9 01 00 00 00	 mov	 ecx, 1
  044a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  044ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169368
  044b5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  044ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169369
  044c1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  044c6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  044cb	41 b9 03 00 00
	00		 mov	 r9d, 3
  044d1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169370
  044d8	ba cf 04 00 00	 mov	 edx, 1231		; 000004cfH
  044dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169371
  044e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN156@main:

; 1232 : 
; 1233 :             /* Format track/blkgrp number or track/blkgrp range, if appropriate */
; 1234 :             track_range[0] = 0;

  044ea	b8 01 00 00 00	 mov	 eax, 1
  044ef	48 6b c0 00	 imul	 rax, rax, 0
  044f3	48 89 84 24 c0
	03 00 00	 mov	 QWORD PTR $T7[rsp], rax
  044fb	48 83 bc 24 c0
	03 00 00 20	 cmp	 QWORD PTR $T7[rsp], 32	; 00000020H
  04504	73 02		 jae	 SHORT $LN286@main
  04506	eb 05		 jmp	 SHORT $LN287@main
$LN286@main:
  04508	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN287@main:
  0450d	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR $T7[rsp]
  04515	c6 84 04 30 07
	00 00 00	 mov	 BYTE PTR track_range$[rsp+rax], 0

; 1235 :             if (0
; 1236 :                 || spacetab[i].spc_typ == SPCTAB_L2
; 1237 :                 || spacetab[i].spc_typ == SPCTAB_TRK
; 1238 :                 || spacetab[i].spc_typ == SPCTAB_BLKGRP

  0451d	33 c0		 xor	 eax, eax
  0451f	85 c0		 test	 eax, eax
  04521	75 58		 jne	 SHORT $LN159@main
  04523	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0452b	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  0452f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  04536	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0453a	83 f8 04	 cmp	 eax, 4
  0453d	74 3c		 je	 SHORT $LN159@main
  0453f	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  04547	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  0454b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  04552	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  04556	83 f8 05	 cmp	 eax, 5
  04559	74 20		 je	 SHORT $LN159@main
  0455b	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  04563	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  04567	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  0456e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  04572	83 f8 06	 cmp	 eax, 6
  04575	0f 85 cb 00 00
	00		 jne	 $LN158@main
$LN159@main:

; 1239 :             )
; 1240 :             {
; 1241 :                 // Do we have a range or not? (is val2 different from val?)
; 1242 :                 if (spacetab[i].spc_val != spacetab[i].spc_val2)

  0457b	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  04583	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  04587	48 63 8c 24 30
	01 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  0458f	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  04593	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR spacetab
  0459a	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR spacetab
  045a1	8b 4c 0f 08	 mov	 ecx, DWORD PTR [rdi+rcx+8]
  045a5	39 4c 02 04	 cmp	 DWORD PTR [rdx+rax+4], ecx
  045a9	74 4f		 je	 SHORT $LN160@main

; 1243 :                     MSGBUF( track_range, "  %"PRId32" - %"PRId32, spacetab[i].spc_val, spacetab[i].spc_val2 );

  045ab	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  045b3	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  045b7	48 63 8c 24 30
	01 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  045bf	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  045c3	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR spacetab
  045ca	8b 44 02 08	 mov	 eax, DWORD PTR [rdx+rax+8]
  045ce	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  045d2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR spacetab
  045d9	44 8b 4c 08 04	 mov	 r9d, DWORD PTR [rax+rcx+4]
  045de	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169376
  045e5	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  045ea	48 8d 8c 24 30
	07 00 00	 lea	 rcx, QWORD PTR track_range$[rsp]
  045f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  045f8	eb 4c		 jmp	 SHORT $LN161@main
$LN160@main:

; 1244 :                 else if (spacetab[i].spc_val >= 0)

  045fa	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  04602	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  04606	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  0460d	83 7c 01 04 00	 cmp	 DWORD PTR [rcx+rax+4], 0
  04612	7c 32		 jl	 SHORT $LN162@main

; 1245 :                     MSGBUF( track_range, "  %"PRId32,             spacetab[i].spc_val );

  04614	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0461c	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  04620	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  04627	44 8b 4c 01 04	 mov	 r9d, DWORD PTR [rcx+rax+4]
  0462c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169378
  04633	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  04638	48 8d 8c 24 30
	07 00 00	 lea	 rcx, QWORD PTR track_range$[rsp]
  04640	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN162@main:
$LN161@main:
$LN158@main:

; 1246 :             }
; 1247 : 
; 1248 :             /* There should NEVER be any overlaps! */
; 1249 :             overlap =

  04646	33 c0		 xor	 eax, eax
  04648	83 f8 01	 cmp	 eax, 1
  0464b	0f 84 f3 00 00
	00		 je	 $LN288@main
  04651	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  04658	ff c0		 inc	 eax
  0465a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR numspace
  04660	0f 8d de 00 00
	00		 jge	 $LN288@main
  04666	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0466d	48 98		 cdqe
  0466f	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  04673	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  0467a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0467e	83 f8 09	 cmp	 eax, 9
  04681	0f 84 bd 00 00
	00		 je	 $LN288@main
  04687	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0468e	48 98		 cdqe
  04690	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  04694	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  0469b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0469f	83 f8 0a	 cmp	 eax, 10
  046a2	0f 84 9c 00 00
	00		 je	 $LN288@main
  046a8	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  046af	ff c0		 inc	 eax
  046b1	48 98		 cdqe
  046b3	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  046b7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  046be	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  046c2	83 f8 09	 cmp	 eax, 9
  046c5	74 7d		 je	 SHORT $LN288@main
  046c7	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  046ce	ff c0		 inc	 eax
  046d0	48 98		 cdqe
  046d2	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  046d6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  046dd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  046e1	83 f8 0a	 cmp	 eax, 10
  046e4	74 5e		 je	 SHORT $LN288@main
  046e6	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  046ed	48 98		 cdqe
  046ef	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  046f3	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  046fa	48 63 c9	 movsxd	 rcx, ecx
  046fd	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  04701	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR spacetab
  04708	48 8b 44 02 10	 mov	 rax, QWORD PTR [rdx+rax+16]
  0470d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR spacetab
  04714	48 03 44 0a 20	 add	 rax, QWORD PTR [rdx+rcx+32]
  04719	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  04720	ff c1		 inc	 ecx
  04722	48 63 c9	 movsxd	 rcx, ecx
  04725	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  04729	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR spacetab
  04730	48 3b 44 0a 10	 cmp	 rax, QWORD PTR [rdx+rcx+16]
  04735	76 0d		 jbe	 SHORT $LN288@main
  04737	c7 84 24 ec 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv2385[rsp], 1
  04742	eb 0b		 jmp	 SHORT $LN289@main
$LN288@main:
  04744	c7 84 24 ec 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv2385[rsp], 0
$LN289@main:
  0474f	83 bc 24 ec 01
	00 00 00	 cmp	 DWORD PTR tv2385[rsp], 0
  04757	75 0d		 jne	 SHORT $LN290@main
  04759	c7 84 24 f0 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv2387[rsp], 0
  04764	eb 0b		 jmp	 SHORT $LN291@main
$LN290@main:
  04766	c7 84 24 f0 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv2387[rsp], 1
$LN291@main:
  04771	0f b6 84 24 f0
	01 00 00	 movzx	 eax, BYTE PTR tv2387[rsp]
  04779	88 05 00 00 00
	00		 mov	 BYTE PTR overlap, al

; 1250 :             (1
; 1251 :                 /* If there's another space after this one ... */
; 1252 :                 && (i+1) < numspace
; 1253 : 
; 1254 :                 /* ... and neither is a lower/upper bound space ... */
; 1255 :                 &&  spacetab[i+0].spc_typ != SPCTAB_L2LOWER
; 1256 :                 &&  spacetab[i+0].spc_typ != SPCTAB_L2UPPER
; 1257 :                 &&  spacetab[i+1].spc_typ != SPCTAB_L2LOWER
; 1258 :                 &&  spacetab[i+1].spc_typ != SPCTAB_L2UPPER
; 1259 : 
; 1260 :                 /* ... then check if this space overlaps the next */
; 1261 :                 && (spacetab[i+0].spc_off
; 1262 :                   + spacetab[i+0].spc_siz)
; 1263 :                   > spacetab[i+1].spc_off
; 1264 :             )
; 1265 :             ? true : false;
; 1266 : 
; 1267 :             MSGBUF( space_type, "%s%s",

  0477f	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR overlap
  04786	85 c0		 test	 eax, eax
  04788	74 11		 je	 SHORT $LN292@main
  0478a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169379
  04791	48 89 84 24 c8
	03 00 00	 mov	 QWORD PTR tv2392[rsp], rax
  04799	eb 0f		 jmp	 SHORT $LN293@main
$LN292@main:
  0479b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169380
  047a2	48 89 84 24 c8
	03 00 00	 mov	 QWORD PTR tv2392[rsp], rax
$LN293@main:
  047aa	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  047b2	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  047b6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  047bd	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  047c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_spc_typ_to_str
  047c7	48 8b 8c 24 c8
	03 00 00	 mov	 rcx, QWORD PTR tv2392[rsp]
  047cf	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  047d4	4c 8b c8	 mov	 r9, rax
  047d7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169381
  047de	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  047e3	48 8d 8c 24 d0
	07 00 00	 lea	 rcx, QWORD PTR space_type$[rsp]
  047eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1268 :                 spc_typ_to_str( spacetab[i].spc_typ ), overlap ? "!" : "" );
; 1269 : 
; 1270 :             // "%-8s 0x%10.10"PRIX64"  0x%10.10"PRIX64" %11"PRIu64"%s"
; 1271 :             WRMSG( HHC03042, "I", space_type, spacetab[i].spc_off,

  047f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169382
  047f8	48 8d 8c 24 30
	07 00 00	 lea	 rcx, QWORD PTR track_range$[rsp]
  04800	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim
  04806	48 89 84 24 d8
	04 00 00	 mov	 QWORD PTR tv2389[rsp], rax
  0480e	48 63 8c 24 30
	01 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  04816	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  0481a	48 89 8c 24 e0
	04 00 00	 mov	 QWORD PTR tv2408[rsp], rcx
  04822	48 63 94 24 30
	01 00 00	 movsxd	 rdx, DWORD PTR i$[rsp]
  0482a	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  0482e	48 89 94 24 e8
	04 00 00	 mov	 QWORD PTR tv2413[rsp], rdx
  04836	48 63 bc 24 30
	01 00 00	 movsxd	 rdi, DWORD PTR i$[rsp]
  0483e	48 6b ff 28	 imul	 rdi, rdi, 40		; 00000028H
  04842	b9 01 00 00 00	 mov	 ecx, 1
  04847	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0484d	48 8b 8c 24 d8
	04 00 00	 mov	 rcx, QWORD PTR tv2389[rsp]
  04855	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0485a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  04861	48 8b 94 24 e0
	04 00 00	 mov	 rdx, QWORD PTR tv2408[rsp]
  04869	48 8b 4c 11 20	 mov	 rcx, QWORD PTR [rcx+rdx+32]
  0486e	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  04873	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  0487a	48 8b 94 24 e8
	04 00 00	 mov	 rdx, QWORD PTR tv2413[rsp]
  04882	48 8b 4c 11 20	 mov	 rcx, QWORD PTR [rcx+rdx+32]
  04887	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0488c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  04893	48 8b 4c 39 10	 mov	 rcx, QWORD PTR [rcx+rdi+16]
  04898	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0489d	48 8d 8c 24 d0
	07 00 00	 lea	 rcx, QWORD PTR space_type$[rsp]
  048a5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  048aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169383
  048b1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  048b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169384
  048bd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  048c2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  048c7	41 b9 03 00 00
	00		 mov	 r9d, 3
  048cd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169385
  048d4	ba f8 04 00 00	 mov	 edx, 1272		; 000004f8H
  048d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169386
  048e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1272 :                 spacetab[i].spc_siz, spacetab[i].spc_siz, RTRIM( track_range ));
; 1273 :         }

  048e6	e9 3a fb ff ff	 jmp	 $LN47@main
$LN48@main:
$LN152@main:

; 1274 :     }
; 1275 : 
; 1276 :     WRMSG( HHC03020, "I" );

  048eb	b9 01 00 00 00	 mov	 ecx, 1
  048f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  048f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169387
  048fd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  04902	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169388
  04909	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0490e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  04913	41 b9 03 00 00
	00		 mov	 r9d, 3
  04919	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169389
  04920	ba fc 04 00 00	 mov	 edx, 1276		; 000004fcH
  04925	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169390
  0492c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1277 : 
; 1278 :     /* DONE! */
; 1279 :     return 0;

  04932	33 c0		 xor	 eax, eax
$LN1@main:
$LN163@main:

; 1280 : }

  04934	48 8b 8c 24 80
	09 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0493c	48 33 cc	 xor	 rcx, rsp
  0493f	e8 00 00 00 00	 call	 __security_check_cookie
  04944	48 81 c4 98 09
	00 00		 add	 rsp, 2456		; 00000998H
  0494b	5f		 pop	 rdi
  0494c	5e		 pop	 rsi
  0494d	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckdmap.c
_TEXT	SEGMENT
gc$ = 0
size$ = 8
fsiz$ = 16
dev_gc_state PROC

; 228  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 229  :     U64  size, fsiz;
; 230  :     int  gc;
; 231  : 
; 232  :     size = cdevhdr.cdh_size;

  00004	48 8b 05 10 00
	00 00		 mov	 rax, QWORD PTR cdevhdr+16
  0000b	48 89 44 24 08	 mov	 QWORD PTR size$[rsp], rax

; 233  :     fsiz = cdevhdr.free_total;

  00010	48 8b 05 28 00
	00 00		 mov	 rax, QWORD PTR cdevhdr+40
  00017	48 89 44 24 10	 mov	 QWORD PTR fsiz$[rsp], rax

; 234  : 
; 235  :     if      (fsiz >= (size = size/2)) gc = 0; // critical   50% - 100%

  0001c	33 d2		 xor	 edx, edx
  0001e	48 8b 44 24 08	 mov	 rax, QWORD PTR size$[rsp]
  00023	b9 02 00 00 00	 mov	 ecx, 2
  00028	48 f7 f1	 div	 rcx
  0002b	48 89 44 24 08	 mov	 QWORD PTR size$[rsp], rax
  00030	48 8b 44 24 08	 mov	 rax, QWORD PTR size$[rsp]
  00035	48 39 44 24 10	 cmp	 QWORD PTR fsiz$[rsp], rax
  0003a	72 0c		 jb	 SHORT $LN2@dev_gc_sta
  0003c	c7 04 24 00 00
	00 00		 mov	 DWORD PTR gc$[rsp], 0
  00043	e9 82 00 00 00	 jmp	 $LN3@dev_gc_sta
$LN2@dev_gc_sta:

; 236  :     else if (fsiz >= (size = size/2)) gc = 1; // severe     25% - 50%

  00048	33 d2		 xor	 edx, edx
  0004a	48 8b 44 24 08	 mov	 rax, QWORD PTR size$[rsp]
  0004f	b9 02 00 00 00	 mov	 ecx, 2
  00054	48 f7 f1	 div	 rcx
  00057	48 89 44 24 08	 mov	 QWORD PTR size$[rsp], rax
  0005c	48 8b 44 24 08	 mov	 rax, QWORD PTR size$[rsp]
  00061	48 39 44 24 10	 cmp	 QWORD PTR fsiz$[rsp], rax
  00066	72 09		 jb	 SHORT $LN4@dev_gc_sta
  00068	c7 04 24 01 00
	00 00		 mov	 DWORD PTR gc$[rsp], 1
  0006f	eb 59		 jmp	 SHORT $LN5@dev_gc_sta
$LN4@dev_gc_sta:

; 237  :     else if (fsiz >= (size = size/2)) gc = 2; // moderate 12.5% - 25%

  00071	33 d2		 xor	 edx, edx
  00073	48 8b 44 24 08	 mov	 rax, QWORD PTR size$[rsp]
  00078	b9 02 00 00 00	 mov	 ecx, 2
  0007d	48 f7 f1	 div	 rcx
  00080	48 89 44 24 08	 mov	 QWORD PTR size$[rsp], rax
  00085	48 8b 44 24 08	 mov	 rax, QWORD PTR size$[rsp]
  0008a	48 39 44 24 10	 cmp	 QWORD PTR fsiz$[rsp], rax
  0008f	72 09		 jb	 SHORT $LN6@dev_gc_sta
  00091	c7 04 24 02 00
	00 00		 mov	 DWORD PTR gc$[rsp], 2
  00098	eb 30		 jmp	 SHORT $LN7@dev_gc_sta
$LN6@dev_gc_sta:

; 238  :     else if (fsiz >= (size = size/2)) gc = 3; // light     6.3% - 12.5%

  0009a	33 d2		 xor	 edx, edx
  0009c	48 8b 44 24 08	 mov	 rax, QWORD PTR size$[rsp]
  000a1	b9 02 00 00 00	 mov	 ecx, 2
  000a6	48 f7 f1	 div	 rcx
  000a9	48 89 44 24 08	 mov	 QWORD PTR size$[rsp], rax
  000ae	48 8b 44 24 08	 mov	 rax, QWORD PTR size$[rsp]
  000b3	48 39 44 24 10	 cmp	 QWORD PTR fsiz$[rsp], rax
  000b8	72 09		 jb	 SHORT $LN8@dev_gc_sta
  000ba	c7 04 24 03 00
	00 00		 mov	 DWORD PTR gc$[rsp], 3
  000c1	eb 07		 jmp	 SHORT $LN9@dev_gc_sta
$LN8@dev_gc_sta:

; 239  :     else                              gc = 4; // none        0% - 6.3%

  000c3	c7 04 24 04 00
	00 00		 mov	 DWORD PTR gc$[rsp], 4
$LN9@dev_gc_sta:
$LN7@dev_gc_sta:
$LN5@dev_gc_sta:
$LN3@dev_gc_sta:

; 240  : 
; 241  :     // Adjust the state based on the number of free spaces
; 242  :     if (cdevhdr.free_num >  800 && gc > 0) gc--;

  000ca	48 81 3d 38 00
	00 00 20 03 00
	00		 cmp	 QWORD PTR cdevhdr+56, 800 ; 00000320H
  000d5	7e 0e		 jle	 SHORT $LN10@dev_gc_sta
  000d7	83 3c 24 00	 cmp	 DWORD PTR gc$[rsp], 0
  000db	7e 08		 jle	 SHORT $LN10@dev_gc_sta
  000dd	8b 04 24	 mov	 eax, DWORD PTR gc$[rsp]
  000e0	ff c8		 dec	 eax
  000e2	89 04 24	 mov	 DWORD PTR gc$[rsp], eax
$LN10@dev_gc_sta:

; 243  :     if (cdevhdr.free_num > 1800 && gc > 0) gc--;

  000e5	48 81 3d 38 00
	00 00 08 07 00
	00		 cmp	 QWORD PTR cdevhdr+56, 1800 ; 00000708H
  000f0	7e 0e		 jle	 SHORT $LN11@dev_gc_sta
  000f2	83 3c 24 00	 cmp	 DWORD PTR gc$[rsp], 0
  000f6	7e 08		 jle	 SHORT $LN11@dev_gc_sta
  000f8	8b 04 24	 mov	 eax, DWORD PTR gc$[rsp]
  000fb	ff c8		 dec	 eax
  000fd	89 04 24	 mov	 DWORD PTR gc$[rsp], eax
$LN11@dev_gc_sta:

; 244  :     if (cdevhdr.free_num > 3000)           gc = 0;

  00100	48 81 3d 38 00
	00 00 b8 0b 00
	00		 cmp	 QWORD PTR cdevhdr+56, 3000 ; 00000bb8H
  0010b	7e 07		 jle	 SHORT $LN12@dev_gc_sta
  0010d	c7 04 24 00 00
	00 00		 mov	 DWORD PTR gc$[rsp], 0
$LN12@dev_gc_sta:

; 245  : 
; 246  :     return gc;

  00114	8b 04 24	 mov	 eax, DWORD PTR gc$[rsp]

; 247  : }

  00117	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0011b	c3		 ret	 0
dev_gc_state ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckdmap.c
_TEXT	SEGMENT
s1$ = 0
s2$ = 8
a$ = 32
b$ = 40
sort_spacetab_by_file_offset PROC

; 205  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 206  :     const SPCTAB64 *s1 = a,

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  00013	48 89 04 24	 mov	 QWORD PTR s1$[rsp], rax

; 207  :                    *s2 = b;

  00017	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  0001c	48 89 44 24 08	 mov	 QWORD PTR s2$[rsp], rax

; 208  : 
; 209  :     if (s1->spc_off < s2->spc_off) return -1;

  00021	48 8b 04 24	 mov	 rax, QWORD PTR s1$[rsp]
  00025	48 8b 4c 24 08	 mov	 rcx, QWORD PTR s2$[rsp]
  0002a	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0002e	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  00032	73 0a		 jae	 SHORT $LN2@sort_space
  00034	b8 ff ff ff ff	 mov	 eax, -1
  00039	e9 ba 00 00 00	 jmp	 $LN1@sort_space
$LN2@sort_space:

; 210  :     if (s1->spc_off > s2->spc_off) return +1;

  0003e	48 8b 04 24	 mov	 rax, QWORD PTR s1$[rsp]
  00042	48 8b 4c 24 08	 mov	 rcx, QWORD PTR s2$[rsp]
  00047	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0004b	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  0004f	76 0a		 jbe	 SHORT $LN3@sort_space
  00051	b8 01 00 00 00	 mov	 eax, 1
  00056	e9 9d 00 00 00	 jmp	 $LN1@sort_space
$LN3@sort_space:

; 211  : 
; 212  :     if (s1->spc_siz < s2->spc_siz) return -1;

  0005b	48 8b 04 24	 mov	 rax, QWORD PTR s1$[rsp]
  0005f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR s2$[rsp]
  00064	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00068	48 39 48 20	 cmp	 QWORD PTR [rax+32], rcx
  0006c	73 0a		 jae	 SHORT $LN4@sort_space
  0006e	b8 ff ff ff ff	 mov	 eax, -1
  00073	e9 80 00 00 00	 jmp	 $LN1@sort_space
$LN4@sort_space:

; 213  :     if (s1->spc_siz > s2->spc_siz) return +1;

  00078	48 8b 04 24	 mov	 rax, QWORD PTR s1$[rsp]
  0007c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR s2$[rsp]
  00081	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00085	48 39 48 20	 cmp	 QWORD PTR [rax+32], rcx
  00089	76 07		 jbe	 SHORT $LN5@sort_space
  0008b	b8 01 00 00 00	 mov	 eax, 1
  00090	eb 66		 jmp	 SHORT $LN1@sort_space
$LN5@sort_space:

; 214  : 
; 215  :     if (s1->spc_typ < s2->spc_typ) return -1;

  00092	48 8b 04 24	 mov	 rax, QWORD PTR s1$[rsp]
  00096	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00099	48 8b 4c 24 08	 mov	 rcx, QWORD PTR s2$[rsp]
  0009e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000a1	3b c1		 cmp	 eax, ecx
  000a3	7d 07		 jge	 SHORT $LN6@sort_space
  000a5	b8 ff ff ff ff	 mov	 eax, -1
  000aa	eb 4c		 jmp	 SHORT $LN1@sort_space
$LN6@sort_space:

; 216  :     if (s1->spc_typ > s2->spc_typ) return +1;

  000ac	48 8b 04 24	 mov	 rax, QWORD PTR s1$[rsp]
  000b0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000b3	48 8b 4c 24 08	 mov	 rcx, QWORD PTR s2$[rsp]
  000b8	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000bb	3b c1		 cmp	 eax, ecx
  000bd	7e 07		 jle	 SHORT $LN7@sort_space
  000bf	b8 01 00 00 00	 mov	 eax, 1
  000c4	eb 32		 jmp	 SHORT $LN1@sort_space
$LN7@sort_space:

; 217  : 
; 218  :     if (s1->spc_val < s2->spc_val) return -1;

  000c6	48 8b 04 24	 mov	 rax, QWORD PTR s1$[rsp]
  000ca	48 8b 4c 24 08	 mov	 rcx, QWORD PTR s2$[rsp]
  000cf	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  000d2	39 48 04	 cmp	 DWORD PTR [rax+4], ecx
  000d5	7d 07		 jge	 SHORT $LN8@sort_space
  000d7	b8 ff ff ff ff	 mov	 eax, -1
  000dc	eb 1a		 jmp	 SHORT $LN1@sort_space
$LN8@sort_space:

; 219  :     if (s1->spc_val > s2->spc_val) return +1;

  000de	48 8b 04 24	 mov	 rax, QWORD PTR s1$[rsp]
  000e2	48 8b 4c 24 08	 mov	 rcx, QWORD PTR s2$[rsp]
  000e7	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  000ea	39 48 04	 cmp	 DWORD PTR [rax+4], ecx
  000ed	7e 07		 jle	 SHORT $LN9@sort_space
  000ef	b8 01 00 00 00	 mov	 eax, 1
  000f4	eb 02		 jmp	 SHORT $LN1@sort_space
$LN9@sort_space:

; 220  : 
; 221  :     return 0;

  000f6	33 c0		 xor	 eax, eax
$LN1@sort_space:

; 222  : }

  000f8	48 83 c4 18	 add	 rsp, 24
  000fc	c3		 ret	 0
sort_spacetab_by_file_offset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckdmap.c
_TEXT	SEGMENT
tv77 = 32
i$ = 64
del_spc_from_table PROC

; 196  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 197  :     memmove( &spacetab[ i ], &spacetab[ i+1 ], (numspace - (i+1)) * sizeof( SPCTAB64 ));

  00008	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0000c	ff c0		 inc	 eax
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR numspace
  00014	2b c8		 sub	 ecx, eax
  00016	8b c1		 mov	 eax, ecx
  00018	48 98		 cdqe
  0001a	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  0001e	8b 4c 24 40	 mov	 ecx, DWORD PTR i$[rsp]
  00022	ff c1		 inc	 ecx
  00024	48 63 c9	 movsxd	 rcx, ecx
  00027	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  0002b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR spacetab
  00032	48 03 d1	 add	 rdx, rcx
  00035	48 8b ca	 mov	 rcx, rdx
  00038	48 63 54 24 40	 movsxd	 rdx, DWORD PTR i$[rsp]
  0003d	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  00041	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR spacetab
  00048	4c 03 c2	 add	 r8, rdx
  0004b	49 8b d0	 mov	 rdx, r8
  0004e	48 89 54 24 20	 mov	 QWORD PTR tv77[rsp], rdx
  00053	4c 8b c0	 mov	 r8, rax
  00056	48 8b d1	 mov	 rdx, rcx
  00059	48 8b 44 24 20	 mov	 rax, QWORD PTR tv77[rsp]
  0005e	48 8b c8	 mov	 rcx, rax
  00061	e8 00 00 00 00	 call	 memmove

; 198  :     numspace--;

  00066	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numspace
  0006c	ff c8		 dec	 eax
  0006e	89 05 00 00 00
	00		 mov	 DWORD PTR numspace, eax

; 199  : }

  00074	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00078	c3		 ret	 0
del_spc_from_table ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckdmap.c
_TEXT	SEGMENT
tv82 = 32
tv84 = 40
spc$ = 80
add_spc_to_table PROC

; 185  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 186  :     spacetab = realloc( spacetab, (numspace + 1) * sizeof( SPCTAB64 ));

  0000b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numspace
  00011	ff c0		 inc	 eax
  00013	48 98		 cdqe
  00015	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  00019	48 8b d0	 mov	 rdx, rax
  0001c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  00029	48 89 05 00 00
	00 00		 mov	 QWORD PTR spacetab, rax

; 187  :     memcpy( &spacetab[ numspace++ ], spc, sizeof( SPCTAB64 ));

  00030	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR numspace
  00037	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  0003b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR spacetab
  00042	48 03 c8	 add	 rcx, rax
  00045	48 89 4c 24 20	 mov	 QWORD PTR tv82[rsp], rcx
  0004a	48 8b 44 24 20	 mov	 rax, QWORD PTR tv82[rsp]
  0004f	48 89 44 24 28	 mov	 QWORD PTR tv84[rsp], rax
  00054	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numspace
  0005a	ff c0		 inc	 eax
  0005c	89 05 00 00 00
	00		 mov	 DWORD PTR numspace, eax
  00062	48 8b 7c 24 28	 mov	 rdi, QWORD PTR tv84[rsp]
  00067	48 8b 74 24 50	 mov	 rsi, QWORD PTR spc$[rsp]
  0006c	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00071	f3 a4		 rep movsb

; 188  : }

  00073	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00077	5f		 pop	 rdi
  00078	5e		 pop	 rsi
  00079	c3		 ret	 0
add_spc_to_table ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckdmap.c
_TEXT	SEGMENT
running_on_big_endian_system$ = 32
tv80 = 36
tv82 = 40
cdevhdr64$ = 64
are_swaps_needed PROC

; 163  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 164  :     bool running_on_big_endian_system = are_big_endian();

  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_are_big_endian
  0000f	88 44 24 20	 mov	 BYTE PTR running_on_big_endian_system$[rsp], al

; 165  : 
; 166  :     return

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	75 4a		 jne	 SHORT $LN4@are_swaps_
  00019	33 c0		 xor	 eax, eax
  0001b	83 f8 01	 cmp	 eax, 1
  0001e	74 19		 je	 SHORT $LN3@are_swaps_
  00020	0f b6 44 24 20	 movzx	 eax, BYTE PTR running_on_big_endian_system$[rsp]
  00025	85 c0		 test	 eax, eax
  00027	74 10		 je	 SHORT $LN3@are_swaps_
  00029	48 8b 44 24 40	 mov	 rax, QWORD PTR cdevhdr64$[rsp]
  0002e	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00032	83 e0 02	 and	 eax, 2
  00035	85 c0		 test	 eax, eax
  00037	74 2a		 je	 SHORT $LN4@are_swaps_
$LN3@are_swaps_:
  00039	33 c0		 xor	 eax, eax
  0003b	83 f8 01	 cmp	 eax, 1
  0003e	74 19		 je	 SHORT $LN5@are_swaps_
  00040	0f b6 44 24 20	 movzx	 eax, BYTE PTR running_on_big_endian_system$[rsp]
  00045	85 c0		 test	 eax, eax
  00047	75 10		 jne	 SHORT $LN5@are_swaps_
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR cdevhdr64$[rsp]
  0004e	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00052	83 e0 02	 and	 eax, 2
  00055	85 c0		 test	 eax, eax
  00057	75 0a		 jne	 SHORT $LN4@are_swaps_
$LN5@are_swaps_:
  00059	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
  00061	eb 08		 jmp	 SHORT $LN6@are_swaps_
$LN4@are_swaps_:
  00063	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
$LN6@are_swaps_:
  0006b	83 7c 24 24 00	 cmp	 DWORD PTR tv80[rsp], 0
  00070	75 0a		 jne	 SHORT $LN7@are_swaps_
  00072	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
  0007a	eb 08		 jmp	 SHORT $LN8@are_swaps_
$LN7@are_swaps_:
  0007c	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
$LN8@are_swaps_:
  00084	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv82[rsp]

; 167  :     (0
; 168  :         || (1
; 169  :             && running_on_big_endian_system
; 170  :             && !(cdevhdr64->cdh_opts & CCKD_OPT_BIGEND)
; 171  :            )
; 172  :         || (1
; 173  :             && !running_on_big_endian_system
; 174  :             && (cdevhdr64->cdh_opts & CCKD_OPT_BIGEND)
; 175  :            )
; 176  :     );
; 177  : }

  00089	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008d	c3		 ret	 0
are_swaps_needed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckdmap.c
_TEXT	SEGMENT
i$1 = 0
L2tab_to_64 PROC

; 142  : {

  00000	48 83 ec 18	 sub	 rsp, 24

; 143  :     if (!cckd64)

  00004	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  0000b	85 c0		 test	 eax, eax
  0000d	0f 85 b8 00 00
	00		 jne	 $LN5@L2tab_to_6

; 144  :     {
; 145  :         int  i;
; 146  :         for (i=0; i < 256; ++i)

  00013	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$1[rsp], 0
  0001a	eb 08		 jmp	 SHORT $LN4@L2tab_to_6
$LN2@L2tab_to_6:
  0001c	8b 04 24	 mov	 eax, DWORD PTR i$1[rsp]
  0001f	ff c0		 inc	 eax
  00021	89 04 24	 mov	 DWORD PTR i$1[rsp], eax
$LN4@L2tab_to_6:
  00024	81 3c 24 00 01
	00 00		 cmp	 DWORD PTR i$1[rsp], 256	; 00000100H
  0002b	0f 8d 9a 00 00
	00		 jge	 $LN3@L2tab_to_6

; 147  :         {
; 148  :             if (L2tab32[i].L2_trkoff == CCKD_MAXSIZE)

  00031	48 63 04 24	 movsxd	 rax, DWORD PTR i$1[rsp]
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:L2tab32
  0003c	83 3c c1 ff	 cmp	 DWORD PTR [rcx+rax*8], -1 ; ffffffffH
  00040	75 19		 jne	 SHORT $LN6@L2tab_to_6

; 149  :                 L2tab[i].L2_trkoff = CCKD64_MAXSIZE;

  00042	48 63 04 24	 movsxd	 rax, DWORD PTR i$1[rsp]
  00046	48 6b c0 10	 imul	 rax, rax, 16
  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:L2tab
  00051	48 c7 04 01 ff
	ff ff ff	 mov	 QWORD PTR [rcx+rax], -1
  00059	eb 21		 jmp	 SHORT $LN7@L2tab_to_6
$LN6@L2tab_to_6:

; 150  :             else
; 151  :                 L2tab[i].L2_trkoff = L2tab32[i].L2_trkoff;

  0005b	48 63 04 24	 movsxd	 rax, DWORD PTR i$1[rsp]
  0005f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:L2tab32
  00066	48 63 14 24	 movsxd	 rdx, DWORD PTR i$1[rsp]
  0006a	48 6b d2 10	 imul	 rdx, rdx, 16
  0006e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:L2tab
  00075	8b 04 c1	 mov	 eax, DWORD PTR [rcx+rax*8]
  00078	49 89 04 10	 mov	 QWORD PTR [r8+rdx], rax
$LN7@L2tab_to_6:

; 152  : 
; 153  :             L2tab[i].L2_len  = L2tab32[i].L2_len;

  0007c	48 63 04 24	 movsxd	 rax, DWORD PTR i$1[rsp]
  00080	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:L2tab32
  00087	48 63 14 24	 movsxd	 rdx, DWORD PTR i$1[rsp]
  0008b	48 6b d2 10	 imul	 rdx, rdx, 16
  0008f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:L2tab
  00096	0f b7 44 c1 04	 movzx	 eax, WORD PTR [rcx+rax*8+4]
  0009b	66 41 89 44 10
	08		 mov	 WORD PTR [r8+rdx+8], ax

; 154  :             L2tab[i].L2_size = L2tab32[i].L2_size;

  000a1	48 63 04 24	 movsxd	 rax, DWORD PTR i$1[rsp]
  000a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:L2tab32
  000ac	48 63 14 24	 movsxd	 rdx, DWORD PTR i$1[rsp]
  000b0	48 6b d2 10	 imul	 rdx, rdx, 16
  000b4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:L2tab
  000bb	0f b7 44 c1 06	 movzx	 eax, WORD PTR [rcx+rax*8+6]
  000c0	66 41 89 44 10
	0a		 mov	 WORD PTR [r8+rdx+10], ax

; 155  :         }

  000c6	e9 51 ff ff ff	 jmp	 $LN2@L2tab_to_6
$LN3@L2tab_to_6:
$LN5@L2tab_to_6:

; 156  :     }
; 157  : }

  000cb	48 83 c4 18	 add	 rsp, 24
  000cf	c3		 ret	 0
L2tab_to_64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckdmap.c
_TEXT	SEGMENT
i$1 = 0
L32$2 = 8
L64$3 = 16
L1tab_to_64 PROC

; 125  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 126  :     if (!cckd64)

  00004	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  0000b	85 c0		 test	 eax, eax
  0000d	75 71		 jne	 SHORT $LN5@L1tab_to_6

; 127  :     {
; 128  :         CCKD_L1ENT*    L32  = L1tab32;      // input 32

  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR L1tab32
  00016	48 89 44 24 08	 mov	 QWORD PTR L32$2[rsp], rax

; 129  :         CCKD64_L1ENT*  L64  = L1tab;        // input 64

  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR L1tab
  00022	48 89 44 24 10	 mov	 QWORD PTR L64$3[rsp], rax

; 130  : 
; 131  :         S32  i;
; 132  :         for (i=0; i < num_L1tab; ++i)

  00027	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$1[rsp], 0
  0002e	eb 08		 jmp	 SHORT $LN4@L1tab_to_6
$LN2@L1tab_to_6:
  00030	8b 04 24	 mov	 eax, DWORD PTR i$1[rsp]
  00033	ff c0		 inc	 eax
  00035	89 04 24	 mov	 DWORD PTR i$1[rsp], eax
$LN4@L1tab_to_6:
  00038	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR num_L1tab
  0003e	39 04 24	 cmp	 DWORD PTR i$1[rsp], eax
  00041	7d 3d		 jge	 SHORT $LN3@L1tab_to_6

; 133  :         {
; 134  :             if (L32[i] == CCKD_MAXSIZE)

  00043	48 63 04 24	 movsxd	 rax, DWORD PTR i$1[rsp]
  00047	48 8b 4c 24 08	 mov	 rcx, QWORD PTR L32$2[rsp]
  0004c	83 3c 81 ff	 cmp	 DWORD PTR [rcx+rax*4], -1 ; ffffffffH
  00050	75 13		 jne	 SHORT $LN6@L1tab_to_6

; 135  :                 L64[i] = CCKD64_MAXSIZE;

  00052	48 63 04 24	 movsxd	 rax, DWORD PTR i$1[rsp]
  00056	48 8b 4c 24 10	 mov	 rcx, QWORD PTR L64$3[rsp]
  0005b	48 c7 04 c1 ff
	ff ff ff	 mov	 QWORD PTR [rcx+rax*8], -1
  00063	eb 19		 jmp	 SHORT $LN7@L1tab_to_6
$LN6@L1tab_to_6:

; 136  :             else
; 137  :                 L64[i] = L32[i];

  00065	48 63 04 24	 movsxd	 rax, DWORD PTR i$1[rsp]
  00069	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$1[rsp]
  0006d	48 8b 54 24 08	 mov	 rdx, QWORD PTR L32$2[rsp]
  00072	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00075	48 8b 54 24 10	 mov	 rdx, QWORD PTR L64$3[rsp]
  0007a	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax
$LN7@L1tab_to_6:

; 138  :         }

  0007e	eb b0		 jmp	 SHORT $LN2@L1tab_to_6
$LN3@L1tab_to_6:
$LN5@L1tab_to_6:

; 139  :     }
; 140  : }

  00080	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00084	c3		 ret	 0
L1tab_to_64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckdmap.c
_TEXT	SEGMENT
cdevhdr_to_64 PROC

; 100  : {

  00000	40 56		 push	 rsi
  00002	57		 push	 rdi

; 101  :     if (!cckd64)

  00003	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR cckd64
  0000a	85 c0		 test	 eax, eax
  0000c	0f 85 d0 00 00
	00		 jne	 $LN2@cdevhdr_to

; 102  :     {
; 103  :         memcpy( cdevhdr.cdh_vrm,  cdevhdr32.cdh_vrm,  sizeof( cdevhdr.cdh_vrm  ));

  00012	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:cdevhdr
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cdevhdr32
  00020	48 8b f8	 mov	 rdi, rax
  00023	48 8b f1	 mov	 rsi, rcx
  00026	b9 03 00 00 00	 mov	 ecx, 3
  0002b	f3 a4		 rep movsb

; 104  :         memcpy( cdevhdr.cdh_cyls, cdevhdr32.cdh_cyls, sizeof( cdevhdr.cdh_cyls ));

  0002d	8b 05 28 00 00
	00		 mov	 eax, DWORD PTR cdevhdr32+40
  00033	89 05 0c 00 00
	00		 mov	 DWORD PTR cdevhdr+12, eax

; 105  : 
; 106  :         cdevhdr.num_L1tab    = cdevhdr32.num_L1tab;

  00039	8b 05 04 00 00
	00		 mov	 eax, DWORD PTR cdevhdr32+4
  0003f	89 05 04 00 00
	00		 mov	 DWORD PTR cdevhdr+4, eax

; 107  :         cdevhdr.num_L2tab    = cdevhdr32.num_L2tab;

  00045	8b 05 08 00 00
	00		 mov	 eax, DWORD PTR cdevhdr32+8
  0004b	89 05 08 00 00
	00		 mov	 DWORD PTR cdevhdr+8, eax

; 108  : 
; 109  :         cdevhdr.cdh_opts     = cdevhdr32.cdh_opts;

  00051	0f b6 05 03 00
	00 00		 movzx	 eax, BYTE PTR cdevhdr32+3
  00058	88 05 03 00 00
	00		 mov	 BYTE PTR cdevhdr+3, al

; 110  :         cdevhdr.cdh_size     = cdevhdr32.cdh_size;

  0005e	8b 05 0c 00 00
	00		 mov	 eax, DWORD PTR cdevhdr32+12
  00064	48 89 05 10 00
	00 00		 mov	 QWORD PTR cdevhdr+16, rax

; 111  :         cdevhdr.cdh_used     = cdevhdr32.cdh_used;

  0006b	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cdevhdr32+16
  00071	48 89 05 18 00
	00 00		 mov	 QWORD PTR cdevhdr+24, rax

; 112  :         cdevhdr.cdh_nullfmt  = cdevhdr32.cdh_nullfmt;

  00078	0f b6 05 2c 00
	00 00		 movzx	 eax, BYTE PTR cdevhdr32+44
  0007f	88 05 48 00 00
	00		 mov	 BYTE PTR cdevhdr+72, al

; 113  : 
; 114  :         cdevhdr.free_off     = cdevhdr32.free_off;

  00085	8b 05 14 00 00
	00		 mov	 eax, DWORD PTR cdevhdr32+20
  0008b	48 89 05 20 00
	00 00		 mov	 QWORD PTR cdevhdr+32, rax

; 115  :         cdevhdr.free_total   = cdevhdr32.free_total;

  00092	8b 05 18 00 00
	00		 mov	 eax, DWORD PTR cdevhdr32+24
  00098	48 89 05 28 00
	00 00		 mov	 QWORD PTR cdevhdr+40, rax

; 116  :         cdevhdr.free_largest = cdevhdr32.free_largest;

  0009f	8b 05 1c 00 00
	00		 mov	 eax, DWORD PTR cdevhdr32+28
  000a5	48 89 05 30 00
	00 00		 mov	 QWORD PTR cdevhdr+48, rax

; 117  :         cdevhdr.free_num     = cdevhdr32.free_num;

  000ac	48 63 05 20 00
	00 00		 movsxd	 rax, DWORD PTR cdevhdr32+32
  000b3	48 89 05 38 00
	00 00		 mov	 QWORD PTR cdevhdr+56, rax

; 118  :         cdevhdr.free_imbed   = cdevhdr32.free_imbed;

  000ba	8b 05 24 00 00
	00		 mov	 eax, DWORD PTR cdevhdr32+36
  000c0	48 89 05 40 00
	00 00		 mov	 QWORD PTR cdevhdr+64, rax

; 119  : 
; 120  :         cdevhdr.cmp_algo     = cdevhdr32.cmp_algo;

  000c7	0f b6 05 2d 00
	00 00		 movzx	 eax, BYTE PTR cdevhdr32+45
  000ce	88 05 49 00 00
	00		 mov	 BYTE PTR cdevhdr+73, al

; 121  :         cdevhdr.cmp_parm     = cdevhdr32.cmp_parm;

  000d4	0f b7 05 2e 00
	00 00		 movzx	 eax, WORD PTR cdevhdr32+46
  000db	66 89 05 4a 00
	00 00		 mov	 WORD PTR cdevhdr+74, ax
$LN2@cdevhdr_to:

; 122  :     }
; 123  : }

  000e2	5f		 pop	 rdi
  000e3	5e		 pop	 rsi
  000e4	c3		 ret	 0
cdevhdr_to_64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckdmap.c
_TEXT	SEGMENT
syntax	PROC

; 79   : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 80   :     // Usage: %s [ -i | -t | -v ] infile
; 81   :     //   infile   Input file
; 82   :     // options:
; 83   :     //   -t       report consolidated track data
; 84   :     //   -v       verbose (report detailed track data)
; 85   :     WRMSG( HHC03000, "I", pgm );

  00004	b9 01 00 00 00	 mov	 ecx, 1
  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0000f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pgm
  00016	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168671
  00022	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168672
  0002e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00033	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00038	41 b9 03 00 00
	00		 mov	 r9d, 3
  0003e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168673
  00045	ba 55 00 00 00	 mov	 edx, 85			; 00000055H
  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168674
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 86   :     return -1;

  00057	b8 ff ff ff ff	 mov	 eax, -1

; 87   : }

  0005c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00060	c3		 ret	 0
syntax	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
END
